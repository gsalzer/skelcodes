{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped;\r\n\r\n    modifier stoppable {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract ERC20Events {\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n}\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address guy) public view returns (uint);\r\n    function allowance(address src, address guy) public view returns (uint);\r\n\r\n    function approve(address guy, uint wad) public returns (bool);\r\n    function transfer(address dst, uint wad) public returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint wad\r\n    ) public returns (bool);\r\n}\r\n\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    function DSTokenBase(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) public view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract DSToken is DSTokenBase(0), DSStop {\r\n\r\n    string  public  symbol = \"\";\r\n    string   public  name = \"\";\r\n    uint256  public  decimals = 18; // standard token precision. override to customize\r\n\r\n    function DSToken(\r\n        string symbol_,\r\n        string name_\r\n    ) public {\r\n        symbol = symbol_;\r\n        name = name_;\r\n    }\r\n\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n\r\n    function setName(string name_) public auth {\r\n        name = name_;\r\n    }\r\n\r\n    function approve(address guy) public stoppable returns (bool) {\r\n        return super.approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        return super.approve(guy, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function push(address dst, uint wad) public {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function pull(address src, uint wad) public {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) public {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    function mint(uint wad) public {\r\n        mint(msg.sender, wad);\r\n    }\r\n    function burn(uint wad) public {\r\n        burn(msg.sender, wad);\r\n    }\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        _balances[guy] = add(_balances[guy], wad);\r\n        _supply = add(_supply, wad);\r\n        emit Mint(guy, wad);\r\n    }\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\r\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\r\n        }\r\n\r\n        _balances[guy] = sub(_balances[guy], wad);\r\n        _supply = sub(_supply, wad);\r\n        emit Burn(guy, wad);\r\n    }\r\n}\r\n\r\n\r\n//==============================\r\n// 使用说明\r\n//1.发布DSToken合约\r\n//\r\n//2.发布TICDist代币操作合约\r\n//\r\n//3.钱包里面，DSToken绑定操作合约合约\r\n//\r\n//4.设置参数\r\n//\r\n// setDistConfig 创始人参数说明\r\n//[\"0xc94cd681477e6a70a4797a9Cbaa9F1E52366823c\",\"0xCc1696E57E2Cd0dCd61164eE884B4994EA3B916A\",\"0x9bD5DB3059186FA8eeAD8e4275a2DA50F0380528\"] //有3个创始人\r\n//[51,15,34] //各自分配比例51%，15%，34%\r\n// setLockedConfig 锁仓参数说明\r\n//[\"0xc94cd681477e6a70a4797a9Cbaa9F1E52366823c\"] //只有第一个创始人锁仓\r\n//[50]\t// 第一个人自己的份额，锁仓50%\r\n//[10]\t// 锁仓截至时间为，开始发行后的10天\r\n//\r\n//5.开始发行 startDist\r\n//==============================\r\n\r\n//===============================\r\n// TIC代币 操作合约\r\n//===============================\r\ncontract TICDist is DSAuth, DSMath {\r\n\r\n    DSToken  public  TIC;                   // TIC代币对象\r\n    uint256  public  initSupply = 0;        // 初始化发行供应量\r\n    uint256  public  decimals = 18;         // 代币精度，默认小数点后18位，不建议修改\r\n\r\n    // 发行相关\r\n    uint public distDay = 0;                // 发行 开始时间\r\n    bool public isDistConfig = false;       // 是否配置过发行标志\r\n    bool public isLockedConfig = false;     // 是否配置过锁仓标志\r\n    \r\n    bool public bTest = true;               // 锁仓的情况下，每天释放1%，做演示用\r\n    uint public testUnlockedDay = 0;        // 测试解锁的时间\r\n    \r\n    struct Detail {  \r\n        uint distPercent;   // 发行时，创始人的分配比例\r\n        uint lockedPercent; // 发行时，创始人的锁仓比例\r\n        uint lockedDay;     // 发行时，创始人的锁仓时间\r\n        uint256 lockedToken;   // 发行时，创始人的被锁仓代币\r\n    }\r\n\r\n    address[] public founderList;                 // 创始人列表\r\n    mapping (address => Detail)  public  founders;// 发行时，创始人的分配比例\r\n    \r\n    // 默认构造\r\n    function TICDist(uint256 initial_supply) public {\r\n        initSupply = initial_supply;\r\n    }\r\n\r\n    // 此操作合约，绑定代币接口, 注意，一开始代币创建，代币都在发行者账号里面\r\n    // @param  {DSToken} tic 代币对象\r\n    function setTIC(DSToken  tic) public auth {\r\n        // 判断之前没有绑定过\r\n        assert(address(TIC) == address(0));\r\n        // 本操作合约有代币所有权\r\n        assert(tic.owner() == address(this));\r\n        // 总发行量不能为0\r\n        assert(tic.totalSupply() == 0);\r\n        // 赋值\r\n        TIC = tic;\r\n        // 初始化代币总量，并把代币总量存到合约账号里面\r\n        initSupply = initSupply*10**uint256(decimals);\r\n        TIC.mint(initSupply);\r\n    }\r\n\r\n    // 设置发行参数\r\n    // @param  {address[]nt} founders_ 创始人列表\r\n    // @param  {uint[]} percents_ 创始人分配比例，总和必须小于100\r\n    function setDistConfig(address[] founders_, uint[] percents_) public auth {\r\n        // 判断是否配置过\r\n        assert(isDistConfig == false);\r\n        // 输入参数测试\r\n        assert(founders_.length > 0);\r\n        assert(founders_.length == percents_.length);\r\n        uint all_percents = 0;\r\n        uint i = 0;\r\n        for (i=0; i<percents_.length; ++i){\r\n            assert(percents_[i] > 0);\r\n            assert(founders_[i] != address(0));\r\n            all_percents += percents_[i];\r\n        }\r\n        assert(all_percents <= 100);\r\n        // 赋值\r\n        founderList = founders_;\r\n        for (i=0; i<founders_.length; ++i){\r\n            founders[founders_[i]].distPercent = percents_[i];\r\n        }\r\n        // 设置标志\r\n        isDistConfig = true;\r\n    }\r\n\r\n    // 设置发行锁仓参数\r\n    // @param  {address[]} founders_ 创始人列表，注意，不一定要所有创始人，只有锁仓需求的才要\r\n    // @param  {uint[]} percents_ 对应的锁仓比例\r\n    // @param  {uint[]} days_ 对应的锁仓时间，这个时间是相对distDay，发行后的时间\r\n    function setLockedConfig(address[] founders_, uint[] percents_, uint[] days_) public auth {\r\n        // 必须先设置发行参数\r\n        assert(isDistConfig == true);\r\n        // 判断是否配置过\r\n        assert(isLockedConfig == false);\r\n        // 判断是否有值\r\n        if (founders_.length > 0){\r\n            // 输入参数测试\r\n            assert(founders_.length == percents_.length);\r\n            assert(founders_.length == days_.length);\r\n            uint i = 0;\r\n            for (i=0; i<percents_.length; ++i){\r\n                assert(percents_[i] > 0);\r\n                assert(percents_[i] <= 100);\r\n                assert(days_[i] > 0);\r\n                assert(founders_[i] != address(0));\r\n            }\r\n            // 赋值\r\n            for (i=0; i<founders_.length; ++i){\r\n                founders[founders_[i]].lockedPercent = percents_[i];\r\n                founders[founders_[i]].lockedDay = days_[i];\r\n            }\r\n        }\r\n        // 设置标志\r\n        isLockedConfig = true;\r\n    }\r\n\r\n    // 开始发行\r\n    function startDist() public auth {\r\n        // 必须还没发行过\r\n        assert(distDay == 0);\r\n        // 判断必须配置过\r\n        assert(isDistConfig == true);\r\n        assert(isLockedConfig == true);\r\n        // 对每个创始人代币初始化\r\n        uint i = 0;\r\n        for(i=0; i<founderList.length; ++i){\r\n            // 获得创始人的份额\r\n            uint256 all_token_num = TIC.totalSupply()*founders[founderList[i]].distPercent/100;\r\n            assert(all_token_num > 0);\r\n            // 获得锁仓的份额\r\n            uint256 locked_token_num = all_token_num*founders[founderList[i]].lockedPercent/100;\r\n            // 记录锁仓的token\r\n            founders[founderList[i]].lockedToken = locked_token_num;\r\n            // 发放token给创始人\r\n            TIC.push(founderList[i], all_token_num - locked_token_num);\r\n        }\r\n        // 设置发行时间\r\n        distDay = today();\r\n        // 更新锁仓时间\r\n        for(i=0; i<founderList.length; ++i){\r\n            if (founders[founderList[i]].lockedDay != 0){\r\n                founders[founderList[i]].lockedDay += distDay;\r\n            }\r\n        }\r\n    }\r\n\r\n    // 确认锁仓时间是否到了，结束锁仓\r\n    function checkLockedToken() public {\r\n        // 必须发行过\r\n        assert(distDay != 0);\r\n        // 是否是测试\r\n        if (bTest){\r\n            // 判断今天解锁过了没有\r\n            assert(today() > testUnlockedDay);\r\n            // 每次固定解锁1%\r\n            uint unlock_percent = 1;\r\n            // 给锁仓的每个人，做解锁动作 TODO\r\n            uint i = 0;\r\n            for(i=0; i<founderList.length; ++i){\r\n                // 有锁仓需求的创始人 并且 有锁仓代币\r\n                if (founders[founderList[i]].lockedDay > 0 && founders[founderList[i]].lockedToken > 0){\r\n                    // 获得总的代币\r\n                    uint256 all_token_num = TIC.totalSupply()*founders[founderList[i]].distPercent/100;\r\n                    // 获得锁仓的份额\r\n                    uint256 locked_token_num = all_token_num*founders[founderList[i]].lockedPercent/100;\r\n                    // 每天释放的量\r\n                    uint256 unlock_token_num = locked_token_num*unlock_percent/founders[founderList[i]].lockedPercent;\r\n                    if (unlock_token_num > founders[founderList[i]].lockedToken){\r\n                        unlock_token_num = founders[founderList[i]].lockedToken;\r\n                    }\r\n                    // 开始解锁 token\r\n                    TIC.push(founderList[i], unlock_token_num);\r\n                    // 锁仓token数据减少\r\n                    founders[founderList[i]].lockedToken -= unlock_token_num;\r\n                }\r\n            }\r\n            // 刷新解锁时间\r\n            testUnlockedDay = today();            \r\n        } else {\r\n            // 有锁仓需求的创始人\r\n            assert(founders[msg.sender].lockedDay > 0);\r\n            // 有锁仓代币\r\n            assert(founders[msg.sender].lockedToken > 0);\r\n            // 判断是否解锁时间到\r\n            assert(today() > founders[msg.sender].lockedDay);\r\n            // 开始解锁 token\r\n            TIC.push(msg.sender, founders[msg.sender].lockedToken);\r\n            // 锁仓token数据清空\r\n            founders[msg.sender].lockedToken = 0;\r\n        }\r\n    }\r\n\r\n    // 获得当前时间 单位天\r\n    function today() public constant returns (uint) {\r\n        return time() / 24 hours;\r\n        // TODO test\r\n        //return time() / 1 minutes;\r\n    }\r\n   \r\n    // 获得区块链时间戳，单位秒\r\n    function time() public constant returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"TIC\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"testUnlockedDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tic\",\"type\":\"address\"}],\"name\":\"setTIC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startDist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"founders_\",\"type\":\"address[]\"},{\"name\":\"percents_\",\"type\":\"uint256[]\"},{\"name\":\"days_\",\"type\":\"uint256[]\"}],\"name\":\"setLockedConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkLockedToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDistConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"founders_\",\"type\":\"address[]\"},{\"name\":\"percents_\",\"type\":\"uint256[]\"}],\"name\":\"setDistConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"today\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"founderList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLockedConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"founders\",\"outputs\":[{\"name\":\"distPercent\",\"type\":\"uint256\"},{\"name\":\"lockedPercent\",\"type\":\"uint256\"},{\"name\":\"lockedDay\",\"type\":\"uint256\"},{\"name\":\"lockedToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bTest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initial_supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"TICDist","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000003b9aca00","Library":"","SwarmSource":"bzzr://cb3bb3fe1831fe5738ed3a10a34f01630a9765b0b435146d94d3a3b67e01c4c9"}]}