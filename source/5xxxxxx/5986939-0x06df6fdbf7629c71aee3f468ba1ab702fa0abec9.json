{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract BBODServiceRegistry is Ownable {\r\n\r\n  //1. Manager\r\n  //2. CustodyStorage\r\n  mapping(uint => address) public registry;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n    }\r\n\r\n  function setServiceRegistryEntry (uint key, address entry) external onlyOwner {\r\n    registry[key] = entry;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract ManagerInterface {\r\n  function createCustody(address) external {}\r\n\r\n  function isExchangeAlive() public pure returns (bool) {}\r\n\r\n  function isDailySettlementOnGoing() public pure returns (bool) {}\r\n}\r\n\r\ncontract Custody {\r\n\r\n  using SafeMath for uint;\r\n\r\n  BBODServiceRegistry public bbodServiceRegistry;\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor(address _serviceRegistryAddress, address _owner) public {\r\n    bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress);\r\n    owner = _owner;\r\n  }\r\n\r\n  function() public payable {}\r\n\r\n  modifier liveExchangeOrOwner(address _recipient) {\r\n    var manager = ManagerInterface(bbodServiceRegistry.registry(1));\r\n\r\n    if (manager.isExchangeAlive()) {\r\n\r\n      require(msg.sender == address(manager));\r\n\r\n      if (manager.isDailySettlementOnGoing()) {\r\n        require(_recipient == address(manager), \"Only manager can do this when the settlement is ongoing\");\r\n      } else {\r\n        require(_recipient == owner);\r\n      }\r\n\r\n    } else {\r\n      require(msg.sender == owner, \"Only owner can do this when exchange is dead\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  function withdraw(uint _amount, address _recipient) external liveExchangeOrOwner(_recipient) {\r\n    _recipient.transfer(_amount);\r\n  }\r\n\r\n  function transferToken(address _erc20Address, address _recipient, uint _amount)\r\n    external liveExchangeOrOwner(_recipient) {\r\n\r\n    ERC20 token = ERC20(_erc20Address);\r\n\r\n    token.transfer(_recipient, _amount);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public {\r\n    require(msg.sender == owner, \"Only the owner can transfer ownership\");\r\n    require(newOwner != address(0));\r\n\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\ncontract CustodyStorage {\r\n\r\n  BBODServiceRegistry public bbodServiceRegistry;\r\n\r\n  mapping(address => bool) public custodiesMap;\r\n\r\n  //Number of all custodies in the contract\r\n  uint public custodyCounter = 0;\r\n\r\n  address[] public custodiesArray;\r\n\r\n  event CustodyRemoved(address indexed custody);\r\n\r\n  constructor(address _serviceRegistryAddress) public {\r\n    bbodServiceRegistry = BBODServiceRegistry(_serviceRegistryAddress);\r\n  }\r\n\r\n  modifier onlyManager() {\r\n    require(msg.sender == bbodServiceRegistry.registry(1));\r\n    _;\r\n  }\r\n\r\n  function addCustody(address _custody) external onlyManager {\r\n    custodiesMap[_custody] = true;\r\n    custodiesArray.push(_custody);\r\n    custodyCounter++;\r\n  }\r\n\r\n  function removeCustody(address _custodyAddress, uint _arrayIndex) external onlyManager {\r\n    require(custodiesArray[_arrayIndex] == _custodyAddress);\r\n\r\n    if (_arrayIndex == custodyCounter - 1) {\r\n      //Removing last custody\r\n      custodiesMap[_custodyAddress] = false;\r\n      emit CustodyRemoved(_custodyAddress);\r\n      custodyCounter--;\r\n      return;\r\n    }\r\n\r\n    custodiesMap[_custodyAddress] = false;\r\n    //Overwriting deleted custody with the last custody in the array\r\n    custodiesArray[_arrayIndex] = custodiesArray[custodyCounter - 1];\r\n    custodyCounter--;\r\n\r\n    emit CustodyRemoved(_custodyAddress);\r\n  }\r\n}\r\ncontract Insurance is Custody {\r\n\r\n  constructor(address _serviceRegistryAddress, address _owner)\r\n  Custody(_serviceRegistryAddress, _owner) public {}\r\n\r\n  function useInsurance (uint _amount) external {\r\n    var manager = ManagerInterface(bbodServiceRegistry.registry(1));\r\n    //Only usable for manager during settlement\r\n    require(manager.isDailySettlementOnGoing() && msg.sender == address(manager));\r\n\r\n    address(manager).transfer(_amount);\r\n  }\r\n}\r\n\r\ncontract Manager is Pausable {\r\nusing SafeMath for uint;\r\n\r\nmapping(address => bool) public ownerAccountsMap;\r\nmapping(address => bool) public exchangeAccountsMap;\r\n\r\n//SETTLEMENT PREPARATION####\r\n\r\nenum SettlementPhase {\r\nPREPARING, ONGOING, FINISHED\r\n}\r\n\r\nenum Cryptocurrency {\r\nETH, BBD\r\n}\r\n\r\n//Initially ready for a settlement\r\nSettlementPhase public currentSettlementPhase = SettlementPhase.FINISHED;\r\n\r\nuint public startingFeeBalance = 0;\r\nuint public totalFeeFlows = 0;\r\nuint public startingInsuranceBalance = 0;\r\nuint public totalInsuranceFlows = 0;\r\n\r\nuint public lastSettlementStartedTimestamp = 0;\r\nuint public earliestNextSettlementTimestamp = 0;\r\n\r\nmapping(uint => mapping(address => bool)) public custodiesServedETH;\r\nmapping(uint => mapping(address => bool)) public custodiesServedBBD;\r\n\r\naddress public feeAccount;\r\naddress public insuranceAccount;\r\nERC20 public bbdToken;\r\nCustodyStorage public custodyStorage;\r\n\r\naddress public custodyFactory;\r\nuint public gweiBBDPriceInWei;\r\nuint public lastTimePriceSet;\r\nuint constant public gwei = 1000000000;\r\n\r\nuint public maxTimeIntervalHB = 1 weeks;\r\nuint public heartBeat = now;\r\n\r\nconstructor(address _feeAccount, address _insuranceAccount, address _bbdTokenAddress, address _custodyStorage,\r\naddress _serviceRegistryAddress) public {\r\n//Contract creator is the first owner\r\nownerAccountsMap[msg.sender] = true;\r\nfeeAccount = _feeAccount;\r\ninsuranceAccount = _insuranceAccount;\r\nbbdToken = ERC20(_bbdTokenAddress);\r\ncustodyStorage = CustodyStorage(_custodyStorage);\r\n}\r\n\r\nfunction() public payable {}\r\n\r\nfunction setCustodyFactory(address _custodyFactory) external onlyOwner {\r\ncustodyFactory = _custodyFactory;\r\n}\r\n\r\nfunction pause() public onlyExchangeOrOwner {\r\npaused = true;\r\n}\r\n\r\nfunction unpause() public onlyExchangeOrOwner {\r\npaused = false;\r\n}\r\n\r\nmodifier onlyAllowedInPhase(SettlementPhase _phase) {\r\nrequire(currentSettlementPhase == _phase, \"Not allowed in this phase\");\r\n_;\r\n}\r\n\r\nmodifier onlyOwner() {\r\nrequire(ownerAccountsMap[msg.sender] == true, \"Only an owner can perform this action\");\r\n_;\r\n}\r\n\r\nmodifier onlyExchange() {\r\nrequire(exchangeAccountsMap[msg.sender] == true, \"Only an exchange can perform this action\");\r\n_;\r\n}\r\n\r\nmodifier onlyExchangeOrOwner() {\r\nrequire(exchangeAccountsMap[msg.sender] == true ||\r\nownerAccountsMap[msg.sender] == true);\r\n_;\r\n}\r\n\r\nfunction isDailySettlementOnGoing() external view returns (bool) {\r\nreturn currentSettlementPhase != SettlementPhase.FINISHED;\r\n}\r\n\r\nfunction updateHeartBeat() external whenNotPaused onlyOwner {\r\nheartBeat = now;\r\n}\r\n\r\nfunction isExchangeAlive() external view returns (bool) {\r\nreturn now - heartBeat < maxTimeIntervalHB;\r\n}\r\n\r\nfunction addOwnerAccount(address _exchangeAccount) external onlyOwner {\r\nownerAccountsMap[_exchangeAccount] = true;\r\n}\r\n\r\nfunction addExchangeAccount(address _exchangeAccount) external onlyOwner whenNotPaused {\r\nexchangeAccountsMap[_exchangeAccount] = true;\r\n}\r\n\r\nfunction rmExchangeAccount(address _exchangeAccount) external onlyOwner whenNotPaused {\r\nexchangeAccountsMap[_exchangeAccount] = false;\r\n}\r\n\r\nfunction setBBDPrice(uint _priceInWei) external onlyExchangeOrOwner whenNotPaused\r\nonlyAllowedInPhase(SettlementPhase.FINISHED) {\r\nif(gweiBBDPriceInWei == 0) {\r\ngweiBBDPriceInWei = _priceInWei;\r\n} else {\r\n//Max 100% daily increase in price\r\nif(_priceInWei > gweiBBDPriceInWei) {\r\nrequire(_priceInWei - gweiBBDPriceInWei <= (gweiBBDPriceInWei / 2));\r\n//Max 50% daily decrease in price\r\n} else if(_priceInWei < gweiBBDPriceInWei) {\r\nrequire(gweiBBDPriceInWei - _priceInWei <= (gweiBBDPriceInWei / 2));\r\n}\r\ngweiBBDPriceInWei = _priceInWei;\r\n}\r\n//Price can only be set once per day\r\nrequire(now - lastTimePriceSet > 23 hours);\r\n\r\nlastTimePriceSet = now;\r\n}\r\n\r\nfunction createCustody(address _custody) external whenNotPaused onlyAllowedInPhase(SettlementPhase.FINISHED) {\r\nrequire(msg.sender == custodyFactory);\r\ncustodyStorage.addCustody(_custody);\r\n}\r\n\r\nfunction removeCustody(address _custodyAddress, uint _arrayIndex) external whenNotPaused onlyExchangeOrOwner\r\nonlyAllowedInPhase(SettlementPhase.FINISHED) {\r\ncustodyStorage.removeCustody(_custodyAddress, _arrayIndex);\r\n}\r\n\r\n/// @dev Exchange uses this function to withdraw ether from the contract\r\n/// @param _amount to withdraw\r\n/// @param _recipient to send withdrawn ether to\r\nfunction withdrawFromManager(uint _amount, address _recipient) external onlyExchangeOrOwner\r\nwhenNotPaused onlyAllowedInPhase(SettlementPhase.FINISHED) {\r\n_recipient.transfer(_amount);\r\n}\r\n\r\n/// @dev Users use this function to withdraw ether from their custody\r\n/// @param _amount to withdraw\r\n/// @param _custodyAddress to withdraw from\r\nfunction withdrawFromCustody(uint _amount, address _custodyAddress,address _recipient) external onlyExchangeOrOwner\r\nwhenNotPaused onlyAllowedInPhase(SettlementPhase.FINISHED) {\r\nCustody custody = Custody(_custodyAddress);\r\ncustody.withdraw(_amount, _recipient);\r\n}\r\n\r\n/// @dev Users use this function to withdraw ether from their custody\r\n/// @param _tokenAddress of the ERC20 to withdraw from\r\n/// @param _amount to withdraw\r\n/// @param _custodyAddress to withdraw from\r\nfunction withdrawTokensFromCustody(address _tokenAddress, uint _amount, address _custodyAddress, address _recipient)\r\nexternal whenNotPaused onlyAllowedInPhase(SettlementPhase.FINISHED) onlyExchangeOrOwner {\r\nCustody custody = Custody(_custodyAddress);\r\ncustody.transferToken(_tokenAddress, _recipient,_amount);\r\n}\r\n\r\n//DAILY SETTLEMENT\r\n\r\n/// @dev This function prepares the daily settlement - resets all settlement\r\n/// @dev scope storage variables to 0.\r\nfunction startSettlementPreparation() external whenNotPaused onlyExchangeOrOwner\r\nonlyAllowedInPhase(SettlementPhase.FINISHED) {\r\nrequire(now > earliestNextSettlementTimestamp, \"A settlement can happen once per day\");\r\nrequire(gweiBBDPriceInWei > 0, \"BBD Price cannot be 0 during settlement\");\r\n\r\nlastSettlementStartedTimestamp = now;\r\ntotalFeeFlows = 0;\r\ntotalInsuranceFlows = 0;\r\n\r\ncurrentSettlementPhase = SettlementPhase.ONGOING;\r\n\r\n\r\nstartingFeeBalance = feeAccount.balance +\r\n((bbdToken.balanceOf(feeAccount) * gweiBBDPriceInWei) / gwei);\r\n\r\nstartingInsuranceBalance = insuranceAccount.balance;\r\n}\r\n\r\n/// @dev This function is used to process a batch of net eth flows, two arrays\r\n/// @dev are pairs of custody addresses and the balance changes that should\r\n/// @dev be executed. Transaction will revert if exchange rules are violated.\r\n/// @param _custodies flow addresses\r\n/// @param _flows flow balance changes (can be negative or positive)\r\n/// @param _fee calculated and deducted from all batch flows\r\n/// @param _insurance to be used\r\nfunction settleETHBatch(address[] _custodies, int[] _flows, uint _fee, uint _insurance) external whenNotPaused onlyExchangeOrOwner\r\nonlyAllowedInPhase(SettlementPhase.ONGOING) {\r\n\r\nrequire(_custodies.length == _flows.length);\r\n\r\nuint preBatchBalance = address(this).balance;\r\n\r\nif(_insurance > 0) {\r\nInsurance(insuranceAccount).useInsurance(_insurance);\r\n}\r\n\r\nfor (uint flowIndex = 0; flowIndex < _flows.length; flowIndex++) {\r\n\r\n//Every custody can be served ETH once during settlement\r\nrequire(custodiesServedETH[lastSettlementStartedTimestamp][_custodies[flowIndex]] == false);\r\n\r\n//All addresses must be custodies\r\nrequire(custodyStorage.custodiesMap(_custodies[flowIndex]));\r\n\r\nif (_flows[flowIndex] > 0) {\r\n//10% rule\r\nvar outboundFlow = uint(_flows[flowIndex]);\r\n\r\n//100% rule exception threshold\r\nif(outboundFlow > 10 ether) {\r\n//100% rule\r\nrequire(getTotalBalanceFor(_custodies[flowIndex]) >= outboundFlow);\r\n}\r\n\r\n_custodies[flowIndex].transfer(uint(_flows[flowIndex]));\r\n\r\n} else if (_flows[flowIndex] < 0) {\r\nCustody custody = Custody(_custodies[flowIndex]);\r\n\r\ncustody.withdraw(uint(-_flows[flowIndex]), address(this));\r\n}\r\n\r\ncustodiesServedETH[lastSettlementStartedTimestamp][_custodies[flowIndex]] = true;\r\n}\r\n\r\nif(_fee > 0) {\r\nfeeAccount.transfer(_fee);\r\ntotalFeeFlows = totalFeeFlows + _fee;\r\n//100% rule for fee account\r\nrequire(totalFeeFlows <= startingFeeBalance);\r\n}\r\n\r\nuint postBatchBalance = address(this).balance;\r\n\r\n//Zero-sum guaranteed for ever batch\r\nif(address(this).balance > preBatchBalance) {\r\nuint leftovers = address(this).balance - preBatchBalance;\r\ninsuranceAccount.transfer(leftovers);\r\ntotalInsuranceFlows += leftovers;\r\n//100% rule for insurance account\r\nrequire(totalInsuranceFlows <= startingInsuranceBalance);\r\n}\r\n}\r\n\r\n/// @dev This function is used to process a batch of net bbd flows, two arrays\r\n/// @dev are pairs of custody addresses and the balance changes that should\r\n/// @dev be executed. Transaction will revert if exchange rules are violated.\r\n/// @param _custodies flow addresses\r\n/// @param _flows flow balance changes (can be negative or positive)\r\n/// @param _fee calculated and deducted from all batch flows\r\nfunction settleBBDBatch(address[] _custodies, int[] _flows, uint _fee) external whenNotPaused onlyExchangeOrOwner\r\nonlyAllowedInPhase(SettlementPhase.ONGOING) {\r\n//TODO optimize for gas usage\r\n\r\nrequire(_custodies.length == _flows.length);\r\n\r\nuint preBatchBalance = bbdToken.balanceOf(address(this));\r\n\r\nfor (uint flowIndex = 0; flowIndex < _flows.length; flowIndex++) {\r\n\r\n//Every custody can be served BBD once during settlement\r\nrequire(custodiesServedBBD[lastSettlementStartedTimestamp][_custodies[flowIndex]] == false);\r\n//All addresses must be custodies\r\nrequire(custodyStorage.custodiesMap(_custodies[flowIndex]));\r\n\r\nif (_flows[flowIndex] > 0) {\r\nvar flowValue = ((uint(_flows[flowIndex]) * gweiBBDPriceInWei)/gwei);\r\n\r\n//Minimal BBD transfer is 1gWeiBBD\r\nrequire(flowValue >= 1);\r\n\r\n//50% rule threshold\r\nif(flowValue > 10 ether) {\r\n//50% rule for bbd\r\nrequire((getTotalBalanceFor(_custodies[flowIndex]) / 2) >= flowValue);\r\n}\r\n\r\nbbdToken.transfer(_custodies[flowIndex], uint(_flows[flowIndex]));\r\n\r\n} else if (_flows[flowIndex] < 0) {\r\nCustody custody = Custody(_custodies[flowIndex]);\r\n\r\ncustody.transferToken(address(bbdToken),address(this), uint(-(_flows[flowIndex])));\r\n}\r\n\r\ncustodiesServedBBD[lastSettlementStartedTimestamp][_custodies[flowIndex]] = true;\r\n}\r\n\r\nif(_fee > 0) {\r\nbbdToken.transfer(feeAccount, _fee);\r\n//No need for safe math, as transfer will trow if _fee could cause overflow\r\ntotalFeeFlows += ((_fee * gweiBBDPriceInWei) / gwei);\r\nrequire (totalFeeFlows <= startingFeeBalance);\r\n}\r\n\r\nuint postBatchBalance = bbdToken.balanceOf(address(this));\r\n\r\n//Zero-or-less-sum guaranteed for every batch, no insurance for spots\r\nrequire(postBatchBalance <= preBatchBalance);\r\n}\r\n\r\n/// @dev This function is used to finish the settlement process\r\nfunction finishSettlement() external whenNotPaused onlyExchangeOrOwner\r\nonlyAllowedInPhase(SettlementPhase.ONGOING) {\r\n//TODO phase change event?\r\nearliestNextSettlementTimestamp = lastSettlementStartedTimestamp + 23 hours;\r\n\r\ncurrentSettlementPhase = SettlementPhase.FINISHED;\r\n}\r\n\r\nfunction getTotalBalanceFor(address _custody) internal view returns (uint) {\r\n\r\nvar bbdHoldingsInWei = ((bbdToken.balanceOf(_custody) * gweiBBDPriceInWei) / gwei);\r\n\r\nreturn _custody.balance + bbdHoldingsInWei;\r\n}\r\n\r\nfunction checkIfCustodiesServedETH(address[] _custodies) external view returns (bool) {\r\nfor (uint custodyIndex = 0; custodyIndex < _custodies.length; custodyIndex++) {\r\nif(custodiesServedETH[lastSettlementStartedTimestamp][_custodies[custodyIndex]]) {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\n\r\nfunction checkIfCustodiesServedBBD(address[] _custodies) external view returns (bool) {\r\nfor (uint custodyIndex = 0; custodyIndex < _custodies.length; custodyIndex++) {\r\nif(custodiesServedBBD[lastSettlementStartedTimestamp][_custodies[custodyIndex]]) {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeAccountsMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeAccount\",\"type\":\"address\"}],\"name\":\"addExchangeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_custodies\",\"type\":\"address[]\"},{\"name\":\"_flows\",\"type\":\"int256[]\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"settleBBDBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastSettlementStartedTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingFeeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"custodyStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateHeartBeat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"custodyFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSettlementPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earliestNextSettlementTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gwei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeAccount\",\"type\":\"address\"}],\"name\":\"rmExchangeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_custodies\",\"type\":\"address[]\"}],\"name\":\"checkIfCustodiesServedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_custodyAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawFromCustody\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeAccount\",\"type\":\"address\"}],\"name\":\"addOwnerAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"custodiesServedBBD\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bbdToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFeeFlows\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_custody\",\"type\":\"address\"}],\"name\":\"createCustody\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceInWei\",\"type\":\"uint256\"}],\"name\":\"setBBDPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_custodyFactory\",\"type\":\"address\"}],\"name\":\"setCustodyFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_custodies\",\"type\":\"address[]\"},{\"name\":\"_flows\",\"type\":\"int256[]\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_insurance\",\"type\":\"uint256\"}],\"name\":\"settleETHBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"custodiesServedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_custodyAddress\",\"type\":\"address\"},{\"name\":\"_arrayIndex\",\"type\":\"uint256\"}],\"name\":\"removeCustody\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingInsuranceBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isExchangeAlive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimePriceSet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawFromManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishSettlement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gweiBBDPriceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heartBeat\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInsuranceFlows\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTimeIntervalHB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"insuranceAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startSettlementPreparation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerAccountsMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_custodyAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdrawTokensFromCustody\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDailySettlementOnGoing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_custodies\",\"type\":\"address[]\"}],\"name\":\"checkIfCustodiesServedBBD\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_feeAccount\",\"type\":\"address\"},{\"name\":\"_insuranceAccount\",\"type\":\"address\"},{\"name\":\"_bbdTokenAddress\",\"type\":\"address\"},{\"name\":\"_custodyStorage\",\"type\":\"address\"},{\"name\":\"_serviceRegistryAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Manager","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e2d4b960d0c639633582cddef57528461e62083d0000000000000000000000001d6c596bb5022a4338b6b8651f3acd4d836ef574000000000000000000000000b79fc5505ea4f3b920ee7e3349de064226692717000000000000000000000000e68f070e656d60a9ff0771399e08282538d546250000000000000000000000009e55ca0690ac83dcb4d675873c0e344c848dbbf2","Library":"","SwarmSource":"bzzr://fb70c2390f780feb67934790eb2035c4648036182961a1333d7c9c56f725f5e0"}]}