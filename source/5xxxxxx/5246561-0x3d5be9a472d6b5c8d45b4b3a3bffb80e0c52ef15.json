{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// File: zeppelin/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: zeppelin/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin/contracts/ownership/HasNoEther.sol\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this ether.\r\n * @notice Ether can still be send to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n*/\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  function HasNoEther() payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    assert(owner.send(this.balance));\r\n  }\r\n}\r\n\r\n// File: contracts/presale/AxiePresale.sol\r\n\r\ncontract AxiePresale is HasNoEther, Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  // No Axies can be adopted after this end date: Friday, March 16, 2018 11:59:59 PM GMT.\r\n  uint256 constant public PRESALE_END_TIMESTAMP = 1521244799;\r\n\r\n  uint8 constant public CLASS_BEAST = 0;\r\n  uint8 constant public CLASS_AQUATIC = 2;\r\n  uint8 constant public CLASS_PLANT = 4;\r\n\r\n  uint256 constant public INITIAL_PRICE_INCREMENT = 1600 szabo; // 0.0016 Ether\r\n  uint256 constant public INITIAL_PRICE = INITIAL_PRICE_INCREMENT;\r\n  uint256 constant public REF_CREDITS_PER_AXIE = 5;\r\n\r\n  mapping (uint8 => uint256) public currentPrices;\r\n  mapping (uint8 => uint256) public priceIncrements;\r\n\r\n  mapping (uint8 => uint256) public totalAxiesAdopted;\r\n  mapping (address => mapping (uint8 => uint256)) public axiesAdopted;\r\n\r\n  mapping (address => uint256) public referralCredits;\r\n  mapping (address => uint256) public axiesRewarded;\r\n  uint256 public totalAxiesRewarded;\r\n\r\n  event AxiesAdopted(\r\n    address indexed adopter,\r\n    uint8 indexed clazz,\r\n    uint256 quantity,\r\n    address indexed referrer\r\n  );\r\n\r\n  event AxiesRewarded(address indexed receiver, uint256 quantity);\r\n\r\n  event AdoptedAxiesRedeemed(address indexed receiver, uint8 indexed clazz, uint256 quantity);\r\n  event RewardedAxiesRedeemed(address indexed receiver, uint256 quantity);\r\n\r\n  function AxiePresale() public {\r\n    priceIncrements[CLASS_BEAST] = priceIncrements[CLASS_AQUATIC] = //\r\n      priceIncrements[CLASS_PLANT] = INITIAL_PRICE_INCREMENT;\r\n\r\n    currentPrices[CLASS_BEAST] = currentPrices[CLASS_AQUATIC] = //\r\n      currentPrices[CLASS_PLANT] = INITIAL_PRICE;\r\n  }\r\n\r\n  function axiesPrice(\r\n    uint256 beastQuantity,\r\n    uint256 aquaticQuantity,\r\n    uint256 plantQuantity\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 totalPrice)\r\n  {\r\n    uint256 price;\r\n\r\n    (price,,) = _axiesPrice(CLASS_BEAST, beastQuantity);\r\n    totalPrice = totalPrice.add(price);\r\n\r\n    (price,,) = _axiesPrice(CLASS_AQUATIC, aquaticQuantity);\r\n    totalPrice = totalPrice.add(price);\r\n\r\n    (price,,) = _axiesPrice(CLASS_PLANT, plantQuantity);\r\n    totalPrice = totalPrice.add(price);\r\n  }\r\n\r\n  function adoptAxies(\r\n    uint256 beastQuantity,\r\n    uint256 aquaticQuantity,\r\n    uint256 plantQuantity,\r\n    address referrer\r\n  )\r\n    public\r\n    payable\r\n    whenNotPaused\r\n  {\r\n    require(now <= PRESALE_END_TIMESTAMP);\r\n\r\n    require(beastQuantity <= 3);\r\n    require(aquaticQuantity <= 3);\r\n    require(plantQuantity <= 3);\r\n\r\n    address adopter = msg.sender;\r\n    address actualReferrer = 0x0;\r\n\r\n    // An adopter cannot be his/her own referrer.\r\n    if (referrer != adopter) {\r\n      actualReferrer = referrer;\r\n    }\r\n\r\n    uint256 value = msg.value;\r\n    uint256 price;\r\n\r\n    if (beastQuantity > 0) {\r\n      price = _adoptAxies(\r\n        adopter,\r\n        CLASS_BEAST,\r\n        beastQuantity,\r\n        actualReferrer\r\n      );\r\n\r\n      require(value >= price);\r\n      value -= price;\r\n    }\r\n\r\n    if (aquaticQuantity > 0) {\r\n      price = _adoptAxies(\r\n        adopter,\r\n        CLASS_AQUATIC,\r\n        aquaticQuantity,\r\n        actualReferrer\r\n      );\r\n\r\n      require(value >= price);\r\n      value -= price;\r\n    }\r\n\r\n    if (plantQuantity > 0) {\r\n      price = _adoptAxies(\r\n        adopter,\r\n        CLASS_PLANT,\r\n        plantQuantity,\r\n        actualReferrer\r\n      );\r\n\r\n      require(value >= price);\r\n      value -= price;\r\n    }\r\n\r\n    msg.sender.transfer(value);\r\n\r\n    // The current referral is ignored if the referrer's address is 0x0.\r\n    if (actualReferrer != 0x0) {\r\n      uint256 numCredit = referralCredits[actualReferrer]\r\n        .add(beastQuantity)\r\n        .add(aquaticQuantity)\r\n        .add(plantQuantity);\r\n\r\n      uint256 numReward = numCredit / REF_CREDITS_PER_AXIE;\r\n\r\n      if (numReward > 0) {\r\n        referralCredits[actualReferrer] = numCredit % REF_CREDITS_PER_AXIE;\r\n        axiesRewarded[actualReferrer] = axiesRewarded[actualReferrer].add(numReward);\r\n        totalAxiesRewarded = totalAxiesRewarded.add(numReward);\r\n        AxiesRewarded(actualReferrer, numReward);\r\n      } else {\r\n        referralCredits[actualReferrer] = numCredit;\r\n      }\r\n    }\r\n  }\r\n\r\n  function redeemAdoptedAxies(\r\n    address receiver,\r\n    uint256 beastQuantity,\r\n    uint256 aquaticQuantity,\r\n    uint256 plantQuantity\r\n  )\r\n    public\r\n    onlyOwner\r\n    returns (\r\n      uint256 /* remainingBeastQuantity */,\r\n      uint256 /* remainingAquaticQuantity */,\r\n      uint256 /* remainingPlantQuantity */\r\n    )\r\n  {\r\n    return (\r\n      _redeemAdoptedAxies(receiver, CLASS_BEAST, beastQuantity),\r\n      _redeemAdoptedAxies(receiver, CLASS_AQUATIC, aquaticQuantity),\r\n      _redeemAdoptedAxies(receiver, CLASS_PLANT, plantQuantity)\r\n    );\r\n  }\r\n\r\n  function redeemRewardedAxies(\r\n    address receiver,\r\n    uint256 quantity\r\n  )\r\n    public\r\n    onlyOwner\r\n    returns (uint256 remainingQuantity)\r\n  {\r\n    remainingQuantity = axiesRewarded[receiver] = axiesRewarded[receiver].sub(quantity);\r\n\r\n    if (quantity > 0) {\r\n      // This requires that rewarded Axies are always included in the total\r\n      // to make sure overflow won't happen.\r\n      totalAxiesRewarded -= quantity;\r\n\r\n      RewardedAxiesRedeemed(receiver, quantity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate price of Axies from the same class.\r\n   * @param clazz The class of Axies.\r\n   * @param quantity Number of Axies to be calculated.\r\n   */\r\n  function _axiesPrice(\r\n    uint8 clazz,\r\n    uint256 quantity\r\n  )\r\n    private\r\n    view\r\n    returns (uint256 totalPrice, uint256 priceIncrement, uint256 currentPrice)\r\n  {\r\n    priceIncrement = priceIncrements[clazz];\r\n    currentPrice = currentPrices[clazz];\r\n\r\n    uint256 nextPrice;\r\n\r\n    for (uint256 i = 0; i < quantity; i++) {\r\n      totalPrice = totalPrice.add(currentPrice);\r\n      nextPrice = currentPrice.add(priceIncrement);\r\n\r\n      if (nextPrice / 100 finney != currentPrice / 100 finney) {\r\n        priceIncrement >>= 1;\r\n      }\r\n\r\n      currentPrice = nextPrice;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Adopt some Axies from the same class.\r\n   * @param adopter Address of the adopter.\r\n   * @param clazz The class of adopted Axies.\r\n   * @param quantity Number of Axies to be adopted, this should be positive.\r\n   * @param referrer Address of the referrer.\r\n   */\r\n  function _adoptAxies(\r\n    address adopter,\r\n    uint8 clazz,\r\n    uint256 quantity,\r\n    address referrer\r\n  )\r\n    private\r\n    returns (uint256 totalPrice)\r\n  {\r\n    (totalPrice, priceIncrements[clazz], currentPrices[clazz]) = _axiesPrice(clazz, quantity);\r\n\r\n    axiesAdopted[adopter][clazz] = axiesAdopted[adopter][clazz].add(quantity);\r\n    totalAxiesAdopted[clazz] = totalAxiesAdopted[clazz].add(quantity);\r\n\r\n    AxiesAdopted(\r\n      adopter,\r\n      clazz,\r\n      quantity,\r\n      referrer\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Redeem adopted Axies from the same class.\r\n   * @param receiver Address of the receiver.\r\n   * @param clazz The class of adopted Axies.\r\n   * @param quantity Number of adopted Axies to be redeemed.\r\n   */\r\n  function _redeemAdoptedAxies(\r\n    address receiver,\r\n    uint8 clazz,\r\n    uint256 quantity\r\n  )\r\n    private\r\n    returns (uint256 remainingQuantity)\r\n  {\r\n    remainingQuantity = axiesAdopted[receiver][clazz] = axiesAdopted[receiver][clazz].sub(quantity);\r\n\r\n    if (quantity > 0) {\r\n      // This requires that adopted Axies are always included in the total\r\n      // to make sure overflow won't happen.\r\n      totalAxiesAdopted[clazz] -= quantity;\r\n\r\n      AdoptedAxiesRedeemed(receiver, clazz, quantity);\r\n    }\r\n  }\r\n}\r\n\r\n// File: zeppelin/contracts/ownership/HasNoContracts.sol\r\n\r\n/**\r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n// File: contracts/presale/AxiePresaleExtended.sol\r\n\r\ncontract AxiePresaleExtended is HasNoContracts, Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  // No Axies can be adopted after this end date: Monday, April 16, 2018 11:59:59 PM GMT.\r\n  uint256 constant public PRESALE_END_TIMESTAMP = 1523923199;\r\n\r\n  // The total number of adopted Axies will be capped at 5250,\r\n  // so the number of Axies which have Mystic parts will be capped roughly at 2000.\r\n  uint256 constant public MAX_TOTAL_ADOPTED_AXIES = 5250;\r\n\r\n  uint8 constant public CLASS_BEAST = 0;\r\n  uint8 constant public CLASS_AQUATIC = 2;\r\n  uint8 constant public CLASS_PLANT = 4;\r\n\r\n  // The initial price increment and the initial price are for reference only\r\n  uint256 constant public INITIAL_PRICE_INCREMENT = 1600 szabo; // 0.0016 Ether\r\n  uint256 constant public INITIAL_PRICE = INITIAL_PRICE_INCREMENT;\r\n\r\n  uint256 constant public REF_CREDITS_PER_AXIE = 5;\r\n\r\n  AxiePresale public presaleContract;\r\n  address public redemptionAddress;\r\n\r\n  mapping (uint8 => uint256) public currentPrice;\r\n  mapping (uint8 => uint256) public priceIncrement;\r\n\r\n  mapping (uint8 => uint256) private _totalAdoptedAxies;\r\n  mapping (uint8 => uint256) private _totalDeductedAdoptedAxies;\r\n  mapping (address => mapping (uint8 => uint256)) private _numAdoptedAxies;\r\n  mapping (address => mapping (uint8 => uint256)) private _numDeductedAdoptedAxies;\r\n\r\n  mapping (address => uint256) private _numRefCredits;\r\n  mapping (address => uint256) private _numDeductedRefCredits;\r\n  uint256 public numBountyCredits;\r\n\r\n  uint256 private _totalRewardedAxies;\r\n  uint256 private _totalDeductedRewardedAxies;\r\n  mapping (address => uint256) private _numRewardedAxies;\r\n  mapping (address => uint256) private _numDeductedRewardedAxies;\r\n\r\n  event AxiesAdopted(\r\n    address indexed _adopter,\r\n    uint8 indexed _class,\r\n    uint256 _quantity,\r\n    address indexed _referrer\r\n  );\r\n\r\n  event AxiesRewarded(address indexed _receiver, uint256 _quantity);\r\n\r\n  event AdoptedAxiesRedeemed(address indexed _receiver, uint8 indexed _class, uint256 _quantity);\r\n  event RewardedAxiesRedeemed(address indexed _receiver, uint256 _quantity);\r\n\r\n  event RefCreditsMinted(address indexed _receiver, uint256 _numMintedCredits);\r\n\r\n  function AxiePresaleExtended() public payable {\r\n    require(msg.value == 0);\r\n    paused = true;\r\n    numBountyCredits = 300;\r\n  }\r\n\r\n  function () external payable {\r\n    require(msg.sender == address(presaleContract));\r\n  }\r\n\r\n  modifier whenNotInitialized {\r\n    require(presaleContract == address(0));\r\n    _;\r\n  }\r\n\r\n  modifier whenInitialized {\r\n    require(presaleContract != address(0));\r\n    _;\r\n  }\r\n\r\n  modifier onlyRedemptionAddress {\r\n    require(msg.sender == redemptionAddress);\r\n    _;\r\n  }\r\n\r\n  function reclaimEther() external onlyOwner whenInitialized {\r\n    presaleContract.reclaimEther();\r\n    owner.transfer(this.balance);\r\n  }\r\n\r\n  /**\r\n   * @dev This must be called only once after the owner of the presale contract\r\n   *  has been updated to this contract.\r\n   */\r\n  function initialize(address _presaleAddress) external onlyOwner whenNotInitialized {\r\n    // Set the presale address.\r\n    presaleContract = AxiePresale(_presaleAddress);\r\n\r\n    presaleContract.pause();\r\n\r\n    // Restore price increments from the old contract.\r\n    priceIncrement[CLASS_BEAST] = presaleContract.priceIncrements(CLASS_BEAST);\r\n    priceIncrement[CLASS_AQUATIC] = presaleContract.priceIncrements(CLASS_AQUATIC);\r\n    priceIncrement[CLASS_PLANT] = presaleContract.priceIncrements(CLASS_PLANT);\r\n\r\n    // Restore current prices from the old contract.\r\n    currentPrice[CLASS_BEAST] = presaleContract.currentPrices(CLASS_BEAST);\r\n    currentPrice[CLASS_AQUATIC] = presaleContract.currentPrices(CLASS_AQUATIC);\r\n    currentPrice[CLASS_PLANT] = presaleContract.currentPrices(CLASS_PLANT);\r\n\r\n    paused = false;\r\n  }\r\n\r\n  function setRedemptionAddress(address _redemptionAddress) external onlyOwner whenInitialized {\r\n    redemptionAddress = _redemptionAddress;\r\n  }\r\n\r\n  function totalAdoptedAxies(\r\n    uint8 _class,\r\n    bool _deduction\r\n  )\r\n    external\r\n    view\r\n    whenInitialized\r\n    returns (uint256 _number)\r\n  {\r\n    _number = _totalAdoptedAxies[_class]\r\n      .add(presaleContract.totalAxiesAdopted(_class));\r\n\r\n    if (_deduction) {\r\n      _number = _number.sub(_totalDeductedAdoptedAxies[_class]);\r\n    }\r\n  }\r\n\r\n  function numAdoptedAxies(\r\n    address _owner,\r\n    uint8 _class,\r\n    bool _deduction\r\n  )\r\n    external\r\n    view\r\n    whenInitialized\r\n    returns (uint256 _number)\r\n  {\r\n    _number = _numAdoptedAxies[_owner][_class]\r\n      .add(presaleContract.axiesAdopted(_owner, _class));\r\n\r\n    if (_deduction) {\r\n      _number = _number.sub(_numDeductedAdoptedAxies[_owner][_class]);\r\n    }\r\n  }\r\n\r\n  function numRefCredits(\r\n    address _owner,\r\n    bool _deduction\r\n  )\r\n    external\r\n    view\r\n    whenInitialized\r\n    returns (uint256 _number)\r\n  {\r\n    _number = _numRefCredits[_owner]\r\n      .add(presaleContract.referralCredits(_owner));\r\n\r\n    if (_deduction) {\r\n      _number = _number.sub(_numDeductedRefCredits[_owner]);\r\n    }\r\n  }\r\n\r\n  function totalRewardedAxies(\r\n    bool _deduction\r\n  )\r\n    external\r\n    view\r\n    whenInitialized\r\n    returns (uint256 _number)\r\n  {\r\n    _number = _totalRewardedAxies\r\n      .add(presaleContract.totalAxiesRewarded());\r\n\r\n    if (_deduction) {\r\n      _number = _number.sub(_totalDeductedRewardedAxies);\r\n    }\r\n  }\r\n\r\n  function numRewardedAxies(\r\n    address _owner,\r\n    bool _deduction\r\n  )\r\n    external\r\n    view\r\n    whenInitialized\r\n    returns (uint256 _number)\r\n  {\r\n    _number = _numRewardedAxies[_owner]\r\n      .add(presaleContract.axiesRewarded(_owner));\r\n\r\n    if (_deduction) {\r\n      _number = _number.sub(_numDeductedRewardedAxies[_owner]);\r\n    }\r\n  }\r\n\r\n  function axiesPrice(\r\n    uint256 _beastQuantity,\r\n    uint256 _aquaticQuantity,\r\n    uint256 _plantQuantity\r\n  )\r\n    external\r\n    view\r\n    whenInitialized\r\n    returns (uint256 _totalPrice)\r\n  {\r\n    uint256 price;\r\n\r\n    (price,,) = _sameClassAxiesPrice(CLASS_BEAST, _beastQuantity);\r\n    _totalPrice = _totalPrice.add(price);\r\n\r\n    (price,,) = _sameClassAxiesPrice(CLASS_AQUATIC, _aquaticQuantity);\r\n    _totalPrice = _totalPrice.add(price);\r\n\r\n    (price,,) = _sameClassAxiesPrice(CLASS_PLANT, _plantQuantity);\r\n    _totalPrice = _totalPrice.add(price);\r\n  }\r\n\r\n  function adoptAxies(\r\n    uint256 _beastQuantity,\r\n    uint256 _aquaticQuantity,\r\n    uint256 _plantQuantity,\r\n    address _referrer\r\n  )\r\n    external\r\n    payable\r\n    whenInitialized\r\n    whenNotPaused\r\n  {\r\n    require(now <= PRESALE_END_TIMESTAMP);\r\n    require(_beastQuantity <= 3 && _aquaticQuantity <= 3 && _plantQuantity <= 3);\r\n\r\n    uint256 _totalAdopted = this.totalAdoptedAxies(CLASS_BEAST, false)\r\n      .add(this.totalAdoptedAxies(CLASS_AQUATIC, false))\r\n      .add(this.totalAdoptedAxies(CLASS_PLANT, false))\r\n      .add(_beastQuantity)\r\n      .add(_aquaticQuantity)\r\n      .add(_plantQuantity);\r\n\r\n    require(_totalAdopted <= MAX_TOTAL_ADOPTED_AXIES);\r\n\r\n    address _adopter = msg.sender;\r\n    address _actualReferrer = 0x0;\r\n\r\n    // An adopter cannot be his/her own referrer.\r\n    if (_referrer != _adopter) {\r\n      _actualReferrer = _referrer;\r\n    }\r\n\r\n    uint256 _value = msg.value;\r\n    uint256 _price;\r\n\r\n    if (_beastQuantity > 0) {\r\n      _price = _adoptSameClassAxies(\r\n        _adopter,\r\n        CLASS_BEAST,\r\n        _beastQuantity,\r\n        _actualReferrer\r\n      );\r\n\r\n      require(_value >= _price);\r\n      _value -= _price;\r\n    }\r\n\r\n    if (_aquaticQuantity > 0) {\r\n      _price = _adoptSameClassAxies(\r\n        _adopter,\r\n        CLASS_AQUATIC,\r\n        _aquaticQuantity,\r\n        _actualReferrer\r\n      );\r\n\r\n      require(_value >= _price);\r\n      _value -= _price;\r\n    }\r\n\r\n    if (_plantQuantity > 0) {\r\n      _price = _adoptSameClassAxies(\r\n        _adopter,\r\n        CLASS_PLANT,\r\n        _plantQuantity,\r\n        _actualReferrer\r\n      );\r\n\r\n      require(_value >= _price);\r\n      _value -= _price;\r\n    }\r\n\r\n    msg.sender.transfer(_value);\r\n\r\n    // The current referral is ignored if the referrer's address is 0x0.\r\n    if (_actualReferrer != 0x0) {\r\n      _applyRefCredits(\r\n        _actualReferrer,\r\n        _beastQuantity.add(_aquaticQuantity).add(_plantQuantity)\r\n      );\r\n    }\r\n  }\r\n\r\n  function mintRefCredits(\r\n    address _receiver,\r\n    uint256 _numMintedCredits\r\n  )\r\n    external\r\n    onlyOwner\r\n    whenInitialized\r\n    returns (uint256)\r\n  {\r\n    require(_receiver != address(0));\r\n    numBountyCredits = numBountyCredits.sub(_numMintedCredits);\r\n    _applyRefCredits(_receiver, _numMintedCredits);\r\n    RefCreditsMinted(_receiver, _numMintedCredits);\r\n    return numBountyCredits;\r\n  }\r\n\r\n  function redeemAdoptedAxies(\r\n    address _receiver,\r\n    uint256 _beastQuantity,\r\n    uint256 _aquaticQuantity,\r\n    uint256 _plantQuantity\r\n  )\r\n    external\r\n    onlyRedemptionAddress\r\n    whenInitialized\r\n    returns (\r\n      uint256 /* remainingBeastQuantity */,\r\n      uint256 /* remainingAquaticQuantity */,\r\n      uint256 /* remainingPlantQuantity */\r\n    )\r\n  {\r\n    return (\r\n      _redeemSameClassAdoptedAxies(_receiver, CLASS_BEAST, _beastQuantity),\r\n      _redeemSameClassAdoptedAxies(_receiver, CLASS_AQUATIC, _aquaticQuantity),\r\n      _redeemSameClassAdoptedAxies(_receiver, CLASS_PLANT, _plantQuantity)\r\n    );\r\n  }\r\n\r\n  function redeemRewardedAxies(\r\n    address _receiver,\r\n    uint256 _quantity\r\n  )\r\n    external\r\n    onlyRedemptionAddress\r\n    whenInitialized\r\n    returns (uint256 _remainingQuantity)\r\n  {\r\n    _remainingQuantity = this.numRewardedAxies(_receiver, true).sub(_quantity);\r\n\r\n    if (_quantity > 0) {\r\n      _numDeductedRewardedAxies[_receiver] = _numDeductedRewardedAxies[_receiver].add(_quantity);\r\n      _totalDeductedRewardedAxies = _totalDeductedRewardedAxies.add(_quantity);\r\n\r\n      RewardedAxiesRedeemed(_receiver, _quantity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Calculate price of Axies from the same class.\r\n   * @param _class The class of Axies.\r\n   * @param _quantity Number of Axies to be calculated.\r\n   */\r\n  function _sameClassAxiesPrice(\r\n    uint8 _class,\r\n    uint256 _quantity\r\n  )\r\n    private\r\n    view\r\n    returns (\r\n      uint256 _totalPrice,\r\n      uint256 /* should be _subsequentIncrement */ _currentIncrement,\r\n      uint256 /* should be _subsequentPrice */ _currentPrice\r\n    )\r\n  {\r\n    _currentIncrement = priceIncrement[_class];\r\n    _currentPrice = currentPrice[_class];\r\n\r\n    uint256 _nextPrice;\r\n\r\n    for (uint256 i = 0; i < _quantity; i++) {\r\n      _totalPrice = _totalPrice.add(_currentPrice);\r\n      _nextPrice = _currentPrice.add(_currentIncrement);\r\n\r\n      if (_nextPrice / 100 finney != _currentPrice / 100 finney) {\r\n        _currentIncrement >>= 1;\r\n      }\r\n\r\n      _currentPrice = _nextPrice;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Adopt some Axies from the same class.\r\n   * @dev The quantity MUST be positive.\r\n   * @param _adopter Address of the adopter.\r\n   * @param _class The class of adopted Axies.\r\n   * @param _quantity Number of Axies to be adopted.\r\n   * @param _referrer Address of the referrer.\r\n   */\r\n  function _adoptSameClassAxies(\r\n    address _adopter,\r\n    uint8 _class,\r\n    uint256 _quantity,\r\n    address _referrer\r\n  )\r\n    private\r\n    returns (uint256 _totalPrice)\r\n  {\r\n    (_totalPrice, priceIncrement[_class], currentPrice[_class]) = _sameClassAxiesPrice(_class, _quantity);\r\n\r\n    _numAdoptedAxies[_adopter][_class] = _numAdoptedAxies[_adopter][_class].add(_quantity);\r\n    _totalAdoptedAxies[_class] = _totalAdoptedAxies[_class].add(_quantity);\r\n\r\n    AxiesAdopted(\r\n      _adopter,\r\n      _class,\r\n      _quantity,\r\n      _referrer\r\n    );\r\n  }\r\n\r\n  function _applyRefCredits(address _receiver, uint256 _numAppliedCredits) private {\r\n    _numRefCredits[_receiver] = _numRefCredits[_receiver].add(_numAppliedCredits);\r\n\r\n    uint256 _numCredits = this.numRefCredits(_receiver, true);\r\n    uint256 _numRewards = _numCredits / REF_CREDITS_PER_AXIE;\r\n\r\n    if (_numRewards > 0) {\r\n      _numDeductedRefCredits[_receiver] = _numDeductedRefCredits[_receiver]\r\n        .add(_numRewards.mul(REF_CREDITS_PER_AXIE));\r\n\r\n      _numRewardedAxies[_receiver] = _numRewardedAxies[_receiver].add(_numRewards);\r\n      _totalRewardedAxies = _totalRewardedAxies.add(_numRewards);\r\n\r\n      AxiesRewarded(_receiver, _numRewards);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Redeem adopted Axies from the same class.\r\n   * @dev Emit the `AdoptedAxiesRedeemed` event if the quantity is positive.\r\n   * @param _receiver The address of the receiver.\r\n   * @param _class The class of adopted Axies.\r\n   * @param _quantity The number of adopted Axies to be redeemed.\r\n   */\r\n  function _redeemSameClassAdoptedAxies(\r\n    address _receiver,\r\n    uint8 _class,\r\n    uint256 _quantity\r\n  )\r\n    private\r\n    returns (uint256 _remainingQuantity)\r\n  {\r\n    _remainingQuantity = this.numAdoptedAxies(_receiver, _class, true).sub(_quantity);\r\n\r\n    if (_quantity > 0) {\r\n      _numDeductedAdoptedAxies[_receiver][_class] = _numDeductedAdoptedAxies[_receiver][_class].add(_quantity);\r\n      _totalDeductedAdoptedAxies[_class] = _totalDeductedAdoptedAxies[_class].add(_quantity);\r\n\r\n      AdoptedAxiesRedeemed(_receiver, _class, _quantity);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_beastQuantity\",\"type\":\"uint256\"},{\"name\":\"_aquaticQuantity\",\"type\":\"uint256\"},{\"name\":\"_plantQuantity\",\"type\":\"uint256\"},{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"adoptAxies\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_class\",\"type\":\"uint8\"},{\"name\":\"_deduction\",\"type\":\"bool\"}],\"name\":\"totalAdoptedAxies\",\"outputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"priceIncrement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_PRICE_INCREMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_numMintedCredits\",\"type\":\"uint256\"}],\"name\":\"mintRefCredits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLASS_BEAST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"redemptionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBountyCredits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_deduction\",\"type\":\"bool\"}],\"name\":\"numRewardedAxies\",\"outputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLASS_PLANT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beastQuantity\",\"type\":\"uint256\"},{\"name\":\"_aquaticQuantity\",\"type\":\"uint256\"},{\"name\":\"_plantQuantity\",\"type\":\"uint256\"}],\"name\":\"axiesPrice\",\"outputs\":[{\"name\":\"_totalPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_END_TIMESTAMP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REF_CREDITS_PER_AXIE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOTAL_ADOPTED_AXIES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_beastQuantity\",\"type\":\"uint256\"},{\"name\":\"_aquaticQuantity\",\"type\":\"uint256\"},{\"name\":\"_plantQuantity\",\"type\":\"uint256\"}],\"name\":\"redeemAdoptedAxies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLASS_AQUATIC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_class\",\"type\":\"uint8\"},{\"name\":\"_deduction\",\"type\":\"bool\"}],\"name\":\"numAdoptedAxies\",\"outputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_redemptionAddress\",\"type\":\"address\"}],\"name\":\"setRedemptionAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"redeemRewardedAxies\",\"outputs\":[{\"name\":\"_remainingQuantity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deduction\",\"type\":\"bool\"}],\"name\":\"totalRewardedAxies\",\"outputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_deduction\",\"type\":\"bool\"}],\"name\":\"numRefCredits\",\"outputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_adopter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_class\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_quantity\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"AxiesAdopted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"AxiesRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_class\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"AdoptedAxiesRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"RewardedAxiesRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numMintedCredits\",\"type\":\"uint256\"}],\"name\":\"RefCreditsMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AxiePresaleExtended","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://52011fcf2d7981df31e01f179008bc31d5123260b3f1da30fc58f9e489fce381"}]}