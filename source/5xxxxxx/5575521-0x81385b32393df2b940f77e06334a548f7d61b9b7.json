{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/**\r\n * Overflow aware uint math functions.\r\n *\r\n * Inspired by https://github.com/MakerDAO/maker-otc/blob/master/contracts/simple_market.sol\r\n */\r\n\r\ncontract SafeMath {\r\n\t/**\r\n\t* @dev Multiplies two numbers, throws on overflow.\r\n\t*/\r\n\tfunction safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Integer division of two numbers, truncating the quotient.\r\n\t*/\r\n\tfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t// uint256 c = a / b;\r\n\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\r\n\t// mitigate short address attack\r\n\t// thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\r\n\t// TODO: doublecheck implication of >= compared to ==\r\n\tmodifier onlyPayloadSize(uint numWords) {\r\n\t\tassert(msg.data.length >= numWords * 32 + 4);\r\n\t\t_;\r\n\t}\r\n}\r\n\r\ncontract Token { // ERC20 standard\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token, SafeMath {\r\n\r\n\tuint256 public totalSupply;\r\n\r\n\tmapping (address => uint256) public index;\r\n\tmapping (uint256 => Info) public infos;\r\n\tmapping (address => mapping (address => uint256)) allowed;\r\n\r\n\tstruct Info {\r\n\t\tuint256 tokenBalances;\r\n\t\taddress holderAddress;\r\n\t}\r\n\r\n\t// TODO: update tests to expect throw\r\n\tfunction transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(infos[index[msg.sender]].tokenBalances >= _value && _value > 0);\r\n\t\tinfos[index[msg.sender]].tokenBalances = safeSub(infos[index[msg.sender]].tokenBalances, _value);\r\n\t\tinfos[index[_to]].tokenBalances = safeAdd(infos[index[_to]].tokenBalances, _value);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// TODO: update tests to expect throw\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3) returns (bool success) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(infos[index[_from]].tokenBalances >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\r\n\t\tinfos[index[_from]].tokenBalances = safeSub(infos[index[_from]].tokenBalances, _value);\r\n\t\tinfos[index[_to]].tokenBalances = safeAdd(infos[index[_to]].tokenBalances, _value);\r\n\t\tallowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n\t\temit Transfer(_from, _to, _value);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn infos[index[_owner]].tokenBalances;\r\n\t}\r\n\r\n\t//  To change the approve amount you first have to reduce the addresses'\r\n\t//  allowance to zero by calling 'approve(_spender, 0)' if it is not\r\n\t//  already 0 to mitigate the race condition described here:\r\n\t//  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\tfunction approve(address _spender, uint256 _value) public onlyPayloadSize(2) returns (bool success) {\r\n\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) public onlyPayloadSize(3) returns (bool success) {\r\n\t\trequire(allowed[msg.sender][_spender] == _oldValue);\r\n\t\tallowed[msg.sender][_spender] = _newValue;\r\n\t\temit Approval(msg.sender, _spender, _newValue);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n\t  return allowed[_owner][_spender];\r\n\t}\r\n}\r\n\r\ncontract JCFv2 is StandardToken {\r\n\r\n\t// FIELDS\r\n\r\n\tstring public name = \"JCFv2\";\r\n\tstring public symbol = \"JCFv2\";\r\n\tuint256 public decimals = 18;\r\n\tstring public version = \"2.0\";\r\n\r\n\tuint256 public tokenCap = 1048576000000 * 10**18;\r\n\r\n\t// root control\r\n\taddress public fundWallet;\r\n\t// control of liquidity and limited control of updatePrice\r\n\taddress public controlWallet;\r\n\r\n\t// fundWallet controlled state variables\r\n\t// halted: halt buying due to emergency, tradeable: signal that assets have been acquired\r\n\tbool public halted = false;\r\n\tbool public tradeable = false;\r\n\r\n\t// -- totalSupply defined in StandardToken\r\n\t// -- mapping to token balances done in StandardToken\r\n\r\n\tuint256 public minAmount = 0.04 ether;\r\n\tuint256 public totalHolder;\r\n\r\n\t// map participant address to a withdrawal request\r\n\tmapping (address => Withdrawal) public withdrawals;\r\n\r\n\t// maps addresses\r\n\tmapping (address => bool) public whitelist;\r\n\r\n\t// TYPES\r\n\r\n\tstruct Withdrawal {\r\n\t\tuint256 tokens;\r\n\t\tuint256 time; // time for each withdrawal is set to the previousUpdateTime\r\n\t\t// uint256 totalAmount;\r\n\t}\r\n\r\n\t// EVENTS\r\n\r\n\tevent Whitelist(address indexed participant);\r\n\tevent AddLiquidity(uint256 ethAmount);\r\n\tevent RemoveLiquidity(uint256 ethAmount);\r\n\tevent WithdrawRequest(address indexed participant, uint256 amountTokens, uint256 requestTime);\r\n\tevent Withdraw(address indexed participant, uint256 amountTokens, uint256 etherAmount);\r\n\tevent Burn(address indexed burner, uint256 value);\r\n\r\n\t// MODIFIERS\r\n\r\n\tmodifier isTradeable {\r\n\t\trequire(tradeable || msg.sender == fundWallet);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyWhitelist {\r\n\t\trequire(whitelist[msg.sender]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyFundWallet {\r\n\t\trequire(msg.sender == fundWallet);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyManagingWallets {\r\n\t\trequire(msg.sender == controlWallet || msg.sender == fundWallet);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier only_if_controlWallet {\r\n\t\tif (msg.sender == controlWallet) {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\tconstructor () public {\r\n\t\tfundWallet = msg.sender;\r\n\t\tcontrolWallet = msg.sender;\r\n\t\tinfos[index[fundWallet]].tokenBalances = 1048576000000 * 10**18;\r\n\t\ttotalSupply = infos[index[fundWallet]].tokenBalances;\r\n\t\twhitelist[fundWallet] = true;\r\n\t\twhitelist[controlWallet] = true;\r\n\t\ttotalHolder = 0;\r\n\t\tindex[msg.sender] = 0;\r\n\t\tinfos[0].holderAddress = msg.sender;\r\n\t}\r\n\r\n\tfunction verifyParticipant(address participant) external onlyManagingWallets {\r\n\t\twhitelist[participant] = true;\r\n\t\temit Whitelist(participant);\r\n\t}\r\n\r\n\tfunction withdraw_to(address participant, uint256 withdrawValue, uint256 amountTokensToWithdraw, uint256 requestTime) public onlyFundWallet {\r\n\t\trequire(amountTokensToWithdraw > 0);\r\n\t\trequire(withdrawValue > 0);\r\n\t\trequire(balanceOf(participant) >= amountTokensToWithdraw);\r\n\t\trequire(withdrawals[participant].tokens == 0);\r\n\r\n\t\tinfos[index[participant]].tokenBalances = safeSub(infos[index[participant]].tokenBalances, amountTokensToWithdraw);\r\n\r\n\t\twithdrawals[participant] = Withdrawal({tokens: amountTokensToWithdraw, time: requestTime});\r\n\r\n\t\temit WithdrawRequest(participant, amountTokensToWithdraw, requestTime);\r\n\r\n\t\tif (address(this).balance >= withdrawValue) {\r\n\t\t\tenact_withdrawal_greater_equal(participant, withdrawValue, amountTokensToWithdraw);\r\n\t\t} else {\r\n\t\t\tenact_withdrawal_less(participant, withdrawValue, amountTokensToWithdraw);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction enact_withdrawal_greater_equal(address participant, uint256 withdrawValue, uint256 tokens) private {\r\n\t\tassert(address(this).balance >= withdrawValue);\r\n\t\tinfos[index[fundWallet]].tokenBalances = safeAdd(infos[index[fundWallet]].tokenBalances, tokens);\r\n\r\n\t\tparticipant.transfer(withdrawValue);\r\n\t\twithdrawals[participant].tokens = 0;\r\n\t\temit Withdraw(participant, tokens, withdrawValue);\r\n\t}\r\n\r\n\tfunction enact_withdrawal_less(address participant, uint256 withdrawValue, uint256 tokens) private {\r\n\t\tassert(address(this).balance < withdrawValue);\r\n\t\tinfos[index[participant]].tokenBalances = safeAdd(infos[index[participant]].tokenBalances, tokens);\r\n\r\n\t\twithdrawals[participant].tokens = 0;\r\n\t\temit Withdraw(participant, tokens, 0); // indicate a failed withdrawal\r\n\t}\r\n\r\n\tfunction addLiquidity() external onlyManagingWallets payable {\r\n\t\trequire(msg.value > 0);\r\n\t\temit AddLiquidity(msg.value);\r\n\t}\r\n\r\n\tfunction removeLiquidity(uint256 amount) external onlyManagingWallets {\r\n\t\trequire(amount <= address(this).balance);\r\n\t\tfundWallet.transfer(amount);\r\n\t\temit RemoveLiquidity(amount);\r\n\t}\r\n\r\n\tfunction changeFundWallet(address newFundWallet) external onlyFundWallet {\r\n\t\trequire(newFundWallet != address(0));\r\n\t\tfundWallet = newFundWallet;\r\n\t}\r\n\r\n\tfunction changeControlWallet(address newControlWallet) external onlyFundWallet {\r\n\t\trequire(newControlWallet != address(0));\r\n\t\tcontrolWallet = newControlWallet;\r\n\t}\r\n\r\n\tfunction halt() external onlyFundWallet {\r\n\t\thalted = true;\r\n\t}\r\n\tfunction unhalt() external onlyFundWallet {\r\n\t\thalted = false;\r\n\t}\r\n\r\n\tfunction enableTrading() external onlyFundWallet {\r\n\t\t// require(block.number > fundingEndBlock);\r\n\t\ttradeable = true;\r\n\t}\r\n\r\n\tfunction disableTrading() external onlyFundWallet {\r\n\t\t// require(block.number > fundingEndBlock);\r\n\t\ttradeable = false;\r\n\t}\r\n\r\n\tfunction claimTokens(address _token) external onlyFundWallet {\r\n\t\trequire(_token != address(0));\r\n\t\tToken token = Token(_token);\r\n\t\tuint256 balance = token.balanceOf(this);\r\n\t\ttoken.transfer(fundWallet, balance);\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _value) public isTradeable returns (bool success) {\r\n\t\tif (index[_to] > 0) {\r\n\t\t\t// do nothing\r\n\t\t} else {\r\n\t\t\t// store token holder infos\r\n\t\t\ttotalHolder = safeAdd(totalHolder, 1);\r\n\t\t\tindex[_to] = totalHolder;\r\n\t\t\tinfos[index[_to]].holderAddress = _to;\r\n\t\t}\r\n\r\n\t\treturn super.transfer(_to, _value);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public isTradeable returns (bool success) {\r\n\t\tif (index[_to] > 0) {\r\n\t\t\t// do nothing\r\n\t\t} else {\r\n\t\t\t// store token holder infos\r\n\t\t\ttotalHolder = safeAdd(totalHolder, 1);\r\n\t\t\tindex[_to] = totalHolder;\r\n\t\t\tinfos[index[_to]].holderAddress = _to;\r\n\t\t}\r\n\t\treturn super.transferFrom(_from, _to, _value);\r\n\t}\r\n\r\n\tfunction burn(address _who, uint256 _value) external only_if_controlWallet {\r\n\t\trequire(_value <= infos[index[_who]].tokenBalances);\r\n\t\t// no need to require value <= totalSupply, since that would imply the\r\n\t\t// sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\t\tinfos[index[_who]].tokenBalances = safeSub(infos[index[_who]].tokenBalances, _value);\r\n\r\n\t\ttotalSupply = safeSub(totalSupply, _value);\r\n\t\temit Burn(_who, _value);\r\n\t\temit Transfer(_who, address(0), _value);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"infos\",\"outputs\":[{\"name\":\"tokenBalances\",\"type\":\"uint256\"},{\"name\":\"holderAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"withdrawValue\",\"type\":\"uint256\"},{\"name\":\"amountTokensToWithdraw\",\"type\":\"uint256\"},{\"name\":\"requestTime\",\"type\":\"uint256\"}],\"name\":\"withdraw_to\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newControlWallet\",\"type\":\"address\"}],\"name\":\"changeControlWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"verifyParticipant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFundWallet\",\"type\":\"address\"}],\"name\":\"changeFundWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawals\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controlWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"changeApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"Whitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestTime\",\"type\":\"uint256\"}],\"name\":\"WithdrawRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"JCFv2","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0f5bcf8dde821c5a2f33939dc481416dd8f4661c921c1e3b81d403211aa2b8f0"}]}