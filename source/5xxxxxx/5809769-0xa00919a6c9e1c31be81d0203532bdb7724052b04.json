{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract safeSend {\r\n    bool private txMutex3847834;\r\n\r\n    // we want to be able to call outside contracts (e.g. the admin proxy contract)\r\n    // but reentrency is bad, so here's a mutex.\r\n    function doSafeSend(address toAddr, uint amount) internal {\r\n        doSafeSendWData(toAddr, \"\", amount);\r\n    }\r\n\r\n    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\r\n        require(txMutex3847834 == false, \"ss-guard\");\r\n        txMutex3847834 = true;\r\n        // we need to use address.call.value(v)() because we want\r\n        // to be able to send to other contracts, even with no data,\r\n        // which might use more than 2300 gas in their fallback function.\r\n        require(toAddr.call.value(amount)(data), \"ss-failed\");\r\n        txMutex3847834 = false;\r\n    }\r\n}\r\n\r\ncontract payoutAllC is safeSend {\r\n    address private _payTo;\r\n\r\n    event PayoutAll(address payTo, uint value);\r\n\r\n    constructor(address initPayTo) public {\r\n        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\r\n        assert(initPayTo != address(0));\r\n        _payTo = initPayTo;\r\n    }\r\n\r\n    function _getPayTo() internal view returns (address) {\r\n        return _payTo;\r\n    }\r\n\r\n    function _setPayTo(address newPayTo) internal {\r\n        _payTo = newPayTo;\r\n    }\r\n\r\n    function payoutAll() external {\r\n        address a = _getPayTo();\r\n        uint bal = address(this).balance;\r\n        doSafeSend(a, bal);\r\n        emit PayoutAll(a, bal);\r\n    }\r\n}\r\n\r\ncontract payoutAllCSettable is payoutAllC {\r\n    constructor (address initPayTo) payoutAllC(initPayTo) public {\r\n    }\r\n\r\n    function setPayTo(address) external;\r\n    function getPayTo() external view returns (address) {\r\n        return _getPayTo();\r\n    }\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    event OwnerChanged(address newOwner);\r\n\r\n    modifier only_owner() {\r\n        require(msg.sender == owner, \"only_owner: forbidden\");\r\n        _;\r\n    }\r\n\r\n    modifier owner_or(address addr) {\r\n        require(msg.sender == addr || msg.sender == owner, \"!owner-or\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address newOwner) only_owner() external {\r\n        owner = newOwner;\r\n        emit OwnerChanged(newOwner);\r\n    }\r\n}\r\n\r\ncontract controlledIface {\r\n    function controller() external view returns (address);\r\n}\r\n\r\ncontract hasAdmins is owned {\r\n    mapping (uint => mapping (address => bool)) admins;\r\n    uint public currAdminEpoch = 0;\r\n    bool public adminsDisabledForever = false;\r\n    address[] adminLog;\r\n\r\n    event AdminAdded(address indexed newAdmin);\r\n    event AdminRemoved(address indexed oldAdmin);\r\n    event AdminEpochInc();\r\n    event AdminDisabledForever();\r\n\r\n    modifier only_admin() {\r\n        require(adminsDisabledForever == false, \"admins must not be disabled\");\r\n        require(isAdmin(msg.sender), \"only_admin: forbidden\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _setAdmin(msg.sender, true);\r\n    }\r\n\r\n    function isAdmin(address a) view public returns (bool) {\r\n        return admins[currAdminEpoch][a];\r\n    }\r\n\r\n    function getAdminLogN() view external returns (uint) {\r\n        return adminLog.length;\r\n    }\r\n\r\n    function getAdminLog(uint n) view external returns (address) {\r\n        return adminLog[n];\r\n    }\r\n\r\n    function upgradeMeAdmin(address newAdmin) only_admin() external {\r\n        // note: already checked msg.sender has admin with `only_admin` modifier\r\n        require(msg.sender != owner, \"owner cannot upgrade self\");\r\n        _setAdmin(msg.sender, false);\r\n        _setAdmin(newAdmin, true);\r\n    }\r\n\r\n    function setAdmin(address a, bool _givePerms) only_admin() external {\r\n        require(a != msg.sender && a != owner, \"cannot change your own (or owner's) permissions\");\r\n        _setAdmin(a, _givePerms);\r\n    }\r\n\r\n    function _setAdmin(address a, bool _givePerms) internal {\r\n        admins[currAdminEpoch][a] = _givePerms;\r\n        if (_givePerms) {\r\n            emit AdminAdded(a);\r\n            adminLog.push(a);\r\n        } else {\r\n            emit AdminRemoved(a);\r\n        }\r\n    }\r\n\r\n    // safety feature if admins go bad or something\r\n    function incAdminEpoch() only_owner() external {\r\n        currAdminEpoch++;\r\n        admins[currAdminEpoch][msg.sender] = true;\r\n        emit AdminEpochInc();\r\n    }\r\n\r\n    // this is internal so contracts can all it, but not exposed anywhere in this\r\n    // contract.\r\n    function disableAdminForever() internal {\r\n        currAdminEpoch++;\r\n        adminsDisabledForever = true;\r\n        emit AdminDisabledForever();\r\n    }\r\n}\r\n\r\ncontract EnsOwnerProxy is hasAdmins {\r\n    bytes32 public ensNode;\r\n    ENSIface public ens;\r\n    PublicResolver public resolver;\r\n\r\n    /**\r\n     * @param _ensNode The node to administer\r\n     * @param _ens The ENS Registrar\r\n     * @param _resolver The ENS Resolver\r\n     */\r\n    constructor(bytes32 _ensNode, ENSIface _ens, PublicResolver _resolver) public {\r\n        ensNode = _ensNode;\r\n        ens = _ens;\r\n        resolver = _resolver;\r\n    }\r\n\r\n    function setAddr(address addr) only_admin() external {\r\n        _setAddr(addr);\r\n    }\r\n\r\n    function _setAddr(address addr) internal {\r\n        resolver.setAddr(ensNode, addr);\r\n    }\r\n\r\n    function returnToOwner() only_owner() external {\r\n        ens.setOwner(ensNode, owner);\r\n    }\r\n\r\n    function fwdToENS(bytes data) only_owner() external {\r\n        require(address(ens).call(data), \"fwding to ens failed\");\r\n    }\r\n\r\n    function fwdToResolver(bytes data) only_owner() external {\r\n        require(address(resolver).call(data), \"fwding to resolver failed\");\r\n    }\r\n}\r\n\r\ncontract permissioned is owned, hasAdmins {\r\n    mapping (address => bool) editAllowed;\r\n    bool public adminLockdown = false;\r\n\r\n    event PermissionError(address editAddr);\r\n    event PermissionGranted(address editAddr);\r\n    event PermissionRevoked(address editAddr);\r\n    event PermissionsUpgraded(address oldSC, address newSC);\r\n    event SelfUpgrade(address oldSC, address newSC);\r\n    event AdminLockdown();\r\n\r\n    modifier only_editors() {\r\n        require(editAllowed[msg.sender], \"only_editors: forbidden\");\r\n        _;\r\n    }\r\n\r\n    modifier no_lockdown() {\r\n        require(adminLockdown == false, \"no_lockdown: check failed\");\r\n        _;\r\n    }\r\n\r\n\r\n    constructor() owned() hasAdmins() public {\r\n    }\r\n\r\n\r\n    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\r\n        editAllowed[e] = _editPerms;\r\n        if (_editPerms)\r\n            emit PermissionGranted(e);\r\n        else\r\n            emit PermissionRevoked(e);\r\n    }\r\n\r\n    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\r\n        editAllowed[oldSC] = false;\r\n        editAllowed[newSC] = true;\r\n        emit PermissionsUpgraded(oldSC, newSC);\r\n    }\r\n\r\n    // always allow SCs to upgrade themselves, even after lockdown\r\n    function upgradeMe(address newSC) only_editors() external {\r\n        editAllowed[msg.sender] = false;\r\n        editAllowed[newSC] = true;\r\n        emit SelfUpgrade(msg.sender, newSC);\r\n    }\r\n\r\n    function hasPermissions(address a) public view returns (bool) {\r\n        return editAllowed[a];\r\n    }\r\n\r\n    function doLockdown() external only_owner() no_lockdown() {\r\n        disableAdminForever();\r\n        adminLockdown = true;\r\n        emit AdminLockdown();\r\n    }\r\n}\r\n\r\ncontract upgradePtr {\r\n    address ptr = address(0);\r\n\r\n    modifier not_upgraded() {\r\n        require(ptr == address(0), \"upgrade pointer is non-zero\");\r\n        _;\r\n    }\r\n\r\n    function getUpgradePointer() view external returns (address) {\r\n        return ptr;\r\n    }\r\n\r\n    function doUpgradeInternal(address nextSC) internal {\r\n        ptr = nextSC;\r\n    }\r\n}\r\n\r\ninterface ERC20Interface {\r\n    // Get the total token supply\r\n    function totalSupply() constant external returns (uint256 _totalSupply);\r\n\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) constant external returns (uint256 balance);\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    // this function is required for some DEX functionality\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ninterface SvEnsIface {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\ninterface ENSIface {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\ncontract PublicResolver {\r\n\r\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\r\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\r\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\r\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\r\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    struct Record {\r\n        address addr;\r\n        bytes32 content;\r\n        string name;\r\n        PublicKey pubkey;\r\n        mapping(string=>string) text;\r\n        mapping(uint256=>bytes) abis;\r\n    }\r\n\r\n    ENSIface ens;\r\n\r\n    mapping (bytes32 => Record) records;\r\n\r\n    modifier only_owner(bytes32 node) {\r\n        require(ens.owner(node) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The ENS registrar contract.\r\n     */\r\n    constructor(ENSIface ensAddr) public {\r\n        ens = ensAddr;\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) public only_owner(node) {\r\n        records[node].addr = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Sets the content hash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The node to update.\r\n     * @param hash The content hash to set\r\n     */\r\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\r\n        records[node].content = hash;\r\n        emit ContentChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string name) public only_owner(node) {\r\n        records[node].name = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n\r\n        records[node].abis[contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\r\n        records[node].pubkey = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string key, string value) public only_owner(node) {\r\n        records[node].text[key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string key) public view returns (string) {\r\n        return records[node].text[key];\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\r\n        return (records[node].pubkey.x, records[node].pubkey.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\r\n        Record storage record = records[node];\r\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\r\n                data = record.abis[contentType];\r\n                return;\r\n            }\r\n        }\r\n        contentType = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) public view returns (string) {\r\n        return records[node].name;\r\n    }\r\n\r\n    /**\r\n     * Returns the content hash associated with an ENS node.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The ENS node to query.\r\n     * @return The associated content hash.\r\n     */\r\n    function content(bytes32 node) public view returns (bytes32) {\r\n        return records[node].content;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return records[node].addr;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID ||\r\n        interfaceID == CONTENT_INTERFACE_ID ||\r\n        interfaceID == NAME_INTERFACE_ID ||\r\n        interfaceID == ABI_INTERFACE_ID ||\r\n        interfaceID == PUBKEY_INTERFACE_ID ||\r\n        interfaceID == TEXT_INTERFACE_ID ||\r\n        interfaceID == INTERFACE_META_ID;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getAdminLog\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"fwdToResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currAdminEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdminLogN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"incAdminEpoch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"},{\"name\":\"_givePerms\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsDisabledForever\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"upgradeMeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"returnToOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"fwdToENS\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ensNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ensNode\",\"type\":\"bytes32\"},{\"name\":\"_ens\",\"type\":\"address\"},{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdminEpochInc\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AdminDisabledForever\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"}]","ContractName":"EnsOwnerProxy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"5bc52185477f1fb191d0a118f3f0a82d0032bc283c62f0f818a0ddee0127d9ba000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b0000000000000000000000005ffc014343cd971b7eb70732021e26c35b744cc4","Library":"","SwarmSource":"bzzr://e786e29ffd886b21665b8087a5fc8f37cadd9c281a6e1c87cfdf3dec74e55b39"}]}