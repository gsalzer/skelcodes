{"status":"1","message":"OK","result":[{"SourceCode":"/** @title Onasander Token Contract\r\n*   \r\n*   @author: Andrzej Wegrzyn\r\n*   Contact: development@onasander.com\r\n*   Date: May 5, 2018\r\n*   Location: New York, USA\r\n*   Token: Onasander\r\n*   Symbol: ONA\r\n*   \r\n*   @notice This is a simple contract due to solidity bugs and complications. \r\n*\r\n*   @notice Owner has the option to burn all the remaining tokens after the ICO.  That way Owners will not end up with majority of the tokens.\r\n*   @notice Onasander would love to give every user the option to burn the remaining tokens, but due to Solidity VM bugs and risk, we will process\r\n*   @notice all coin burns and refunds manually.\r\n*   \r\n*   @notice How to run the contract:\r\n*\r\n*   Requires:\r\n*   Wallet Address\r\n*\r\n*   Run:\r\n*   1. Create Contract\r\n*   2. Set Minimum Goal\r\n*   3. Set Tokens Per ETH\r\n*   4. Create PRE ICO Sale (can have multiple PRE-ICOs)\r\n*   5. End PRE ICO Sale\r\n*   6. Create ICO Sale\r\n*   7. End ICO Sale\r\n*   8. END ICO\r\n*   9. Burn Remaining Tokens\r\n*\r\n*   e18 for every value except tokens per ETH\r\n*   \r\n*   @dev This contract allows you to configure as many Pre-ICOs as you need.  It's a very simple contract written to give contract admin lots of dynamic options.\r\n*   @dev Here, most features except for total supply, max tokens for sale, company reserves, and token standard features, are dynamic.  You can configure your contract\r\n*   @dev however you want to.  \r\n*\r\n*   @dev IDE: Remix with Mist 0.10\r\n*   @dev Token supply numbers are provided in 0e18 format in MIST in order to bypass MIST number format errors.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract OnasanderToken\r\n{\r\n    using SafeMath for uint;\r\n    \r\n    address private wallet;                                // Address where funds are collected\r\n    address public owner;                                  // contract owner\r\n    string constant public name = \"Onasander\";\r\n    string constant public symbol = \"ONA\";\r\n    uint8 constant public decimals = 18;\r\n    uint public totalSupply = 88000000e18;                       \r\n    uint public totalTokensSold = 0e18;                    // total number of tokens sold to date\r\n    uint public totalTokensSoldInThisSale = 0e18;          // total number of tokens sold in this sale\r\n    uint public maxTokensForSale = 79200000e18;            // 90%  max tokens we can ever sale  \r\n    uint public companyReserves = 8800000e18;              // 10%  company reserves. this is what we end up with after eco ends and burns the rest if any  \r\n    uint public minimumGoal = 0e18;                        // hold minimum goal\r\n    uint public tokensForSale = 0e18;                      // total number of tokens we are selling in the current sale (ICO, preICO)\r\n    bool public saleEnabled = false;                       // enables all sales: ICO and tokensPreICO\r\n    bool public ICOEnded = false;                          // flag checking if the ICO has completed\r\n    bool public burned = false;                            // Excess tokens burned flag after ICO ends\r\n    uint public tokensPerETH = 800;                        // amount of Onasander tokens you get for 1 ETH\r\n    bool public wasGoalReached = false;                    // checks if minimum goal was reached\r\n    address private lastBuyer;\r\n    uint private singleToken = 1e18;\r\n\r\n    constructor(address icoWallet) public \r\n    {   \r\n        require(icoWallet != address(0), \"ICO Wallet address is required.\");\r\n\r\n        owner = msg.sender;\r\n        wallet = icoWallet;\r\n        balances[owner] = totalSupply;  // give initial full balance to contract owner\r\n        emit TokensMinted(owner, totalSupply);        \r\n    }\r\n\r\n    event ICOHasEnded();\r\n    event SaleEnded();\r\n    event OneTokenBugFixed();\r\n    event ICOConfigured(uint minimumGoal);\r\n    event TokenPerETHReset(uint amount);\r\n    event ICOCapReached(uint amount);\r\n    event SaleCapReached(uint amount);\r\n    event GoalReached(uint amount);\r\n    event Burned(uint amount);    \r\n    event BuyTokens(address buyer, uint tokens);\r\n    event SaleStarted(uint tokensForSale);    \r\n    event TokensMinted(address targetAddress, uint tokens);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint tokens);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    mapping(address => uint) balances;\r\n    \r\n    mapping(address => mapping (address => uint)) allowances;\r\n\r\n    function balanceOf(address accountAddress) public constant returns (uint balance)\r\n    {\r\n        return balances[accountAddress];\r\n    }\r\n\r\n    function allowance(address sender, address spender) public constant returns (uint remainingAllowedAmount)\r\n    {\r\n        return allowances[sender][spender];\r\n    }\r\n\r\n    function transfer(address to, uint tokens) public returns (bool success)\r\n    {     \r\n        require (ICOEnded, \"ICO has not ended.  Can not transfer.\");\r\n        require (balances[to] + tokens > balances[to], \"Overflow is not allowed.\");\r\n\r\n        // actual transfer\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        \r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns(bool success) \r\n    {\r\n        require (ICOEnded, \"ICO has not ended.  Can not transfer.\");\r\n        require (balances[to] + tokens > balances[to], \"Overflow is not allowed.\");\r\n\r\n        // actual transfer\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowances[from][msg.sender] = allowances[from][msg.sender].sub(tokens); // lower the allowance by the amount of tokens \r\n        balances[to] = balances[to].add(tokens);\r\n        \r\n        emit Transfer(from, to, tokens);        \r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint tokens) public returns(bool success) \r\n    {          \r\n        require (ICOEnded, \"ICO has not ended.  Can not transfer.\");      \r\n        allowances[msg.sender][spender] = tokens;                \r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n        // in case some investor pays by wire or credit card we will transfer him the tokens manually.\r\n    function wirePurchase(address to, uint numberOfTokenPurchased) onlyOwner public\r\n    {     \r\n        require (saleEnabled, \"Sale must be enabled.\");\r\n        require (!ICOEnded, \"ICO already ended.\");\r\n        require (numberOfTokenPurchased > 0, \"Tokens must be greater than 0.\");\r\n        require (tokensForSale > totalTokensSoldInThisSale, \"There is no more tokens for sale in this sale.\");\r\n                        \r\n        // calculate amount\r\n        uint buyAmount = numberOfTokenPurchased;\r\n        uint tokens = 0e18;\r\n\r\n        // this check is not perfect as someone may want to buy more than we offer for sale and we lose a sale.\r\n        // the best would be to calclate and sell you only the amout of tokens that is left and refund the rest of money        \r\n        if (totalTokensSoldInThisSale.add(buyAmount) >= tokensForSale)\r\n        {\r\n            tokens = tokensForSale.sub(totalTokensSoldInThisSale);  // we allow you to buy only up to total tokens for sale, and refund the rest\r\n            // need to program the refund for the rest,or do it manually.  \r\n        }\r\n        else\r\n        {\r\n            tokens = buyAmount;\r\n        }\r\n\r\n        // transfer only as we do not need to take the payment since we already did in wire\r\n        require (balances[to].add(tokens) > balances[to], \"Overflow is not allowed.\");\r\n        balances[to] = balances[to].add(tokens);\r\n        balances[owner] = balances[owner].sub(tokens);\r\n        lastBuyer = to;\r\n\r\n        // update counts\r\n        totalTokensSold = totalTokensSold.add(tokens);\r\n        totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(tokens);\r\n        \r\n        emit BuyTokens(to, tokens);\r\n        emit Transfer(owner, to, tokens);\r\n\r\n        isGoalReached();\r\n        isMaxCapReached();\r\n    }\r\n\r\n    function buyTokens() payable public\r\n    {        \r\n        require (saleEnabled, \"Sale must be enabled.\");\r\n        require (!ICOEnded, \"ICO already ended.\");\r\n        require (tokensForSale > totalTokensSoldInThisSale, \"There is no more tokens for sale in this sale.\");\r\n        require (msg.value > 0, \"Must send ETH\");\r\n\r\n        // calculate amount\r\n        uint buyAmount = SafeMath.mul(msg.value, tokensPerETH);\r\n        uint tokens = 0e18;\r\n\r\n        // this check is not perfect as someone may want to buy more than we offer for sale and we lose a sale.\r\n        // the best would be to calclate and sell you only the amout of tokens that is left and refund the rest of money        \r\n        if (totalTokensSoldInThisSale.add(buyAmount) >= tokensForSale)\r\n        {\r\n            tokens = tokensForSale.sub(totalTokensSoldInThisSale);  // we allow you to buy only up to total tokens for sale, and refund the rest\r\n\r\n            // need to program the refund for the rest\r\n        }\r\n        else\r\n        {\r\n            tokens = buyAmount;\r\n        }\r\n\r\n        // buy\r\n        require (balances[msg.sender].add(tokens) > balances[msg.sender], \"Overflow is not allowed.\");\r\n        balances[msg.sender] = balances[msg.sender].add(tokens);\r\n        balances[owner] = balances[owner].sub(tokens);\r\n        lastBuyer = msg.sender;\r\n\r\n        // take the money out right away\r\n        wallet.transfer(msg.value);\r\n\r\n        // update counts\r\n        totalTokensSold = totalTokensSold.add(tokens);\r\n        totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(tokens);\r\n        \r\n        emit BuyTokens(msg.sender, tokens);\r\n        emit Transfer(owner, msg.sender, tokens);\r\n\r\n        isGoalReached();\r\n        isMaxCapReached();\r\n    }\r\n\r\n    // Fallback function. Used for buying tokens from contract owner by simply\r\n    // sending Ethers to contract.\r\n    function() public payable \r\n    {\r\n        // we buy tokens using whatever ETH was sent in\r\n        buyTokens();\r\n    }\r\n\r\n    // Called when ICO is closed. Burns the remaining tokens except the tokens reserved\r\n    // Must be called by the owner to trigger correct transfer event\r\n    function burnRemainingTokens() public onlyOwner\r\n    {\r\n        require (!burned, \"Remaining tokens have been burned already.\");\r\n        require (ICOEnded, \"ICO has not ended yet.\");\r\n\r\n        uint difference = balances[owner].sub(companyReserves); \r\n\r\n        if (wasGoalReached)\r\n        {\r\n            totalSupply = totalSupply.sub(difference);\r\n            balances[owner] = companyReserves;\r\n        }\r\n        else\r\n        {\r\n            // in case we did not reach the goal, we burn all tokens except tokens purchased.\r\n            totalSupply = totalTokensSold;\r\n            balances[owner] = 0e18;\r\n        }\r\n\r\n        burned = true;\r\n\r\n        emit Transfer(owner, address(0), difference);    // this is run in order to update token holders in the website\r\n        emit Burned(difference);        \r\n    }\r\n\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public\r\n    {\r\n        address preOwner = owner;        \r\n        owner = newOwner;\r\n\r\n        uint previousBalance = balances[preOwner];\r\n\r\n        // transfer balance \r\n        balances[newOwner] = balances[newOwner].add(previousBalance);\r\n        balances[preOwner] = 0;\r\n\r\n        //emit Transfer(preOwner, newOwner, previousBalance); // required to update the Token Holders on the network\r\n        emit OwnershipTransferred(preOwner, newOwner, previousBalance);\r\n    }\r\n\r\n    // Set the number of ONAs sold per ETH \r\n    function setTokensPerETH(uint newRate) onlyOwner public\r\n    {\r\n        require (!ICOEnded, \"ICO already ended.\");\r\n        require (newRate > 0, \"Rate must be higher than 0.\");\r\n        tokensPerETH = newRate;\r\n        emit TokenPerETHReset(newRate);\r\n    }\r\n\r\n    // Minimum goal is based on USD, not on ETH. Since we will have different dynamic prices based on the daily pirce of ETH, we\r\n    // will need to be able to adjust our minimum goal in tokens sold, as our goal is set in tokens, not USD.\r\n    function setMinimumGoal(uint goal) onlyOwner public\r\n    {   \r\n        require(goal > 0e18,\"Minimum goal must be greater than 0.\");\r\n        minimumGoal = goal;\r\n\r\n        // since we can edit the goal, we want to check if we reached the goal before in case we lowered the goal number.\r\n        isGoalReached();\r\n\r\n        emit ICOConfigured(goal);\r\n    }\r\n\r\n    function createSale(uint numberOfTokens) onlyOwner public\r\n    {\r\n        require (!saleEnabled, \"Sale is already going on.\");\r\n        require (!ICOEnded, \"ICO already ended.\");\r\n        require (totalTokensSold < maxTokensForSale, \"We already sold all our tokens.\");\r\n\r\n        totalTokensSoldInThisSale = 0e18;\r\n        uint tryingToSell = totalTokensSold.add(numberOfTokens);\r\n\r\n        // in case we are trying to create a sale with too many tokens, we subtract and sell only what's left\r\n        if (tryingToSell > maxTokensForSale)\r\n        {\r\n            tokensForSale = maxTokensForSale.sub(totalTokensSold); \r\n        }\r\n        else\r\n        {\r\n            tokensForSale = numberOfTokens;\r\n        }\r\n\r\n        tryingToSell = 0e18;\r\n        saleEnabled = true;\r\n        emit SaleStarted(tokensForSale);\r\n    }\r\n\r\n    function endSale() public\r\n    {\r\n        if (saleEnabled)\r\n        {\r\n            saleEnabled = false;\r\n            tokensForSale = 0e18;\r\n            emit SaleEnded();\r\n        }\r\n    }\r\n\r\n    function endICO() onlyOwner public\r\n    {\r\n        if (!ICOEnded)\r\n        {\r\n            // run this before end of ICO and end of last sale            \r\n            fixTokenCalcBug();\r\n\r\n            endSale();\r\n\r\n            ICOEnded = true;            \r\n            lastBuyer = address(0);\r\n            \r\n            emit ICOHasEnded();\r\n        }\r\n    }\r\n\r\n    function isGoalReached() internal\r\n    {\r\n        // check if we reached the goal\r\n        if (!wasGoalReached)\r\n        {\r\n            if (totalTokensSold >= minimumGoal)\r\n            {\r\n                wasGoalReached = true;\r\n                emit GoalReached(minimumGoal);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isMaxCapReached() internal\r\n    {\r\n        if (totalTokensSoldInThisSale >= tokensForSale)\r\n        {            \r\n            emit SaleCapReached(totalTokensSoldInThisSale);\r\n            endSale();\r\n        }\r\n\r\n        if (totalTokensSold >= maxTokensForSale)\r\n        {            \r\n            emit ICOCapReached(maxTokensForSale);\r\n            endICO();\r\n        }\r\n    }\r\n\r\n    // This is a hack to add the lost token during final full sale. \r\n    function fixTokenCalcBug() internal\r\n    {        \r\n        require(!burned, \"Fix lost token can only run before the burning of the tokens.\");        \r\n        \r\n        if (maxTokensForSale.sub(totalTokensSold) == singleToken)\r\n        {\r\n            totalTokensSold = totalTokensSold.add(singleToken);\r\n            totalTokensSoldInThisSale = totalTokensSoldInThisSale.add(singleToken);\r\n            \r\n            balances[lastBuyer] = balances[lastBuyer].add(singleToken);\r\n            balances[owner] = balances[owner].sub(singleToken);\r\n\r\n            emit Transfer(owner, lastBuyer, singleToken);\r\n            emit OneTokenBugFixed();\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setTokensPerETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"numberOfTokenPurchased\",\"type\":\"uint256\"}],\"name\":\"wirePurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICOEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wasGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"accountAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSoldInThisSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnRemainingTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokensForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"createSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyReserves\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"goal\",\"type\":\"uint256\"}],\"name\":\"setMinimumGoal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remainingAllowedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"icoWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICOHasEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OneTokenBugFixed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minimumGoal\",\"type\":\"uint256\"}],\"name\":\"ICOConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPerETHReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ICOCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SaleCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"BuyTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokensForSale\",\"type\":\"uint256\"}],\"name\":\"SaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"TokensMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"OnasanderToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c5190398f2cdf63504df8150e13a2b70ce91d24d","Library":"","SwarmSource":"bzzr://a473a0b54ed24bd66c59e500def6aa48b310b7d56b41369d38ebcb1967205063"}]}