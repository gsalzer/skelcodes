{"status":"1","message":"OK","result":[{"SourceCode":"/* script to add preToken Signers and remove deployer account as signer\r\n    must be executed via PreTokenProxy\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract Main0002_setupPreTokenSigners {\r\n\r\n    PreTokenProxy constant\r\n            preTokenProxy = PreTokenProxy(0x1411b3B189B01f6e6d1eA883bFFcbD3a5224934C);\r\n\r\n    function execute(Main0002_setupPreTokenSigners /* self (not used) */) external {\r\n        /******************************************************************************\r\n         * Set up PretokenSigners\r\n         ******************************************************************************/\r\n\r\n        address[] memory signersToAdd = new address[](2); // dynamic array needed for addSigners() & removeSigners()\r\n        signersToAdd[0] = 0xf9ea0E2857405C859bb8647ECB11f931D1259753;\r\n        signersToAdd[1] = 0xd8203A652452906586F2E6cB6e31f6f7fed094D4;\r\n        preTokenProxy.addSigners(signersToAdd);\r\n\r\n        // revoke deployer account signer rights\r\n        address[] memory signersToRemove = new address[](1); // dynamic array needed for addSigners() & removeSigners()\r\n        signersToRemove[0] = 0x7b534c2D0F9Ee973e0b6FE8D4000cA711A20f22e;\r\n        preTokenProxy.removeSigners(signersToRemove);\r\n    }\r\n\r\n}\r\n\r\n/* Abstract multisig contract to allow multi approval execution of atomic contracts scripts\r\n        e.g. migrations or settings.\r\n    * Script added by signing a script address by a signer  (NEW state)\r\n    * Script goes to ALLOWED state once a quorom of signers sign it (quorom fx is defined in each derived contracts)\r\n    * Script can be signed even in APPROVED state\r\n    * APPROVED scripts can be executed only once.\r\n        - if script succeeds then state set to DONE\r\n        - If script runs out of gas or reverts then script state set to FAILEd and not allowed to run again\r\n          (To avoid leaving \"behind\" scripts which fail in a given state but eventually execute in the future)\r\n    * Scripts can be cancelled by an other multisig script approved and calling cancelScript()\r\n    * Adding/removing signers is only via multisig approved scripts using addSigners / removeSigners fxs\r\n*/\r\ncontract MultiSig {\r\n    using SafeMath for uint256;\r\n\r\n    uint public constant CHUNK_SIZE = 100;\r\n\r\n    mapping(address => bool) public isSigner;\r\n    address[] public allSigners; // all signers, even the disabled ones\r\n                                // NB: it can contain duplicates when a signer is added, removed then readded again\r\n                                //   the purpose of this array is to being able to iterate on signers in isSigner\r\n    uint public activeSignersCount;\r\n\r\n    enum ScriptState {New, Approved, Done, Cancelled, Failed}\r\n\r\n    struct Script {\r\n        ScriptState state;\r\n        uint signCount;\r\n        mapping(address => bool) signedBy;\r\n        address[] allSigners;\r\n    }\r\n\r\n    mapping(address => Script) public scripts;\r\n    address[] public scriptAddresses;\r\n\r\n    event SignerAdded(address signer);\r\n    event SignerRemoved(address signer);\r\n\r\n    event ScriptSigned(address scriptAddress, address signer);\r\n    event ScriptApproved(address scriptAddress);\r\n    event ScriptCancelled(address scriptAddress);\r\n\r\n    event ScriptExecuted(address scriptAddress, bool result);\r\n\r\n    constructor() public {\r\n        // deployer address is the first signer. Deployer can configure new contracts by itself being the only \"signer\"\r\n        // The first script which sets the new contracts live should add signers and revoke deployer's signature right\r\n        isSigner[msg.sender] = true;\r\n        allSigners.push(msg.sender);\r\n        activeSignersCount = 1;\r\n        emit SignerAdded(msg.sender);\r\n    }\r\n\r\n    function sign(address scriptAddress) public {\r\n        require(isSigner[msg.sender], \"sender must be signer\");\r\n        Script storage script = scripts[scriptAddress];\r\n        require(script.state == ScriptState.Approved || script.state == ScriptState.New,\r\n                \"script state must be New or Approved\");\r\n        require(!script.signedBy[msg.sender], \"script must not be signed by signer yet\");\r\n\r\n        if(script.allSigners.length == 0) {\r\n            // first sign of a new script\r\n            scriptAddresses.push(scriptAddress);\r\n        }\r\n\r\n        script.allSigners.push(msg.sender);\r\n        script.signedBy[msg.sender] =  true;\r\n        script.signCount = script.signCount.add(1);\r\n\r\n        emit ScriptSigned(scriptAddress, msg.sender);\r\n\r\n        if(checkQuorum(script.signCount)){\r\n            script.state = ScriptState.Approved;\r\n            emit ScriptApproved(scriptAddress);\r\n        }\r\n    }\r\n\r\n    function execute(address scriptAddress) public returns (bool result) {\r\n        // only allow execute to signers to avoid someone set an approved script failed by calling it with low gaslimit\r\n        require(isSigner[msg.sender], \"sender must be signer\");\r\n        Script storage script = scripts[scriptAddress];\r\n        require(script.state == ScriptState.Approved, \"script state must be Approved\");\r\n\r\n        /* init to failed because if delegatecall rans out of gas we won't have enough left to set it.\r\n           NB: delegatecall leaves 63/64 part of gasLimit for the caller.\r\n                Therefore the execute might revert with out of gas, leaving script in Approved state\r\n                when execute() is called with small gas limits.\r\n        */\r\n        script.state = ScriptState.Failed;\r\n\r\n        // passing scriptAddress to allow called script access its own public fx-s if needed\r\n        if(scriptAddress.delegatecall(bytes4(keccak256(\"execute(address)\")), scriptAddress)) {\r\n            script.state = ScriptState.Done;\r\n            result = true;\r\n        } else {\r\n            result = false;\r\n        }\r\n        emit ScriptExecuted(scriptAddress, result);\r\n    }\r\n\r\n    function cancelScript(address scriptAddress) public {\r\n        require(msg.sender == address(this), \"only callable via MultiSig\");\r\n        Script storage script = scripts[scriptAddress];\r\n        require(script.state == ScriptState.Approved || script.state == ScriptState.New,\r\n                \"script state must be New or Approved\");\r\n\r\n        script.state= ScriptState.Cancelled;\r\n\r\n        emit ScriptCancelled(scriptAddress);\r\n    }\r\n\r\n    /* requires quorum so it's callable only via a script executed by this contract */\r\n    function addSigners(address[] signers) public {\r\n        require(msg.sender == address(this), \"only callable via MultiSig\");\r\n        for (uint i= 0; i < signers.length; i++) {\r\n            if (!isSigner[signers[i]]) {\r\n                require(signers[i] != address(0), \"new signer must not be 0x0\");\r\n                activeSignersCount++;\r\n                allSigners.push(signers[i]);\r\n                isSigner[signers[i]] = true;\r\n                emit SignerAdded(signers[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* requires quorum so it's callable only via a script executed by this contract */\r\n    function removeSigners(address[] signers) public {\r\n        require(msg.sender == address(this), \"only callable via MultiSig\");\r\n        for (uint i= 0; i < signers.length; i++) {\r\n            if (isSigner[signers[i]]) {\r\n                require(activeSignersCount > 1, \"must not remove last signer\");\r\n                activeSignersCount--;\r\n                isSigner[signers[i]] = false;\r\n                emit SignerRemoved(signers[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* implement it in derived contract */\r\n    function checkQuorum(uint signersCount) internal view returns(bool isQuorum);\r\n\r\n    function getAllSignersCount() view external returns (uint allSignersCount) {\r\n        return allSigners.length;\r\n    }\r\n\r\n    // UI helper fx - Returns signers from offset as [signer id (index in allSigners), address as uint, isActive 0 or 1]\r\n    function getAllSigners(uint offset) external view returns(uint[3][CHUNK_SIZE] signersResult) {\r\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allSigners.length; i++) {\r\n            address signerAddress = allSigners[i + offset];\r\n            signersResult[i] = [ i + offset, uint(signerAddress), isSigner[signerAddress] ? 1 : 0 ];\r\n        }\r\n    }\r\n\r\n    function getScriptsCount() view external returns (uint scriptsCount) {\r\n        return scriptAddresses.length;\r\n    }\r\n\r\n    // UI helper fx - Returns scripts from offset as\r\n    //  [scriptId (index in scriptAddresses[]), address as uint, state, signCount]\r\n    function getAllScripts(uint offset) external view returns(uint[4][CHUNK_SIZE] scriptsResult) {\r\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < scriptAddresses.length; i++) {\r\n            address scriptAddress = scriptAddresses[i + offset];\r\n            scriptsResult[i] = [ i + offset, uint(scriptAddress), uint(scripts[scriptAddress].state),\r\n                            scripts[scriptAddress].signCount ];\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n\r\n    TODO: check against ds-math: https://blog.dapphub.com/ds-math/\r\n    TODO: move roundedDiv to a sep lib? (eg. Math.sol)\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, \"mul overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div by 0\"); // Solidity automatically throws for div by 0 but require to emit reason\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"sub underflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"add overflow\");\r\n        return c;\r\n    }\r\n\r\n    function roundedDiv(uint a, uint b) internal pure returns (uint256) {\r\n        require(b > 0, \"div by 0\"); // Solidity automatically throws for div by 0 but require to emit reason\r\n        uint256 z = a / b;\r\n        if (a % b >= b / 2) {\r\n            z++;  // no need for safe add b/c it can happen only if we divided the input\r\n        }\r\n        return z;\r\n    }\r\n}\r\n\r\ncontract PreTokenProxy is MultiSig {\r\n\r\n    function checkQuorum(uint signersCount) internal view returns(bool isQuorum) {\r\n        isQuorum = signersCount > activeSignersCount / 2 ;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Main0002_setupPreTokenSigners","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c8d2ab596c150873171e04f16a8c036182411e7d9c01a9fe396e118cd31d23ce"}]}