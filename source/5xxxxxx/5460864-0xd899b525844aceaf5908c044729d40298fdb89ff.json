{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n\r\n  function add(uint a, uint b)\r\n    internal\r\n    pure\r\n    returns (uint c)\r\n  {\r\n    c = a + b;\r\n    require(c >= a);\r\n  }\r\n\r\n  function sub(uint a, uint b)\r\n    internal\r\n    pure\r\n    returns (uint c)\r\n  {\r\n    require(b <= a);\r\n    c = a - b;\r\n  }\r\n\r\n  function mul(uint a, uint b)\r\n    internal\r\n    pure\r\n    returns (uint c)\r\n  {\r\n    c = a * b;\r\n    require(a == 0 || c / a == b);\r\n  }\r\n\r\n  function div(uint a, uint b)\r\n    internal\r\n    pure\r\n    returns (uint c)\r\n  {\r\n    require(b > 0);\r\n    c = a / b;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract ERC20Interface {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint tokens);\r\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n  function totalSupply() public constant returns (uint);\r\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n  function transfer(address to, uint tokens) public returns (bool success);\r\n  function approve(address spender, uint tokens) public returns (bool success);\r\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Owned {\r\n\r\n  event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n  address public owner;\r\n  address public newOwner;\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function Owned()\r\n    public\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner)\r\n    public\r\n    onlyOwner\r\n  {\r\n    newOwner = _newOwner;\r\n  }\r\n\r\n  function acceptOwnership()\r\n    public\r\n  {\r\n    require(msg.sender == newOwner);\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n    newOwner = address(0);\r\n  }\r\n\r\n}\r\n\r\ncontract ELOT is ERC20Interface, Owned {\r\n\r\n  using SafeMath for uint;\r\n\r\n  string public symbol;\r\n  string public  name;\r\n  uint8 public decimals;\r\n  uint public _totalSupply;\r\n\r\n  mapping(address => uint) balances;\r\n  mapping(address => mapping(address => uint)) allowed;\r\n\r\n  function ELOT()\r\n    public\r\n  {\r\n    symbol = \"ELOT\";\r\n    name = \"ELOT COIN\";\r\n    decimals = 0;\r\n    _totalSupply = 5000000000 ;\r\n    balances[owner] = _totalSupply;\r\n    emit Transfer(address(0), owner, _totalSupply);\r\n  }\r\n\r\n  function totalSupply()\r\n    public\r\n    constant\r\n    returns (uint)\r\n  {\r\n    return _totalSupply  - balances[address(0)];\r\n  }\r\n\r\n  function balanceOf(address tokenOwner)\r\n    public\r\n    constant\r\n    returns (uint balance)\r\n  {\r\n    return balances[tokenOwner];\r\n  }\r\n\r\n\r\n  function transfer(address to, uint tokens)\r\n    public\r\n    returns (bool success)\r\n  {\r\n    balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n    balances[to] = balances[to].add(tokens);\r\n    emit Transfer(msg.sender, to, tokens);\r\n    return true;\r\n  }\r\n\r\n\r\n  function approve(address spender, uint tokens)\r\n    public\r\n    returns (bool success)\r\n  {\r\n    allowed[msg.sender][spender] = tokens;\r\n    emit Approval(msg.sender, spender, tokens);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint tokens)\r\n    public\r\n    returns (bool success)\r\n  {\r\n    balances[from] = balances[from].sub(tokens);\r\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n    balances[to] = balances[to].add(tokens);\r\n    emit Transfer(from, to, tokens);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address tokenOwner, address spender)\r\n    public\r\n    constant\r\n    returns (uint remaining)\r\n  {\r\n    return allowed[tokenOwner][spender];\r\n  }\r\n\r\n\r\n  \r\n   function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n  function ApproveAndDo(address spender, uint tokens,bytes32 id, string data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).approveAndDo(msg.sender,tokens,this,id,data);\r\n        return true;\r\n        \r\n  }\r\n\r\n\r\n  function ()\r\n    public\r\n    payable\r\n  {\r\n    revert();\r\n  }\r\n\r\n  function transferAnyERC20Token(address tokenAddress, uint tokens)\r\n    public\r\n    onlyOwner\r\n    returns (bool success)\r\n  {\r\n    return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n  }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function approveAndDo(address from, uint256 tokens, address token,bytes32 id, string data) public;\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n\r\ncontract LOTTERY{\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    uint256 private randomnumber1 = 0;\r\n    uint256 private randomnumber2 = 0;\r\n    uint256 private randomnumber3 = 0;\r\n    uint256 private randomnumber4 = 0;\r\n    uint256 private randomnumber5 = 0;\r\n    \r\n    uint public round=0;\r\n    address private owner;\r\n    \r\n    mapping ( bytes32 => Note ) private Notes; //mapping id to note information\r\n    mapping ( address=> bytes32[]) private GuestBetList;\r\n    mapping ( uint => uint[]) winNumbers;//mapping round to win numbers  \r\n    \r\n    struct Note{\r\n        uint round;\r\n        uint[] betNumbers; \r\n        uint tokens;\r\n        address client;\r\n        uint state;//0 inactive , 1 active\r\n        uint star;\r\n    }\r\n    \r\n    function LOTTERY() payable public{\r\n       owner  = msg.sender; \r\n   }\r\n   //\"0xff63212fa36420c22c6dac761a3f60d29fc1f32378a6451b291fdb540b152600\",\"0xAfC28904Fc9fFbA207181e60a183716af4e5bce2\"\r\n    function retrieve(bytes32 _id,address _tokenAddress)\r\n    payable\r\n    public\r\n    returns (bool success)\r\n    {\r\n        if( Notes[_id].state == 0 )\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        if( Notes[_id].round > round )\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        if(msg.sender != Notes[_id].client )\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        \r\n        \r\n        if(        1 == Notes[_id].star \r\n                && msg.sender == Notes[_id].client\r\n                && 1 == Notes[_id].state\r\n                && winNumbers[Notes[_id].round][4] == Notes[_id].betNumbers[4]\r\n          )\r\n        {\r\n            \r\n            if(ERC20Interface(_tokenAddress).transfer(Notes[_id].client,Notes[_id].tokens * 6))\r\n            { \r\n                Notes[_id].state = 0;\r\n                return true;\r\n            }\r\n         }else if( 2 == Notes[_id].star \r\n                && msg.sender == Notes[_id].client \r\n                && 1 == Notes[_id].state\r\n                && winNumbers[Notes[_id].round][4] == Notes[_id].betNumbers[4] \r\n                && winNumbers[Notes[_id].round][3] == Notes[_id].betNumbers[3]\r\n          )\r\n        {\r\n            \r\n            if(ERC20Interface(_tokenAddress).transfer(Notes[_id].client,Notes[_id].tokens * 60))\r\n            { \r\n                Notes[_id].state = 0;\r\n                return true;\r\n            }\r\n         }\r\n        else if(   3 == Notes[_id].star\r\n                && msg.sender == Notes[_id].client \r\n                && 1 == Notes[_id].state\r\n                && winNumbers[Notes[_id].round][4] == Notes[_id].betNumbers[4] \r\n                && winNumbers[Notes[_id].round][3] == Notes[_id].betNumbers[3]\r\n                && winNumbers[Notes[_id].round][2] == Notes[_id].betNumbers[2]\r\n            \r\n          )\r\n        {\r\n            \r\n            if(ERC20Interface(_tokenAddress).transfer(Notes[_id].client,Notes[_id].tokens * 600))\r\n            { \r\n                Notes[_id].state = 0;\r\n                return true;\r\n            }\r\n         }\r\n         else if(   4 == Notes[_id].star\r\n                && msg.sender == Notes[_id].client \r\n                && 1 == Notes[_id].state\r\n                && winNumbers[Notes[_id].round][4] == Notes[_id].betNumbers[4] \r\n                && winNumbers[Notes[_id].round][3] == Notes[_id].betNumbers[3]\r\n                && winNumbers[Notes[_id].round][2] == Notes[_id].betNumbers[2]\r\n                && winNumbers[Notes[_id].round][1] == Notes[_id].betNumbers[1]\r\n            \r\n          )\r\n        {\r\n            \r\n            if(ERC20Interface(_tokenAddress).transfer(Notes[_id].client,Notes[_id].tokens * 6000))\r\n            { \r\n                Notes[_id].state = 0;\r\n                return true;\r\n            }\r\n         }\r\n        else if(   5 == Notes[_id].star\r\n                && msg.sender == Notes[_id].client \r\n                && 1 == Notes[_id].state\r\n                && winNumbers[Notes[_id].round][4] == Notes[_id].betNumbers[4] \r\n                && winNumbers[Notes[_id].round][3] == Notes[_id].betNumbers[3]\r\n                && winNumbers[Notes[_id].round][2] == Notes[_id].betNumbers[2]\r\n                && winNumbers[Notes[_id].round][1] == Notes[_id].betNumbers[1]\r\n                && winNumbers[Notes[_id].round][0] == Notes[_id].betNumbers[0]\r\n            \r\n          )\r\n        {\r\n            \r\n            if(ERC20Interface(_tokenAddress).transfer(Notes[_id].client,Notes[_id].tokens * 60000))\r\n            { \r\n                Notes[_id].state = 0;\r\n                return true;\r\n            }\r\n         }\r\n         \r\n         \r\n          \r\n    }\r\n    \r\n    function approveAndDo(address from, uint256 tokens, address token, bytes32 id,string data) \r\n    payable\r\n    public{\r\n        \r\n         //betting round bigger than current round , return;\r\n         string memory roundstring = substring(data,0,10);\r\n         \r\n         uint betround = parseInt(roundstring,5);\r\n       \r\n         if(round >= betround)\r\n         {\r\n             return ;\r\n         }\r\n        \r\n         if(ERC20Interface(token).transferFrom(from,this,tokens))//transfer token to contract address\r\n         {\r\n          \r\n             uint[] memory numbers = new uint[](5);\r\n             numbers[0] = parseInt(substring(data,10,11),1);\r\n             numbers[1] = parseInt(substring(data,11,12),1);\r\n             numbers[2] = parseInt(substring(data,12,13),1);\r\n             numbers[3] = parseInt(substring(data,13,14),1);\r\n             numbers[4] = parseInt(substring(data,14,15),1);\r\n             randomnumber1 = randomnumber1 + numbers[0];\r\n             randomnumber2 = randomnumber2 + numbers[1];\r\n             randomnumber3 = randomnumber3 + numbers[2];\r\n             randomnumber4 = randomnumber4 + numbers[3];\r\n             randomnumber5 = randomnumber5 + numbers[4];\r\n             \r\n             \r\n            Notes[id]=Note({\r\n                               round:betround,\r\n                               betNumbers:numbers,\r\n                               tokens:tokens,\r\n                               client:from,\r\n                               state:1,\r\n                               star:parseInt(substring(data,15,16),1)\r\n                               \r\n                             });\r\n            GuestBetList[from].push(id);                 \r\n             \r\n             \r\n         }\r\n        \r\n        \r\n    }\r\n    \r\n\r\n    function getGuestNotesInfo(bytes32 _id)\r\n    view\r\n    public\r\n    returns (uint _round,uint[] _guessNumber,uint _tokens,uint _state,uint _star)\r\n    {\r\n      return (\r\n                Notes[_id].round,\r\n                Notes[_id].betNumbers,\r\n                Notes[_id].tokens,\r\n                Notes[_id].state,\r\n                Notes[_id].star\r\n                \r\n            );\r\n    }\r\n    \r\n    function getGuestNotes(address _clientaddress)\r\n    view\r\n    public\r\n    returns (bytes32[] _ids)\r\n    {\r\n      return GuestBetList[_clientaddress];\r\n    }\r\n    \r\n    function getWinNumbers(uint _round)\r\n    view\r\n    public\r\n    returns (uint[] _winnumbers)\r\n    {\r\n      return winNumbers[_round];\r\n    }\r\n\r\n\r\n    function generateWinNumber() public returns (bool){\r\n        if(msg.sender != owner)\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        uint winnumber1= uint8((uint256(keccak256(block.timestamp, block.difficulty))+randomnumber1)%10);\r\n        uint winnumber2= uint8((uint256(keccak256(block.timestamp, block.difficulty))+randomnumber2)%10);\r\n        uint winnumber3= uint8((uint256(keccak256(block.timestamp, block.difficulty))+randomnumber3)%10);\r\n        uint winnumber4= uint8((uint256(keccak256(block.timestamp, block.difficulty))+randomnumber4)%10);\r\n        uint winnumber5= uint8((uint256(keccak256(block.timestamp, block.difficulty))+randomnumber5)%10);\r\n        \r\n         round = round.add(1);\r\n        \r\n        winNumbers[round].push(winnumber1);\r\n        winNumbers[round].push(winnumber2);\r\n        winNumbers[round].push(winnumber3);\r\n        winNumbers[round].push(winnumber4);\r\n        winNumbers[round].push(winnumber5);\r\n        return true;\r\n    }\r\n    \r\n     function generateWinNumberTest(uint winnumber1,uint winnumber2,uint winnumber3,uint winnumber4,uint winnumber5) public returns (bool){\r\n        if(msg.sender != owner)\r\n        {\r\n            return false;\r\n        }\r\n        \r\n         round = round.add(1);\r\n        \r\n        winNumbers[round].push(winnumber1);\r\n        winNumbers[round].push(winnumber2);\r\n        winNumbers[round].push(winnumber3);\r\n        winNumbers[round].push(winnumber4);\r\n        winNumbers[round].push(winnumber5);\r\n        return true;\r\n    }\r\n\r\n    function substring(string str, uint startIndex, uint endIndex) internal pure returns (string) {\r\n    bytes memory strBytes = bytes(str);\r\n    bytes memory result = new bytes(endIndex-startIndex);\r\n    for(uint i = startIndex; i < endIndex; i++) {\r\n        result[i-startIndex] = strBytes[i];\r\n    }\r\n    return string(result);\r\n    }\r\n\r\n   function parseInt(string _a, uint _b) internal pure returns (uint) {\r\n          bytes memory bresult = bytes(_a);\r\n          uint mint = 0;\r\n          bool decimals = false;\r\n          for (uint i = 0; i < bresult.length; i++) {\r\n            if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\r\n              if (decimals) {\r\n                if (_b == 0) break;\r\n                  else _b--;\r\n              }\r\n              mint *= 10;\r\n              mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n          }\r\n          return mint;\r\n}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"ApproveAndDo\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ELOT","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0f0486d3e451c9873206ef22888910690ea6da6afc8d211bc595f3c1bbe78da2"}]}