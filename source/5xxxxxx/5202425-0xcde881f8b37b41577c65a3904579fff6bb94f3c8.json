{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/* King of the Hill, but with a twist\r\n\r\nTo with the pot, you must obtain 1 million points.\r\nYou obtain points by becoming and staying the King.\r\nTo become the King, you must pay 1% of the pot.\r\nAs the King, you earn (minutes)^2 points, where minutes\r\nis the amount of time you remain King.\r\n\r\n50% of the pot is used as an award, and the other 50%\r\nseeds the pot for the next round.\r\n\r\n20% of bids go to the bonus pot, which is given to the\r\nsecond-place person when someone wins.\r\n\r\n*/\r\n\r\ncontract EthKing {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// ------------------ Events -----------------------------\r\n\r\n\tevent NewRound(\r\n\t\tuint _timestamp,\r\n\t\tuint _round,\r\n\t\tuint _initialMainPot,\r\n\t\tuint _initialBonusPot\r\n  );\r\n\r\n\tevent NewKingBid(\r\n\t\tuint _timestamp,\r\n\t\taddress _address,\r\n\t\tuint _amount,\r\n\t\tuint _newMainPot,\r\n\t\tuint _newBonusPot\r\n\t);\r\n\r\n\tevent PlaceChange(\r\n\t\tuint _timestamp,\r\n\t\taddress _newFirst,\r\n\t\taddress _newSecond,\r\n\t\tuint _firstPoints,\r\n\t\tuint _secondPoints\r\n\t);\r\n\r\n\tevent Winner(\r\n\t\tuint _timestamp,\r\n\t\taddress _first,\r\n\t\tuint _firstAmount,\r\n\t\taddress _second,\r\n\t\tuint _secondAmount\r\n\t);\r\n\r\n\tevent EarningsWithdrawal(\r\n\t\tuint _timestamp,\r\n\t\taddress _address,\r\n\t\tuint _amount\r\n\t);\r\n\r\n\t// -------------------------------------------------------\r\n\r\n\taddress owner;\r\n\r\n\t// ------------------ Game Constants ---------------------\r\n\r\n\t// Fraction of the previous pot used to seed the next pot\r\n\t// Currently 50%\r\n\tuint private constant NEXT_POT_FRAC_TOP = 1;\r\n\tuint private constant NEXT_POT_FRAC_BOT = 2;\r\n\r\n\t// Minimum fraction of the pot required to become the King\r\n\t// Currently 0.5%\r\n\tuint private constant MIN_LEADER_FRAC_TOP = 5;\r\n\tuint private constant MIN_LEADER_FRAC_BOT = 1000;\r\n\r\n\t// Fraction of each bid used for the bonus pot\r\n\tuint private constant BONUS_POT_FRAC_TOP = 20;\r\n\tuint private constant BONUS_POT_FRAC_BOT = 100;\r\n\r\n\t// Fractino of each bid used for the developer fee\r\n\tuint private constant DEV_FEE_FRAC_TOP = 5;\r\n\tuint private constant DEV_FEE_FRAC_BOT = 100;\r\n\r\n\t// Exponent for point calculation\r\n\t// Currently x^2\r\n\tuint private constant POINT_EXPONENT = 2;\r\n\r\n\t// How many points to win?\r\n\tuint private constant POINTS_TO_WIN = 1000000;\r\n\t\r\n\t// Null address for advancing round\r\n    address null_address = address(0x0);\r\n\r\n\t// ----------------- Game Variables ----------------------\r\n\r\n\t// The current King, and when he was last put in power\r\n\taddress public king;\r\n\tuint public crownedTime;\r\n\r\n\t// The current leader and the current 2nd-place leader\r\n\taddress public first;\r\n\taddress public second;\r\n\r\n\t// Player info\r\n\tstruct Player {\r\n\t\tuint points;\r\n\t\tuint roundLastPlayed;\r\n\t\tuint winnings;\r\n\t}\r\n\r\n\t// Player mapping\r\n\tmapping (address => Player) private players;\r\n\r\n\t// Current round number\r\n\tuint public round;\r\n\r\n\t// Value of pot and bonus pot\r\n\tuint public mainPot;\r\n\tuint public bonusPot;\r\n\r\n\t// ----------------- Game Logic -------------------------\r\n\r\n\tfunction EthKing() public payable {\r\n\t\t// We should seed the game\r\n\t\trequire(msg.value > 0);\r\n\r\n\t\t// Set owner and round\r\n\t\towner = msg.sender;\r\n\t\tround = 1;\r\n\r\n\t\t// Calculate bonus pot and main pot\r\n\t\tuint _bonusPot = msg.value.mul(BONUS_POT_FRAC_TOP).div(BONUS_POT_FRAC_BOT);\r\n\t\tuint _mainPot = msg.value.sub(_bonusPot);\r\n\r\n\t\t// Make sure we didn't make a mistake\r\n\t\trequire(_bonusPot + _mainPot <= msg.value);\r\n\r\n\t\tmainPot = _mainPot;\r\n\t\tbonusPot = _bonusPot;\r\n\r\n\t\t// Set owner as King\r\n\t\t// Crowned upon contract creation\r\n\t\tking = owner;\r\n\t\tfirst = null_address;\r\n\t\tsecond = null_address;\r\n\t\tcrownedTime = now;\r\n\t\tplayers[owner].roundLastPlayed = round;\r\n        players[owner].points = 0;\r\n\t}\r\n\r\n\t// Calculate and reward points to the current King\r\n\t// Should be called when the current King is being kicked out\r\n\tmodifier payoutOldKingPoints {\r\n\t\tuint _pointsToAward = calculatePoints(crownedTime, now);\r\n\t\tplayers[king].points = players[king].points.add(_pointsToAward);\r\n\r\n\t\t// Check to see if King now is in first or second place.\r\n\t\t// If second place, just replace second place with King.\r\n\t\t// If first place, move first place down to second and King to first\r\n\t\tif (players[king].points > players[first].points) {\r\n\t\t\tsecond = first;\r\n\t\t\tfirst = king;\r\n\r\n\t\t\tPlaceChange(now, first, second, players[first].points, players[second].points);\r\n\r\n\t\t} else if (players[king].points > players[second].points && king != first) {\r\n\t\t\tsecond = king;\r\n\r\n\t\t\tPlaceChange(now, first, second, players[first].points, players[second].points);\r\n\t\t}\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t// Check current leader's points\r\n\t// Advances the round if he's at 1 million or greater\r\n\t// Pays out main pot and bonus pot\r\n\tmodifier advanceRoundIfNeeded {\r\n\t\tif (players[first].points >= POINTS_TO_WIN) {\r\n\t\t\t// Calculate next pots and winnings\r\n\t\t\tuint _nextMainPot = mainPot.mul(NEXT_POT_FRAC_TOP).div(NEXT_POT_FRAC_BOT);\r\n\t\t\tuint _nextBonusPot = bonusPot.mul(NEXT_POT_FRAC_TOP).div(NEXT_POT_FRAC_BOT);\r\n\r\n\t\t\tuint _firstEarnings = mainPot.sub(_nextMainPot);\r\n\t\t\tuint _secondEarnings = bonusPot.sub(_nextBonusPot);\r\n\r\n\t\t\tplayers[first].winnings = players[first].winnings.add(_firstEarnings);\r\n\t\t\tplayers[second].winnings = players[second].winnings.add(_secondEarnings);\r\n\r\n\t\t\t// Advance round\r\n\t\t\tround++;\r\n\t\t\tmainPot = _nextMainPot;\r\n\t\t\tbonusPot = _nextBonusPot;\r\n\r\n\t\t\t// Reset first and second and King\r\n\t\t\tfirst = null_address;\r\n\t\t\tsecond = null_address;\r\n\t\t\tplayers[owner].roundLastPlayed = round;\r\n\t\t\tplayers[owner].points = 0;\r\n\t\t\tplayers[king].roundLastPlayed = round;\r\n\t\t\tplayers[king].points = 0;\r\n\t\t\tking = owner;\r\n\t\t\tcrownedTime = now;\r\n\r\n\t\t\tNewRound(now, round, mainPot, bonusPot);\r\n\t\t\tPlaceChange(now, first, second, players[first].points, players[second].points);\r\n\t\t}\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t// Calculates the points a player earned in a given timer interval\r\n\tfunction calculatePoints(uint _earlierTime, uint _laterTime) private pure returns (uint) {\r\n\t\t// Earlier time could be the same as latertime (same block)\r\n\t\t// But it should never be later than laterTime!\r\n\t\tassert(_earlierTime <= _laterTime);\r\n\r\n\t\t// If crowned and dethroned on same block, no points\r\n\t\tif (_earlierTime == _laterTime) { return 0; }\r\n\r\n\t\t// Calculate points. Less than 1 minute is no payout\r\n\t\tuint timeElapsedInSeconds = _laterTime.sub(_earlierTime);\r\n\t\tif (timeElapsedInSeconds < 60) { return 0; }\r\n\r\n\t\tuint timeElapsedInMinutes = timeElapsedInSeconds.div(60);\r\n\t\tassert(timeElapsedInMinutes > 0);\r\n\r\n\t\t// 1000 minutes is an automatic win.\r\n\t\tif (timeElapsedInMinutes >= 1000) { return POINTS_TO_WIN; }\r\n\r\n\t\treturn timeElapsedInMinutes**POINT_EXPONENT;\r\n\t}\r\n\r\n\t// Pays out current King\r\n\t// Advances round, if necessary\r\n\t// Makes sender King\r\n\t// Reverts if bid isn't high enough\r\n\tfunction becomeKing() public payable\r\n\t\tpayoutOldKingPoints\r\n\t\tadvanceRoundIfNeeded\r\n\t{\r\n\t\t// Calculate minimum bid amount\r\n\t\tuint _minLeaderAmount = mainPot.mul(MIN_LEADER_FRAC_TOP).div(MIN_LEADER_FRAC_BOT);\r\n\t\trequire(msg.value >= _minLeaderAmount);\r\n\r\n\t\tuint _bidAmountToDeveloper = msg.value.mul(DEV_FEE_FRAC_TOP).div(DEV_FEE_FRAC_BOT);\r\n\t\tuint _bidAmountToBonusPot = msg.value.mul(BONUS_POT_FRAC_TOP).div(BONUS_POT_FRAC_BOT);\r\n\t\tuint _bidAmountToMainPot = msg.value.sub(_bidAmountToDeveloper).sub(_bidAmountToBonusPot);\r\n\r\n\t\tassert(_bidAmountToDeveloper + _bidAmountToBonusPot + _bidAmountToMainPot <= msg.value);\r\n\r\n\t\t// Transfer dev fee to owner's winnings\r\n\t\tplayers[owner].winnings = players[owner].winnings.add(_bidAmountToDeveloper);\r\n\r\n\t\t// Set new pot values\r\n\t\tmainPot = mainPot.add(_bidAmountToMainPot);\r\n\t\tbonusPot = bonusPot.add(_bidAmountToBonusPot);\r\n\r\n\t\t// Clear out King's points if they are from last round\r\n\t\tif (players[king].roundLastPlayed != round) {\r\n\t\t\tplayers[king].points = 0;\t\r\n\t\t}\r\n\t\t\r\n\t\t// Set King\r\n\t\tking = msg.sender;\r\n\t\tplayers[king].roundLastPlayed = round;\r\n\t\tcrownedTime = now;\r\n\r\n\t\tNewKingBid(now, king, msg.value, mainPot, bonusPot);\r\n\t}\r\n\r\n\t// Transfer players their winnings\r\n\tfunction withdrawEarnings() public {\r\n\t\trequire(players[msg.sender].winnings > 0);\r\n\t\tassert(players[msg.sender].winnings <= this.balance);\r\n\r\n\t\tuint _amount = players[msg.sender].winnings;\r\n\t\tplayers[msg.sender].winnings = 0;\r\n\r\n\t\tEarningsWithdrawal(now, msg.sender, _amount);\r\n\r\n\t\tmsg.sender.transfer(_amount);\r\n\t}\r\n\r\n\t// Fallback function.\r\n\t// If 0 ether, triggers tryAdvance()\r\n\t// If > 0 ether, triggers becomeKing()\r\n\tfunction () public payable {\r\n\t\tif (msg.value == 0) { tryAdvance(); }\r\n\t\telse { becomeKing(); }\r\n\t}\r\n\r\n\t// Utility function to advance the round / payout the winner\r\n\tfunction tryAdvance() public {\r\n\t\t// Calculate the King's current points.\r\n\t\t// If he's won, we payout and advance the round.\r\n\t\t// Equivalent to a bid, but without an actual bid.\r\n\t\tuint kingTotalPoints = calculatePoints(crownedTime, now) + players[king].points;\r\n\t\tif (kingTotalPoints >= POINTS_TO_WIN) { forceAdvance(); }\r\n\t}\r\n\r\n\t// Internal function called by tryAdvance if current King has won\r\n\tfunction forceAdvance() private payoutOldKingPoints advanceRoundIfNeeded { }\r\n\t\r\n\t// Gets a player's information\r\n\tfunction getPlayerInfo(address _player) public constant returns(uint, uint, uint) {\r\n\t\treturn (players[_player].points, players[_player].roundLastPlayed, players[_player].winnings);\r\n\t}\r\n\t\r\n\t// Gets the sender's information\r\n\tfunction getMyInfo() public constant returns(uint, uint, uint) {\r\n\t\treturn getPlayerInfo(msg.sender);\t\t\r\n\t}\r\n\t\r\n\t// Get the King's current points\r\n\tfunction getKingPoints() public constant returns(uint) { return players[king].points; }\r\n\t\r\n\t// Get the first player's current points\r\n\tfunction getFirstPoints() public constant returns(uint) { return players[first].points; }\r\n\t\r\n\t// Get the second player's current points\r\n\tfunction getSecondPoints() public constant returns(uint) { return players[second].points; }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"first\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getPlayerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"second\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"becomeKing\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tryAdvance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKingPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crownedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSecondPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"king\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_initialMainPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_initialBonusPot\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newMainPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBonusPot\",\"type\":\"uint256\"}],\"name\":\"NewKingBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newFirst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newSecond\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_firstPoints\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_secondPoints\",\"type\":\"uint256\"}],\"name\":\"PlaceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_first\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_firstAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_second\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_secondAmount\",\"type\":\"uint256\"}],\"name\":\"Winner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"EarningsWithdrawal\",\"type\":\"event\"}]","ContractName":"EthKing","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8a4aaa6f85a6a433f39d3418c1d8d543cbbfefb4389aca39f408d0999542d49a"}]}