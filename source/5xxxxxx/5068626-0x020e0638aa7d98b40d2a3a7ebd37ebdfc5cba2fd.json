{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract EtherBags {\r\n  // Bag sold event\r\n  event BagSold(\r\n    uint256 bagId,\r\n    uint256 multiplier,\r\n    uint256 oldPrice,\r\n    uint256 newPrice,\r\n    address prevOwner,\r\n    address newOwner\r\n  );\r\n\r\n  // Address of the contract creator\r\n  address public contractOwner;\r\n\r\n  // Default timeout is 4 hours\r\n  uint256 public timeout = 4 hours;\r\n\r\n  // Default starting price is 0.005 ether\r\n  uint256 public startingPrice = 0.005 ether;\r\n\r\n  Bag[] private bags;\r\n\r\n  struct Bag {\r\n    address owner;\r\n    uint256 level;\r\n    uint256 multiplier; // Multiplier must be rate * 100. example: 1.5x == 150\r\n    uint256 purchasedAt;\r\n  }\r\n\r\n  /// Access modifier for contract owner only functionality\r\n  modifier onlyContractOwner() {\r\n    require(msg.sender == contractOwner);\r\n    _;\r\n  }\r\n\r\n  function EtherBags() public {\r\n    contractOwner = msg.sender;\r\n    createBag(200);\r\n    createBag(200);\r\n    createBag(200);\r\n    createBag(200);\r\n    createBag(150);\r\n    createBag(150);\r\n    createBag(150);\r\n    createBag(150);\r\n    createBag(125);\r\n    createBag(125);\r\n    createBag(125);\r\n    createBag(125);\r\n  }\r\n\r\n  function createBag(uint256 multiplier) public onlyContractOwner {\r\n    Bag memory bag = Bag({\r\n      owner: this,\r\n      level: 0,\r\n      multiplier: multiplier,\r\n      purchasedAt: 0\r\n    });\r\n\r\n    bags.push(bag);\r\n  }\r\n\r\n  function setTimeout(uint256 _timeout) public onlyContractOwner {\r\n    timeout = _timeout;\r\n  }\r\n\r\n  function setStartingPrice(uint256 _startingPrice) public onlyContractOwner {\r\n    startingPrice = _startingPrice;\r\n  }\r\n\r\n  function setBagMultiplier(uint256 bagId, uint256 multiplier) public onlyContractOwner {\r\n    Bag storage bag = bags[bagId];\r\n    bag.multiplier = multiplier;\r\n  }\r\n\r\n  function getBag(uint256 bagId) public view returns (\r\n    address owner,\r\n    uint256 sellingPrice,\r\n    uint256 nextSellingPrice,\r\n    uint256 level,\r\n    uint256 multiplier,\r\n    uint256 purchasedAt\r\n  ) {\r\n    Bag storage bag = bags[bagId];\r\n\r\n    owner = bag.owner;\r\n    level = getBagLevel(bag);\r\n    sellingPrice = getBagSellingPrice(bag);\r\n    nextSellingPrice = getNextBagSellingPrice(bag);\r\n    multiplier = bag.multiplier;\r\n    purchasedAt = bag.purchasedAt;\r\n  }\r\n\r\n  function getBagCount() public view returns (uint256 bagCount) {\r\n    return bags.length;\r\n  }\r\n\r\n  function deleteBag(uint256 bagId) public onlyContractOwner {\r\n    delete bags[bagId];\r\n  }\r\n\r\n  function purchase(uint256 bagId) public payable {\r\n    Bag storage bag = bags[bagId];\r\n\r\n    address oldOwner = bag.owner;\r\n    address newOwner = msg.sender;\r\n\r\n    // Making sure token owner is not sending to self\r\n    require(oldOwner != newOwner);\r\n\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_addressNotNull(newOwner));\r\n    \r\n    uint256 sellingPrice = getBagSellingPrice(bag);\r\n\r\n    // Making sure sent amount is greater than or equal to the sellingPrice\r\n    require(msg.value >= sellingPrice);\r\n\r\n    // Take a transaction fee\r\n    uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 92), 100));\r\n    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\r\n\r\n    uint256 level = getBagLevel(bag);\r\n    bag.level = SafeMath.add(level, 1);\r\n    bag.owner = newOwner;\r\n    bag.purchasedAt = now;\r\n\r\n    // Pay previous tokenOwner if owner is not contract\r\n    if (oldOwner != address(this)) {\r\n      oldOwner.transfer(payment);\r\n    }\r\n\r\n    // Trigger BagSold event\r\n    BagSold(bagId, bag.multiplier, sellingPrice, getBagSellingPrice(bag), oldOwner, newOwner);\r\n\r\n    newOwner.transfer(purchaseExcess);\r\n  }\r\n\r\n  function payout() public onlyContractOwner {\r\n    contractOwner.transfer(this.balance);\r\n  }\r\n\r\n  /*** PRIVATE FUNCTIONS ***/\r\n\r\n  // If a bag hasn't been purchased in over $timeout,\r\n  // reset its level back to 0 but retain the existing owner\r\n  function getBagLevel(Bag bag) private view returns (uint256) {\r\n    if (now <= (SafeMath.add(bag.purchasedAt, timeout))) {\r\n      return bag.level;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function getBagSellingPrice(Bag bag) private view returns (uint256) {\r\n    uint256 level = getBagLevel(bag);\r\n    return getPriceForLevel(bag, level);\r\n  }\r\n\r\n  function getNextBagSellingPrice(Bag bag) private view returns (uint256) {\r\n    uint256 level = SafeMath.add(getBagLevel(bag), 1);\r\n    return getPriceForLevel(bag, level);\r\n  }\r\n\r\n  function getPriceForLevel(Bag bag, uint256 level) private view returns (uint256) {\r\n    uint256 sellingPrice = startingPrice;\r\n\r\n    for (uint256 i = 0; i < level; i++) {\r\n      sellingPrice = SafeMath.div(SafeMath.mul(sellingPrice, bag.multiplier), 100);\r\n    }\r\n\r\n    return sellingPrice;\r\n  }\r\n\r\n  /// Safety check on _to address to prevent against an unexpected 0x0 default.\r\n  function _addressNotNull(address _to) private pure returns (bool) {\r\n    return _to != address(0);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_startingPrice\",\"type\":\"uint256\"}],\"name\":\"setStartingPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"deleteBag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"createBag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timeout\",\"type\":\"uint256\"}],\"name\":\"setTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bagId\",\"type\":\"uint256\"},{\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"setBagMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"getBag\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"sellingPrice\",\"type\":\"uint256\"},{\"name\":\"nextSellingPrice\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"multiplier\",\"type\":\"uint256\"},{\"name\":\"purchasedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBagCount\",\"outputs\":[{\"name\":\"bagCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bagId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"multiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"BagSold\",\"type\":\"event\"}]","ContractName":"EtherBags","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5b3aef16dc991dfa92f26a009ff1878da01b4ad4c8d2e70d747a5aa571fc0413"}]}