{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancy_lock);\r\n    reentrancy_lock = true;\r\n    _;\r\n    reentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\ncontract Ethery is Pausable, ReentrancyGuard{\r\n  event NewBet(uint id, address player, uint wager, uint targetBlock);\r\n  event BetResolved(uint id, BetStatus status);\r\n  \r\n  bytes32 constant byteMask = bytes32(0xF);\r\n\r\n  enum BetStatus { Pending, PlayerWon, HouseWon, Refunded }\r\n  \r\n  struct Bet {\r\n    address player;\r\n    uint wager;\r\n    uint digits;\r\n    bytes32 guess;\r\n    BetStatus status;\r\n    uint targetBlock;\r\n  }\r\n  \r\n  Bet[] public bets;\r\n  \r\n  mapping (uint => address) public betToOwner;\r\n  mapping (address => uint) ownerBetCount;\r\n  \r\n  uint resolverFee = 0.1 finney;\r\n  uint maxPayout = 1 ether;\r\n  uint pendingPay;\r\n  \r\n  function setResolverFee(uint _resolverFee) external onlyOwner {\r\n    resolverFee = _resolverFee;\r\n  }\r\n  \r\n  function getResolverFee() external view returns (uint){\r\n    return resolverFee;\r\n  }\r\n  \r\n  function setMaxPayout(uint _maxPayout) external onlyOwner {\r\n    maxPayout = _maxPayout;\r\n  }\r\n\r\n  function getMaxPayout() external view returns (uint){\r\n    return maxPayout;\r\n  }\r\n  \r\n  function withDraw(uint _amount) external onlyOwner {\r\n    require(_amount < this.balance - pendingPay);\r\n    msg.sender.transfer(_amount);\r\n  }\r\n  \r\n  function () public payable {}\r\n  \r\n  function createBet(uint _digits, bytes32 _guess, uint _targetBlock) public payable whenNotPaused {\r\n    require(\r\n      msg.value >= resolverFee &&\r\n      _targetBlock > block.number &&\r\n      block.number + 256 >= _targetBlock &&\r\n      payout(msg.value, _digits) <= maxPayout &&\r\n      payout(msg.value, _digits) <= this.balance - pendingPay\r\n    );\r\n    uint id = bets.push(Bet(msg.sender, msg.value, _digits, _guess, BetStatus.Pending, _targetBlock)) - 1;\r\n    betToOwner[id] = msg.sender;\r\n    ownerBetCount[msg.sender]++;\r\n    pendingPay += payout(msg.value, _digits);\r\n    NewBet(id, msg.sender, msg.value, _targetBlock);\r\n  }\r\n  \r\n  function resolveBet(uint _betId) public nonReentrant {\r\n    Bet storage myBet = bets[_betId];  \r\n    require(\r\n      myBet.status == BetStatus.Pending &&    // only resolve pending bets\r\n      myBet.targetBlock < block.number        // only resolve targetBlock > current block\r\n    );\r\n    \r\n    pendingPay -= payout(myBet.wager, uint(myBet.digits));\r\n    \r\n    if (myBet.targetBlock + 255 < block.number) {    // too late to determine out come issue refund\r\n      myBet.status = BetStatus.Refunded;\r\n      betToOwner[_betId].transfer(myBet.wager);\r\n    } else {\r\n      bytes32 targetBlockHash = block.blockhash(myBet.targetBlock);\r\n      if (isCorrectGuess(targetBlockHash, myBet.guess, uint(myBet.digits))) {\r\n        myBet.status = BetStatus.PlayerWon;\r\n        betToOwner[_betId].transfer(payout(myBet.wager, uint(myBet.digits)));\r\n      } else {\r\n        myBet.status = BetStatus.HouseWon;\r\n      }\r\n    }\r\n    msg.sender.transfer(resolverFee);\r\n    BetResolved(_betId, myBet.status);\r\n  }\r\n  \r\n  function isCorrectGuess(bytes32 _blockHash, bytes32 _guess, uint _digits) public pure returns (bool) {\r\n    for (uint i = 0; i < uint(_digits); i++) {\r\n      if (byteMask & _guess != _blockHash & byteMask) {\r\n        return false;\r\n      }\r\n      _blockHash = _blockHash >> 4;\r\n      _guess = _guess >> 4;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  function payout(uint _wager, uint _digits) public view returns (uint) {\r\n    uint baseWager = (100 - houseFee(_digits)) * (_wager - resolverFee) / 100;\r\n    return baseWager * 16 ** _digits;\r\n  }\r\n  \r\n  function houseFee(uint _digits) public pure returns (uint) {    // in percent\r\n    require(0 < _digits && _digits <= 4);\r\n    if (_digits == 1) { return 2; }\r\n    else if(_digits == 2) { return 3; }\r\n    else if(_digits == 3) { return 4; }\r\n    else { return 5; }\r\n  }\r\n  \r\n  function getBet(uint index) public view returns(address, uint, uint, bytes32, BetStatus, uint) {\r\n    return (bets[index].player, bets[index].wager, bets[index].digits, bets[index].guess, bets[index].status, bets[index].targetBlock);\r\n  }\r\n  \r\n  function getPlayerBets() external view returns(uint[]) {\r\n    return getBetsByOwner(msg.sender);  \r\n  }\r\n  \r\n  function getBetsByOwner(address _owner) private view returns(uint[]) {\r\n    uint[] memory result = new uint[](ownerBetCount[_owner]);\r\n    uint counter = 0;\r\n    for (uint i = 0; i < bets.length; i++) {\r\n      if (betToOwner[i] == _owner) {\r\n        result[counter] = i;\r\n        counter++;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  \r\n  function getTotalWins() external view returns(uint) {\r\n    uint pays = 0;\r\n    for (uint i = 0; i < bets.length; i++) {\r\n      if (bets[i].status == BetStatus.PlayerWon) {\r\n        pays += payout(bets[i].wager, bets[i].digits);\r\n      }\r\n    }\r\n    return pays;\r\n  }\r\n\r\n  function recentWinners() external view returns(uint[]) {\r\n    uint len = 5;\r\n    uint[] memory result = new uint[](len);\r\n    uint counter = 0;\r\n\r\n    for (uint i = 1; i <= bets.length && counter < len; i++) {\r\n      if (bets[bets.length - i].status == BetStatus.PlayerWon) {\r\n        result[counter] = bets.length - i;\r\n        counter++;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_digits\",\"type\":\"uint256\"}],\"name\":\"houseFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"name\":\"_guess\",\"type\":\"bytes32\"},{\"name\":\"_digits\",\"type\":\"uint256\"}],\"name\":\"isCorrectGuess\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"wager\",\"type\":\"uint256\"},{\"name\":\"digits\",\"type\":\"uint256\"},{\"name\":\"guess\",\"type\":\"bytes32\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"targetBlock\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_betId\",\"type\":\"uint256\"}],\"name\":\"resolveBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxPayout\",\"type\":\"uint256\"}],\"name\":\"setMaxPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wager\",\"type\":\"uint256\"},{\"name\":\"_digits\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_digits\",\"type\":\"uint256\"},{\"name\":\"_guess\",\"type\":\"bytes32\"},{\"name\":\"_targetBlock\",\"type\":\"uint256\"}],\"name\":\"createBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_resolverFee\",\"type\":\"uint256\"}],\"name\":\"setResolverFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getResolverFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalWins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recentWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wager\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"targetBlock\",\"type\":\"uint256\"}],\"name\":\"NewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"BetResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Ethery","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2e136dbaa8c06a627e2ee9a8ab43c582135cfd60c5e56627dcf8757dd0b9e2e5"}]}