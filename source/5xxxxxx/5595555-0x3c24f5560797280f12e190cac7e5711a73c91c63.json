{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface ERC20TokenInterface {\r\n    function totalSupply() public constant returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ninterface TokenVestingInterface {\r\n    function getReleasableFunds() public view returns(uint256);\r\n    function release() public ;\r\n    function setWithdrawalAddress(address _newAddress) external;\r\n    function revoke(string _reason) public;\r\n    function getTokenBalance() public constant returns(uint256);\r\n    function updateBalanceOnFunding(uint256 _amount) external;\r\n    function salvageOtherTokensFromContract(address _tokenAddress, address _to, uint _amount) external;\r\n}\r\n\r\n\r\ninterface VestingMasterInterface{\r\n    function amountLockedInVestings() view public returns (uint256);\r\n    function substractLockedAmount(uint256 _amount) external;\r\n    function addLockedAmount(uint256 _amount) external;\r\n    function addInternalBalance(uint256 _amount) external;\r\n}\r\n\r\ncontract TokenVestingContract is Owned {\r\n    using SafeMath for uint256;\r\n    \r\n    address public beneficiary;\r\n    address public tokenAddress;\r\n    uint256 public startTime;\r\n    uint256 public tickDuration;\r\n    uint256 public amountPerTick;\r\n    uint256 public version;\r\n    bool public revocable;\r\n    \r\n\r\n    uint256 public alreadyReleasedAmount;\r\n    bool public revoked;\r\n    uint256 public internalBalance;\r\n    \r\n    event Released(uint256 amount);\r\n    event RevokedAndDestroyed(string reason);\r\n    event WithdrawalAddressSet(address _newAddress);\r\n    event TokensReceivedSinceLastCheck(uint256 amount);\r\n    event VestingReceivedFunding(uint256 amount);\r\n\r\n    function TokenVestingContract(address _beneficiary,\r\n                address _tokenAddress,\r\n                uint256 _startTime, \r\n                uint256 _tickDuration, \r\n                uint256 _amountPerTick,\r\n                uint256 _version,\r\n                bool _revocable\r\n                )public onlyOwner{\r\n                    beneficiary = _beneficiary;\r\n                    tokenAddress = _tokenAddress;\r\n                    startTime = _startTime;\r\n                    tickDuration = _tickDuration;\r\n                    amountPerTick = _amountPerTick;\r\n                    version =  _version;\r\n                    revocable = _revocable;\r\n                    alreadyReleasedAmount = 0;\r\n                    revoked = false;\r\n                    internalBalance = 0;\r\n    }\r\n    \r\n    function getReleasableFunds() public view returns(uint256){\r\n        uint256 balance = ERC20TokenInterface(tokenAddress).balanceOf(address(this));\r\n        // check if there is balance and if it is active yet\r\n        if (balance == 0 || (startTime >= now)){\r\n            return 0;\r\n        }\r\n        // all funds that may be released according to vesting schedule \r\n        uint256 vestingScheduleAmount = (now.sub(startTime) / tickDuration) * amountPerTick;\r\n        // deduct already released funds \r\n        uint256 releasableFunds = vestingScheduleAmount.sub(alreadyReleasedAmount);\r\n        // make sure to release remainder of funds for last payout\r\n        if(releasableFunds > balance){\r\n            releasableFunds = balance;\r\n        }\r\n        return releasableFunds;\r\n    }\r\n    \r\n    function setWithdrawalAddress(address _newAddress) public onlyOwner {\r\n        beneficiary = _newAddress;\r\n        \r\n        emit WithdrawalAddressSet(_newAddress);\r\n    }\r\n    \r\n    function release() public returns(uint256 transferedAmount) {\r\n        checkForReceivedTokens();\r\n        require(msg.sender == beneficiary);//, \"Funds may be released only to beneficiary\");\r\n        uint256 amountToTransfer = getReleasableFunds();\r\n        require(amountToTransfer > 0);//, \"Out of funds\");\r\n        // internal accounting\r\n        alreadyReleasedAmount = alreadyReleasedAmount.add(amountToTransfer);\r\n        internalBalance = internalBalance.sub(amountToTransfer);\r\n        VestingMasterInterface(owner).substractLockedAmount(amountToTransfer);\r\n        // actual transfer\r\n        ERC20TokenInterface(tokenAddress).transfer(beneficiary, amountToTransfer);\r\n        emit Released(amountToTransfer);\r\n        return amountToTransfer;\r\n    }\r\n    \r\n    function revoke(string _reason) external onlyOwner {\r\n        require(revocable);\r\n        // returns funds not yet vested according to vesting schedule\r\n        uint256 releasableFunds = getReleasableFunds();\r\n        ERC20TokenInterface(tokenAddress).transfer(beneficiary, releasableFunds);\r\n        VestingMasterInterface(owner).substractLockedAmount(releasableFunds);  // have to do it here, can't use return, because contract selfdestructs\r\n        // returns remainder of funds to VestingMaster and kill vesting contract\r\n        VestingMasterInterface(owner).addInternalBalance(getTokenBalance());\r\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\r\n        emit RevokedAndDestroyed(_reason);\r\n        selfdestruct(owner);\r\n    }\r\n    \r\n    function getTokenBalance() public view returns(uint256 tokenBalance) {\r\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\r\n    }\r\n    // todo public or internal?\r\n    // master calls this when it uploads funds in order to differentiate betwen funds from master and 3rd party\r\n    function updateBalanceOnFunding(uint256 _amount) external onlyOwner{\r\n        internalBalance = internalBalance.add(_amount);\r\n        emit VestingReceivedFunding(_amount);\r\n    }\r\n    // check for changes in balance in order to track amount of locked tokens and notify master\r\n    function checkForReceivedTokens() public{\r\n        if (getTokenBalance() != internalBalance){\r\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\r\n            internalBalance = getTokenBalance();\r\n            VestingMasterInterface(owner).addLockedAmount(receivedFunds);\r\n            emit TokensReceivedSinceLastCheck(receivedFunds);\r\n        }\r\n    }\r\n    function salvageOtherTokensFromContract(address _tokenAddress, address _to, uint _amount) external onlyOwner {\r\n        require(_tokenAddress != tokenAddress);\r\n        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n}\r\n\r\n\r\ncontract VestingMasterContract is Owned {\r\n    using SafeMath for uint256;\r\n   \r\n    // TODO: set this before deploy\r\n    address public constant tokenAddress = 0xc7C03B8a3FC5719066E185ea616e87B88eba44a3;   \r\n    uint256 public internalBalance = 0;\r\n    uint256 public amountLockedInVestings = 0;\r\n    \r\n    struct VestingStruct{\r\n        uint256 arrayPointer;\r\n        string vestingType;\r\n        uint256 version;\r\n        \r\n    }\r\n    address[] public vestingAddresses;\r\n    mapping (address => VestingStruct) public addressToVesting;\r\n    \r\n    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\r\n    event LockedAmountDecreased(uint256 amount);\r\n    event LockedAmountIncreased(uint256 amount);\r\n    event TokensReceivedSinceLastCheck(uint256 amount);\r\n\r\n    ////////// STORAGE HELPERS  ///////////\r\n    function vestingExists(address _vestingAddress) public view returns(bool exists){\r\n        if(vestingAddresses.length == 0) {return false;}\r\n        return (vestingAddresses[addressToVesting[_vestingAddress].arrayPointer] == _vestingAddress);\r\n    }\r\n    \r\n    function storeNewVesting(address _vestingAddress, string _vestingType, uint256 _version) public onlyOwner returns(uint256 vestingsLength) {\r\n        require(!vestingExists(_vestingAddress));\r\n        addressToVesting[_vestingAddress].version = _version;\r\n        addressToVesting[_vestingAddress].vestingType = _vestingType ;\r\n        addressToVesting[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\r\n        return vestingAddresses.length;\r\n    }\r\n\r\n    function deleteVestingFromStorage(address _vestingAddress) public onlyOwner returns(uint256 vestingsLength) {\r\n        require(vestingExists(_vestingAddress));\r\n        uint256 indexToDelete = addressToVesting[_vestingAddress].arrayPointer;\r\n        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\r\n        vestingAddresses[indexToDelete] = keyToMove;\r\n        addressToVesting[keyToMove].arrayPointer = indexToDelete;\r\n        vestingAddresses.length--;\r\n        return vestingAddresses.length;\r\n    }\r\n    \r\n    function createNewVesting(\r\n        // todo uncomment\r\n        address _beneficiary,\r\n        uint256 _startTime, \r\n        uint256 _tickDuration, \r\n        uint256 _amountPerTick,\r\n        string _vestingType,\r\n        uint256 _version,\r\n        bool _revocable\r\n        ) \r\n        \r\n        public onlyOwner returns(address){\r\n            TokenVestingContract newVesting = new TokenVestingContract(   \r\n                _beneficiary,\r\n                tokenAddress,\r\n                _startTime, \r\n                _tickDuration, \r\n                _amountPerTick,\r\n                _version,\r\n                _revocable\r\n                );\r\n           \r\n        storeNewVesting(newVesting, _vestingType, _version);\r\n        return newVesting;\r\n    }\r\n    \r\n    // add funds to vesting contract\r\n    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\r\n        // convenience, so you don't have to call it manualy if you just uploaded funds\r\n        checkForReceivedTokens();\r\n        // check if there is actually enough funds\r\n        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\r\n        // make sure that fundee is vesting contract on the list\r\n        require(vestingExists(_vestingContract)); \r\n        internalBalance = internalBalance.sub(_amount);\r\n        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\r\n        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\r\n        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\r\n    }\r\n    \r\n    function getTokenBalance() public constant returns(uint256) {\r\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\r\n    }\r\n    // revoke vesting; release releasable funds to beneficiary and return remaining to master and kill vesting contract\r\n    function revokeVesting(address _vestingContract, string _reason) public onlyOwner{\r\n        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\r\n        subVestingContract.revoke(_reason);\r\n        deleteVestingFromStorage(_vestingContract);\r\n    }\r\n    // when vesting is revoked it sends back remaining tokens and updates internalBalance\r\n    function addInternalBalance(uint256 _amount) external {\r\n        require(vestingExists(msg.sender));\r\n        internalBalance = internalBalance.add(_amount);\r\n    }\r\n    // vestings notifies if there has been any changes in amount of locked tokens\r\n    function addLockedAmount(uint256 _amount) external {\r\n        require(vestingExists(msg.sender));\r\n        amountLockedInVestings = amountLockedInVestings.add(_amount);\r\n        emit LockedAmountIncreased(_amount);\r\n    }\r\n    // vestings notifies if there has been any changes in amount of locked tokens\r\n    function substractLockedAmount(uint256 _amount) external {\r\n        require(vestingExists(msg.sender));\r\n        amountLockedInVestings = amountLockedInVestings.sub(_amount);\r\n        emit LockedAmountDecreased(_amount);\r\n    }\r\n    // check for changes in balance in order to track amount of locked tokens\r\n    function checkForReceivedTokens() public{\r\n        if (getTokenBalance() != internalBalance){\r\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\r\n            amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\r\n            internalBalance = getTokenBalance();\r\n            emit TokensReceivedSinceLastCheck(receivedFunds);\r\n        }else{\r\n        emit TokensReceivedSinceLastCheck(0);\r\n        }\r\n    }\r\n    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) public onlyOwner {\r\n        require(_tokenAddress != tokenAddress);\r\n        if (_contractAddress == address(this)){\r\n            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n        }\r\n        if (vestingExists(_contractAddress)){\r\n            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\r\n        }\r\n    }\r\n    \r\n    function killContract() public onlyOwner{\r\n        require(vestingAddresses.length == 0);\r\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\r\n        selfdestruct(owner);\r\n    }\r\n    function setWithdrawalAddress(address _vestingContract, address _beneficiary) public onlyOwner{\r\n        require(vestingExists(_vestingContract));\r\n        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\r\n    }\r\n}\r\n\r\n\r\ncontract EligmaSupplyContract  is Owned {\r\n    address public tokenAddress;\r\n    address public vestingMasterAddress;\r\n    \r\n    function EligmaSupplyContract(address _tokenAddress, address _vestingMasterAddress) public onlyOwner{\r\n        tokenAddress = _tokenAddress;\r\n        vestingMasterAddress = _vestingMasterAddress;\r\n    }\r\n    \r\n    function totalSupply() view public returns(uint256) {\r\n        return ERC20TokenInterface(tokenAddress).totalSupply();\r\n    }\r\n    \r\n    function lockedSupply() view public returns(uint256) {\r\n        return VestingMasterInterface(vestingMasterAddress).amountLockedInVestings();\r\n    }\r\n    \r\n    function avaliableSupply() view public returns(uint256) {\r\n        return ERC20TokenInterface(tokenAddress).totalSupply() - VestingMasterInterface(vestingMasterAddress).amountLockedInVestings();\r\n    }\r\n    \r\n    function setTokenAddress(address _tokenAddress) onlyOwner public {\r\n        tokenAddress = _tokenAddress;\r\n    }\r\n    \r\n    function setVestingMasterAddress(address _vestingMasterAddress) onlyOwner public {\r\n        vestingMasterAddress = _vestingMasterAddress;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_vestingContract\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setWithdrawalAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageOtherTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingAddress\",\"type\":\"address\"}],\"name\":\"deleteVestingFromStorage\",\"outputs\":[{\"name\":\"vestingsLength\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountLockedInVestings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"internalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingAddress\",\"type\":\"address\"},{\"name\":\"_vestingType\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"storeNewVesting\",\"outputs\":[{\"name\":\"vestingsLength\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addLockedAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingContract\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"revokeVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingContract\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fundVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vestingAddress\",\"type\":\"address\"}],\"name\":\"vestingExists\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_tickDuration\",\"type\":\"uint256\"},{\"name\":\"_amountPerTick\",\"type\":\"uint256\"},{\"name\":\"_vestingType\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"},{\"name\":\"_revocable\",\"type\":\"bool\"}],\"name\":\"createNewVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"substractLockedAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addInternalBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToVesting\",\"outputs\":[{\"name\":\"arrayPointer\",\"type\":\"uint256\"},{\"name\":\"vestingType\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkForReceivedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingContractFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedAmountDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedAmountIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensReceivedSinceLastCheck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"VestingMasterContract","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c42bbd874bd3c05f6cbf7d3c9b0dd2d1ca8183411ed46b01344900e2685e64fb"}]}