{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// ERC20 token protocol, see more details at\r\n// https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n// And also https://github.com/ethereum/eips/issues/20\r\n\r\ncontract Token {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  function totalSupply() constant returns (uint256 supply);\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n  function approve(address _spender, uint256 _value) returns (bool success);\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// Safe mathematics to make the code more readable\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\n// Ownable interface to simplify owner checks\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) onlyOwner {\r\n    require(_newOwner != address(0));\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// Interface for trading discounts and rebates for specific accounts\r\n\r\ncontract AccountModifiersInterface {\r\n  function accountModifiers(address _user) constant returns(uint takeFeeDiscount, uint rebatePercentage);\r\n  function tradeModifiers(address _maker, address _taker) constant returns(uint takeFeeDiscount, uint rebatePercentage);\r\n}\r\n\r\n// Interface for trade tacker\r\n\r\ncontract TradeTrackerInterface {\r\n  function tradeComplete(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, address _get, address _give, uint _takerFee, uint _makerRebate);\r\n}\r\n\r\n// Exchange contract\r\n\r\ncontract TokenStore is SafeMath, Ownable {\r\n\r\n  // The account that will receive fees\r\n  address feeAccount;\r\n\r\n  // The account that stores fee discounts/rebates\r\n  address accountModifiers;\r\n\r\n  // Trade tracker account\r\n  address tradeTracker;\r\n\r\n  // We charge only the takers and this is the fee, percentage times 1 ether\r\n  uint public fee;\r\n\r\n  // Mapping of token addresses to mapping of account balances (token 0 means Ether)\r\n  mapping (address => mapping (address => uint)) public tokens;\r\n\r\n  // Mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills;\r\n\r\n  // Address of a next and previous versions of the contract, also status of the contract\r\n  // can be used for user-triggered fund migrations\r\n  address public successor;\r\n  address public predecessor;\r\n  bool public deprecated;\r\n  uint16 public version;\r\n\r\n  // Logging events\r\n  // Note: Order creation is handled off-chain, see explanation further below\r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give, uint nonce);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n  event FundsMigrated(address user);\r\n\r\n  function TokenStore(uint _fee, address _predecessor) {\r\n    feeAccount = owner;\r\n    fee = _fee;\r\n    predecessor = _predecessor;\r\n    deprecated = false;\r\n    if (predecessor != address(0)) {\r\n      version = TokenStore(predecessor).version() + 1;\r\n    } else {\r\n      version = 1;\r\n    }\r\n  }\r\n\r\n  // Throw on default handler to prevent direct transactions of Ether\r\n  function() {\r\n    revert();\r\n  }\r\n\r\n  modifier deprecable() {\r\n    require(!deprecated);\r\n    _;\r\n  }\r\n\r\n  function deprecate(bool _deprecated, address _successor) onlyOwner {\r\n    deprecated = _deprecated;\r\n    successor = _successor;\r\n  }\r\n\r\n  function changeFeeAccount(address _feeAccount) onlyOwner {\r\n    require(_feeAccount != address(0));\r\n    feeAccount = _feeAccount;\r\n  }\r\n\r\n  function changeAccountModifiers(address _accountModifiers) onlyOwner {\r\n    accountModifiers = _accountModifiers;\r\n  }\r\n\r\n  function changeTradeTracker(address _tradeTracker) onlyOwner {\r\n    tradeTracker = _tradeTracker;\r\n  }\r\n\r\n  // Fee can only be decreased!\r\n  function changeFee(uint _fee) onlyOwner {\r\n    require(_fee <= fee);\r\n    fee = _fee;\r\n  }\r\n\r\n  // Allows a user to get her current discount/rebate\r\n  function getAccountModifiers() constant returns(uint takeFeeDiscount, uint rebatePercentage) {\r\n    if (accountModifiers != address(0)) {\r\n      return AccountModifiersInterface(accountModifiers).accountModifiers(msg.sender);\r\n    } else {\r\n      return (0, 0);\r\n    }\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Deposits, withdrawals, balances\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  function deposit() payable deprecable {\r\n    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function withdraw(uint _amount) {\r\n    require(tokens[0][msg.sender] >= _amount);\r\n    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);\r\n    if (!msg.sender.call.value(_amount)()) {\r\n      revert();\r\n    }\r\n    Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function depositToken(address _token, uint _amount) deprecable {\r\n    // Note that Token(_token).approve(this, _amount) needs to be called\r\n    // first or this contract will not be able to do the transfer.\r\n    require(_token != 0);\r\n    if (!Token(_token).transferFrom(msg.sender, this, _amount)) {\r\n      revert();\r\n    }\r\n    tokens[_token][msg.sender] = safeAdd(tokens[_token][msg.sender], _amount);\r\n    Deposit(_token, msg.sender, _amount, tokens[_token][msg.sender]);\r\n  }\r\n\r\n  function withdrawToken(address _token, uint _amount) {\r\n    require(_token != 0);\r\n    require(tokens[_token][msg.sender] >= _amount);\r\n    tokens[_token][msg.sender] = safeSub(tokens[_token][msg.sender], _amount);\r\n    if (!Token(_token).transfer(msg.sender, _amount)) {\r\n      revert();\r\n    }\r\n    Withdraw(_token, msg.sender, _amount, tokens[_token][msg.sender]);\r\n  }\r\n\r\n  function balanceOf(address _token, address _user) constant returns (uint) {\r\n    return tokens[_token][_user];\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Trading\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  // Note: Order creation happens off-chain but the orders are signed by creators,\r\n  // we validate the contents and the creator address in the logic below\r\n\r\n  function trade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,\r\n      uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount) {\r\n    bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    // Check order signatures and expiration, also check if not fulfilled yet\r\n\t\tif (ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash), _v, _r, _s) != _user ||\r\n      block.number > _expires ||\r\n      safeAdd(orderFills[_user][hash], _amount) > _amountGet) {\r\n      revert();\r\n    }\r\n    tradeBalances(_tokenGet, _amountGet, _tokenGive, _amountGive, _user, msg.sender, _amount);\r\n    orderFills[_user][hash] = safeAdd(orderFills[_user][hash], _amount);\r\n    Trade(_tokenGet, _amount, _tokenGive, _amountGive * _amount / _amountGet, _user, msg.sender, _nonce);\r\n  }\r\n\r\n  function tradeBalances(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,\r\n      address _user, address _caller, uint _amount) private {\r\n\r\n    uint feeTakeValue = safeMul(_amount, fee) / (1 ether);\r\n    uint rebateValue = 0;\r\n    uint tokenGiveValue = safeMul(_amountGive, _amount) / _amountGet; // Proportionate to request ratio\r\n\r\n    // Apply modifiers\r\n    if (accountModifiers != address(0)) {\r\n      var (feeTakeDiscount, rebatePercentage) = AccountModifiersInterface(accountModifiers).tradeModifiers(_user, _caller);\r\n      // Check that the discounts/rebates are never higher then 100%\r\n      if (feeTakeDiscount > 100) {\r\n        feeTakeDiscount = 0;\r\n      }\r\n      if (rebatePercentage > 100) {\r\n        rebatePercentage = 0;\r\n      }\r\n      feeTakeValue = safeMul(feeTakeValue, 100 - feeTakeDiscount) / 100;  // discounted fee\r\n      rebateValue = safeMul(rebatePercentage, feeTakeValue) / 100;        // % of actual taker fee\r\n    }\r\n\r\n    tokens[_tokenGet][_user] = safeAdd(tokens[_tokenGet][_user], safeAdd(_amount, rebateValue));\r\n    tokens[_tokenGet][_caller] = safeSub(tokens[_tokenGet][_caller], safeAdd(_amount, feeTakeValue));\r\n    tokens[_tokenGive][_user] = safeSub(tokens[_tokenGive][_user], tokenGiveValue);\r\n    tokens[_tokenGive][_caller] = safeAdd(tokens[_tokenGive][_caller], tokenGiveValue);\r\n    tokens[_tokenGet][feeAccount] = safeAdd(tokens[_tokenGet][feeAccount], safeSub(feeTakeValue, rebateValue));\r\n\r\n    if (tradeTracker != address(0)) {\r\n      TradeTrackerInterface(tradeTracker).tradeComplete(_tokenGet, _amount, _tokenGive, tokenGiveValue, _user, _caller, feeTakeValue, rebateValue);\r\n    }\r\n  }\r\n\r\n  function testTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\r\n      uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _sender) constant returns(bool) {\r\n    if (tokens[_tokenGet][_sender] < _amount ||\r\n      availableVolume(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s) < _amount) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function availableVolume(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\r\n      uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s) constant returns(uint) {\r\n    bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    if (ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash), _v, _r, _s) != _user ||\r\n      block.number > _expires) {\r\n      return 0;\r\n    }\r\n    uint available1 = safeSub(_amountGet, orderFills[_user][hash]);\r\n    uint available2 = safeMul(tokens[_tokenGive][_user], _amountGet) / _amountGive;\r\n    if (available1 < available2) return available1;\r\n    return available2;\r\n  }\r\n\r\n  function amountFilled(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\r\n      uint _nonce, address _user) constant returns(uint) {\r\n    bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    return orderFills[_user][hash];\r\n  }\r\n\r\n  function cancelOrder(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive, uint _expires,\r\n      uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) {\r\n    bytes32 hash = sha256(this, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    if (!(ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash), _v, _r, _s) == msg.sender)) {\r\n      revert();\r\n    }\r\n    orderFills[msg.sender][hash] = _amountGet;\r\n    Cancel(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, msg.sender, _v, _r, _s);\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Migrations\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  // User-triggered (!) fund migrations in case contract got updated\r\n  // Similar to withdraw but we use a successor account instead\r\n  // As we don't store user tokens list on chain, it has to be passed from the outside\r\n  function migrateFunds(address[] _tokens) {\r\n\r\n    // Get the latest successor in the chain\r\n    require(successor != address(0));\r\n    TokenStore newExchange = TokenStore(successor);\r\n    for (uint16 n = 0; n < 20; n++) {  // We will look past 20 contracts in the future\r\n      address nextSuccessor = newExchange.successor();\r\n      if (nextSuccessor == address(this)) {  // Circular succession\r\n        revert();\r\n      }\r\n      if (nextSuccessor == address(0)) { // We reached the newest, stop\r\n        break;\r\n      }\r\n      newExchange = TokenStore(nextSuccessor);\r\n    }\r\n\r\n    // Ether\r\n    uint etherAmount = tokens[0][msg.sender];\r\n    if (etherAmount > 0) {\r\n      tokens[0][msg.sender] = 0;\r\n      newExchange.depositForUser.value(etherAmount)(msg.sender);\r\n    }\r\n\r\n    // Tokens\r\n    for (n = 0; n < _tokens.length; n++) {\r\n      address token = _tokens[n];\r\n      require(token != address(0)); // 0 = Ether, we handle it above\r\n      uint tokenAmount = tokens[token][msg.sender];\r\n      if (tokenAmount == 0) {\r\n        continue;\r\n      }\r\n      if (!Token(token).approve(newExchange, tokenAmount)) {\r\n        revert();\r\n      }\r\n      tokens[token][msg.sender] = 0;\r\n      newExchange.depositTokenForUser(token, tokenAmount, msg.sender);\r\n    }\r\n\r\n    FundsMigrated(msg.sender);\r\n  }\r\n\r\n  // This is used for migrations only. To be called by previous exchange only,\r\n  // user-triggered, on behalf of the user called the migrateFunds method.\r\n  // Note that it does exactly the same as depositToken, but as this is called\r\n  // by a previous generation of exchange itself, we credit internally not the\r\n  // previous exchange, but the user it was called for.\r\n  function depositForUser(address _user) payable deprecable {\r\n    require(_user != address(0));\r\n    require(msg.value > 0);\r\n    TokenStore caller = TokenStore(msg.sender);\r\n    require(caller.version() > 0); // Make sure it's an exchange account\r\n    tokens[0][_user] = safeAdd(tokens[0][_user], msg.value);\r\n  }\r\n\r\n  function depositTokenForUser(address _token, uint _amount, address _user) deprecable {\r\n    require(_token != address(0));\r\n    require(_user != address(0));\r\n    require(_amount > 0);\r\n    TokenStore caller = TokenStore(msg.sender);\r\n    require(caller.version() > 0); // Make sure it's an exchange account\r\n    if (!Token(_token).transferFrom(msg.sender, this, _amount)) {\r\n      revert();\r\n    }\r\n    tokens[_token][_user] = safeAdd(tokens[_token][_user], _amount);\r\n  }\r\n}\r\n\r\ncontract InstantTrade is SafeMath, Ownable {\r\n\r\n  // This is needed so we can withdraw funds from other smart contracts\r\n  function() payable {\r\n  }\r\n  \r\n  // End to end trading in a single call\r\n  function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,\r\n      uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {\r\n    \r\n    // Fix max fee (0.4%) and always reserve it\r\n    uint totalValue = safeMul(_amount, 1004) / 1000;\r\n    \r\n    // Paying with Ethereum or token? Deposit to the actual store\r\n    if (_tokenGet == address(0)) {\r\n      // Check amount of ether sent to make sure it's correct\r\n      if (msg.value != totalValue) {\r\n        revert();\r\n      }\r\n      TokenStore(_store).deposit.value(totalValue)();\r\n    } else {\r\n      // Assuming user already approved transfer, transfer first to this contract\r\n      if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {\r\n        revert();\r\n      }\r\n      // Allow now actual store to deposit\r\n      if (!Token(_tokenGet).approve(_store, totalValue)) {\r\n        revert();\r\n      }\r\n      TokenStore(_store).depositToken(_tokenGet, totalValue);\r\n    }\r\n    \r\n    // Trade\r\n    TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,\r\n      _expires, _nonce, _user, _v, _r, _s, _amount);\r\n    \r\n    // Check how much did we get and how much should we send back\r\n    totalValue = TokenStore(_store).balanceOf(_tokenGive, this);\r\n    uint customerValue = safeMul(_amountGive, _amount) / _amountGet;\r\n    \r\n    // Now withdraw all the funds into this contract and then pass to the user\r\n    if (_tokenGive == address(0)) {\r\n      TokenStore(_store).withdraw(totalValue);\r\n      msg.sender.transfer(customerValue);\r\n    } else {\r\n      TokenStore(_store).withdrawToken(_tokenGive, totalValue);\r\n      if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {\r\n        revert();\r\n      }\r\n    }\r\n  }\r\n  \r\n  function withdrawFees(address _token) onlyOwner {\r\n    if (_token == address(0)) {\r\n      msg.sender.transfer(this.balance);\r\n    } else {\r\n      uint amount = Token(_token).balanceOf(this);\r\n      if (!Token(_token).transfer(msg.sender, amount)) {\r\n        revert();\r\n      }\r\n    }\r\n  }  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenGet\",\"type\":\"address\"},{\"name\":\"_amountGet\",\"type\":\"uint256\"},{\"name\":\"_tokenGive\",\"type\":\"address\"},{\"name\":\"_amountGive\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_store\",\"type\":\"address\"}],\"name\":\"instantTrade\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"InstantTrade","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://81a354272428a9b8d3f961d3793825f26e08c07debe709d8815e1c110f5698c2"}]}