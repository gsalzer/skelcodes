{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Governable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    address public governor;\r\n    bool public paused = false;\r\n\r\n    constructor() public {\r\n        governor = msg.sender;\r\n    }\r\n\r\n    function setGovernor(address _gov) public onlyGovernor {\r\n        governor = _gov;\r\n    }\r\n\r\n    modifier onlyGovernor {\r\n        require(msg.sender == governor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyGovernor whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyGovernor whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n}\r\n\r\ncontract CardBase is Governable {\r\n\r\n\r\n    struct Card {\r\n        uint16 proto;\r\n        uint16 purity;\r\n    }\r\n\r\n    function getCard(uint id) public view returns (uint16 proto, uint16 purity) {\r\n        Card memory card = cards[id];\r\n        return (card.proto, card.purity);\r\n    }\r\n\r\n    function getShine(uint16 purity) public pure returns (uint8) {\r\n        return uint8(purity / 1000);\r\n    }\r\n\r\n    Card[] public cards;\r\n    \r\n}\r\n\r\ncontract CardProto is CardBase {\r\n\r\n    event NewProtoCard(\r\n        uint16 id, uint8 season, uint8 god, \r\n        Rarity rarity, uint8 mana, uint8 attack, \r\n        uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    );\r\n\r\n    struct Limit {\r\n        uint64 limit;\r\n        bool exists;\r\n    }\r\n\r\n    // limits for mythic cards\r\n    mapping(uint16 => Limit) public limits;\r\n\r\n    // can only set limits once\r\n    function setLimit(uint16 id, uint64 limit) public onlyGovernor {\r\n        Limit memory l = limits[id];\r\n        require(!l.exists);\r\n        limits[id] = Limit({\r\n            limit: limit,\r\n            exists: true\r\n        });\r\n    }\r\n\r\n    function getLimit(uint16 id) public view returns (uint64 limit, bool set) {\r\n        Limit memory l = limits[id];\r\n        return (l.limit, l.exists);\r\n    }\r\n\r\n    // could make these arrays to save gas\r\n    // not really necessary - will be update a very limited no of times\r\n    mapping(uint8 => bool) public seasonTradable;\r\n    mapping(uint8 => bool) public seasonTradabilityLocked;\r\n    uint8 public currentSeason;\r\n\r\n    function makeTradeable(uint8 season) public onlyGovernor {\r\n        seasonTradable[season] = true;\r\n    }\r\n\r\n    function makeUntradable(uint8 season) public onlyGovernor {\r\n        require(!seasonTradabilityLocked[season]);\r\n        seasonTradable[season] = false;\r\n    }\r\n\r\n    function makePermanantlyTradable(uint8 season) public onlyGovernor {\r\n        require(seasonTradable[season]);\r\n        seasonTradabilityLocked[season] = true;\r\n    }\r\n\r\n    function isTradable(uint16 proto) public view returns (bool) {\r\n        return seasonTradable[protos[proto].season];\r\n    }\r\n\r\n    function nextSeason() public onlyGovernor {\r\n        //Seasons shouldn't go to 0 if there is more than the uint8 should hold, the governor should know this ¯\\_(ツ)_/¯ -M\r\n        require(currentSeason <= 255); \r\n\r\n        currentSeason++;\r\n        mythic.length = 0;\r\n        legendary.length = 0;\r\n        epic.length = 0;\r\n        rare.length = 0;\r\n        common.length = 0;\r\n    }\r\n\r\n    enum Rarity {\r\n        Common,\r\n        Rare,\r\n        Epic,\r\n        Legendary, \r\n        Mythic\r\n    }\r\n\r\n    uint8 constant SPELL = 1;\r\n    uint8 constant MINION = 2;\r\n    uint8 constant WEAPON = 3;\r\n    uint8 constant HERO = 4;\r\n\r\n    struct ProtoCard {\r\n        bool exists;\r\n        uint8 god;\r\n        uint8 season;\r\n        uint8 cardType;\r\n        Rarity rarity;\r\n        uint8 mana;\r\n        uint8 attack;\r\n        uint8 health;\r\n        uint8 tribe;\r\n    }\r\n\r\n    // there is a particular design decision driving this:\r\n    // need to be able to iterate over mythics only for card generation\r\n    // don't store 5 different arrays: have to use 2 ids\r\n    // better to bear this cost (2 bytes per proto card)\r\n    // rather than 1 byte per instance\r\n\r\n    uint16 public protoCount;\r\n    \r\n    mapping(uint16 => ProtoCard) protos;\r\n\r\n    uint16[] public mythic;\r\n    uint16[] public legendary;\r\n    uint16[] public epic;\r\n    uint16[] public rare;\r\n    uint16[] public common;\r\n\r\n    function addProtos(\r\n        uint16[] externalIDs, uint8[] gods, Rarity[] rarities, uint8[] manas, uint8[] attacks, uint8[] healths, uint8[] cardTypes, uint8[] tribes, bool[] packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        for (uint i = 0; i < externalIDs.length; i++) {\r\n\r\n            ProtoCard memory card = ProtoCard({\r\n                exists: true,\r\n                god: gods[i],\r\n                season: currentSeason,\r\n                cardType: cardTypes[i],\r\n                rarity: rarities[i],\r\n                mana: manas[i],\r\n                attack: attacks[i],\r\n                health: healths[i],\r\n                tribe: tribes[i]\r\n            });\r\n\r\n            _addProto(externalIDs[i], card, packable[i]);\r\n        }\r\n        \r\n    }\r\n\r\n    function addProto(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: cardType,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addWeapon(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 durability, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: WEAPON,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: durability,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addSpell(uint16 externalID, uint8 god, Rarity rarity, uint8 mana, bool packable) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: SPELL,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: 0,\r\n            health: 0,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addMinion(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: MINION,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function _addProto(uint16 externalID, ProtoCard memory card, bool packable) internal {\r\n\r\n        require(!protos[externalID].exists);\r\n\r\n        card.exists = true;\r\n\r\n        protos[externalID] = card;\r\n\r\n        protoCount++;\r\n\r\n        emit NewProtoCard(\r\n            externalID, currentSeason, card.god, \r\n            card.rarity, card.mana, card.attack, \r\n            card.health, card.cardType, card.tribe, packable\r\n        );\r\n\r\n        if (packable) {\r\n            Rarity rarity = card.rarity;\r\n            if (rarity == Rarity.Common) {\r\n                common.push(externalID);\r\n            } else if (rarity == Rarity.Rare) {\r\n                rare.push(externalID);\r\n            } else if (rarity == Rarity.Epic) {\r\n                epic.push(externalID);\r\n            } else if (rarity == Rarity.Legendary) {\r\n                legendary.push(externalID);\r\n            } else if (rarity == Rarity.Mythic) {\r\n                mythic.push(externalID);\r\n            } else {\r\n                require(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getProto(uint16 id) public view returns(\r\n        bool exists, uint8 god, uint8 season, uint8 cardType, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) {\r\n        ProtoCard memory proto = protos[id];\r\n        return (\r\n            proto.exists,\r\n            proto.god,\r\n            proto.season,\r\n            proto.cardType,\r\n            proto.rarity,\r\n            proto.mana,\r\n            proto.attack,\r\n            proto.health,\r\n            proto.tribe\r\n        );\r\n    }\r\n\r\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16) {\r\n        // modulo bias is fine - creates rarity tiers etc\r\n        // will obviously revert is there are no cards of that type: this is expected - should never happen\r\n        if (rarity == Rarity.Common) {\r\n            return common[random % common.length];\r\n        } else if (rarity == Rarity.Rare) {\r\n            return rare[random % rare.length];\r\n        } else if (rarity == Rarity.Epic) {\r\n            return epic[random % epic.length];\r\n        } else if (rarity == Rarity.Legendary) {\r\n            return legendary[random % legendary.length];\r\n        } else if (rarity == Rarity.Mythic) {\r\n            // make sure a mythic is available\r\n            uint16 id;\r\n            uint64 limit;\r\n            bool set;\r\n            for (uint i = 0; i < mythic.length; i++) {\r\n                id = mythic[(random + i) % mythic.length];\r\n                (limit, set) = getLimit(id);\r\n                if (set && limit > 0){\r\n                    return id;\r\n                }\r\n            }\r\n            // if not, they get a legendary :(\r\n            return legendary[random % legendary.length];\r\n        }\r\n        require(false);\r\n        return 0;\r\n    }\r\n\r\n    // can never adjust tradable cards\r\n    // each season gets a 'balancing beta'\r\n    // totally immutable: season, rarity\r\n    function replaceProto(\r\n        uint16 index, uint8 god, uint8 cardType, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) public onlyGovernor {\r\n        ProtoCard memory pc = protos[index];\r\n        require(!seasonTradable[pc.season]);\r\n        protos[index] = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: pc.season,\r\n            cardType: cardType,\r\n            rarity: pc.rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n    }\r\n\r\n}\r\n\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs    owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable;\r\n    function transfer(address _to, uint256 _tokenId) public payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public payable;\r\n    function approve(address _to, uint256 _tokenId) public payable;\r\n    function setApprovalForAll(address _to, bool _approved) public;\r\n    function getApproved(uint256 _tokenId) public view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n}\r\n\r\ncontract NFT is ERC721, ERC165, ERC721Metadata, ERC721Enumerable {}\r\n\r\ncontract CardOwnership is NFT, CardProto {\r\n\r\n    // doing this strategy doesn't save gas\r\n    // even setting the length to the max and filling in\r\n    // unfortunately - maybe if we stop it boundschecking\r\n    // address[] owners;\r\n    mapping(uint => address) owners;\r\n    mapping(uint => address) approved;\r\n    // support multiple operators\r\n    mapping(address => mapping(address => bool)) operators;\r\n\r\n    // save space, limits us to 2^40 tokens (>1t)\r\n    mapping(address => uint40[]) public ownedTokens;\r\n\r\n    mapping(uint => string) uris;\r\n\r\n    // save space, limits us to 2^24 tokens per user (~17m)\r\n    uint24[] indices;\r\n\r\n    uint public burnCount;\r\n\r\n    /**\r\n    * @return the name of this token\r\n    */\r\n    function name() public view returns (string) {\r\n        return \"Gods Unchained\";\r\n    }\r\n\r\n    /**\r\n    * @return the symbol of this token\r\n    */  \r\n    function symbol() public view returns (string) {\r\n        return \"GODS\";\r\n    }\r\n\r\n    /**\r\n    * @return the total number of cards in circulation\r\n    */\r\n    function totalSupply() public view returns (uint) {\r\n        return cards.length - burnCount;\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to which the card will be transferred\r\n    * @param id : the id of the card to be transferred\r\n    */\r\n    function transfer(address to, uint id) public payable {\r\n        require(owns(msg.sender, id));\r\n        require(isTradable(cards[id].proto));\r\n        require(to != address(0));\r\n        _transfer(msg.sender, to, id);\r\n    }\r\n\r\n    /**\r\n    * internal transfer function which skips checks - use carefully\r\n    * @param from : the address from which the card will be transferred\r\n    * @param to : the address to which the card will be transferred\r\n    * @param id : the id of the card to be transferred\r\n    */\r\n    function _transfer(address from, address to, uint id) internal {\r\n        approved[id] = address(0);\r\n        owners[id] = to;\r\n        _addToken(to, id);\r\n        _removeToken(from, id);\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    /**\r\n    * initial internal transfer function which skips checks and saves gas - use carefully\r\n    * @param to : the address to which the card will be transferred\r\n    * @param id : the id of the card to be transferred\r\n    */\r\n    function _create(address to, uint id) internal {\r\n        owners[id] = to;\r\n        _addToken(to, id);\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to which the cards will be transferred\r\n    * @param ids : the ids of the cards to be transferred\r\n    */\r\n    function transferAll(address to, uint[] ids) public payable {\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            transfer(to, ids[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param proposed : the claimed owner of the cards\r\n    * @param ids : the ids of the cards to check\r\n    * @return whether proposed owns all of the cards \r\n    */\r\n    function ownsAll(address proposed, uint[] ids) public view returns (bool) {\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            if (!owns(proposed, ids[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @param proposed : the claimed owner of the card\r\n    * @param id : the id of the card to check\r\n    * @return whether proposed owns the card\r\n    */\r\n    function owns(address proposed, uint id) public view returns (bool) {\r\n        return ownerOf(id) == proposed;\r\n    }\r\n\r\n    /**\r\n    * @param id : the id of the card\r\n    * @return the address of the owner of the card\r\n    */\r\n    function ownerOf(uint id) public view returns (address) {\r\n        return owners[id];\r\n    }\r\n\r\n    /**\r\n    * @param id : the index of the token to burn\r\n    */\r\n    function burn(uint id) public {\r\n        // require(isTradable(cards[id].proto));\r\n        require(owns(msg.sender, id));\r\n        burnCount++;\r\n        // use the internal transfer function as the external\r\n        // has a guard to prevent transfers to 0x0\r\n        _transfer(msg.sender, address(0), id);\r\n    }\r\n\r\n    /**\r\n    * @param ids : the indices of the tokens to burn\r\n    */\r\n    function burnAll(uint[] ids) public {\r\n        for (uint i = 0; i < ids.length; i++){\r\n            burn(ids[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to approve for transfer\r\n    * @param id : the index of the card to be approved\r\n    */\r\n    function approve(address to, uint id) public payable {\r\n        require(owns(msg.sender, id));\r\n        require(isTradable(cards[id].proto));\r\n        approved[id] = to;\r\n        emit Approval(msg.sender, to, id);\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to approve for transfer\r\n    * @param ids : the indices of the cards to be approved\r\n    */\r\n    function approveAll(address to, uint[] ids) public payable {\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            approve(to, ids[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @param id : the index of the token to check\r\n    * @return the address approved to transfer this token\r\n    */\r\n    function getApproved(uint id) public view returns(address) {\r\n        return approved[id];\r\n    }\r\n\r\n    /**\r\n    * @param owner : the address to check\r\n    * @return the number of tokens controlled by owner\r\n    */\r\n    function balanceOf(address owner) public view returns (uint) {\r\n        return ownedTokens[owner].length;\r\n    }\r\n\r\n    /**\r\n    * @param id : the index of the proposed token\r\n    * @return whether the token is owned by a non-zero address\r\n    */\r\n    function exists(uint id) public view returns (bool) {\r\n        return owners[id] != address(0);\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to which the token should be transferred\r\n    * @param id : the index of the token to transfer\r\n    */\r\n    function transferFrom(address from, address to, uint id) public payable {\r\n        \r\n        require(to != address(0));\r\n        require(to != address(this));\r\n\r\n        // TODO: why is this necessary\r\n        // if you're approved, why does it matter where it comes from?\r\n        require(ownerOf(id) == from);\r\n\r\n        require(isSenderApprovedFor(id));\r\n\r\n        require(isTradable(cards[id].proto));\r\n\r\n        _transfer(ownerOf(id), to, id);\r\n    }\r\n\r\n    /**\r\n    * @param to : the address to which the tokens should be transferred\r\n    * @param ids : the indices of the tokens to transfer\r\n    */\r\n    function transferAllFrom(address to, uint[] ids) public payable {\r\n        for (uint i = 0; i < ids.length; i++) {\r\n            transferFrom(address(0), to, ids[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the number of cards which have been burned\r\n     */\r\n    function getBurnCount() public view returns (uint) {\r\n        return burnCount;\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return operators[owner][operator];\r\n    }\r\n\r\n    function setApprovalForAll(address to, bool toApprove) public {\r\n        require(to != msg.sender);\r\n        operators[msg.sender][to] = toApprove;\r\n        emit ApprovalForAll(msg.sender, to, toApprove);\r\n    }\r\n\r\n    bytes4 constant magic = bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"));\r\n\r\n    function safeTransferFrom(address from, address to, uint id, bytes data) public payable {\r\n        require(to != address(0));\r\n        transferFrom(from, to, id);\r\n        if (_isContract(to)) {\r\n            bytes4 response = ERC721TokenReceiver(to).onERC721Received.gas(50000)(from, id, data);\r\n            require(response == magic);\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint id) public payable {\r\n        safeTransferFrom(from, to, id, \"\");\r\n    }\r\n\r\n    function _addToken(address to, uint id) private {\r\n        uint pos = ownedTokens[to].push(uint40(id)) - 1;\r\n        indices.push(uint24(pos));\r\n    }\r\n\r\n    function _removeToken(address from, uint id) public payable {\r\n        uint24 index = indices[id];\r\n        uint lastIndex = ownedTokens[from].length - 1;\r\n        uint40 lastId = ownedTokens[from][lastIndex];\r\n\r\n        ownedTokens[from][index] = lastId;\r\n        ownedTokens[from][lastIndex] = 0;\r\n        ownedTokens[from].length--;\r\n    }\r\n\r\n    function isSenderApprovedFor(uint256 id) internal view returns (bool) {\r\n        return owns(msg.sender, id) || getApproved(id) == msg.sender || isApprovedForAll(ownerOf(id), msg.sender);\r\n    }\r\n\r\n    function _isContract(address test) internal view returns (bool) {\r\n        uint size; \r\n        assembly {\r\n            size := extcodesize(test)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    function tokenURI(uint id) public view returns (string) {\r\n        return uris[id];\r\n    }\r\n    \r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 _tokenId){\r\n        return ownedTokens[owner][index];\r\n    }\r\n\r\n    function tokenByIndex(uint256 index) external view returns (uint256){\r\n        return index;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public view returns (bool) {\r\n        return (\r\n            interfaceID == this.supportsInterface.selector || // ERC165\r\n            interfaceID == 0x5b5e139f || // ERC721Metadata\r\n            interfaceID == 0x6466353c || // ERC-721 on 3/7/2018\r\n            interfaceID == 0x780e9d63\r\n        ); // ERC721Enumerable\r\n    }\r\n\r\n    function implementsERC721() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function getOwnedTokens(address user) public view returns (uint40[]) {\r\n        return ownedTokens[user];\r\n    }\r\n    \r\n\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n\r\n\r\ncontract CardIntegration is CardOwnership {\r\n    \r\n    CardPack[] packs;\r\n\r\n    event CardCreated(uint indexed id, uint16 proto, uint16 purity, address owner);\r\n\r\n    function addPack(CardPack approved) public onlyGovernor {\r\n        packs.push(approved);\r\n    }\r\n\r\n    modifier onlyApprovedPacks {\r\n        require(_isApprovedPack());\r\n        _;\r\n    }\r\n\r\n    function _isApprovedPack() private view returns (bool) {\r\n        for (uint i = 0; i < packs.length; i++) {\r\n            if (msg.sender == address(packs[i])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function createCard(address owner, uint16 proto, uint16 purity) public whenNotPaused onlyApprovedPacks returns (uint) {\r\n        ProtoCard memory card = protos[proto];\r\n        require(card.season == currentSeason);\r\n        if (card.rarity == Rarity.Mythic) {\r\n            uint64 limit;\r\n            bool exists;\r\n            (limit, exists) = getLimit(proto);\r\n            require(!exists || limit > 0);\r\n            limits[proto].limit--;\r\n        }\r\n        return _createCard(owner, proto, purity);\r\n    }\r\n\r\n    function _createCard(address owner, uint16 proto, uint16 purity) internal returns (uint) {\r\n        Card memory card = Card({\r\n            proto: proto,\r\n            purity: purity\r\n        });\r\n\r\n        uint id = cards.push(card) - 1;\r\n\r\n        _create(owner, id);\r\n        \r\n        emit CardCreated(id, proto, purity, owner);\r\n\r\n        return id;\r\n    }\r\n\r\n    /*function combineCards(uint[] ids) public whenNotPaused {\r\n        require(ids.length == 5);\r\n        require(ownsAll(msg.sender, ids));\r\n        Card memory first = cards[ids[0]];\r\n        uint16 proto = first.proto;\r\n        uint8 shine = _getShine(first.purity);\r\n        require(shine < shineLimit);\r\n        uint16 puritySum = first.purity - (shine * 1000);\r\n        burn(ids[0]);\r\n        for (uint i = 1; i < ids.length; i++) {\r\n            Card memory next = cards[ids[i]];\r\n            require(next.proto == proto);\r\n            require(_getShine(next.purity) == shine);\r\n            puritySum += (next.purity - (shine * 1000));\r\n            burn(ids[i]);\r\n        }\r\n        uint16 newPurity = uint16(((shine + 1) * 1000) + (puritySum / ids.length));\r\n        _createCard(msg.sender, proto, newPurity);\r\n    }*/\r\n\r\n\r\n    // PURITY NOTES\r\n    // currently, we only\r\n    // however, to protect rarity, you'll never be abl\r\n    // this is enforced by the restriction in the create-card function\r\n    // no cards above this point can be found in packs\r\n\r\n    \r\n\r\n}\r\n\r\ncontract CardPack {\r\n\r\n    CardIntegration public integration;\r\n    uint public creationBlock;\r\n\r\n    constructor(CardIntegration _integration) public payable {\r\n        integration = _integration;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n    event Referral(address indexed referrer, uint value, address purchaser);\r\n\r\n    /**\r\n    * purchase 'count' of this type of pack\r\n    */\r\n    function purchase(uint16 packCount, address referrer) public payable;\r\n\r\n    // store purity and shine as one number to save users gas\r\n    function _getPurity(uint16 randOne, uint16 randTwo) internal pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000 + randTwo;\r\n        } else if (randOne >= 988) {\r\n            return 2000 + randTwo;\r\n        } else if (randOne >= 938) {\r\n            return 1000 + randTwo;\r\n        } else {\r\n            return randTwo;\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"getProto\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"god\",\"type\":\"uint8\"},{\"name\":\"season\",\"type\":\"uint8\"},{\"name\":\"cardType\",\"type\":\"uint8\"},{\"name\":\"rarity\",\"type\":\"uint8\"},{\"name\":\"mana\",\"type\":\"uint8\"},{\"name\":\"attack\",\"type\":\"uint8\"},{\"name\":\"health\",\"type\":\"uint8\"},{\"name\":\"tribe\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"burnAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"season\",\"type\":\"uint8\"}],\"name\":\"makePermanantlyTradable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"externalID\",\"type\":\"uint16\"},{\"name\":\"god\",\"type\":\"uint8\"},{\"name\":\"rarity\",\"type\":\"uint8\"},{\"name\":\"mana\",\"type\":\"uint8\"},{\"name\":\"packable\",\"type\":\"bool\"}],\"name\":\"addSpell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"common\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"_removeToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mythic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint16\"},{\"name\":\"god\",\"type\":\"uint8\"},{\"name\":\"cardType\",\"type\":\"uint8\"},{\"name\":\"mana\",\"type\":\"uint8\"},{\"name\":\"attack\",\"type\":\"uint8\"},{\"name\":\"health\",\"type\":\"uint8\"},{\"name\":\"tribe\",\"type\":\"uint8\"}],\"name\":\"replaceProto\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"seasonTradabilityLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint16\"},{\"name\":\"limit\",\"type\":\"uint64\"}],\"name\":\"setLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"transferAll\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"season\",\"type\":\"uint8\"}],\"name\":\"makeTradeable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"seasonTradable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposed\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"owns\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approved\",\"type\":\"address\"}],\"name\":\"addPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"getShine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards\",\"outputs\":[{\"name\":\"proto\",\"type\":\"uint16\"},{\"name\":\"purity\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getCard\",\"outputs\":[{\"name\":\"proto\",\"type\":\"uint16\"},{\"name\":\"purity\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint16\"}],\"name\":\"getLimit\",\"outputs\":[{\"name\":\"limit\",\"type\":\"uint64\"},{\"name\":\"set\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"limits\",\"outputs\":[{\"name\":\"limit\",\"type\":\"uint64\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"toApprove\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proto\",\"type\":\"uint16\"}],\"name\":\"isTradable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposed\",\"type\":\"address\"},{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"ownsAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nextSeason\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSeason\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"setGovernor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"season\",\"type\":\"uint8\"}],\"name\":\"makeUntradable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rarity\",\"type\":\"uint8\"},{\"name\":\"random\",\"type\":\"uint16\"}],\"name\":\"getRandomCard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"externalID\",\"type\":\"uint16\"},{\"name\":\"god\",\"type\":\"uint8\"},{\"name\":\"rarity\",\"type\":\"uint8\"},{\"name\":\"mana\",\"type\":\"uint8\"},{\"name\":\"attack\",\"type\":\"uint8\"},{\"name\":\"durability\",\"type\":\"uint8\"},{\"name\":\"packable\",\"type\":\"bool\"}],\"name\":\"addWeapon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"externalID\",\"type\":\"uint16\"},{\"name\":\"god\",\"type\":\"uint8\"},{\"name\":\"rarity\",\"type\":\"uint8\"},{\"name\":\"mana\",\"type\":\"uint8\"},{\"name\":\"attack\",\"type\":\"uint8\"},{\"name\":\"health\",\"type\":\"uint8\"},{\"name\":\"cardType\",\"type\":\"uint8\"},{\"name\":\"tribe\",\"type\":\"uint8\"},{\"name\":\"packable\",\"type\":\"bool\"}],\"name\":\"addProto\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protoCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getOwnedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint40[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"externalID\",\"type\":\"uint16\"},{\"name\":\"god\",\"type\":\"uint8\"},{\"name\":\"rarity\",\"type\":\"uint8\"},{\"name\":\"mana\",\"type\":\"uint8\"},{\"name\":\"attack\",\"type\":\"uint8\"},{\"name\":\"health\",\"type\":\"uint8\"},{\"name\":\"tribe\",\"type\":\"uint8\"},{\"name\":\"packable\",\"type\":\"bool\"}],\"name\":\"addMinion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint40\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"externalIDs\",\"type\":\"uint16[]\"},{\"name\":\"gods\",\"type\":\"uint8[]\"},{\"name\":\"rarities\",\"type\":\"uint8[]\"},{\"name\":\"manas\",\"type\":\"uint8[]\"},{\"name\":\"attacks\",\"type\":\"uint8[]\"},{\"name\":\"healths\",\"type\":\"uint8[]\"},{\"name\":\"cardTypes\",\"type\":\"uint8[]\"},{\"name\":\"tribes\",\"type\":\"uint8[]\"},{\"name\":\"packable\",\"type\":\"bool[]\"}],\"name\":\"addProtos\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBurnCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"legendary\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"approveAll\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"transferAllFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"proto\",\"type\":\"uint16\"},{\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"createCard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proto\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"purity\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"CardCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"season\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"god\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"rarity\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"mana\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"attack\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"health\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"cardType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"tribe\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"packable\",\"type\":\"bool\"}],\"name\":\"NewProtoCard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"CardIntegration","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c8069c2ac22ba1f7a118db5e6bba1fa58500c5769b9ce6483d1dc9db2a01c4cc"}]}