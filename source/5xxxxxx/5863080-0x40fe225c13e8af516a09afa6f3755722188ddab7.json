{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ninterface insChainTokenInterface{\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address who ) public view returns (uint value);\r\n    function allowance( address owner, address spender ) public view returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) public returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Owned{\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Owned() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still need to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n    \r\n    event Pause();\r\n    event Unpause();\r\n    bool public paused = false;\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n/*\r\n    Overflow protected math functions\r\n*/\r\ncontract SafeMath {\r\n    /**\r\n        constructor\r\n    */\r\n    function SafeMath() public{\r\n    }\r\n\r\n       // Check if it is safe to add two numbers\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n\r\n    // Check if it is safe to subtract two numbers\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint c = a - b;\r\n        assert(b <= a && c <= a);\r\n        return c;\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint c = a * b;\r\n        assert(a == 0 || (c / a) == b);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n// a ledger recording policy participants\r\n// kill() property is limited to the officially-released policies, which must be removed in the later template versions.\r\ncontract PolicyPool is SafeMath, Owned{\r\n\r\n    \r\n    insChainTokenInterface public insChainTokenLedger;\r\n    address public agent;\r\n\r\n    uint256 public policyTokenBalance=0;\r\n    uint256 public policyTokenBalanceFromEther=0;\r\n    //might turn to private in production\r\n    uint256 public policyFeeCollector=0;\r\n    \r\n    uint256 public policyCandyBalance=0;\r\n    \r\n    uint256 public policyActiveNum=0;\r\n\r\n\r\n    mapping (uint256 => uint256) policyInternalID;\r\n\r\n    struct Policy {\r\n        uint256 since;\r\n        uint256 accumulatedIn;\r\n    }\r\n\r\n    // policies[policyInternalID[extraData]]\r\n    Policy[] public policies;\r\n\r\n    struct Proposal {\r\n        uint256 policyPayload;\r\n        address recipient;\r\n        uint256 amount;\r\n        string description;\r\n        bool executed;\r\n        bool proposalPassed;\r\n        // bytes32 proposalHash;\r\n    }\r\n    \r\n    // struct array to store user claims\r\n    Proposal[] public proposals;\r\n    uint256 public numProposals;\r\n    \r\n    uint256 public updated_policy_payload;\r\n\r\n    event PolicyIn(address indexed backer, uint256 indexed amount, uint256 indexed policyExternalID);\r\n\r\n    event PolicyOut(address indexed backer, uint256 indexed amount, uint256 indexed policyExternalID);\r\n\r\n    event PolicyValueIn(address indexed backer, uint256 indexed amount,uint256 indexed policyExternalID);\r\n\r\n\r\n    // event log for user claims(admin)\r\n    event ProposalAdded(uint indexed proposalID, uint256 indexed policyExternalID, uint256 indexed amount, string description);\r\n    event ProposalTallied(uint indexed proposalId, uint256 indexed amount, bool indexed proposalPassed);\r\n\r\n    // external agent for candy policies\r\n    modifier onlyAgent {\r\n        assert(msg.sender == agent);\r\n        _;\r\n    }\r\n    \r\n    function PolicyPool(address tokenLedger) public {\r\n        insChainTokenLedger=insChainTokenInterface(tokenLedger);\r\n        // temp agent only, will be changed to the contract later\r\n        agent=msg.sender;\r\n        addPolicy(0,0);\r\n    }\r\n\r\n    //user must perform the following opertions before calling this function\r\n    //approveAndCall() to activate the policy account in this policy contract\r\n    //this function works as a policy registering and deposit handler\r\n\r\n   function receiveApproval(address from,uint256 weiAmount,address tokenLedger, bytes extraData) whenNotPaused public returns (bool success){\r\n\r\n        require(insChainTokenInterface(tokenLedger)==insChainTokenLedger);\r\n\r\n\r\n        require(insChainTokenLedger.transferFrom(from, this, weiAmount));\r\n        \r\n        //convert msg.data bytes to uint\r\n        uint payload=0;\r\n        \r\n        for (uint i = 0; i < 32; i++) {\r\n            uint b = uint(msg.data[131 - i]);\r\n            payload += b * 256**i;\r\n        }\r\n        updated_policy_payload = payload;\r\n        \r\n        if(!getx2Policy(from, payload, now, weiAmount)){revert();}\r\n        policyTokenBalance=safeAdd(policyTokenBalance,weiAmount);\r\n\r\n        return true;\r\n    }\r\n    \r\n    function policyID(uint256 payload) public view returns (uint id){\r\n        return policyInternalID[payload];\r\n    }\r\n    \r\n\r\n    function accumulatedBalanceOf(uint id) public view returns (uint256 balance) {\r\n        return policies[id].accumulatedIn;\r\n    }\r\n    \r\n    function joinSinceOf(uint id) public view returns (uint256 balance) {\r\n        return policies[id].since;\r\n    }\r\n\r\n\r\n    function addPolicy(uint256 ticker, uint256 weiAmount) internal returns(uint) {\r\n        policies.length++;\r\n        policies[policies.length-1].since = ticker;\r\n        policies[policies.length-1].accumulatedIn = weiAmount;\r\n        return policies.length;\r\n    }\r\n    \r\n    function getx2Policy(address from, uint256 payload, uint256 timeStamp, uint256 weiAmount) internal returns(bool success){\r\n        uint id = policyInternalID[payload];\r\n  \r\n        if (id == 0) {\r\n            id = policies.length;\r\n            policyInternalID[payload] = id;\r\n            addPolicy(timeStamp,weiAmount);\r\n            emit PolicyIn(from, weiAmount, payload);\r\n            policyActiveNum++;\r\n        }else if (policies[id].accumulatedIn==0){\r\n\r\n            policies[id].since=timeStamp;\r\n            policies[id].accumulatedIn=weiAmount;\r\n            emit PolicyIn(from, weiAmount, payload);\r\n            policyActiveNum++;\r\n\r\n        }else{\r\n\r\n            policies[id].accumulatedIn=safeAdd(policies[id].accumulatedIn,weiAmount);\r\n            emit PolicyValueIn(from, weiAmount, payload);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //the policy balance ledger will be updated either\r\n    // onlyOwner might be changed to onlyManager later\r\n    function withdrawPolicy(uint256 payload, uint256 weiAmount, uint256 fees, address to) public onlyOwner returns (bool success) {\r\n\r\n        uint id=policyInternalID[payload];\r\n        require(id>0);\r\n        require(policies[id].accumulatedIn>0);\r\n        require(policies[id].since<now);\r\n        require(weiAmount<policyTokenBalance);\r\n\r\n        if(!insChainTokenLedger.transfer(to,weiAmount)){revert();}\r\n        policyTokenBalance=safeSub(policyTokenBalance,weiAmount);\r\n        policyTokenBalance=safeSub(policyTokenBalance,fees);\r\n        policyFeeCollector=safeAdd(policyFeeCollector,fees);\r\n\r\n\r\n        policies[id].accumulatedIn=0;\r\n        policies[id].since=now;\r\n\r\n        emit PolicyOut(to, weiAmount, payload);\r\n        policyActiveNum--;\r\n        return true;\r\n    }\r\n\r\n    function kill() public onlyOwner {\r\n        if(policyTokenBalance>0){\r\n            if(!insChainTokenLedger.transfer(owner,policyTokenBalance)){revert();}\r\n            policyTokenBalance=0;\r\n            policyTokenBalanceFromEther=0;\r\n        }\r\n        if(policyFeeCollector>0){\r\n            if(!insChainTokenLedger.transfer(owner,policyFeeCollector)){revert();}\r\n            policyFeeCollector=0;\r\n        }\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /**\r\n     * Add Proposal\r\n     *\r\n     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `ClaimDescription`. `transactionBytecode ? Contains : Does not contain` code.\r\n     *\r\n     * param payload the policy id\r\n     * param beneficiary who to send the ether to\r\n     * param weiAmount amount of token to send, in wei(18 decimals)\r\n     * param claimDescription Description of claim\r\n     */\r\n    function newProposal(uint256 payload, address beneficiary, uint256 weiAmount,string claimDescription) onlyOwner public returns(uint256 proposalID){\r\n\r\n        require(policyTokenBalance>weiAmount);\r\n\r\n        proposals.length++;\r\n        proposalID = proposals.length-1;\r\n        Proposal storage p = proposals[proposalID];\r\n        p.policyPayload=payload;\r\n        p.recipient = beneficiary;\r\n        p.amount = weiAmount;\r\n        p.description = claimDescription;\r\n        p.executed = false;\r\n        p.proposalPassed = false;\r\n        emit ProposalAdded(proposalID, p.policyPayload, p.amount, p.description);\r\n        numProposals = proposalID+1;\r\n\r\n        return proposalID;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * param proposalNumber proposal number\r\n     * param refundAmount the money should pay back\r\n     * param fees to be paid by claimer\r\n     */\r\n    function executeProposal(uint proposalNumber, uint256 refundAmount, uint256 fees) onlyOwner public returns (bool success){\r\n        Proposal storage p = proposals[proposalNumber];\r\n\r\n        require(!p.executed);                               //it has not already been executed\r\n        require(p.amount>=refundAmount);                  \r\n\r\n        // ...then execute result\r\n        \r\n        uint256 totalReduce = safeAdd(refundAmount,fees);\r\n        if ( totalReduce<=policyTokenBalance ) {\r\n            // Proposal passed; execute the transaction\r\n\r\n            p.executed = true; // Avoid recursive calling\r\n\r\n            \r\n            policyTokenBalance=safeSub(policyTokenBalance,totalReduce);\r\n            policyFeeCollector=safeAdd(policyFeeCollector,fees);\r\n            // refund the GETX\r\n            if(!insChainTokenLedger.transfer(p.recipient,refundAmount)){revert();}\r\n            // clear the data inside\r\n            uint id = policyInternalID[p.policyPayload];\r\n            policies[id].accumulatedIn=0;\r\n            policies[id].since=now;\r\n            p.proposalPassed = true;\r\n\r\n            emit ProposalTallied(proposalNumber, refundAmount, p.proposalPassed);\r\n\r\n            emit PolicyOut(p.recipient, refundAmount, p.policyPayload);\r\n            policyActiveNum--;\r\n\r\n            \r\n        } else {\r\n            // Proposal failed\r\n            p.proposalPassed = false;\r\n        }\r\n\r\n        return p.proposalPassed;\r\n    }\r\n    \r\n    // This function is controlled by agent\r\n    function joinWithCandy(address signer, uint256 payload, uint256 timeStamp) onlyAgent public returns (bool success){\r\n        require(signer!=address(0));\r\n        require(timeStamp<now);\r\n        require(policyInternalID[payload] == 0);\r\n        \r\n        if(!getx2Policy(signer, payload, timeStamp, 0)){revert();}\r\n        return true;\r\n    }\r\n    \r\n    function updateAgent(address newAgent) onlyOwner public returns(bool success){\r\n        agent=newAgent;\r\n        return true;\r\n    }\r\n\r\n    // admin function to transfer in the GETX according to the rate\r\n    // the admin should transfer \"policyTokenBalanceFromEther\" to this pool later\r\n    function settleEtherPolicy(address[] froms, uint256[] payloads, uint256[] timeStamps, uint256[] weiAmounts) onlyOwner public returns(bool success){\r\n        require(froms.length == payloads.length);\r\n        require(payloads.length == weiAmounts.length);\r\n        uint i;\r\n\r\n        for (i=0;i<froms.length;i++){\r\n            if(!getx2Policy(froms[i], payloads[i], timeStamps[i], weiAmounts[i])){revert();}\r\n            // this GETX value must be the same as the ether collector account\r\n            policyTokenBalanceFromEther=safeAdd(policyTokenBalanceFromEther,weiAmounts[i]);\r\n            policyTokenBalance=safeAdd(policyTokenBalance,weiAmounts[i]);\r\n            if(!insChainTokenLedger.transferFrom(msg.sender, this, weiAmounts[i])){revert();}\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function settleCandyGetx(uint256 weiAmount) onlyOwner public returns (bool success){\r\n        policyCandyBalance=safeAdd(policyCandyBalance,weiAmount);\r\n        return true;\r\n    }\r\n\r\n    function retrievePoolFee(uint256 weiAmount) onlyOwner public returns (bool success){\r\n        policyFeeCollector=safeSub(policyFeeCollector,weiAmount);\r\n        if(!insChainTokenLedger.transfer(msg.sender,weiAmount)){revert();}\r\n        return true;\r\n    }\r\n    \r\n    function claimTokens(address _token) onlyOwner public {\r\n        require(_token != address(0));\r\n        require(_token != address(insChainTokenLedger));\r\n\r\n        ERC20 token = ERC20(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"policyPayload\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"policyActiveNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"policyFeeCollector\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAgent\",\"type\":\"address\"}],\"name\":\"updateAgent\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"froms\",\"type\":\"address[]\"},{\"name\":\"payloads\",\"type\":\"uint256[]\"},{\"name\":\"timeStamps\",\"type\":\"uint256[]\"},{\"name\":\"weiAmounts\",\"type\":\"uint256[]\"}],\"name\":\"settleEtherPolicy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"policyTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"policyTokenBalanceFromEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"policyCandyBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payload\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"claimDescription\",\"type\":\"string\"}],\"name\":\"newProposal\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"accumulatedBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payload\",\"type\":\"uint256\"}],\"name\":\"policyID\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"tokenLedger\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"executeProposal\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payload\",\"type\":\"uint256\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawPolicy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signer\",\"type\":\"address\"},{\"name\":\"payload\",\"type\":\"uint256\"},{\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"joinWithCandy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"settleCandyGetx\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"policies\",\"outputs\":[{\"name\":\"since\",\"type\":\"uint256\"},{\"name\":\"accumulatedIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"insChainTokenLedger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"updated_policy_payload\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"retrievePoolFee\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"agent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"joinSinceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenLedger\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"policyExternalID\",\"type\":\"uint256\"}],\"name\":\"PolicyIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"policyExternalID\",\"type\":\"uint256\"}],\"name\":\"PolicyOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"policyExternalID\",\"type\":\"uint256\"}],\"name\":\"PolicyValueIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"policyExternalID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"proposalPassed\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"PolicyPool","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000007a58629aaf3e1a0d07d8f43114b76bd5eee3b91","Library":"","SwarmSource":"bzzr://ad750f444f8e7f196e5105d796eb3c0c19b4e9f1e1cd64bbe907d9d9435b90cb"}]}