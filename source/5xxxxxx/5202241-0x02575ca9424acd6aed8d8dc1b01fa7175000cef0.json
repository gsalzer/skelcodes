{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner{\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC721Interface {\r\n    // Required methods\r\n    // function totalSupply() public view returns (uint256 total);\r\n    // function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    // function approve(address _to, uint256 _tokenId) external;\r\n    // function transfer(address _to, uint256 _tokenId) external;\r\n    // function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n}\r\n\r\n/** \r\n * @dev Name provider contract\r\n * Allows saving names and descriptons for specified addresses and tokens\r\n */\r\ncontract NameProvider is Ownable {\r\n    \r\n    uint256 public FEE = 1 finney;\r\n    \r\n    //name storage for addresses\r\n    mapping(bytes32 => mapping(address => string)) addressNames;\r\n    \r\n    //marks namespaces as already used on first name save to specified namespace\r\n    mapping(bytes32 => bool) takenNamespaces;\r\n    \r\n    //name storage for tokens\r\n    mapping(address => mapping(uint256 => string)) tokenNames;\r\n    \r\n    //description storage for tokens\r\n    mapping(address => mapping(uint256 => string)) tokenDescriptions;\r\n    \r\n    /* EVENTS */\r\n    \r\n    event NameChanged(bytes32 namespace, address account, string name);\r\n    \r\n    event TokenNameChanged(address tokenProvider, uint256 tokenId, string name);\r\n    \r\n    event TokenDescriptionChanged(address tokenProvider, uint256 tokenId, string description);\r\n    \r\n    function NameProvider(address _owner) public {\r\n        require(_owner != address(0));\r\n        owner = _owner;\r\n    }\r\n    \r\n    modifier setTokenText(address _tokenInterface, uint256 _tokenId, string _text){\r\n        //check fee\r\n        require(msg.value >= FEE);\r\n        //no empty strings allowed\r\n        require(bytes(_text).length > 0);\r\n        \r\n        ERC721Interface tokenInterface = ERC721Interface(_tokenInterface);\r\n        //only token owner can set its name\r\n        require(msg.sender == tokenInterface.ownerOf(_tokenId));\r\n        \r\n        _;//set text code\r\n        \r\n        //return excess\r\n        if (msg.value > FEE) {\r\n            msg.sender.transfer(msg.value - FEE);\r\n        }\r\n    }\r\n    \r\n    //@dev set name for specified token,\r\n    // NB msg.sender must be owner of the specified token.\r\n    //@param _tokenInterface ERC721 protocol provider address\r\n    //@param _tokenId id of the token, whose name will be set\r\n    //@param _name string that will be set as new token name\r\n    function setTokenName(address _tokenInterface, uint256 _tokenId, string _name) \r\n    setTokenText(_tokenInterface, _tokenId, _name) external payable {\r\n        _setTokenName(_tokenInterface, _tokenId, _name);\r\n    }\r\n    \r\n    //@dev set description for specified token,\r\n    // NB msg.sender must be owner of the specified token.\r\n    //@param _tokenInterface ERC721 protocol provider address\r\n    //@param _tokenId id of the token, whose description will be set\r\n    //@param _description string that will be set as new token description\r\n    function setTokenDescription(address _tokenInterface, uint256 _tokenId, string _description)\r\n    setTokenText(_tokenInterface, _tokenId, _description) external payable {\r\n        _setTokenDescription(_tokenInterface, _tokenId, _description);\r\n    }\r\n    \r\n    //@dev get name of specified token,\r\n    //@param _tokenInterface ERC721 protocol provider address\r\n    //@param _tokenId id of the token, whose name will be returned\r\n    function getTokenName(address _tokenInterface, uint256 _tokenId) external view returns(string) {\r\n        return tokenNames[_tokenInterface][_tokenId];\r\n    }\r\n    \r\n    //@dev get description of specified token,\r\n    //@param _tokenInterface ERC721 protocol provider address\r\n    //@param _tokenId id of the token, whose description will be returned\r\n    function getTokenDescription(address _tokenInterface, uint256 _tokenId) external view returns(string) {\r\n        return tokenDescriptions[_tokenInterface][_tokenId];\r\n    }\r\n    \r\n    //@dev set global name for msg.sender,\r\n    // NB msg.sender must be owner of the specified token.\r\n    //@param _name string that will be set as new address name\r\n    function setName(string _name) external payable {\r\n        setServiceName(bytes32(0), _name);\r\n    }\r\n    \r\n    //@dev set name for msg.sender in cpecified namespace,\r\n    // NB msg.sender must be owner of the specified token.\r\n    //@param _namespace bytes32 service identifier\r\n    //@param _name string that will be set as new address name\r\n    function setServiceName(bytes32 _namespace, string memory _name) public payable {\r\n        //check fee\r\n        require(msg.value >= FEE);\r\n        //set name\r\n        _setName(_namespace, _name);\r\n        //return excess\r\n        if (msg.value > FEE) {\r\n            msg.sender.transfer(msg.value - FEE);\r\n        }\r\n    }\r\n    \r\n    //@dev get global name for specified address,\r\n    //@param _address the address for whom name string will be returned\r\n    function getNameByAddress(address _address) external view returns(string) {\r\n        return addressNames[bytes32(0)][_address];\r\n    }\r\n    \r\n    //@dev get global name for msg.sender,\r\n    function getName() external view returns(string) {\r\n        return addressNames[bytes32(0)][msg.sender];\r\n    }\r\n    \r\n    //@dev get name for specified address and namespace,\r\n    //@param _namespace bytes32 service identifier\r\n    //@param _address the address for whom name string will be returned\r\n    function getServiceNameByAddress(bytes32 _namespace, address _address) external view returns(string) {\r\n        return addressNames[_namespace][_address];\r\n    }\r\n    \r\n    //@dev get name for specified namespace and msg.sender,\r\n    //@param _namespace bytes32 service identifier\r\n    function getServiceName(bytes32 _namespace) external view returns(string) {\r\n        return addressNames[_namespace][msg.sender];\r\n    }\r\n    \r\n    //@dev get names for specified addresses in global namespace (bytes32(0))\r\n    //@param _address address[] array of addresses for whom names will be returned\r\n    //@return namesData bytes32 \r\n    //@return nameLength number of bytes32 in address name, sum of nameLength values equals namesData.length (1 to 1 with _address) \r\n    function getNames(address[] _address) external view returns(bytes32[] namesData, uint256[] nameLength) {\r\n        return getServiceNames(bytes32(0), _address);\r\n\t}\r\n\t\r\n\t//@dev get names for specified tokens \r\n    //@param _tokenIds uint256[] array of ids for whom names will be returned\r\n    //@return namesData bytes32 \r\n    //@return nameLength number of bytes32 in token name, sum of nameLength values equals namesData.length (1 to 1 with _tokenIds) \r\n\tfunction getTokenNames(address _tokenInterface, uint256[] _tokenIds) external view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\r\n        return _getTokenTexts(_tokenInterface, _tokenIds, true);\r\n\t}\r\n\t\r\n\t//@dev get names for specified tokens \r\n    //@param _tokenIds uint256[] array of ids for whom descriptons will be returned\r\n    //@return descriptonData bytes32 \r\n    //@return descriptionLength number of bytes32 in token name, sum of nameLength values equals namesData.length (1 to 1 with _tokenIds) \r\n\tfunction getTokenDescriptions(address _tokenInterface, uint256[] _tokenIds) external view returns(bytes32[] memory descriptonData, uint256[] memory descriptionLength) {\r\n        return _getTokenTexts(_tokenInterface, _tokenIds, false);\r\n\t}\r\n\t\r\n\t//@dev get names for specified addresses and namespace\r\n\t//@param _namespace bytes32 namespace identifier\r\n    //@param _address address[] array of addresses for whom names will be returned\r\n    //@return namesData bytes32 \r\n    //@return nameLength number of bytes32 in address name, sum of nameLength values equals namesData.length (1 to 1 with _address) \r\n    function getServiceNames(bytes32 _namespace, address[] _address) public view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\r\n        uint256 length = _address.length;\r\n        nameLength = new uint256[](length);\r\n        \r\n        bytes memory stringBytes;\r\n        uint256 size = 0;\r\n        uint256 i;\r\n        for (i = 0; i < length; i ++) {\r\n            stringBytes = bytes(addressNames[_namespace][_address[i]]);\r\n            size += nameLength[i] = stringBytes.length % 32 == 0 ? stringBytes.length / 32 : stringBytes.length / 32 + 1;\r\n        }\r\n        namesData = new bytes32[](size);\r\n        size = 0;\r\n        for (i = 0; i < length; i ++) {\r\n            size += _stringToBytes32(addressNames[_namespace][_address[i]], namesData, size);\r\n        }\r\n    }\r\n    \r\n    function namespaceTaken(bytes32 _namespace) external view returns(bool) {\r\n        return takenNamespaces[_namespace];\r\n    }\r\n    \r\n    function setFee(uint256 _fee) onlyOwner external {\r\n        FEE = _fee;\r\n    }\r\n    \r\n    function withdraw() onlyOwner external {\r\n        owner.transfer(this.balance);\r\n    }\r\n    \r\n    function _setName(bytes32 _namespace, string _name) internal {\r\n        addressNames[_namespace][msg.sender] = _name;\r\n        if (!takenNamespaces[_namespace]) {\r\n            takenNamespaces[_namespace] = true;\r\n        }\r\n        NameChanged(_namespace, msg.sender, _name);\r\n    }\r\n    \r\n    function _setTokenName(address _tokenInterface, uint256 _tokenId, string _name) internal {\r\n        tokenNames[_tokenInterface][_tokenId] = _name;\r\n        TokenNameChanged(_tokenInterface, _tokenId, _name);\r\n    }\r\n    \r\n    function _setTokenDescription(address _tokenInterface, uint256 _tokenId, string _description) internal {\r\n        tokenDescriptions[_tokenInterface][_tokenId] = _description;\r\n        TokenDescriptionChanged(_tokenInterface, _tokenId, _description);\r\n    }\r\n    \r\n    function _getTokenTexts(address _tokenInterface, uint256[] memory _tokenIds, bool names) internal view returns(bytes32[] memory namesData, uint256[] memory nameLength) {\r\n        uint256 length = _tokenIds.length;\r\n        nameLength = new uint256[](length);\r\n        mapping(address => mapping(uint256 => string)) textMap = names ? tokenNames : tokenDescriptions;\r\n        \r\n        bytes memory stringBytes;\r\n        uint256 size = 0;\r\n        uint256 i;\r\n        for (i = 0; i < length; i ++) {\r\n            stringBytes = bytes(textMap[_tokenInterface][_tokenIds[i]]);\r\n            size += nameLength[i] = stringBytes.length % 32 == 0 ? stringBytes.length / 32 : stringBytes.length / 32 + 1;\r\n        }\r\n        namesData = new bytes32[](size);\r\n        size = 0;\r\n        for (i = 0; i < length; i ++) {\r\n            size += _stringToBytes32(textMap[_tokenInterface][_tokenIds[i]], namesData, size);\r\n        }\r\n    }\r\n    \r\n        \r\n    function _stringToBytes32(string memory source, bytes32[] memory namesData, uint256 _start) internal pure returns (uint256) {\r\n        bytes memory stringBytes = bytes(source);\r\n        uint256 length = stringBytes.length;\r\n        bytes32[] memory result = new bytes32[](length % 32 == 0 ? length / 32 : length / 32 + 1);\r\n        \r\n        bytes32 word;\r\n        uint256 index = 0;\r\n        uint256 limit = 0;\r\n        for (uint256 i = 0; i < length; i += 32) {\r\n            limit = i + 32;\r\n            assembly {\r\n                word := mload(add(source, limit))\r\n            }\r\n            namesData[_start + index++] = word;\r\n        }\r\n        return result.length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenInterface\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setTokenName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenInterface\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getTokenDescriptions\",\"outputs\":[{\"name\":\"descriptonData\",\"type\":\"bytes32[]\"},{\"name\":\"descriptionLength\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_namespace\",\"type\":\"bytes32\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getServiceNameByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_namespace\",\"type\":\"bytes32\"}],\"name\":\"namespaceTaken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_namespace\",\"type\":\"bytes32\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setServiceName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getNameByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenInterface\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getTokenNames\",\"outputs\":[{\"name\":\"namesData\",\"type\":\"bytes32[]\"},{\"name\":\"nameLength\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenInterface\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenDescription\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenInterface\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"setTokenDescription\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address[]\"}],\"name\":\"getNames\",\"outputs\":[{\"name\":\"namesData\",\"type\":\"bytes32[]\"},{\"name\":\"nameLength\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenInterface\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_namespace\",\"type\":\"bytes32\"}],\"name\":\"getServiceName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_namespace\",\"type\":\"bytes32\"},{\"name\":\"_address\",\"type\":\"address[]\"}],\"name\":\"getServiceNames\",\"outputs\":[{\"name\":\"namesData\",\"type\":\"bytes32[]\"},{\"name\":\"nameLength\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"namespace\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenProvider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"TokenNameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenProvider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"TokenDescriptionChanged\",\"type\":\"event\"}]","ContractName":"NameProvider","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000eec590b9849dd5a97748d688d3307bf3e9c9811a","Library":"","SwarmSource":"bzzr://658afb46dff2f4ec5afb643ec0b71f03bede572ebab041fe4b059314f91d08b7"}]}