{"status":"1","message":"OK","result":[{"SourceCode":"//File: contracts/common/Controlled.sol\r\npragma solidity ^0.4.21;\r\n\r\ncontract Controlled {\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() public { controller = msg.sender;}\r\n\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n//File: contracts/common/TokenController.sol\r\npragma solidity ^0.4.21;\r\n\r\ncontract TokenController {\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\r\n}\r\n\r\n//File: contracts/common/ApproveAndCallFallBack.sol\r\npragma solidity ^0.4.21;\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\r\n}\r\n\r\n//File: contracts/Token.sol\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Token is Controlled {\r\n\r\n    string public name = \"ShineCoin\";\r\n    uint8 public decimals = 9;\r\n    string public symbol = \"SHINE\";\r\n\r\n    struct  Checkpoint {\r\n        uint128 fromBlock;\r\n        uint128 value;\r\n    }\r\n\r\n    uint public creationBlock;\r\n\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    bool public transfersEnabled = true;\r\n\r\n    address public frozenReserveTeamWallet;\r\n\r\n    uint public unfreezeTeamWalletBlock;\r\n\r\n    function Token(address _frozenReserveTeamWallet) public {\r\n        creationBlock = block.number;\r\n        frozenReserveTeamWallet = _frozenReserveTeamWallet;\r\n        unfreezeTeamWalletBlock = block.number + ((365 * 24 * 3600) / 15); // ~ 396 days\r\n    }\r\n\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n\r\n        if (address(msg.sender) == frozenReserveTeamWallet) {\r\n            require(block.number > unfreezeTeamWalletBlock);\r\n        }\r\n\r\n        doTransfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        if (msg.sender != controller) {\r\n            require(transfersEnabled);\r\n\r\n            require(allowed[_from][msg.sender] >= _amount);\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        doTransfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function doTransfer(address _from, address _to, uint _amount) internal {\r\n\r\n           if (_amount <= 0) {\r\n               emit Transfer(_from, _to, _amount);\r\n               return;\r\n           }\r\n\r\n           require((_to != 0) && (_to != address(this)));\r\n\r\n           uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\r\n\r\n           require(previousBalanceFrom >= _amount);\r\n\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           uint256 previousBalanceTo = balanceOfAt(_to, block.number);\r\n           require(previousBalanceTo + _amount >= previousBalanceTo);\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           emit Transfer(_from, _to, _amount);\r\n\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) public returns (bool success) {\r\n        require(approve(_spender, _amount));\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint) {\r\n\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            return 0;\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\r\n\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            return 0;\r\n\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n    function generateTokens(address _owner, uint _amount) public onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        emit Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n    function destroyTokens(address _owner, uint _amount) onlyController public returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        emit Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n    function enableTransfers(bool _transfersEnabled) public onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function () public payable {\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n\r\n}\r\n//File: contracts/common/SafeMath.sol\r\npragma solidity ^0.4.21;\r\n\r\ncontract SafeMath {\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n//File: ./contracts/CrowdFunder.sol\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\ncontract CrowdFunder is Controlled, SafeMath {\r\n    address public creator;\r\n    address public fundRecipient;\r\n    address public reserveTeamRecipient;\r\n    address public reserveBountyRecipient;\r\n    address public developersRecipient;\r\n    address public marketingRecipient;\r\n\r\n    bool public isReserveGenerated;\r\n\r\n    uint investorCount;\r\n    uint public currentBalance;\r\n    uint public tokensIssued;\r\n    uint public capTokenAmount;\r\n    uint public startBlockNumber;\r\n    uint public endBlockNumber;\r\n    uint public tokenExchangeRate;\r\n\r\n    address[] fiatInvestors;\r\n\r\n    Token public exchangeToken;\r\n\r\n    enum State {\r\n        Wait,\r\n        Fundraising,\r\n        Successful,\r\n        Closed\r\n    }\r\n    State public state = State.Wait;\r\n\r\n    event GoalReached(address fundRecipient, uint amountRaised);\r\n    event FundTransfer(address backer, uint amount, bool isContribution);\r\n    event FrozenFunds(address target, bool frozen);\r\n    event LogFundingReceived(address addr, uint amount, uint currentTotal);\r\n\r\n    mapping (address => uint256) private balanceOf;\r\n    mapping (address => uint) public fiatInvestorShare;\r\n    mapping (address => bool) private frozenAccount;\r\n\r\n    modifier inState(State _state) {\r\n        require(state == _state);\r\n        _;\r\n    }\r\n\r\n    modifier accountNotFrozen() {\r\n        require(!(frozenAccount[msg.sender] == true));\r\n        _;\r\n    }\r\n\r\n    modifier minInvestment() {\r\n        // User has to send at least 0.01 Eth\r\n        require(msg.value >= 10 ** 16);\r\n        _;\r\n    }\r\n\r\n    function CrowdFunder(\r\n        address _fundRecipient,\r\n        address _reserveTeamRecipient,\r\n        address _reserveBountyRecipient,\r\n        address _developersRecipient,\r\n        address _marketingRecipient,\r\n        Token _addressOfExchangeToken\r\n    ) public {\r\n        creator = msg.sender;\r\n\r\n        fundRecipient = _fundRecipient;\r\n        reserveTeamRecipient = _reserveTeamRecipient;\r\n        reserveBountyRecipient = _reserveBountyRecipient;\r\n        developersRecipient = _developersRecipient;\r\n        marketingRecipient = _marketingRecipient;\r\n\r\n        isReserveGenerated = false;\r\n\r\n        capTokenAmount = 10000000 * 10 ** 9;\r\n\r\n        state = State.Wait;\r\n\r\n        exchangeToken = Token(_addressOfExchangeToken);\r\n\r\n        currentBalance = 0;\r\n        tokensIssued = 0;\r\n        tokenExchangeRate = 0;\r\n    }\r\n\r\n    function startFundraising() public inState(State.Wait) onlyController {\r\n        startBlockNumber = block.number;\r\n        endBlockNumber = startBlockNumber + ((31 * 24 * 3600) / 15); // 31 days\r\n        state = State.Fundraising;\r\n        tokensIssued = exchangeToken.totalSupply();\r\n        updateExchangeRate();\r\n    }\r\n\r\n    function changeReserveBountyRecipient(address _reserveBountyRecipient) public onlyController {\r\n        reserveBountyRecipient = _reserveBountyRecipient;\r\n    }\r\n\r\n    function changeDevelopersRecipient(address _developersRecipient) public onlyController {\r\n        developersRecipient = _developersRecipient;\r\n    }\r\n\r\n    function changeMarketingRecipient(address _marketingRecipient) public onlyController {\r\n        marketingRecipient = _marketingRecipient;\r\n    }\r\n\r\n    function addInvestor(address target, uint share) public onlyController {\r\n        if (fiatInvestorShare[target] == uint(0x0)) { // new address\r\n            fiatInvestorShare[target] = share;\r\n            fiatInvestors.push(target);\r\n        } else { // address already exists\r\n            if (share > 0) {\r\n                uint prevShare = fiatInvestorShare[target];\r\n                uint newShare = prevShare + share;\r\n\r\n                fiatInvestorShare[target] = newShare;\r\n            }\r\n        }\r\n    }\r\n\r\n    function freezeAccount(address target, bool freeze) public onlyController {\r\n        frozenAccount[target] = freeze;\r\n        emit FrozenFunds(target, freeze);\r\n    }\r\n\r\n    function updateExchangeRate() public {\r\n        if (tokensIssued >= 0 && tokensIssued < (1000000 * 10 ** 9)) {\r\n            tokenExchangeRate = 1000 * 10 ** 9;\r\n        }\r\n        if (tokensIssued >= (1000000 * 10 ** 9) && tokensIssued < (2000000 * 10 ** 9)) {\r\n            tokenExchangeRate = 600 * 10 ** 9;\r\n        }\r\n        if (tokensIssued >= (2000000 * 10 ** 9) && tokensIssued < (3500000 * 10 ** 9)) {\r\n            tokenExchangeRate = 500 * 10 ** 9;\r\n        }\r\n        if (tokensIssued >= (3500000 * 10 ** 9) && tokensIssued < (6000000 * 10 ** 9)) {\r\n            tokenExchangeRate = 400 * 10 ** 9;\r\n        }\r\n        if (tokensIssued >= (6000000 * 10 ** 9)) {\r\n            tokenExchangeRate = 300 * 10 ** 9;\r\n        }\r\n    }\r\n\r\n    function getExchangeRate(uint amount) public constant returns (uint) {\r\n        return tokenExchangeRate * amount / 1 ether;\r\n    }\r\n\r\n    function investment() public inState(State.Fundraising) accountNotFrozen minInvestment payable returns (uint)  {\r\n        uint amount = msg.value;\r\n\r\n        balanceOf[msg.sender] += amount;\r\n        currentBalance += amount;\r\n\r\n        updateExchangeRate();\r\n        uint tokenAmount = getExchangeRate(amount);\r\n        exchangeToken.generateTokens(msg.sender, tokenAmount);\r\n        tokensIssued += tokenAmount;\r\n        updateExchangeRate();\r\n\r\n        emit FundTransfer(msg.sender, amount, true);\r\n        emit LogFundingReceived(msg.sender, tokenAmount, tokensIssued);\r\n\r\n        checkIfFundingCompleteOrExpired();\r\n\r\n        return balanceOf[msg.sender];\r\n    }\r\n\r\n    function checkIfFundingCompleteOrExpired() private {\r\n        if (block.number > endBlockNumber || tokensIssued >= capTokenAmount) {\r\n            state = State.Successful;\r\n            emit GoalReached(fundRecipient, currentBalance);\r\n        }\r\n    }\r\n\r\n    function endFundraising() public inState(State.Successful) onlyController() {\r\n        uint amount = currentBalance;\r\n        uint balance = currentBalance;\r\n\r\n        for (uint i = 0; i < fiatInvestors.length; i++) {\r\n            address investorAddress = fiatInvestors[i];\r\n            uint investorShare = fiatInvestorShare[investorAddress];\r\n            uint investorAmount = div(mul(balance, investorShare), 1000000);\r\n            investorAddress.transfer(investorAmount);\r\n            amount -= investorAmount;\r\n        }\r\n\r\n        uint percentDevelopers = 5;\r\n        uint percentMarketing = 5;\r\n        uint amountDevelopers = div(mul(balance, percentDevelopers), 100);\r\n        uint amountMarketing = div(mul(balance, percentMarketing), 100);\r\n\r\n        developersRecipient.transfer(amountDevelopers);\r\n        marketingRecipient.transfer(amountMarketing);\r\n\r\n        amount -= (amountDevelopers + amountMarketing);\r\n\r\n        fundRecipient.transfer(amount);\r\n\r\n        generateReserve();\r\n\r\n        currentBalance = 0;\r\n        state = State.Closed;\r\n\r\n        exchangeToken.changeController(controller);\r\n    }\r\n\r\n    function generateReserve() private {\r\n        require(isReserveGenerated == false);\r\n\r\n        uint issued = tokensIssued;\r\n        uint percentTeam = 15;\r\n        uint percentBounty = 1;\r\n        uint reserveAmountTeam = div(mul(issued, percentTeam), 85);\r\n        uint reserveAmountBounty = div(mul(issued, percentBounty), 99);\r\n\r\n        exchangeToken.generateTokens(reserveTeamRecipient, reserveAmountTeam);\r\n        exchangeToken.generateTokens(reserveBountyRecipient, reserveAmountBounty);\r\n\r\n        isReserveGenerated = true;\r\n    }\r\n\r\n    function removeContract() public inState(State.Closed) onlyController {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    function() inState(State.Fundraising) public accountNotFrozen minInvestment payable {\r\n        investment();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"updateExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketingRecipient\",\"type\":\"address\"}],\"name\":\"changeMarketingRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"investment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endFundraising\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developersRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveBountyRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTeamRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startFundraising\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserveBountyRecipient\",\"type\":\"address\"}],\"name\":\"changeReserveBountyRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fiatInvestorShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_developersRecipient\",\"type\":\"address\"}],\"name\":\"changeDevelopersRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isReserveGenerated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"addInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fundRecipient\",\"type\":\"address\"},{\"name\":\"_reserveTeamRecipient\",\"type\":\"address\"},{\"name\":\"_reserveBountyRecipient\",\"type\":\"address\"},{\"name\":\"_developersRecipient\",\"type\":\"address\"},{\"name\":\"_marketingRecipient\",\"type\":\"address\"},{\"name\":\"_addressOfExchangeToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fundRecipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountRaised\",\"type\":\"uint256\"}],\"name\":\"GoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isContribution\",\"type\":\"bool\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentTotal\",\"type\":\"uint256\"}],\"name\":\"LogFundingReceived\",\"type\":\"event\"}]","ContractName":"CrowdFunder","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006db9b85b37ba0df497684a45d6352261a065f1920000000000000000000000002b753dd5383b34e5e7f62179168b37542fd4b479000000000000000000000000e9bfa4167083167f628755297948ccde55f0820000000000000000000000000000374e4de533fa72a282403cb9f63a463610008f000000000000000000000000879fbe0b98c2ee58046816f2f9213f7f24369fde000000000000000000000000b7ca96345f44e8b6c5b18c94dedb742803a20809","Library":"","SwarmSource":"bzzr://ac52cb4ef98f637e1f9e6ae512090f60199644170123178ac59c4dcf9f0d5c13"}]}