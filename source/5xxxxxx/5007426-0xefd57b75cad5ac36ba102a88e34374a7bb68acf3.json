{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    \r\n    address public owner;\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title TenTimesToken\r\n * @dev An ERC20 token which doubles the balance each 2 million blocks.\r\n */\r\ncontract TenTimesToken is Ownable {\r\n    \r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) startBalances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    mapping(address => uint256) startBlocks;\r\n    \r\n    string public constant name = \"Ten Times\";\r\n    string public constant symbol = \"TENT\";\r\n    uint32 public constant decimals = 10;\r\n\r\n    function TenTimesToken() public {\r\n        totalSupply = 1000000 * 10**uint256(decimals);\r\n        startBalances[owner] = totalSupply;\r\n        startBlocks[owner] = block.number;\r\n        Transfer(address(0), owner, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev Computes `k * (1+1/q) ^ N`, with precision `p`. The higher\r\n     * the precision, the higher the gas cost. It should be\r\n     * something around the log of `n`. When `p == n`, the\r\n     * precision is absolute (sans possible integer overflows). <edit: NOT true, see comments>\r\n     * Much smaller values are sufficient to get a great approximation.\r\n     * from https://ethereum.stackexchange.com/questions/10425/is-there-any-efficient-way-to-compute-the-exponentiation-of-a-fraction-and-an-in\r\n     */\r\n    function fracExp(uint256 k, uint256 q, uint256 n, uint256 p) pure public returns (uint256) {\r\n        uint256 s = 0;\r\n        uint256 N = 1;\r\n        uint256 B = 1;\r\n        for (uint256 i = 0; i < p; ++i) {\r\n            s += k * N / B / (q**i);\r\n            N = N * (n-i);\r\n            B = B * (i+1);\r\n        }\r\n        return s;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Computes the compound interest for an account since the block stored in startBlock\r\n     * about factor 10 for 2 million blocks.\r\n     */\r\n    function compoundInterest(address tokenOwner) view public returns (uint256) {\r\n        require(startBlocks[tokenOwner] > 0);\r\n        uint256 start = startBlocks[tokenOwner];\r\n        uint256 current = block.number;\r\n        uint256 blockCount = current - start;\r\n        uint256 balance = startBalances[tokenOwner];\r\n        return fracExp(balance, 867598, blockCount, 8) - balance;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Get the token balance for account 'tokenOwner'\r\n     */\r\n    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\r\n        return startBalances[tokenOwner] + compoundInterest(tokenOwner);\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Add the compound interest to the startBalance, update the start block,\r\n     * and update totalSupply\r\n     */\r\n    function updateBalance(address tokenOwner) private {\r\n        if (startBlocks[tokenOwner] == 0) {\r\n            startBlocks[tokenOwner] = block.number;\r\n        }\r\n        uint256 ci = compoundInterest(tokenOwner);\r\n        startBalances[tokenOwner] = startBalances[tokenOwner] + ci;\r\n        totalSupply = totalSupply + ci;\r\n        startBlocks[tokenOwner] = block.number;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Transfer the balance from token owner's account to `to` account\r\n     * - Owner's account must have sufficient balance to transfer\r\n     * - 0 value transfers are allowed\r\n     */\r\n    function transfer(address to, uint256 tokens) public returns (bool) {\r\n        updateBalance(msg.sender);\r\n        updateBalance(to);\r\n        require(tokens <= startBalances[msg.sender]);\r\n\r\n        startBalances[msg.sender] = startBalances[msg.sender] - tokens;\r\n        startBalances[to] = startBalances[to] + tokens;\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Transfer `tokens` from the `from` account to the `to` account\r\n     * \r\n     * The calling account must already have sufficient tokens approve(...)-d\r\n     * for spending from the `from` account and\r\n     * - From account must have sufficient balance to transfer\r\n     * - Spender must have sufficient allowance to transfer\r\n     * - 0 value transfers are allowed\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool) {\r\n        updateBalance(from);\r\n        updateBalance(to);\r\n        require(tokens <= startBalances[from]);\r\n\r\n        startBalances[from] = startBalances[from] - tokens;\r\n        allowed[from][msg.sender] = allowed[from][msg.sender] - tokens;\r\n        startBalances[to] = startBalances[to] + tokens;\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow `spender` to withdraw from your account, multiple times, up to the 'tokens' amount.\r\n     * If this function is called again it overwrites the current allowance with 'tokens'.\r\n     */\r\n    function approve(address spender, uint256 tokens) public returns (bool) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n   \r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 tokens);\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"compoundInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"k\",\"type\":\"uint256\"},{\"name\":\"q\",\"type\":\"uint256\"},{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"fracExp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"TenTimesToken","CompilerVersion":"v0.4.16+commit.d7661dd9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6e8035cfcd01b93a0bc4c274080295c9480d69f224a9c94eafb216a648e2a343"}]}