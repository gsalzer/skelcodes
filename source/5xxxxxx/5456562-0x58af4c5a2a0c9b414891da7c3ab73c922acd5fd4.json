{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure  returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    require(b > 0);\r\n    uint c = a / b;\r\n    require(a == b * c + a % b);\r\n    return c;\r\n  }\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n  function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n  function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min256(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint);\r\n  function transfer(address to, uint value) public;\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint);\r\n  function transferFrom(address from, address to, uint value) public;\r\n  function approve(address spender, uint value) public;\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  \r\n  using SafeMath for uint;\r\n  \r\n  mapping(address => uint) balances;\r\n\r\n  function transfer(address _to, uint _value) public{\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) public constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\n\r\ncontract StandardToken is BasicToken, ERC20 {\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transferFrom(address _from, address _to, uint _value) public {\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint _value) public{\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function transferOwnership(address newOwner) onlyOwner public{\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract TTC is StandardToken, Ownable {\r\n  string public constant name = \"TTC\";\r\n  string public constant symbol = \"TTC\";\r\n  uint public constant decimals = 18;\r\n\r\n\r\n  function TTC() public {\r\n      totalSupply = 1000000000000000000000000000;\r\n      balances[msg.sender] = totalSupply; // Send all tokens to owner\r\n  }\r\n\r\n\r\n  function burn(uint _value) onlyOwner public returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    totalSupply = totalSupply.sub(_value);\r\n    Transfer(msg.sender, 0x0, _value);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract CrowdsaleMain is Ownable{\r\n    \r\n    using SafeMath for uint;\r\n\r\n    struct Backer {\r\n    uint weiReceived; \r\n    uint coinSent;\r\n    uint coinReadyToSend;\r\n  }\r\n\r\n  /*\r\n  * Constants\r\n  */\r\n\r\n  /**\r\n    * ICO Phases.\r\n    *\r\n    * - PreStart:   tokens are not yet sold/issued\r\n    * - MainIco     new tokens sold/issued at the regular price\r\n    * - AfterIco:   tokens are not sold/issued\r\n    */\r\n    enum Phases {PreStart,  MainIco, AfterIco}\r\n\r\n  /* Maximum number of TTC to main ico sell */\r\n  uint public constant MAIN_MAX_CAP = 100000000000000000000000000; // 100,000,000 TTC\r\n\r\n  /* Minimum amount to invest */\r\n  uint public constant MIN_INVEST_ETHER = 100 finney;\r\n\r\n  /* Number of TTC per Ether */\r\n  uint public constant MAIN_COIN_PER_ETHER_ICO = 4000000000000000000000; // 4,000 TTC\r\n\r\n  /*\r\n  * Variables\r\n  */\r\n\r\n  /* Crowdsale period */\r\n  uint private mainStartTime = 1524052800;  // 2018-04-18 20:00 AM (UTC + 08:00)\r\n  uint private mainEndTime = 1526644800;    // 2018-05-18 20:00 AM (UTC + 08:00)\r\n\r\n  /* TTC contract reference */\r\n  TTC public coin;\r\n\r\n  /*Maximum Ether for one address during pre ico or main ico */\r\n  uint public maximumCoinsPerAddress = 50 ether;\r\n    \r\n  /* Multisig contract that will receive the Ether during main ico*/\r\n  address public mainMultisigEther;\r\n  /* Number of Ether received during main ico */\r\n  uint public mainEtherReceived;\r\n  /* Number of TTC sent to Ether contributors during main ico */\r\n  uint public mainCoinSentToEther;\r\n\r\n  /* Backers Ether indexed by their Ethereum address */\r\n  mapping(address => Backer) public mainBackers;\r\n  address[] internal mainReadyToSendAddress;\r\n\r\n  /* White List */\r\n  mapping(address => bool) public whiteList;\r\n  address private whiteListOwner;\r\n\r\n    /* Current Phase */\r\n    Phases public phase = Phases.PreStart;\r\n\r\n  /*\r\n  * Modifiers\r\n  */\r\n\r\n  modifier respectTimeFrame() {\r\n    require((now >= mainStartTime) && (now < mainEndTime ));\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * Event\r\n  */\r\n  event LogReceivedETH(address addr, uint value);\r\n  event LogCoinsEmited(address indexed from, uint amount);\r\n\r\n  /*\r\n   * Constructor\r\n  */\r\n  function CrowdsaleMain() public{\r\n    whiteListOwner = msg.sender;\r\n  }\r\n\r\n  /**\r\n  * Allow to set TTC address\r\n  */\r\n  function setTTCAddress(address _addr) onlyOwner public {\r\n    require(_addr != address(0));\r\n    coin = TTC(_addr);\r\n  }\r\n\r\n  /**\r\n  * Allow owner to set whiteListOwner\r\n  */\r\n  function setWhiteListOwner(address _addr) onlyOwner public {\r\n    whiteListOwner = _addr;\r\n\r\n  }\r\n\r\n  /**\r\n  * Check addressExistInWhiteList\r\n  */ \r\n  function isExistInWhiteList(address _addr) public view returns (bool) {\r\n    return whiteList[_addr];\r\n  }\r\n\r\n  /**\r\n  * change main start time by owner\r\n  */\r\n  function changeMainStartTime(uint _timestamp) onlyOwner public {\r\n\r\n    mainStartTime = _timestamp;\r\n  }\r\n\r\n  /**\r\n  * change main stop time by owner\r\n  */\r\n  function changeMainEndTime(uint _timestamp) onlyOwner public {\r\n    mainEndTime = _timestamp;\r\n\r\n  }\r\n\r\n  /**\r\n   * Allow to change the team multisig address in the case of emergency.\r\n   */\r\n  function setMultisigMain(address _addr) onlyOwner public {\r\n    require(_addr != address(0));\r\n    mainMultisigEther = _addr;\r\n  }\r\n\r\n  /**\r\n  * Allow to change the maximum Coin one address can buy during the ico\r\n  */\r\n  function setMaximumCoinsPerAddress(uint _cnt) onlyOwner public{\r\n    maximumCoinsPerAddress = _cnt;\r\n  }\r\n\r\n  /* \r\n   * The fallback function corresponds to a donation in ETH\r\n   */\r\n  function() respectTimeFrame  payable public{\r\n    require(whiteList[msg.sender]);\r\n    receiveETH(msg.sender);\r\n  }\r\n\r\n  /*\r\n   *  Receives a donation in Ether\r\n  */\r\n  function receiveETH(address _beneficiary) internal {\r\n    require(msg.value >= MIN_INVEST_ETHER) ; \r\n    adjustPhaseBasedOnTime();\r\n    uint coinToSend ;\r\n\r\n    if (phase == Phases.MainIco){\r\n      Backer storage mainBacker = mainBackers[_beneficiary];\r\n      require(mainBacker.weiReceived.add(msg.value) <= maximumCoinsPerAddress);\r\n\r\n      coinToSend = msg.value.mul(MAIN_COIN_PER_ETHER_ICO).div(1 ether);   \r\n      require(coinToSend.add(mainCoinSentToEther) <= MAIN_MAX_CAP) ;\r\n\r\n      mainBacker.coinSent = mainBacker.coinSent.add(coinToSend);\r\n      mainBacker.weiReceived = mainBacker.weiReceived.add(msg.value);   \r\n      mainBacker.coinReadyToSend = mainBacker.coinReadyToSend.add(coinToSend);\r\n      mainReadyToSendAddress.push(_beneficiary);\r\n\r\n      // Update the total wei collected during the crowdfunding\r\n      mainEtherReceived = mainEtherReceived.add(msg.value); \r\n      mainCoinSentToEther = mainCoinSentToEther.add(coinToSend);\r\n\r\n      // Send events\r\n      LogReceivedETH(_beneficiary, mainEtherReceived); \r\n    }\r\n  }\r\n\r\n  /*\r\n  * Adjust phase base on time\r\n  */\r\n    function adjustPhaseBasedOnTime() internal {\r\n\r\n        if (now < mainStartTime ) {\r\n            if (phase != Phases.PreStart) {\r\n                phase = Phases.PreStart;\r\n            }\r\n        } else if (now >= mainStartTime && now < mainEndTime) {\r\n            if (phase != Phases.MainIco) {\r\n                phase = Phases.MainIco;\r\n            }\r\n        }else {\r\n          if (phase != Phases.AfterIco){\r\n            phase = Phases.AfterIco;\r\n          }\r\n        }\r\n    }\r\n  \r\n\r\n  /*\r\n  * Durign the main ico, should be called by owner to send TTC to beneficiary address\r\n  */\r\n  function mainSendTTC() onlyOwner public{\r\n    for(uint i=0; i < mainReadyToSendAddress.length ; i++){\r\n      address backerAddress = mainReadyToSendAddress[i];\r\n      uint coinReadyToSend = mainBackers[backerAddress].coinReadyToSend;\r\n      if ( coinReadyToSend > 0) {\r\n        mainBackers[backerAddress].coinReadyToSend = 0;\r\n        coin.transfer(backerAddress, coinReadyToSend);\r\n        LogCoinsEmited(backerAddress, coinReadyToSend);\r\n      }\r\n    }\r\n    delete mainReadyToSendAddress;\r\n    require(mainMultisigEther.send(this.balance)) ; \r\n\r\n  }\r\n\r\n  /*\r\n  *  White list, only address in white list can buy TTC\r\n  */\r\n  function addWhiteList(address[] _whiteList) public {\r\n    require(msg.sender == whiteListOwner);\r\n    for (uint i =0;i<_whiteList.length;i++){\r\n      whiteList[_whiteList[i]] = true;\r\n    } \r\n  }\r\n  /**\r\n  * Remove address from whiteList by whiteListOwner\r\n  */\r\n  function removeWhiteList(address[] _whiteList) public {\r\n    require(msg.sender == whiteListOwner);\r\n    for (uint i =0;i<_whiteList.length;i++){\r\n      whiteList[_whiteList[i]] = false;\r\n    }\r\n  }\r\n\r\n  /*  \r\n   * Finalize the crowdsale, should be called after the refund period\r\n  */\r\n  function finalize() onlyOwner public {\r\n    adjustPhaseBasedOnTime();\r\n    require(phase == Phases.AfterIco);\r\n    require(this.balance > 0);\r\n    require(mainMultisigEther.send(this.balance)) ; \r\n    uint remains = coin.balanceOf(this);\r\n    if (remains > 0) { \r\n      coin.transfer(owner,remains);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Manually back TTC owner address.\r\n   */\r\n  function backTTCOwner() onlyOwner public {\r\n    coin.transferOwnership(owner);\r\n  }\r\n\r\n  /**\r\n   * Transfer remains to owner in case if impossible to do min invest\r\n   */\r\n  function getMainRemainCoins() onlyOwner public {\r\n    uint mainRemains = MAIN_MAX_CAP - mainCoinSentToEther;\r\n    Backer storage backer = mainBackers[owner];\r\n    coin.transfer(owner, mainRemains); \r\n    backer.coinSent = backer.coinSent.add(mainRemains);\r\n    mainCoinSentToEther = mainCoinSentToEther.add(mainRemains);\r\n\r\n    LogCoinsEmited(this ,mainRemains);\r\n    LogReceivedETH(owner, mainEtherReceived); \r\n  }\r\n\r\n  /**\r\n  * Refund to specific address \r\n  */\r\n  function refund(address _beneficiary) onlyOwner public {\r\n    uint valueToSend = 0;\r\n    Backer storage mainBacker = mainBackers[_beneficiary];\r\n    if (mainBacker.coinReadyToSend > 0){ \r\n      uint mainValueToSend = mainBacker.coinReadyToSend.mul(1 ether).div(MAIN_COIN_PER_ETHER_ICO);\r\n      mainBacker.coinSent = mainBacker.coinSent.sub(mainBacker.coinReadyToSend);\r\n      mainBacker.weiReceived = mainBacker.weiReceived.sub(mainValueToSend);   \r\n      mainEtherReceived = mainEtherReceived.sub(mainValueToSend); \r\n      mainCoinSentToEther = mainCoinSentToEther.sub(mainBacker.coinReadyToSend);\r\n      mainBacker.coinReadyToSend = 0;\r\n      valueToSend = valueToSend + mainValueToSend;\r\n\r\n    }\r\n    if (valueToSend > 0){\r\n      require(_beneficiary.send(valueToSend));\r\n    }\r\n    \r\n  }\r\n\r\n\r\n  /**\r\n  * Refund to all address\r\n  */  \r\n  function refundAll() onlyOwner public {\r\n    \r\n    for(uint j=0; j < mainReadyToSendAddress.length ; j++){\r\n      refund(mainReadyToSendAddress[j]);\r\n\r\n    }\r\n\r\n    delete mainReadyToSendAddress;\r\n\r\n  }\r\n  \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isExistInWhiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whiteList\",\"type\":\"address[]\"}],\"name\":\"removeWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAIN_COIN_PER_ETHER_ICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"changeMainEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMainRemainCoins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whiteList\",\"type\":\"address[]\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mainBackers\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"coinSent\",\"type\":\"uint256\"},{\"name\":\"coinReadyToSend\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainMultisigEther\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVEST_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"backTTCOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumCoinsPerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWhiteListOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mainSendTTC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cnt\",\"type\":\"uint256\"}],\"name\":\"setMaximumCoinsPerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainCoinSentToEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAIN_MAX_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainEtherReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"changeMainStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMultisigMain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTTCAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogCoinsEmited\",\"type\":\"event\"}]","ContractName":"CrowdsaleMain","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ec8244feb196376dc2c196eb5b22369bf198d97e1d23616f7d2051ee0660e357"}]}