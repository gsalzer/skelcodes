{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/*****************************************************\r\n************* PENNYETHER REGISTRY ********************\r\n******************************************************\r\n\r\nRegistry allows a permanent owner to map names to addresses.\r\nAnyone can find a mapped address by calling .addressOf(),\r\nwhich throws if the name is not registered to an address.\r\n\r\nRegistry uses a doubly linked list to maintain an iterable\r\nlist of name => address mappings. When a name is mapped to\r\nthe address 0, it is removed from the list.\r\n\r\nMethods:\r\n    - [onlyOwner] register(name, address)\r\n    - [onlyOnwer] unregiser(name)\r\nPublic Views:\r\n    - size()\r\n    - addressOf(name)\r\n    - nameOf(address)\r\n    - mappings()\r\n\r\n*/\r\ncontract Registry {\r\n    // Doubly Linked List of NameEntries\r\n    struct Entry {\r\n        address addr;\r\n        bytes32 next;\r\n        bytes32 prev;\r\n    }\r\n    mapping (bytes32 => Entry) public entries;\r\n\r\n    // Used to determine if an entry is empty or not.\r\n    address constant NO_ADDRESS = address(0);\r\n\r\n    address public owner;\r\n    modifier fromOwner() { require(msg.sender==owner); _; }\r\n\r\n    event Created(uint time);\r\n    event Registered(uint time, bytes32 name, address addr);\r\n    event Unregistered(uint time, bytes32 name);\r\n\r\n    // Constructor sets the owner\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        owner = _owner;\r\n        emit Created(now);\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** OWNER METHODS ************************/\r\n    /******************************************************/\r\n\r\n    function register(bytes32 _name, address _addr)\r\n        fromOwner\r\n        public\r\n    {\r\n        require(_name != 0 && _addr != 0);\r\n        Entry storage entry = entries[_name];\r\n\r\n        // If new entry, replace first one with this one.\r\n        if (entry.addr == NO_ADDRESS) {\r\n            entry.next = entries[0x0].next;\r\n            entries[entries[0x0].next].prev = _name;\r\n            entries[0x0].next = _name;\r\n        }\r\n        // Update the address\r\n        entry.addr = _addr;\r\n        emit Registered(now, _name, _addr);\r\n    }\r\n\r\n    function unregister(bytes32 _name)\r\n        fromOwner\r\n        public\r\n    {\r\n        require(_name != 0);\r\n        Entry storage entry = entries[_name];\r\n        if (entry.addr == NO_ADDRESS) return;\r\n\r\n        // Remove entry by stitching together prev and next\r\n        entries[entry.prev].next = entry.next;\r\n        entries[entry.next].prev = entry.prev;\r\n        delete entries[_name];\r\n        emit Unregistered(now, _name);\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** PUBLIC VIEWS *************************/\r\n    /******************************************************/\r\n\r\n    function size()\r\n        public\r\n        view\r\n        returns (uint _size)\r\n    {\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _curEntry = entries[_curEntry.next];\r\n            _size++;\r\n        }\r\n        return _size;\r\n    }\r\n\r\n    // Retrieves the address for the name of _name.\r\n    function addressOf(bytes32 _name)\r\n        public\r\n        view\r\n        returns (address _addr)\r\n    {\r\n        _addr = entries[_name].addr;\r\n        require(_addr != address(0));\r\n        return _addr;\r\n    }\r\n\r\n    // Retrieves a associated with an _address.\r\n    function nameOf(address _address)\r\n        public\r\n        view\r\n        returns (bytes32 _name)\r\n    {\r\n        Entry memory _curEntry = entries[0x0];\r\n        Entry memory _nextEntry;\r\n        while (_curEntry.next > 0) {\r\n            _nextEntry = entries[_curEntry.next];\r\n            if (_nextEntry.addr == _address){\r\n                return _curEntry.next;\r\n            }\r\n            _curEntry = _nextEntry;\r\n        }\r\n    }\r\n\r\n    // Retrieves the name of _addr, if any\r\n    function mappings()\r\n        public\r\n        view\r\n        returns (bytes32[] _names, address[] _addresses)\r\n    {\r\n        uint _size = size();\r\n\r\n        // Populate names and addresses\r\n        _names = new bytes32[](_size);\r\n        _addresses = new address[](_size);\r\n        uint _i = 0;\r\n        Entry memory _curEntry = entries[0x0];\r\n        Entry memory _nextEntry;\r\n        while (_curEntry.next > 0) {\r\n            _nextEntry = entries[_curEntry.next];\r\n            _names[_i] = _curEntry.next;\r\n            _addresses[_i] = _nextEntry.addr;\r\n            _curEntry = _nextEntry;\r\n            _i++;\r\n        }\r\n        return (_names, _addresses);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"unregister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"entries\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"next\",\"type\":\"bytes32\"},{\"name\":\"prev\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mappings\",\"outputs\":[{\"name\":\"_names\",\"type\":\"bytes32[]\"},{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"size\",\"outputs\":[{\"name\":\"_size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"addressOf\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"nameOf\",\"outputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Registered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"Unregistered\",\"type\":\"event\"}]","ContractName":"Registry","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000017d77cdda0df5a9670df804d8aa2b490f760044d","Library":"","SwarmSource":"bzzr://b4754265c8ba346171ab36f0915e8df3fb5f44665998da30cb73facf1b77559d"}]}