{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\ninterface FeeBurnerInterface {\r\n    function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);\r\n}\r\n\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface ExpectedRateInterface {\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n}\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract WhiteListInterface {\r\n    function getUserCapInWei(address user) external view returns (uint userCapWei);\r\n}\r\n\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\ncontract KyberNetwork is Withdrawable, Utils {\r\n\r\n    uint public negligibleRateDiff = 10; // basic rate steps will be in 0.01%\r\n    KyberReserveInterface[] public reserves;\r\n    mapping(address=>bool) public isReserve;\r\n    WhiteListInterface public whiteListContract;\r\n    ExpectedRateInterface public expectedRateContract;\r\n    FeeBurnerInterface    public feeBurnerContract;\r\n    uint                  public maxGasPrice = 50 * 1000 * 1000 * 1000; // 50 gwei\r\n    bool                  public enabled = false; // network is enabled\r\n    mapping(bytes32=>uint) public info; // this is only a UI field for external app.\r\n    mapping(address=>mapping(bytes32=>bool)) public perReserveListedPairs;\r\n\r\n    function KyberNetwork(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    event EtherReceival(address indexed sender, uint amount);\r\n\r\n    /* solhint-disable no-complex-fallback */\r\n    function() public payable {\r\n        require(isReserve[msg.sender]);\r\n        EtherReceival(msg.sender, msg.value);\r\n    }\r\n    /* solhint-enable no-complex-fallback */\r\n\r\n    event ExecuteTrade(address indexed sender, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount);\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @return amount of actual dest tokens\r\n    function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(enabled);\r\n\r\n        uint userSrcBalanceBefore;\r\n        uint userSrcBalanceAfter;\r\n        uint userDestBalanceBefore;\r\n        uint userDestBalanceAfter;\r\n\r\n        userSrcBalanceBefore = getBalance(src, msg.sender);\r\n        if (src == ETH_TOKEN_ADDRESS)\r\n            userSrcBalanceBefore += msg.value;\r\n        userDestBalanceBefore = getBalance(dest, destAddress);\r\n\r\n        uint actualDestAmount = doTrade(src,\r\n                                        srcAmount,\r\n                                        dest,\r\n                                        destAddress,\r\n                                        maxDestAmount,\r\n                                        minConversionRate,\r\n                                        walletId\r\n                                        );\r\n        require(actualDestAmount > 0);\r\n\r\n        userSrcBalanceAfter = getBalance(src, msg.sender);\r\n        userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n        require(userSrcBalanceAfter <= userSrcBalanceBefore);\r\n        require(userDestBalanceAfter >= userDestBalanceBefore);\r\n\r\n        require((userDestBalanceAfter - userDestBalanceBefore) >=\r\n            calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest),\r\n                minConversionRate));\r\n\r\n        return actualDestAmount;\r\n    }\r\n\r\n    event AddReserveToNetwork(KyberReserveInterface reserve, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev add or deletes a reserve to/from the network.\r\n    /// @param reserve The reserve address.\r\n    /// @param add If true, the add reserve. Otherwise delete reserve.\r\n    function addReserve(KyberReserveInterface reserve, bool add) public onlyAdmin {\r\n\r\n        if (add) {\r\n            require(!isReserve[reserve]);\r\n            reserves.push(reserve);\r\n            isReserve[reserve] = true;\r\n            AddReserveToNetwork(reserve, true);\r\n        } else {\r\n            isReserve[reserve] = false;\r\n            // will have trouble if more than 50k reserves...\r\n            for (uint i = 0; i < reserves.length; i++) {\r\n                if (reserves[i] == reserve) {\r\n                    reserves[i] = reserves[reserves.length - 1];\r\n                    reserves.length--;\r\n                    AddReserveToNetwork(reserve, false);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    event ListReservePairs(address reserve, ERC20 src, ERC20 dest, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev allow or prevent a specific reserve to trade a pair of tokens\r\n    /// @param reserve The reserve address.\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /// @param add If true then enable trade, otherwise delist pair.\r\n    function listPairForReserve(address reserve, ERC20 src, ERC20 dest, bool add) public onlyAdmin {\r\n        (perReserveListedPairs[reserve])[keccak256(src, dest)] = add;\r\n\r\n        if (src != ETH_TOKEN_ADDRESS) {\r\n            if (add) {\r\n                src.approve(reserve, 2**255); // approve infinity\r\n            } else {\r\n                src.approve(reserve, 0);\r\n            }\r\n        }\r\n\r\n        setDecimals(src);\r\n        setDecimals(dest);\r\n\r\n        ListReservePairs(reserve, src, dest, add);\r\n    }\r\n\r\n    function setParams(\r\n        WhiteListInterface    _whiteList,\r\n        ExpectedRateInterface _expectedRate,\r\n        FeeBurnerInterface    _feeBurner,\r\n        uint                  _maxGasPrice,\r\n        uint                  _negligibleRateDiff\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_whiteList != address(0));\r\n        require(_feeBurner != address(0));\r\n        require(_expectedRate != address(0));\r\n        require(_negligibleRateDiff <= 100 * 100); // at most 100%\r\n\r\n        whiteListContract = _whiteList;\r\n        expectedRateContract = _expectedRate;\r\n        feeBurnerContract = _feeBurner;\r\n        maxGasPrice = _maxGasPrice;\r\n        negligibleRateDiff = _negligibleRateDiff;\r\n    }\r\n\r\n    function setEnable(bool _enable) public onlyAdmin {\r\n        if (_enable) {\r\n            require(whiteListContract != address(0));\r\n            require(feeBurnerContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n        }\r\n        enabled = _enable;\r\n    }\r\n\r\n    function setInfo(bytes32 field, uint value) public onlyOperator {\r\n        info[field] = value;\r\n    }\r\n\r\n    /// @dev returns number of reserves\r\n    /// @return number of reserves\r\n    function getNumReserves() public view returns(uint) {\r\n        return reserves.length;\r\n    }\r\n\r\n    /// @notice should be called off chain with as much gas as needed\r\n    /// @dev get an array of all reserves\r\n    /// @return An array of all reserves\r\n    function getReserves() public view returns(KyberReserveInterface[]) {\r\n        return reserves;\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev best conversion rate for a pair of tokens, if number of reserves have small differences. randomize\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /* solhint-disable code-complexity */\r\n    function findBestRate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint) {\r\n        uint bestRate = 0;\r\n        uint bestReserve = 0;\r\n        uint numRelevantReserves = 0;\r\n        uint numReserves = reserves.length;\r\n        uint[] memory rates = new uint[](numReserves);\r\n        uint[] memory reserveCandidates = new uint[](numReserves);\r\n\r\n        for (uint i = 0; i < numReserves; i++) {\r\n            //list all reserves that have this token.\r\n            if (!(perReserveListedPairs[reserves[i]])[keccak256(src, dest)]) continue;\r\n\r\n            rates[i] = reserves[i].getConversionRate(src, dest, srcQty, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate > 0) {\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < numReserves; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    reserveCandidates[numRelevantReserves++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantReserves > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant reserves\r\n                random = uint(block.blockhash(block.number-1)) % numRelevantReserves;\r\n            }\r\n\r\n            bestReserve = reserveCandidates[random];\r\n            bestRate = rates[bestReserve];\r\n        }\r\n\r\n        return (bestReserve, bestRate);\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(expectedRateContract != address(0));\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        return whiteListContract.getUserCapInWei(user);\r\n    }\r\n\r\n    function doTrade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        internal\r\n        returns(uint)\r\n    {\r\n        require(tx.gasprice <= maxGasPrice);\r\n        require(validateTradeInput(src, srcAmount, destAddress));\r\n\r\n        uint reserveInd;\r\n        uint rate;\r\n\r\n        (reserveInd, rate) = findBestRate(src, dest, srcAmount);\r\n        KyberReserveInterface theReserve = reserves[reserveInd];\r\n        require(rate > 0);\r\n        require(rate < MAX_RATE);\r\n        require(rate >= minConversionRate);\r\n\r\n        uint actualSrcAmount = srcAmount;\r\n        uint actualDestAmount = calcDestAmount(src, dest, actualSrcAmount, rate);\r\n        if (actualDestAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate);\r\n            require(actualSrcAmount <= srcAmount);\r\n        }\r\n\r\n        // do the trade\r\n        // verify trade size is smaller than user cap\r\n        uint ethAmount;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            ethAmount = actualSrcAmount;\r\n        } else {\r\n            ethAmount = actualDestAmount;\r\n        }\r\n\r\n        require(ethAmount <= getUserCapInWei(msg.sender));\r\n        require(doReserveTrade(\r\n                src,\r\n                actualSrcAmount,\r\n                dest,\r\n                destAddress,\r\n                actualDestAmount,\r\n                theReserve,\r\n                rate,\r\n                true));\r\n\r\n        if ((actualSrcAmount < srcAmount) && (src == ETH_TOKEN_ADDRESS)) {\r\n            msg.sender.transfer(srcAmount - actualSrcAmount);\r\n        }\r\n\r\n        require(feeBurnerContract.handleFees(ethAmount, theReserve, walletId));\r\n\r\n        ExecuteTrade(msg.sender, src, dest, actualSrcAmount, actualDestAmount);\r\n        return actualDestAmount;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev do one trade with a reserve\r\n    /// @param src Src token\r\n    /// @param amount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param reserve Reserve to use\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true if trade is successful\r\n    function doReserveTrade(\r\n        ERC20 src,\r\n        uint amount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint expectedDestAmount,\r\n        KyberReserveInterface reserve,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint callValue = 0;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        } else {\r\n            // take src tokens to this contract\r\n            src.transferFrom(msg.sender, this, amount);\r\n        }\r\n\r\n        // reserve sends tokens/eth to network. network sends it to destination\r\n        require(reserve.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\r\n\r\n        if (dest == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(expectedDestAmount);\r\n        } else {\r\n            require(dest.transfer(destAddress, expectedDestAmount));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev checks that user sent ether/tokens to contract before trade\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @return true if input is valid\r\n    function validateTradeInput(ERC20 src, uint srcAmount, address destAddress) internal view returns(bool) {\r\n        if ((srcAmount >= MAX_QTY) || (srcAmount == 0) || (destAddress == 0))\r\n            return false;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            if (msg.value != srcAmount)\r\n                return false;\r\n        } else {\r\n            if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/// @title Contract for a burnable ERC\r\n/// @dev From https://github.com/KyberNetwork/smart-contracts/blob/master/contracts/ERC20Interface.sol\r\n/// @dev Added burn function\r\ninterface BurnableErc20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function burn(uint _value) public;\r\n}\r\n\r\n\r\n/// @title A contract to burn ERC20 tokens from ETH on the contract\r\n/// @notice Sends the ETH on the contract to kyber for conversion to ERC20\r\n///  The converted ERC20 is then burned\r\n/// @dev Used to burn the REQ fees. Request fees are paid in ETH. The ETH is sent by the \r\n///  currency contracts to this burn contract. When the burn contract is called, it converts\r\n///  the ETH to REQ and burn the REQ\r\n/// @author Request Network\r\ncontract Burner {\r\n    /// Kyber contract that will be used for the conversion\r\n    KyberNetwork public kyberContract;\r\n\r\n    // Contract for the ERC20\r\n    BurnableErc20 public destErc20;\r\n\r\n    /// @param _destErc20 Destination token\r\n    /// @param _kyberContract Kyber contract to use\r\n    function Burner(address _destErc20, address _kyberContract) public {\r\n        // Check inputs\r\n        require(_destErc20 != address(0));\r\n        require(_kyberContract != address(0));\r\n\r\n        destErc20 = BurnableErc20(_destErc20);\r\n        kyberContract = KyberNetwork(_kyberContract);\r\n    }\r\n    \r\n    /// Fallback function to receive the ETH to burn later\r\n    function() public payable { }\r\n\r\n    /// @dev Main function. Trade the ETH for ERC20 and burn them\r\n    /// @param maxSrcAmount Maximum amount of ETH to convert. If set to 0, all ETH on the\r\n    ///  contract will be burned\r\n    /// @param maxDestAmount A limit on the amount of converted ERC20 tokens. Default value is MAX_UINT\r\n    /// @param minConversionRate The minimal conversion rate. Default value is 1 (market rate)\r\n    /// @return amount of dest ERC20 tokens burned\r\n    function burn(uint maxSrcAmount, uint maxDestAmount, uint minConversionRate)\r\n        public\r\n        returns(uint)\r\n    {\r\n        // ETH to convert on Kyber, by default the amount of ETH on the contract\r\n        // If maxSrcAmount is defined, ethToConvert = min(balance on contract, maxSrcAmount)\r\n        uint ethToConvert = this.balance;\r\n        if (maxSrcAmount != 0 && maxSrcAmount < ethToConvert) {\r\n            ethToConvert = maxSrcAmount;\r\n        }\r\n\r\n        // Set maxDestAmount to MAX_UINT if not sent as parameter\r\n        if (maxDestAmount == 0) {\r\n            maxDestAmount = 2**256 - 1;\r\n        }\r\n\r\n        // Set minConversionRate to 1 if not sent as parameter\r\n        // A value of 1 will execute the trade according to market price in the time of the transaction confirmation\r\n        if (minConversionRate == 0) {\r\n            minConversionRate = 1;\r\n        }\r\n\r\n        // Convert the ETH to ERC20\r\n        // erc20ToBurn is the amount of the ERC20 tokens converted by Kyber that will be burned\r\n        uint erc20ToBurn = kyberContract.trade.value(ethToConvert)(\r\n            // Source. From Kyber docs, this value denotes ETH\r\n            ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee),\r\n            \r\n            // Source amount\r\n            ethToConvert,\r\n\r\n            // Destination. Downcast BurnableErc20 to ERC20\r\n            ERC20(destErc20),\r\n            \r\n            // destAddress: this contract\r\n            this,\r\n            \r\n            // maxDestAmount\r\n            maxDestAmount,\r\n            \r\n            // minConversionRate \r\n            minConversionRate,\r\n            \r\n            // walletId\r\n            0\r\n        );\r\n\r\n        // Burn the converted ERC20 tokens\r\n        destErc20.burn(erc20ToBurn);\r\n\r\n        return erc20ToBurn;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"maxSrcAmount\",\"type\":\"uint256\"},{\"name\":\"maxDestAmount\",\"type\":\"uint256\"},{\"name\":\"minConversionRate\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destErc20\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_destErc20\",\"type\":\"address\"},{\"name\":\"_kyberContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Burner","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008f8221afbb33998d8584a2b05749ba73c37a938a000000000000000000000000964f35fae36d75b1e72770e244f6595b68508cf5","Library":"","SwarmSource":"bzzr://fa65b1dfe11fe1e3332d4baaa2831c5b3419255c6383793ceec467127a8de4e7"}]}