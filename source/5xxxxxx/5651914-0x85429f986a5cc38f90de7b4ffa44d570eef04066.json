{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ncontract ERC223 is ERC20 {\r\n  function transfer(address to, uint value, bytes data) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value, bytes data) returns (bool ok);\r\n}\r\n\r\n\r\n\r\n/*\r\nBase class contracts willing to accept ERC223 token transfers must conform to.\r\n\r\nSender: msg.sender to the token contract, the address originating the token transfer.\r\n          - For user originated transfers sender will be equal to tx.origin\r\n          - For contract originated transfers, tx.origin will be the user that made the tx that produced the transfer.\r\nOrigin: the origin address from whose balance the tokens are sent\r\n          - For transfer(), origin = msg.sender\r\n          - For transferFrom() origin = _from to token contract\r\nValue is the amount of tokens sent\r\nData is arbitrary data sent with the token transfer. Simulates ether tx.data\r\n\r\nFrom, origin and value shouldn't be trusted unless the token contract is trusted.\r\nIf sender == tx.origin, it is safe to trust it regardless of the token.\r\n*/\r\n\r\ncontract ERC223Receiver {\r\n  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  /*function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }*/\r\n}\r\n\r\n\r\n/**\r\n * Standard ERC20 token\r\n *\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, SafeMath {\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\ncontract KinguinKrowns is ERC223, StandardToken {\r\n  address public owner;  // token owner adddres\r\n  string public constant name = \"PINGUINS\";\r\n  string public constant symbol = \"PGS\";\r\n  uint8 public constant decimals = 18;\r\n  // uint256 public totalSupply; // defined in ERC20 contract\r\n\t\t\r\n  function KinguinKrowns() {\r\n\towner = msg.sender;\r\n    totalSupply = 100000000 * (10**18); // 100 mln\r\n    balances[msg.sender] = totalSupply;\r\n  } \r\n  \r\n  /*\r\n  //only do if call is from owner modifier\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) throw;\r\n    _;\r\n  }*/\r\n  \r\n  //function that is called when a user or another contract wants to transfer funds\r\n  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (!super.transfer(_to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value, bytes _data) returns (bool success) {\r\n    if (!super.transferFrom(_from, _to, _value)) throw; // do a normal token transfer\r\n    if (isContract(_to)) return contractFallback(_from, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    return transfer(_to, _value, new bytes(0));\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    return transferFrom(_from, _to, _value, new bytes(0));\r\n  }\r\n\r\n  //function that is called when transaction target is a contract\r\n  function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool success) {\r\n    ERC223Receiver receiver = ERC223Receiver(_to);\r\n    return receiver.tokenFallback(msg.sender, _origin, _value, _data);\r\n  }\r\n\r\n  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  function isContract(address _addr) private returns (bool is_contract) {\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }\r\n  \r\n  // returns krown balance of given address \t\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\t\r\n}\r\n\r\ncontract KinguinIco is SafeMath, ERC223Receiver {\r\n  address constant public superOwner = 0xcEbb7454429830C92606836350569A17207dA857;\r\n  address public owner;             // contract owner address\r\n  address public api;               // address of api manager\r\n  KinguinKrowns public krs;     // handler to KRS token contract\r\n  \r\n  // rounds data storage:\r\n  struct IcoRoundData {\r\n    uint rMinEthPayment;            // set minimum ETH payment\r\n    uint rKrsUsdFixed;              // set KRS/USD fixed ratio for calculation of krown amount to be sent, \r\n    uint rKycTreshold;              // KYC treshold in EUR (needed for check whether incoming payment requires KYC/AML verified address)\r\n    uint rMinKrsCap;                // minimum amount of KRS to be sent during a round\r\n    uint rMaxKrsCap;                // maximum amount of KRS to be sent during a round\r\n    uint rStartBlock;               // number of blockchain start block for a round\r\n    uint rEndBlock;                 // number of blockchain end block for a round\r\n    uint rEthPaymentsAmount;        // sum of ETH tokens received from participants during a round\r\n    uint rEthPaymentsCount;         // counter of ETH payments during a round \r\n    uint rSentKrownsAmount;         // sum of ETH tokens received from participants during a round\r\n    uint rSentKrownsCount;          // counter of KRS transactions during a round\r\n    bool roundCompleted;            // flag whether a round has finished\r\n  }\r\n  mapping(uint => IcoRoundData) public icoRounds;  // table of rounds data: ico number, ico record\r\n  \r\n  mapping(address => bool) public allowedAdresses; // list of KYC/AML approved wallets: participant address, allowed/not allowed\r\n  \r\n  struct RoundPayments {            // structure for storing sum of payments\r\n    uint round;\r\n    uint amount;\r\n  }\r\n  // amount of payments from the same address during each round \r\n  //  (to catch multiple payments to check KYC/AML approvance): participant address, payments record\r\n  mapping(address => RoundPayments) public paymentsFromAddress; \r\n\r\n  uint public ethEur;               // current EUR/ETH exchange rate (for AML check)\r\n  uint public ethUsd;               // current ETH/USD exchange rate (sending KRS for ETH calc) \r\n  uint public krsUsd;               // current KRS/USD exchange rate (sending KRS for ETH calc)\r\n  uint public rNo;                  // counter for rounds\r\n  bool public icoInProgress;        // ico status flag\r\n  bool public apiAccessDisabled;    // api access security flag\r\n  \r\n  event LogReceivedEth(address from, uint value, uint block); // publish an event about incoming ETH\r\n  event LogSentKrs(address to, uint value, uint block); // publish an event about sent KRS\r\n\r\n  // execution allowed only for contract superowner\r\n  modifier onlySuperOwner() {\r\n\trequire(msg.sender == superOwner);\r\n    _;\r\n  }\r\n\r\n  // execution allowed only for contract owner\r\n  modifier onlyOwner() {\r\n\trequire(msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  // execution allowed only for contract owner or api address\r\n  modifier onlyOwnerOrApi() {\r\n\trequire(msg.sender == owner || msg.sender == api);\r\n    if (msg.sender == api && api != owner) {\r\n      require(!apiAccessDisabled);\r\n\t}\r\n    _;\r\n  }\r\n \r\n  function KinguinIco() {\r\n    owner = msg.sender; // this contract owner\r\n    api = msg.sender; // initially api address is the contract owner's address \r\n    krs = KinguinKrowns(0xdfb410994b66778bd6cc2c82e8ffe4f7b2870006); // KRS token \r\n  } \r\n \r\n  // receiving ETH and sending KRS\r\n  function () payable {\r\n    if(msg.sender != owner) { // if ETH comes from other than the contract owner address\r\n      if(block.number >= icoRounds[rNo].rStartBlock && block.number <= icoRounds[rNo].rEndBlock && !icoInProgress) {\r\n        icoInProgress = true;\r\n      }  \r\n      require(block.number >= icoRounds[rNo].rStartBlock && block.number <= icoRounds[rNo].rEndBlock && !icoRounds[rNo].roundCompleted); // allow payments only during the ico round\r\n      require(msg.value >= icoRounds[rNo].rMinEthPayment); // minimum eth payment\r\n\t  require(ethEur > 0); // ETH/EUR rate for AML must be set earlier\r\n\t  require(ethUsd > 0); // ETH/USD rate for conversion to KRS\r\n\t  uint krowns4eth;\r\n\t  if(icoRounds[rNo].rKrsUsdFixed > 0) { // KRS has fixed ratio to USD\r\n        krowns4eth = safeDiv(safeMul(safeMul(msg.value, ethUsd), uint(100)), icoRounds[rNo].rKrsUsdFixed);\r\n\t  } else { // KRS/USD is traded on exchanges\r\n\t\trequire(krsUsd > 0); // KRS/USD rate for conversion to KRS\r\n        krowns4eth = safeDiv(safeMul(safeMul(msg.value, ethUsd), uint(100)), krsUsd);\r\n  \t  }\r\n      require(safeAdd(icoRounds[rNo].rSentKrownsAmount, krowns4eth) <= icoRounds[rNo].rMaxKrsCap); // krs cap per round\r\n\r\n      if(paymentsFromAddress[msg.sender].round != rNo) { // on mappings all keys are possible, so there is no checking for its existence\r\n        paymentsFromAddress[msg.sender].round = rNo; // on new round set to current round\r\n        paymentsFromAddress[msg.sender].amount = 0; // zeroing amount on new round\r\n      }   \r\n      if(safeMul(ethEur, safeDiv(msg.value, 10**18)) >= icoRounds[rNo].rKycTreshold || // if payment from this sender requires to be from KYC/AML approved address\r\n        // if sum of payments from this sender address requires to be from KYC/AML approved address\r\n        safeMul(ethEur, safeDiv(safeAdd(paymentsFromAddress[msg.sender].amount, msg.value), 10**18)) >= icoRounds[rNo].rKycTreshold) { \r\n\t\trequire(allowedAdresses[msg.sender]); // only KYC/AML allowed address\r\n      }\r\n\r\n      icoRounds[rNo].rEthPaymentsAmount = safeAdd(icoRounds[rNo].rEthPaymentsAmount, msg.value);\r\n      icoRounds[rNo].rEthPaymentsCount += 1; \r\n      paymentsFromAddress[msg.sender].amount = safeAdd(paymentsFromAddress[msg.sender].amount, msg.value);\r\n      LogReceivedEth(msg.sender, msg.value, block.number);\r\n      icoRounds[rNo].rSentKrownsAmount = safeAdd(icoRounds[rNo].rSentKrownsAmount, krowns4eth);\r\n      icoRounds[rNo].rSentKrownsCount += 1;\r\n      krs.transfer(msg.sender, krowns4eth);\r\n      LogSentKrs(msg.sender, krowns4eth, block.number);\r\n    } else { // owner can always pay-in (and trigger round start/stop)\r\n\t    if(block.number >= icoRounds[rNo].rStartBlock && block.number <= icoRounds[rNo].rEndBlock && !icoInProgress) {\r\n          icoInProgress = true;\r\n        }\r\n        if(block.number > icoRounds[rNo].rEndBlock && icoInProgress) {\r\n          endIcoRound();\r\n        }\r\n    }\r\n  }\r\n\r\n  // receiving tokens other than ETH\r\n  \r\n  // ERC223 receiver implementation - https://github.com/aragon/ERC23/blob/master/contracts/implementation/Standard223Receiver.sol\r\n  Tkn tkn;\r\n\r\n  struct Tkn {\r\n    address addr;\r\n    address sender;\r\n    address origin;\r\n    uint256 value;\r\n    bytes data;\r\n    bytes4 sig;\r\n  }\r\n\r\n  function tokenFallback(address _sender, address _origin, uint _value, bytes _data) returns (bool ok) {\r\n    if (!supportsToken(msg.sender)) return false;\r\n    return true;\r\n  }\r\n\r\n  function getSig(bytes _data) private returns (bytes4 sig) {\r\n    uint l = _data.length < 4 ? _data.length : 4;\r\n    for (uint i = 0; i < l; i++) {\r\n      sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (l - 1 - i))));\r\n    }\r\n  }\r\n\r\n  bool __isTokenFallback;\r\n\r\n  modifier tokenPayable {\r\n    if (!__isTokenFallback) throw;\r\n    _;\r\n  }\r\n  \r\n  function supportsToken(address token) returns (bool) {\r\n    if (token == address(krs)) {\r\n\t  return true; \r\n    } else {\r\n      revert();\r\n\t}\r\n  }\r\n  // end of ERC223 receiver implementation ------------------------------------\r\n\r\n\r\n  // set up a new ico round  \r\n  function newIcoRound(uint _rMinEthPayment, uint _rKrsUsdFixed, uint _rKycTreshold,\r\n    uint _rMinKrsCap, uint _rMaxKrsCap, uint _rStartBlock, uint _rEndBlock) public onlyOwner {\r\n    require(!icoInProgress);            // new round can be set up only after finished/cancelled the active one\r\n    require(rNo < 25);                  // limit of 25 rounds (with pre-ico)\r\n\trNo += 1;                           // increment round number, pre-ico has number 1\r\n\ticoRounds[rNo] = IcoRoundData(_rMinEthPayment, _rKrsUsdFixed, _rKycTreshold, _rMinKrsCap, _rMaxKrsCap, \r\n\t  _rStartBlock, _rEndBlock, 0, 0, 0, 0, false); // rEthPaymentsAmount, rEthPaymentsCount, rSentKrownsAmount, rSentKrownsCount); \r\n  }\r\n  \r\n  // remove current round, params only - it does not refund any ETH!\r\n  function removeCurrentIcoRound() public onlyOwner {\r\n    require(icoRounds[rNo].rEthPaymentsAmount == 0); // only if there was no payment already\r\n\trequire(!icoRounds[rNo].roundCompleted); // only current round can be removed\r\n    icoInProgress = false;\r\n    icoRounds[rNo].rMinEthPayment = 0;\r\n    icoRounds[rNo].rKrsUsdFixed = 0;\r\n    icoRounds[rNo].rKycTreshold = 0;\r\n    icoRounds[rNo].rMinKrsCap = 0;\r\n    icoRounds[rNo].rMaxKrsCap = 0;\r\n    icoRounds[rNo].rStartBlock = 0;\r\n    icoRounds[rNo].rEndBlock = 0;\r\n    icoRounds[rNo].rEthPaymentsAmount = 0;\r\n    icoRounds[rNo].rEthPaymentsCount = 0;\r\n    icoRounds[rNo].rSentKrownsAmount = 0;\r\n    icoRounds[rNo].rSentKrownsCount = 0;\r\n    if(rNo > 0) rNo -= 1;\r\n  }\r\n\r\n  function changeIcoRoundEnding(uint _rEndBlock) public onlyOwner {\r\n    require(icoRounds[rNo].rStartBlock > 0); // round must be set up earlier\r\n    icoRounds[rNo].rEndBlock = _rEndBlock;  \r\n  }\r\n \r\n  // closes round automatically\r\n  function endIcoRound() private {\r\n    icoInProgress = false;\r\n\ticoRounds[rNo].rEndBlock = block.number;\r\n\ticoRounds[rNo].roundCompleted = true;\r\n  }\r\n\r\n  // close round manually - if needed  \r\n  function endIcoRoundManually() public onlyOwner {\r\n    endIcoRound();\r\n  }\r\n  \r\n  // add a verified KYC/AML address\r\n  function addAllowedAddress(address _address) public onlyOwnerOrApi {\r\n    allowedAdresses[_address] = true;\r\n  }\r\n  function removeAllowedAddress(address _address) public onlyOwnerOrApi {\r\n    delete allowedAdresses[_address];\r\n  }\r\n\r\n  // set exchange rate for ETH/EUR - needed for check whether incoming payment\r\n  //  is more than xxxx EUR (thus requires KYC/AML verified address)\r\n  function setEthEurRate(uint _ethEur) public onlyOwnerOrApi {\r\n    ethEur = _ethEur;\r\n  }\r\n\r\n  // set exchange rate for ETH/USD\r\n  function setEthUsdRate(uint _ethUsd) public onlyOwnerOrApi {\r\n    ethUsd = _ethUsd;\r\n  }\r\n\r\n  // set exchange rate for KRS/USD\r\n  function setKrsUsdRate(uint _krsUsd) public onlyOwnerOrApi {\r\n    krsUsd = _krsUsd;\r\n  }\r\n  \r\n  // set all three exchange rates: ETH/EUR, ETH/USD, KRS/USD\r\n  function setAllRates(uint _ethEur, uint _ethUsd, uint _krsUsd) public onlyOwnerOrApi {\r\n    ethEur = _ethEur;\r\n    ethUsd = _ethUsd;\r\n\t  krsUsd = _krsUsd;\r\n  }\r\n  \r\n  // send KRS from the contract to a given address (for BTC and FIAT payments)\r\n  function sendKrs(address _receiver, uint _amount) public onlyOwnerOrApi {\r\n    krs.transfer(_receiver, _amount);\r\n  }\r\n\r\n  // transfer KRS from other holder, up to amount allowed through krs.approve() function\r\n  function getKrsFromApproved(address _from, uint _amount) public onlyOwnerOrApi {\r\n    krs.transferFrom(_from, address(this), _amount);\r\n  }\r\n  \r\n  // send ETH from the contract to a given address\r\n  function sendEth(address _receiver, uint _amount) public onlyOwner {\r\n    _receiver.transfer(_amount);\r\n  }\r\n \r\n  // disable/enable access from API - for security reasons\r\n  function disableApiAccess(bool _disabled) public onlyOwner {\r\n    apiAccessDisabled = _disabled;\r\n  }\r\n  \r\n  // change API wallet address - for security reasons\r\n  function changeApi(address _address) public onlyOwner {\r\n    api = _address;\r\n  }\r\n\r\n  // change owner address\r\n  function changeOwner(address _address) public onlySuperOwner {\r\n    owner = _address;\r\n  }\r\n  \r\n}\r\n\r\nlibrary MicroWalletLib {\r\n\r\n    //change to production token address\r\n    KinguinKrowns constant token = KinguinKrowns(0xdfb410994b66778bd6cc2c82e8ffe4f7b2870006);\r\n\r\n    struct MicroWalletStorage {\r\n        uint krsAmount ;\r\n        address owner;\r\n    }\r\n\r\n    function toBytes(address a) private pure returns (bytes b){\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n    }\r\n\r\n    function processPayment(MicroWalletStorage storage self, address _sender) public {\r\n        require(msg.sender == address(token));\r\n\r\n        if (self.owner == _sender) {    //closing MicroWallet\r\n            self.krsAmount = 0;\r\n            return;\r\n        }\r\n\r\n        require(self.krsAmount > 0);\r\n        \r\n        uint256 currentBalance = token.balanceOf(address(this));\r\n\r\n        require(currentBalance >= self.krsAmount);\r\n\r\n        if(currentBalance > self.krsAmount) {\r\n            //return rest of the token\r\n            require(token.transfer(_sender, currentBalance - self.krsAmount));\r\n        }\r\n\r\n        require(token.transfer(self.owner, self.krsAmount, toBytes(_sender)));\r\n\r\n        self.krsAmount = 0;\r\n    }\r\n}\r\n\r\ncontract KinguinVault is Ownable, ERC223Receiver {\r\n    \r\n    mapping(uint=>address) public microWalletPayments;\r\n    mapping(uint=>address) public microWalletsAddrs;\r\n    mapping(address=>uint) public microWalletsIDs;\r\n    mapping(uint=>uint) public microWalletPaymentBlockNr;\r\n\r\n    KinguinKrowns public token;\r\n    uint public uncleSafeNr = 5;\r\n    address public withdrawAddress;\r\n\r\n    modifier onlyWithdraw() {\r\n        require(withdrawAddress == msg.sender);\r\n        _;\r\n    }\r\n\r\n    constructor(KinguinKrowns _token) public {\r\n        token = _token;\r\n        withdrawAddress = owner;\r\n    }\r\n    \r\n    function createMicroWallet(uint productOrderID, uint krsAmount) onlyOwner public {\r\n        require(productOrderID != 0 && microWalletsAddrs[productOrderID] == address(0x0));\r\n        microWalletsAddrs[productOrderID] = new MicroWallet(krsAmount);\r\n        microWalletsIDs[microWalletsAddrs[productOrderID]] = productOrderID;\r\n    }\r\n\r\n    function getMicroWalletAddress(uint productOrderID) public view returns(address) {\r\n        return microWalletsAddrs[productOrderID];\r\n    }\r\n\r\n    function closeMicroWallet(uint productOrderID) onlyOwner public {\r\n        token.transfer(microWalletsAddrs[productOrderID], 0);\r\n    }\r\n\r\n    function checkIfOnUncle(uint currentBlockNr, uint transBlockNr) private view returns (bool) {\r\n        if((currentBlockNr - transBlockNr) < uncleSafeNr) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setUncleSafeNr(uint newUncleSafeNr) onlyOwner public {\r\n        uncleSafeNr = newUncleSafeNr;\r\n    }\r\n\r\n    function getProductOrderPayer(uint productOrderID) public view returns (address) {\r\n        if (checkIfOnUncle(block.number, microWalletPaymentBlockNr[productOrderID])) {\r\n            return 0;    \r\n        }\r\n        return microWalletPayments[productOrderID];\r\n    }\r\n\r\n    function tokenFallback(address _sender, address _origin, uint _value, bytes _data) public returns (bool)  {\r\n        require(msg.sender == address(token));\r\n        if(microWalletsIDs[_sender] > 0) {\r\n            microWalletPayments[microWalletsIDs[_sender]] = bytesToAddr(_data);\r\n            microWalletPaymentBlockNr[microWalletsIDs[_sender]] = block.number;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setWithdrawAccount(address _addr) onlyWithdraw public {\r\n        withdrawAddress = _addr;\r\n    } \r\n\r\n    function withdrawKrowns(address wallet, uint amount) onlyWithdraw public {\r\n        require(wallet != address(0x0));\r\n        token.transfer(wallet, amount);\r\n    }\r\n\r\n    function bytesToAddr (bytes b) private pure returns (address) {\r\n        uint result = 0;\r\n        for (uint i = b.length-1; i+1 > 0; i--) {\r\n            uint c = uint(b[i]);\r\n            uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\r\n            result += to_inc;\r\n        }\r\n        return address(result);\r\n    }\r\n}\r\n\r\ncontract MicroWallet is ERC223Receiver {\r\n    \r\n    MicroWalletLib.MicroWalletStorage private mwStorage;\r\n\r\n    constructor(uint _krsAmount) public {\r\n        mwStorage.krsAmount = _krsAmount;\r\n        mwStorage.owner = msg.sender;\r\n    }\r\n\r\n    function tokenFallback(address _sender, address _origin, uint _value, bytes _data) public returns (bool)  {\r\n        MicroWalletLib.processPayment(mwStorage, _sender);\r\n        \r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"productOrderID\",\"type\":\"uint256\"}],\"name\":\"closeMicroWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productOrderID\",\"type\":\"uint256\"},{\"name\":\"krsAmount\",\"type\":\"uint256\"}],\"name\":\"createMicroWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"productOrderID\",\"type\":\"uint256\"}],\"name\":\"getProductOrderPayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"productOrderID\",\"type\":\"uint256\"}],\"name\":\"getMicroWalletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWithdrawAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"microWalletPaymentBlockNr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_origin\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newUncleSafeNr\",\"type\":\"uint256\"}],\"name\":\"setUncleSafeNr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawKrowns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"microWalletPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"microWalletsAddrs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"microWalletsIDs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uncleSafeNr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"KinguinVault","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dfb410994b66778bd6cc2c82e8ffe4f7b2870006","Library":"MicroWalletLib:420b2fce878e4da42820e768ec31b172bd388c90","SwarmSource":"bzzr://9be73c10040ffe88ecef8cc265f980fb48f486d6775a0c54b118c9ee7d1cbe2d"}]}