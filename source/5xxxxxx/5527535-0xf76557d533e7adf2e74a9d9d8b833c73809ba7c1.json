{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract CryptoCupVirtualMatch {\r\n\r\n    // evsoftware.co.uk\r\n    // cryptocup.online\r\n\r\n    /*****------ EVENTS -----*****/\r\n    event MatchCreated(uint256 indexed id, uint256 playerEntryPrice, uint256 homeTeam, uint256 awayTeam, uint256 kickOff, uint256 fullTime);\r\n    event MatchFinished(uint256 indexed id, uint256 homeTeam, uint256 awayTeam, uint256 winningTeam, uint256 teamAllocation);\r\n    event PlayerJoined(uint256 indexed id, uint256 team, string playerName, address account);\r\n    event TeamOwnerPaid(uint256 indexed id, uint256 amount);\r\n\r\n    /*****------- STORAGE -------******/\r\n    CryptoCupToken cryptoCupTokenContract;\r\n    address public contractModifierAddress;\r\n    address public developerAddress;\r\n    mapping (uint256 => Match) public matches;\r\n    mapping (address => Player) public players;\r\n    mapping (uint256 => Team) public teams;\r\n    uint256 private developerBalance;\r\n    bool private allowInPlayJoining = true;\r\n    bool private allowPublicMatches = true;\r\n    uint256 private entryPrice = 0.05 ether; \r\n    uint256 private startInSeconds = 300;\r\n    uint256 private durationInSeconds = 120;\r\n    uint256 private dataVisibleWindow = 21600; // Initial 6 hours\r\n    uint256 private matchCounter;\r\n    uint256 private playerCounter;\r\n    uint256 private teamCounter;\r\n    bool private commentating = false;\r\n    \r\n    /*****------- DATATYPES -------******/\r\n    struct Match {\r\n        uint256 id;\r\n        uint256 playerEntryPrice;\r\n        uint256 homeTeam;\r\n        mapping (uint256 => Player) homeTeamPlayers;\r\n        uint256 homeTeamPlayersCount;\r\n        uint256 awayTeam;\r\n        mapping (uint256 => Player) awayTeamPlayers;\r\n        uint256 awayTeamPlayersCount;\r\n        uint256 kickOff;\r\n        uint256 fullTime;\r\n        uint256 prize;\r\n        uint256 homeScore;\r\n        uint256 awayScore;\r\n        uint256 winningTeam;\r\n        uint256 winningTeamBonus;\r\n        bool reported;\r\n    }\r\n\r\n    struct Player {\r\n        uint256 id;\r\n        string name;\r\n        address account;\r\n        uint256 balance;\r\n    }\r\n    \r\n    struct Team {\r\n        uint256 id;\r\n        address owner;\r\n        uint256 balance;\r\n        bool init;\r\n    }\r\n\r\n    /*****------- MODIFIERS -------******/\r\n    modifier onlyContractModifier() {\r\n        require(msg.sender == contractModifierAddress);\r\n        _;\r\n    }\r\n    \r\n    /*****------- CONSTRUCTOR -------******/\r\n    constructor() public {\r\n        contractModifierAddress = msg.sender;\r\n        developerAddress = msg.sender;\r\n    }\r\n\r\n\tfunction destroy() public onlyContractModifier {\r\n\t\tselfdestruct(contractModifierAddress);\r\n    }\r\n\r\n    function setDeveloper(address _newDeveloperAddress) public onlyContractModifier {\r\n        require(_newDeveloperAddress != address(0));\r\n        developerAddress = _newDeveloperAddress;\r\n    }\r\n\r\n    function setCryptoCupTokenContractAddress(address _cryptoCupTokenAddress) public onlyContractModifier {\r\n        cryptoCupTokenContract = CryptoCupToken(_cryptoCupTokenAddress);\r\n    }\r\n    \r\n    function togglePublicMatches() public onlyContractModifier {\r\n        // If we find an issue with people creating matches\r\n        allowPublicMatches = !allowPublicMatches;\r\n    }\r\n    \r\n    function toggleInPlayJoining() public onlyContractModifier {\r\n        // If we find an issue with people trying to join games that are in progress, we can change the logic to not allow this and they can only join before a game starts\r\n        allowInPlayJoining = !allowInPlayJoining;\r\n    }\r\n    \r\n    function toggleMatchStartEnd(uint256 _startInSeconds, uint256 _durationInSeconds) public onlyContractModifier {\r\n        startInSeconds = _startInSeconds;\r\n        durationInSeconds = _durationInSeconds;\r\n    }\r\n    \r\n    function toggleDataViewWindow(uint256 _periodInSeconds) public onlyContractModifier {\r\n        dataVisibleWindow = _periodInSeconds;\r\n    }\r\n\r\n    function doubleEntryPrice() public onlyContractModifier {\r\n        // May want to ramp up during knockouts\r\n        entryPrice = SafeMath.mul(entryPrice,2);\r\n    }\r\n    \r\n    function halveEntryPrice() public onlyContractModifier {\r\n        // Ability to ramp down\r\n        entryPrice = SafeMath.div(entryPrice,2);\r\n    }\r\n    \r\n    function developerPrizeClaim() public onlyContractModifier {\r\n        developerAddress.transfer(developerBalance);\r\n        developerBalance = 0;\r\n    }\r\n    \r\n    function getBalance()  public constant returns(uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    function getTotalMatches() public constant returns(uint256) {\r\n        return matchCounter;\r\n    }\r\n    \r\n    function getTotalPlayers() public constant returns(uint256) {\r\n        return playerCounter;\r\n    }\r\n    \r\n    function getCryptoCupTokenContractAddress() public view returns (address contractAddress) {\r\n        return cryptoCupTokenContract;\r\n    }\r\n    \r\n    function getTeamOwner(uint256 _tokenId) public view returns(address owner)\r\n    {\r\n        owner = cryptoCupTokenContract.ownerOf(_tokenId);\r\n    }\r\n\r\n    function getEntryPrice() public constant returns(uint256) {\r\n        return entryPrice;\r\n    }\r\n    \r\n    function createPlayerMatch(uint256 _homeTeam, uint256 _awayTeam, uint256 _entryPrice, uint256 _startInSecondsTime, uint256 _matchDuration) public {\r\n        require(allowPublicMatches);\r\n        require(_homeTeam != _awayTeam);\r\n        require(_homeTeam < 32 && _awayTeam < 32);\r\n        require(_entryPrice >= entryPrice);\r\n        require(_startInSecondsTime > 0);\r\n        require(_matchDuration >= durationInSeconds);\r\n        \r\n        // Does home team exist?\r\n        if (!teams[_homeTeam].init) {\r\n            teams[_homeTeam] = Team(_homeTeam, cryptoCupTokenContract.ownerOf(_homeTeam), 0, true);\r\n        }\r\n        \r\n        // Does away team exist?\r\n        if (!teams[_awayTeam].init) {\r\n            teams[_awayTeam] = Team(_awayTeam, cryptoCupTokenContract.ownerOf(_awayTeam), 0, true);\r\n        }\r\n        \r\n        // Does the user own one of these teams?\r\n        require(teams[_homeTeam].owner == msg.sender || teams[_awayTeam].owner == msg.sender);\r\n\r\n        uint256 _kickOff = now + _startInSecondsTime;\r\n        uint256 _fullTime = _kickOff + _matchDuration;\r\n        matchCounter++;\r\n        matches[matchCounter] = Match(matchCounter, _entryPrice, _homeTeam, 0, _awayTeam, 0, _kickOff, _fullTime, 0, 0, 0, 0, 0, false);\r\n        emit MatchCreated(matchCounter, entryPrice, _homeTeam, _awayTeam, _kickOff, _fullTime);\r\n    }\r\n\r\n    function createMatch(uint256 _homeTeam, uint256 _awayTeam) public onlyContractModifier {\r\n        require(_homeTeam != _awayTeam);\r\n        \r\n        // Does home team exist?\r\n        if (!teams[_homeTeam].init) {\r\n            teams[_homeTeam] = Team(_homeTeam, cryptoCupTokenContract.ownerOf(_homeTeam), 0, true);\r\n        }\r\n        \r\n        // Does away team exist?\r\n        if (!teams[_awayTeam].init) {\r\n            teams[_awayTeam] = Team(_awayTeam, cryptoCupTokenContract.ownerOf(_awayTeam), 0, true);\r\n        }\r\n        \r\n        // match starts in five mins, lasts for 3 mins\r\n        uint256 _kickOff = now + startInSeconds;\r\n        uint256 _fullTime = _kickOff + durationInSeconds;\r\n        matchCounter++;\r\n        matches[matchCounter] = Match(matchCounter, entryPrice, _homeTeam, 0, _awayTeam, 0, _kickOff, _fullTime, 0, 0, 0, 0, 0, false);\r\n        emit MatchCreated(matchCounter, entryPrice, _homeTeam, _awayTeam, _kickOff, _fullTime);\r\n    }\r\n\r\n    function joinMatch(uint256 _matchId, uint256 _team, string _playerName) public payable {\r\n\r\n        // Does player exist?\r\n        if (players[msg.sender].id == 0) {\r\n            players[msg.sender] = Player(playerCounter++, _playerName, msg.sender, 0);\r\n        } else {\r\n            players[msg.sender].name = _playerName;\r\n        }\r\n        \r\n        // Get match\r\n        Match storage theMatch = matches[_matchId];\r\n        \r\n        // Validation\r\n        require(theMatch.id != 0); \r\n        require(msg.value >= theMatch.playerEntryPrice);\r\n\t    require(_addressNotNull(msg.sender));\r\n\r\n        // Match status\r\n        if (allowInPlayJoining) {\r\n            require(now < theMatch.fullTime);    \r\n        } else {\r\n            require(now < theMatch.kickOff);\r\n        }\r\n\r\n        // Spaces left on team\r\n        if (theMatch.homeTeam == _team)\r\n        {\r\n            require(theMatch.homeTeamPlayersCount < 11);\r\n            theMatch.homeTeamPlayers[theMatch.homeTeamPlayersCount++] = players[msg.sender];\r\n        } else {\r\n            require(theMatch.awayTeamPlayersCount < 11);\r\n            theMatch.awayTeamPlayers[theMatch.awayTeamPlayersCount++] = players[msg.sender];\r\n        }\r\n\r\n        theMatch.prize += theMatch.playerEntryPrice;\r\n\r\n        // Overpayments are refunded\r\n        uint256 purchaseExcess = SafeMath.sub(msg.value, theMatch.playerEntryPrice);\r\n\t    msg.sender.transfer(purchaseExcess);\r\n\t    \r\n        emit PlayerJoined(_matchId, _team, players[msg.sender].name, msg.sender);\r\n    }\r\n    \r\n    function getMatchHomePlayers(uint256 matchId) public constant returns(address[]) {\r\n        if(matchCounter == 0) {\r\n            return new address[](0x0);\r\n        }\r\n        \r\n        // We only return matches that are in play\r\n        address[] memory matchPlayers = new address[](matches[matchId].homeTeamPlayersCount);\r\n        for (uint256 i = 0; i < matches[matchId].homeTeamPlayersCount; i++) {\r\n            matchPlayers[i] =  matches[matchId].homeTeamPlayers[i].account;\r\n        }\r\n        return (matchPlayers);\r\n    }\r\n        \r\n    function getMatchAwayPlayers(uint256 matchId) public constant returns(address[]) {\r\n        if(matchCounter == 0) {\r\n            return new address[](0x0);\r\n        }\r\n        \r\n        // We only return matches that are in play\r\n        address[] memory matchPlayers = new address[](matches[matchId].awayTeamPlayersCount);\r\n        for (uint256 i = 0; i < matches[matchId].awayTeamPlayersCount; i++) {\r\n            matchPlayers[i] =  matches[matchId].awayTeamPlayers[i].account;\r\n        }\r\n        return (matchPlayers);\r\n    }\r\n\r\n    function getFixtures() public constant returns(uint256[]) {\r\n        if(matchCounter == 0) {\r\n            return new uint[](0);\r\n        }\r\n\r\n        uint256[] memory matchIds = new uint256[](matchCounter);\r\n        uint256 numberOfMatches = 0;\r\n        for (uint256 i = 1; i <= matchCounter; i++) {\r\n            if (now < matches[i].kickOff) {\r\n                matchIds[numberOfMatches] = matches[i].id;\r\n                numberOfMatches++;\r\n            }\r\n        }\r\n\r\n        // copy it to a shorter array\r\n        uint[] memory smallerArray = new uint[](numberOfMatches);\r\n        for (uint j = 0; j < numberOfMatches; j++) {\r\n            smallerArray[j] = matchIds[j];\r\n        }\r\n        return (smallerArray);\r\n    }\r\n    \r\n    function getInPlayGames() public constant returns(uint256[]) {\r\n        if(matchCounter == 0) {\r\n            return new uint[](0);\r\n        }\r\n        \r\n        // We only return matches that are in play\r\n        uint256[] memory matchIds = new uint256[](matchCounter);\r\n        uint256 numberOfMatches = 0;\r\n        for (uint256 i = 1; i <= matchCounter; i++) {\r\n            if (now > matches[i].kickOff && now < matches[i].fullTime) {\r\n                matchIds[numberOfMatches] = matches[i].id;\r\n                numberOfMatches++;\r\n            }\r\n        }\r\n\r\n        // copy it to a shorter array\r\n        uint[] memory smallerArray = new uint[](numberOfMatches);\r\n        for (uint j = 0; j < numberOfMatches; j++) {\r\n            smallerArray[j] = matchIds[j];\r\n        }\r\n        return (smallerArray);\r\n    }\r\n    \r\n    function getUnReportedMatches() public constant returns(uint256[]) {\r\n        if(matchCounter == 0) {\r\n            return new uint[](0);\r\n        }\r\n        \r\n        // We only return matches that are finished and unreported that had players\r\n        uint256[] memory matchIds = new uint256[](matchCounter);\r\n        uint256 numberOfMatches = 0;\r\n        for (uint256 i = 1; i <= matchCounter; i++) {\r\n            if (!matches[i].reported && now > matches[i].fullTime && (matches[i].homeTeamPlayersCount + matches[i].awayTeamPlayersCount) > 0) {\r\n                matchIds[numberOfMatches] = matches[i].id;\r\n                numberOfMatches++;\r\n            }\r\n        }\r\n\r\n        // copy it to a shorter array\r\n        uint[] memory smallerArray = new uint[](numberOfMatches);\r\n        for (uint j = 0; j < numberOfMatches; j++) {\r\n            smallerArray[j] = matchIds[j];\r\n        }\r\n        return (smallerArray);\r\n    }\r\n\r\n    function getMatchReport(uint256 _matchId) public {\r\n        \r\n        Match storage theMatch = matches[_matchId];\r\n        \r\n        require(theMatch.id > 0 && !theMatch.reported);\r\n        \r\n        uint256 index;\r\n        // if a match was one sided, refund all players\r\n        if (theMatch.homeTeamPlayersCount == 0 || theMatch.awayTeamPlayersCount == 0)\r\n        {\r\n            for (index = 0; index < theMatch.homeTeamPlayersCount; index++) {\r\n                players[theMatch.homeTeamPlayers[index].account].balance += theMatch.playerEntryPrice;\r\n            }\r\n\r\n            for (index = 0; index < theMatch.awayTeamPlayersCount; index++) {\r\n                players[theMatch.awayTeamPlayers[index].account].balance += theMatch.playerEntryPrice;\r\n            }\r\n\r\n        } else {\r\n            \r\n            // Get the account balances of each team, NOT the in game balance.\r\n            uint256 htpBalance = 0;\r\n            for (index = 0; index < theMatch.homeTeamPlayersCount; index++) {\r\n               htpBalance += theMatch.homeTeamPlayers[index].account.balance;\r\n            }\r\n            \r\n            uint256 atpBalance = 0;\r\n            for (index = 0; index < theMatch.awayTeamPlayersCount; index++) {\r\n               atpBalance += theMatch.awayTeamPlayers[index].account.balance;\r\n            }\r\n            \r\n            theMatch.homeScore = htpBalance % 5;\r\n            theMatch.awayScore = atpBalance % 5;\r\n            \r\n            // We want a distinct winner\r\n            if (theMatch.homeScore == theMatch.awayScore)\r\n            {\r\n                if(block.timestamp % 2 == 0){\r\n                  theMatch.homeScore += 1;\r\n                } else {\r\n                  theMatch.awayScore += 1;\r\n                }\r\n            }\r\n    \r\n            uint256 prizeMoney = 0;\r\n            if(theMatch.homeScore > theMatch.awayScore){\r\n              // home wins\r\n              theMatch.winningTeam = theMatch.homeTeam;\r\n              prizeMoney = SafeMath.mul(theMatch.playerEntryPrice, theMatch.awayTeamPlayersCount);\r\n            } else {\r\n              // away wins\r\n              theMatch.winningTeam = theMatch.awayTeam;\r\n              prizeMoney = SafeMath.mul(theMatch.playerEntryPrice, theMatch.homeTeamPlayersCount);\r\n            }\r\n            \r\n    \t    uint256 onePercent = SafeMath.div(prizeMoney, 100);\r\n            uint256 developerAllocation = SafeMath.mul(onePercent, 1);\r\n            uint256 teamOwnerAllocation = SafeMath.mul(onePercent, 9);\r\n            uint256 playersProfit = SafeMath.mul(onePercent, 90);\r\n            \r\n            uint256 playersProfitShare = 0;\r\n            \r\n            // Allocate funds to players\r\n            if (theMatch.winningTeam == theMatch.homeTeam)\r\n            {\r\n                playersProfitShare = SafeMath.add(SafeMath.div(playersProfit, theMatch.homeTeamPlayersCount), theMatch.playerEntryPrice);\r\n                \r\n                for (index = 0; index < theMatch.homeTeamPlayersCount; index++) {\r\n                    players[theMatch.homeTeamPlayers[index].account].balance += playersProfitShare;\r\n                }\r\n                \r\n            } else {\r\n                playersProfitShare = SafeMath.add(SafeMath.div(playersProfit, theMatch.awayTeamPlayersCount), theMatch.playerEntryPrice);\r\n                \r\n                for (index = 0; index < theMatch.awayTeamPlayersCount; index++) {\r\n                    players[theMatch.awayTeamPlayers[index].account].balance += playersProfitShare;\r\n                }\r\n            }\r\n    \r\n            // Allocate to team owner\r\n            teams[theMatch.winningTeam].balance += teamOwnerAllocation;\r\n            theMatch.winningTeamBonus = teamOwnerAllocation;\r\n\r\n            // Allocate to developer\r\n\t        developerBalance += developerAllocation;\r\n            \r\n            emit MatchFinished(theMatch.id, theMatch.homeTeam, theMatch.awayTeam, theMatch.winningTeam, teamOwnerAllocation);\r\n        }\r\n        \r\n        theMatch.reported = true;\r\n    }\r\n\r\n    function getReportedMatches() public constant returns(uint256[]) {\r\n        if(matchCounter == 0) {\r\n            return new uint[](0);\r\n        }\r\n        \r\n        // We only return matches for the last x hours - everything else is on chain\r\n        uint256[] memory matchIds = new uint256[](matchCounter);\r\n        uint256 numberOfMatches = 0;\r\n        for (uint256 i = 1; i <= matchCounter; i++) {\r\n            if (matches[i].reported && now > matches[i].fullTime && matches[i].fullTime + dataVisibleWindow > now) {\r\n                matchIds[numberOfMatches] = matches[i].id;\r\n                numberOfMatches++;\r\n            }\r\n        }\r\n\r\n        // copy it to a shorter array\r\n        uint[] memory smallerArray = new uint[](numberOfMatches);\r\n        for (uint j = 0; j < numberOfMatches; j++) {\r\n            smallerArray[j] = matchIds[j];\r\n        }\r\n        return (smallerArray);\r\n    }\r\n    \r\n    function playerPrizeClaim() public {\r\n        require(_addressNotNull(msg.sender));\r\n        require(players[msg.sender].account != address(0));\r\n        \r\n        msg.sender.transfer(players[msg.sender].balance);\r\n        players[msg.sender].balance = 0;\r\n    }\r\n    \r\n    function teamPrizeClaim(uint256 _teamId) public {\r\n        require(_addressNotNull(msg.sender));\r\n        require(teams[_teamId].init);\r\n        \r\n        // This allows for sniping of teams. If a balance increases because teams have won games with bets on them\r\n        // then it is down to the owner to claim the prize. If someone spots a build up of balance on a team\r\n        // and then buys the team they can claim the prize. This is the intent.\r\n        teams[_teamId].owner = cryptoCupTokenContract.ownerOf(_teamId);\r\n        \r\n        // This way the claimant either gets the balance because he sniped the team\r\n        // Or he initiates the transfer to the rightful owner\r\n        teams[_teamId].owner.transfer(teams[_teamId].balance);\r\n        emit TeamOwnerPaid(_teamId, teams[_teamId].balance);\r\n        teams[_teamId].balance = 0;\r\n    }\r\n\r\n    /********----------- PRIVATE FUNCTIONS ------------********/\r\n    function _addressNotNull(address _to) private pure returns (bool) {\r\n        return _to != address(0);\r\n    }  \r\n}\r\n\r\ncontract CryptoCupToken {\r\n    function ownerOf(uint256 _tokenId) public view returns (address addr);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_cryptoCupTokenAddress\",\"type\":\"address\"}],\"name\":\"setCryptoCupTokenContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReportedMatches\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTeamOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_playerName\",\"type\":\"string\"}],\"name\":\"joinMatch\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startInSeconds\",\"type\":\"uint256\"},{\"name\":\"_durationInSeconds\",\"type\":\"uint256\"}],\"name\":\"toggleMatchStartEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"playerPrizeClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractModifierAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doubleEntryPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFixtures\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint256\"}],\"name\":\"teamPrizeClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teams\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"init\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matches\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"playerEntryPrice\",\"type\":\"uint256\"},{\"name\":\"homeTeam\",\"type\":\"uint256\"},{\"name\":\"homeTeamPlayersCount\",\"type\":\"uint256\"},{\"name\":\"awayTeam\",\"type\":\"uint256\"},{\"name\":\"awayTeamPlayersCount\",\"type\":\"uint256\"},{\"name\":\"kickOff\",\"type\":\"uint256\"},{\"name\":\"fullTime\",\"type\":\"uint256\"},{\"name\":\"prize\",\"type\":\"uint256\"},{\"name\":\"homeScore\",\"type\":\"uint256\"},{\"name\":\"awayScore\",\"type\":\"uint256\"},{\"name\":\"winningTeam\",\"type\":\"uint256\"},{\"name\":\"winningTeamBonus\",\"type\":\"uint256\"},{\"name\":\"reported\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInPlayGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"getMatchAwayPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"togglePublicMatches\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_periodInSeconds\",\"type\":\"uint256\"}],\"name\":\"toggleDataViewWindow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_matchId\",\"type\":\"uint256\"}],\"name\":\"getMatchReport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCryptoCupTokenContractAddress\",\"outputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"getMatchHomePlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEntryPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalMatches\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUnReportedMatches\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_homeTeam\",\"type\":\"uint256\"},{\"name\":\"_awayTeam\",\"type\":\"uint256\"},{\"name\":\"_entryPrice\",\"type\":\"uint256\"},{\"name\":\"_startInSecondsTime\",\"type\":\"uint256\"},{\"name\":\"_matchDuration\",\"type\":\"uint256\"}],\"name\":\"createPlayerMatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleInPlayJoining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_homeTeam\",\"type\":\"uint256\"},{\"name\":\"_awayTeam\",\"type\":\"uint256\"}],\"name\":\"createMatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"developerPrizeClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halveEntryPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDeveloperAddress\",\"type\":\"address\"}],\"name\":\"setDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerEntryPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"homeTeam\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"awayTeam\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"kickOff\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fullTime\",\"type\":\"uint256\"}],\"name\":\"MatchCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"homeTeam\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"awayTeam\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winningTeam\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"teamAllocation\",\"type\":\"uint256\"}],\"name\":\"MatchFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"team\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PlayerJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TeamOwnerPaid\",\"type\":\"event\"}]","ContractName":"CryptoCupVirtualMatch","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://864f0357edf0ceb97ca82916bada72aa70716e62250819c52af39295265a683b"}]}