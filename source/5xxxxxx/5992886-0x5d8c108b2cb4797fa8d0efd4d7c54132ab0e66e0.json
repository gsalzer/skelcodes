{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// Turn the usage of callcode\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract CreatorEnabled {\r\n    address public creator = 0x0;\r\n\r\n    modifier onlyCreator() { require(msg.sender==creator); _; }\r\n\r\n    function changeCreator(address _to) public onlyCreator {\r\n        creator = _to;\r\n    }\r\n}\r\n\r\n// ERC20 standard\r\ncontract StdToken is SafeMath {\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    uint public totalSupply = 0;\r\n\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns(bool) {\r\n      require(0x0!=_to);\r\n\r\n      balances[msg.sender] = safeSub(balances[msg.sender],_value);\r\n      balances[_to] = safeAdd(balances[_to],_value);\r\n\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {\r\n      require(0x0!=_to);\r\n\r\n      balances[_to] = safeAdd(balances[_to],_value);\r\n      balances[_from] = safeSub(balances[_from],_value);\r\n      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\r\n\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256) {\r\n      return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool) {\r\n      // To change the approve amount you first have to reduce the addresses`\r\n      //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n      //  already 0 to mitigate the race condition described here:\r\n      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n      require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n      allowed[msg.sender][_spender] = _value;\r\n      Approval(msg.sender, _spender, _value);\r\n      return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint _size) {\r\n      require(msg.data.length >= _size + 4);\r\n      _;\r\n    }\r\n}\r\n\r\ncontract IGoldFee {\r\n    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint);\r\n}\r\n\r\ncontract GoldFee is CreatorEnabled {\r\n\r\n    mapping(address => bool) exceptAddresses;\r\n\r\n    function GoldFee() {\r\n        creator = msg.sender;\r\n    }\r\n\r\n    function getMin(uint out)returns (uint) {\r\n        // 0.002 GOLD is min fee\r\n        uint minFee = (2 * 1 ether) / 1000;\r\n        if (out < minFee) {\r\n             return minFee;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function getMax(uint out)returns (uint) {\r\n        // 0.02 GOLD is max fee\r\n        uint maxFee = (2 * 1 ether) / 100;\r\n        if (out >= maxFee) {\r\n             return maxFee;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint)\r\n    {\r\n        return 0;\r\n\r\n       //if this is an excaptional address\r\n       if (exceptAddresses[_sender]) {\r\n            return 0;\r\n       }\r\n\r\n        // When migration process is finished (1 year from Goldmint blockchain launch), then transaction fee is 1% GOLD.\r\n        if (_isMigrationFinished) {\r\n             return (_value / 100);\r\n        }\r\n\r\n        // If the sender holds 0 MNTP, then the transaction fee is 1% GOLD.\r\n\r\n        // If the sender holds at least 10 MNTP, then the transaction fee is 0.333333% GOLD,\r\n        // but not less than 0.002 MNTP\r\n\r\n        // If the sender holds at least 1000 MNTP, then the transaction fee is 0.033333% GOLD,\r\n        // but not less than 0.002 MNTP\r\n\r\n        // If the sender holds at least 10000 MNTP, then the transaction fee is 0.0333333% GOLD,\r\n        // but not more than 0.02 MNTP\r\n        if (_mntpBalance >= (10000 * 1 ether)) {\r\n             return getMax((_value / 100) / 30);\r\n        }\r\n        if (_mntpBalance >= (1000 * 1 ether)) {\r\n             return getMin((_value / 100) / 30);\r\n        }\r\n        if (_mntpBalance >= (10 * 1 ether)) {\r\n             return getMin((_value / 100) / 3);\r\n        }\r\n\r\n        // 1%\r\n        return getMin(_value / 100);\r\n    }\r\n\r\n    function addExceptAddress(address _address) public onlyCreator {\r\n        exceptAddresses[_address] = true;\r\n    }\r\n\r\n    function removeExceptAddress(address _address) public onlyCreator {\r\n        exceptAddresses[_address] = false;\r\n    }\r\n\r\n    function isAddressExcept(address _address) public constant returns(bool) {\r\n        return exceptAddresses[_address];\r\n    }\r\n}\r\n\r\ncontract Gold is StdToken, CreatorEnabled {\r\n\r\n    string public constant name = \"GoldMint GOLD cryptoasset\";\r\n    string public constant symbol = \"GOLD\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    // this is used to send fees (that is then distributed as rewards)\r\n    address public migrationAddress = 0x0;\r\n    address public storageControllerAddress = 0x0;\r\n\r\n    address public goldmintTeamAddress = 0x0;\r\n    IMNTP public mntpToken;\r\n    IGoldFee public goldFee;\r\n\r\n\r\n    bool public transfersLocked = false;\r\n    bool public contractLocked = false;\r\n    bool public migrationStarted = false;\r\n    bool public migrationFinished = false;\r\n\r\n    uint public totalIssued = 0;\r\n    uint public totalBurnt = 0;\r\n\r\n    // Modifiers:\r\n    modifier onlyMigration() { require(msg.sender == migrationAddress); _; }\r\n    modifier onlyMigrationOrStorageController() { require(msg.sender == migrationAddress || msg.sender == storageControllerAddress); _; }\r\n    modifier onlyCreatorOrStorageController() { require(msg.sender == creator || msg.sender == storageControllerAddress); _; }\r\n    modifier onlyIfUnlocked() { require(!transfersLocked); _; }\r\n\r\n    // Functions:\r\n    function Gold(address _mntpContractAddress, address _goldmintTeamAddress, address _goldFeeAddress) public {\r\n        creator = msg.sender;\r\n\r\n        mntpToken = IMNTP(_mntpContractAddress);\r\n        goldmintTeamAddress = _goldmintTeamAddress;\r\n        goldFee = IGoldFee(_goldFeeAddress);\r\n    }\r\n\r\n    function setCreator(address _address) public onlyCreator {\r\n       creator = _address;\r\n    }\r\n\r\n    function lockContract(bool _contractLocked) public onlyCreator {\r\n       contractLocked = _contractLocked;\r\n    }\r\n\r\n    function setStorageControllerContractAddress(address _address) public onlyCreator {\r\n        storageControllerAddress = _address;\r\n    }\r\n\r\n    function setMigrationContractAddress(address _migrationAddress) public onlyCreator {\r\n        migrationAddress = _migrationAddress;\r\n    }\r\n\r\n    function setGoldmintTeamAddress(address _teamAddress) public onlyCreator {\r\n        goldmintTeamAddress = _teamAddress;\r\n    }\r\n\r\n    function setGoldFeeAddress(address _goldFeeAddress) public onlyCreator {\r\n        goldFee = IGoldFee(_goldFeeAddress);\r\n    }\r\n\r\n    function issueTokens(address _who, uint _tokens) public onlyCreatorOrStorageController {\r\n        require(!contractLocked);\r\n\r\n        balances[_who] = safeAdd(balances[_who],_tokens);\r\n        totalSupply = safeAdd(totalSupply,_tokens);\r\n        totalIssued = safeAdd(totalIssued,_tokens);\r\n\r\n        Transfer(0x0, _who, _tokens);\r\n    }\r\n\r\n    function burnTokens(address _who, uint _tokens) public onlyMigrationOrStorageController {\r\n        require(!contractLocked);\r\n        balances[_who] = safeSub(balances[_who],_tokens);\r\n        totalSupply = safeSub(totalSupply,_tokens);\r\n        totalBurnt = safeAdd(totalBurnt,_tokens);\r\n    }\r\n\r\n    // there is no way to revert that\r\n    function startMigration() public onlyMigration {\r\n        require(false == migrationStarted);\r\n        migrationStarted = true;\r\n    }\r\n\r\n    // there is no way to revert that\r\n    function finishMigration() public onlyMigration {\r\n        require(true == migrationStarted);\r\n\r\n        migrationFinished = true;\r\n    }\r\n\r\n    function lockTransfer(bool _lock) public onlyMigration {\r\n        transfersLocked = _lock;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public onlyIfUnlocked onlyPayloadSize(2 * 32) returns(bool) {\r\n\r\n        uint yourCurrentMntpBalance = mntpToken.balanceOf(msg.sender);\r\n\r\n        // you can transfer if fee is ZERO\r\n        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);\r\n        \r\n        uint sendThis = _value;\r\n        if (0 != fee) {\r\n             sendThis = safeSub(_value,fee);\r\n\r\n             // 1.Transfer fee\r\n             // A -> rewards account\r\n             //\r\n             // Each GOLD token transfer should send transaction fee to\r\n             // GoldmintMigration contract if Migration process is not started.\r\n             // Goldmint team if Migration process is started.\r\n             if (migrationStarted) {\r\n                  super.transfer(goldmintTeamAddress, fee);\r\n             } else {\r\n                  super.transfer(migrationAddress, fee);\r\n             }\r\n        }\r\n        \r\n        // 2.Transfer\r\n        // A -> B\r\n        return super.transfer(_to, sendThis);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyIfUnlocked returns(bool) {\r\n\r\n        uint yourCurrentMntpBalance = mntpToken.balanceOf(_from);\r\n\r\n        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);\r\n        if (0 != fee) {\r\n             // 1.Transfer fee\r\n             // A -> rewards account\r\n             //\r\n             // Each GOLD token transfer should send transaction fee to\r\n             // GoldmintMigration contract if Migration process is not started.\r\n             // Goldmint team if Migration process is started.\r\n             if (migrationStarted) {\r\n                  super.transferFrom(_from, goldmintTeamAddress, fee);\r\n             } else {\r\n                  super.transferFrom(_from, migrationAddress, fee);\r\n             }\r\n        }\r\n\r\n        // 2.Transfer\r\n        // A -> B\r\n        uint sendThis = safeSub(_value,fee);\r\n        return super.transferFrom(_from, _to, sendThis);\r\n    }\r\n\r\n    // Used to send rewards)\r\n    function transferRewardWithoutFee(address _to, uint _value) public onlyMigration onlyPayloadSize(2*32) {\r\n        require(0x0!=_to);\r\n\r\n        balances[migrationAddress] = safeSub(balances[migrationAddress],_value);\r\n        balances[_to] = safeAdd(balances[_to],_value);\r\n\r\n        Transfer(migrationAddress, _to, _value);\r\n    }\r\n\r\n    // This is an emergency function that can be called by Creator only\r\n    function rescueAllRewards(address _to) public onlyCreator {\r\n        require(0x0!=_to);\r\n\r\n        uint totalReward = balances[migrationAddress];\r\n\r\n        balances[_to] = safeAdd(balances[_to],totalReward);\r\n        balances[migrationAddress] = 0;\r\n\r\n        Transfer(migrationAddress, _to, totalReward);\r\n    }\r\n\r\n\r\n    function getTotalIssued() public constant returns (uint) {\r\n        return totalIssued;\r\n    }\r\n\r\n    function getTotalBurnt() public constant returns (uint) {\r\n        return totalBurnt;\r\n    }\r\n}\r\n\r\ncontract IMNTP is StdToken {\r\n    // Additional methods that MNTP contract provides\r\n    function lockTransfer(bool _lock);\r\n    function issueTokens(address _who, uint _tokens);\r\n    function burnTokens(address _who, uint _tokens);\r\n}\r\n\r\ncontract GoldmintMigration is CreatorEnabled {\r\n    \r\n    IMNTP public mntpToken;\r\n    Gold public goldToken;\r\n\r\n    address public managerAddress = 0x0;\r\n\r\n    event MntpHold(address _ethAddress, string _gmAddress, uint256 _amount);\r\n    event MntpUnhold(address _ethAddress, uint256 _amount);\r\n    event GoldHold(address _ethAddress, string _gmAddress, uint256 _amount);\r\n    event GoldUnhold(address _ethAddress, uint256 _amount);\r\n\r\n    modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }\r\n\r\n\r\n    function GoldmintMigration(address _mntpContractAddress, address _goldContractAddress) public {\r\n        creator = msg.sender;\r\n\r\n        require(_mntpContractAddress != 0);\r\n        require(_goldContractAddress != 0);\r\n\r\n        mntpToken = IMNTP(_mntpContractAddress);\r\n        goldToken = Gold(_goldContractAddress);\r\n    }\r\n\r\n    function setManagerAddress(address _address) public onlyCreator {\r\n       managerAddress = _address;\r\n    }\r\n\r\n    function lockMntpTransfers(bool _lock) public onlyCreator {\r\n        mntpToken.lockTransfer(_lock);\r\n    }\r\n\r\n    function lockGoldTransfers(bool _lock) public onlyCreator {\r\n        goldToken.lockTransfer(_lock);\r\n    }\r\n\r\n    function unholdMntp(address _ethAddress, uint _amount) public onlyManagerOrCreator {\r\n        uint balance = mntpToken.balanceOf(address(this));\r\n        require(balance >= _amount);\r\n\r\n        mntpToken.transfer(_ethAddress, _amount);\r\n\r\n        MntpUnhold(_ethAddress, _amount);\r\n    }\r\n\r\n    function unholdGold(address _ethAddress, uint _amount) public onlyManagerOrCreator {\r\n        uint balance = goldToken.balanceOf(address(this));\r\n        require(balance >= _amount);\r\n\r\n        goldToken.transfer(_ethAddress, _amount);\r\n\r\n        GoldUnhold(_ethAddress, _amount);\r\n    }\r\n\r\n    // do not allow to send money to this contract...\r\n    function() external payable {\r\n        revert();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setManagerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"lockMntpTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"lockGoldTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goldToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mntpToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unholdGold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unholdMntp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_mntpContractAddress\",\"type\":\"address\"},{\"name\":\"_goldContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ethAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_gmAddress\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"MntpHold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ethAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"MntpUnhold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ethAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_gmAddress\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"GoldHold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_ethAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"GoldUnhold\",\"type\":\"event\"}]","ContractName":"GoldmintMigration","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000083cee9e086a77e492ee0bb93c2b0437ad6fdeccc00000000000000000000000061d40b844ea5b68c9c504fccdb05b68c2d7ae965","Library":"","SwarmSource":"bzzr://00ab7c7e0f5b1c1b348cdd6d1f1790fbef4037c8982e4c446db1e209e9ff9e3b"}]}