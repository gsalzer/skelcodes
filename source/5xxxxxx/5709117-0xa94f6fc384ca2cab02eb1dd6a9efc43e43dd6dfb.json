{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title AddressTools\r\n * @dev Useful tools for address type\r\n */\r\nlibrary AddressTools {\r\n\t\r\n\t/**\r\n\t* @dev Returns true if given address is the contract address, otherwise - returns false\r\n\t*/\r\n\tfunction isContract(address a) internal view returns (bool) {\r\n\t\tif(a == address(0)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tuint codeSize;\r\n\t\t// solium-disable-next-line security/no-inline-assembly\r\n\t\tassembly {\r\n\t\t\tcodeSize := extcodesize(a)\r\n\t\t}\r\n\t\t\r\n\t\tif(codeSize > 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\t\r\n\taddress public owner;\r\n\taddress public potentialOwner;\r\n\t\r\n\t\r\n\tevent OwnershipRemoved(address indexed previousOwner);\r\n\tevent OwnershipTransfer(address indexed previousOwner, address indexed newOwner);\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyPotentialOwner() {\r\n\t\trequire(msg.sender == potentialOwner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address of potential new owner to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransfer(owner, newOwner);\r\n\t\tpotentialOwner = newOwner;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allow the potential owner confirm ownership of the contract.\r\n\t */\r\n\tfunction confirmOwnership() public onlyPotentialOwner {\r\n\t\temit OwnershipTransferred(owner, potentialOwner);\r\n\t\towner = potentialOwner;\r\n\t\tpotentialOwner = address(0);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Remove the contract owner permanently\r\n\t */\r\n\tfunction removeOwnership() public onlyOwner {\r\n\t\temit OwnershipRemoved(owner);\r\n\t\towner = address(0);\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\t\r\n\t/**\r\n\t* @dev Multiplies two numbers, throws on overflow.\r\n\t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Integer division of two numbers, truncating the quotient.\r\n\t*/\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a / b;\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Adds two numbers, throws on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Powers the first number to the second, throws on overflow.\r\n\t*/\r\n\tfunction pow(uint a, uint b) internal pure returns (uint) {\r\n\t\tif (b == 0) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tuint c = a ** b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Multiplies the given number by 10**decimals\r\n\t */\r\n\tfunction withDecimals(uint number, uint decimals) internal pure returns (uint) {\r\n\t\treturn mul(number, pow(10, decimals));\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n\tfunction totalSupply() public view returns (uint256);\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n\t\r\n\tusing SafeMath for uint256;\r\n\t\r\n\tmapping(address => uint256) public balances;\r\n\t\r\n\tuint256 public totalSupply_;\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev total number of tokens in existence\r\n\t*/\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn totalSupply_;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev transfer token for a specified address\r\n\t* @param _to The address to transfer to.\r\n\t* @param _value The amount to be transferred.\r\n\t*/\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\t\t\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param _owner The address to query the the balance of.\r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t*/\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\t\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\t\r\n\tevent Burn(address indexed burner, uint256 value);\r\n\t\r\n\t/**\r\n\t * @dev Burns a specific amount of tokens.\r\n\t * @param _value The amount of token to be burned.\r\n\t */\r\n\tfunction burn(uint256 _value) public {\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\t\t// no need to require value <= totalSupply, since that would imply the\r\n\t\t// sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\t\t\r\n\t\taddress burner = msg.sender;\r\n\t\tbalances[burner] = balances[burner].sub(_value);\r\n\t\ttotalSupply_ = totalSupply_.sub(_value);\r\n\t\temit Burn(burner, _value);\r\n\t\temit Transfer(burner, address(0), _value);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) public view returns (uint256);\r\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\tfunction approve(address spender, uint256 value) public returns (bool);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC223 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/223\r\n */\r\ncontract ERC223 is ERC20 {\r\n\tfunction transfer(address to, uint256 value, bytes data) public returns (bool);\r\n\tevent ERC223Transfer(address indexed from, address indexed to, uint256 value, bytes data);\r\n}\r\n\r\n/**\r\n * @title UKTTokenBasic\r\n * @dev UKTTokenBasic interface\r\n */\r\ncontract UKTTokenBasic is ERC223, BurnableToken {\r\n\t\r\n\tbool public isControlled = false;\r\n\tbool public isConfigured = false;\r\n\tbool public isAllocated = false;\r\n\t\r\n\t// mapping of string labels to initial allocated addresses\r\n\tmapping(bytes32 => address) public allocationAddressesTypes;\r\n\t// mapping of addresses to time lock period\r\n\tmapping(address => uint32) public timelockedAddresses;\r\n\t// mapping of addresses to lock flag\r\n\tmapping(address => bool) public lockedAddresses;\r\n\t\r\n\t\r\n\tfunction setConfiguration(string _name, string _symbol, uint _totalSupply) external returns (bool);\r\n\tfunction setInitialAllocation(address[] addresses, bytes32[] addressesTypes, uint[] amounts) external returns (bool);\r\n\tfunction setInitialAllocationLock(address allocationAddress ) external returns (bool);\r\n\tfunction setInitialAllocationUnlock(address allocationAddress ) external returns (bool);\r\n\tfunction setInitialAllocationTimelock(address allocationAddress, uint32 timelockTillDate ) external returns (bool);\r\n\t\r\n\t// fires when the token contract becomes controlled\r\n\tevent Controlled(address indexed tokenController);\r\n\t// fires when the token contract becomes configured\r\n\tevent Configured(string tokenName, string tokenSymbol, uint totalSupply);\r\n\tevent InitiallyAllocated(address indexed owner, bytes32 addressType, uint balance);\r\n\tevent InitiallAllocationLocked(address indexed owner);\r\n\tevent InitiallAllocationUnlocked(address indexed owner);\r\n\tevent InitiallAllocationTimelocked(address indexed owner, uint32 timestamp);\r\n\t\r\n}\r\n\r\n/**\r\n * @title  Basic controller contract for basic UKT token\r\n * @author  Oleg Levshin <levshin@ucoz-team.net>\r\n */\r\ncontract UKTTokenController is Ownable {\r\n\t\r\n\tusing SafeMath for uint256;\r\n\tusing AddressTools for address;\r\n\t\r\n\tbool public isFinalized = false;\r\n\t\r\n\t// address of the controlled token\r\n\tUKTTokenBasic public token;\r\n\t// finalize function type. One of two values is possible: \"transfer\" or \"burn\"\r\n\tbytes32 public finalizeType = \"transfer\";\r\n\t// address type where finalize function will transfer undistributed tokens\r\n\tbytes32 public finalizeTransferAddressType = \"\";\r\n\t// maximum quantity of addresses to distribute\r\n\tuint8 internal MAX_ADDRESSES_FOR_DISTRIBUTE = 100;\r\n\t// list of locked initial allocation addresses\r\n\taddress[] internal lockedAddressesList;\r\n\t\r\n\t\r\n\t// fires when tokens distributed to holder\r\n\tevent Distributed(address indexed holder, bytes32 indexed trackingId, uint256 amount);\r\n\t// fires when tokens distribution is finalized\r\n\tevent Finalized();\r\n\t\r\n\t/**\r\n\t * @dev The UKTTokenController constructor\r\n\t */\r\n\tfunction UKTTokenController(\r\n\t\tbytes32 _finalizeType,\r\n\t\tbytes32 _finalizeTransferAddressType\r\n\t) public {\r\n\t\trequire(_finalizeType == \"transfer\" || _finalizeType == \"burn\");\r\n\t\t\r\n\t\tif (_finalizeType == \"transfer\") {\r\n\t\t\trequire(_finalizeTransferAddressType != \"\");\r\n\t\t} else if (_finalizeType == \"burn\") {\r\n\t\t\trequire(_finalizeTransferAddressType == \"\");\r\n\t\t}\r\n\t\t\r\n\t\tfinalizeType = _finalizeType;\r\n\t\tfinalizeTransferAddressType = _finalizeTransferAddressType;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Sets controlled token\r\n\t */\r\n\tfunction setToken (\r\n\t\taddress _token\r\n\t) public onlyOwner returns (bool) {\r\n\t\trequire(token == address(0));\r\n\t\trequire(_token.isContract());\r\n\t\t\r\n\t\ttoken = UKTTokenBasic(_token);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Configures controlled token params\r\n\t */\r\n\tfunction configureTokenParams(\r\n\t\tstring _name,\r\n\t\tstring _symbol,\r\n\t\tuint _totalSupply\r\n\t) public onlyOwner returns (bool) {\r\n\t\trequire(token != address(0));\r\n\t\treturn token.setConfiguration(_name, _symbol, _totalSupply);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Allocates initial ICO balances (like team, advisory tokens and others)\r\n\t */\r\n\tfunction allocateInitialBalances(\r\n\t\taddress[] addresses,\r\n\t\tbytes32[] addressesTypes,\r\n\t\tuint[] amounts\r\n\t) public onlyOwner returns (bool) {\r\n\t\trequire(token != address(0));\r\n\t\treturn token.setInitialAllocation(addresses, addressesTypes, amounts);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Locks given allocation address\r\n\t */\r\n\tfunction lockAllocationAddress(\r\n\t\taddress allocationAddress\r\n\t) public onlyOwner returns (bool) {\r\n\t\trequire(token != address(0));\r\n\t\ttoken.setInitialAllocationLock(allocationAddress);\r\n\t\tlockedAddressesList.push(allocationAddress);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Unlocks given allocation address\r\n\t */\r\n\tfunction unlockAllocationAddress(\r\n\t\taddress allocationAddress\r\n\t) public onlyOwner returns (bool) {\r\n\t\trequire(token != address(0));\r\n\t\t\r\n\t\ttoken.setInitialAllocationUnlock(allocationAddress);\r\n\t\t\r\n\t\tfor (uint idx = 0; idx < lockedAddressesList.length; idx++) {\r\n\t\t\tif (lockedAddressesList[idx] == allocationAddress) {\r\n\t\t\t\tlockedAddressesList[idx] = address(0);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Unlocks all allocation addresses\r\n\t */\r\n\tfunction unlockAllAllocationAddresses() public onlyOwner returns (bool) {\r\n\t\tfor(uint a = 0; a < lockedAddressesList.length; a++) {\r\n\t\t\tif (lockedAddressesList[a] == address(0)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tunlockAllocationAddress(lockedAddressesList[a]);\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Locks given allocation address with timestamp\r\n\t */\r\n\tfunction timelockAllocationAddress(\r\n\t\taddress allocationAddress,\r\n\t\tuint32 timelockTillDate\r\n\t) public onlyOwner returns (bool) {\r\n\t\trequire(token != address(0));\r\n\t\treturn token.setInitialAllocationTimelock(allocationAddress, timelockTillDate);\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Distributes tokens to holders (investors)\r\n\t */\r\n\tfunction distribute(\r\n\t\taddress[] addresses,\r\n\t\tuint[] amounts,\r\n\t\tbytes32[] trackingIds\r\n\t) public onlyOwner returns (bool) {\r\n\t\trequire(token != address(0));\r\n\t\t// quantity of addresses should be less than MAX_ADDRESSES_FOR_DISTRIBUTE\r\n\t\trequire(addresses.length < MAX_ADDRESSES_FOR_DISTRIBUTE);\r\n\t\t// the array of addresses should be the same length as the array of amounts\r\n\t\trequire(addresses.length == amounts.length && addresses.length == trackingIds.length);\r\n\t\t\r\n\t\tfor(uint a = 0; a < addresses.length; a++) {\r\n\t\t\ttoken.transfer(addresses[a], amounts[a]);\r\n\t\t\temit Distributed(addresses[a], trackingIds[a], amounts[a]);\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev Finalizes the ability to use the controller and destructs it\r\n\t */\r\n\tfunction finalize() public onlyOwner {\r\n\t\t\r\n\t\tif (finalizeType == \"transfer\") {\r\n\t\t\t// transfer all undistributed tokens to particular address\r\n\t\t\ttoken.transfer(\r\n\t\t\t\ttoken.allocationAddressesTypes(finalizeTransferAddressType),\r\n\t\t\t\ttoken.balanceOf(this)\r\n\t\t\t);\r\n\t\t} else if (finalizeType == \"burn\") {\r\n\t\t\t// burn all undistributed tokens\r\n\t\t\ttoken.burn(token.balanceOf(this));\r\n\t\t}\r\n\t\t\r\n\t\trequire(unlockAllAllocationAddresses());\r\n\t\t\r\n\t\tremoveOwnership();\r\n\t\t\r\n\t\tisFinalized = true;\r\n\t\temit Finalized();\r\n\t}\r\n\t\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"configureTokenParams\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeType\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"trackingIds\",\"type\":\"bytes32[]\"}],\"name\":\"distribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allocationAddress\",\"type\":\"address\"}],\"name\":\"lockAllocationAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potentialOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allocationAddress\",\"type\":\"address\"}],\"name\":\"unlockAllocationAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeTransferAddressType\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"addressesTypes\",\"type\":\"bytes32[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"allocateInitialBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockAllAllocationAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"allocationAddress\",\"type\":\"address\"},{\"name\":\"timelockTillDate\",\"type\":\"uint32\"}],\"name\":\"timelockAllocationAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_finalizeType\",\"type\":\"bytes32\"},{\"name\":\"_finalizeTransferAddressType\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"trackingId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UKTTokenController","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"6275726e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://50ee1086babb9de9db8af139f592716d0ce444a0ffe3fd7ab8987b996d84cbb8"}]}