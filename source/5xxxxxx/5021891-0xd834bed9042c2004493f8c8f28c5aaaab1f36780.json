{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n// Contract that:\r\n//      Lets anyone bet with x ethers\r\n//      When it reaches y bets, it chooses a gambler at random and sends z% of the ethers received. other v% goes to GiveDirectly\r\n\r\n\r\ncontract Lottery {\r\n\r\n\r\n\r\n    mapping(uint => address) public gamblers;// A mapping to store ethereum addresses of the gamblers\r\n    uint8 public player_count; //keep track of how many people are signed up.\r\n    uint public ante; //how big is the bet per person (in ether)\r\n    uint8 public required_number_players; //how many sign ups trigger the lottery\r\n    uint8 public next_round_players; //how many sign ups trigger the lottery\r\n    uint random; //random number\r\n    uint public winner_percentage; // how much does the winner get (in percentage)\r\n    address owner; // owner of the contract\r\n    uint bet_blocknumber; //block number on the moment the required number of players signed up\r\n\r\n\r\n    //constructor\r\n    function Lottery(){\r\n        owner = msg.sender;\r\n        player_count = 0;\r\n        ante = 1 ether;\r\n        required_number_players = 10;\r\n        winner_percentage = 90;\r\n    }\r\n\r\nfunction refund() {\r\n    if (msg.sender == owner) {\r\n        while (this.balance > ante) {\r\n                gamblers[player_count].transfer(ante);\r\n                player_count -=1;    \r\n            }\r\n            gamblers[1].transfer(this.balance);\r\n    }\r\n}\r\n// announce the winner with an event\r\nevent Announce_winner(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint _value\r\n    );\r\n\r\n// function when someone gambles a.k.a sends ether to the contract\r\nfunction () payable {\r\n    // No arguments are necessary, all\r\n    // information is already part of\r\n    // the transaction. The keyword payable\r\n    // is required for the function to\r\n    // be able to receive Ether.\r\n\r\n    // If the bet is not equal to the ante, send the\r\n    // money back.\r\n    if(msg.value != ante) throw; // give it back, revert state changes, abnormal stop\r\n    player_count +=1;\r\n\r\n    gamblers[player_count] = msg.sender;\r\n    \r\n    // when we have enough participants\r\n    if (player_count == required_number_players) {\r\n        bet_blocknumber=block.number;\r\n    }\r\n    if (player_count > required_number_players) {\r\n        if (block.number>bet_blocknumber){\r\n            // pick a random number between 1 and 5\r\n            random = uint(block.blockhash(block.number-1))%required_number_players + 1;\r\n            // more secure way to move funds: make the winners withdraw them. Will implement later.\r\n            //asyncSend(gamblers[random],winner_payout);\r\n            gamblers[random].transfer(ante*required_number_players*winner_percentage/100);\r\n            0x4b0044E50E074A86aFAbA6eac1872c4Ce5af7712.transfer(ante*required_number_players - ante*required_number_players*winner_percentage/100);\r\n            // move the gamblers who have joined the lottery but did not participate on this draw down on the mapping structure for next bets\r\n            next_round_players = player_count-required_number_players;\r\n            while (player_count > required_number_players) {\r\n                gamblers[player_count-required_number_players] = gamblers[player_count];\r\n                player_count -=1;    \r\n            }\r\n            player_count = next_round_players;\r\n        }\r\n        else throw;\r\n    }\r\n    \r\n}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"next_round_players\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gamblers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required_number_players\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winner_percentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"player_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ante\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Announce_winner\",\"type\":\"event\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bcd53a700cc8491150f8b9e3e68e57a3744d9ed4bd5fecf8ba90cb2c5660607d"}]}