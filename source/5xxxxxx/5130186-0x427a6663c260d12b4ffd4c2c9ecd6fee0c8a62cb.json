{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @dev modifier to allow actions only when the contract IS paused\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to allow actions only when the contract IS NOT paused\r\n    */\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public returns (bool) {\r\n        paused = true;\r\n        Pause();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public returns (bool) {\r\n        paused = false;\r\n        Unpause();\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ERC721 {\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    // Required\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint _tokenId) public view returns (address approved);\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function transfer(address _to, uint256 _tokenId) public;\r\n    function implementsERC721() public pure returns (bool);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\r\n}\r\n\r\ncontract BCFAuction is Pausable {\r\n\r\n    struct CardAuction {\r\n        address seller;\r\n        uint128 startPrice; // in wei\r\n        uint128 endPrice;\r\n        uint64 duration;\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // To lookup owners \r\n    ERC721 public dataStore;\r\n    uint256 public auctioneerCut;\r\n\r\n    mapping (uint256 => CardAuction) playerCardIdToAuction;\r\n\r\n    event AuctionCreated(uint256 cardId, uint256 startPrice, uint256 endPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 cardId, uint256 finalPrice, address winner);\r\n    event AuctionCancelled(uint256 cardId);\r\n\r\n    function BCFAuction(address dataStoreAddress, uint cutValue) public {\r\n        require(cutValue <= 10000); // 100% == 10,000\r\n        auctioneerCut = cutValue;\r\n\r\n        ERC721 candidateDataStoreContract = ERC721(dataStoreAddress);\r\n        require(candidateDataStoreContract.implementsERC721());\r\n        dataStore = candidateDataStoreContract;\r\n    }\r\n\r\n    function withdrawBalance() external {\r\n        address storageAddress = address(dataStore);\r\n        require(msg.sender == owner || msg.sender == storageAddress);\r\n        storageAddress.transfer(this.balance);\r\n    }\r\n\r\n    function createAuction(\r\n        uint256 cardId, \r\n        uint256 startPrice, \r\n        uint256 endPrice, \r\n        uint256 duration, \r\n        address seller\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(startPrice == uint256(uint128(startPrice)));\r\n        require(endPrice == uint256(uint128(endPrice)));\r\n        require(duration == uint256(uint64(duration)));\r\n        require(seller != address(0));\r\n        require(address(dataStore) != address(0));\r\n        require(msg.sender == address(dataStore));\r\n\r\n        _escrow(seller, cardId);\r\n        CardAuction memory auction = CardAuction(\r\n            seller,\r\n            uint128(startPrice),\r\n            uint128(endPrice),\r\n            uint64(duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(cardId, auction);\r\n    }\r\n\r\n    function bid(uint256 cardId) external payable whenNotPaused {\r\n        _bid(cardId, msg.value); // This function handles validation and throws\r\n        _transfer(msg.sender, cardId);\r\n    }\r\n\r\n    function cancelAuction(uint256 cardId) external {\r\n        CardAuction storage auction = playerCardIdToAuction[cardId];\r\n        require(isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(cardId, seller);\r\n    }\r\n\r\n    function getAuction(uint256 cardId) external view returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        CardAuction storage auction = playerCardIdToAuction[cardId];\r\n        require(isOnAuction(auction));\r\n        return (auction.seller, auction.startPrice, auction.endPrice, auction.duration, auction.startedAt);\r\n    }\r\n\r\n    function getCurrentPrice(uint256 cardId) external view returns (uint256) {\r\n        CardAuction storage auction = playerCardIdToAuction[cardId];\r\n        require(isOnAuction(auction));\r\n        return currentPrice(auction);\r\n    }\r\n\r\n    // Internal utility functions\r\n    function ownsPlayerCard(address cardOwner, uint256 cardId) internal view returns (bool) {\r\n        return (dataStore.ownerOf(cardId) == cardOwner);\r\n    }\r\n\r\n    function _escrow(address owner, uint256 cardId) internal {\r\n        dataStore.transferFrom(owner, this, cardId);\r\n    }\r\n\r\n    function _transfer(address receiver, uint256 cardId) internal {\r\n        dataStore.transfer(receiver, cardId);\r\n    }\r\n\r\n    function _addAuction(uint256 cardId, CardAuction auction) internal {\r\n        require(auction.duration >= 1 minutes && auction.duration <= 14 days);\r\n        playerCardIdToAuction[cardId] = auction;\r\n        AuctionCreated(cardId, auction.startPrice, auction.endPrice, auction.duration);\r\n    }\r\n\r\n    function _removeAuction(uint256 cardId) internal {\r\n        delete playerCardIdToAuction[cardId];\r\n    }\r\n\r\n    function _cancelAuction(uint256 cardId, address seller) internal {\r\n        _removeAuction(cardId);\r\n        _transfer(seller, cardId);\r\n        AuctionCancelled(cardId);\r\n    }\r\n\r\n    function isOnAuction(CardAuction storage auction) internal view returns (bool) {\r\n        return (auction.startedAt > 0);\r\n    }\r\n\r\n    function _bid(uint256 cardId, uint256 bidAmount) internal returns (uint256) {\r\n        CardAuction storage auction = playerCardIdToAuction[cardId];\r\n        require(isOnAuction(auction));\r\n\r\n        uint256 price = currentPrice(auction);\r\n        require(bidAmount >= price);\r\n\r\n        address seller = auction.seller;\r\n        _removeAuction(cardId);\r\n\r\n        if (price > 0) {\r\n            uint256 handlerCut = calculateAuctioneerCut(price);\r\n            uint256 sellerProceeds = price - handlerCut;\r\n            seller.transfer(sellerProceeds);\r\n        } \r\n\r\n        uint256 bidExcess = bidAmount - price;\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        AuctionSuccessful(cardId, price, msg.sender); // Emit event/log\r\n\r\n        return price;\r\n    }\r\n\r\n    function currentPrice(CardAuction storage auction) internal view returns (uint256) {\r\n        uint256 secondsPassed = 0;\r\n        if (now > auction.startedAt) {\r\n            secondsPassed = now - auction.startedAt;\r\n        }\r\n\r\n        return calculateCurrentPrice(auction.startPrice, auction.endPrice, auction.duration, secondsPassed);\r\n    }\r\n\r\n    function calculateCurrentPrice(uint256 startPrice, uint256 endPrice, uint256 duration, uint256 secondsElapsed)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (secondsElapsed >= duration) {\r\n            return endPrice;\r\n        } \r\n\r\n        int256 totalPriceChange = int256(endPrice) - int256(startPrice);\r\n        int256 currentPriceChange = totalPriceChange * int256(secondsElapsed) / int256(duration);\r\n        int256 _currentPrice = int256(startPrice) + currentPriceChange;\r\n\r\n        return uint256(_currentPrice);\r\n    }\r\n\r\n    function calculateAuctioneerCut(uint256 sellPrice) internal view returns (uint256) {\r\n        // 10,000 = 100%, ownerCut required'd <= 10,000 in the constructor so no requirement to validate here\r\n        uint finalCut = sellPrice * auctioneerCut / 10000;\r\n        return finalCut;\r\n    }    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"cardId\",\"type\":\"uint256\"},{\"name\":\"startPrice\",\"type\":\"uint256\"},{\"name\":\"endPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataStore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctioneerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"dataStoreAddress\",\"type\":\"address\"},{\"name\":\"cutValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"BCFAuction","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000006abf810730a342add1374e11f3e97500ee774d1f0000000000000000000000000000000000000000000000000000000000000190","Library":"","SwarmSource":"bzzr://ccbe8212b336775bcf45f8b0e603ad4d320fc4482c9ec1b0007b7cab3d6694cd"}]}