{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title CryptoDivert DAPP\r\n * @dev Implementation of the CryptoDivert Smart Contract.\r\n * @version 2018.04.05 \r\n * @copyright All rights reserved (c) 2018 Cryptology ltd, Hong Kong.\r\n * @author Cryptology ltd, Hong Kong.\r\n * @disclaimer CryptoDivert DAPP provided by Cryptology ltd, Hong Kong is for illustrative purposes only. \r\n * \r\n * The interface for this contract is running on https://CryptoDivert.io \r\n * \r\n * You can also use the contract in https://www.myetherwallet.com/#contracts. \r\n * With ABI / JSON Interface:\r\n * [{\"constant\":true,\"inputs\":[],\"name\":\"showPendingAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_password\",\"type\":\"string\"},{\"name\":\"_originAddress\",\"type\":\"address\"}],\"name\":\"Retrieve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ping\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whoIsAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originAddressHash\",\"type\":\"bytes20\"},{\"name\":\"_releaseTime\",\"type\":\"uint256\"},{\"name\":\"_privacyCommission\",\"type\":\"uint16\"}],\"name\":\"SafeGuard\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_originAddressHash\",\"type\":\"bytes20\"}],\"name\":\"AuditSafeGuard\",\"outputs\":[{\"name\":\"_safeGuarded\",\"type\":\"uint256\"},{\"name\":\"_timelock\",\"type\":\"uint256\"},{\"name\":\"_privacypercentage\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AuditBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"RetrieveCommissions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentAdmin\",\"type\":\"address\"}],\"name\":\"ContractAdminTransferPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"NewContractAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CommissionsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes20\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"comissions\",\"type\":\"uint256\"}],\"name\":\"SafeGuardSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RetrieveSuccess\",\"type\":\"event\"}]\r\n * \r\n * ABOUT\r\n * This Distributed Application (DAPP) provides private (pseudo-anonymous) transactions on the ETH blockchain.\r\n * A forensic expert will be able to trace these transaction with some time and effort. If you don't do\r\n * anything illegal where time and effort will be spend to trace you down this should be providing you enough privacy. \r\n * You can create public and private transfers (public: anybody with the password can retrieve, private: only a specific address can retrieve).\r\n * For private transfers there will be no direct link between safeguarding and retrieving the funds, only an indirect link\r\n * where a forensic investigator would have to trial and error hashing all retrieved password/address combinations \r\n * until he stumbles upon the one you used to safeguard the ETH. The more usage this DAPP gets, the more private it becomes.\r\n *\r\n * You can check our FAQ at https://cryptodivert.io/faq for details.\r\n * \r\n * This software is supplied \"AS IS\" without any warranties and support. \r\n * Cryptology ltd assumes no responsibility or liability for the use of the software, \r\n * conveys no license or title under any patent, copyright, or mask work right to the product. \r\n * Cryptology ltd make no representation or warranty that such application will be suitable for \r\n * the specified use without further testing or modification.\r\n * \r\n * To the maximum extent permitted by applicable law, in no event shall Cryptology ltd be liable for \r\n * any direct, indirect, punitive, incidental, special, consequential damages or any damages \r\n * whatsoever including, without limitation, damages for loss of use, data or profits, arising \r\n * out of or in any way connected with the use or performance of the CryptoDivert DAPP, with the delay \r\n * or inability to use the CryptoDivert DAPP or related services, the provision of or failure to \r\n * provide services, or for any information obtained through the CryptoDivert DAPP, or otherwise arising out \r\n * of the use of the CryptoDivert DAPP, whether based on contract, tort, negligence, strict liability \r\n * or otherwise, even if Cryptology ltd has been advised of the possibility of damages. \r\n * Because some states/jurisdictions do not allow the exclusion or limitation of liability for \r\n * consequential or incidental damages, the above limitation may not apply to you. \r\n * If you are dissatisfied with any portion of the CryptoDivert DAPP, or with any of these terms of \r\n * use, your sole and exclusive remedy is to discontinue using the CryptoDivert DAPP.\r\n * \r\n * DO NOT USE THIS DAPP IN A WAY THAT VIOLATES ANY LAW, WOULD CREATE LIABILITY OR PROMOTES\r\n * ILLEGAL ACTIVITIES. \r\n */\r\n \r\npragma solidity ^0.4.21;\r\n\r\ncontract CryptoDivert {\r\n    using SafeMath for uint256; // We don't like overflow errors.\r\n    \r\n    // ETH address of the admin.\r\n    // Some methods from this contract can only be executed by the admin address.\r\n    address private admin;\r\n    \r\n    // Used to confirm a new Admin address. The current admin sets this variable \r\n    // when he wants to transfer the contract. The change will only be implemented \r\n    // once the new admin ETH address confirms the address is correct.\r\n    address private pendingAdmin; \r\n    \r\n    // 0x ETH address, we check input against this address.\r\n    address private constant NO_ADDRESS = address(0);\r\n    \r\n    // Store the originating addresses for every SafeGuard. These will be used to \r\n    // verify the bytes20 hash when a safeguard is retrieved.\r\n    mapping (bytes20 => address) private senders;\r\n    \r\n    // Allow a SafeGuard to be locked until a certain time (e.g. can`t be retrieved before).\r\n    mapping (bytes20 => uint256) private timers;\r\n    \r\n    // Allow a maximum deviation of the amount by x% where x/100 is x * 1%\r\n    mapping (bytes20 => uint16) private privacyDeviation;\r\n    \r\n    // Store the value of every SafeGuard.\r\n    mapping (bytes20 => uint256) private balances;\r\n    \r\n    // Keep balance administrations. \r\n    uint256 private userBalance; // The total value of all outstanding safeguards combined.\r\n    \r\n    // Create additional privacy (only for receiver hashed transfers)\r\n    uint256 private privacyFund;\r\n    \r\n    /// EVENTS ///\r\n    event ContractAdminTransferPending(address pendingAdmin, address currentAdmin);\r\n    event NewContractAdmin(address newAdmin, address previousAdmin);\r\n    event SafeGuardSuccess(bytes20 hash, uint256 value, uint256 comissions);\r\n    event RetrieveSuccess(uint256 value);\r\n    \r\n    \r\n    /// MODIFIERS ///\r\n    /**\r\n     * @dev Only allow a method to be executed if '_who' is not the 0x address\r\n     */\r\n    modifier isAddress(address _who) {\r\n        require(_who != NO_ADDRESS);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Only allow a method the be executed if the input hasn't been messed with.\r\n     */\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size +4); // +4 because the 4 bytes of the method.\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Only allow a method to be executed if 'msg.sender' is the admin.\r\n     */\r\n    modifier OnlyByAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Only allow a method to be executed if '_who' is not the admin.\r\n     */\r\n    modifier isNotAdmin(address _who) {\r\n        require(_who != admin);\r\n        _;\r\n    }\r\n\r\n    /// PUBLIC METHODS ///    \r\n    function CryptoDivert() public {\r\n        // We need to define the initial administrator for this DAPP.\r\n        // This should be transferred to the permanent administrator after the contract\r\n        // has been created on the blockchain.\r\n        admin = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * @dev Process users sending ETH to this contract.\r\n     * Don't send ETH directly to this contract, use the SafeGuard method to \r\n     * safeguard your ETHs; then again we don't mind if you like to \r\n     * buy us a beer (or a Lambo). In that case thanks for the ETH! \r\n     * We'll assume you actually intended to tip us.\r\n     */\r\n    function() public payable {\r\n    }\r\n    \r\n    /// EXTERNAL VIEW METHODS ///\r\n    /**\r\n     * @dev Test for web3js interface to see if contract is correctly initialized.\r\n     */\r\n    function ping() external view returns(string, uint256) {\r\n        return (\"CryptoDivert version 2018.04.05\", now);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev Shows who is the pending admin for this contract\r\n     * @return 'pendingAdmin'\r\n     */\r\n    function showPendingAdmin() external view \r\n    OnlyByAdmin()\r\n    returns(address) \r\n    {\r\n        require(pendingAdmin != NO_ADDRESS);\r\n        return pendingAdmin;\r\n    }\r\n    \r\n    /**\r\n     * @dev Shows who is the admin for this contract\r\n     * @return 'admin'\r\n     */\r\n    function whoIsAdmin() external view \r\n    returns(address) \r\n    {\r\n        return admin;\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if the internal administration is correct. The safeguarded user balances added to the \r\n     * un-retrieved admin commission should be the same as the ETH balance of this contract.\r\n     * \r\n     * @return uint256 The total current safeguarded balance of all users 'userBalance' + 'privacyfund'.\r\n     * @return uint256 The outstanding admin commissions 'commissions'.\r\n     */\r\n    function AuditBalances() external view returns(uint256, uint256) {\r\n        assert(address(this).balance >= userBalance);\r\n        uint256 pendingBalance = userBalance.add(privacyFund);\r\n        uint256 commissions = address(this).balance.sub(pendingBalance);\r\n        \r\n        return(pendingBalance, commissions);\r\n    }\r\n    \r\n    /**\r\n     * @dev Check the remaining balance for a safeguarded transaction\r\n     *\r\n     * @param _originAddressHash The RIPEMD160 Hash (bytes20) of a password and the originating ETH address.\r\n     * @return uint256 The remaining value in Wei for this safeguard.\r\n     */\r\n    function AuditSafeGuard(bytes20 _originAddressHash) external view \r\n    returns(uint256 _safeGuarded, uint256 _timelock, uint16 _privacypercentage)\r\n    {\r\n        // Only by the address that uploaded the safeguard to make it harder for prying eyes to track.\r\n        require(msg.sender == senders[_originAddressHash] || msg.sender == admin);\r\n         \r\n        _safeGuarded = balances[_originAddressHash];\r\n        _timelock = timers[_originAddressHash];\r\n        _privacypercentage = privacyDeviation[_originAddressHash];\r\n        \r\n        return (_safeGuarded, _timelock, _privacypercentage);\r\n    }\r\n    \r\n    \r\n    /// EXTERNAL METHODS ///\r\n    /**\r\n     * @dev Safeguard a value in Wei. You can retreive this after '_releaseTime' via any ETH address \r\n     * by callling the Retreive method with your password and the originating ETH address.\r\n     * \r\n     * To prevent the password from being visible in the blockchain (everything added is visible in the blockchain!)\r\n     * and allow more users to set the same password, you need to create a RIPEMD160 Hash from your password\r\n     * and your originating (or intended receiver) ETH address: e.g. if you choose password: 'secret' and transfer balance \r\n     * from (or to) ETH address (ALL LOWERCASE!) '0x14723a09acff6d2a60dcdf7aa4aff308fddc160c' you should RIPEMD160 Hash:\r\n     * 'secret0x14723a09acff6d2a60dcdf7aa4aff308fddc160c'.\r\n     * http://www.md5calc.com/ RIPEMD160 gives us the 20 bytes Hash: '602bc74a8e09f80c2d5bbc4374b8f400f33f2683'.\r\n     * If you manually transfer value to this contract make sure to enter the hash as a bytes20 '0x602bc74a8e09f80c2d5bbc4374b8f400f33f2683'.\r\n     * Before you transfer any value to SafeGuard, test the example above and make sure you get the same hash, \r\n     * then test a transfer (and Retreive!) with a small amount (minimal 1 finney) before SafeGuarding a larger amount. \r\n     * \r\n     * IF YOU MAKE AN ERROR WITH YOUR HASH, OR FORGET YOUR PASSWORD, YOUR FUNDS WILL BE SAFEGUARDED FOREVER.\r\n     * \r\n     * @param _originAddressHash The RIPEMD160 Hash (bytes20) of a password and the msg.sender or intended receiver ETH address.\r\n     * @param _releaseTime The UNIX time (uint256) until when this balance is locked up.\r\n     * @param _privacyCommission The maximum deviation (up or down) that you are willing to use to make tracking on the amount harder.\r\n     * @return true Usefull if this method is called from a contract.\r\n     */\r\n    function SafeGuard(bytes20 _originAddressHash, uint256 _releaseTime, uint16 _privacyCommission) external payable\r\n    onlyPayloadSize(3*32)\r\n    returns(bool)\r\n    {\r\n        // We can only SafeGuard anything if there is value transferred.\r\n        // Minimal value is 1 finney, to prevent SPAM and any errors with the commissions calculations.\r\n        require(msg.value >= 1 finney); \r\n        \r\n        // Prevent Re-usage of a compromised password by this address; Check that we have not used this before. \r\n        // In case we have used this password, but haven't retrieved the amount, the password is still \r\n        // uncompromised and we can add this amount to the existing amount.\r\n        // A password/ETH combination that was used before will be known to the blockchain (clear text) \r\n        // after the Retrieve method has been called and can't be used again to prevent others retrieving you funds.\r\n        require(senders[_originAddressHash] == NO_ADDRESS || balances[_originAddressHash] > 0);\r\n       \r\n        // We don't know your password (Only you do!) so we can't possible check wether or not \r\n        // you created the correct hash, we have to assume you did. Only store the first sender of this hash\r\n        // to prevent someone uploading a small amount with this hash to gain access to the AuditSafeGuard method \r\n        // or reset the timer.\r\n        if(senders[_originAddressHash] == NO_ADDRESS) {\r\n            \r\n            senders[_originAddressHash] = msg.sender;\r\n            \r\n            // If you set a timer we check if it's in the future and add it to this SafeGuard.\r\n            if (_releaseTime > now) {\r\n                timers[_originAddressHash] = _releaseTime;\r\n            } else {\r\n                timers[_originAddressHash] = now;\r\n            }\r\n            \r\n            // if we have set a privacy deviation store it, max 100% = 10000.\r\n            if (_privacyCommission > 0 && _privacyCommission <= 10000) {\r\n                privacyDeviation[_originAddressHash] = _privacyCommission;\r\n            }\r\n        }    \r\n        \r\n        // To pay for our servers (and maybe a beer or two) we charge a 0.8% fee (that's 80cents per 100$).\r\n        uint256 _commission = msg.value.div(125); //100/125 = 0.8\r\n        uint256 _balanceAfterCommission = msg.value.sub(_commission);\r\n        balances[_originAddressHash] = balances[_originAddressHash].add(_balanceAfterCommission);\r\n        \r\n        // Keep score of total user balance \r\n        userBalance = userBalance.add(_balanceAfterCommission);\r\n        \r\n        // Double check that our administration is correct.\r\n        // The administration can only be incorrect if someone found a loophole in Solidity or in our programming.\r\n        // The assert will effectively revert the transaction in case someone is cheating.\r\n        assert(address(this).balance >= userBalance); \r\n        \r\n        // Let the user know what a great success.\r\n        emit SafeGuardSuccess(_originAddressHash, _balanceAfterCommission, _commission);\r\n        \r\n        return true;\r\n    } \r\n    \r\n    /**\r\n     * @dev Retrieve a safeguarded value to the ETH address that calls this method.\r\n     * \r\n     * The safeguarded value can be retrieved by any ETH address, including the originating ETH address and contracts.\r\n     * All you need is the (clear text) password and the originating ETH address that was used to transfer the \r\n     * value to this contract. This method will recreate the RIPEMD160 Hash that was \r\n     * given to the SafeGuard method (this will only succeed when both password and address are correct).\r\n     * The value can only be retrieved after the release timer for this SafeGuard (if any) has expired.\r\n     * \r\n     * This Retrieve method can be traced in the blockchain via the input field. \r\n     * We can create additional anonimity by hashing the receivers address instead of the originating address\r\n     * in the SafeGuard method. By doing this we render searching for the originating address \r\n     * in the input field useless. To make the tracement harder, we will charge an addition random \r\n     * commission between 0 and 5% so the outgoing value is randomized. This will still not create \r\n     * 100% anonimity because it is possible to hash every password and receiver address combination and compare it\r\n     * to the hash that was originally given when safeguarding the transaction. \r\n     * \r\n     * @param _password The password that was originally hashed for this safeguarded value.\r\n     * @param _originAddress The address where this safeguarded value was received from.\r\n     * @return true Usefull if this method is called from a contract.\r\n     */ \r\n    function Retrieve(string _password, address _originAddress) external \r\n    isAddress(_originAddress) \r\n    onlyPayloadSize(2*32)\r\n    returns(bool)\r\n    {\r\n        \r\n        // Re-create the _originAddressHash that was given when transferring to this contract.\r\n        // Either the sender's address was hashed (and allows to retrieve from any address) or \r\n        // the receiver's address was hashed (more private, but only allows to retrieve from that address).\r\n        bytes20 _addressHash = _getOriginAddressHash(_originAddress, _password); \r\n        bytes20 _senderHash = _getOriginAddressHash(msg.sender, _password); \r\n        bytes20 _transactionHash;\r\n        uint256 _randomPercentage; // used to make a receiver hashed transaction more private.\r\n        uint256 _month = 30 * 24 * 60 * 60;\r\n        \r\n        // Check if the given '_originAddress' is the same as the address that transferred to this contract.\r\n        // We do this to prevent people simply giving any hash.\r\n        if (_originAddress == senders[_addressHash]) { // Public Transaction, hashed with originating address.\r\n            \r\n            // Anybody with the password and the sender's address\r\n            _transactionHash = _addressHash;\r\n            \r\n        } \r\n        else if (msg.sender == senders[_addressHash] && timers[_addressHash].add(_month) < now ) { // Private transaction, retrieve by sender after a month delay. \r\n            \r\n            // Allow a sender to retrieve his transfer, only a month after the timelock expired \r\n            _transactionHash = _addressHash;\r\n            \r\n        }\r\n        else { // Private transaction, hashed with receivers address\r\n            \r\n            // Allow a pre-defined receiver to retrieve.\r\n            _transactionHash = _senderHash;\r\n        }\r\n        \r\n        // Check if the _transactionHash exists and this balance hasn't been received already.\r\n        // We would normally do this with a require(), but to keep it more private we need the \r\n        // method to be executed also if it will not result.\r\n        if (balances[_transactionHash] == 0) {\r\n            emit RetrieveSuccess(0);\r\n            return false;    \r\n        }\r\n        \r\n        // Check if this SafeGuard has a timelock and if it already has expired.\r\n        // In case the transaction was sent to a pre-defined address, the sender can retrieve the transaction 1 month after it expired.\r\n        // We would normally do this with a require(), but to keep it more private we need the \r\n        // method to be executed also if it will not result.\r\n        if (timers[_transactionHash] > now ) {\r\n            emit RetrieveSuccess(0);\r\n            return false;\r\n        }\r\n        \r\n        // Prepare to transfer the balance out.\r\n        uint256 _balance = balances[_transactionHash];\r\n        balances[_transactionHash] = 0;\r\n        \r\n        // Check if the sender allowed for a deviation (up or down) of the value to make tracking harder.\r\n        // To do this we need to randomize the balance a little so it\r\n        // become less traceable: To make the tracement harder, we will calculate an \r\n        // additional random commission between 0 and the allowed deviation which can be added to or substracted from \r\n        // this transfer's balance so the outgoing value is randomized.\r\n        if (privacyDeviation[_transactionHash] > 0) {\r\n             _randomPercentage = _randomize(now, privacyDeviation[_transactionHash]);\r\n        }\r\n        \r\n        if(_randomPercentage > 0) {\r\n            // Calculate the privacy commissions amount in wei.\r\n            uint256 _privacyCommission = _balance.div(10000).mul(_randomPercentage);\r\n            \r\n            // Check integrity of privacyFund\r\n            if (userBalance.add(privacyFund) > address(this).balance) {\r\n                privacyFund = 0;\r\n            }\r\n            \r\n            // Check if we have enough availability in the privacy fund to add to this Retrieve\r\n            if (_privacyCommission <= privacyFund) {\r\n                // we have enough funds to add\r\n                 privacyFund = privacyFund.sub(_privacyCommission);\r\n                 userBalance = userBalance.add(_privacyCommission);\r\n                _balance = _balance.add(_privacyCommission);\r\n               \r\n            } else {\r\n                // the privacy fund is not filled enough, you will contribute to it.\r\n                _balance = _balance.sub(_privacyCommission);\r\n                userBalance = userBalance.sub(_privacyCommission);\r\n                privacyFund = privacyFund.add(_privacyCommission);\r\n            }\r\n        }\r\n        \r\n        // Keep score of total user balance \r\n        userBalance = userBalance.sub(_balance);\r\n        \r\n        // Transfer the value.\r\n        msg.sender.transfer(_balance);\r\n        \r\n        // Double check that our admin is correct. If not then revert this transaction.\r\n        assert(address(this).balance >= userBalance);\r\n        \r\n        emit RetrieveSuccess(_balance);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Retrieve commissions to the Admin address. \r\n     */\r\n    function RetrieveCommissions() external OnlyByAdmin() {\r\n        // The fees are the remainder of the contract balance after the userBalance and privacyFund\r\n        // reservations have been substracted. \r\n        uint256 pendingBalance = userBalance.add(privacyFund);\r\n        uint256 commissions = address(this).balance.sub(pendingBalance);\r\n        \r\n        // Transfer the commissions.\r\n        msg.sender.transfer(commissions);\r\n        \r\n        // Double check that our admin is correct.\r\n        assert(address(this).balance >= userBalance);\r\n    } \r\n    \r\n    /**\r\n     * @dev Approve a new admin for this contract. The new admin will have to \r\n     * confirm that he is the admin. \r\n     * @param _newAdmin the new owner of the contract.\r\n     */\r\n    function setAdmin(address _newAdmin) external \r\n    OnlyByAdmin() \r\n    isAddress(_newAdmin)\r\n    isNotAdmin(_newAdmin)\r\n    onlyPayloadSize(32)\r\n    {\r\n        pendingAdmin = _newAdmin;\r\n        emit ContractAdminTransferPending(pendingAdmin, admin);\r\n    }\r\n    \r\n    /**\r\n     * @dev Let the pending admin confirm his address and become the new admin.\r\n     */ \r\n    function confirmAdmin() external\r\n    {\r\n        require(msg.sender==pendingAdmin);\r\n        address _previousAdmin = admin;\r\n        admin = pendingAdmin;\r\n        pendingAdmin = NO_ADDRESS;\r\n        \r\n        emit NewContractAdmin(admin, _previousAdmin);\r\n    }\r\n    \r\n    \r\n    /// PRIVATE METHODS ///\r\n    /**\r\n     * @dev Create a (semi) random number.\r\n     * This is not truely random, as that isn't possible in the blockchain, but \r\n     * random enough for our purpose.\r\n     * \r\n     * @param _seed Randomizing seed.\r\n     * @param _max Max value.\r\n     */\r\n    function _randomize(uint256 _seed, uint256 _max) private view returns(uint256 _return) {\r\n        _return = uint256(keccak256(_seed, block.blockhash(block.number -1), block.difficulty, block.coinbase));\r\n        return _return % _max;\r\n    }\r\n    \r\n    function _getOriginAddressHash(address _address, string _password) private pure returns(bytes20) {\r\n        string memory _addressString = toAsciiString(_address);\r\n        return ripemd160(_password,\"0x\",_addressString);\r\n    }\r\n    \r\n    function toAsciiString(address x) private pure returns (string) {\r\n    bytes memory s = new bytes(40);\r\n        for (uint i = 0; i < 20; i++) {\r\n            byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));\r\n            byte hi = byte(uint8(b) / 16);\r\n            byte lo = byte(uint8(b) - 16 * uint8(hi));\r\n            s[2*i] = char(hi);\r\n            s[2*i+1] = char(lo);            \r\n        }\r\n        return string(s);\r\n    }\r\n    \r\n    function char(byte b) private pure returns (byte c) {\r\n        if (b < 10) return byte(uint8(b) + 0x30);\r\n        else return byte(uint8(b) + 0x57);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"showPendingAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_password\",\"type\":\"string\"},{\"name\":\"_originAddress\",\"type\":\"address\"}],\"name\":\"Retrieve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ping\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whoIsAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_originAddressHash\",\"type\":\"bytes20\"},{\"name\":\"_releaseTime\",\"type\":\"uint256\"},{\"name\":\"_privacyCommission\",\"type\":\"uint16\"}],\"name\":\"SafeGuard\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_originAddressHash\",\"type\":\"bytes20\"}],\"name\":\"AuditSafeGuard\",\"outputs\":[{\"name\":\"_safeGuarded\",\"type\":\"uint256\"},{\"name\":\"_timelock\",\"type\":\"uint256\"},{\"name\":\"_privacypercentage\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AuditBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"RetrieveCommissions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"currentAdmin\",\"type\":\"address\"}],\"name\":\"ContractAdminTransferPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"NewContractAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes20\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"comissions\",\"type\":\"uint256\"}],\"name\":\"SafeGuardSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RetrieveSuccess\",\"type\":\"event\"}]","ContractName":"CryptoDivert","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b80b1200799060569985490043fe101ff3e981b0acbc0bdd72abbce42b6ceb8a"}]}