{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n/**\r\n * Changes by https://www.docademic.com/\r\n */\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract Destroyable is Ownable{\r\n    /**\r\n     * @notice Allows to destroy the contract and return the tokens to the owner.\r\n     */\r\n    function destroy() public onlyOwner{\r\n        selfdestruct(owner);\r\n    }\r\n}\r\ninterface Token {\r\n    function transfer(address _to, uint256 _value) external;\r\n\r\n    function balanceOf(address who) view external returns (uint256);\r\n}\r\n\r\ncontract MultiVesting is Ownable, Destroyable {\r\n    using SafeMath for uint256;\r\n\r\n    // beneficiary of tokens\r\n    struct Beneficiary {\r\n        string description;\r\n        uint256 vested;\r\n        uint256 released;\r\n        uint256 start;\r\n        uint256 cliff;\r\n        uint256 duration;\r\n        bool revoked;\r\n        bool revocable;\r\n        bool isBeneficiary;\r\n    }\r\n\r\n    event Released(address _beneficiary, uint256 amount);\r\n    event Revoked(address _beneficiary);\r\n    event NewBeneficiary(address _beneficiary);\r\n    event BeneficiaryDestroyed(address _beneficiary);\r\n\r\n\r\n    mapping(address => Beneficiary) public beneficiaries;\r\n    address[] public addresses;\r\n    Token public token;\r\n    uint256 public totalVested;\r\n    uint256 public totalReleased;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier isNotBeneficiary(address _beneficiary) {\r\n        require(!beneficiaries[_beneficiary].isBeneficiary);\r\n        _;\r\n    }\r\n    modifier isBeneficiary(address _beneficiary) {\r\n        require(beneficiaries[_beneficiary].isBeneficiary);\r\n        _;\r\n    }\r\n\r\n    modifier wasRevoked(address _beneficiary) {\r\n        require(beneficiaries[_beneficiary].revoked);\r\n        _;\r\n    }\r\n\r\n    modifier wasNotRevoked(address _beneficiary) {\r\n        require(!beneficiaries[_beneficiary].revoked);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n     * beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n     * of the balance will have vested.\r\n     * @param _token address of the token of vested tokens\r\n     */\r\n    function MultiVesting (address _token) public {\r\n        require(_token != address(0));\r\n        token = Token(_token);\r\n    }\r\n\r\n    function() payable public {\r\n        release(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers vested tokens to beneficiary (alternative to fallback function).\r\n     */\r\n    function release() public {\r\n        release(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers vested tokens to beneficiary.\r\n     * @param _beneficiary Beneficiary address\r\n     */\r\n    function release(address _beneficiary) private\r\n    isBeneficiary(_beneficiary)\r\n    {\r\n        Beneficiary storage beneficiary = beneficiaries[_beneficiary];\r\n\r\n        uint256 unreleased = releasableAmount(_beneficiary);\r\n\r\n        require(unreleased > 0);\r\n\r\n        beneficiary.released = beneficiary.released.add(unreleased);\r\n\r\n        totalReleased = totalReleased.add(unreleased);\r\n\r\n        token.transfer(_beneficiary, unreleased);\r\n\r\n        if ((beneficiary.vested - beneficiary.released) == 0) {\r\n            beneficiary.isBeneficiary = false;\r\n        }\r\n\r\n        emit Released(_beneficiary, unreleased);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to transfers vested tokens to beneficiary.\r\n     * @param _beneficiary Beneficiary address\r\n     */\r\n    function releaseTo(address _beneficiary) public onlyOwner {\r\n        release(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @dev Add new beneficiary to start vesting\r\n     * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n     * @param _start time in seconds which the tokens will vest\r\n     * @param _cliff time in seconds of the cliff in which tokens will begin to vest\r\n     * @param _duration duration in seconds of the period in which the tokens will vest\r\n     * @param _revocable whether the vesting is revocable or not\r\n     */\r\n    function addBeneficiary(address _beneficiary, uint256 _vested, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable, string _description)\r\n    onlyOwner\r\n    isNotBeneficiary(_beneficiary)\r\n    public {\r\n        require(_beneficiary != address(0));\r\n        require(_cliff >= _start);\r\n        require(token.balanceOf(this) >= totalVested.sub(totalReleased).add(_vested));\r\n        beneficiaries[_beneficiary] = Beneficiary({\r\n            released : 0,\r\n            vested : _vested,\r\n            start : _start,\r\n            cliff : _cliff,\r\n            duration : _duration,\r\n            revoked : false,\r\n            revocable : _revocable,\r\n            isBeneficiary : true,\r\n            description : _description\r\n            });\r\n        totalVested = totalVested.add(_vested);\r\n        addresses.push(_beneficiary);\r\n        emit NewBeneficiary(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n     * remain in the contract, the rest are returned to the owner.\r\n     * @param _beneficiary Beneficiary address\r\n     */\r\n    function revoke(address _beneficiary) public onlyOwner {\r\n        Beneficiary storage beneficiary = beneficiaries[_beneficiary];\r\n        require(beneficiary.revocable);\r\n        require(!beneficiary.revoked);\r\n\r\n        uint256 balance = beneficiary.vested.sub(beneficiary.released);\r\n\r\n        uint256 unreleased = releasableAmount(_beneficiary);\r\n        uint256 refund = balance.sub(unreleased);\r\n\r\n        token.transfer(owner, refund);\r\n\r\n        totalReleased = totalReleased.add(refund);\r\n\r\n        beneficiary.revoked = true;\r\n        beneficiary.released = beneficiary.released.add(refund);\r\n\r\n        emit Revoked(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to destroy a beneficiary. Remain tokens are returned to the owner.\r\n     * @param _beneficiary Beneficiary address\r\n     */\r\n    function destroyBeneficiary(address _beneficiary) public onlyOwner {\r\n        Beneficiary storage beneficiary = beneficiaries[_beneficiary];\r\n\r\n        uint256 balance = beneficiary.vested.sub(beneficiary.released);\r\n\r\n        token.transfer(owner, balance);\r\n\r\n        totalReleased = totalReleased.add(balance);\r\n\r\n        beneficiary.isBeneficiary = false;\r\n        beneficiary.released = beneficiary.released.add(balance);\r\n\r\n        for (uint i = 0; i < addresses.length - 1; i++)\r\n            if (addresses[i] == _beneficiary) {\r\n                addresses[i] = addresses[addresses.length - 1];\r\n                break;\r\n            }\r\n\r\n        addresses.length -= 1;\r\n\r\n        emit BeneficiaryDestroyed(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to clear the contract. Remain tokens are returned to the owner.\r\n     */\r\n    function clearAll() public onlyOwner {\r\n\r\n        token.transfer(owner, token.balanceOf(this));\r\n\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            Beneficiary storage beneficiary = beneficiaries[addresses[i]];\r\n            beneficiary.isBeneficiary = false;\r\n            beneficiary.released = 0;\r\n            beneficiary.vested = 0;\r\n            beneficiary.start = 0;\r\n            beneficiary.cliff = 0;\r\n            beneficiary.duration = 0;\r\n            beneficiary.revoked = false;\r\n            beneficiary.revocable = false;\r\n            beneficiary.description = \"\";\r\n        }\r\n        addresses.length = 0;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n     * @param _beneficiary Beneficiary address\r\n     */\r\n    function releasableAmount(address _beneficiary) public view returns (uint256) {\r\n        return vestedAmount(_beneficiary).sub(beneficiaries[_beneficiary].released);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already vested.\r\n     * @param _beneficiary Beneficiary address\r\n     */\r\n    function vestedAmount(address _beneficiary) public view returns (uint256) {\r\n        Beneficiary storage beneficiary = beneficiaries[_beneficiary];\r\n        uint256 totalBalance = beneficiary.vested;\r\n\r\n        if (now < beneficiary.cliff) {\r\n            return 0;\r\n        } else if (now >= beneficiary.start.add(beneficiary.duration) || beneficiary.revoked) {\r\n            return totalBalance;\r\n        } else {\r\n            return totalBalance.mul(now.sub(beneficiary.start)).div(beneficiary.duration);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the remain MTC on the contract.\r\n     */\r\n    function Balance() view public returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the numbers of beneficiaries in the vesting contract.\r\n     */\r\n    function beneficiariesLength() view public returns (uint256) {\r\n        return addresses.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to flush the eth.\r\n     */\r\n    function flushEth() public onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to destroy the contract and return the tokens to the owner.\r\n     */\r\n    function destroy() public onlyOwner {\r\n        token.transfer(owner, token.balanceOf(this));\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"vested\",\"type\":\"uint256\"},{\"name\":\"released\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"cliff\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"revoked\",\"type\":\"bool\"},{\"name\":\"revocable\",\"type\":\"bool\"},{\"name\":\"isBeneficiary\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"releasableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalVested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"flushEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"vestedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"destroyBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiariesLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"releaseTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReleased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clearAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_vested\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_revocable\",\"type\":\"bool\"},{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"addBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"Revoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"NewBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryDestroyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MultiVesting","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000905e337c6c8645263d3521205aa37bf4d034e745","Library":"","SwarmSource":"bzzr://41619356153f7807e8f9c15fc1e55b7d8c10fc3a18337e6021dd4e71bd008429"}]}