{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract zombieToken {\r\n  function mint(address to, uint256 value) public returns (bool success);\r\n}\r\n\r\ncontract zombieMain {\r\n  function checkAllOwner(uint256[] _tokenId, address owner) public view returns (bool);\r\n  function seeZombieRole(uint256 _tokenId) public view returns (uint16 roletype);\r\n  function seeZombieColor(uint256 _tokenId) public view returns (uint8 color);\r\n  function seeZombieStar(uint256 _tokenId) public view returns (uint8 star);\r\n  function seeZombieDna(uint256 _tokenId) public view returns (bytes32 dna);\r\n}\r\n\r\ncontract zombieInvasion is Ownable{\r\n    using SafeMath for uint256;\r\n    \r\n    zombieToken zombietoken = zombieToken(0x2Bb48FE71ba5f73Ab1c2B9775cfe638400110d34);\r\n    zombieMain zombiemain = zombieMain(0x58fd762F76D57C6fC2a480F6d26c1D03175AD64F);\r\n\r\n    struct Zombie {\r\n      uint32 readyTime;//剩餘可出戰時間\r\n      bool notAtHome;  //是否離家\r\n      uint16 undeadsTime;//不死次數\r\n    }\r\n\r\n    struct Area {\r\n      uint starLimit; \r\n      uint8 TeamMemberlimitCount; // 5\r\n      uint8[] roletype;     //  4,4,99,99,99\r\n      uint TotallimitTeamCount;\r\n      uint TotalTeamCount;\r\n      string name;\r\n      uint ZOBRevenue;\r\n      bool isOpen;\r\n      uint32 duration;\r\n    }\r\n\r\n    struct Team {\r\n      bool isCharge;\r\n      uint areaID;\r\n      uint[] Zombies;\r\n      uint32 awardTime;\r\n      address Owner;\r\n      bytes32 teamHash;\r\n      uint blocknumber;\r\n    }\r\n    \r\n    Area[] public areas;\r\n\r\n    mapping (uint=>Zombie) public zombies;\r\n    mapping (bytes32=>Team) public teams;\r\n\r\n    event StartInvasion(bytes32 indexed teamhash, uint _areaId,uint[] _zombieId,address player);\r\n    event AwardInvation(bytes32 indexed teamhash, bool InvationResult, uint ZOBRevenue, address player);\r\n\r\n    modifier onlyOwnerOf(uint[] _zombieId) {\r\n      require(zombiemain.checkAllOwner(_zombieId, msg.sender));\r\n      _;\r\n    }\r\n\r\n\r\n  function startInvasion(uint _areaId, uint[] _zombieId) public onlyOwnerOf(_zombieId){\r\n    require(areas[_areaId].TotallimitTeamCount >= areas[_areaId].TotalTeamCount + 1);\r\n    require(areas[_areaId].isOpen);\r\n    require(areas[_areaId].TeamMemberlimitCount >= _zombieId.length);\r\n\r\n    bytes32 teamHash = block.blockhash(block.number-1);\r\n\r\n    for(uint16 i = 0; i<_zombieId.length; i++){\r\n      //確保殭屍都在家，並且可以出戰\r\n      require(now > zombies[_zombieId[i]].readyTime);\r\n      require(!zombies[_zombieId[i]].notAtHome);\r\n\r\n      teamHash = keccak256(teamHash,now,_areaId,zombiemain.seeZombieDna(_zombieId[i]));\r\n\r\n      zombies[_zombieId[i]].notAtHome = true;\r\n      zombies[_zombieId[i]].readyTime = uint32(now + areas[_areaId].duration);\r\n    }\r\n\r\n    //職業都必須符合條件\r\n    for(uint16 a = 0; a<areas[_areaId].roletype.length; a++){\r\n      if(areas[_areaId].roletype[a] == 99) continue;\r\n      if(zombiemain.seeZombieRole(_zombieId[a]) != areas[_areaId].roletype[a]) revert();\r\n    }    \r\n\r\n    areas[_areaId].TotalTeamCount ++;\r\n\r\n    require(teams[teamHash].areaID == 0);\r\n    teams[teamHash] = Team(false,_areaId,_zombieId,uint32(now+areas[_areaId].duration),msg.sender,teamHash,block.number + 1);\r\n    \r\n    StartInvasion(teamHash, _areaId, _zombieId, msg.sender);\r\n  }\r\n\r\n  function awardInvation(bytes32 _teamId) public {\r\n    require(teams[_teamId].Owner == msg.sender);\r\n    require(now >= teams[_teamId].awardTime);\r\n    require(!teams[_teamId].isCharge);\r\n    uint totalUndeadsTime;\r\n    uint totalStar;\r\n    uint dieNumber;\r\n\r\n    uint[] memory zb =  teams[_teamId].Zombies;\r\n\r\n    for(i=0;i<zb.length;i++){\r\n        totalUndeadsTime += zombies[zb[i]].undeadsTime;\r\n        totalStar += zombiemain.seeZombieStar(zb[i]);\r\n    }\r\n\r\n    if(totalStar<areas[teams[_teamId].areaID].starLimit){\r\n        dieNumber = totalStar*9500/(areas[teams[_teamId].areaID].starLimit)+totalUndeadsTime*10;\r\n    }else{\r\n        dieNumber = totalStar*100/(areas[teams[_teamId].areaID].starLimit)+9400+totalUndeadsTime;\r\n    }\r\n\r\n    if(dieNumber <= uint(keccak256(teams[_teamId].teamHash, now, block.blockhash(block.number-1),block.blockhash(teams[_teamId].blocknumber))) % 10000) {\r\n      //Lose\r\n      for(uint16 i = 0; i<zb.length; i++){\r\n        zombies[zb[ii]].readyTime = uint32(now + 7 days);\r\n        zombies[zb[ii]].undeadsTime = 0;\r\n        zombies[zb[ii]].notAtHome = false;\r\n      }\r\n      AwardInvation(_teamId, false, 0, msg.sender);\r\n    } else {\r\n      //Win\r\n      for(uint16 ii = 0; ii<zb.length; ii++){\r\n        zombies[zb[ii]].undeadsTime ++;\r\n        zombies[zb[ii]].notAtHome = false;\r\n      }\r\n      zombietoken.mint(teams[_teamId].Owner, areas[teams[_teamId].areaID].ZOBRevenue);\r\n      AwardInvation(_teamId, true, areas[teams[_teamId].areaID].ZOBRevenue, msg.sender);\r\n    }\r\n\r\n    teams[_teamId].isCharge = true;\r\n    areas[teams[_teamId].areaID].TotalTeamCount --;\r\n  }\r\n\r\n  function addArea(uint starLimit,uint8 TeamMemberlimitCount,uint8[] roletype,uint _totallimitTeamCount,string name,uint ZOBRevenue,bool isOpen,uint32 duration) public onlyOwner{\r\n      areas.push(Area(starLimit, TeamMemberlimitCount, roletype, _totallimitTeamCount, 0, name, ZOBRevenue, isOpen, duration));\r\n  }\r\n  \r\n  function closeArea(uint areaId) public onlyOwner{\r\n      areas[areaId].isOpen = false;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"zombies\",\"outputs\":[{\"name\":\"readyTime\",\"type\":\"uint32\"},{\"name\":\"notAtHome\",\"type\":\"bool\"},{\"name\":\"undeadsTime\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"areaId\",\"type\":\"uint256\"}],\"name\":\"closeArea\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"bytes32\"}],\"name\":\"awardInvation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"teams\",\"outputs\":[{\"name\":\"isCharge\",\"type\":\"bool\"},{\"name\":\"areaID\",\"type\":\"uint256\"},{\"name\":\"awardTime\",\"type\":\"uint32\"},{\"name\":\"Owner\",\"type\":\"address\"},{\"name\":\"teamHash\",\"type\":\"bytes32\"},{\"name\":\"blocknumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"starLimit\",\"type\":\"uint256\"},{\"name\":\"TeamMemberlimitCount\",\"type\":\"uint8\"},{\"name\":\"roletype\",\"type\":\"uint8[]\"},{\"name\":\"_totallimitTeamCount\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"ZOBRevenue\",\"type\":\"uint256\"},{\"name\":\"isOpen\",\"type\":\"bool\"},{\"name\":\"duration\",\"type\":\"uint32\"}],\"name\":\"addArea\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"areas\",\"outputs\":[{\"name\":\"starLimit\",\"type\":\"uint256\"},{\"name\":\"TeamMemberlimitCount\",\"type\":\"uint8\"},{\"name\":\"TotallimitTeamCount\",\"type\":\"uint256\"},{\"name\":\"TotalTeamCount\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"ZOBRevenue\",\"type\":\"uint256\"},{\"name\":\"isOpen\",\"type\":\"bool\"},{\"name\":\"duration\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_areaId\",\"type\":\"uint256\"},{\"name\":\"_zombieId\",\"type\":\"uint256[]\"}],\"name\":\"startInvasion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"teamhash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_areaId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_zombieId\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"StartInvasion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"teamhash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"InvationResult\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"ZOBRevenue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"AwardInvation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"zombieInvasion","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://43ffd64f8297e8682591829c828b89f5eaada48274e0b770f89f7070cf68b346"}]}