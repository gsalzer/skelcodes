{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n/**\r\n * This contract specially developed for http://diceforslice.co\r\n * \r\n * What is it?\r\n * This is a game that allows you to win an amount of ETH to your personal ethereum address.\r\n * The possible winning depends on your stake and on amount of ETH in the bank.\r\n *\r\n * Wanna profit?\r\n * Be a sponsor or referral - read more on http://diceforslice.co\r\n *\r\n * Win chances:\r\n * 1 dice = 1/6\r\n * 2 dice = 1/18\r\n * 3 dice = 1/36\r\n * 4 dice = 1/54\r\n * 5 dice = 1/64\r\n */\r\n\r\n/**\r\n * @title Math\r\n * @dev Math operations with safety checks that throw on error. Added: random and \"float\" divide for numbers\r\n */\r\nlibrary Math {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function divf(int256 numerator, int256 denominator, uint256 precision) internal pure returns(int256) {\r\n        int256 _numerator = numerator * int256(10 ** (precision + 1));\r\n        int256 _quotient  = ((_numerator / denominator) + 5) / 10;\r\n        return _quotient;\r\n    }\r\n\r\n    function percent(uint256 value, uint256 per) internal pure returns(uint256) {\r\n        return uint256((divf(int256(value), 100, 4) * int256(per)) / 10000);\r\n    }\r\n\r\n    function random(uint256 nonce, int256 min, int256 max) internal view returns(int256) {\r\n        return int256(uint256(keccak256(nonce + block.number + block.timestamp + uint256(block.coinbase))) % uint256((max - min))) + min;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev Check contract ownable for some admin operations\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    \r\n    modifier onlyOwner()  { require(msg.sender == owner); _; }\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function updateContractOwner(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev General contract\r\n */\r\ncontract DiceForSlice is Ownable {\r\n    // Contract events\r\n    event UserBet       (address user, uint8 number1, uint8 number2, uint8 number3, uint8 number4, uint8 number5);\r\n    event DiceRoll      (uint8 number1, uint8 number2, uint8 number3, uint8 number4, uint8 number5);\r\n    event Loser         (address loser);\r\n    event WeHaveAWinner (address winner, uint256 amount);\r\n    event OMGItIsJackPot(address winner);\r\n\r\n    // Address storage for referral system\r\n    mapping(address => uint256) private bets;\r\n\r\n    // Sponsor data\r\n    address private sponsor;\r\n    uint256 private sponsorDiff  = 100000000000000000;\r\n    uint256 public sponsorValue  = 0;\r\n\r\n    // Nonce for more random\r\n    uint256 private nonce        = 1;\r\n\r\n    // Current balances of contract\r\n    // -bank  - available reward value\r\n    // -stock - available value for restore bank in emergency\r\n    uint256 public bank          = 0;\r\n    uint256 public stock         = 0;\r\n\r\n    // Bet price\r\n    uint256 private betPrice     = 500000000000000000;\r\n\r\n    // Current bet split rules (in percent)\r\n    uint8   private partBank     = 55;\r\n    uint8   private partOwner    = 20;\r\n    uint8   private partSponsor  = 12;\r\n    uint8   private partStock    = 10;\r\n    uint8   private partReferral = 3;\r\n\r\n    // Current rewards (in percent from bank)\r\n    uint8   private rewardOne    = 10;\r\n    uint8   private rewardTwo    = 20;\r\n    uint8   private rewardThree  = 30;\r\n    uint8   private rewardFour   = 50;\r\n    uint8   private jackPot      = 100;\r\n\r\n    // Current number min max\r\n    uint8   private minNumber    = 1;\r\n    uint8   private maxNumber    = 6;\r\n\r\n    /**\r\n     * @dev Check is valid msg value\r\n     */\r\n    modifier isValidBet(uint8 reward) {\r\n        require(msg.value == Math.percent(betPrice, reward));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check bank not empty (empty is < betPrice eth)\r\n     */\r\n    modifier bankNotEmpty() {\r\n        require(bank >= Math.percent(betPrice, rewardTwo));\r\n        require(address(this).balance >= bank);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Special method for fill contract bank \r\n     */\r\n    function fillTheBank() external payable {\r\n        require(msg.value >= sponsorDiff);\r\n        if (msg.value >= sponsorValue + sponsorDiff) {\r\n            sponsorValue = msg.value;\r\n            sponsor      = msg.sender;\r\n        }\r\n        bank = Math.add(bank, msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Restore value from stock\r\n     */\r\n    function appendStock(uint256 amount) external onlyOwner {\r\n        require(amount > 0);\r\n        require(stock >= amount);\r\n        bank  = Math.add(bank,  amount);\r\n        stock = Math.sub(stock, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Get full contract balance\r\n     */\r\n    function getBalance() public view returns(uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Get random number\r\n     */\r\n    function getRN() internal returns(uint8) {\r\n        // 7 is max because method sub min from max (7-1 = 6). Look in Math::random implementation\r\n        nonce++;\r\n        return uint8(Math.random(nonce, minNumber, maxNumber + minNumber));\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Check is valid number\r\n     */\r\n    function isValidNumber(uint8 number) internal view returns(bool) {\r\n        return number >= minNumber && number <= maxNumber;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Split user bet in some pieces:\r\n     * - 55% go to bank\r\n     * - 20% go to contract developer :)\r\n     * - 12% go to sponsor\r\n     * - 10% go to stock for future restores\r\n     * - 3%  go to referral (if exists, if not - go into stock)\r\n     */\r\n    function splitTheBet(address referral) internal {\r\n        uint256 _partBank     = Math.percent(msg.value, partBank);\r\n        uint256 _partOwner    = Math.percent(msg.value, partOwner);\r\n        uint256 _partStock    = Math.percent(msg.value, partStock);\r\n        uint256 _partSponsor  = Math.percent(msg.value, partSponsor);\r\n        uint256 _partReferral = Math.percent(msg.value, partReferral);\r\n        \r\n        bank  = Math.add(bank,  _partBank);\r\n        stock = Math.add(stock, _partStock);\r\n        owner.transfer(_partOwner);\r\n        sponsor.transfer(_partSponsor);\r\n\r\n        if (referral != address(0) && referral != msg.sender && bets[referral] > 0) {\r\n            referral.transfer(_partReferral);\r\n        } else {\r\n            stock = Math.add(stock, _partReferral);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Check the winner\r\n     */\r\n    function isWinner(uint8 required, uint8[5] numbers, uint8[5] randoms) internal pure returns(bool) {\r\n        uint8 count = 0;\r\n        for (uint8 i = 0; i < numbers.length; i++) {\r\n            if (numbers[i] == 0) continue;\r\n            for (uint8 j = 0; j < randoms.length; j++) {\r\n                if (randoms[j] == 0) continue;\r\n                if (randoms[j] == numbers[i]) {\r\n                    count++;\r\n                    delete randoms[j];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return count == required;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Reward the winner\r\n     */\r\n    function rewardTheWinner(uint8 reward) internal {\r\n        uint256 rewardValue = Math.percent(bank, reward);\r\n        require(rewardValue <= getBalance());\r\n        require(rewardValue <= bank);\r\n        bank = Math.sub(bank, rewardValue);\r\n        msg.sender.transfer(rewardValue);\r\n        emit WeHaveAWinner(msg.sender, rewardValue);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Roll the dice for numbers\r\n     */\r\n    function rollOne(address referral, uint8 number)\r\n    external payable isValidBet(rewardOne) bankNotEmpty {\r\n        require(isValidNumber(number));       \r\n        bets[msg.sender]++;\r\n\r\n        splitTheBet(referral);\r\n\r\n        uint8[5] memory numbers = [number,  0, 0, 0, 0];\r\n        uint8[5] memory randoms = [getRN(), 0, 0, 0, 0];\r\n\r\n        emit UserBet(msg.sender, number, 0, 0, 0, 0);\r\n        emit DiceRoll(randoms[0], 0, 0, 0, 0);\r\n        if (isWinner(1, numbers, randoms)) {\r\n            rewardTheWinner(rewardOne);\r\n        } else {\r\n            emit Loser(msg.sender);\r\n        }\r\n    }\r\n\r\n\r\n    function rollTwo(address referral, uint8 number1, uint8 number2)\r\n    external payable isValidBet(rewardTwo) bankNotEmpty {\r\n        require(isValidNumber(number1) && isValidNumber(number2));\r\n        bets[msg.sender]++;\r\n\r\n        splitTheBet(referral);\r\n\r\n        uint8[5] memory numbers = [number1, number2, 0, 0, 0];\r\n        uint8[5] memory randoms = [getRN(), getRN(), 0, 0, 0];\r\n\r\n        emit UserBet(msg.sender, number1, number2, 0, 0, 0);\r\n        emit DiceRoll(randoms[0], randoms[1], 0, 0, 0);\r\n        if (isWinner(2, numbers, randoms)) {\r\n            rewardTheWinner(rewardTwo);\r\n        } else {\r\n            emit Loser(msg.sender);\r\n        }\r\n    }\r\n\r\n\r\n    function rollThree(address referral, uint8 number1, uint8 number2, uint8 number3)\r\n    external payable isValidBet(rewardThree) bankNotEmpty {\r\n        require(isValidNumber(number1) && isValidNumber(number2) && isValidNumber(number3));\r\n        bets[msg.sender]++;\r\n\r\n        splitTheBet(referral);\r\n\r\n        uint8[5] memory numbers = [number1, number2, number3, 0, 0];\r\n        uint8[5] memory randoms = [getRN(), getRN(), getRN(), 0, 0];\r\n\r\n        emit UserBet(msg.sender, number1, number2, number3, 0, 0);\r\n        emit DiceRoll(randoms[0], randoms[1], randoms[2], 0, 0);\r\n        if (isWinner(3, numbers, randoms)) {\r\n            rewardTheWinner(rewardThree);\r\n        } else {\r\n            emit Loser(msg.sender);\r\n        }\r\n    }\r\n\r\n\r\n    function rollFour(address referral, uint8 number1, uint8 number2, uint8 number3, uint8 number4)\r\n    external payable isValidBet(rewardFour) bankNotEmpty {\r\n        require(isValidNumber(number1) && isValidNumber(number2) && isValidNumber(number3) && isValidNumber(number4));\r\n        bets[msg.sender]++;\r\n\r\n        splitTheBet(referral);\r\n\r\n        uint8[5] memory numbers = [number1, number2, number3, number4, 0];\r\n        uint8[5] memory randoms = [getRN(), getRN(), getRN(), getRN(), 0];\r\n\r\n        emit UserBet(msg.sender, number1, number2, number3, number4, 0);\r\n        emit DiceRoll(randoms[0], randoms[1], randoms[2], randoms[3], 0);\r\n        if (isWinner(4, numbers, randoms)) {\r\n            rewardTheWinner(rewardFour);\r\n        } else {\r\n            emit Loser(msg.sender);\r\n        }\r\n    }\r\n\r\n\r\n    function rollFive(address referral, uint8 number1, uint8 number2, uint8 number3, uint8 number4, uint8 number5)\r\n    external payable isValidBet(jackPot) bankNotEmpty {\r\n        require(isValidNumber(number1) && isValidNumber(number2) && isValidNumber(number3) && isValidNumber(number4) && isValidNumber(number5));\r\n        bets[msg.sender]++;\r\n\r\n        splitTheBet(referral);\r\n\r\n        uint8[5] memory numbers = [number1, number2, number3, number4, number5];\r\n        uint8[5] memory randoms = [getRN(), getRN(), getRN(), getRN(), getRN()];\r\n\r\n        emit UserBet(msg.sender, number1, number2, number3, number4, number5);\r\n        emit DiceRoll(randoms[0], randoms[1], randoms[2], randoms[3], randoms[4]);\r\n        if (isWinner(5, numbers, randoms)) {\r\n            rewardTheWinner(jackPot);\r\n            emit OMGItIsJackPot(msg.sender);\r\n        } else {\r\n            emit Loser(msg.sender);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"},{\"name\":\"number1\",\"type\":\"uint8\"},{\"name\":\"number2\",\"type\":\"uint8\"}],\"name\":\"rollTwo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"},{\"name\":\"number\",\"type\":\"uint8\"}],\"name\":\"rollOne\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"},{\"name\":\"number1\",\"type\":\"uint8\"},{\"name\":\"number2\",\"type\":\"uint8\"},{\"name\":\"number3\",\"type\":\"uint8\"}],\"name\":\"rollThree\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"},{\"name\":\"number1\",\"type\":\"uint8\"},{\"name\":\"number2\",\"type\":\"uint8\"},{\"name\":\"number3\",\"type\":\"uint8\"},{\"name\":\"number4\",\"type\":\"uint8\"}],\"name\":\"rollFour\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fillTheBank\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sponsorValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"appendStock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"},{\"name\":\"number1\",\"type\":\"uint8\"},{\"name\":\"number2\",\"type\":\"uint8\"},{\"name\":\"number3\",\"type\":\"uint8\"},{\"name\":\"number4\",\"type\":\"uint8\"},{\"name\":\"number5\",\"type\":\"uint8\"}],\"name\":\"rollFive\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"updateContractOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"number1\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"number2\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"number3\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"number4\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"number5\",\"type\":\"uint8\"}],\"name\":\"UserBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"number1\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"number2\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"number3\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"number4\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"number5\",\"type\":\"uint8\"}],\"name\":\"DiceRoll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"Loser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WeHaveAWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"OMGItIsJackPot\",\"type\":\"event\"}]","ContractName":"DiceForSlice","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ad18b47a57cbf7d4a583701ebc37cedcfe9578d89f3d8bae9692a875f14b4e11"}]}