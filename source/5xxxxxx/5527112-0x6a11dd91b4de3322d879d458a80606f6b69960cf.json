{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n// GOO\r\n// ~~ https://ethergoo.io ~~\r\n\r\n// Allows players to purchase tickets for rare ERC721 items using Goo! (ERC20)\r\n// Get in touch if you are a game with ERC721 items and wish to sponsor us (in return for raffle-placement on our main game page)\r\n\r\ncontract SponsoredItemGooRaffle {\r\n    \r\n    Goo goo = Goo(0x57b116da40f21f91aec57329ecb763d29c1b2355);\r\n    \r\n    ERC721 erc;\r\n    uint256 tokenId;\r\n    address owner;\r\n    \r\n    // Raffle tickets\r\n    mapping(address => TicketPurchases) private ticketsBoughtByPlayer;\r\n    mapping(uint256 => address[]) private rafflePlayers;\r\n\r\n    // Current Raffle info\r\n    uint256 private constant RAFFLE_TICKET_BASE_GOO_PRICE = 1000;\r\n    uint256 private raffleEndTime;\r\n    uint256 private raffleTicketsBought;\r\n    uint256 private raffleId;\r\n    address private raffleWinner;\r\n    bool private raffleWinningTicketSelected;\r\n    uint256 private raffleTicketThatWon;\r\n    \r\n    \r\n    // Raffle structures\r\n    struct TicketPurchases {\r\n        TicketPurchase[] ticketsBought;\r\n        uint256 numPurchases; // Allows us to reset without clearing TicketPurchase[] (avoids potential for gas limit)\r\n        uint256 raffleId;\r\n    }\r\n    \r\n    // Allows us to query winner without looping (avoiding potential for gas limit)\r\n    struct TicketPurchase {\r\n        uint256 startId;\r\n        uint256 endId;\r\n    }\r\n    \r\n    function SponsoredItemGooRaffle() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function startTokenRaffle(uint256 endTime, address tokenContract, uint256 id) external {\r\n        require(msg.sender == owner);\r\n        require(block.timestamp < endTime);\r\n        \r\n        // Grab ownership of token\r\n        erc = ERC721(tokenContract);\r\n        tokenId = id;\r\n        erc.transferFrom(msg.sender, this, id);\r\n        \r\n        if (raffleId != 0) { // Sanity to assure raffle has ended before next one starts\r\n            require(raffleWinner != 0);\r\n        }\r\n        \r\n        // Reset previous raffle info\r\n        raffleWinningTicketSelected = false;\r\n        raffleTicketThatWon = 0;\r\n        raffleWinner = 0;\r\n        raffleTicketsBought = 0;\r\n        \r\n        // Set current raffle info\r\n        raffleEndTime = endTime;\r\n        raffleId++;\r\n    }\r\n    \r\n\r\n    function buyRaffleTicket(uint256 amount) external {\r\n        require(raffleEndTime >= block.timestamp);\r\n        require(amount > 0);\r\n        \r\n        uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount);\r\n        goo.transferFrom(msg.sender, this, ticketsCost);\r\n        // Burn 95% of the Goo (save 5% for contests / marketing fund)\r\n        goo.transfer(address(0), (ticketsCost * 95) / 100);\r\n        \r\n        // Handle new tickets\r\n        TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\r\n        \r\n        // If we need to reset tickets from a previous raffle\r\n        if (purchases.raffleId != raffleId) {\r\n            purchases.numPurchases = 0;\r\n            purchases.raffleId = raffleId;\r\n            rafflePlayers[raffleId].push(msg.sender); // Add user to raffle\r\n        }\r\n        \r\n        // Store new ticket purchase\r\n        if (purchases.numPurchases == purchases.ticketsBought.length) {\r\n            purchases.ticketsBought.length += 1;\r\n        }\r\n        purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1)); // (eg: buy 10, get id's 0-9)\r\n        \r\n        // Finally update ticket total\r\n        raffleTicketsBought += amount;\r\n    }\r\n    \r\n    function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\r\n        require(raffleEndTime < block.timestamp);\r\n        require(raffleWinner == 0);\r\n        require(erc.ownerOf(tokenId) == address(this));\r\n        \r\n        if (!raffleWinningTicketSelected) {\r\n            drawRandomWinner(); // Ideally do it in one call (gas limit cautious)\r\n        }\r\n        \r\n        // Reduce gas by (optionally) offering an address to _check_ for winner\r\n        if (checkWinner != 0) {\r\n            TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\r\n            if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleId == raffleId) {\r\n                TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\r\n                if (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\r\n                    assignRafflePrize(checkWinner); // WINNER!\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Otherwise just naively try to find the winner (will work until mass amounts of players)\r\n        for (uint256 i = 0; i < rafflePlayers[raffleId].length; i++) {\r\n            address player = rafflePlayers[raffleId][i];\r\n            TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\r\n            \r\n            uint256 endIndex = playersTickets.numPurchases - 1;\r\n            // Minor optimization to avoid checking every single player\r\n            if (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\r\n                for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\r\n                    TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\r\n                    if (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\r\n                        assignRafflePrize(player); // WINNER!\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function assignRafflePrize(address winner) internal {\r\n        raffleWinner = winner;\r\n        erc.transfer(winner, tokenId);\r\n    }\r\n    \r\n    // Random enough for small contests (Owner only to prevent trial & error execution)\r\n    function drawRandomWinner() public {\r\n        require(msg.sender == owner);\r\n        require(raffleEndTime < block.timestamp);\r\n        require(!raffleWinningTicketSelected);\r\n        \r\n        uint256 seed = raffleTicketsBought + block.timestamp;\r\n        raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1));\r\n        raffleWinningTicketSelected = true;\r\n    }\r\n    \r\n    // 5% of Goo gained will be reinvested into the game (contests / marketing / acquiring more raffle assets)\r\n    function transferGoo(address recipient, uint256 amount) external {\r\n        require(msg.sender == owner);\r\n        goo.transfer(recipient, amount);\r\n    }\r\n    \r\n     // To display on website\r\n    function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\r\n        return (raffleEndTime, raffleId, raffleTicketsBought, raffleWinner, raffleTicketThatWon);\r\n    }\r\n    \r\n    // To allow clients to verify contestants\r\n    function getRafflePlayers(uint256 raffle) external constant returns (address[]) {\r\n        return (rafflePlayers[raffle]);\r\n    }\r\n    \r\n     // To allow clients to verify contestants\r\n    function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) {\r\n        TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\r\n        \r\n        if (playersTickets.raffleId == raffleId) {\r\n            uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\r\n            uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\r\n            \r\n            for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\r\n                startIds[i] = playersTickets.ticketsBought[i].startId;\r\n                endIds[i] = playersTickets.ticketsBought[i].endId;\r\n            }\r\n        }\r\n        \r\n        return (startIds, endIds);\r\n    }\r\n}\r\n\r\n\r\ninterface Goo {\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n}\r\n\r\n\r\ninterface ERC721 {\r\n    function transfer(address to, uint tokenId) public payable;\r\n    function transferFrom(address from, address to, uint tokenId) public;\r\n    function ownerOf(uint tokenId) public view returns (address owner);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayersTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLatestRaffleInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"checkWinner\",\"type\":\"address\"},{\"name\":\"checkIndex\",\"type\":\"uint256\"}],\"name\":\"awardRafflePrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"raffle\",\"type\":\"uint256\"}],\"name\":\"getRafflePlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyRaffleTicket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drawRandomWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferGoo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"startTokenRaffle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"SponsoredItemGooRaffle","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5fa3413d1e5a5f71b971348d1101c2b25549b5d9bf986174472a5553f75e501f"}]}