{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title Serpentio Contract <http://serpentio.com> - April 2018\r\n * @Author Alber Erre <arblugo@gmail.com> <http://albererre.com>\r\n * Technical details here: https://medium.com/@alber_erre/serpentio-a-snake-on-the-ethereum-blockchain-non-linear-distribution-scheme-b116bfa187d8\r\n */\r\n\r\n/**\r\n * The Serpent contract distributes its acummulated balance between investors using a non-linear scheme, inside a period of time.\r\n * As such, every new investor help to fund previous investors, under the promise that future new investors will fund itself.\r\n * Result: Early investors receive more funds than last investors.\r\n */\r\n\r\n/**\r\n * Based on Open Zeppelin - https://github.com/OpenZeppelin/zeppelin-solidity\r\n * \r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract Serpent is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// everyone should check this measure to find out how much they have earned.\r\n\tmapping (address => uint256) public investorReturn;\r\n\r\n\tuint256 public SerpenSegmentCount;\r\n\tuint256 public SerpentCountDown;\r\n\taddress public SerpentHead;\r\n\taddress[] investormapping;\r\n\r\n\tstruct investorDetails {\r\n\t    address investorAddress;\r\n\t    uint256 amountInvested;\r\n\t    uint256 SegmentNumber;\r\n\t    uint256 time;\r\n\t    string  quote;\r\n\t}\r\n\r\n\tinvestorDetails[] public investorsList;\r\n\r\n\tfunction Serpent () {\r\n\t\t// Constructor: init public variables and add creator as SerpentHead\r\n\t\tSerpentHead = owner;\r\n\t\tSerpenSegmentCount = 0;\r\n\t\tSerpentCountDown = uint256(block.timestamp);\r\n\t}\r\n\r\n\tfunction Play (string _quote) payable public {\r\n\r\n\t\trequire (msg.value > 0);\r\n        require (msg.sender != address(0)); // just in case\r\n        require (uint256(block.timestamp) < SerpentCountDown); // nobody can play once countdown is finished\r\n\r\n        address thisAddress = msg.sender;\r\n\t\tuint256 thisAmmount = msg.value;\r\n\r\n        AddReturnsMapping(thisAmmount);\r\n\t    // AddReturnsMapping MUST be before AddNewSegment, to avoid counting the new segment while calculating returns\r\n\r\n\t    SerpenSegmentCount = SerpenSegmentCount.add(1);\r\n\t\tAddNewSegment(thisAddress, thisAmmount, SerpenSegmentCount, uint256(block.timestamp), _quote);\r\n\t    // Adding new segment - the same address can send more than once.\r\n        // Although, distribution is based on chronological amounts, not addresses.\r\n\t}\r\n\r\n\t// Callback function\r\n\tfunction () payable public {\r\n\t\trequire(msg.value > 0);\r\n\r\n\t\tPlay(\"Callback, No quote\");\r\n\t}\r\n\r\n\tfunction NewSerpent (uint256 _SerpentCountDown) public onlyOwner {\r\n\r\n\t\t// this is to avoid deleting current serpent game until the previous game has finished\r\n\t\trequire (uint256(block.timestamp) > SerpentCountDown);\r\n\t\t\r\n\t\tSerpenSegmentCount = 0;\r\n\t\tSerpentCountDown = _SerpentCountDown;\r\n\r\n\t\t//Collect prime-number reminders from previous game calculations\r\n\t\tuint256 nonPrimeReminders = 0;\r\n\t\tfor (uint256 p = 0; p < investormapping.length; p++) {\r\n\t\t\tnonPrimeReminders.add(investorReturn[investormapping[p]]);\r\n\t\t}\r\n\t\tuint256 PrimeReminder = uint256(address(this).balance) - nonPrimeReminders;\r\n\t\tSerpentHead.transfer(PrimeReminder);\r\n\r\n\t\t//Delete current investormapping array elements, to init new-serpent investormapping\r\n\t\twhile (investormapping.length != 0) {\r\n\t\t\tdelete investormapping[investormapping.length-1]; //delete last element\r\n\t\t\tinvestormapping.length--;\r\n\t\t}\r\n\r\n\t\t// Start first serpent segment\r\n\t    SerpenSegmentCount = SerpenSegmentCount.add(1);\r\n\t    investormapping.push(SerpentHead);\r\n\t    AddNewSegment(SerpentHead, 1 ether, SerpenSegmentCount, uint256(block.timestamp), \"Everything started with Salazar Slytherin\");\r\n\t}\r\n\t\r\n\t\r\n\tfunction AddNewSegment (address _address, uint256 _amount, uint256 _segmentNumber, uint256 _time, string _quote) internal {\r\n\t    require (_amount > 0); // just in case\r\n\r\n\t\t// in case this is a new address, add it to mappings, if not, just do nothing\r\n\t\tuint256 inList = 0;\r\n\t\tfor (uint256 n = 0; n < investormapping.length; n++) {\r\n\t\t\tif (investormapping[n] == _address) {\r\n\t\t\t\tinList = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (inList == 0) {\r\n\t\t\tinvestorReturn[_address] = 0;\r\n\t\t\tinvestormapping.push(_address); //add only once per address\r\n\t\t}\r\n\r\n\t\t// add to struct list, but after inList check\r\n\t\tinvestorsList.push(investorDetails(_address, _amount, _segmentNumber, _time, _quote));\r\n\t}\r\n\r\n\tfunction AddReturnsMapping (uint256 _amount) internal {\r\n\r\n\t\tuint256 individualAmount = _amount.div(investormapping.length);\r\n\r\n\t\tfor (uint256 a = 0; a < investormapping.length; a++) {\r\n\t\t\tinvestorReturn[investormapping[a]] = investorReturn[investormapping[a]].add(individualAmount); \r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction CollectReturns () external {\r\n\r\n\t\tuint256 currentTime = uint256(block.timestamp);\r\n\t\tuint256 amountToCollect = getReturns(msg.sender);\r\n\t\trequire (currentTime > SerpentCountDown); // collect if serpent has finished\r\n\t\trequire(address(this).balance >= amountToCollect);\r\n\r\n\t\taddress(msg.sender).transfer(amountToCollect);\r\n\t\tinvestorReturn[msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction getBalance () public view returns(uint256) {\r\n\t\treturn uint256(address(this).balance);\r\n\t}\r\n\r\n\tfunction getParticipants () public view returns(uint256) {\r\n\t\treturn uint256(investormapping.length);\r\n\t}\r\n\r\n\tfunction getCountdownDate () public view returns(uint256) {\r\n\t\treturn uint256(SerpentCountDown);\r\n\t}\r\n\r\n\tfunction getReturns (address _address) public view returns(uint256) {\r\n\t\treturn uint256(investorReturn[_address]);\r\n\t}\r\n\t\r\n\tfunction SerpentIsRunning () public view returns(bool) {\r\n\t\treturn bool(uint256(block.timestamp) < SerpentCountDown);\r\n\t}\r\n\r\n  // End of contract\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"CollectReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SerpenSegmentCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorsList\",\"outputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"amountInvested\",\"type\":\"uint256\"},{\"name\":\"SegmentNumber\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"quote\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SerpentCountDown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_SerpentCountDown\",\"type\":\"uint256\"}],\"name\":\"NewSerpent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCountdownDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quote\",\"type\":\"string\"}],\"name\":\"Play\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getReturns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SerpentIsRunning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SerpentHead\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Serpent","CompilerVersion":"v0.4.24-nightly.2018.5.16+commit.7f965c86","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d10b34c697e693e60c97bef39719513f4a6c134e99aa4aecad2a63e27a15171f"}]}