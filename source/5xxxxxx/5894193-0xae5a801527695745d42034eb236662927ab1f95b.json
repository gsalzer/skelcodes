{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ninterface FundInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PortfolioContent(address[] assets, uint[] holdings, uint[] prices);\r\n    event RequestUpdated(uint id);\r\n    event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);\r\n    event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);\r\n    event ErrorMessage(string errorMessage);\r\n\r\n    // EXTERNAL METHODS\r\n    // Compliance by Investor\r\n    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external;\r\n    function executeRequest(uint requestId) external;\r\n    function cancelRequest(uint requestId) external;\r\n    function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);\r\n    // Administration by Manager\r\n    function enableInvestment(address[] ofAssets) external;\r\n    function disableInvestment(address[] ofAssets) external;\r\n    function shutDown() external;\r\n\r\n    // PUBLIC METHODS\r\n    function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);\r\n    function calcSharePriceAndAllocateFees() public returns (uint);\r\n\r\n\r\n    // PUBLIC VIEW METHODS\r\n    // Get general information\r\n    function getModules() view returns (address, address, address);\r\n    function getLastRequestId() view returns (uint);\r\n    function getManager() view returns (address);\r\n\r\n    // Get accounting information\r\n    function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);\r\n    function calcSharePrice() view returns (uint);\r\n}\r\n\r\ninterface AssetInterface {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    // Events\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n\r\n    //ERC 223\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\r\n\r\n    // ERC 20\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    // PUBLIC VIEW METHODS\r\n    function balanceOf(address _owner) view public returns (uint balance);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ninterface SharesInterface {\r\n\r\n    event Created(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event Annihilated(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n\r\n    // VIEW METHODS\r\n\r\n    function getName() view returns (bytes32);\r\n    function getSymbol() view returns (bytes8);\r\n    function getDecimals() view returns (uint);\r\n    function getCreationTime() view returns (uint);\r\n    function toSmallestShareUnit(uint quantity) view returns (uint);\r\n    function toWholeShareUnit(uint quantity) view returns (uint);\r\n\r\n}\r\n\r\ninterface CompetitionInterface {\r\n\r\n    // EVENTS\r\n\r\n    event Register(uint withId, address fund, address manager);\r\n    event ClaimReward(address registrant, address fund, uint shares);\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool);\r\n    function isWhitelisted(address x) view returns (bool);\r\n    function isCompetitionActive() view returns (bool);\r\n\r\n    // CONSTANT METHODS\r\n\r\n    function getMelonAsset() view returns (address);\r\n    function getRegistrantId(address x) view returns (uint);\r\n    function getRegistrantFund(address x) view returns (address);\r\n    function getCompetitionStatusOfRegistrants() view returns (address[], address[], bool[]);\r\n    function getTimeTillEnd() view returns (uint);\r\n    function getEtherValue(uint amount) view returns (uint);\r\n    function calculatePayout(uint payin) view returns (uint);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function registerForCompetition(address fund, uint8 v, bytes32 r, bytes32 s) payable;\r\n    function batchAddToWhitelist(uint maxBuyinQuantity, address[] whitelistants);\r\n    function withdrawMln(address to, uint amount);\r\n    function claimReward();\r\n\r\n}\r\n\r\ninterface ComplianceInterface {\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks whether investment is permitted for a participant\r\n    /// @param ofParticipant Address requesting to invest in a Melon fund\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    /// @return Whether identity is eligible to invest in a Melon fund.\r\n    function isInvestmentPermitted(\r\n        address ofParticipant,\r\n        uint256 giveQuantity,\r\n        uint256 shareQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks whether redemption is permitted for a participant\r\n    /// @param ofParticipant Address requesting to redeem from a Melon fund\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\r\n    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\r\n    /// @return Whether identity is eligible to redeem from a Melon fund.\r\n    function isRedemptionPermitted(\r\n        address ofParticipant,\r\n        uint256 shareQuantity,\r\n        uint256 receiveQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ncontract DBC {\r\n\r\n    // MODIFIERS\r\n\r\n    modifier pre_cond(bool condition) {\r\n        require(condition);\r\n        _;\r\n    }\r\n\r\n    modifier post_cond(bool condition) {\r\n        _;\r\n        assert(condition);\r\n    }\r\n\r\n    modifier invariant(bool condition) {\r\n        require(condition);\r\n        _;\r\n        assert(condition);\r\n    }\r\n}\r\n\r\ncontract Owned is DBC {\r\n\r\n    // FIELDS\r\n\r\n    address public owner;\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    function isOwner() internal returns (bool) { return msg.sender == owner; }\r\n\r\n}\r\n\r\ncontract CompetitionCompliance is ComplianceInterface, DBC, Owned {\r\n\r\n    address public competitionAddress;\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Constructor\r\n    /// @param ofCompetition Address of the competition contract\r\n    function CompetitionCompliance(address ofCompetition) public {\r\n        competitionAddress = ofCompetition;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks whether investment is permitted for a participant\r\n    /// @param ofParticipant Address requesting to invest in a Melon fund\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    /// @return Whether identity is eligible to invest in a Melon fund.\r\n    function isInvestmentPermitted(\r\n        address ofParticipant,\r\n        uint256 giveQuantity,\r\n        uint256 shareQuantity\r\n    )\r\n        view\r\n        returns (bool)\r\n    {\r\n        return competitionAddress == ofParticipant;\r\n    }\r\n\r\n    /// @notice Checks whether redemption is permitted for a participant\r\n    /// @param ofParticipant Address requesting to redeem from a Melon fund\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\r\n    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\r\n    /// @return isEligible Whether identity is eligible to redeem from a Melon fund.\r\n    function isRedemptionPermitted(\r\n        address ofParticipant,\r\n        uint256 shareQuantity,\r\n        uint256 receiveQuantity\r\n    )\r\n        view\r\n        returns (bool)\r\n    {\r\n        return competitionAddress == ofParticipant;\r\n    }\r\n\r\n    /// @notice Checks whether an address is whitelisted in the competition contract and competition is active\r\n    /// @param x Address\r\n    /// @return Whether the address is whitelisted\r\n    function isCompetitionAllowed(\r\n        address x\r\n    )\r\n        view\r\n        returns (bool)\r\n    {\r\n        return CompetitionInterface(competitionAddress).isWhitelisted(x) && CompetitionInterface(competitionAddress).isCompetitionActive();\r\n    }\r\n\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @notice Changes the competition address\r\n    /// @param ofCompetition Address of the competition contract\r\n    function changeCompetitionAddress(\r\n        address ofCompetition\r\n    )\r\n        pre_cond(isOwner())\r\n    {\r\n        competitionAddress = ofCompetition;\r\n    }\r\n\r\n}\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSExec {\r\n    function tryExec( address target, bytes calldata, uint value)\r\n             internal\r\n             returns (bool call_ret)\r\n    {\r\n        return target.call.value(value)(calldata);\r\n    }\r\n    function exec( address target, bytes calldata, uint value)\r\n             internal\r\n    {\r\n        if(!tryExec(target, calldata, value)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    // Convenience aliases\r\n    function exec( address t, bytes c )\r\n        internal\r\n    {\r\n        exec(t, c, 0);\r\n    }\r\n    function exec( address t, uint256 v )\r\n        internal\r\n    {\r\n        bytes memory c; exec(t, c, v);\r\n    }\r\n    function tryExec( address t, bytes c )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return tryExec(t, c, 0);\r\n    }\r\n    function tryExec( address t, uint256 v )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        bytes memory c; return tryExec(t, c, v);\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Asset is DSMath, ERC20Interface {\r\n\r\n    // DATA STRUCTURES\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public _totalSupply;\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    /// @notice Restriction: An account can only use this function to send to itself\r\n    /// @dev Allows for an approved third party to transfer tokens from one\r\n    /// address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n        // require(_to == msg.sender); // can only use transferFrom to send to self\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(_spender != address(0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @dev Returns number of allowed tokens that a spender can transfer on\r\n    /// behalf of a token owner.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    /// @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by the given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns balance of owner.\r\n    function balanceOf(address _owner) constant public returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function totalSupply() view public returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract Shares is SharesInterface, Asset {\r\n\r\n    // FIELDS\r\n\r\n    // Constructor fields\r\n    bytes32 public name;\r\n    bytes8 public symbol;\r\n    uint public decimal;\r\n    uint public creationTime;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param _name Name these shares\r\n    /// @param _symbol Symbol of shares\r\n    /// @param _decimal Amount of decimals sharePrice is denominated in, defined to be equal as deciamls in REFERENCE_ASSET contract\r\n    /// @param _creationTime Timestamp of share creation\r\n    function Shares(bytes32 _name, bytes8 _symbol, uint _decimal, uint _creationTime) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimal = _decimal;\r\n        creationTime = _creationTime;\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getName() view returns (bytes32) { return name; }\r\n    function getSymbol() view returns (bytes8) { return symbol; }\r\n    function getDecimals() view returns (uint) { return decimal; }\r\n    function getCreationTime() view returns (uint) { return creationTime; }\r\n    function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }\r\n    function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @param recipient Address the new shares should be sent to\r\n    /// @param shareQuantity Number of shares to be created\r\n    function createShares(address recipient, uint shareQuantity) internal {\r\n        _totalSupply = add(_totalSupply, shareQuantity);\r\n        balances[recipient] = add(balances[recipient], shareQuantity);\r\n        emit Created(msg.sender, now, shareQuantity);\r\n        emit Transfer(address(0), recipient, shareQuantity);\r\n    }\r\n\r\n    /// @param recipient Address the new shares should be taken from when destroyed\r\n    /// @param shareQuantity Number of shares to be annihilated\r\n    function annihilateShares(address recipient, uint shareQuantity) internal {\r\n        _totalSupply = sub(_totalSupply, shareQuantity);\r\n        balances[recipient] = sub(balances[recipient], shareQuantity);\r\n        emit Annihilated(msg.sender, now, shareQuantity);\r\n        emit Transfer(recipient, address(0), shareQuantity);\r\n    }\r\n}\r\n\r\ncontract Fund is DSMath, DBC, Owned, Shares, FundInterface {\r\n\r\n    event OrderUpdated(address exchange, bytes32 orderId, UpdateType updateType);\r\n\r\n    // TYPES\r\n\r\n    struct Modules { // Describes all modular parts, standardised through an interface\r\n        CanonicalPriceFeed pricefeed; // Provides all external data\r\n        ComplianceInterface compliance; // Boolean functions regarding invest/redeem\r\n        RiskMgmtInterface riskmgmt; // Boolean functions regarding make/take orders\r\n    }\r\n\r\n    struct Calculations { // List of internal calculations\r\n        uint gav; // Gross asset value\r\n        uint managementFee; // Time based fee\r\n        uint performanceFee; // Performance based fee measured against QUOTE_ASSET\r\n        uint unclaimedFees; // Fees not yet allocated to the fund manager\r\n        uint nav; // Net asset value\r\n        uint highWaterMark; // A record of best all-time fund performance\r\n        uint totalSupply; // Total supply of shares\r\n        uint timestamp; // Time when calculations are performed in seconds\r\n    }\r\n\r\n    enum UpdateType { make, take, cancel }\r\n    enum RequestStatus { active, cancelled, executed }\r\n    struct Request { // Describes and logs whenever asset enter and leave fund due to Participants\r\n        address participant; // Participant in Melon fund requesting investment or redemption\r\n        RequestStatus status; // Enum: active, cancelled, executed; Status of request\r\n        address requestAsset; // Address of the asset being requested\r\n        uint shareQuantity; // Quantity of Melon fund shares\r\n        uint giveQuantity; // Quantity in Melon asset to give to Melon fund to receive shareQuantity\r\n        uint receiveQuantity; // Quantity in Melon asset to receive from Melon fund for given shareQuantity\r\n        uint timestamp;     // Time of request creation in seconds\r\n        uint atUpdateId;    // Pricefeed updateId when this request was created\r\n    }\r\n\r\n    struct Exchange {\r\n        address exchange;\r\n        address exchangeAdapter;\r\n        bool takesCustody;  // exchange takes custody before making order\r\n    }\r\n\r\n    struct OpenMakeOrder {\r\n        uint id; // Order Id from exchange\r\n        uint expiresAt; // Timestamp when the order expires\r\n    }\r\n\r\n    struct Order { // Describes an order event (make or take order)\r\n        address exchangeAddress; // address of the exchange this order is on\r\n        bytes32 orderId; // Id as returned from exchange\r\n        UpdateType updateType; // Enum: make, take (cancel should be ignored)\r\n        address makerAsset; // Order maker's asset\r\n        address takerAsset; // Order taker's asset\r\n        uint makerQuantity; // Quantity of makerAsset to be traded\r\n        uint takerQuantity; // Quantity of takerAsset to be traded\r\n        uint timestamp; // Time of order creation in seconds\r\n        uint fillTakerQuantity; // Quantity of takerAsset to be filled\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // Constant fields\r\n    uint public constant MAX_FUND_ASSETS = 20; // Max ownable assets by the fund supported by gas limits\r\n    uint public constant ORDER_EXPIRATION_TIME = 86400; // Make order expiration time (1 day)\r\n    // Constructor fields\r\n    uint public MANAGEMENT_FEE_RATE; // Fee rate in QUOTE_ASSET per managed seconds in WAD\r\n    uint public PERFORMANCE_FEE_RATE; // Fee rate in QUOTE_ASSET per delta improvement in WAD\r\n    address public VERSION; // Address of Version contract\r\n    Asset public QUOTE_ASSET; // QUOTE asset as ERC20 contract\r\n    // Methods fields\r\n    Modules public modules; // Struct which holds all the initialised module instances\r\n    Exchange[] public exchanges; // Array containing exchanges this fund supports\r\n    Calculations public atLastUnclaimedFeeAllocation; // Calculation results at last allocateUnclaimedFees() call\r\n    Order[] public orders;  // append-only list of makes/takes from this fund\r\n    mapping (address => mapping(address => OpenMakeOrder)) public exchangesToOpenMakeOrders; // exchangeIndex to: asset to open make orders\r\n    bool public isShutDown; // Security feature, if yes than investing, managing, allocateUnclaimedFees gets blocked\r\n    Request[] public requests; // All the requests this fund received from participants\r\n    mapping (address => bool) public isInvestAllowed; // If false, fund rejects investments from the key asset\r\n    address[] public ownedAssets; // List of all assets owned by the fund or for which the fund has open make orders\r\n    mapping (address => bool) public isInAssetList; // Mapping from asset to whether the asset exists in ownedAssets\r\n    mapping (address => bool) public isInOpenMakeOrder; // Mapping from asset to whether the asset is in a open make order as buy asset\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Should only be called via Version.setupFund(..)\r\n    /// @param withName human-readable descriptive name (not necessarily unique)\r\n    /// @param ofQuoteAsset Asset against which mgmt and performance fee is measured against and which can be used to invest using this single asset\r\n    /// @param ofManagementFee A time based fee expressed, given in a number which is divided by 1 WAD\r\n    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 1 WAD\r\n    /// @param ofCompliance Address of compliance module\r\n    /// @param ofRiskMgmt Address of risk management module\r\n    /// @param ofPriceFeed Address of price feed module\r\n    /// @param ofExchanges Addresses of exchange on which this fund can trade\r\n    /// @param ofDefaultAssets Addresses of assets to enable invest for (quote asset is already enabled)\r\n    /// @return Deployed Fund with manager set as ofManager\r\n    function Fund(\r\n        address ofManager,\r\n        bytes32 withName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address ofPriceFeed,\r\n        address[] ofExchanges,\r\n        address[] ofDefaultAssets\r\n    )\r\n        Shares(withName, \"MLNF\", 18, now)\r\n    {\r\n        require(ofManagementFee < 10 ** 18); // Require management fee to be less than 100 percent\r\n        require(ofPerformanceFee < 10 ** 18); // Require performance fee to be less than 100 percent\r\n        isInvestAllowed[ofQuoteAsset] = true;\r\n        owner = ofManager;\r\n        MANAGEMENT_FEE_RATE = ofManagementFee; // 1 percent is expressed as 0.01 * 10 ** 18\r\n        PERFORMANCE_FEE_RATE = ofPerformanceFee; // 1 percent is expressed as 0.01 * 10 ** 18\r\n        VERSION = msg.sender;\r\n        modules.compliance = ComplianceInterface(ofCompliance);\r\n        modules.riskmgmt = RiskMgmtInterface(ofRiskMgmt);\r\n        modules.pricefeed = CanonicalPriceFeed(ofPriceFeed);\r\n        // Bridged to Melon exchange interface by exchangeAdapter library\r\n        for (uint i = 0; i < ofExchanges.length; ++i) {\r\n            require(modules.pricefeed.exchangeIsRegistered(ofExchanges[i]));\r\n            var (ofExchangeAdapter, takesCustody, ) = modules.pricefeed.getExchangeInformation(ofExchanges[i]);\r\n            exchanges.push(Exchange({\r\n                exchange: ofExchanges[i],\r\n                exchangeAdapter: ofExchangeAdapter,\r\n                takesCustody: takesCustody\r\n            }));\r\n        }\r\n        QUOTE_ASSET = Asset(ofQuoteAsset);\r\n        // Quote Asset always in owned assets list\r\n        ownedAssets.push(ofQuoteAsset);\r\n        isInAssetList[ofQuoteAsset] = true;\r\n        require(address(QUOTE_ASSET) == modules.pricefeed.getQuoteAsset()); // Sanity check\r\n        for (uint j = 0; j < ofDefaultAssets.length; j++) {\r\n            require(modules.pricefeed.assetIsRegistered(ofDefaultAssets[j]));\r\n            isInvestAllowed[ofDefaultAssets[j]] = true;\r\n        }\r\n        atLastUnclaimedFeeAllocation = Calculations({\r\n            gav: 0,\r\n            managementFee: 0,\r\n            performanceFee: 0,\r\n            unclaimedFees: 0,\r\n            nav: 0,\r\n            highWaterMark: 10 ** getDecimals(),\r\n            totalSupply: _totalSupply,\r\n            timestamp: now\r\n        });\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    // EXTERNAL : ADMINISTRATION\r\n\r\n    /// @notice Enable investment in specified assets\r\n    /// @param ofAssets Array of assets to enable investment in\r\n    function enableInvestment(address[] ofAssets)\r\n        external\r\n        pre_cond(isOwner())\r\n    {\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            require(modules.pricefeed.assetIsRegistered(ofAssets[i]));\r\n            isInvestAllowed[ofAssets[i]] = true;\r\n        }\r\n    }\r\n\r\n    /// @notice Disable investment in specified assets\r\n    /// @param ofAssets Array of assets to disable investment in\r\n    function disableInvestment(address[] ofAssets)\r\n        external\r\n        pre_cond(isOwner())\r\n    {\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            isInvestAllowed[ofAssets[i]] = false;\r\n        }\r\n    }\r\n\r\n    function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }\r\n\r\n    // EXTERNAL : PARTICIPATION\r\n\r\n    /// @notice Give melon tokens to receive shares of this fund\r\n    /// @dev Recommended to give some leeway in prices to account for possibly slightly changing prices\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    /// @param investmentAsset Address of asset to invest in\r\n    function requestInvestment(\r\n        uint giveQuantity,\r\n        uint shareQuantity,\r\n        address investmentAsset\r\n    )\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(isInvestAllowed[investmentAsset]) // investment using investmentAsset has not been deactivated by the Manager\r\n        pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))    // Compliance Module: Investment permitted\r\n    {\r\n        requests.push(Request({\r\n            participant: msg.sender,\r\n            status: RequestStatus.active,\r\n            requestAsset: investmentAsset,\r\n            shareQuantity: shareQuantity,\r\n            giveQuantity: giveQuantity,\r\n            receiveQuantity: shareQuantity,\r\n            timestamp: now,\r\n            atUpdateId: modules.pricefeed.getLastUpdateId()\r\n        }));\r\n\r\n        emit RequestUpdated(getLastRequestId());\r\n    }\r\n\r\n    /// @notice Executes active investment and redemption requests, in a way that minimises information advantages of investor\r\n    /// @dev Distributes melon and shares according to the request\r\n    /// @param id Index of request to be executed\r\n    /// @dev Active investment or redemption request executed\r\n    function executeRequest(uint id)\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(requests[id].status == RequestStatus.active)\r\n        pre_cond(\r\n            _totalSupply == 0 ||\r\n            (\r\n                now >= add(requests[id].timestamp, modules.pricefeed.getInterval()) &&\r\n                modules.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)\r\n            )\r\n        )   // PriceFeed Module: Wait at least one interval time and two updates before continuing (unless it is the first investment)\r\n\r\n    {\r\n        Request request = requests[id];\r\n        var (isRecent, , ) =\r\n            modules.pricefeed.getPriceInfo(address(request.requestAsset));\r\n        require(isRecent);\r\n\r\n        // sharePrice quoted in QUOTE_ASSET and multiplied by 10 ** fundDecimals\r\n        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees())); // By definition quoteDecimals == fundDecimals\r\n        if (request.requestAsset != address(QUOTE_ASSET)) {\r\n            var (isPriceRecent, invertedRequestAssetPrice, requestAssetDecimal) = modules.pricefeed.getInvertedPriceInfo(request.requestAsset);\r\n            if (!isPriceRecent) {\r\n                revert();\r\n            }\r\n            costQuantity = mul(costQuantity, invertedRequestAssetPrice) / 10 ** requestAssetDecimal;\r\n        }\r\n\r\n        if (\r\n            isInvestAllowed[request.requestAsset] &&\r\n            costQuantity <= request.giveQuantity\r\n        ) {\r\n            request.status = RequestStatus.executed;\r\n            require(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity)); // Allocate Value\r\n            createShares(request.participant, request.shareQuantity); // Accounting\r\n            if (!isInAssetList[request.requestAsset]) {\r\n                ownedAssets.push(request.requestAsset);\r\n                isInAssetList[request.requestAsset] = true;\r\n            }\r\n        } else {\r\n            revert(); // Invalid Request or invalid giveQuantity / receiveQuantity\r\n        }\r\n    }\r\n\r\n    /// @notice Cancels active investment and redemption requests\r\n    /// @param id Index of request to be executed\r\n    function cancelRequest(uint id)\r\n        external\r\n        pre_cond(requests[id].status == RequestStatus.active) // Request is active\r\n        pre_cond(requests[id].participant == msg.sender || isShutDown) // Either request creator or fund is shut down\r\n    {\r\n        requests[id].status = RequestStatus.cancelled;\r\n    }\r\n\r\n    /// @notice Redeems by allocating an ownership percentage of each asset to the participant\r\n    /// @dev Independent of running price feed!\r\n    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for individual assets\r\n    /// @return Whether all assets sent to shareholder or not\r\n    function redeemAllOwnedAssets(uint shareQuantity)\r\n        external\r\n        returns (bool success)\r\n    {\r\n        return emergencyRedeem(shareQuantity, ownedAssets);\r\n    }\r\n\r\n    // EXTERNAL : MANAGING\r\n\r\n    /// @notice Universal method for calling exchange functions through adapters\r\n    /// @notice See adapter contracts for parameters needed for each exchange\r\n    /// @param exchangeIndex Index of the exchange in the \"exchanges\" array\r\n    /// @param method Signature of the adapter method to call (as per ABI spec)\r\n    /// @param orderAddresses [0] Order maker\r\n    /// @param orderAddresses [1] Order taker\r\n    /// @param orderAddresses [2] Order maker asset\r\n    /// @param orderAddresses [3] Order taker asset\r\n    /// @param orderAddresses [4] Fee recipient\r\n    /// @param orderValues [0] Maker token quantity\r\n    /// @param orderValues [1] Taker token quantity\r\n    /// @param orderValues [2] Maker fee\r\n    /// @param orderValues [3] Taker fee\r\n    /// @param orderValues [4] Timestamp (seconds)\r\n    /// @param orderValues [5] Salt/nonce\r\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\r\n    /// @param orderValues [7] Dexy signature mode\r\n    /// @param identifier Order identifier\r\n    /// @param v ECDSA recovery id\r\n    /// @param r ECDSA signature output r\r\n    /// @param s ECDSA signature output s\r\n    function callOnExchange(\r\n        uint exchangeIndex,\r\n        bytes4 method,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            modules.pricefeed.exchangeMethodIsAllowed(\r\n                exchanges[exchangeIndex].exchange, method\r\n            )\r\n        );\r\n        require(\r\n            exchanges[exchangeIndex].exchangeAdapter.delegatecall(\r\n                method, exchanges[exchangeIndex].exchange,\r\n                orderAddresses, orderValues, identifier, v, r, s\r\n            )\r\n        );\r\n    }\r\n\r\n    function addOpenMakeOrder(\r\n        address ofExchange,\r\n        address ofSellAsset,\r\n        uint orderId\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        isInOpenMakeOrder[ofSellAsset] = true;\r\n        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].id = orderId;\r\n        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].expiresAt = add(now, ORDER_EXPIRATION_TIME);\r\n    }\r\n\r\n    function removeOpenMakeOrder(\r\n        address ofExchange,\r\n        address ofSellAsset\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        delete exchangesToOpenMakeOrders[ofExchange][ofSellAsset];\r\n    }\r\n\r\n    function orderUpdateHook(\r\n        address ofExchange,\r\n        bytes32 orderId,\r\n        UpdateType updateType,\r\n        address[2] orderAddresses, // makerAsset, takerAsset\r\n        uint[3] orderValues        // makerQuantity, takerQuantity, fillTakerQuantity (take only)\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        // only save make/take\r\n        if (updateType == UpdateType.make || updateType == UpdateType.take) {\r\n            orders.push(Order({\r\n                exchangeAddress: ofExchange,\r\n                orderId: orderId,\r\n                updateType: updateType,\r\n                makerAsset: orderAddresses[0],\r\n                takerAsset: orderAddresses[1],\r\n                makerQuantity: orderValues[0],\r\n                takerQuantity: orderValues[1],\r\n                timestamp: block.timestamp,\r\n                fillTakerQuantity: orderValues[2]\r\n            }));\r\n        }\r\n        emit OrderUpdated(ofExchange, orderId, updateType);\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    // PUBLIC METHODS : ACCOUNTING\r\n\r\n    /// @notice Calculates gross asset value of the fund\r\n    /// @dev Decimals in assets must be equal to decimals in PriceFeed for all entries in AssetRegistrar\r\n    /// @dev Assumes that module.pricefeed.getPriceInfo(..) returns recent prices\r\n    /// @return gav Gross asset value quoted in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcGav() returns (uint gav) {\r\n        // prices quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        uint[] memory allAssetHoldings = new uint[](ownedAssets.length);\r\n        uint[] memory allAssetPrices = new uint[](ownedAssets.length);\r\n        address[] memory tempOwnedAssets;\r\n        tempOwnedAssets = ownedAssets;\r\n        delete ownedAssets;\r\n        for (uint i = 0; i < tempOwnedAssets.length; ++i) {\r\n            address ofAsset = tempOwnedAssets[i];\r\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\r\n            uint assetHoldings = add(\r\n                uint(AssetInterface(ofAsset).balanceOf(address(this))), // asset base units held by fund\r\n                quantityHeldInCustodyOfExchange(ofAsset)\r\n            );\r\n            // assetPrice formatting: mul(exchangePrice, 10 ** assetDecimal)\r\n            var (isRecent, assetPrice, assetDecimals) = modules.pricefeed.getPriceInfo(ofAsset);\r\n            if (!isRecent) {\r\n                revert();\r\n            }\r\n            allAssetHoldings[i] = assetHoldings;\r\n            allAssetPrices[i] = assetPrice;\r\n            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\r\n            gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));   // Sum up product of asset holdings of this vault and asset prices\r\n            if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || isInOpenMakeOrder[ofAsset]) { // Check if asset holdings is not zero or is address(QUOTE_ASSET) or in open make order\r\n                ownedAssets.push(ofAsset);\r\n            } else {\r\n                isInAssetList[ofAsset] = false; // Remove from ownedAssets if asset holdings are zero\r\n            }\r\n        }\r\n        emit PortfolioContent(tempOwnedAssets, allAssetHoldings, allAssetPrices);\r\n    }\r\n\r\n    /// @notice Add an asset to the list that this fund owns\r\n    function addAssetToOwnedAssets (address ofAsset)\r\n        public\r\n        pre_cond(isOwner() || msg.sender == address(this))\r\n    {\r\n        isInOpenMakeOrder[ofAsset] = true;\r\n        if (!isInAssetList[ofAsset]) {\r\n            ownedAssets.push(ofAsset);\r\n            isInAssetList[ofAsset] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Calculates unclaimed fees of the fund manager\r\n    @param gav Gross asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    @return {\r\n      \"managementFees\": \"A time (seconds) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\",\r\n      \"performanceFees\": \"A performance (rise of sharePrice measured in QUOTE_ASSET) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\",\r\n      \"unclaimedfees\": \"The sum of both managementfee and performancefee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\"\r\n    }\r\n    */\r\n    function calcUnclaimedFees(uint gav)\r\n        view\r\n        returns (\r\n            uint managementFee,\r\n            uint performanceFee,\r\n            uint unclaimedFees)\r\n    {\r\n        // Management fee calculation\r\n        uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);\r\n        uint gavPercentage = mul(timePassed, gav) / (1 years);\r\n        managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);\r\n\r\n        // Performance fee calculation\r\n        // Handle potential division through zero by defining a default value\r\n        uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), _totalSupply) : toSmallestShareUnit(1);\r\n        if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {\r\n            uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);\r\n            uint investmentProfits = wmul(gainInSharePrice, _totalSupply);\r\n            performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);\r\n        }\r\n\r\n        // Sum of all FEES\r\n        unclaimedFees = add(managementFee, performanceFee);\r\n    }\r\n\r\n    /// @notice Calculates the Net asset value of this fund\r\n    /// @param gav Gross asset value of this fund in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @param unclaimedFees The sum of both managementFee and performanceFee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @return nav Net asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcNav(uint gav, uint unclaimedFees)\r\n        view\r\n        returns (uint nav)\r\n    {\r\n        nav = sub(gav, unclaimedFees);\r\n    }\r\n\r\n    /// @notice Calculates the share price of the fund\r\n    /// @dev Convention for valuePerShare (== sharePrice) formatting: mul(totalValue / numShares, 10 ** decimal), to avoid floating numbers\r\n    /// @dev Non-zero share supply; value denominated in [base unit of melonAsset]\r\n    /// @param totalValue the total value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @param numShares the number of shares multiplied by 10 ** shareDecimals\r\n    /// @return valuePerShare Share price denominated in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcValuePerShare(uint totalValue, uint numShares)\r\n        view\r\n        pre_cond(numShares > 0)\r\n        returns (uint valuePerShare)\r\n    {\r\n        valuePerShare = toSmallestShareUnit(totalValue) / numShares;\r\n    }\r\n\r\n    /**\r\n    @notice Calculates essential fund metrics\r\n    @return {\r\n      \"gav\": \"Gross asset value of this fund denominated in [base unit of melonAsset]\",\r\n      \"managementFee\": \"A time (seconds) based fee\",\r\n      \"performanceFee\": \"A performance (rise of sharePrice measured in QUOTE_ASSET) based fee\",\r\n      \"unclaimedFees\": \"The sum of both managementFee and performanceFee denominated in [base unit of melonAsset]\",\r\n      \"feesShareQuantity\": \"The number of shares to be given as fees to the manager\",\r\n      \"nav\": \"Net asset value denominated in [base unit of melonAsset]\",\r\n      \"sharePrice\": \"Share price denominated in [base unit of melonAsset]\"\r\n    }\r\n    */\r\n    function performCalculations()\r\n        view\r\n        returns (\r\n            uint gav,\r\n            uint managementFee,\r\n            uint performanceFee,\r\n            uint unclaimedFees,\r\n            uint feesShareQuantity,\r\n            uint nav,\r\n            uint sharePrice\r\n        )\r\n    {\r\n        gav = calcGav(); // Reflects value independent of fees\r\n        (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);\r\n        nav = calcNav(gav, unclaimedFees);\r\n\r\n        // The value of unclaimedFees measured in shares of this fund at current value\r\n        feesShareQuantity = (gav == 0) ? 0 : mul(_totalSupply, unclaimedFees) / gav;\r\n        // The total share supply including the value of unclaimedFees, measured in shares of this fund\r\n        uint totalSupplyAccountingForFees = add(_totalSupply, feesShareQuantity);\r\n        sharePrice = _totalSupply > 0 ? calcValuePerShare(gav, totalSupplyAccountingForFees) : toSmallestShareUnit(1); // Handle potential division through zero by defining a default value\r\n    }\r\n\r\n    /// @notice Converts unclaimed fees of the manager into fund shares\r\n    /// @return sharePrice Share price denominated in [base unit of melonAsset]\r\n    function calcSharePriceAndAllocateFees() public returns (uint)\r\n    {\r\n        var (\r\n            gav,\r\n            managementFee,\r\n            performanceFee,\r\n            unclaimedFees,\r\n            feesShareQuantity,\r\n            nav,\r\n            sharePrice\r\n        ) = performCalculations();\r\n\r\n        createShares(owner, feesShareQuantity); // Updates _totalSupply by creating shares allocated to manager\r\n\r\n        // Update Calculations\r\n        uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;\r\n        atLastUnclaimedFeeAllocation = Calculations({\r\n            gav: gav,\r\n            managementFee: managementFee,\r\n            performanceFee: performanceFee,\r\n            unclaimedFees: unclaimedFees,\r\n            nav: nav,\r\n            highWaterMark: highWaterMark,\r\n            totalSupply: _totalSupply,\r\n            timestamp: now\r\n        });\r\n\r\n        emit FeesConverted(now, feesShareQuantity, unclaimedFees);\r\n        emit CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, _totalSupply);\r\n\r\n        return sharePrice;\r\n    }\r\n\r\n    // PUBLIC : REDEEMING\r\n\r\n    /// @notice Redeems by allocating an ownership percentage only of requestedAssets to the participant\r\n    /// @dev This works, but with loops, so only up to a certain number of assets (right now the max is 4)\r\n    /// @dev Independent of running price feed! Note: if requestedAssets != ownedAssets then participant misses out on some owned value\r\n    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for a slice of assets\r\n    /// @param requestedAssets List of addresses that consitute a subset of ownedAssets.\r\n    /// @return Whether all assets sent to shareholder or not\r\n    function emergencyRedeem(uint shareQuantity, address[] requestedAssets)\r\n        public\r\n        pre_cond(balances[msg.sender] >= shareQuantity)  // sender owns enough shares\r\n        returns (bool)\r\n    {\r\n        address ofAsset;\r\n        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\r\n        address[] memory redeemedAssets = new address[](requestedAssets.length);\r\n\r\n        // Check whether enough assets held by fund\r\n        for (uint i = 0; i < requestedAssets.length; ++i) {\r\n            ofAsset = requestedAssets[i];\r\n            require(isInAssetList[ofAsset]);\r\n            for (uint j = 0; j < redeemedAssets.length; j++) {\r\n                if (ofAsset == redeemedAssets[j]) {\r\n                    revert();\r\n                }\r\n            }\r\n            redeemedAssets[i] = ofAsset;\r\n            uint assetHoldings = add(\r\n                uint(AssetInterface(ofAsset).balanceOf(address(this))),\r\n                quantityHeldInCustodyOfExchange(ofAsset)\r\n            );\r\n\r\n            if (assetHoldings == 0) continue;\r\n\r\n            // participant's ownership percentage of asset holdings\r\n            ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / _totalSupply;\r\n\r\n            // CRITICAL ERR: Not enough fund asset balance for owed ownershipQuantitiy, eg in case of unreturned asset quantity at address(exchanges[i].exchange) address\r\n            if (uint(AssetInterface(ofAsset).balanceOf(address(this))) < ownershipQuantities[i]) {\r\n                isShutDown = true;\r\n                emit ErrorMessage(\"CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy\");\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Annihilate shares before external calls to prevent reentrancy\r\n        annihilateShares(msg.sender, shareQuantity);\r\n\r\n        // Transfer ownershipQuantity of Assets\r\n        for (uint k = 0; k < requestedAssets.length; ++k) {\r\n            // Failed to send owed ownershipQuantity from fund to participant\r\n            ofAsset = requestedAssets[k];\r\n            if (ownershipQuantities[k] == 0) {\r\n                continue;\r\n            } else if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[k])) {\r\n                revert();\r\n            }\r\n        }\r\n        emit Redeemed(msg.sender, now, shareQuantity);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC : FEES\r\n\r\n    /// @dev Quantity of asset held in exchange according to associated order id\r\n    /// @param ofAsset Address of asset\r\n    /// @return Quantity of input asset held in exchange\r\n    function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {\r\n        uint totalSellQuantity;     // quantity in custody across exchanges\r\n        uint totalSellQuantityInApprove; // quantity of asset in approve (allowance) but not custody of exchange\r\n        for (uint i; i < exchanges.length; i++) {\r\n            if (exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id == 0) {\r\n                continue;\r\n            }\r\n            var (sellAsset, , sellQuantity, ) = GenericExchangeInterface(exchanges[i].exchangeAdapter).getOrder(exchanges[i].exchange, exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id);\r\n            if (sellQuantity == 0) {    // remove id if remaining sell quantity zero (closed)\r\n                delete exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset];\r\n            }\r\n            totalSellQuantity = add(totalSellQuantity, sellQuantity);\r\n            if (!exchanges[i].takesCustody) {\r\n                totalSellQuantityInApprove += sellQuantity;\r\n            }\r\n        }\r\n        if (totalSellQuantity == 0) {\r\n            isInOpenMakeOrder[sellAsset] = false;\r\n        }\r\n        return sub(totalSellQuantity, totalSellQuantityInApprove); // Since quantity in approve is not actually in custody\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Calculates sharePrice denominated in [base unit of melonAsset]\r\n    /// @return sharePrice Share price denominated in [base unit of melonAsset]\r\n    function calcSharePrice() view returns (uint sharePrice) {\r\n        (, , , , , sharePrice) = performCalculations();\r\n        return sharePrice;\r\n    }\r\n\r\n    function getModules() view returns (address, address, address) {\r\n        return (\r\n            address(modules.pricefeed),\r\n            address(modules.compliance),\r\n            address(modules.riskmgmt)\r\n        );\r\n    }\r\n\r\n    function getLastRequestId() view returns (uint) { return requests.length - 1; }\r\n    function getLastOrderIndex() view returns (uint) { return orders.length - 1; }\r\n    function getManager() view returns (address) { return owner; }\r\n    function getOwnedAssetsLength() view returns (uint) { return ownedAssets.length; }\r\n    function getExchangeInfo() view returns (address[], address[], bool[]) {\r\n        address[] memory ofExchanges = new address[](exchanges.length);\r\n        address[] memory ofAdapters = new address[](exchanges.length);\r\n        bool[] memory takesCustody = new bool[](exchanges.length);\r\n        for (uint i = 0; i < exchanges.length; i++) {\r\n            ofExchanges[i] = exchanges[i].exchange;\r\n            ofAdapters[i] = exchanges[i].exchangeAdapter;\r\n            takesCustody[i] = exchanges[i].takesCustody;\r\n        }\r\n        return (ofExchanges, ofAdapters, takesCustody);\r\n    }\r\n    function orderExpired(address ofExchange, address ofAsset) view returns (bool) {\r\n        uint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;\r\n        require(expiryTime > 0);\r\n        return block.timestamp >= expiryTime;\r\n    }\r\n    function getOpenOrderInfo(address ofExchange, address ofAsset) view returns (uint, uint) {\r\n        OpenMakeOrder order = exchangesToOpenMakeOrders[ofExchange][ofAsset];\r\n        return (order.id, order.expiresAt);\r\n    }\r\n}\r\n\r\ncontract Competition is CompetitionInterface, DSMath, DBC, Owned {\r\n\r\n    // TYPES\r\n\r\n    struct Registrant {\r\n        address fund; // Address of the Melon fund\r\n        address registrant; // Manager and registrant of the fund\r\n        bool hasSigned; // Whether initial requirements passed and Registrant signed Terms and Conditions;\r\n        uint buyinQuantity; // Quantity of buyinAsset spent\r\n        uint payoutQuantity; // Quantity of payoutAsset received as prize\r\n        bool isRewarded; // Is the Registrant rewarded yet\r\n    }\r\n\r\n    struct RegistrantId {\r\n        uint id; // Actual Registrant Id\r\n        bool exists; // Used to check if the mapping exists\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // Constant fields\r\n    // Competition terms and conditions as displayed on https://ipfs.io/ipfs/QmXuUfPi6xeYfuMwpVAughm7GjGUjkbEojhNR8DJqVBBxc\r\n    // IPFS hash encoded using http://lenschulwitz.com/base58\r\n    bytes public constant TERMS_AND_CONDITIONS = hex\"12208E21FD34B8B2409972D30326D840C9D747438A118580D6BA8C0735ED53810491\";\r\n    uint public MELON_BASE_UNIT = 10 ** 18;\r\n    // Constructor fields\r\n    address public custodian; // Address of the custodian which holds the funds sent\r\n    uint public startTime; // Competition start time in seconds (Temporarily Set)\r\n    uint public endTime; // Competition end time in seconds\r\n    uint public payoutRate; // Fixed MLN - Ether conversion rate\r\n    uint public bonusRate; // Bonus multiplier\r\n    uint public totalMaxBuyin; // Limit amount of deposit to participate in competition (Valued in Ether)\r\n    uint public currentTotalBuyin; // Total buyin till now\r\n    uint public maxRegistrants; // Limit number of participate in competition\r\n    uint public prizeMoneyAsset; // Equivalent to payoutAsset\r\n    uint public prizeMoneyQuantity; // Total prize money pool\r\n    address public MELON_ASSET; // Adresss of Melon asset contract\r\n    ERC20Interface public MELON_CONTRACT; // Melon as ERC20 contract\r\n    address public COMPETITION_VERSION; // Version contract address\r\n\r\n    // Methods fields\r\n    Registrant[] public registrants; // List of all registrants, can be externally accessed\r\n    mapping (address => address) public registeredFundToRegistrants; // For fund address indexed accessing of registrant addresses\r\n    mapping(address => RegistrantId) public registrantToRegistrantIds; // For registrant address indexed accessing of registrant ids\r\n    mapping(address => uint) public whitelistantToMaxBuyin; // For registrant address to respective max buyIn cap (Valued in Ether)\r\n\r\n    //EVENTS\r\n\r\n    event Register(uint withId, address fund, address manager);\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    function Competition(\r\n        address ofMelonAsset,\r\n        address ofCompetitionVersion,\r\n        address ofCustodian,\r\n        uint ofStartTime,\r\n        uint ofEndTime,\r\n        uint ofPayoutRate,\r\n        uint ofTotalMaxBuyin,\r\n        uint ofMaxRegistrants\r\n    ) {\r\n        MELON_ASSET = ofMelonAsset;\r\n        MELON_CONTRACT = ERC20Interface(MELON_ASSET);\r\n        COMPETITION_VERSION = ofCompetitionVersion;\r\n        custodian = ofCustodian;\r\n        startTime = ofStartTime;\r\n        endTime = ofEndTime;\r\n        payoutRate = ofPayoutRate;\r\n        totalMaxBuyin = ofTotalMaxBuyin;\r\n        maxRegistrants = ofMaxRegistrants;\r\n    }\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    /// @dev Proofs that terms and conditions have been read and understood\r\n    /// @param byManager Address of the fund manager, as used in the ipfs-frontend\r\n    /// @param v ellipitc curve parameter v\r\n    /// @param r ellipitc curve parameter r\r\n    /// @param s ellipitc curve parameter s\r\n    /// @return Whether or not terms and conditions have been read and understood\r\n    function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool) {\r\n        return ecrecover(\r\n            // Parity does prepend \\x19Ethereum Signed Message:\\n{len(message)} before signing.\r\n            //  Signature order has also been changed in 1.6.7 and upcoming 1.7.x,\r\n            //  it will return rsv (same as geth; where v is [27, 28]).\r\n            // Note that if you are using ecrecover, v will be either \"00\" or \"01\".\r\n            //  As a result, in order to use this value, you will have to parse it to an\r\n            //  integer and then add 27. This will result in either a 27 or a 28.\r\n            //  https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsign\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n34\", TERMS_AND_CONDITIONS),\r\n            v,\r\n            r,\r\n            s\r\n        ) == byManager; // Has sender signed TERMS_AND_CONDITIONS\r\n    }\r\n\r\n    /// @dev Whether message sender is KYC verified through CERTIFIER\r\n    /// @param x Address to be checked for KYC verification\r\n    function isWhitelisted(address x) view returns (bool) { return whitelistantToMaxBuyin[x] > 0; }\r\n\r\n    /// @dev Whether the competition is on-going\r\n    function isCompetitionActive() view returns (bool) { return now >= startTime && now < endTime; }\r\n\r\n    // CONSTANT METHODS\r\n\r\n    function getMelonAsset() view returns (address) { return MELON_ASSET; }\r\n\r\n    /// @return Get RegistrantId from registrant address\r\n    function getRegistrantId(address x) view returns (uint) { return registrantToRegistrantIds[x].id; }\r\n\r\n    /// @return Address of the fund registered by the registrant address\r\n    function getRegistrantFund(address x) view returns (address) { return registrants[getRegistrantId(x)].fund; }\r\n\r\n    /// @return Get time to end of the competition\r\n    function getTimeTillEnd() view returns (uint) {\r\n        if (now > endTime) {\r\n            return 0;\r\n        }\r\n        return sub(endTime, now);\r\n    }\r\n\r\n    /// @return Get value of MLN amount in Ether\r\n    function getEtherValue(uint amount) view returns (uint) {\r\n        address feedAddress = Version(COMPETITION_VERSION).CANONICAL_PRICEFEED();\r\n        var (isRecent, price, ) = CanonicalPriceFeed(feedAddress).getPriceInfo(MELON_ASSET);\r\n        if (!isRecent) {\r\n            revert();\r\n        }\r\n        return mul(price, amount) / 10 ** 18;\r\n    }\r\n\r\n    /// @return Calculated payout in MLN with bonus for payin in Ether\r\n    function calculatePayout(uint payin) view returns (uint payoutQuantity) {\r\n        payoutQuantity = mul(payin, payoutRate) / 10 ** 18;\r\n    }\r\n\r\n    /**\r\n    @notice Returns an array of fund addresses and an associated array of whether competing and whether disqualified\r\n    @return {\r\n      \"fundAddrs\": \"Array of addresses of Melon Funds\",\r\n      \"fundRegistrants\": \"Array of addresses of Melon fund managers, as used in the ipfs-frontend\",\r\n    }\r\n    */\r\n    function getCompetitionStatusOfRegistrants()\r\n        view\r\n        returns(\r\n            address[],\r\n            address[],\r\n            bool[]\r\n        )\r\n    {\r\n        address[] memory fundAddrs = new address[](registrants.length);\r\n        address[] memory fundRegistrants = new address[](registrants.length);\r\n        bool[] memory isRewarded = new bool[](registrants.length);\r\n\r\n        for (uint i = 0; i < registrants.length; i++) {\r\n            fundAddrs[i] = registrants[i].fund;\r\n            fundRegistrants[i] = registrants[i].registrant;\r\n            isRewarded[i] = registrants[i].isRewarded;\r\n        }\r\n        return (fundAddrs, fundRegistrants, isRewarded);\r\n    }\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    /// @notice Register to take part in the competition\r\n    /// @dev Check if the fund address is actually from the Competition Version\r\n    /// @param fund Address of the Melon fund\r\n    /// @param v ellipitc curve parameter v\r\n    /// @param r ellipitc curve parameter r\r\n    /// @param s ellipitc curve parameter s\r\n    function registerForCompetition(\r\n        address fund,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        payable\r\n        pre_cond(isCompetitionActive() && !Version(COMPETITION_VERSION).isShutDown())\r\n        pre_cond(termsAndConditionsAreSigned(msg.sender, v, r, s) && isWhitelisted(msg.sender))\r\n    {\r\n        require(registeredFundToRegistrants[fund] == address(0) && registrantToRegistrantIds[msg.sender].exists == false);\r\n        require(add(currentTotalBuyin, msg.value) <= totalMaxBuyin && registrants.length < maxRegistrants);\r\n        require(msg.value <= whitelistantToMaxBuyin[msg.sender]);\r\n        require(Version(COMPETITION_VERSION).getFundByManager(msg.sender) == fund);\r\n\r\n        // Calculate Payout Quantity, invest the quantity in registrant's fund\r\n        uint payoutQuantity = calculatePayout(msg.value);\r\n        registeredFundToRegistrants[fund] = msg.sender;\r\n        registrantToRegistrantIds[msg.sender] = RegistrantId({id: registrants.length, exists: true});\r\n        currentTotalBuyin = add(currentTotalBuyin, msg.value);\r\n        FundInterface fundContract = FundInterface(fund);\r\n        MELON_CONTRACT.approve(fund, payoutQuantity);\r\n\r\n        // Give payoutRequest MLN in return for msg.value\r\n        fundContract.requestInvestment(payoutQuantity, getEtherValue(payoutQuantity), MELON_ASSET);\r\n        fundContract.executeRequest(fundContract.getLastRequestId());\r\n        custodian.transfer(msg.value);\r\n\r\n        // Emit Register event\r\n        emit Register(registrants.length, fund, msg.sender);\r\n\r\n        registrants.push(Registrant({\r\n            fund: fund,\r\n            registrant: msg.sender,\r\n            hasSigned: true,\r\n            buyinQuantity: msg.value,\r\n            payoutQuantity: payoutQuantity,\r\n            isRewarded: false\r\n        }));\r\n    }\r\n\r\n    /// @notice Add batch addresses to whitelist with set maxBuyinQuantity\r\n    /// @dev Only the owner can call this function\r\n    /// @param maxBuyinQuantity Quantity of payoutAsset received as prize\r\n    /// @param whitelistants Performance of Melon fund at competition endTime; Can be changed for any other comparison metric\r\n    function batchAddToWhitelist(\r\n        uint maxBuyinQuantity,\r\n        address[] whitelistants\r\n    )\r\n        pre_cond(isOwner())\r\n        pre_cond(now < endTime)\r\n    {\r\n        for (uint i = 0; i < whitelistants.length; ++i) {\r\n            whitelistantToMaxBuyin[whitelistants[i]] = maxBuyinQuantity;\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw MLN\r\n    /// @dev Only the owner can call this function\r\n    function withdrawMln(address to, uint amount)\r\n        pre_cond(isOwner())\r\n    {\r\n        MELON_CONTRACT.transfer(to, amount);\r\n    }\r\n\r\n    /// @notice Claim Reward\r\n    function claimReward()\r\n        pre_cond(getRegistrantFund(msg.sender) != address(0))\r\n    {\r\n        require(block.timestamp >= endTime || Version(COMPETITION_VERSION).isShutDown());\r\n        Registrant registrant  = registrants[getRegistrantId(msg.sender)];\r\n        require(registrant.isRewarded == false);\r\n        registrant.isRewarded = true;\r\n        // Is this safe to assume this or should we transfer all the balance instead?\r\n        uint balance = AssetInterface(registrant.fund).balanceOf(address(this));\r\n        require(AssetInterface(registrant.fund).transfer(registrant.registrant, balance));\r\n\r\n        // Emit ClaimedReward event\r\n        emit ClaimReward(msg.sender, registrant.fund, balance);\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSGroup is DSExec, DSNote {\r\n    address[]  public  members;\r\n    uint       public  quorum;\r\n    uint       public  window;\r\n    uint       public  actionCount;\r\n\r\n    mapping (uint => Action)                     public  actions;\r\n    mapping (uint => mapping (address => bool))  public  confirmedBy;\r\n    mapping (address => bool)                    public  isMember;\r\n\r\n    // Legacy events\r\n    event Proposed   (uint id, bytes calldata);\r\n    event Confirmed  (uint id, address member);\r\n    event Triggered  (uint id);\r\n\r\n    struct Action {\r\n        address  target;\r\n        bytes    calldata;\r\n        uint     value;\r\n\r\n        uint     confirmations;\r\n        uint     deadline;\r\n        bool     triggered;\r\n    }\r\n\r\n    function DSGroup(\r\n        address[]  members_,\r\n        uint       quorum_,\r\n        uint       window_\r\n    ) {\r\n        members  = members_;\r\n        quorum   = quorum_;\r\n        window   = window_;\r\n\r\n        for (uint i = 0; i < members.length; i++) {\r\n            isMember[members[i]] = true;\r\n        }\r\n    }\r\n\r\n    function memberCount() constant returns (uint) {\r\n        return members.length;\r\n    }\r\n\r\n    function target(uint id) constant returns (address) {\r\n        return actions[id].target;\r\n    }\r\n    function calldata(uint id) constant returns (bytes) {\r\n        return actions[id].calldata;\r\n    }\r\n    function value(uint id) constant returns (uint) {\r\n        return actions[id].value;\r\n    }\r\n\r\n    function confirmations(uint id) constant returns (uint) {\r\n        return actions[id].confirmations;\r\n    }\r\n    function deadline(uint id) constant returns (uint) {\r\n        return actions[id].deadline;\r\n    }\r\n    function triggered(uint id) constant returns (bool) {\r\n        return actions[id].triggered;\r\n    }\r\n\r\n    function confirmed(uint id) constant returns (bool) {\r\n        return confirmations(id) >= quorum;\r\n    }\r\n    function expired(uint id) constant returns (bool) {\r\n        return now > deadline(id);\r\n    }\r\n\r\n    function deposit() note payable {\r\n    }\r\n\r\n    function propose(\r\n        address  target,\r\n        bytes    calldata,\r\n        uint     value\r\n    ) onlyMembers note returns (uint id) {\r\n        id = ++actionCount;\r\n\r\n        actions[id].target    = target;\r\n        actions[id].calldata  = calldata;\r\n        actions[id].value     = value;\r\n        actions[id].deadline  = now + window;\r\n\r\n        Proposed(id, calldata);\r\n    }\r\n\r\n    function confirm(uint id) onlyMembers onlyActive(id) note {\r\n        assert(!confirmedBy[id][msg.sender]);\r\n\r\n        confirmedBy[id][msg.sender] = true;\r\n        actions[id].confirmations++;\r\n\r\n        Confirmed(id, msg.sender);\r\n    }\r\n\r\n    function trigger(uint id) onlyMembers onlyActive(id) note {\r\n        assert(confirmed(id));\r\n\r\n        actions[id].triggered = true;\r\n        exec(actions[id].target, actions[id].calldata, actions[id].value);\r\n\r\n        Triggered(id);\r\n    }\r\n\r\n    modifier onlyMembers {\r\n        assert(isMember[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyActive(uint id) {\r\n        assert(!expired(id));\r\n        assert(!triggered(id));\r\n        _;\r\n    }\r\n\r\n    //------------------------------------------------------------------\r\n    // Legacy functions\r\n    //------------------------------------------------------------------\r\n\r\n    function getInfo() constant returns (\r\n        uint  quorum_,\r\n        uint  memberCount,\r\n        uint  window_,\r\n        uint  actionCount_\r\n    ) {\r\n        return (quorum, members.length, window, actionCount);\r\n    }\r\n\r\n    function getActionStatus(uint id) constant returns (\r\n        uint     confirmations,\r\n        uint     deadline,\r\n        bool     triggered,\r\n        address  target,\r\n        uint     value\r\n    ) {\r\n        return (\r\n            actions[id].confirmations,\r\n            actions[id].deadline,\r\n            actions[id].triggered,\r\n            actions[id].target,\r\n            actions[id].value\r\n        );\r\n    }\r\n}\r\n\r\ncontract DSGroupFactory is DSNote {\r\n    mapping (address => bool)  public  isGroup;\r\n\r\n    function newGroup(\r\n        address[]  members,\r\n        uint       quorum,\r\n        uint       window\r\n    ) note returns (DSGroup group) {\r\n        group = new DSGroup(members, quorum, window);\r\n        isGroup[group] = true;\r\n    }\r\n}\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(s));\r\n    }\r\n\r\n}\r\n\r\ninterface GenericExchangeInterface {\r\n\r\n    // EVENTS\r\n\r\n    event OrderUpdated(uint id);\r\n\r\n    // METHODS\r\n    // EXTERNAL METHODS\r\n\r\n    function makeOrder(\r\n        address onExchange,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) external returns (uint);\r\n    function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);\r\n    function cancelOrder(address onExchange, uint id) external returns (bool);\r\n\r\n\r\n    // PUBLIC METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function isApproveOnly() view returns (bool);\r\n    function getLastOrderId(address onExchange) view returns (uint);\r\n    function isActive(address onExchange, uint id) view returns (bool);\r\n    function getOwner(address onExchange, uint id) view returns (address);\r\n    function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);\r\n    function getTimestamp(address onExchange, uint id) view returns (uint);\r\n\r\n}\r\n\r\ncontract CanonicalRegistrar is DSThing, DBC {\r\n\r\n    // TYPES\r\n\r\n    struct Asset {\r\n        bool exists; // True if asset is registered here\r\n        bytes32 name; // Human-readable name of the Asset as in ERC223 token standard\r\n        bytes8 symbol; // Human-readable symbol of the Asset as in ERC223 token standard\r\n        uint decimals; // Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\r\n        string url; // URL for additional information of Asset\r\n        string ipfsHash; // Same as url but for ipfs\r\n        address breakIn; // Break in contract on destination chain\r\n        address breakOut; // Break out contract on this chain; A way to leave\r\n        uint[] standards; // compliance with standards like ERC20, ERC223, ERC777, etc. (the uint is the standard number)\r\n        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->Asset` as much as possible. I.e. name same concepts with the same functionSignature.\r\n        uint price; // Price of asset quoted against `QUOTE_ASSET` * 10 ** decimals\r\n        uint timestamp; // Timestamp of last price update of this asset\r\n    }\r\n\r\n    struct Exchange {\r\n        bool exists;\r\n        address adapter; // adapter contract for this exchange\r\n        // One-time note: takesCustody is inverse case of isApproveOnly\r\n        bool takesCustody; // True in case of exchange implementation which requires  are approved when an order is made instead of transfer\r\n        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->ExchangeAdapter` as much as possible. I.e. name same concepts with the same functionSignature.\r\n    }\r\n    // TODO: populate each field here\r\n    // TODO: add whitelistFunction function\r\n\r\n    // FIELDS\r\n\r\n    // Methods fields\r\n    mapping (address => Asset) public assetInformation;\r\n    address[] public registeredAssets;\r\n\r\n    mapping (address => Exchange) public exchangeInformation;\r\n    address[] public registeredExchanges;\r\n\r\n    // METHODS\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @notice Registers an Asset information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofAsset is registered\r\n    /// @param ofAsset Address of asset to be registered\r\n    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputDecimals Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputUrl Url for extended information of the asset\r\n    /// @param inputIpfsHash Same as url but for ipfs\r\n    /// @param breakInBreakOut Address of break in and break out contracts on destination chain\r\n    /// @param inputStandards Integers of EIP standards this asset adheres to\r\n    /// @param inputFunctionSignatures Function signatures for whitelisted asset functions\r\n    function registerAsset(\r\n        address ofAsset,\r\n        bytes32 inputName,\r\n        bytes8 inputSymbol,\r\n        uint inputDecimals,\r\n        string inputUrl,\r\n        string inputIpfsHash,\r\n        address[2] breakInBreakOut,\r\n        uint[] inputStandards,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(!assetInformation[ofAsset].exists)\r\n    {\r\n        assetInformation[ofAsset].exists = true;\r\n        registeredAssets.push(ofAsset);\r\n        updateAsset(\r\n            ofAsset,\r\n            inputName,\r\n            inputSymbol,\r\n            inputDecimals,\r\n            inputUrl,\r\n            inputIpfsHash,\r\n            breakInBreakOut,\r\n            inputStandards,\r\n            inputFunctionSignatures\r\n        );\r\n        assert(assetInformation[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Register an exchange information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofExchange is registered\r\n    /// @param ofExchange Address of the exchange\r\n    /// @param ofExchangeAdapter Address of exchange adapter for this exchange\r\n    /// @param inputTakesCustody Whether this exchange takes custody of tokens before trading\r\n    /// @param inputFunctionSignatures Function signatures for whitelisted exchange functions\r\n    function registerExchange(\r\n        address ofExchange,\r\n        address ofExchangeAdapter,\r\n        bool inputTakesCustody,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(!exchangeInformation[ofExchange].exists)\r\n    {\r\n        exchangeInformation[ofExchange].exists = true;\r\n        registeredExchanges.push(ofExchange);\r\n        updateExchange(\r\n            ofExchange,\r\n            ofExchangeAdapter,\r\n            inputTakesCustody,\r\n            inputFunctionSignatures\r\n        );\r\n        assert(exchangeInformation[ofExchange].exists);\r\n    }\r\n\r\n    /// @notice Updates description information of a registered Asset\r\n    /// @dev Pre: Owner can change an existing entry\r\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\r\n    /// @param ofAsset Address of the asset to be updated\r\n    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputUrl Url for extended information of the asset\r\n    /// @param inputIpfsHash Same as url but for ipfs\r\n    function updateAsset(\r\n        address ofAsset,\r\n        bytes32 inputName,\r\n        bytes8 inputSymbol,\r\n        uint inputDecimals,\r\n        string inputUrl,\r\n        string inputIpfsHash,\r\n        address[2] ofBreakInBreakOut,\r\n        uint[] inputStandards,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(assetInformation[ofAsset].exists)\r\n    {\r\n        Asset asset = assetInformation[ofAsset];\r\n        asset.name = inputName;\r\n        asset.symbol = inputSymbol;\r\n        asset.decimals = inputDecimals;\r\n        asset.url = inputUrl;\r\n        asset.ipfsHash = inputIpfsHash;\r\n        asset.breakIn = ofBreakInBreakOut[0];\r\n        asset.breakOut = ofBreakInBreakOut[1];\r\n        asset.standards = inputStandards;\r\n        asset.functionSignatures = inputFunctionSignatures;\r\n    }\r\n\r\n    function updateExchange(\r\n        address ofExchange,\r\n        address ofExchangeAdapter,\r\n        bool inputTakesCustody,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(exchangeInformation[ofExchange].exists)\r\n    {\r\n        Exchange exchange = exchangeInformation[ofExchange];\r\n        exchange.adapter = ofExchangeAdapter;\r\n        exchange.takesCustody = inputTakesCustody;\r\n        exchange.functionSignatures = inputFunctionSignatures;\r\n    }\r\n\r\n    // TODO: check max size of array before remaking this becomes untenable\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofAsset address for which specific information is requested\r\n    function removeAsset(\r\n        address ofAsset,\r\n        uint assetIndex\r\n    )\r\n        auth\r\n        pre_cond(assetInformation[ofAsset].exists)\r\n    {\r\n        require(registeredAssets[assetIndex] == ofAsset);\r\n        delete assetInformation[ofAsset]; // Sets exists boolean to false\r\n        delete registeredAssets[assetIndex];\r\n        for (uint i = assetIndex; i < registeredAssets.length-1; i++) {\r\n            registeredAssets[i] = registeredAssets[i+1];\r\n        }\r\n        registeredAssets.length--;\r\n        assert(!assetInformation[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofExchange address for which specific information is requested\r\n    /// @param exchangeIndex index of the exchange in array\r\n    function removeExchange(\r\n        address ofExchange,\r\n        uint exchangeIndex\r\n    )\r\n        auth\r\n        pre_cond(exchangeInformation[ofExchange].exists)\r\n    {\r\n        require(registeredExchanges[exchangeIndex] == ofExchange);\r\n        delete exchangeInformation[ofExchange];\r\n        delete registeredExchanges[exchangeIndex];\r\n        for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {\r\n            registeredExchanges[i] = registeredExchanges[i+1];\r\n        }\r\n        registeredExchanges.length--;\r\n        assert(!exchangeInformation[ofExchange].exists);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // get asset specific information\r\n    function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }\r\n    function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }\r\n    function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }\r\n    function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }\r\n    function getRegisteredAssets() view returns (address[]) { return registeredAssets; }\r\n    function assetMethodIsAllowed(\r\n        address ofAsset, bytes4 querySignature\r\n    )\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == querySignature) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // get exchange-specific information\r\n    function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }\r\n    function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }\r\n    function getExchangeInformation(address ofExchange)\r\n        view\r\n        returns (address, bool)\r\n    {\r\n        Exchange exchange = exchangeInformation[ofExchange];\r\n        return (\r\n            exchange.adapter,\r\n            exchange.takesCustody\r\n        );\r\n    }\r\n    function getExchangeFunctionSignatures(address ofExchange)\r\n        view\r\n        returns (bytes4[])\r\n    {\r\n        return exchangeInformation[ofExchange].functionSignatures;\r\n    }\r\n    function exchangeMethodIsAllowed(\r\n        address ofExchange, bytes4 querySignature\r\n    )\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == querySignature) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\ninterface SimplePriceFeedInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PriceUpdated(bytes32 hash);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function update(address[] ofAssets, uint[] newPrices) external;\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get price feed operation specific information\r\n    function getQuoteAsset() view returns (address);\r\n    function getLastUpdateId() view returns (uint);\r\n    // Get asset specific information as updated in price feed\r\n    function getPrice(address ofAsset) view returns (uint price, uint timestamp);\r\n    function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);\r\n}\r\n\r\ncontract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {\r\n\r\n    // TYPES\r\n    struct Data {\r\n        uint price;\r\n        uint timestamp;\r\n    }\r\n\r\n    // FIELDS\r\n    mapping(address => Data) public assetsToPrices;\r\n\r\n    // Constructor fields\r\n    address public QUOTE_ASSET; // Asset of a portfolio against which all other assets are priced\r\n\r\n    // Contract-level variables\r\n    uint public updateId;        // Update counter for this pricefeed; used as a check during investment\r\n    CanonicalRegistrar public registrar;\r\n    CanonicalPriceFeed public superFeed;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param ofRegistrar Address of canonical registrar\r\n    /// @param ofSuperFeed Address of superfeed\r\n    function SimplePriceFeed(\r\n        address ofRegistrar,\r\n        address ofQuoteAsset,\r\n        address ofSuperFeed\r\n    ) {\r\n        registrar = CanonicalRegistrar(ofRegistrar);\r\n        QUOTE_ASSET = ofQuoteAsset;\r\n        superFeed = CanonicalPriceFeed(ofSuperFeed);\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    /// @param newPrices list of prices for each of the assets\r\n    function update(address[] ofAssets, uint[] newPrices)\r\n        external\r\n        auth\r\n    {\r\n        _updatePrices(ofAssets, newPrices);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get pricefeed specific information\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    /**\r\n    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\r\n    @dev Asset has been registered\r\n    @param ofAsset Asset for which price should be returned\r\n    @return {\r\n      \"price\": \"Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers\",\r\n      \"timestamp\": \"When the asset's price was updated\"\r\n    }\r\n    */\r\n    function getPrice(address ofAsset)\r\n        view\r\n        returns (uint price, uint timestamp)\r\n    {\r\n        Data data = assetsToPrices[ofAsset];\r\n        return (data.price, data.timestamp);\r\n    }\r\n\r\n    /**\r\n    @notice Price of a registered asset in format (bool areRecent, uint[] prices, uint[] decimals)\r\n    @dev Convention for price formatting: mul(price, 10 ** decimal), to avoid floating numbers\r\n    @param ofAssets Assets for which prices should be returned\r\n    @return {\r\n        \"prices\":       \"Array of prices\",\r\n        \"timestamps\":   \"Array of timestamps\",\r\n    }\r\n    */\r\n    function getPrices(address[] ofAssets)\r\n        view\r\n        returns (uint[], uint[])\r\n    {\r\n        uint[] memory prices = new uint[](ofAssets.length);\r\n        uint[] memory timestamps = new uint[](ofAssets.length);\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            var (price, timestamp) = getPrice(ofAssets[i]);\r\n            prices[i] = price;\r\n            timestamps[i] = timestamp;\r\n        }\r\n        return (prices, timestamps);\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @dev Internal so that feeds inheriting this one are not obligated to have an exposed update(...) method, but can still perform updates\r\n    function _updatePrices(address[] ofAssets, uint[] newPrices)\r\n        internal\r\n        pre_cond(ofAssets.length == newPrices.length)\r\n    {\r\n        updateId++;\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            require(registrar.assetIsRegistered(ofAssets[i]));\r\n            require(assetsToPrices[ofAssets[i]].timestamp != now); // prevent two updates in one block\r\n            assetsToPrices[ofAssets[i]].timestamp = now;\r\n            assetsToPrices[ofAssets[i]].price = newPrices[i];\r\n        }\r\n        emit PriceUpdated(keccak256(ofAssets, newPrices));\r\n    }\r\n}\r\n\r\ncontract StakingPriceFeed is SimplePriceFeed {\r\n\r\n    OperatorStaking public stakingContract;\r\n    AssetInterface public stakingToken;\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param ofRegistrar Address of canonical registrar\r\n    /// @param ofSuperFeed Address of superfeed\r\n    function StakingPriceFeed(\r\n        address ofRegistrar,\r\n        address ofQuoteAsset,\r\n        address ofSuperFeed\r\n    )\r\n        SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)\r\n    {\r\n        stakingContract = OperatorStaking(ofSuperFeed); // canonical feed *is* staking contract\r\n        stakingToken = AssetInterface(stakingContract.stakingToken());\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @param amount Number of tokens to stake for this feed\r\n    /// @param data Data may be needed for some future applications (can be empty for now)\r\n    function depositStake(uint amount, bytes data)\r\n        external\r\n        auth\r\n    {\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n        require(stakingToken.approve(stakingContract, amount));\r\n        stakingContract.stake(amount, data);\r\n    }\r\n\r\n    /// @param amount Number of tokens to unstake for this feed\r\n    /// @param data Data may be needed for some future applications (can be empty for now)\r\n    function unstake(uint amount, bytes data)\r\n        external\r\n        auth\r\n    {\r\n        stakingContract.unstake(amount, data);\r\n    }\r\n\r\n    function withdrawStake()\r\n        external\r\n        auth\r\n    {\r\n        uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));\r\n        stakingContract.withdrawStake();\r\n        require(stakingToken.transfer(msg.sender, amountToWithdraw));\r\n    }\r\n}\r\n\r\ninterface RiskMgmtInterface {\r\n\r\n    // METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks if the makeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If makeOrder is permitted\r\n    function isMakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks if the takeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If takeOrder is permitted\r\n    function isTakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ncontract OperatorStaking is DBC {\r\n\r\n    // EVENTS\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event StakeBurned(address indexed user, uint256 amount, bytes data);\r\n\r\n    // TYPES\r\n\r\n    struct StakeData {\r\n        uint amount;\r\n        address staker;\r\n    }\r\n\r\n    // Circular linked list\r\n    struct Node {\r\n        StakeData data;\r\n        uint prev;\r\n        uint next;\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // INTERNAL FIELDS\r\n    Node[] internal stakeNodes; // Sorted circular linked list nodes containing stake data (Built on top https://programtheblockchain.com/posts/2018/03/30/storage-patterns-doubly-linked-list/)\r\n\r\n    // PUBLIC FIELDS\r\n    uint public minimumStake;\r\n    uint public numOperators;\r\n    uint public withdrawalDelay;\r\n    mapping (address => bool) public isRanked;\r\n    mapping (address => uint) public latestUnstakeTime;\r\n    mapping (address => uint) public stakeToWithdraw;\r\n    mapping (address => uint) public stakedAmounts;\r\n    uint public numStakers; // Current number of stakers (Needed because of array holes)\r\n    AssetInterface public stakingToken;\r\n\r\n    // TODO: consider renaming \"operator\" depending on how this is implemented\r\n    //  (i.e. is pricefeed staking itself?)\r\n    function OperatorStaking(\r\n        AssetInterface _stakingToken,\r\n        uint _minimumStake,\r\n        uint _numOperators,\r\n        uint _withdrawalDelay\r\n    )\r\n        public\r\n    {\r\n        require(address(_stakingToken) != address(0));\r\n        stakingToken = _stakingToken;\r\n        minimumStake = _minimumStake;\r\n        numOperators = _numOperators;\r\n        withdrawalDelay = _withdrawalDelay;\r\n        StakeData memory temp = StakeData({ amount: 0, staker: address(0) });\r\n        stakeNodes.push(Node(temp, 0, 0));\r\n    }\r\n\r\n    // METHODS : STAKING\r\n\r\n    function stake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n        pre_cond(amount >= minimumStake)\r\n    {\r\n        stakedAmounts[msg.sender] += amount;\r\n        updateStakerRanking(msg.sender);\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n\r\n    function unstake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n    {\r\n        uint preStake = stakedAmounts[msg.sender];\r\n        uint postStake = preStake - amount;\r\n        require(postStake >= minimumStake || postStake == 0);\r\n        require(stakedAmounts[msg.sender] >= amount);\r\n        latestUnstakeTime[msg.sender] = block.timestamp;\r\n        stakedAmounts[msg.sender] -= amount;\r\n        stakeToWithdraw[msg.sender] += amount;\r\n        updateStakerRanking(msg.sender);\r\n        emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);\r\n    }\r\n\r\n    function withdrawStake()\r\n        public\r\n        pre_cond(stakeToWithdraw[msg.sender] > 0)\r\n        pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)\r\n    {\r\n        uint amount = stakeToWithdraw[msg.sender];\r\n        stakeToWithdraw[msg.sender] = 0;\r\n        require(stakingToken.transfer(msg.sender, amount));\r\n    }\r\n\r\n    // VIEW FUNCTIONS\r\n\r\n    function isValidNode(uint id) view returns (bool) {\r\n        // 0 is a sentinel and therefore invalid.\r\n        // A valid node is the head or has a previous node.\r\n        return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);\r\n    }\r\n\r\n    function searchNode(address staker) view returns (uint) {\r\n        uint current = stakeNodes[0].next;\r\n        while (isValidNode(current)) {\r\n            if (staker == stakeNodes[current].data.staker) {\r\n                return current;\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function isOperator(address user) view returns (bool) {\r\n        address[] memory operators = getOperators();\r\n        for (uint i; i < operators.length; i++) {\r\n            if (operators[i] == user) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getOperators()\r\n        view\r\n        returns (address[])\r\n    {\r\n        uint arrLength = (numOperators > numStakers) ?\r\n            numStakers :\r\n            numOperators;\r\n        address[] memory operators = new address[](arrLength);\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < arrLength; i++) {\r\n            operators[i] = stakeNodes[current].data.staker;\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return operators;\r\n    }\r\n\r\n    function getStakersAndAmounts()\r\n        view\r\n        returns (address[], uint[])\r\n    {\r\n        address[] memory stakers = new address[](numStakers);\r\n        uint[] memory amounts = new uint[](numStakers);\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < numStakers; i++) {\r\n            stakers[i] = stakeNodes[current].data.staker;\r\n            amounts[i] = stakeNodes[current].data.amount;\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return (stakers, amounts);\r\n    }\r\n\r\n    function totalStakedFor(address user)\r\n        view\r\n        returns (uint)\r\n    {\r\n        return stakedAmounts[user];\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    // DOUBLY-LINKED LIST\r\n\r\n    function insertNodeSorted(uint amount, address staker) internal returns (uint) {\r\n        uint current = stakeNodes[0].next;\r\n        if (current == 0) return insertNodeAfter(0, amount, staker);\r\n        while (isValidNode(current)) {\r\n            if (amount > stakeNodes[current].data.amount) {\r\n                break;\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return insertNodeBefore(current, amount, staker);\r\n    }\r\n\r\n    function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {\r\n\r\n        // 0 is allowed here to insert at the beginning.\r\n        require(id == 0 || isValidNode(id));\r\n\r\n        Node storage node = stakeNodes[id];\r\n\r\n        stakeNodes.push(Node({\r\n            data: StakeData(amount, staker),\r\n            prev: id,\r\n            next: node.next\r\n        }));\r\n\r\n        newID = stakeNodes.length - 1;\r\n\r\n        stakeNodes[node.next].prev = newID;\r\n        node.next = newID;\r\n        numStakers++;\r\n    }\r\n\r\n    function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {\r\n        return insertNodeAfter(stakeNodes[id].prev, amount, staker);\r\n    }\r\n\r\n    function removeNode(uint id) internal {\r\n        require(isValidNode(id));\r\n\r\n        Node storage node = stakeNodes[id];\r\n\r\n        stakeNodes[node.next].prev = node.prev;\r\n        stakeNodes[node.prev].next = node.next;\r\n\r\n        delete stakeNodes[id];\r\n        numStakers--;\r\n    }\r\n\r\n    // UPDATING OPERATORS\r\n\r\n    function updateStakerRanking(address _staker) internal {\r\n        uint newStakedAmount = stakedAmounts[_staker];\r\n        if (newStakedAmount == 0) {\r\n            isRanked[_staker] = false;\r\n            removeStakerFromArray(_staker);\r\n        } else if (isRanked[_staker]) {\r\n            removeStakerFromArray(_staker);\r\n            insertNodeSorted(newStakedAmount, _staker);\r\n        } else {\r\n            isRanked[_staker] = true;\r\n            insertNodeSorted(newStakedAmount, _staker);\r\n        }\r\n    }\r\n\r\n    function removeStakerFromArray(address _staker) internal {\r\n        uint id = searchNode(_staker);\r\n        require(id > 0);\r\n        removeNode(id);\r\n    }\r\n\r\n}\r\n\r\ncontract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {\r\n\r\n    // EVENTS\r\n    event SetupPriceFeed(address ofPriceFeed);\r\n\r\n    struct HistoricalPrices {\r\n        address[] assets;\r\n        uint[] prices;\r\n        uint timestamp;\r\n    }\r\n\r\n    // FIELDS\r\n    bool public updatesAreAllowed = true;\r\n    uint public minimumPriceCount = 1;\r\n    uint public VALIDITY;\r\n    uint public INTERVAL;\r\n    mapping (address => bool) public isStakingFeed; // If the Staking Feed has been created through this contract\r\n    HistoricalPrices[] public priceHistory;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Define and register a quote asset against which all prices are measured/based against\r\n    /// @param ofStakingAsset Address of staking asset (may or may not be quoteAsset)\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param quoteAssetName Name of quote asset\r\n    /// @param quoteAssetSymbol Symbol for quote asset\r\n    /// @param quoteAssetDecimals Decimal places for quote asset\r\n    /// @param quoteAssetUrl URL related to quote asset\r\n    /// @param quoteAssetIpfsHash IPFS hash associated with quote asset\r\n    /// @param quoteAssetBreakInBreakOut Break-in/break-out for quote asset on destination chain\r\n    /// @param quoteAssetStandards EIP standards quote asset adheres to\r\n    /// @param quoteAssetFunctionSignatures Whitelisted functions of quote asset contract\r\n    // /// @param interval Number of seconds between pricefeed updates (this interval is not enforced on-chain, but should be followed by the datafeed maintainer)\r\n    // /// @param validity Number of seconds that datafeed update information is valid for\r\n    /// @param ofGovernance Address of contract governing the Canonical PriceFeed\r\n    function CanonicalPriceFeed(\r\n        address ofStakingAsset,\r\n        address ofQuoteAsset, // Inital entry in asset registrar contract is Melon (QUOTE_ASSET)\r\n        bytes32 quoteAssetName,\r\n        bytes8 quoteAssetSymbol,\r\n        uint quoteAssetDecimals,\r\n        string quoteAssetUrl,\r\n        string quoteAssetIpfsHash,\r\n        address[2] quoteAssetBreakInBreakOut,\r\n        uint[] quoteAssetStandards,\r\n        bytes4[] quoteAssetFunctionSignatures,\r\n        uint[2] updateInfo, // interval, validity\r\n        uint[3] stakingInfo, // minStake, numOperators, unstakeDelay\r\n        address ofGovernance\r\n    )\r\n        OperatorStaking(\r\n            AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]\r\n        )\r\n        SimplePriceFeed(address(this), ofQuoteAsset, address(0))\r\n    {\r\n        registerAsset(\r\n            ofQuoteAsset,\r\n            quoteAssetName,\r\n            quoteAssetSymbol,\r\n            quoteAssetDecimals,\r\n            quoteAssetUrl,\r\n            quoteAssetIpfsHash,\r\n            quoteAssetBreakInBreakOut,\r\n            quoteAssetStandards,\r\n            quoteAssetFunctionSignatures\r\n        );\r\n        INTERVAL = updateInfo[0];\r\n        VALIDITY = updateInfo[1];\r\n        setOwner(ofGovernance);\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @notice Create a new StakingPriceFeed\r\n    function setupStakingPriceFeed() external {\r\n        address ofStakingPriceFeed = new StakingPriceFeed(\r\n            address(this),\r\n            stakingToken,\r\n            address(this)\r\n        );\r\n        isStakingFeed[ofStakingPriceFeed] = true;\r\n        StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);\r\n        emit SetupPriceFeed(ofStakingPriceFeed);\r\n    }\r\n\r\n    /// @dev override inherited update function to prevent manual update from authority\r\n    function update(address[] ofAssets, uint[] newPrices) external { revert(); }\r\n\r\n    /// @dev Burn state for a pricefeed operator\r\n    /// @param user Address of pricefeed operator to burn the stake from\r\n    function burnStake(address user)\r\n        external\r\n        auth\r\n    {\r\n        uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);\r\n        stakedAmounts[user] = 0;\r\n        stakeToWithdraw[user] = 0;\r\n        updateStakerRanking(user);\r\n        emit StakeBurned(user, totalToBurn, \"\");\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    // STAKING\r\n\r\n    function stake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n        pre_cond(isStakingFeed[msg.sender])\r\n    {\r\n        OperatorStaking.stake(amount, data);\r\n    }\r\n\r\n    // function stakeFor(\r\n    //     address user,\r\n    //     uint amount,\r\n    //     bytes data\r\n    // )\r\n    //     public\r\n    //     pre_cond(isStakingFeed[user])\r\n    // {\r\n\r\n    //     OperatorStaking.stakeFor(user, amount, data);\r\n    // }\r\n\r\n    // AGGREGATION\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    function collectAndUpdate(address[] ofAssets)\r\n        public\r\n        auth\r\n        pre_cond(updatesAreAllowed)\r\n    {\r\n        uint[] memory newPrices = pricesToCommit(ofAssets);\r\n        priceHistory.push(\r\n            HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})\r\n        );\r\n        _updatePrices(ofAssets, newPrices);\r\n    }\r\n\r\n    function pricesToCommit(address[] ofAssets)\r\n        view\r\n        returns (uint[])\r\n    {\r\n        address[] memory operators = getOperators();\r\n        uint[] memory newPrices = new uint[](ofAssets.length);\r\n        for (uint i = 0; i < ofAssets.length; i++) {\r\n            uint[] memory assetPrices = new uint[](operators.length);\r\n            for (uint j = 0; j < operators.length; j++) {\r\n                SimplePriceFeed feed = SimplePriceFeed(operators[j]);\r\n                var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);\r\n                if (now > add(timestamp, VALIDITY)) {\r\n                    continue; // leaves a zero in the array (dealt with later)\r\n                }\r\n                assetPrices[j] = price;\r\n            }\r\n            newPrices[i] = medianize(assetPrices);\r\n        }\r\n        return newPrices;\r\n    }\r\n\r\n    /// @dev from MakerDao medianizer contract\r\n    function medianize(uint[] unsorted)\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint numValidEntries;\r\n        for (uint i = 0; i < unsorted.length; i++) {\r\n            if (unsorted[i] != 0) {\r\n                numValidEntries++;\r\n            }\r\n        }\r\n        if (numValidEntries < minimumPriceCount) {\r\n            revert();\r\n        }\r\n        uint counter;\r\n        uint[] memory out = new uint[](numValidEntries);\r\n        for (uint j = 0; j < unsorted.length; j++) {\r\n            uint item = unsorted[j];\r\n            if (item != 0) {    // skip zero (invalid) entries\r\n                if (counter == 0 || item >= out[counter - 1]) {\r\n                    out[counter] = item;  // item is larger than last in array (we are home)\r\n                } else {\r\n                    uint k = 0;\r\n                    while (item >= out[k]) {\r\n                        k++;  // get to where element belongs (between smaller and larger items)\r\n                    }\r\n                    for (uint m = counter; m > k; m--) {\r\n                        out[m] = out[m - 1];    // bump larger elements rightward to leave slot\r\n                    }\r\n                    out[k] = item;\r\n                }\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        uint value;\r\n        if (counter % 2 == 0) {\r\n            uint value1 = uint(out[(counter / 2) - 1]);\r\n            uint value2 = uint(out[(counter / 2)]);\r\n            value = add(value1, value2) / 2;\r\n        } else {\r\n            value = out[(counter - 1) / 2];\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }\r\n    function enableUpdates() auth { updatesAreAllowed = true; }\r\n    function disableUpdates() auth { updatesAreAllowed = false; }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // FEED INFORMATION\r\n\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getInterval() view returns (uint) { return INTERVAL; }\r\n    function getValidity() view returns (uint) { return VALIDITY; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    // PRICES\r\n\r\n    /// @notice Whether price of asset has been updated less than VALIDITY seconds ago\r\n    /// @param ofAsset Asset in registrar\r\n    /// @return isRecent Price information ofAsset is recent\r\n    function hasRecentPrice(address ofAsset)\r\n        view\r\n        pre_cond(assetIsRegistered(ofAsset))\r\n        returns (bool isRecent)\r\n    {\r\n        var ( , timestamp) = getPrice(ofAsset);\r\n        return (sub(now, timestamp) <= VALIDITY);\r\n    }\r\n\r\n    /// @notice Whether prices of assets have been updated less than VALIDITY seconds ago\r\n    /// @param ofAssets All assets in registrar\r\n    /// @return isRecent Price information ofAssets array is recent\r\n    function hasRecentPrices(address[] ofAssets)\r\n        view\r\n        returns (bool areRecent)\r\n    {\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            if (!hasRecentPrice(ofAssets[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getPriceInfo(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint price, uint assetDecimals)\r\n    {\r\n        isRecent = hasRecentPrice(ofAsset);\r\n        (price, ) = getPrice(ofAsset);\r\n        assetDecimals = getDecimals(ofAsset);\r\n    }\r\n\r\n    /**\r\n    @notice Gets inverted price of an asset\r\n    @dev Asset has been initialised and its price is non-zero\r\n    @dev Existing price ofAssets quoted in QUOTE_ASSET (convention)\r\n    @param ofAsset Asset for which inverted price should be return\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"invertedPrice\": \"Price based (instead of quoted) against QUOTE_ASSET\",\r\n        \"assetDecimals\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getInvertedPriceInfo(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint invertedPrice, uint assetDecimals)\r\n    {\r\n        uint inputPrice;\r\n        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);\r\n\r\n        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\r\n        uint quoteDecimals = getDecimals(QUOTE_ASSET);\r\n\r\n        return (\r\n            isRecent,\r\n            mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,\r\n            quoteDecimals   // TODO: check on this; shouldn't it be assetDecimals?\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice Gets reference price of an asset pair\r\n    @dev One of the address is equal to quote asset\r\n    @dev either ofBase == QUOTE_ASSET or ofQuote == QUOTE_ASSET\r\n    @param ofBase Address of base asset\r\n    @param ofQuote Address of quote asset\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"referencePrice\": \"Reference price\",\r\n        \"decimal\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getReferencePriceInfo(address ofBase, address ofQuote)\r\n        view\r\n        returns (bool isRecent, uint referencePrice, uint decimal)\r\n    {\r\n        if (getQuoteAsset() == ofQuote) {\r\n            (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);\r\n        } else if (getQuoteAsset() == ofBase) {\r\n            (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);\r\n        } else {\r\n            revert(); // no suitable reference price available\r\n        }\r\n    }\r\n\r\n    /// @notice Gets price of Order\r\n    /// @param sellAsset Address of the asset to be sold\r\n    /// @param buyAsset Address of the asset to be bought\r\n    /// @param sellQuantity Quantity in base units being sold of sellAsset\r\n    /// @param buyQuantity Quantity in base units being bought of buyAsset\r\n    /// @return orderPrice Price as determined by an order\r\n    function getOrderPriceInfo(\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        view\r\n        returns (uint orderPrice)\r\n    {\r\n        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\r\n    }\r\n\r\n    /// @notice Checks whether data exists for a given asset pair\r\n    /// @dev Prices are only upated against QUOTE_ASSET\r\n    /// @param sellAsset Asset for which check to be done if data exists\r\n    /// @param buyAsset Asset for which check to be done if data exists\r\n    /// @return Whether assets exist for given asset pair\r\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\r\n        view\r\n        returns (bool isExistent)\r\n    {\r\n        return\r\n            hasRecentPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            hasRecentPrice(buyAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) && // One asset must be QUOTE_ASSET\r\n            (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET); // Pair must consists of diffrent assets\r\n    }\r\n\r\n    /// @return Sparse array of addresses of owned pricefeeds\r\n    function getPriceFeedsByOwner(address _owner)\r\n        view\r\n        returns(address[])\r\n    {\r\n        address[] memory ofPriceFeeds = new address[](numStakers);\r\n        if (numStakers == 0) return ofPriceFeeds;\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < numStakers; i++) {\r\n            StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);\r\n            if (stakingFeed.owner() == _owner) {\r\n                ofPriceFeeds[i] = address(stakingFeed);\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return ofPriceFeeds;\r\n    }\r\n\r\n    function getHistoryLength() returns (uint) { return priceHistory.length; }\r\n\r\n    function getHistoryAt(uint id) returns (address[], uint[], uint) {\r\n        address[] memory assets = priceHistory[id].assets;\r\n        uint[] memory prices = priceHistory[id].prices;\r\n        uint timestamp = priceHistory[id].timestamp;\r\n        return (assets, prices, timestamp);\r\n    }\r\n}\r\n\r\ninterface VersionInterface {\r\n\r\n    // EVENTS\r\n\r\n    event FundUpdated(uint id);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function shutDown() external;\r\n\r\n    function setupFund(\r\n        bytes32 ofFundName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address[] ofExchanges,\r\n        address[] ofDefaultAssets,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n    function shutDownFund(address ofFund);\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getNativeAsset() view returns (address);\r\n    function getFundById(uint withId) view returns (address);\r\n    function getLastFundId() view returns (uint);\r\n    function getFundByManager(address ofManager) view returns (address);\r\n    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\r\n\r\n}\r\n\r\ncontract Version is DBC, Owned, VersionInterface {\r\n    // FIELDS\r\n\r\n    bytes32 public constant TERMS_AND_CONDITIONS = 0xAA9C907B0D6B4890E7225C09CBC16A01CB97288840201AA7CDCB27F4ED7BF159; // Hashed terms and conditions as displayed on IPFS, decoded from base 58\r\n\r\n    // Constructor fields\r\n    string public VERSION_NUMBER; // SemVer of Melon protocol version\r\n    address public MELON_ASSET; // Address of Melon asset contract\r\n    address public NATIVE_ASSET; // Address of Fixed quote asset\r\n    address public GOVERNANCE; // Address of Melon protocol governance contract\r\n    address public CANONICAL_PRICEFEED; // Address of the canonical pricefeed\r\n\r\n    // Methods fields\r\n    bool public isShutDown; // Governance feature, if yes than setupFund gets blocked and shutDownFund gets opened\r\n    address public COMPLIANCE; // restrict to Competition compliance module for this version\r\n    address[] public listOfFunds; // A complete list of fund addresses created using this version\r\n    mapping (address => address) public managerToFunds; // Links manager address to fund address created using this version\r\n\r\n    // EVENTS\r\n\r\n    event FundUpdated(address ofFund);\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param versionNumber SemVer of Melon protocol version\r\n    /// @param ofGovernance Address of Melon governance contract\r\n    /// @param ofMelonAsset Address of Melon asset contract\r\n    function Version(\r\n        string versionNumber,\r\n        address ofGovernance,\r\n        address ofMelonAsset,\r\n        address ofNativeAsset,\r\n        address ofCanonicalPriceFeed,\r\n        address ofCompetitionCompliance\r\n    ) {\r\n        VERSION_NUMBER = versionNumber;\r\n        GOVERNANCE = ofGovernance;\r\n        MELON_ASSET = ofMelonAsset;\r\n        NATIVE_ASSET = ofNativeAsset;\r\n        CANONICAL_PRICEFEED = ofCanonicalPriceFeed;\r\n        COMPLIANCE = ofCompetitionCompliance;\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    function shutDown() external pre_cond(msg.sender == GOVERNANCE) { isShutDown = true; }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @param ofFundName human-readable descriptive name (not necessarily unique)\r\n    /// @param ofQuoteAsset Asset against which performance fee is measured against\r\n    /// @param ofManagementFee A time based fee, given in a number which is divided by 10 ** 15\r\n    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 10 ** 15\r\n    /// @param ofCompliance Address of participation module\r\n    /// @param ofRiskMgmt Address of risk management module\r\n    /// @param ofExchanges Addresses of exchange on which this fund can trade\r\n    /// @param ofDefaultAssets Enable invest/redeem with these assets (quote asset already enabled)\r\n    /// @param v ellipitc curve parameter v\r\n    /// @param r ellipitc curve parameter r\r\n    /// @param s ellipitc curve parameter s\r\n    function setupFund(\r\n        bytes32 ofFundName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address[] ofExchanges,\r\n        address[] ofDefaultAssets,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) {\r\n        require(!isShutDown);\r\n        require(termsAndConditionsAreSigned(v, r, s));\r\n        require(CompetitionCompliance(COMPLIANCE).isCompetitionAllowed(msg.sender));\r\n        require(managerToFunds[msg.sender] == address(0)); // Add limitation for simpler migration process of shutting down and setting up fund\r\n        address[] memory melonAsDefaultAsset = new address[](1);\r\n        melonAsDefaultAsset[0] = MELON_ASSET; // Melon asset should be in default assets\r\n        address ofFund = new Fund(\r\n            msg.sender,\r\n            ofFundName,\r\n            NATIVE_ASSET,\r\n            0,\r\n            0,\r\n            COMPLIANCE,\r\n            ofRiskMgmt,\r\n            CANONICAL_PRICEFEED,\r\n            ofExchanges,\r\n            melonAsDefaultAsset\r\n        );\r\n        listOfFunds.push(ofFund);\r\n        managerToFunds[msg.sender] = ofFund;\r\n        emit FundUpdated(ofFund);\r\n    }\r\n\r\n    /// @dev Dereference Fund and shut it down\r\n    /// @param ofFund Address of the fund to be shut down\r\n    function shutDownFund(address ofFund)\r\n        pre_cond(isShutDown || managerToFunds[msg.sender] == ofFund)\r\n    {\r\n        Fund fund = Fund(ofFund);\r\n        delete managerToFunds[msg.sender];\r\n        fund.shutDown();\r\n        emit FundUpdated(ofFund);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @dev Proof that terms and conditions have been read and understood\r\n    /// @param v ellipitc curve parameter v\r\n    /// @param r ellipitc curve parameter r\r\n    /// @param s ellipitc curve parameter s\r\n    /// @return signed Whether or not terms and conditions have been read and understood\r\n    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) {\r\n        return ecrecover(\r\n            // Parity does prepend \\x19Ethereum Signed Message:\\n{len(message)} before signing.\r\n            //  Signature order has also been changed in 1.6.7 and upcoming 1.7.x,\r\n            //  it will return rsv (same as geth; where v is [27, 28]).\r\n            // Note that if you are using ecrecover, v will be either \"00\" or \"01\".\r\n            //  As a result, in order to use this value, you will have to parse it to an\r\n            //  integer and then add 27. This will result in either a 27 or a 28.\r\n            //  https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsign\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", TERMS_AND_CONDITIONS),\r\n            v,\r\n            r,\r\n            s\r\n        ) == msg.sender; // Has sender signed TERMS_AND_CONDITIONS\r\n    }\r\n\r\n    function getNativeAsset() view returns (address) { return NATIVE_ASSET; }\r\n    function getFundById(uint withId) view returns (address) { return listOfFunds[withId]; }\r\n    function getLastFundId() view returns (uint) { return listOfFunds.length - 1; }\r\n    function getFundByManager(address ofManager) view returns (address) { return managerToFunds[ofManager]; }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"TERMS_AND_CONDITIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredFundToRegistrants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"address\"}],\"name\":\"getRegistrantId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRegistrants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"address\"}],\"name\":\"getRegistrantFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxBuyinQuantity\",\"type\":\"uint256\"},{\"name\":\"whitelistants\",\"type\":\"address[]\"}],\"name\":\"batchAddToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeTillEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawMln\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"custodian\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeMoneyAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payin\",\"type\":\"uint256\"}],\"name\":\"calculatePayout\",\"outputs\":[{\"name\":\"payoutQuantity\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMelonAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCompetitionActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPETITION_VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistantToMaxBuyin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registrants\",\"outputs\":[{\"name\":\"fund\",\"type\":\"address\"},{\"name\":\"registrant\",\"type\":\"address\"},{\"name\":\"hasSigned\",\"type\":\"bool\"},{\"name\":\"buyinQuantity\",\"type\":\"uint256\"},{\"name\":\"payoutQuantity\",\"type\":\"uint256\"},{\"name\":\"isRewarded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMaxBuyin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeMoneyQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MELON_ASSET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MELON_BASE_UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTotalBuyin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofNewOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCompetitionStatusOfRegistrants\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MELON_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"byManager\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"termsAndConditionsAreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"registerForCompetition\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getEtherValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registrantToRegistrantIds\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ofMelonAsset\",\"type\":\"address\"},{\"name\":\"ofCompetitionVersion\",\"type\":\"address\"},{\"name\":\"ofCustodian\",\"type\":\"address\"},{\"name\":\"ofStartTime\",\"type\":\"uint256\"},{\"name\":\"ofEndTime\",\"type\":\"uint256\"},{\"name\":\"ofPayoutRate\",\"type\":\"uint256\"},{\"name\":\"ofTotalMaxBuyin\",\"type\":\"uint256\"},{\"name\":\"ofMaxRegistrants\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"registrant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"}]","ContractName":"Competition","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000beb9ef514a379b997e0798fdcc901ee474b6d9a1000000000000000000000000b81f5b60e186cf84ab21e43064b4defd77e96d4d0000000000000000000000000d580ae50b58fe08514deab4e38c0dfdb0d30adc000000000000000000000000000000000000000000000000000000005b3a7fb4000000000000000000000000000000000000000000000000000000005bbe55b4000000000000000000000000000000000000000000000001158e460913d0000000000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000000000000000000000003e8","Library":"","SwarmSource":"bzzr://6d4dfae843dc64432e6fc1bf6f4299038782bfdf945c5217bbd6f09bd51d2b7b"}]}