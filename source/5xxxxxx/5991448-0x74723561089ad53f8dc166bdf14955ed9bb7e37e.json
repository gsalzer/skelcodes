{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\nlibrary AddressUtils {\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        // solium-disable-line security/no-inline-assembly\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC721Receiver {\r\n    function onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\ncontract ERC721BasicToken {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    using SafeMath for uint256;\r\n    using AddressUtils for address;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) internal tokenOwner;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) internal ownedTokensCount;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721TokenReceiver =\r\n        bytes4(keccak256('onERC721Received(address,uint256,bytes)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) ^\r\n        bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n        bytes4(keccak256('getApproved(uint256)')) ^\r\n        bytes4(keccak256('isApprovedForAll(address,address)'));\r\n\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        require(tokenOwner[_tokenId] == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        require(\r\n            tokenOwner[_tokenId] == msg.sender\r\n            || tokenApprovals[_tokenId] == msg.sender\r\n            || operatorApprovals[tokenOwner[_tokenId]][msg.sender]\r\n        );\r\n        _;\r\n    }\r\n\r\n    //  We implement ERC721 here\r\n    function supportsInterface(bytes4 _interfaceID) public pure returns (bool)\r\n    {\r\n        return (\r\n          (_interfaceID == InterfaceSignature_ERC165)\r\n          || (_interfaceID == InterfaceSignature_ERC721)\r\n        );\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        //require(_owner != address(0));\r\n        return ownedTokensCount[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        //require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        transferFrom(_from, _to, _tokenId);\r\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        canTransfer(_tokenId)\r\n    {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) external {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_approved != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        if (getApproved(_tokenId) != address(0) || _approved != address(0)) {\r\n            tokenApprovals[_tokenId] = _approved;\r\n            emit Approval(owner, _approved, _tokenId);\r\n        }\r\n    }\r\n\r\n    function setApprovalForAll(address _to, bool _approved) external {\r\n        require(_to != msg.sender);\r\n        operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll\r\n    (\r\n        address _owner,\r\n        address _operator\r\n    )\r\n        public view returns (bool)\r\n    {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n            emit Approval(_owner, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require(tokenOwner[_tokenId] == address(0));\r\n        tokenOwner[_tokenId] = _to;\r\n        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n    }\r\n\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _from);\r\n        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n        tokenOwner[_tokenId] = address(0);\r\n    }\r\n\r\n    function checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (!_to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\r\n        return (retval == InterfaceSignature_ERC721TokenReceiver);\r\n    }\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        clearApproval(_owner, _tokenId);\r\n        removeTokenFrom(_owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n    }\r\n}\r\n\r\ncontract ERC721Token is ERC721BasicToken{\r\n\r\n    string internal name_;\r\n    string internal symbol_;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] internal allTokens;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) internal tokenURIs;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping (address => uint256[]) internal ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n    bytes4 constant InterfaceSignature_ERC721Metadata =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('tokenURI(uint256)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721Enumerable =\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('tokenByIndex(uint256)')) ^\r\n        bytes4(keccak256('tokenOfOwnerByIndex(address, uint256)'));\r\n\r\n    function ERC721Token(string _name, string _symbol) public {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n    }\r\n\r\n    //  We implement ERC721Metadata(optional) and ERC721Enumerable(optional).\r\n    function supportsInterface(bytes4 _interfaceID) public pure returns (bool)\r\n    {\r\n        return (\r\n            super.supportsInterface(_interfaceID)\r\n            || (_interfaceID == InterfaceSignature_ERC721Metadata)\r\n            || (_interfaceID == InterfaceSignature_ERC721Enumerable)\r\n        );\r\n    }\r\n\r\n    function name() external view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    function symbol() external view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string) {\r\n        return tokenURIs[_tokenId];\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < allTokens.length);\r\n        return allTokens[_index];\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        external view returns (uint256)\r\n    {\r\n        require(_index < balanceOf(_owner));\r\n        return ownedTokens[_owner][_index];\r\n    }\r\n\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        super.addTokenTo(_to, _tokenId);\r\n\r\n        uint256 length = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n        ownedTokensIndex[_tokenId] = length;\r\n    }\r\n\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        super.removeTokenFrom(_from, _tokenId);\r\n\r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        ownedTokens[_from][lastTokenIndex] = 0;\r\n\r\n        ownedTokens[_from].length = ownedTokens[_from].length.sub(1);\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    function _setTokenURI(uint256 _tokenId, string _uri) internal {\r\n        require(ownerOf(_tokenId) != address(0));\r\n        tokenURIs[_tokenId] = _uri;\r\n    }\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        super._mint(_to, _tokenId);\r\n\r\n        allTokensIndex[_tokenId] = allTokens.length;\r\n        allTokens.push(_tokenId);\r\n    }\r\n\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        super._burn(_owner, _tokenId);\r\n\r\n        // Clear metadata (if any)\r\n        if (bytes(tokenURIs[_tokenId]).length != 0) {\r\n            delete tokenURIs[_tokenId];\r\n        }\r\n\r\n        uint256 tokenIndex = allTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = allTokens.length.sub(1);\r\n        uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n        allTokens[tokenIndex] = lastToken;\r\n        allTokens[lastTokenIndex] = 0;\r\n\r\n        allTokens.length = allTokens.length.sub(1);\r\n        allTokensIndex[_tokenId] = 0;\r\n        allTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract HashLand is ERC721Token, owned{\r\n\r\n    function HashLand() ERC721Token(\"HashLand\", \"HSL\") public {}\r\n\r\n    struct LandInfo {\r\n        // Unique key for a land, derived from longitude and latitude\r\n        bytes8 landKey;\r\n        string landName;\r\n\r\n        string ownerNick;\r\n        string landSlogan;\r\n\r\n        bool forSale;\r\n        uint256 sellPrice;\r\n    }\r\n\r\n    mapping(uint256 => bytes8) landKeyOfId;\r\n    mapping(bytes8 => uint256) landIdOfKey;\r\n    mapping(uint256 => LandInfo) landInfoOfId;\r\n\r\n    mapping (address => uint256) pendingWithdrawals;\r\n\r\n    function mintLand(\r\n        address _to,\r\n        bytes8 _landKey,\r\n        string _landName,\r\n        string _ownerNick,\r\n        string _landSlogan,\r\n        string _landURI     // keccak256(landKey)\r\n    )\r\n        public onlyOwner\r\n    {\r\n        require(landIdOfKey[_landKey] == 0);\r\n        uint256 _landId = allTokens.length.add(1);\r\n\r\n        landKeyOfId[_landId] = _landKey;\r\n        landIdOfKey[_landKey] = _landId;\r\n        landInfoOfId[_landId] = LandInfo(\r\n            _landKey, _landName,\r\n            _ownerNick, _landSlogan,\r\n            false, 0\r\n        );\r\n\r\n        _mint(_to, _landId);\r\n        _setTokenURI(_landId, _landURI);\r\n    }\r\n\r\n    function officialTransfer(\r\n        address _to,\r\n        bytes8 _landKey,\r\n        string _landName,\r\n        string _ownerNick,\r\n        string _landSlogan,\r\n        string _landURI     // keccak256(landKey)\r\n    )\r\n        public\r\n    {\r\n        uint256 _landId = landIdOfKey[_landKey];\r\n        if (_landId == 0) {\r\n            require(msg.sender == owner);\r\n            _landId = allTokens.length.add(1);\r\n\r\n            landKeyOfId[_landId] = _landKey;\r\n            landIdOfKey[_landKey] = _landId;\r\n            landInfoOfId[_landId] = LandInfo(\r\n                _landKey, _landName,\r\n                _ownerNick, _landSlogan,\r\n                false, 0\r\n            );\r\n\r\n            _mint(_to, _landId);\r\n            _setTokenURI(_landId, _landURI);\r\n        }\r\n        else {\r\n            require(tokenOwner[_landId] == msg.sender);\r\n            require(_to != address(0));\r\n\r\n            landInfoOfId[_landId].forSale = false;\r\n            landInfoOfId[_landId].sellPrice = 0;\r\n            landInfoOfId[_landId].ownerNick = _ownerNick;\r\n            landInfoOfId[_landId].landSlogan = _landSlogan;\r\n\r\n            clearApproval(msg.sender, _landId);\r\n            removeTokenFrom(msg.sender, _landId);\r\n            addTokenTo(_to, _landId);\r\n\r\n            emit Transfer(msg.sender, _to, _landId);\r\n        }\r\n    }\r\n\r\n\r\n    function burnLand(uint256 _landId) public onlyOwnerOf(_landId){\r\n        bytes8 _landKey = landKeyOfId[_landId];\r\n        require(_landKey != 0);\r\n        landKeyOfId[_landId] = 0x0;\r\n        landIdOfKey[_landKey] = 0;\r\n        delete landInfoOfId[_landId];\r\n\r\n        _burn(msg.sender, _landId);\r\n    }\r\n\r\n    function getLandIdByKey(bytes8 _landKey)\r\n        external view\r\n        returns (uint256)\r\n    {\r\n        return landIdOfKey[_landKey];\r\n    }\r\n\r\n    function getLandInfo(uint256 _landId)\r\n        external view\r\n        returns (bytes8, bool, uint256, string, string, string)\r\n    {\r\n        bytes8 _landKey = landKeyOfId[_landId];\r\n        require(_landKey != 0);\r\n        return (\r\n            _landKey,\r\n            landInfoOfId[_landId].forSale, landInfoOfId[_landId].sellPrice,\r\n            landInfoOfId[_landId].landName,\r\n            landInfoOfId[_landId].ownerNick, landInfoOfId[_landId].landSlogan\r\n        );\r\n    }\r\n\r\n    function setOwnerNick(\r\n        uint256 _landId,\r\n        string _ownerNick\r\n    )\r\n        public\r\n        onlyOwnerOf(_landId)\r\n    {\r\n        landInfoOfId[_landId].ownerNick = _ownerNick;\r\n    }\r\n\r\n    function setLandSlogan(\r\n        uint256 _landId,\r\n        string _landSlogan\r\n    )\r\n        public\r\n        onlyOwnerOf(_landId)\r\n    {\r\n        landInfoOfId[_landId].landSlogan = _landSlogan;\r\n    }\r\n\r\n    function setForSale(\r\n        uint256 _landId,\r\n        bool _forSale,\r\n        uint256 _sellPrice\r\n    )\r\n        public\r\n        onlyOwnerOf(_landId)\r\n    {\r\n        landInfoOfId[_landId].forSale = _forSale;\r\n        landInfoOfId[_landId].sellPrice = _sellPrice;\r\n    }\r\n\r\n    function buyLand(uint256 _landId) payable public {\r\n        bytes8 _landKey = landKeyOfId[_landId];\r\n        require(_landKey != 0);\r\n\r\n        require(landInfoOfId[_landId].forSale == true);\r\n        require(msg.value >= landInfoOfId[_landId].sellPrice);\r\n\r\n        address origin_owner = tokenOwner[_landId];\r\n\r\n        clearApproval(origin_owner, _landId);\r\n        removeTokenFrom(origin_owner, _landId);\r\n        addTokenTo(msg.sender, _landId);\r\n\r\n        landInfoOfId[_landId].forSale = false;\r\n        emit Transfer(origin_owner, msg.sender, _landId);\r\n\r\n        uint256 price = landInfoOfId[_landId].sellPrice;\r\n        uint256 priviousBalance = pendingWithdrawals[origin_owner];\r\n        pendingWithdrawals[origin_owner] = priviousBalance.add(price);\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint256 amount = pendingWithdrawals[msg.sender];\r\n        // Remember to zero the pending refund before\r\n        // sending to prevent re-entrancy attacks\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landId\",\"type\":\"uint256\"}],\"name\":\"burnLand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_landKey\",\"type\":\"bytes8\"},{\"name\":\"_landName\",\"type\":\"string\"},{\"name\":\"_ownerNick\",\"type\":\"string\"},{\"name\":\"_landSlogan\",\"type\":\"string\"},{\"name\":\"_landURI\",\"type\":\"string\"}],\"name\":\"officialTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landId\",\"type\":\"uint256\"},{\"name\":\"_landSlogan\",\"type\":\"string\"}],\"name\":\"setLandSlogan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landId\",\"type\":\"uint256\"}],\"name\":\"getLandInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_landKey\",\"type\":\"bytes8\"}],\"name\":\"getLandIdByKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landId\",\"type\":\"uint256\"},{\"name\":\"_ownerNick\",\"type\":\"string\"}],\"name\":\"setOwnerNick\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_landKey\",\"type\":\"bytes8\"},{\"name\":\"_landName\",\"type\":\"string\"},{\"name\":\"_ownerNick\",\"type\":\"string\"},{\"name\":\"_landSlogan\",\"type\":\"string\"},{\"name\":\"_landURI\",\"type\":\"string\"}],\"name\":\"mintLand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landId\",\"type\":\"uint256\"}],\"name\":\"buyLand\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_landId\",\"type\":\"uint256\"},{\"name\":\"_forSale\",\"type\":\"bool\"},{\"name\":\"_sellPrice\",\"type\":\"uint256\"}],\"name\":\"setForSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"HashLand","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://396b9750a5d94b4abb35180f6ae87bc9728fbb89179defddbc1fdeb8c49a95c6"}]}