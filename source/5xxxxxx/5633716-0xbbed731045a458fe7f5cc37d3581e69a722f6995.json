{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * @dev Supports unlimited numbers of roles and addresses.\r\n * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n *  for you to write your own implementation of this interface using Enums or similar.\r\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\r\n *  to avoid typos.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * @dev This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable, RBAC {\r\n  event WhitelistedAddressAdded(address addr);\r\n  event WhitelistedAddressRemoved(address addr);\r\n\r\n  string public constant ROLE_WHITELISTED = \"whitelist\";\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not whitelisted.\r\n   */\r\n  modifier onlyWhitelisted() {\r\n    checkRole(msg.sender, ROLE_WHITELISTED);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param addr address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address addr)\r\n    onlyOwner\r\n    public\r\n  {\r\n    addRole(addr, ROLE_WHITELISTED);\r\n    emit WhitelistedAddressAdded(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in whitelist\r\n   */\r\n  function whitelist(address addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return hasRole(addr, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] addrs)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      addAddressToWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param addr address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address addr)\r\n    onlyOwner\r\n    public\r\n  {\r\n    removeRole(addr, ROLE_WHITELISTED);\r\n    emit WhitelistedAddressRemoved(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param addrs addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] addrs)\r\n    onlyOwner\r\n    public\r\n  {\r\n    for (uint256 i = 0; i < addrs.length; i++) {\r\n      removeAddressFromWhitelist(addrs[i]);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n\r\ncontract PresaleSecond is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    uint256 public maxcap;      // sale hardcap\r\n    uint256 public exceed;      // indivisual hardcap\r\n    uint256 public minimum;     // indivisual softcap\r\n    uint256 public rate;        // exchange rate\r\n\r\n    bool public paused = false;   // is sale paused?\r\n    bool public ignited = false;  // is sale started?\r\n    uint256 public weiRaised = 0; // check sale status\r\n\r\n    address public wallet;      // wallet for withdrawal\r\n    address public distributor; // contract for release, refund\r\n    Whitelist public List;      // whitelist\r\n    ERC20 public Token;         // token\r\n\r\n    constructor (\r\n        uint256 _maxcap,\r\n        uint256 _exceed,\r\n        uint256 _minimum,\r\n        uint256 _rate,\r\n        address _wallet,\r\n        address _distributor,\r\n        address _whitelist,\r\n        address _token\r\n    )\r\n        public\r\n    {\r\n        require(_wallet != address(0));\r\n        require(_whitelist != address(0));\r\n        require(_distributor != address(0));\r\n        require(_token != address(0));\r\n\r\n        maxcap = _maxcap;\r\n        exceed = _exceed;\r\n        minimum = _minimum;\r\n        rate = _rate;\r\n\r\n        wallet = _wallet;\r\n        distributor = _distributor;\r\n\r\n        Token = ERC20(_token);\r\n        List = Whitelist(_whitelist);\r\n    }\r\n\r\n    /* fallback function */\r\n    function () external payable {\r\n        collect();\r\n    }\r\n\r\n//  address\r\n    event Change(address _addr, string _name);\r\n\r\n    function setWhitelist(address _whitelist) external onlyOwner {\r\n        require(_whitelist != address(0));\r\n\r\n        List = Whitelist(_whitelist);\r\n        emit Change(_whitelist, \"whitelist\");\r\n    }\r\n\r\n    function setDistributor(address _distributor) external onlyOwner {\r\n        require(_distributor != address(0));\r\n\r\n        distributor = _distributor;\r\n        emit Change(_distributor, \"distributor\");\r\n\r\n    }\r\n\r\n    function setWallet(address _wallet) external onlyOwner {\r\n        require(_wallet != address(0));\r\n\r\n        wallet = _wallet;\r\n        emit Change(_wallet, \"wallet\");\r\n    }\r\n\r\n//  sale controller\r\n    event Pause();\r\n    event Resume();\r\n    event Ignite();\r\n    event Extinguish();\r\n\r\n    function pause() external onlyOwner {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function resume() external onlyOwner {\r\n        paused = false;\r\n        emit Resume();\r\n    }\r\n\r\n    function ignite() external onlyOwner {\r\n        ignited = true;\r\n        emit Ignite();\r\n    }\r\n\r\n    function extinguish() external onlyOwner {\r\n        ignited = false;\r\n        emit Extinguish();\r\n    }\r\n\r\n//  collect eth\r\n    event Purchase(address indexed _buyer, uint256 _purchased, uint256 _refund, uint256 _tokens);\r\n\r\n    mapping (address => uint256) public buyers;\r\n\r\n    function collect() public payable {\r\n        address buyer = msg.sender;\r\n        uint256 amount = msg.value;\r\n\r\n        require(ignited && !paused);\r\n        require(List.whitelist(buyer));\r\n        require(buyer != address(0));\r\n        require(buyers[buyer].add(amount) >= minimum);\r\n        require(buyers[buyer] < exceed);\r\n        require(weiRaised < maxcap);\r\n\r\n        uint256 purchase;\r\n        uint256 refund;\r\n\r\n        (purchase, refund) = getPurchaseAmount(buyer, amount);\r\n\r\n        weiRaised = weiRaised.add(purchase);\r\n\r\n        if(weiRaised >= maxcap) ignited = false;\r\n\r\n        buyers[buyer] = buyers[buyer].add(purchase);\r\n        emit Purchase(buyer, purchase, refund, purchase.mul(rate));\r\n\r\n        buyer.transfer(refund);\r\n    }\r\n\r\n//  util functions for collect\r\n    function getPurchaseAmount(address _buyer, uint256 _amount)\r\n        private\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 d1 = maxcap.sub(weiRaised);\r\n        uint256 d2 = exceed.sub(buyers[_buyer]);\r\n\r\n        uint256 d = (d1 > d2) ? d2 : d1;\r\n\r\n        return (_amount > d) ? (d, _amount.sub(d)) : (_amount, 0);\r\n    }\r\n\r\n//  finalize\r\n    bool public finalized = false;\r\n\r\n    function finalize() external onlyOwner {\r\n        require(!ignited && !finalized);\r\n\r\n        withdrawEther();\r\n        withdrawToken();\r\n\r\n        finalized = true;\r\n    }\r\n\r\n//  release & release\r\n    event Release(address indexed _to, uint256 _amount);\r\n    event Refund(address indexed _to, uint256 _amount);\r\n\r\n    function release(address _addr)\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(!ignited && !finalized);\r\n        require(msg.sender == distributor); // only for distributor\r\n        require(_addr != address(0));\r\n\r\n        if(buyers[_addr] == 0) return false;\r\n\r\n        uint256 releaseAmount = buyers[_addr].mul(rate);\r\n        buyers[_addr] = 0;\r\n\r\n        Token.safeTransfer(_addr, releaseAmount);\r\n        emit Release(_addr, releaseAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    // 어떤 모종의 이유로 환불 절차를 밟아야 하는 경우를 상정하여 만들어놓은 안전장치입니다.\r\n    // This exists for safety when we have to run refund process by some reason.\r\n    function refund(address _addr)\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(!ignited && !finalized);\r\n        require(msg.sender == distributor); // only for distributor\r\n        require(_addr != address(0));\r\n\r\n        if(buyers[_addr] == 0) return false;\r\n\r\n        uint256 refundAmount = buyers[_addr];\r\n        buyers[_addr] = 0;\r\n\r\n        _addr.transfer(refundAmount);\r\n        emit Refund(_addr, refundAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n//  withdraw\r\n    event WithdrawToken(address indexed _from, uint256 _amount);\r\n    event WithdrawEther(address indexed _from, uint256 _amount);\r\n\r\n    function withdrawToken() public onlyOwner {\r\n        require(!ignited);\r\n        Token.safeTransfer(wallet, Token.balanceOf(address(this)));\r\n        emit WithdrawToken(wallet, Token.balanceOf(address(this)));\r\n    }\r\n\r\n    function withdrawEther() public onlyOwner {\r\n        require(!ignited);\r\n        wallet.transfer(address(this).balance);\r\n        emit WithdrawEther(wallet, address(this).balance);\r\n    }\r\n}\r\n\r\n\r\ncontract SaleManager is Ownable {\r\n    PresaleSecond public Sale;\r\n\r\n    constructor(address _sale) public {\r\n        require(_sale != address(0));\r\n        Sale = PresaleSecond(_sale);\r\n    }\r\n\r\n    function setSaleAddress(address _addr) external onlyOwner {\r\n        require(_addr != address(0));\r\n        Sale = PresaleSecond(_addr);\r\n    }\r\n\r\n    event Fail(address indexed _addr);\r\n\r\n    function releaseMany(address[] _addrs) external onlyOwner {\r\n        require(_addrs.length < 30);\r\n\r\n        for(uint256 i = 0; i < _addrs.length; i++)\r\n            if (!Sale.release(_addrs[i]))\r\n                emit Fail(_addrs[i]);\r\n    }\r\n\r\n    function refundMany(address[] _addrs) external onlyOwner {\r\n        require(_addrs.length < 30);\r\n\r\n        for(uint256 i = 0; i < _addrs.length; i++)\r\n            if (!Sale.refund(_addrs[i]))\r\n                emit Fail(_addrs[i]);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"refundMany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"releaseMany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setSaleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_sale\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"Fail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SaleManager","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000edc77f347a7dbdba2319e86ef5681535f8da75e0","Library":"","SwarmSource":"bzzr://9bf47d94cce1e23e6507a3a188131d788018418e068dba378ea520a2224a14b0"}]}