{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract BdpBaseData {\r\n\r\n\taddress public ownerAddress;\r\n\r\n\taddress public managerAddress;\r\n\r\n\taddress[16] public contracts;\r\n\r\n\tbool public paused = false;\r\n\r\n\tbool public setupComplete = false;\r\n\r\n\tbytes8 public version;\r\n\r\n}\r\nlibrary BdpContracts {\r\n\r\n\tfunction getBdpEntryPoint(address[16] _contracts) pure internal returns (address) {\r\n\t\treturn _contracts[0];\r\n\t}\r\n\r\n\tfunction getBdpController(address[16] _contracts) pure internal returns (address) {\r\n\t\treturn _contracts[1];\r\n\t}\r\n\r\n\tfunction getBdpControllerHelper(address[16] _contracts) pure internal returns (address) {\r\n\t\treturn _contracts[3];\r\n\t}\r\n\r\n\tfunction getBdpDataStorage(address[16] _contracts) pure internal returns (address) {\r\n\t\treturn _contracts[4];\r\n\t}\r\n\r\n\tfunction getBdpImageStorage(address[16] _contracts) pure internal returns (address) {\r\n\t\treturn _contracts[5];\r\n\t}\r\n\r\n\tfunction getBdpOwnershipStorage(address[16] _contracts) pure internal returns (address) {\r\n\t\treturn _contracts[6];\r\n\t}\r\n\r\n\tfunction getBdpPriceStorage(address[16] _contracts) pure internal returns (address) {\r\n\t\treturn _contracts[7];\r\n\t}\r\n\r\n}\r\n\r\ncontract BdpBase is BdpBaseData {\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == ownerAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyAuthorized() {\r\n\t\trequire(msg.sender == ownerAddress || msg.sender == managerAddress);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier whenContractActive() {\r\n\t\trequire(!paused && setupComplete);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier storageAccessControl() {\r\n\t\trequire(\r\n\t\t\t(! setupComplete && (msg.sender == ownerAddress || msg.sender == managerAddress))\r\n\t\t\t|| (setupComplete && !paused && (msg.sender == BdpContracts.getBdpEntryPoint(contracts)))\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction setOwner(address _newOwner) external onlyOwner {\r\n\t\trequire(_newOwner != address(0));\r\n\t\townerAddress = _newOwner;\r\n\t}\r\n\r\n\tfunction setManager(address _newManager) external onlyOwner {\r\n\t\trequire(_newManager != address(0));\r\n\t\tmanagerAddress = _newManager;\r\n\t}\r\n\r\n\tfunction setContracts(address[16] _contracts) external onlyOwner {\r\n\t\tcontracts = _contracts;\r\n\t}\r\n\r\n\tfunction pause() external onlyAuthorized {\r\n\t\tpaused = true;\r\n\t}\r\n\r\n\tfunction unpause() external onlyOwner {\r\n\t\tpaused = false;\r\n\t}\r\n\r\n\tfunction setSetupComplete() external onlyOwner {\r\n\t\tsetupComplete = true;\r\n\t}\r\n\r\n\tfunction kill() public onlyOwner {\r\n\t\tselfdestruct(ownerAddress);\r\n\t}\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract BdpDataStorage is BdpBase {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tstruct Region {\r\n\t\tuint256 x1;\r\n\t\tuint256 y1;\r\n\t\tuint256 x2;\r\n\t\tuint256 y2;\r\n\t\tuint256 currentImageId;\r\n\t\tuint256 nextImageId;\r\n\t\tuint8[128] url;\r\n\t\tuint256 currentPixelPrice;\r\n\t\tuint256 blockUpdatedAt;\r\n\t\tuint256 updatedAt;\r\n\t\tuint256 purchasedAt;\r\n\t\tuint256 purchasedPixelPrice;\r\n\t}\r\n\r\n\tuint256 public lastRegionId = 0;\r\n\r\n\tmapping (uint256 => Region) public data;\r\n\r\n\r\n\tfunction getLastRegionId() view public returns (uint256) {\r\n\t\treturn lastRegionId;\r\n\t}\r\n\r\n\tfunction getNextRegionId() public storageAccessControl returns (uint256) {\r\n\t\tlastRegionId = lastRegionId.add(1);\r\n\t\treturn lastRegionId;\r\n\t}\r\n\r\n\tfunction deleteRegionData(uint256 _id) public storageAccessControl {\r\n\t\tdelete data[_id];\r\n\t}\r\n\r\n\tfunction getRegionCoordinates(uint256 _id) view public returns (uint256, uint256, uint256, uint256) {\r\n\t\treturn (data[_id].x1, data[_id].y1, data[_id].x2, data[_id].y2);\r\n\t}\r\n\r\n\tfunction setRegionCoordinates(uint256 _id, uint256 _x1, uint256 _y1, uint256 _x2, uint256 _y2) public storageAccessControl {\r\n\t\tdata[_id].x1 = _x1;\r\n\t\tdata[_id].y1 = _y1;\r\n\t\tdata[_id].x2 = _x2;\r\n\t\tdata[_id].y2 = _y2;\r\n\t}\r\n\r\n\tfunction getRegionCurrentImageId(uint256 _id) view public returns (uint256) {\r\n\t\treturn data[_id].currentImageId;\r\n\t}\r\n\r\n\tfunction setRegionCurrentImageId(uint256 _id, uint256 _currentImageId) public storageAccessControl {\r\n\t\tdata[_id].currentImageId = _currentImageId;\r\n\t}\r\n\r\n\tfunction getRegionNextImageId(uint256 _id) view public returns (uint256) {\r\n\t\treturn data[_id].nextImageId;\r\n\t}\r\n\r\n\tfunction setRegionNextImageId(uint256 _id, uint256 _nextImageId) public storageAccessControl {\r\n\t\tdata[_id].nextImageId = _nextImageId;\r\n\t}\r\n\r\n\tfunction getRegionUrl(uint256 _id) view public returns (uint8[128]) {\r\n\t\treturn data[_id].url;\r\n\t}\r\n\r\n\tfunction setRegionUrl(uint256 _id, uint8[128] _url) public storageAccessControl {\r\n\t\tdata[_id].url = _url;\r\n\t}\r\n\r\n\tfunction getRegionCurrentPixelPrice(uint256 _id) view public returns (uint256) {\r\n\t\treturn data[_id].currentPixelPrice;\r\n\t}\r\n\r\n\tfunction setRegionCurrentPixelPrice(uint256 _id, uint256 _currentPixelPrice) public storageAccessControl {\r\n\t\tdata[_id].currentPixelPrice = _currentPixelPrice;\r\n\t}\r\n\r\n\tfunction getRegionBlockUpdatedAt(uint256 _id) view public returns (uint256) {\r\n\t\treturn data[_id].blockUpdatedAt;\r\n\t}\r\n\r\n\tfunction setRegionBlockUpdatedAt(uint256 _id, uint256 _blockUpdatedAt) public storageAccessControl {\r\n\t\tdata[_id].blockUpdatedAt = _blockUpdatedAt;\r\n\t}\r\n\r\n\tfunction getRegionUpdatedAt(uint256 _id) view public returns (uint256) {\r\n\t\treturn data[_id].updatedAt;\r\n\t}\r\n\r\n\tfunction setRegionUpdatedAt(uint256 _id, uint256 _updatedAt) public storageAccessControl {\r\n\t\tdata[_id].updatedAt = _updatedAt;\r\n\t}\r\n\r\n\tfunction getRegionPurchasedAt(uint256 _id) view public returns (uint256) {\r\n\t\treturn data[_id].purchasedAt;\r\n\t}\r\n\r\n\tfunction setRegionPurchasedAt(uint256 _id, uint256 _purchasedAt) public storageAccessControl {\r\n\t\tdata[_id].purchasedAt = _purchasedAt;\r\n\t}\r\n\r\n\tfunction getRegionUpdatedAtPurchasedAt(uint256 _id) view public returns (uint256 _updatedAt, uint256 _purchasedAt) {\r\n\t\treturn (data[_id].updatedAt, data[_id].purchasedAt);\r\n\t}\r\n\r\n\tfunction getRegionPurchasePixelPrice(uint256 _id) view public returns (uint256) {\r\n\t\treturn data[_id].purchasedPixelPrice;\r\n\t}\r\n\r\n\tfunction setRegionPurchasedPixelPrice(uint256 _id, uint256 _purchasedPixelPrice) public storageAccessControl {\r\n\t\tdata[_id].purchasedPixelPrice = _purchasedPixelPrice;\r\n\t}\r\n\r\n\tfunction BdpDataStorage(bytes8 _version) public {\r\n\t\townerAddress = msg.sender;\r\n\t\tmanagerAddress = msg.sender;\r\n\t\tversion = _version;\r\n\t}\r\n\r\n}\r\n\r\ncontract BdpPriceStorage is BdpBase {\r\n\r\n\tuint64[1001] public pricePoints;\r\n\r\n\tuint256 public pricePointsLength = 0;\r\n\r\n\taddress public forwardPurchaseFeesTo = address(0);\r\n\r\n\taddress public forwardUpdateFeesTo = address(0);\r\n\r\n\r\n\tfunction getPricePointsLength() view public returns (uint256) {\r\n\t\treturn pricePointsLength;\r\n\t}\r\n\r\n\tfunction getPricePoint(uint256 _i) view public returns (uint256) {\r\n\t\treturn pricePoints[_i];\r\n\t}\r\n\r\n\tfunction setPricePoints(uint64[] _pricePoints) public storageAccessControl {\r\n\t\tpricePointsLength = 0;\r\n\t\tappendPricePoints(_pricePoints);\r\n\t}\r\n\r\n\tfunction appendPricePoints(uint64[] _pricePoints) public storageAccessControl {\r\n\t\tfor (uint i = 0; i < _pricePoints.length; i++) {\r\n\t\t\tpricePoints[pricePointsLength++] = _pricePoints[i];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getForwardPurchaseFeesTo() view public returns (address) {\r\n\t\treturn forwardPurchaseFeesTo;\r\n\t}\r\n\r\n\tfunction setForwardPurchaseFeesTo(address _forwardPurchaseFeesTo) public storageAccessControl {\r\n\t\tforwardPurchaseFeesTo = _forwardPurchaseFeesTo;\r\n\t}\r\n\r\n\tfunction getForwardUpdateFeesTo() view public returns (address) {\r\n\t\treturn forwardUpdateFeesTo;\r\n\t}\r\n\r\n\tfunction setForwardUpdateFeesTo(address _forwardUpdateFeesTo) public storageAccessControl {\r\n\t\tforwardUpdateFeesTo = _forwardUpdateFeesTo;\r\n\t}\r\n\r\n\tfunction BdpPriceStorage(bytes8 _version) public {\r\n\t\townerAddress = msg.sender;\r\n\t\tmanagerAddress = msg.sender;\r\n\t\tversion = _version;\r\n\t}\r\n\r\n}\r\n\r\nlibrary BdpCalculator {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tfunction calculateArea(address[16] _contracts, uint256 _regionId) view public returns (uint256 _area, uint256 _width, uint256 _height) {\r\n\t\tvar (x1, y1, x2, y2) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCoordinates(_regionId);\r\n\t\t_width = x2 - x1 + 1;\r\n\t\t_height = y2 - y1 + 1;\r\n\t\t_area = _width * _height;\r\n\t}\r\n\r\n\tfunction countPurchasedPixels(address[16] _contracts) view public returns (uint256 _count) {\r\n\t\tvar lastRegionId = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getLastRegionId();\r\n\t\tfor (uint256 i = 0; i <= lastRegionId; i++) {\r\n\t\t\tif(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionPurchasedAt(i) > 0) { // region is purchased\r\n\t\t\t\tvar (area,,) = calculateArea(_contracts, i);\r\n\t\t\t\t_count += area;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction calculateCurrentMarketPixelPrice(address[16] _contracts) view public returns(uint) {\r\n\t\treturn calculateMarketPixelPrice(_contracts, countPurchasedPixels(_contracts));\r\n\t}\r\n\r\n\tfunction calculateMarketPixelPrice(address[16] _contracts, uint _pixelsSold) view public returns(uint) {\r\n\t\tvar pricePointsLength = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePointsLength();\r\n\t\tuint mod = _pixelsSold % (1000000 / (pricePointsLength - 1));\r\n\t\tuint div = _pixelsSold * (pricePointsLength - 1) / 1000000;\r\n\t\tvar divPoint = BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div);\r\n\t\tif(mod == 0) return divPoint;\r\n\t\treturn divPoint + mod * (BdpPriceStorage(BdpContracts.getBdpPriceStorage(_contracts)).getPricePoint(div+1) - divPoint) * (pricePointsLength - 1) / 1000000;\r\n\t}\r\n\r\n\tfunction calculateAveragePixelPrice(address[16] _contracts, uint _a, uint _b) view public returns (uint _price) {\r\n\t\t_price = (calculateMarketPixelPrice(_contracts, _a) + calculateMarketPixelPrice(_contracts, _b)) / 2;\r\n\t}\r\n\r\n\t/** Current market price per pixel for this region if it is the first sale of this region\r\n\t  */\r\n\tfunction calculateRegionInitialSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {\r\n\t\trequire(BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAt(_regionId) > 0); // region exists\r\n\t\tvar purchasedPixels = countPurchasedPixels(_contracts);\r\n\t\tvar (area,,) = calculateArea(_contracts, _regionId);\r\n\t\treturn calculateAveragePixelPrice(_contracts, purchasedPixels, purchasedPixels + area);\r\n\t}\r\n\r\n\t/** Current market price or (Current market price)*3 if the region was sold\r\n\t  */\r\n\tfunction calculateRegionSalePixelPrice(address[16] _contracts, uint256 _regionId) view public returns (uint256) {\r\n\t\tvar pixelPrice = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionCurrentPixelPrice(_regionId);\r\n\t\tif(pixelPrice > 0) {\r\n\t\t\treturn pixelPrice * 3;\r\n\t\t} else {\r\n\t\t\treturn calculateRegionInitialSalePixelPrice(_contracts, _regionId);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Setup is allowed one whithin one day after purchase\r\n\t  */\r\n\tfunction calculateSetupAllowedUntil(address[16] _contracts, uint256 _regionId) view public returns (uint256) {\r\n\t\tvar (updatedAt, purchasedAt) = BdpDataStorage(BdpContracts.getBdpDataStorage(_contracts)).getRegionUpdatedAtPurchasedAt(_regionId);\r\n\t\tif(updatedAt != purchasedAt) {\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\treturn purchasedAt + 1 days;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\ncontract BdpOwnershipStorage is BdpBase {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\t// Mapping from token ID to owner\r\n\tmapping (uint256 => address) public tokenOwner;\r\n\r\n\t// Mapping from token ID to approved address\r\n\tmapping (uint256 => address) public tokenApprovals;\r\n\r\n\t// Mapping from owner to the sum of owned area\r\n\tmapping (address => uint256) public ownedArea;\r\n\r\n\t// Mapping from owner to list of owned token IDs\r\n\tmapping (address => uint256[]) public ownedTokens;\r\n\r\n\t// Mapping from token ID to index of the owner tokens list\r\n\tmapping(uint256 => uint256) public ownedTokensIndex;\r\n\r\n\t// All tokens list tokens ids\r\n\tuint256[] public tokenIds;\r\n\r\n\t// Mapping from tokenId to index of the tokens list\r\n\tmapping (uint256 => uint256) public tokenIdsIndex;\r\n\r\n\r\n\tfunction getTokenOwner(uint256 _tokenId) view public returns (address) {\r\n\t\treturn tokenOwner[_tokenId];\r\n\t}\r\n\r\n\tfunction setTokenOwner(uint256 _tokenId, address _owner) public storageAccessControl {\r\n\t\ttokenOwner[_tokenId] = _owner;\r\n\t}\r\n\r\n\tfunction getTokenApproval(uint256 _tokenId) view public returns (address) {\r\n\t\treturn tokenApprovals[_tokenId];\r\n\t}\r\n\r\n\tfunction setTokenApproval(uint256 _tokenId, address _to) public storageAccessControl {\r\n\t\ttokenApprovals[_tokenId] = _to;\r\n\t}\r\n\r\n\tfunction getOwnedArea(address _owner) view public returns (uint256) {\r\n\t\treturn ownedArea[_owner];\r\n\t}\r\n\r\n\tfunction setOwnedArea(address _owner, uint256 _area) public storageAccessControl {\r\n\t\townedArea[_owner] = _area;\r\n\t}\r\n\r\n\tfunction incrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {\r\n\t\townedArea[_owner] = ownedArea[_owner].add(_area);\r\n\t\treturn ownedArea[_owner];\r\n\t}\r\n\r\n\tfunction decrementOwnedArea(address _owner, uint256 _area) public storageAccessControl returns (uint256) {\r\n\t\townedArea[_owner] = ownedArea[_owner].sub(_area);\r\n\t\treturn ownedArea[_owner];\r\n\t}\r\n\r\n\tfunction getOwnedTokensLength(address _owner) view public returns (uint256) {\r\n\t\treturn ownedTokens[_owner].length;\r\n\t}\r\n\r\n\tfunction getOwnedToken(address _owner, uint256 _index) view public returns (uint256) {\r\n\t\treturn ownedTokens[_owner][_index];\r\n\t}\r\n\r\n\tfunction setOwnedToken(address _owner, uint256 _index, uint256 _tokenId) public storageAccessControl {\r\n\t\townedTokens[_owner][_index] = _tokenId;\r\n\t}\r\n\r\n\tfunction pushOwnedToken(address _owner, uint256 _tokenId) public storageAccessControl returns (uint256) {\r\n\t\townedTokens[_owner].push(_tokenId);\r\n\t\treturn ownedTokens[_owner].length;\r\n\t}\r\n\r\n\tfunction decrementOwnedTokensLength(address _owner) public storageAccessControl {\r\n\t\townedTokens[_owner].length--;\r\n\t}\r\n\r\n\tfunction getOwnedTokensIndex(uint256 _tokenId) view public returns (uint256) {\r\n\t\treturn ownedTokensIndex[_tokenId];\r\n\t}\r\n\r\n\tfunction setOwnedTokensIndex(uint256 _tokenId, uint256 _tokenIndex) public storageAccessControl {\r\n\t\townedTokensIndex[_tokenId] = _tokenIndex;\r\n\t}\r\n\r\n\tfunction getTokenIdsLength() view public returns (uint256) {\r\n\t\treturn tokenIds.length;\r\n\t}\r\n\r\n\tfunction getTokenIdByIndex(uint256 _index) view public returns (uint256) {\r\n\t\treturn tokenIds[_index];\r\n\t}\r\n\r\n\tfunction setTokenIdByIndex(uint256 _index, uint256 _tokenId) public storageAccessControl {\r\n\t\ttokenIds[_index] = _tokenId;\r\n\t}\r\n\r\n\tfunction pushTokenId(uint256 _tokenId) public storageAccessControl returns (uint256) {\r\n\t\ttokenIds.push(_tokenId);\r\n\t\treturn tokenIds.length;\r\n\t}\r\n\r\n\tfunction decrementTokenIdsLength() public storageAccessControl {\r\n\t\ttokenIds.length--;\r\n\t}\r\n\r\n\tfunction getTokenIdsIndex(uint256 _tokenId) view public returns (uint256) {\r\n\t\treturn tokenIdsIndex[_tokenId];\r\n\t}\r\n\r\n\tfunction setTokenIdsIndex(uint256 _tokenId, uint256 _tokenIdIndex) public storageAccessControl {\r\n\t\ttokenIdsIndex[_tokenId] = _tokenIdIndex;\r\n\t}\r\n\r\n\tfunction BdpOwnershipStorage(bytes8 _version) public {\r\n\t\townerAddress = msg.sender;\r\n\t\tmanagerAddress = msg.sender;\r\n\t\tversion = _version;\r\n\t}\r\n\r\n}\r\n\r\nlibrary BdpOwnership {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n\tfunction ownerOf(address[16] _contracts, uint256 _tokenId) public view returns (address) {\r\n\t\tvar owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);\r\n\t\trequire(owner != address(0));\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction balanceOf(address[16] _contracts, address _owner) public view returns (uint256) {\r\n\t\treturn BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getOwnedTokensLength(_owner);\r\n\t}\r\n\r\n\tfunction approve(address[16] _contracts, address _to, uint256 _tokenId) public {\r\n\t\tvar ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));\r\n\r\n\t\taddress owner = ownerOf(_contracts, _tokenId);\r\n\t\trequire(_to != owner);\r\n\t\tif (ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0) {\r\n\t\t\townStorage.setTokenApproval(_tokenId, _to);\r\n\t\t\tApproval(owner, _to, _tokenId);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Clear current approval of a given token ID\r\n\t * @param _tokenId uint256 ID of the token to be transferred\r\n\t */\r\n\tfunction clearApproval(address[16] _contracts, address _owner, uint256 _tokenId) public {\r\n\t\tvar ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));\r\n\r\n\t\trequire(ownerOf(_contracts, _tokenId) == _owner);\r\n\t\tif (ownStorage.getTokenApproval(_tokenId) != 0) {\r\n\t\t\tBdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).setTokenApproval(_tokenId, 0);\r\n\t\t\tApproval(_owner, 0, _tokenId);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Clear current approval and transfer the ownership of a given token ID\r\n\t * @param _from address which you want to send tokens from\r\n\t * @param _to address which you want to transfer the token to\r\n\t * @param _tokenId uint256 ID of the token to be transferred\r\n\t */\r\n\tfunction clearApprovalAndTransfer(address[16] _contracts, address _from, address _to, uint256 _tokenId) public {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_to != ownerOf(_contracts, _tokenId));\r\n\t\trequire(ownerOf(_contracts, _tokenId) == _from);\r\n\r\n\t\tclearApproval(_contracts, _from, _tokenId);\r\n\t\tremoveToken(_contracts, _from, _tokenId);\r\n\t\taddToken(_contracts, _to, _tokenId);\r\n\t\tTransfer(_from, _to, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal function to add a token ID to the list of a given address\r\n\t * @param _to address representing the new owner of the given token ID\r\n\t * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n\t */\r\n\tfunction addToken(address[16] _contracts, address _to, uint256 _tokenId) private {\r\n\t\tvar ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));\r\n\r\n\t\trequire(ownStorage.getTokenOwner(_tokenId) == address(0));\r\n\r\n\t\t// Set token owner\r\n\t\townStorage.setTokenOwner(_tokenId, _to);\r\n\r\n\t\t// Add token to tokenIds list\r\n\t\tvar tokenIdsLength = ownStorage.pushTokenId(_tokenId);\r\n\t\townStorage.setTokenIdsIndex(_tokenId, tokenIdsLength.sub(1));\r\n\r\n\t\tuint256 ownedTokensLength = ownStorage.getOwnedTokensLength(_to);\r\n\r\n\t\t// Add token to ownedTokens list\r\n\t\townStorage.pushOwnedToken(_to, _tokenId);\r\n\t\townStorage.setOwnedTokensIndex(_tokenId, ownedTokensLength);\r\n\r\n\t\t// Increment total owned area\r\n\t\tvar (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);\r\n\t\townStorage.incrementOwnedArea(_to, area);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal function to remove a token ID from the list of a given address\r\n\t * @param _from address representing the previous owner of the given token ID\r\n\t * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n\t */\r\n\tfunction removeToken(address[16] _contracts, address _from, uint256 _tokenId) private {\r\n\t\tvar ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));\r\n\r\n\t\trequire(ownerOf(_contracts, _tokenId) == _from);\r\n\r\n\t\t// Clear token owner\r\n\t\townStorage.setTokenOwner(_tokenId, 0);\r\n\r\n\t\tremoveFromTokenIds(ownStorage, _tokenId);\r\n\t\tremoveFromOwnedToken(ownStorage, _from, _tokenId);\r\n\r\n\t\t// Decrement total owned area\r\n\t\tvar (area,,) = BdpCalculator.calculateArea(_contracts, _tokenId);\r\n\t\townStorage.decrementOwnedArea(_from, area);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove token from ownedTokens list\r\n\t * Note that this will handle single-element arrays. In that case, both ownedTokenIndex and lastOwnedTokenIndex are going to\r\n\t * be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n\t * the lastOwnedToken to the first position, and then dropping the element placed in the last position of the list\r\n\t */\r\n\tfunction removeFromOwnedToken(BdpOwnershipStorage _ownStorage, address _from, uint256 _tokenId) private {\r\n\t\tvar ownedTokenIndex = _ownStorage.getOwnedTokensIndex(_tokenId);\r\n\t\tvar lastOwnedTokenIndex = _ownStorage.getOwnedTokensLength(_from).sub(1);\r\n\t\tvar lastOwnedToken = _ownStorage.getOwnedToken(_from, lastOwnedTokenIndex);\r\n\t\t_ownStorage.setOwnedToken(_from, ownedTokenIndex, lastOwnedToken);\r\n\t\t_ownStorage.setOwnedToken(_from, lastOwnedTokenIndex, 0);\r\n\t\t_ownStorage.decrementOwnedTokensLength(_from);\r\n\t\t_ownStorage.setOwnedTokensIndex(_tokenId, 0);\r\n\t\t_ownStorage.setOwnedTokensIndex(lastOwnedToken, ownedTokenIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove token from tokenIds list\r\n\t */\r\n\tfunction removeFromTokenIds(BdpOwnershipStorage _ownStorage, uint256 _tokenId) private {\r\n\t\tvar tokenIndex = _ownStorage.getTokenIdsIndex(_tokenId);\r\n\t\tvar lastTokenIdIndex = _ownStorage.getTokenIdsLength().sub(1);\r\n\t\tvar lastTokenId = _ownStorage.getTokenIdByIndex(lastTokenIdIndex);\r\n\t\t_ownStorage.setTokenIdByIndex(tokenIndex, lastTokenId);\r\n\t\t_ownStorage.setTokenIdByIndex(lastTokenIdIndex, 0);\r\n\t\t_ownStorage.decrementTokenIdsLength();\r\n\t\t_ownStorage.setTokenIdsIndex(_tokenId, 0);\r\n\t\t_ownStorage.setTokenIdsIndex(lastTokenId, tokenIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Mint token function\r\n\t * @param _to The address that will own the minted token\r\n\t * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n\t */\r\n\tfunction mint(address[16] _contracts, address _to, uint256 _tokenId) public {\r\n\t\trequire(_to != address(0));\r\n\t\taddToken(_contracts, _to, _tokenId);\r\n\t\tTransfer(address(0), _to, _tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Burns a specific token\r\n\t * @param _tokenId uint256 ID of the token being burned\r\n\t */\r\n\tfunction burn(address[16] _contracts, uint256 _tokenId) public {\r\n\t\taddress owner = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts)).getTokenOwner(_tokenId);\r\n\t\tclearApproval(_contracts, owner, _tokenId);\r\n\t\tremoveToken(_contracts, owner, _tokenId);\r\n\t\tTransfer(owner, address(0), _tokenId);\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_contracts\",\"type\":\"address[16]\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"clearApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contracts\",\"type\":\"address[16]\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contracts\",\"type\":\"address[16]\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"clearApprovalAndTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contracts\",\"type\":\"address[16]\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contracts\",\"type\":\"address[16]\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contracts\",\"type\":\"address[16]\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contracts\",\"type\":\"address[16]\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"BdpOwnership","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"BdpCalculator:6c0a11e254b666b107abe5ecf5003b53bf362eb0","SwarmSource":"bzzr://8f9e045f847b34768a8e721e99ea5040f4f94f3b52de7622ea9d7f9ccb88a45e"}]}