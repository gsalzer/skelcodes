{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // require(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\r\n        _transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\r\n        require(allowance[_from][msg.sender] >= _value);\r\n\r\n        allowance[_from][msg.sender] = SafeMath.sub(allowance[_from][msg.sender], _value);\r\n\r\n        _transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *   ######################\r\n     *  #  private function  #\r\n     * ######################\r\n     */\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n\r\n        require(balanceOf[_from] >= _value);\r\n\r\n        require(SafeMath.add(balanceOf[_to], _value) >= balanceOf[_to]);\r\n\r\n        balanceOf[_from] = SafeMath.sub(balanceOf[_from], _value);\r\n\r\n        balanceOf[_to] = SafeMath.add(balanceOf[_to], _value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n}\r\n\r\ncontract Token is ERC20 {\r\n\r\n    uint8 public constant decimals = 9;\r\n\r\n    uint256 public constant initialSupply = 10 * (10 ** 8) * (10 ** uint256(decimals));\r\n\r\n    string public constant name = 'INK Coin';\r\n\r\n    string public constant symbol = 'INK';\r\n\r\n\r\n    function() public {\r\n\r\n        revert();\r\n    }\r\n\r\n    function Token() public {\r\n\r\n        balanceOf[msg.sender] = initialSupply;\r\n\r\n        totalSupply = initialSupply;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n\r\n        if (approve(_spender, _value)) {\r\n\r\n            if (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {\r\n\r\n                revert();\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ninterface XCInterface {\r\n\r\n    /**\r\n     * Set contract service status.\r\n     * @param status contract service status (0:closed;1:only-closed-lock;2:only-closed-unlock;3:opened;).\r\n     */\r\n    function setStatus(uint8 status) external;\r\n\r\n    /**\r\n     * Get contract service status.\r\n     * @return contract service status.\r\n     */\r\n    function getStatus() external view returns (uint8);\r\n\r\n    /**\r\n     * Get the current contract platform name.\r\n     * @return contract platform name.\r\n     */\r\n    function getPlatformName() external view returns (bytes32);\r\n\r\n    /**\r\n     * Set the current contract administrator.\r\n     * @param account account of contract administrator.\r\n     */\r\n    function setAdmin(address account) external;\r\n\r\n    /**\r\n     * Get the current contract administrator.\r\n     * @return contract administrator.\r\n     */\r\n    function getAdmin() external view returns (address);\r\n\r\n    /**\r\n     * Set the Token contract address.\r\n     * @param account contract address.\r\n     */\r\n    function setToken(address account) external;\r\n\r\n    /**\r\n     * Get the Token contract address.\r\n     * @return contract address.\r\n     */\r\n    function getToken() external view returns (address);\r\n\r\n    /**\r\n     * Set the XCPlugin contract address.\r\n     * @param account contract address.\r\n     */\r\n    function setXCPlugin(address account) external;\r\n\r\n    /**\r\n     * Get the XCPlugin contract address.\r\n     * @return contract address.\r\n     */\r\n    function getXCPlugin() external view returns (address);\r\n\r\n    /**\r\n     * Set the comparison symbol in the contract.\r\n     * @param symbol comparison symbol ({\"-=\" : \">\" , \"+=\" : \">=\" }).\r\n     */\r\n    function setCompare(bytes2 symbol) external;\r\n\r\n    /**\r\n     * Get the comparison symbol in the contract.\r\n     * @return comparison symbol.\r\n     */\r\n    function getCompare() external view returns (bytes2);\r\n\r\n    /**\r\n     * Transfer out of cross chain.\r\n     * @param toPlatform name of to platform.\r\n     * @param toAccount account of to platform.\r\n     * @param value transfer amount.\r\n     */\r\n    function lock(bytes32 toPlatform, address toAccount, uint value) external payable;\r\n\r\n    /**\r\n     * Transfer in of cross chain.\r\n     * @param txid transaction id.\r\n     * @param fromPlatform name of form platform.\r\n     * @param fromAccount ame of to platform.\r\n     * @param toAccount account of to platform.\r\n     * @param value transfer amount.\r\n     */\r\n    function unlock(string txid, bytes32 fromPlatform, address fromAccount, address toAccount, uint value) external payable;\r\n\r\n    /**\r\n     * Transfer the misoperation to the amount of the contract account to the specified account.\r\n     * @param account the specified account.\r\n     * @param value transfer amount.\r\n     */\r\n    function withdraw(address account, uint value) external payable;\r\n\r\n    /**\r\n     * Transfer the money(qtum/eth) from the contract account.\r\n     * @param account the specified account.\r\n     * @param value transfer amount.\r\n     */\r\n    function transfer(address account, uint value) external payable;\r\n\r\n    /**\r\n     * Deposit money(eth) into a contract.\r\n     */\r\n    function deposit() external payable;\r\n}\r\n\r\ncontract XC is XCInterface {\r\n\r\n    /**\r\n     * Contract Administrator\r\n     * @field status Contract external service status.\r\n     * @field platformName Current contract platform name.\r\n     * @field account Current contract administrator.\r\n     */\r\n    struct Admin {\r\n\r\n        uint8 status;\r\n\r\n        bytes32 platformName;\r\n\r\n        bytes32 tokenSymbol;\r\n\r\n        bytes2 compareSymbol;\r\n\r\n        address account;\r\n    }\r\n\r\n    Admin private admin;\r\n\r\n    uint public lockBalance;\r\n\r\n    Token private token;\r\n\r\n    XCPlugin private xcPlugin;\r\n\r\n    event Lock(bytes32 toPlatform, address toAccount, bytes32 value, bytes32 tokenSymbol);\r\n\r\n    event Unlock(string txid, bytes32 fromPlatform, address fromAccount, bytes32 value, bytes32 tokenSymbol);\r\n\r\n    event Deposit(address from, bytes32 value);\r\n\r\n    function XC() public payable {\r\n\r\n        init();\r\n    }\r\n\r\n    function init() internal {\r\n\r\n        // Admin {status | platformName | tokenSymbol | compareSymbol | account}\r\n        admin.status = 3;\r\n\r\n        admin.platformName = \"ETH\";\r\n\r\n        admin.tokenSymbol = \"INK\";\r\n\r\n        admin.compareSymbol = \"+=\";\r\n\r\n        admin.account = msg.sender;\r\n\r\n        //totalSupply = 10 * (10 ** 8) * (10 ** 9);\r\n        lockBalance = 10 * (10 ** 8) * (10 ** 9);\r\n\r\n        token = Token(0xc15d8f30fa3137eee6be111c2933f1624972f45c);\r\n\r\n        xcPlugin = XCPlugin(0x55c87c2e26f66fd3642645c3f25c9e81a75ec0f4);\r\n    }\r\n\r\n    function setStatus(uint8 status) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(status == 0 || status == 1 || status == 2 || status == 3);\r\n\r\n        if (admin.status != status) {\r\n\r\n            admin.status = status;\r\n        }\r\n    }\r\n\r\n    function getStatus() external view returns (uint8) {\r\n\r\n        return admin.status;\r\n    }\r\n\r\n    function getPlatformName() external view returns (bytes32) {\r\n\r\n        return admin.platformName;\r\n    }\r\n\r\n    function setAdmin(address account) external {\r\n\r\n        require(account != address(0));\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        if (admin.account != account) {\r\n\r\n            admin.account = account;\r\n        }\r\n    }\r\n\r\n    function getAdmin() external view returns (address) {\r\n\r\n        return admin.account;\r\n    }\r\n\r\n    function setToken(address account) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        if (token != account) {\r\n\r\n            token = Token(account);\r\n        }\r\n    }\r\n\r\n    function getToken() external view returns (address) {\r\n\r\n        return token;\r\n    }\r\n\r\n    function setXCPlugin(address account) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        if (xcPlugin != account) {\r\n\r\n            xcPlugin = XCPlugin(account);\r\n        }\r\n    }\r\n\r\n    function getXCPlugin() external view returns (address) {\r\n\r\n        return xcPlugin;\r\n    }\r\n\r\n    function setCompare(bytes2 symbol) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(symbol == \"+=\" || symbol == \"-=\");\r\n\r\n        if (admin.compareSymbol != symbol) {\r\n\r\n            admin.compareSymbol = symbol;\r\n        }\r\n    }\r\n\r\n    function getCompare() external view returns (bytes2){\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        return admin.compareSymbol;\r\n    }\r\n\r\n    function lock(bytes32 toPlatform, address toAccount, uint value) external payable {\r\n\r\n        require(admin.status == 2 || admin.status == 3);\r\n\r\n        require(xcPlugin.getStatus());\r\n\r\n        require(xcPlugin.existPlatform(toPlatform));\r\n\r\n        require(toAccount != address(0));\r\n\r\n        // require(token.totalSupply >= value && value > 0);\r\n        require(value > 0);\r\n\r\n        //get user approve the contract quota\r\n        uint allowance = token.allowance(msg.sender, this);\r\n\r\n        require(toCompare(allowance, value));\r\n\r\n        //do transferFrom\r\n        bool success = token.transferFrom(msg.sender, this, value);\r\n\r\n        require(success);\r\n\r\n        //record the amount of local platform turn out\r\n        lockBalance = SafeMath.add(lockBalance, value);\r\n        // require(token.totalSupply >= lockBalance);\r\n\r\n        //trigger Lock\r\n        emit Lock(toPlatform, toAccount, bytes32(value), admin.tokenSymbol);\r\n    }\r\n\r\n    function unlock(string txid, bytes32 fromPlatform, address fromAccount, address toAccount, uint value) external payable {\r\n\r\n        require(admin.status == 1 || admin.status == 3);\r\n\r\n        require(xcPlugin.getStatus());\r\n\r\n        require(xcPlugin.existPlatform(fromPlatform));\r\n\r\n        require(toAccount != address(0));\r\n\r\n        // require(token.totalSupply >= value && value > 0);\r\n        require(value > 0);\r\n\r\n        //verify args by function xcPlugin.verify\r\n        bool complete;\r\n\r\n        bool verify;\r\n\r\n        (complete, verify) = xcPlugin.verifyProposal(fromPlatform, fromAccount, toAccount, value, admin.tokenSymbol, txid);\r\n\r\n        require(verify && !complete);\r\n\r\n        //get contracts balance\r\n        uint balance = token.balanceOf(this);\r\n\r\n        //validate the balance of contract were less than amount\r\n        require(toCompare(balance, value));\r\n\r\n        require(token.transfer(toAccount, value));\r\n\r\n        require(xcPlugin.commitProposal(fromPlatform, txid));\r\n\r\n        lockBalance = SafeMath.sub(lockBalance, value);\r\n\r\n        emit Unlock(txid, fromPlatform, fromAccount, bytes32(value), admin.tokenSymbol);\r\n    }\r\n\r\n    function withdraw(address account, uint value) external payable {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(account != address(0));\r\n\r\n        // require(token.totalSupply >= value && value > 0);\r\n        require(value > 0);\r\n\r\n        uint balance = token.balanceOf(this);\r\n\r\n        require(toCompare(SafeMath.sub(balance, lockBalance), value));\r\n\r\n        bool success = token.transfer(account, value);\r\n\r\n        require(success);\r\n    }\r\n\r\n    function transfer(address account, uint value) external payable {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(account != address(0));\r\n\r\n        require(value > 0 && value >= address(this).balance);\r\n\r\n        this.transfer(account, value);\r\n    }\r\n\r\n    function deposit() external payable {\r\n\r\n        emit Deposit(msg.sender, bytes32(msg.value));\r\n    }\r\n\r\n    /**\r\n     *   ######################\r\n     *  #  private function  #\r\n     * ######################\r\n     */\r\n\r\n    function toCompare(uint f, uint s) internal view returns (bool) {\r\n\r\n        if (admin.compareSymbol == \"-=\") {\r\n\r\n            return f > s;\r\n        } else if (admin.compareSymbol == \"+=\") {\r\n\r\n            return f >= s;\r\n        } else {\r\n\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ninterface XCPluginInterface {\r\n\r\n    /**\r\n     * Open the contract service status.\r\n     */\r\n    function start() external;\r\n\r\n    /**\r\n     * Close the contract service status.\r\n     */\r\n    function stop() external;\r\n\r\n    /**\r\n     * Get contract service status.\r\n     * @return contract service status.\r\n     */\r\n    function getStatus() external view returns (bool);\r\n\r\n    /**\r\n     * Get the current contract platform name.\r\n     * @return contract platform name.\r\n     */\r\n    function getPlatformName() external view returns (bytes32);\r\n\r\n    /**\r\n     * Set the current contract administrator.\r\n     * @param account account of contract administrator.\r\n     */\r\n    function setAdmin(address account) external;\r\n\r\n    /**\r\n     * Get the current contract administrator.\r\n     * @return contract administrator.\r\n     */\r\n    function getAdmin() external view returns (address);\r\n\r\n    /**\r\n     * Add a contract trust caller.\r\n     * @param caller account of caller.\r\n     */\r\n    function addCaller(address caller) external;\r\n\r\n    /**\r\n     * Delete a contract trust caller.\r\n     * @param caller account of caller.\r\n     */\r\n    function deleteCaller(address caller) external;\r\n\r\n    /**\r\n     * Whether the trust caller exists.\r\n     * @param caller account of caller.\r\n     * @return whether exists.\r\n     */\r\n    function existCaller(address caller) external view returns (bool);\r\n\r\n    /**\r\n     * Get all contract trusted callers.\r\n     * @return al lcallers.\r\n     */\r\n    function getCallers() external view returns (address[]);\r\n\r\n    /**\r\n     * Add a trusted platform name.\r\n     * @param name a platform name.\r\n     */\r\n    function addPlatform(bytes32 name) external;\r\n\r\n    /**\r\n     * Delete a trusted platform name.\r\n     * @param name a platform name.\r\n     */\r\n    function deletePlatform(bytes32 name) external;\r\n\r\n    /**\r\n     * Whether the trusted platform information exists.\r\n     * @param name a platform name.\r\n     * @return whether exists.\r\n     */\r\n    function existPlatform(bytes32 name) external view returns (bool);\r\n\r\n    /**\r\n     * Add the trusted platform public key information.\r\n     * @param platformName a platform name.\r\n     * @param publicKey a public key.\r\n     */\r\n    function addPublicKey(bytes32 platformName, address publicKey) external;\r\n\r\n    /**\r\n     * Delete the trusted platform public key information.\r\n     * @param platformName a platform name.\r\n     * @param publicKey a public key.\r\n     */\r\n    function deletePublicKey(bytes32 platformName, address publicKey) external;\r\n\r\n    /**\r\n     * Whether the trusted platform public key information exists.\r\n     * @param platformName a platform name.\r\n     * @param publicKey a public key.\r\n     */\r\n    function existPublicKey(bytes32 platformName, address publicKey) external view returns (bool);\r\n\r\n    /**\r\n     * Get the count of public key for the trusted platform.\r\n     * @param platformName a platform name.\r\n     * @return count of public key.\r\n     */\r\n    function countOfPublicKey(bytes32 platformName) external view returns (uint);\r\n\r\n    /**\r\n     * Get the list of public key for the trusted platform.\r\n     * @param platformName a platform name.\r\n     * @return list of public key.\r\n     */\r\n    function publicKeys(bytes32 platformName) external view returns (address[]);\r\n\r\n    /**\r\n     * Set the weight of a trusted platform.\r\n     * @param platformName a platform name.\r\n     * @param weight weight of platform.\r\n     */\r\n    function setWeight(bytes32 platformName, uint weight) external;\r\n\r\n    /**\r\n     * Get the weight of a trusted platform.\r\n     * @param platformName a platform name.\r\n     * @return weight of platform.\r\n     */\r\n    function getWeight(bytes32 platformName) external view returns (uint);\r\n\r\n    /**\r\n     * Initiate and vote on the transaction proposal.\r\n     * @param fromPlatform name of form platform.\r\n     * @param fromAccount name of to platform.\r\n     * @param toAccount account of to platform.\r\n     * @param value transfer amount.\r\n     * @param tokenSymbol token Symbol.\r\n     * @param txid transaction id.\r\n     * @param sig transaction signature.\r\n     */\r\n    function voteProposal(bytes32 fromPlatform, address fromAccount, address toAccount, uint value, bytes32 tokenSymbol, string txid, bytes sig) external;\r\n\r\n    /**\r\n     * Verify that the transaction proposal is valid.\r\n     * @param fromPlatform name of form platform.\r\n     * @param fromAccount name of to platform.\r\n     * @param toAccount account of to platform.\r\n     * @param value transfer amount.\r\n     * @param tokenSymbol token Symbol.\r\n     * @param txid transaction id.\r\n     */\r\n    function verifyProposal(bytes32 fromPlatform, address fromAccount, address toAccount, uint value, bytes32 tokenSymbol, string txid) external view returns (bool, bool);\r\n\r\n    /**\r\n     * Commit the transaction proposal.\r\n     * @param platformName a platform name.\r\n     * @param txid transaction id.\r\n     */\r\n    function commitProposal(bytes32 platformName, string txid) external returns (bool);\r\n\r\n    /**\r\n     * Get the transaction proposal information.\r\n     * @param platformName a platform name.\r\n     * @param txid transaction id.\r\n     * @return status completion status of proposal.\r\n     * @return fromAccount account of to platform.\r\n     * @return toAccount account of to platform.\r\n     * @return value transfer amount.\r\n     * @return voters notarial voters.\r\n     * @return weight The weight value of the completed time.\r\n     */\r\n    function getProposal(bytes32 platformName, string txid) external view returns (bool status, address fromAccount, address toAccount, uint value, address[] voters, uint weight);\r\n\r\n    /**\r\n     * Delete the transaction proposal information.\r\n     * @param platformName a platform name.\r\n     * @param txid transaction id.\r\n     */\r\n    function deleteProposal(bytes32 platformName, string txid) external;\r\n\r\n    /**\r\n     * Transfer the money(qtum/eth) from the contract account.\r\n     * @param account the specified account.\r\n     * @param value transfer amount.\r\n     */\r\n    function transfer(address account, uint value) external payable;\r\n}\r\n\r\ncontract XCPlugin is XCPluginInterface {\r\n\r\n    /**\r\n     * Contract Administrator\r\n     * @field status Contract external service status.\r\n     * @field platformName Current contract platform name.\r\n     * @field tokenSymbol token Symbol.\r\n     * @field account Current contract administrator.\r\n     */\r\n    struct Admin {\r\n\r\n        bool status;\r\n\r\n        bytes32 platformName;\r\n\r\n        bytes32 tokenSymbol;\r\n\r\n        address account;\r\n    }\r\n\r\n    /**\r\n     * Transaction Proposal\r\n     * @field status Transaction proposal status(false:pending,true:complete).\r\n     * @field fromAccount Account of form platform.\r\n     * @field toAccount Account of to platform.\r\n     * @field value Transfer amount.\r\n     * @field tokenSymbol token Symbol.\r\n     * @field voters Proposers.\r\n     * @field weight The weight value of the completed time.\r\n     */\r\n    struct Proposal {\r\n\r\n        bool status;\r\n\r\n        address fromAccount;\r\n\r\n        address toAccount;\r\n\r\n        uint value;\r\n\r\n        bytes32 tokenSymbol;\r\n\r\n        address[] voters;\r\n\r\n        uint weight;\r\n    }\r\n\r\n    /**\r\n     * Trusted Platform\r\n     * @field status Trusted platform state(false:no trusted,true:trusted).\r\n     * @field weight weight of platform.\r\n     * @field publicKeys list of public key.\r\n     * @field proposals list of proposal.\r\n     */\r\n    struct Platform {\r\n\r\n        bool status;\r\n\r\n        uint weight;\r\n\r\n        address[] publicKeys;\r\n\r\n        mapping(string => Proposal) proposals;\r\n    }\r\n\r\n    Admin private admin;\r\n\r\n    address[] private callers;\r\n\r\n    mapping(bytes32 => Platform) private platforms;\r\n\r\n    function XCPlugin() public {\r\n\r\n        init();\r\n    }\r\n\r\n    function init() internal {\r\n        // Admin { status | platformName | tokenSymbol | account}\r\n        admin.status = true;\r\n\r\n        admin.platformName = \"ETH\";\r\n\r\n        admin.tokenSymbol = \"INK\";\r\n\r\n        admin.account = msg.sender;\r\n\r\n        bytes32 platformName = \"INK\";\r\n\r\n        platforms[platformName].status = true;\r\n\r\n        platforms[platformName].weight = 1;\r\n\r\n        platforms[platformName].publicKeys.push(0x4230a12f5b0693dd88bb35c79d7e56a68614b199);\r\n\r\n        platforms[platformName].publicKeys.push(0x07caf88941eafcaaa3370657fccc261acb75dfba);\r\n    }\r\n\r\n    function start() external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        if (!admin.status) {\r\n\r\n            admin.status = true;\r\n        }\r\n    }\r\n\r\n    function stop() external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        if (admin.status) {\r\n\r\n            admin.status = false;\r\n        }\r\n    }\r\n\r\n    function getStatus() external view returns (bool) {\r\n\r\n        return admin.status;\r\n    }\r\n\r\n    function getPlatformName() external view returns (bytes32) {\r\n\r\n        return admin.platformName;\r\n    }\r\n\r\n    function setAdmin(address account) external {\r\n\r\n        require(account != address(0));\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        if (admin.account != account) {\r\n\r\n            admin.account = account;\r\n        }\r\n    }\r\n\r\n    function getAdmin() external view returns (address) {\r\n\r\n        return admin.account;\r\n    }\r\n\r\n    function addCaller(address caller) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        if (!_existCaller(caller)) {\r\n\r\n            callers.push(caller);\r\n        }\r\n    }\r\n\r\n    function deleteCaller(address caller) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        if (_existCaller(caller)) {\r\n\r\n            bool exist;\r\n\r\n            for (uint i = 0; i <= callers.length; i++) {\r\n\r\n                if (exist) {\r\n\r\n                    if (i == callers.length) {\r\n\r\n                        delete callers[i - 1];\r\n\r\n                        callers.length--;\r\n                    } else {\r\n\r\n                        callers[i - 1] = callers[i];\r\n                    }\r\n                } else if (callers[i] == caller) {\r\n\r\n                    exist = true;\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function existCaller(address caller) external view returns (bool) {\r\n\r\n        return _existCaller(caller);\r\n    }\r\n\r\n    function getCallers() external view returns (address[]) {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        return callers;\r\n    }\r\n\r\n    function addPlatform(bytes32 name) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(name != \"\");\r\n\r\n        require(name != admin.platformName);\r\n\r\n        if (!_existPlatform(name)) {\r\n\r\n            platforms[name].status = true;\r\n\r\n            if (platforms[name].weight == 0) {\r\n\r\n                platforms[name].weight = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function deletePlatform(bytes32 name) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(name != admin.platformName);\r\n\r\n        if (_existPlatform(name)) {\r\n\r\n            platforms[name].status = false;\r\n        }\r\n    }\r\n\r\n    function existPlatform(bytes32 name) external view returns (bool){\r\n\r\n        return _existPlatform(name);\r\n    }\r\n\r\n    function setWeight(bytes32 platformName, uint weight) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        require(weight > 0);\r\n\r\n        if (platforms[platformName].weight != weight) {\r\n\r\n            platforms[platformName].weight = weight;\r\n        }\r\n    }\r\n\r\n    function getWeight(bytes32 platformName) external view returns (uint) {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        return platforms[platformName].weight;\r\n    }\r\n\r\n    function addPublicKey(bytes32 platformName, address publicKey) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        require(publicKey != address(0));\r\n\r\n        address[] storage listOfPublicKey = platforms[platformName].publicKeys;\r\n\r\n        for (uint i; i < listOfPublicKey.length; i++) {\r\n\r\n            if (publicKey == listOfPublicKey[i]) {\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        listOfPublicKey.push(publicKey);\r\n    }\r\n\r\n    function deletePublicKey(bytes32 platformName, address publickey) external {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        address[] storage listOfPublicKey = platforms[platformName].publicKeys;\r\n\r\n        bool exist;\r\n\r\n        for (uint i = 0; i <= listOfPublicKey.length; i++) {\r\n\r\n            if (exist) {\r\n                if (i == listOfPublicKey.length) {\r\n\r\n                    delete listOfPublicKey[i - 1];\r\n\r\n                    listOfPublicKey.length--;\r\n                } else {\r\n\r\n                    listOfPublicKey[i - 1] = listOfPublicKey[i];\r\n                }\r\n            } else if (listOfPublicKey[i] == publickey) {\r\n\r\n                exist = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function existPublicKey(bytes32 platformName, address publicKey) external view returns (bool) {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        return _existPublicKey(platformName, publicKey);\r\n    }\r\n\r\n    function countOfPublicKey(bytes32 platformName) external view returns (uint){\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        return platforms[platformName].publicKeys.length;\r\n    }\r\n\r\n    function publicKeys(bytes32 platformName) external view returns (address[]){\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        return platforms[platformName].publicKeys;\r\n    }\r\n\r\n    function voteProposal(bytes32 fromPlatform, address fromAccount, address toAccount, uint value, bytes32 tokenSymbol, string txid, bytes sig) external {\r\n\r\n        require(admin.status);\r\n\r\n        require(_existPlatform(fromPlatform));\r\n\r\n        bytes32 msgHash = hashMsg(fromPlatform, fromAccount, admin.platformName, toAccount, value, tokenSymbol, txid);\r\n\r\n        // address publicKey = ecrecover(msgHash, v, r, s);\r\n        address publicKey = recover(msgHash, sig);\r\n\r\n        require(_existPublicKey(fromPlatform, publicKey));\r\n\r\n        Proposal storage proposal = platforms[fromPlatform].proposals[txid];\r\n\r\n        if (proposal.value == 0) {\r\n\r\n            proposal.fromAccount = fromAccount;\r\n\r\n            proposal.toAccount = toAccount;\r\n\r\n            proposal.value = value;\r\n\r\n            proposal.tokenSymbol = tokenSymbol;\r\n        } else {\r\n\r\n            require(proposal.fromAccount == fromAccount && proposal.toAccount == toAccount && proposal.value == value && proposal.tokenSymbol == tokenSymbol);\r\n        }\r\n\r\n        changeVoters(fromPlatform, publicKey, txid);\r\n    }\r\n\r\n    function verifyProposal(bytes32 fromPlatform, address fromAccount, address toAccount, uint value, bytes32 tokenSymbol, string txid) external view returns (bool, bool) {\r\n\r\n        require(admin.status);\r\n\r\n        require(_existPlatform(fromPlatform));\r\n\r\n        Proposal storage proposal = platforms[fromPlatform].proposals[txid];\r\n\r\n        if (proposal.status) {\r\n\r\n            return (true, (proposal.voters.length >= proposal.weight));\r\n        }\r\n\r\n        if (proposal.value == 0) {\r\n\r\n            return (false, false);\r\n        }\r\n\r\n        require(proposal.fromAccount == fromAccount && proposal.toAccount == toAccount && proposal.value == value && proposal.tokenSymbol == tokenSymbol);\r\n\r\n        return (false, (proposal.voters.length >= platforms[fromPlatform].weight));\r\n    }\r\n\r\n    function commitProposal(bytes32 platformName, string txid) external returns (bool) {\r\n\r\n        require(admin.status);\r\n\r\n        require(_existCaller(msg.sender) || msg.sender == admin.account);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        require(!platforms[platformName].proposals[txid].status);\r\n\r\n        platforms[platformName].proposals[txid].status = true;\r\n\r\n        platforms[platformName].proposals[txid].weight = platforms[platformName].proposals[txid].voters.length;\r\n\r\n        return true;\r\n    }\r\n\r\n    function getProposal(bytes32 platformName, string txid) external view returns (bool status, address fromAccount, address toAccount, uint value, address[] voters, uint weight){\r\n\r\n        require(admin.status);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        fromAccount = platforms[platformName].proposals[txid].fromAccount;\r\n\r\n        toAccount = platforms[platformName].proposals[txid].toAccount;\r\n\r\n        value = platforms[platformName].proposals[txid].value;\r\n\r\n        voters = platforms[platformName].proposals[txid].voters;\r\n\r\n        status = platforms[platformName].proposals[txid].status;\r\n\r\n        weight = platforms[platformName].proposals[txid].weight;\r\n\r\n        return;\r\n    }\r\n\r\n    function deleteProposal(bytes32 platformName, string txid) external {\r\n\r\n        require(msg.sender == admin.account);\r\n\r\n        require(_existPlatform(platformName));\r\n\r\n        delete platforms[platformName].proposals[txid];\r\n    }\r\n\r\n    function transfer(address account, uint value) external payable {\r\n\r\n        require(admin.account == msg.sender);\r\n\r\n        require(account != address(0));\r\n\r\n        require(value > 0 && value >= address(this).balance);\r\n\r\n        this.transfer(account, value);\r\n    }\r\n\r\n    /**\r\n     *   ######################\r\n     *  #  private function  #\r\n     * ######################\r\n     */\r\n\r\n    function hashMsg(bytes32 fromPlatform, address fromAccount, bytes32 toPlatform, address toAccount, uint value, bytes32 tokenSymbol, string txid) internal pure returns (bytes32) {\r\n\r\n        return sha256(bytes32ToStr(fromPlatform), \":0x\", uintToStr(uint160(fromAccount), 16), \":\", bytes32ToStr(toPlatform), \":0x\", uintToStr(uint160(toAccount), 16), \":\", uintToStr(value, 10), \":\", bytes32ToStr(tokenSymbol), \":\", txid);\r\n    }\r\n\r\n    function changeVoters(bytes32 platformName, address publicKey, string txid) internal {\r\n\r\n        address[] storage voters = platforms[platformName].proposals[txid].voters;\r\n\r\n        bool change = true;\r\n\r\n        for (uint i = 0; i < voters.length; i++) {\r\n\r\n            if (voters[i] == publicKey) {\r\n\r\n                change = false;\r\n            }\r\n        }\r\n\r\n        if (change) {\r\n\r\n            voters.push(publicKey);\r\n        }\r\n    }\r\n\r\n    function bytes32ToStr(bytes32 b) internal pure returns (string) {\r\n\r\n        uint length = b.length;\r\n\r\n        for (uint i = 0; i < b.length; i++) {\r\n\r\n            if (b[b.length - 1 - i] == \"\") {\r\n\r\n                length -= 1;\r\n            } else {\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        bytes memory bs = new bytes(length);\r\n\r\n        for (uint j = 0; j < length; j++) {\r\n\r\n            bs[j] = b[j];\r\n        }\r\n\r\n        return string(bs);\r\n    }\r\n\r\n    function uintToStr(uint value, uint base) internal pure returns (string) {\r\n\r\n        uint _value = value;\r\n\r\n        uint length = 0;\r\n\r\n        bytes16 tenStr = \"0123456789abcdef\";\r\n\r\n        while (true) {\r\n\r\n            if (_value > 0) {\r\n\r\n                length ++;\r\n\r\n                _value = _value / base;\r\n            } else {\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (base == 16) {\r\n            length = 40;\r\n        }\r\n\r\n        bytes memory bs = new bytes(length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n\r\n            bs[length - 1 - i] = tenStr[value % base];\r\n\r\n            value = value / base;\r\n        }\r\n\r\n        return string(bs);\r\n    }\r\n\r\n    function _existCaller(address caller) internal view returns (bool) {\r\n\r\n        for (uint i = 0; i < callers.length; i++) {\r\n\r\n            if (callers[i] == caller) {\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function _existPlatform(bytes32 name) internal view returns (bool){\r\n\r\n        return platforms[name].status;\r\n    }\r\n\r\n    function _existPublicKey(bytes32 platformName, address publicKey) internal view returns (bool) {\r\n\r\n\r\n        address[] memory listOfPublicKey = platforms[platformName].publicKeys;\r\n\r\n        for (uint i = 0; i < listOfPublicKey.length; i++) {\r\n\r\n            if (listOfPublicKey[i] == publicKey) {\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes sig) internal pure returns (address) {\r\n\r\n        bytes32 r;\r\n\r\n        bytes32 s;\r\n\r\n        uint8 v;\r\n\r\n        assembly {\r\n\r\n            r := mload(add(sig, 32))\r\n\r\n            s := mload(add(sig, 64))\r\n\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        if (v < 27) {\r\n\r\n            v += 27;\r\n        }\r\n\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"toPlatform\",\"type\":\"bytes32\"},{\"name\":\"toAccount\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"txid\",\"type\":\"string\"},{\"name\":\"fromPlatform\",\"type\":\"bytes32\"},{\"name\":\"fromAccount\",\"type\":\"address\"},{\"name\":\"toAccount\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"setStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCompare\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getXCPlugin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setXCPlugin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"symbol\",\"type\":\"bytes2\"}],\"name\":\"setCompare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlatformName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"toPlatform\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"toAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenSymbol\",\"type\":\"bytes32\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"txid\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"fromPlatform\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"fromAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenSymbol\",\"type\":\"bytes32\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bytes32\"}],\"name\":\"Deposit\",\"type\":\"event\"}]","ContractName":"XC","CompilerVersion":"v0.4.22+commit.4cb486ee","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://54ed9cdae3f0b9d16bd5408870ae2626965e9d741fc0fdfdadc72f2ec1854ee2"}]}