{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\ncontract ERC223 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) public view returns (uint);\r\n  \r\n  function name() public view returns (string _name);\r\n  function symbol() public view returns (string _symbol);\r\n  function decimals() public view returns (uint8 _decimals);\r\n  function totalSupply() public view returns (uint256 _supply);\r\n\r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transfer(address to, uint value, bytes data) public returns (bool ok);\r\n  function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);\r\n  \r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ContractReceiver {\r\n     \r\n    struct TKN {\r\n        address sender;\r\n        uint value;\r\n        bytes data;\r\n        bytes4 sig;\r\n    }\r\n    \r\n    \r\n    function tokenFallback(address _from, uint _value, bytes _data) public pure {\r\n      TKN memory tkn;\r\n      tkn.sender = _from;\r\n      tkn.value = _value;\r\n      tkn.data = _data;\r\n      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n      tkn.sig = bytes4(u);\r\n      \r\n      /* tkn variable is analogue of msg variable of Ether transaction\r\n      *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\r\n      *  tkn.value the number of tokens that were sent   (analogue of msg.value)\r\n      *  tkn.data is data of token transaction   (analogue of msg.data)\r\n      *  tkn.sig is 4 bytes signature of function\r\n      *  if data of token transaction is a function execution\r\n      */\r\n    }\r\n}\r\n\r\ncontract StandardToken is ERC223 {\r\n    using SafeMath for uint;\r\n\r\n    //user token balances\r\n    mapping (address => uint) balances;\r\n    //token transer permissions\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {\r\n        if(isContract(_to)) {\r\n            if (balanceOf(msg.sender) < _value) revert();\r\n            balances[msg.sender] = balanceOf(msg.sender).sub(_value);\r\n            balances[_to] = balanceOf(_to).add(_value);\r\n            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return transferToAddress(_to, _value);\r\n        }\r\n    }\r\n    \r\n\r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool success) {\r\n          \r\n        if(isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        }\r\n        else {\r\n            return transferToAddress(_to, _value);\r\n        }\r\n    }\r\n      \r\n    // Standard function transfer similar to ERC20 transfer with no _data .\r\n    // Added due to backwards compatibility reasons .\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n          \r\n        //standard function transfer similar to ERC20 transfer with no _data\r\n        //added due to backwards compatibility reasons\r\n        bytes memory empty;\r\n        if(isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        }\r\n        else {\r\n            return transferToAddress(_to, _value);\r\n        }\r\n    }\r\n\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) private view returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n\r\n    //function that is called when transaction target is an address\r\n    function transferToAddress(address _to, uint _value) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) revert();\r\n        balances[msg.sender] = balanceOf(msg.sender).sub(_value);\r\n        balances[_to] = balanceOf(_to).add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n      \r\n      //function that is called when transaction target is a contract\r\n      function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) revert();\r\n        balances[msg.sender] = balanceOf(msg.sender).sub(_value);\r\n        balances[_to] = balanceOf(_to).add(_value);\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Token transfer from from to _to (permission needed)\r\n     */\r\n    function transferFrom(\r\n        address _from, \r\n        address _to,\r\n        uint _value\r\n    ) \r\n        public \r\n        returns (bool)\r\n    {\r\n        if (balanceOf(_from) < _value && allowance(_from, msg.sender) < _value) revert();\r\n\r\n        bytes memory empty;\r\n        balances[_to] = balanceOf(_to).add(_value);\r\n        balances[_from] = balanceOf(_from).sub(_value);\r\n        allowed[_from][msg.sender] = allowance(_from, msg.sender).sub(_value);\r\n        if (isContract(_to)) {\r\n            ContractReceiver receiver = ContractReceiver(_to);\r\n            receiver.tokenFallback(msg.sender, _value, empty);\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Increase permission for transfer\r\n     */\r\n    function increaseApproval(\r\n        address spender,\r\n        uint value\r\n    )\r\n        public\r\n        returns (bool) \r\n    {\r\n        allowed[msg.sender][spender] = allowed[msg.sender][spender].add(value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Decrease permission for transfer\r\n     */\r\n    function decreaseApproval(\r\n        address spender,\r\n        uint value\r\n    )\r\n        public\r\n        returns (bool) \r\n    {\r\n        allowed[msg.sender][spender] = allowed[msg.sender][spender].add(value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * User token balance\r\n     */\r\n    function balanceOf(\r\n        address owner\r\n    ) \r\n        public \r\n        constant \r\n        returns (uint) \r\n    {\r\n        return balances[owner];\r\n    }\r\n\r\n    /**\r\n     * User transfer permission\r\n     */\r\n    function allowance(\r\n        address owner, \r\n        address spender\r\n    )\r\n        public\r\n        constant\r\n        returns (uint remaining)\r\n    {\r\n        return allowed[owner][spender];\r\n    }\r\n}\r\n\r\ncontract MyDFSToken is StandardToken {\r\n\r\n    string public name = \"MyDFS Token\";\r\n    uint8 public decimals = 6;\r\n    string public symbol = \"MyDFS\";\r\n    string public version = 'H1.0';\r\n    uint256 public totalSupply;\r\n\r\n    function () external {\r\n        revert();\r\n    } \r\n\r\n    function MyDFSToken() public {\r\n        totalSupply = 125 * 1e12;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n\r\n    // Function to access name of token .\r\n    function name() public view returns (string _name) {\r\n        return name;\r\n    }\r\n    // Function to access symbol of token .\r\n    function symbol() public view returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n    // Function to access decimals of token .\r\n    function decimals() public view returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n    // Function to access total supply of tokens .\r\n    function totalSupply() public view returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed _by, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() { require(msg.sender == owner); _;}\r\n\r\n    /// Proposes to transfer control of the contract to a newOwnerCandidate.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    function transferOwnership(address _newOwnerCandidate) external onlyOwner {\r\n        require(_newOwnerCandidate != address(0));\r\n\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// Accept ownership transfer. This method needs to be called by the perviously proposed owner.\r\n    function acceptOwnership() external {\r\n        if (msg.sender == newOwnerCandidate) {\r\n            owner = newOwnerCandidate;\r\n            newOwnerCandidate = address(0);\r\n\r\n            OwnershipTransferred(owner, newOwnerCandidate);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DevTokensHolder is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 collectedTokens;\r\n    GenericCrowdsale crowdsale;\r\n    MyDFSToken token;\r\n\r\n    event ClaimedTokens(address token, uint256 amount);\r\n    event TokensWithdrawn(address holder, uint256 amount);\r\n    event Debug(uint256 amount);\r\n\r\n    function DevTokensHolder(address _crowdsale, address _token, address _owner) public {\r\n        crowdsale = GenericCrowdsale(_crowdsale);\r\n        token = MyDFSToken(_token);\r\n        owner = _owner;\r\n    }\r\n\r\n    function tokenFallback(\r\n        address _from, \r\n        uint _value, \r\n        bytes _data\r\n    ) \r\n        public \r\n        view \r\n    {\r\n        require(_from == owner || _from == address(crowdsale));\r\n        require(_value > 0 || _data.length > 0);\r\n    }\r\n\r\n    /// @notice The Dev (Owner) will call this method to extract the tokens\r\n    function collectTokens() public onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        uint256 total = collectedTokens.add(balance);\r\n\r\n        uint256 finalizedTime = crowdsale.finishTime();\r\n        require(finalizedTime > 0 && getTime() > finalizedTime.add(14 days));\r\n\r\n        uint256 canExtract = total.mul(getTime().sub(finalizedTime)).div(months(12));\r\n        canExtract = canExtract.sub(collectedTokens);\r\n\r\n        if (canExtract > balance) {\r\n            canExtract = balance;\r\n        }\r\n\r\n        collectedTokens = collectedTokens.add(canExtract);\r\n        require(token.transfer(owner, canExtract));\r\n        TokensWithdrawn(owner, canExtract);\r\n    }\r\n\r\n    function months(uint256 m) internal pure returns (uint256) {\r\n        return m.mul(30 days);\r\n    }\r\n\r\n    function getTime() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    //////////\r\n    // Safety Methods\r\n    //////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyOwner {\r\n        require(_token != address(token));\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        token = MyDFSToken(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, balance);\r\n    }\r\n}\r\n\r\ncontract AdvisorsTokensHolder is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    GenericCrowdsale crowdsale;\r\n    MyDFSToken token;\r\n\r\n    event ClaimedTokens(address token, uint256 amount);\r\n    event TokensWithdrawn(address holder, uint256 amount);\r\n\r\n    function AdvisorsTokensHolder(address _crowdsale, address _token, address _owner) public {\r\n        crowdsale = GenericCrowdsale(_crowdsale);\r\n        token = MyDFSToken(_token);\r\n        owner = _owner;\r\n    }\r\n\r\n    function tokenFallback(\r\n        address _from, \r\n        uint _value, \r\n        bytes _data\r\n    ) \r\n        public \r\n        view \r\n    {\r\n        require(_from == owner || _from == address(crowdsale));\r\n        require(_value > 0 || _data.length > 0);\r\n    }\r\n\r\n    /// @notice The Dev (Owner) will call this method to extract the tokens\r\n    function collectTokens() public onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance > 0);\r\n\r\n        uint256 finalizedTime = crowdsale.finishTime();\r\n        require(finalizedTime > 0 && getTime() > finalizedTime.add(14 days));\r\n\r\n        require(token.transfer(owner, balance));\r\n        TokensWithdrawn(owner, balance);\r\n    }\r\n\r\n    function getTime() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    //////////\r\n    // Safety Methods\r\n    //////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyOwner {\r\n        require(_token != address(token));\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        token = MyDFSToken(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, balance);\r\n    }\r\n}\r\n\r\ncontract GenericCrowdsale is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    //Crowrdsale states\r\n    enum State { Initialized, PreIco, PreIcoFinished, Ico, IcoFinished}\r\n\r\n    struct Discount {\r\n        uint256 amount;\r\n        uint256 value;\r\n    }\r\n\r\n    //ether trasfered to\r\n    address public beneficiary;\r\n    //Crowrdsale state\r\n    State public state;\r\n    //Hard goal in Wei\r\n    uint public hardFundingGoal;\r\n    //soft goal in Wei\r\n    uint public softFundingGoal;\r\n    //gathered Ether amount in Wei\r\n    uint public amountRaised;\r\n    //ICO/PreICO start timestamp in seconds\r\n    uint public started;\r\n    //Crowdsale finish time\r\n    uint public finishTime;\r\n    //price for 1 token in Wei\r\n    uint public price;\r\n    //minimum purchase value in Wei\r\n    uint public minPurchase;\r\n    //Token cantract\r\n    ERC223 public tokenReward;\r\n    //Wei balances for refund if ICO failed\r\n    mapping(address => uint256) public balances;\r\n\r\n    //Emergency stop sell\r\n    bool emergencyPaused = false;\r\n    //Soft cap reached\r\n    bool softCapReached = false;\r\n    //dev holder\r\n    DevTokensHolder public devTokensHolder;\r\n    //advisors holder\r\n    AdvisorsTokensHolder public advisorsTokensHolder;\r\n    \r\n    //Disconts\r\n    Discount[] public discounts;\r\n\r\n    //price overhead for next stages\r\n    uint8[2] public preIcoTokenPrice = [70,75];\r\n    //price overhead for next stages\r\n    uint8[4] public icoTokenPrice = [100,120,125,130];\r\n\r\n    event TokenPurchased(address investor, uint sum, uint tokensCount, uint discountTokens);\r\n    event PreIcoLimitReached(uint totalAmountRaised);\r\n    event SoftGoalReached(uint totalAmountRaised);\r\n    event HardGoalReached(uint totalAmountRaised);\r\n    event Debug(uint num);\r\n\r\n    //Sale is active\r\n    modifier sellActive() { \r\n        require(\r\n            !emergencyPaused \r\n            && (state == State.PreIco || state == State.Ico)\r\n            && amountRaised < hardFundingGoal\r\n        );\r\n    _; }\r\n    //Soft cap not reached\r\n    modifier goalNotReached() { require(state == State.IcoFinished && amountRaised < softFundingGoal); _; }\r\n\r\n    /**\r\n     * Constrctor function\r\n     */\r\n    function GenericCrowdsale(\r\n        address ifSuccessfulSendTo,\r\n        address addressOfTokenUsedAsReward\r\n    ) public {\r\n        require(ifSuccessfulSendTo != address(0) \r\n            && addressOfTokenUsedAsReward != address(0));\r\n        beneficiary = ifSuccessfulSendTo;\r\n        tokenReward = ERC223(addressOfTokenUsedAsReward);\r\n        state = State.Initialized;\r\n    }\r\n\r\n    function tokenFallback(\r\n        address _from, \r\n        uint _value, \r\n        bytes _data\r\n    ) \r\n        public \r\n        view \r\n    {\r\n        require(_from == owner);\r\n        require(_value > 0 || _data.length > 0);\r\n    }\r\n\r\n    /**\r\n     * Start PreICO\r\n     */\r\n    function preIco(\r\n        uint hardFundingGoalInEthers,\r\n        uint minPurchaseInFinney,\r\n        uint costOfEachToken,\r\n        uint256[] discountEthers,\r\n        uint256[] discountValues\r\n    ) \r\n        external \r\n        onlyOwner \r\n    {\r\n        require(hardFundingGoalInEthers > 0\r\n            && costOfEachToken > 0\r\n            && state == State.Initialized\r\n            && discountEthers.length == discountValues.length);\r\n\r\n        hardFundingGoal = hardFundingGoalInEthers.mul(1 ether);\r\n        minPurchase = minPurchaseInFinney.mul(1 finney);\r\n        price = costOfEachToken;\r\n        initDiscounts(discountEthers, discountValues);\r\n        state = State.PreIco;\r\n        started = now;\r\n    }\r\n\r\n    /**\r\n     * Start ICO\r\n     */\r\n    function ico(\r\n        uint softFundingGoalInEthers,\r\n        uint hardFundingGoalInEthers,\r\n        uint minPurchaseInFinney,\r\n        uint costOfEachToken,\r\n        uint256[] discountEthers,\r\n        uint256[] discountValues\r\n    ) \r\n        external\r\n        onlyOwner\r\n    {\r\n        require(softFundingGoalInEthers > 0\r\n            && hardFundingGoalInEthers > 0\r\n            && hardFundingGoalInEthers > softFundingGoalInEthers\r\n            && costOfEachToken > 0\r\n            && state < State.Ico\r\n            && discountEthers.length == discountValues.length);\r\n\r\n        softFundingGoal = softFundingGoalInEthers.mul(1 ether);\r\n        hardFundingGoal = hardFundingGoalInEthers.mul(1 ether);\r\n        minPurchase = minPurchaseInFinney.mul(1 finney);\r\n        price = costOfEachToken;\r\n        delete discounts;\r\n        initDiscounts(discountEthers, discountValues);\r\n        state = State.Ico;\r\n        started = now;\r\n    }\r\n\r\n    /**\r\n     * Finish ICO / PreICO\r\n     */\r\n    function finishSale() external onlyOwner {\r\n        require(state == State.PreIco || state == State.Ico);\r\n        \r\n        if (state == State.PreIco)\r\n            state = State.PreIcoFinished;\r\n        else\r\n            state = State.IcoFinished;\r\n    }\r\n\r\n    /**\r\n     * Admin can pause token sell\r\n     */\r\n    function emergencyPause() external onlyOwner {\r\n        emergencyPaused = true;\r\n    }\r\n\r\n    /**\r\n     * Admin can unpause token sell\r\n     */\r\n    function emergencyUnpause() external onlyOwner {\r\n        emergencyPaused = false;\r\n    }\r\n\r\n    /**\r\n     * Transfer dev tokens to vesting wallet\r\n     */\r\n    function sendDevTokens() external onlyOwner returns(address) {\r\n        require(successed());\r\n\r\n        devTokensHolder = new DevTokensHolder(address(this), address(tokenReward), owner);\r\n        tokenReward.transfer(address(devTokensHolder), 12500 * 1e9);\r\n        return address(devTokensHolder);\r\n    }\r\n\r\n    /**\r\n     * Transfer dev tokens to vesting wallet\r\n     */\r\n    function sendAdvisorsTokens() external onlyOwner returns(address) {\r\n        require(successed());\r\n\r\n        advisorsTokensHolder = new AdvisorsTokensHolder(address(this), address(tokenReward), owner);\r\n        tokenReward.transfer(address(advisorsTokensHolder), 12500 * 1e9);\r\n        return address(advisorsTokensHolder);\r\n    }\r\n\r\n    /**\r\n     * Admin can withdraw ether beneficiary address\r\n     */\r\n    function withdrawFunding() external onlyOwner {\r\n        require((state == State.PreIco || successed()));\r\n        beneficiary.transfer(this.balance);\r\n    }\r\n\r\n    /**\r\n     * Different coins purchase\r\n     */\r\n    function foreignPurchase(address user, uint256 amount)\r\n        external\r\n        onlyOwner\r\n        sellActive\r\n    {\r\n        buyTokens(user, amount);\r\n        checkGoals();\r\n    }\r\n\r\n    /**\r\n     * Claim refund ether in soft goal not reached \r\n     */\r\n    function claimRefund() \r\n        external \r\n        goalNotReached \r\n    {\r\n        uint256 amount = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n        if (amount > 0){\r\n            if (!msg.sender.send(amount)) {\r\n                balances[msg.sender] = amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Payment transaction\r\n     */\r\n    function () \r\n        external \r\n        payable \r\n        sellActive\r\n    {\r\n        require(msg.value > 0);\r\n        require(msg.value >= minPurchase);\r\n        uint amount = msg.value;\r\n        if (amount > hardFundingGoal.sub(amountRaised)) {\r\n            uint availableAmount = hardFundingGoal.sub(amountRaised);\r\n            msg.sender.transfer(amount.sub(availableAmount));\r\n            amount = availableAmount;\r\n        }\r\n\r\n        buyTokens(msg.sender,  amount);\r\n        checkGoals();\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens to user\r\n     */\r\n    function buyTokens(\r\n        address user,\r\n        uint256 amount\r\n    ) internal {\r\n        require(amount <= hardFundingGoal.sub(amountRaised));\r\n\r\n        uint256 passedSeconds = getTime().sub(started);\r\n        uint256 week = 0;\r\n        if (passedSeconds >= 604800){\r\n            week = passedSeconds.div(604800);\r\n        }\r\n        Debug(week);\r\n\r\n        uint256 tokenPrice;\r\n        if (state == State.Ico){\r\n            uint256 cup = amountRaised.mul(4).div(hardFundingGoal);\r\n            if (cup > week)\r\n                week = cup;\r\n            if (week >= 4)\r\n                 week = 3;\r\n            tokenPrice = price.mul(icoTokenPrice[week]).div(100);\r\n        } else {\r\n            if (week >= 2)\r\n                 week = 1;\r\n            tokenPrice = price.mul(preIcoTokenPrice[week]).div(100);\r\n        }\r\n\r\n        Debug(tokenPrice);\r\n\r\n        uint256 count = amount.div(tokenPrice);\r\n        uint256 discount = getDiscountOf(amount);\r\n        uint256 discountBonus = discount.mul(count).div(100);\r\n        count = count.add(discountBonus);\r\n        count = ceilTokens(count);\r\n\r\n        require(tokenReward.transfer(user, count));\r\n        balances[user] = balances[user].add(amount);\r\n        amountRaised = amountRaised.add(amount);\r\n        TokenPurchased(user, amount, count, discountBonus);\r\n    }\r\n\r\n    /**\r\n     * Define distount percents for different token amounts\r\n     */\r\n    function ceilTokens(\r\n        uint256 num\r\n    ) \r\n        public\r\n        pure\r\n        returns(uint256) \r\n    {\r\n        uint256 part = num % 1000000;\r\n        return part > 0 ? num.div(1000000).mul(1000000) + 1000000 : num;\r\n    }\r\n\r\n    /**\r\n     * ICO is finished successfully\r\n     */\r\n    function successed() \r\n        public \r\n        view \r\n        returns(bool) \r\n    {\r\n        return state == State.IcoFinished && amountRaised >= softFundingGoal;\r\n    }\r\n\r\n    /**\r\n     * Define distount percents for different token amounts\r\n     */\r\n    function initDiscounts(\r\n        uint256[] discountEthers,\r\n        uint256[] discountValues\r\n    ) internal {\r\n        for (uint256 i = 0; i < discountEthers.length; i++) {\r\n            discounts.push(Discount(discountEthers[i].mul(1 ether), discountValues[i]));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get discount percent for number of tokens\r\n     */\r\n    function getDiscountOf(\r\n        uint256 _amount\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (discounts.length > 0)\r\n            for (uint256 i = 0; i < discounts.length; i++) {\r\n                if (_amount >= discounts[i].amount) {\r\n                    return discounts[i].value;\r\n                }\r\n            }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Check ICO goals achievement\r\n     */\r\n    function checkGoals() internal {\r\n        if (state == State.PreIco) {\r\n            if (amountRaised >= hardFundingGoal) {\r\n                PreIcoLimitReached(amountRaised);\r\n                state = State.PreIcoFinished;\r\n            }\r\n        } else {\r\n            if (!softCapReached && amountRaised >= softFundingGoal){\r\n                softCapReached = true;\r\n                SoftGoalReached(amountRaised);\r\n            }\r\n            if (amountRaised >= hardFundingGoal) {\r\n                finishTime = now;\r\n                HardGoalReached(amountRaised);\r\n                state = State.IcoFinished;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTime() internal view returns (uint) {\r\n        return now;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hardFundingGoalInEthers\",\"type\":\"uint256\"},{\"name\":\"minPurchaseInFinney\",\"type\":\"uint256\"},{\"name\":\"costOfEachToken\",\"type\":\"uint256\"},{\"name\":\"discountEthers\",\"type\":\"uint256[]\"},{\"name\":\"discountValues\",\"type\":\"uint256[]\"}],\"name\":\"preIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"ceilTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"softFundingGoalInEthers\",\"type\":\"uint256\"},{\"name\":\"hardFundingGoalInEthers\",\"type\":\"uint256\"},{\"name\":\"minPurchaseInFinney\",\"type\":\"uint256\"},{\"name\":\"costOfEachToken\",\"type\":\"uint256\"},{\"name\":\"discountEthers\",\"type\":\"uint256[]\"},{\"name\":\"discountValues\",\"type\":\"uint256[]\"}],\"name\":\"ico\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"preIcoTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"icoTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyUnpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"foreignPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finishTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTokensHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorsTokensHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendAdvisorsTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"successed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"discounts\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getDiscountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendDevTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardFundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softFundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ifSuccessfulSendTo\",\"type\":\"address\"},{\"name\":\"addressOfTokenUsedAsReward\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"discountTokens\",\"type\":\"uint256\"}],\"name\":\"TokenPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"totalAmountRaised\",\"type\":\"uint256\"}],\"name\":\"PreIcoLimitReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"totalAmountRaised\",\"type\":\"uint256\"}],\"name\":\"SoftGoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"totalAmountRaised\",\"type\":\"uint256\"}],\"name\":\"HardGoalReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"Debug\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"GenericCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007c1d56a4cc68440c124ab04cbd917fa869097f63000000000000000000000000d184b10ee51be2c6bf45214b048f311a15296cae","Library":"","SwarmSource":"bzzr://e3c85b6dfa4c20ae31317cbe8254281d393ba5c1d99f409078fb9254c6551ebf"}]}