{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n    \r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function safeDiv(uint a, uint b) internal pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n    \r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n    \r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) \r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n    \r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n    \r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n }\r\n \r\n /**\r\n * Date and Time utilities for ethereum contracts\r\n */\r\n contract DateTime {\r\n\r\n        struct _DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) internal pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) internal pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n\r\n                // Minute\r\n                dt.minute = getMinute(timestamp);\r\n\r\n                // Second\r\n                dt.second = getSecond(timestamp);\r\n\r\n                // Day of week.\r\n                dt.weekday = getWeekday(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) internal pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) internal pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) internal pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) internal pure returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n\r\n        function getMinute(uint timestamp) internal pure returns (uint8) {\r\n                return uint8((timestamp / 60) % 60);\r\n        }\r\n\r\n        function getSecond(uint timestamp) internal pure returns (uint8) {\r\n                return uint8(timestamp % 60);\r\n        }\r\n\r\n        function getWeekday(uint timestamp) internal pure returns (uint8) {\r\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, 0, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) internal pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) internal pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, minute, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal pure returns (uint timestamp) {\r\n                uint16 i;\r\n\r\n                // Year\r\n                for (i = ORIGIN_YEAR; i < year; i++) {\r\n                        if (isLeapYear(i)) {\r\n                                timestamp += LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                timestamp += YEAR_IN_SECONDS;\r\n                        }\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                for (i = 1; i < month; i++) {\r\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n                }\r\n\r\n                // Day\r\n                timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n                // Hour\r\n                timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n                // Minute\r\n                timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n                // Second\r\n                timestamp += second;\r\n\r\n                return timestamp;\r\n        }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint256);\r\n    function balanceOf(address _owner) public constant returns (uint);\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n    function approve(address _spender, uint _value) public returns (bool);\r\n    function allowance(address _owner, address _spender) public constant returns (uint);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n} \r\n \r\n\r\ncontract EdgeSmartToken is ERC20, SafeMath, DateTime {\r\n\r\n    uint256  public constant _decimals = 18;\r\n    uint256 public constant _totalSupply = (100000000 * 10**_decimals);\r\n    \r\n    string public constant symbol = 'EDUX';\r\n    string public constant name = 'Edgecoin Smart Token';\r\n    \r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) approved;\r\n    address EdgeSmartTokenOwner;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == EdgeSmartTokenOwner);\r\n        _;\r\n    }    \r\n    \r\n    constructor() public {\r\n        EdgeSmartTokenOwner = msg.sender;\r\n        balances[EdgeSmartTokenOwner] = _totalSupply;\r\n    }\r\n   \r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != EdgeSmartTokenOwner);      \r\n        EdgeSmartTokenOwner = newOwner;\r\n    }    \r\n    \r\n\r\n    function decimals() public pure returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer self tokens to given address\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send\r\n     * @notice `_value` tokens will be sended to `_to`\r\n     * @return `true` when transfer done\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(\r\n            balances[msg.sender] >= _value && _value > 0\r\n        );\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer with approvement mechainsm\r\n     * @param _from source address, `_value` tokens shold be approved for `sender`\r\n     * @param _to destination address\r\n     * @param _value amount of token values to send\r\n     * @notice from `_from` will be sended `_value` tokens to `_to`\r\n     * @return `true` when transfer is done\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(\r\n            approved[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0\r\n        );\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        approved[_from][msg.sender] = safeSub(approved[_from][msg.sender], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Give to target address ability for self token manipulation without sending\r\n     * @param _spender target address (future requester)\r\n     * @param _value amount of token values for approving\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        approved[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Reset count of tokens approved for given address\r\n     * @param _spender target address (future requester)\r\n     */\r\n    function unapprove(address _spender) public { \r\n        approved[msg.sender][_spender] = 0; \r\n    }\r\n\r\n    /**\r\n     * @dev Take allowed tokens\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n        return approved[_owner][_spender];\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Edgecoin is SafeMath, DateTime, EdgeSmartToken {\r\n    \r\n    address owner; \r\n    uint private totalCollected = 0;\r\n    uint private preSaleCollected = 0;\r\n    uint private ICOCollected = 0;\r\n    \r\n    uint256 public totalTokensCap = (50000000 * 10**_decimals); //50% of total supply\r\n    uint public preSaleTokensLimit = (10000000 * 10**_decimals); //10% of total supply\r\n    \r\n    uint256 public icoSaleSoftCap = (5000000 * 10**_decimals); //5mio EDUX or 1000 ETH\r\n    uint public icoSaleHardCap = (25000000 * 10**_decimals);//25mio EDUX or 5000 ETH\r\n   \r\n    uint256 private preSaleTokenPrice = (10000 * 10**_decimals); //10k\r\n    uint256 private ICOTokenPrice = (5000 * 10**_decimals); //5k\r\n   \r\n    bool ICOActive = true;\r\n   \r\n    uint pre_ICO_end_date = toTimestamp(2017, 12, 6, 20, 0);\r\n   \r\n    uint ICO_end_date = toTimestamp(2018, 1, 1, 20, 0); \r\n    \r\n    //since ICO date and period are not defined precisely, lets put hardcoded end date \r\n    uint ICO_hardcoded_expiry_date = toTimestamp(2019, 1, 1, 20, 0); \r\n   \r\n    uint256 private tokensToBuy;\r\n    \r\n    //multisig withdrawal part\r\n    mapping (address => bool) private isOwner; // immutable state\r\n    mapping (address => bool) private isConfirmed; // immutable state\r\n    mapping (uint => address) private ownersArr; // immutable state\r\n    uint public nonce;                // (only) mutable state\r\n    uint public threshold = 3;            // immutable state\r\n    uint public pendingAmount;\r\n    address public pendingAddress;\r\n    uint public confirmedTimesByOwners = 0;\r\n    //multisig ended\r\n\r\n    constructor() public {\r\n       owner = msg.sender;\r\n       isOwner[0x512B431fc06855C8418495ffcc570D246B654f6E] = true; //am\r\n       isOwner[0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48] = true; //kj\r\n       isOwner[0x9016f6fb21F454F294A78AdeFbD700f4B6795C91] = true; //aw\r\n       \r\n       ownersArr[0] = 0x512B431fc06855C8418495ffcc570D246B654f6E;\r\n       ownersArr[2] = 0xb43d2a6fEFEF1260F772EDa4eF4341044C494b48;\r\n       ownersArr[3] = 0x9016f6fb21F454F294A78AdeFbD700f4B6795C91;\r\n       \r\n       //migrated from first version of ICO contract, addr 0x25992f65334b5d23096b912af089ac454c3aabb6\r\n       totalCollected = 366536727590000000000000;\r\n       preSaleCollected = 265029930140000000000000;\r\n       ICOCollected = 101506797450000000000000;\r\n    }\r\n   \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwners() {\r\n        require(isOwner[msg.sender] == true);\r\n        _;\r\n    }\r\n    \r\n    function initiateWithdrawal(address destination, uint value) public onlyOwners {\r\n        confirmedTimesByOwners = 0;\r\n        for (uint j = 0; j < threshold; j++) {\r\n            isConfirmed[ownersArr[j]] = false;\r\n        }  \r\n            \r\n        pendingAmount = value;\r\n        pendingAddress = destination;\r\n\r\n        isConfirmed[msg.sender] = true;\r\n        confirmedTimesByOwners++;\r\n    }\r\n\r\n    function confirmAndExecuteWithdrawal() public onlyOwners payable {\r\n        isConfirmed[msg.sender] = true;\r\n        for (uint i = 0; i < threshold; i++) {\r\n            if (isConfirmed[ownersArr[i]]) {\r\n                confirmedTimesByOwners++;\r\n            }\r\n        }\r\n      \r\n        if (confirmedTimesByOwners >= (threshold-1) ) { // 2/3 or 3/3\r\n            nonce = nonce + 1;\r\n            pendingAddress.transfer(pendingAmount);\r\n\r\n            //reset withdrawal data\r\n            pendingAmount = 0;\r\n            pendingAddress = 0x0;\r\n            confirmedTimesByOwners = 0;\r\n        \r\n            for (uint j = 0; j < threshold; j++) {\r\n                isConfirmed[ownersArr[j]] = false;\r\n            }  \r\n        }\r\n    }\r\n    \r\n    function getTotalTokensSold() public constant returns (uint) {\r\n        return totalCollected;\r\n    }\r\n    \r\n    function getPreSaleTokensSold() public constant returns (uint) {\r\n        return preSaleCollected;\r\n    } \r\n    \r\n    function getIcoTokensSold() public constant returns (uint) {\r\n        return ICOCollected;\r\n    }    \r\n\r\n    function setICOStatus(bool status) onlyOwner public {\r\n        ICOActive = status;\r\n    }\r\n\r\n    function () public payable {\r\n        createTokens(msg.sender);\r\n    }\r\n    \r\n    function createTokens(address recipient) public payable {\r\n        \r\n        if (ICOActive && (now < ICO_hardcoded_expiry_date)) {\r\n            require(msg.value >= 0.1 * (1 ether)); //minimum 0.1 ETH\r\n            tokensToBuy = safeDiv(safeMul(msg.value * 1 ether, ICOTokenPrice), 1000000000000000000 ether);\r\n            require (totalCollected + tokensToBuy <= totalTokensCap); //max sell 50mio, 40mio + rest from preSale\r\n            ICOCollected = safeAdd(ICOCollected, tokensToBuy);\r\n            totalCollected = safeAdd(totalCollected, tokensToBuy);\r\n            \r\n            balances[recipient] = safeAdd(balances[recipient], tokensToBuy);\r\n            balances[owner] = safeSub(balances[owner], tokensToBuy);\r\n            emit Transfer(owner, recipient, tokensToBuy);\r\n        }\r\n        else  {\r\n            revert(\"Edgecoin ICO has ended.\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"preSaleTokensLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoSaleHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPreSaleTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmAndExecuteWithdrawal\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setICOStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"confirmedTimesByOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoSaleSoftCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIcoTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"initiateWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"unapprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Edgecoin","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3b07121cfb0b5e81ab158785b02a8b053f22c7ba99b6d69761244f38338eb8a2"}]}