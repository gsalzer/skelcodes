{"status":"1","message":"OK","result":[{"SourceCode":"/*   \r\n *    Exodus adaptation of OasisDirectProxy by MakerDAO.\r\n *    Edited by Konnor Klashinsky (kklash).\r\n *    Work in progress, first Mainnet iteration.\r\n */\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract OtcInterface {\r\n    function sellAllAmount(address, uint, address, uint) public returns (uint);\r\n    function buyAllAmount(address, uint, address, uint) public returns (uint);\r\n    function getPayAmount(address, address, uint) public constant returns (uint);\r\n}\r\n\r\ncontract TokenInterface {\r\n    function balanceOf(address) public returns (uint);\r\n    function allowance(address, address) public returns (uint);\r\n    function approve(address, uint) public;\r\n    function transfer(address,uint) public returns (bool);\r\n    function transferFrom(address, address, uint) public returns (bool);\r\n    function deposit() public payable;\r\n    function withdraw(uint) public;\r\n}\r\n\r\ncontract Control {\r\n/* TODO: convert to DSAuth if needed */\r\n    address owner;\r\n    \r\n    modifier auth {\r\n         require(msg.sender == owner);\r\n         _; /* func body goes here */\r\n    }\r\n\r\n    function withdrawTo(address _to, uint amt) public auth {\r\n        _to.transfer(amt);\r\n    }\r\n    \r\n    function withdrawTokenTo(TokenInterface token, address _to, uint amt) public auth {\r\n        require(token.transfer(_to, amt));\r\n    }\r\n\r\n    function kill() public auth {\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\ncontract OasisDirectProxy is Control, DSMath {\r\n    uint feePercentageWad;\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n        feePercentageWad = 0.01 ether; /* set initial fee to 1% */\r\n    }\r\n\r\n    function newFee(uint newFeePercentageWad) public auth {\r\n        require(newFeePercentageWad <= 1 ether);\r\n        feePercentageWad = newFeePercentageWad;\r\n    }\r\n\r\n    function takeFee(uint amt) public view returns (uint fee, uint remaining) {\r\n       /* shave the fee off of an amount */\r\n        fee = wmul(amt*WAD, feePercentageWad) / WAD;\r\n        remaining = sub(amt, fee);\r\n    }\r\n    \r\n    function withdrawAndSend(TokenInterface wethToken, uint wethAmt) internal {\r\n        wethToken.withdraw(wethAmt);\r\n        require(msg.sender.call.value(wethAmt)());\r\n    }\r\n    \r\n    function sellAllAmount(\r\n        OtcInterface otc,\r\n        TokenInterface payToken, \r\n        uint payAmt, \r\n        TokenInterface buyToken, \r\n        uint minBuyAmt\r\n    ) public returns (uint) {\r\n        require(payToken.transferFrom(msg.sender, this, payAmt));\r\n        if (payToken.allowance(this, otc) < payAmt) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        uint buyAmt = otc.sellAllAmount(payToken, payAmt, buyToken, minBuyAmt);\r\n        (uint feeAmt, uint buyAmtRemainder) = takeFee(buyAmt);\r\n        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\r\n        require(buyToken.transfer(msg.sender, buyAmtRemainder));\r\n        return buyAmtRemainder;\r\n    }\r\n\r\n    function sellAllAmountPayEth(\r\n        OtcInterface otc,\r\n        TokenInterface wethToken,\r\n        TokenInterface buyToken,\r\n        uint minBuyAmt\r\n    ) public payable returns (uint) {\r\n        wethToken.deposit.value(msg.value)();\r\n        if (wethToken.allowance(this, otc) < msg.value) {\r\n            wethToken.approve(otc, uint(-1));\r\n        }\r\n        uint buyAmt = otc.sellAllAmount(wethToken, msg.value, buyToken, minBuyAmt);\r\n        (uint feeAmt, uint buyAmtRemainder) = takeFee(buyAmt);\r\n        require(buyToken.transfer(owner, feeAmt)); /* fee is taken */\r\n        require(buyToken.transfer(msg.sender, buyAmtRemainder));\r\n        return buyAmtRemainder;\r\n    }\r\n\r\n    function sellAllAmountBuyEth(\r\n        OtcInterface otc,\r\n        TokenInterface payToken, \r\n        uint payAmt, \r\n        TokenInterface wethToken, \r\n        uint minBuyAmt\r\n    ) public returns (uint) {\r\n        require(payToken.transferFrom(msg.sender, this, payAmt));\r\n        if (payToken.allowance(this, otc) < payAmt) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        uint wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt);\r\n        (uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt);\r\n        require(wethToken.transfer(owner, feeAmt)); /* fee is taken in WETH */ \r\n        withdrawAndSend(wethToken, wethAmtRemainder);\r\n        return wethAmtRemainder;\r\n    }\r\n\r\n    function buyAllAmount(\r\n        OtcInterface otc, \r\n        TokenInterface buyToken, \r\n        uint buyAmt, \r\n        TokenInterface payToken, \r\n        uint maxPayAmt\r\n    ) public returns (uint payAmt) {\r\n        uint payAmtNow = otc.getPayAmount(payToken, buyToken, buyAmt);\r\n        require(payAmtNow <= maxPayAmt);\r\n        require(payToken.transferFrom(msg.sender, this, payAmtNow));\r\n        if (payToken.allowance(this, otc) < payAmtNow) {\r\n            payToken.approve(otc, uint(-1));\r\n        } \r\n        payAmt = otc.buyAllAmount(buyToken, buyAmt, payToken, payAmtNow);\r\n        require(buyToken.transfer(msg.sender, min(buyAmt, buyToken.balanceOf(this)))); // To avoid rounding issues we check the minimum value\r\n                                /* TODO: Find out what this is for, before touching it */\r\n    }\r\n\r\n    function buyAllAmountPayEth(\r\n        OtcInterface otc, \r\n        TokenInterface buyToken, \r\n        uint buyAmt, \r\n        TokenInterface wethToken\r\n    ) public payable returns (uint wethAmt) {\r\n        // In this case user needs to send more ETH than a estimated value, then contract will send back the rest\r\n        wethToken.deposit.value(msg.value)();\r\n        if (wethToken.allowance(this, otc) < msg.value) {\r\n            wethToken.approve(otc, uint(-1));\r\n        }\r\n        wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value);\r\n        require(buyToken.transfer(msg.sender, min(buyAmt, buyToken.balanceOf(this)))); // To avoid rounding issues we check the minimum value\r\n                                                       /* TODO: Find out what this is for, before touching it */\r\n        withdrawAndSend(wethToken, sub(msg.value, wethAmt));\r\n    }\r\n\r\n    function buyAllAmountBuyEth(\r\n        OtcInterface otc, \r\n        TokenInterface wethToken, \r\n        uint wethAmt, \r\n        TokenInterface payToken, \r\n        uint maxPayAmt\r\n    ) public returns (uint payAmt) {\r\n        uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt);\r\n        require(payAmtNow <= maxPayAmt);\r\n        require(payToken.transferFrom(msg.sender, this, payAmtNow));\r\n        if (payToken.allowance(this, otc) < payAmtNow) {\r\n            payToken.approve(otc, uint(-1));\r\n        }\r\n        payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow);\r\n        (uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt);\r\n        require(wethToken.transfer(owner, feeAmt));\r\n        withdrawAndSend(wethToken, wethAmtRemainder);\r\n    }\r\n\r\n    function() public payable {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmountBuyEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"payAmt\",\"type\":\"uint256\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"buyAllAmount\",\"outputs\":[{\"name\":\"payAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"takeFee\",\"outputs\":[{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"name\":\"wethToken\",\"type\":\"address\"}],\"name\":\"buyAllAmountPayEth\",\"outputs\":[{\"name\":\"wethAmt\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFeePercentageWad\",\"type\":\"uint256\"}],\"name\":\"newFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"buyToken\",\"type\":\"address\"},{\"name\":\"minBuyAmt\",\"type\":\"uint256\"}],\"name\":\"sellAllAmountPayEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"otc\",\"type\":\"address\"},{\"name\":\"wethToken\",\"type\":\"address\"},{\"name\":\"wethAmt\",\"type\":\"uint256\"},{\"name\":\"payToken\",\"type\":\"address\"},{\"name\":\"maxPayAmt\",\"type\":\"uint256\"}],\"name\":\"buyAllAmountBuyEth\",\"outputs\":[{\"name\":\"payAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"OasisDirectProxy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://accb400e6bd7350a778cf555e2145e0333b9e0d322019358b49f8f1c1d4f5b66"}]}