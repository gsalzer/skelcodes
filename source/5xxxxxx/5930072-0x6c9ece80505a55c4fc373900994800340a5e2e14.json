{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/*\r\n* Contract that is working with ERC223 tokens\r\n*/\r\n \r\ncontract ERC223Receiver {\r\n\tstruct TKN {\r\n\t\taddress sender;\r\n\t\tuint value;\r\n\t\tbytes data;\r\n\t\tbytes4 sig;\r\n\t}\r\n\tfunction tokenFallback(address _from, uint _value, bytes _data) public pure;\r\n}\r\n\r\n /* New ERC223 contract interface */\r\n \r\ncontract ERC223 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) public view returns (uint);\r\n\r\n// redundant as public accessors are automatically assigned   \r\n//  function name() public view returns (string _name);\r\n//  function symbol() public view returns (string _symbol);\r\n//  function decimals() public view returns (uint8 _decimals);\r\n//  function totalSupply() public view returns (uint256 _supply);\r\n\r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transfer(address to, uint value, bytes data) public returns (bool ok);\r\n  function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);\r\n  \r\n  //event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract CGENToken is ERC223 {\r\n\r\n\t// standard token metadata\r\n\t// implements ERC20/ERC223 interface\r\n\tstring public constant name = \"Cryptanogen\"; \r\n\tstring public constant symbol = \"CGEN\" ;\r\n\tuint8 public constant decimals = 8;\r\n\r\n\t// amount of tokens vested\r\n\tuint128 public availableSupply;\r\n\r\n\t// individual vesting data\r\n\tstruct vesting {\r\n\t\tuint createdAt;\r\n\t\tuint128 amount;\r\n\t\tuint8 releaseRate;\r\n\t\tuint32 releaseIntervalSeconds;\r\n\t\tuint8 nextReleasePeriod;\r\n\t\tbool completed;\r\n\t}\r\n\r\n\tstruct tokenAccount {\r\n\t\tuint128 vestedBalance;\r\n\t\tuint128 releasedBalance;\r\n\t\tvesting []vestingIndex; \r\n\t}\r\n\r\n\t// locked balance per address\r\n\tmapping (address => tokenAccount) tokenAccountIndex;\r\n\r\n\t// contract owner\r\n\taddress public owner;\r\n\r\n\t// contract creation time\r\n\tuint creationTime;\r\n\r\n\t// How often vested tokens are released\r\n\t//uint32 public defaultReleaseIntervalSeconds = 31536000;\r\n\r\n\t// Percentage vested amount released each interval\r\n\t//uint8 public defaultReleaseRate = 10; \r\n\r\n\tfunction CGENToken(uint _supply) public {\r\n\t\ttotalSupply = _supply;\r\n\t\tavailableSupply = uint128(totalSupply);\r\n\t\trequire(uint(availableSupply) == totalSupply);\r\n\t\towner = msg.sender;\r\n\t\tcreationTime = now;\r\n\t\temit Transfer(0x0, owner, _supply);\r\n\t}\r\n\r\n\t// creates a new vesting with default parameters for rate and interval\t\r\n//\tfunction vestToAddress(address _who, uint128 _amount) public returns(bool) {\r\n//\t\treturn vestToAddressEx(_who, _amount, defaultReleaseRate, defaultReleaseIntervalSeconds);\r\n//\t}\r\n\r\n\r\n\t// creates a new vesting with explicit parameters for rate and interval\r\n\tfunction vestToAddressEx(address _who, uint128 _amount, uint8 _divisor, uint32 _intervalSeconds) public returns(bool) {\r\n\r\n\t\t// uninitialized but all fields will be set below\r\n\t\tvesting memory newVesting;\r\n\r\n\t\t// vestings are registered manually by contract owner\r\n\t\trequire(msg.sender == owner);\r\n\r\n\t\t// duh\r\n\t\trequire(_amount > 0);\r\n\t\trequire(_divisor <= 100 && _divisor > 0);\r\n\t\trequire(_intervalSeconds > 0);\r\n\r\n\t\t// rate should divide evenly to 100 (percent)\r\n\t\trequire(100 % _divisor == 0);\r\n\r\n\t\t// prevent vesting of more tokens than total supply\r\n\t\trequire(_amount <= availableSupply);\r\n\r\n\t\tnewVesting.createdAt = now;\r\n\t\tnewVesting.amount = _amount;\r\n\t\tnewVesting.releaseRate = 100 / _divisor;\r\n\t\tnewVesting.releaseIntervalSeconds = _intervalSeconds;\r\n\t\tnewVesting.nextReleasePeriod = 0;\r\n\t\tnewVesting.completed = false;\r\n\t\ttokenAccountIndex[_who].vestingIndex.push(newVesting);\r\n\r\n\t\tavailableSupply -= _amount;\r\n\t\ttokenAccountIndex[_who].vestedBalance += _amount;\r\n\t\temit Transfer(owner, _who, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// check the vesting at the particular index for the address for amount eligible for release\r\n\t// returns the eligible amount\r\n\tfunction checkRelease(address _who, uint _idx) public view returns(uint128) {\r\n\t\tvesting memory v;\r\n\t\tuint i;\r\n\t\tuint timespan;\r\n\t\tuint timestep;\r\n\t\tuint maxEligibleFactor;\r\n\t\tuint128 releaseStep;\r\n\t\tuint128 eligibleAmount;\r\n\r\n\t\t// check if any tokens have been vested to this account\r\n\t\trequire(tokenAccountIndex[_who].vestingIndex.length > _idx);\r\n\t\tv = tokenAccountIndex[_who].vestingIndex[_idx];\r\n\t\tif (v.completed) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// by dividing timespan (time passed since vesting creation) by the release intervals, we get the maximal rate that is eligible for release so far\r\n\t\t// cap it at 100 percent\r\n\t\ttimespan = now - tokenAccountIndex[_who].vestingIndex[_idx].createdAt;\r\n\t\ttimestep = tokenAccountIndex[_who].vestingIndex[_idx].releaseIntervalSeconds * 1 seconds;\r\n\t\tmaxEligibleFactor = (timespan / timestep) * tokenAccountIndex[_who].vestingIndex[_idx].releaseRate;\r\n\t\tif (maxEligibleFactor > 100) {\r\n\t\t\tmaxEligibleFactor = 100;\r\n\t\t}\r\n\r\n\t\treleaseStep = (tokenAccountIndex[_who].vestingIndex[_idx].amount * tokenAccountIndex[_who].vestingIndex[_idx].releaseRate) / 100;\r\n\t\t// iterate from the cursor on the next vesting period that has not yet been released\r\n\t\tfor (i = tokenAccountIndex[_who].vestingIndex[_idx].nextReleasePeriod * tokenAccountIndex[_who].vestingIndex[_idx].releaseRate; i < maxEligibleFactor; i += tokenAccountIndex[_who].vestingIndex[_idx].releaseRate) {\r\n\t\t\teligibleAmount += releaseStep;\r\n\t\t}\r\n\r\n\t\treturn eligibleAmount;\r\n\t}\r\n\r\n\t// will release and make transferable any tokens eligible for release\r\n\t// to avoid waste of gas, the calling agent should have confirmed with checkRelease that there actually is something to release\r\n\tfunction release(address _who, uint _idx) public returns(uint128) {\r\n\t\tvesting storage v;\r\n\t\tuint8 j;\r\n\t\tuint8 i;\r\n\t\tuint128 total;\r\n\t\tuint timespan;\r\n\t\tuint timestep;\r\n\t\tuint128 releaseStep;\r\n\t\tuint maxEligibleFactor;\r\n\r\n\t\t// check if any tokens have been vested to this account\r\n\t\t// don't burn gas if already completed\r\n\t\trequire(tokenAccountIndex[_who].vestingIndex.length > _idx);\r\n\t\tv = tokenAccountIndex[_who].vestingIndex[_idx];\r\n\t\tif (v.completed) {\r\n\t\t\trevert();\r\n\t\t}\r\n\r\n\t\t// by dividing timespan (time passed since vesting creation) by the release intervals, we get the maximal rate that is eligible for release so far\r\n\t\t// cap it at 100 percent\r\n\t\ttimespan = now - v.createdAt;\r\n\t\ttimestep = v.releaseIntervalSeconds * 1 seconds;\r\n\t\tmaxEligibleFactor = (timespan / timestep) * v.releaseRate;\r\n\t\tif (maxEligibleFactor > 100) {\r\n\t\t\tmaxEligibleFactor = 100;\r\n\t\t}\r\n\r\n\t\treleaseStep = (v.amount * v.releaseRate) / 100;\r\n\t\tfor (i = v.nextReleasePeriod * v.releaseRate; i < maxEligibleFactor; i += v.releaseRate) {\r\n\t\t\ttotal += releaseStep;\r\n\t\t\tj++;\r\n\t\t}\r\n\t\ttokenAccountIndex[_who].vestedBalance -= total;\r\n\t\ttokenAccountIndex[_who].releasedBalance += total;\r\n\t\tif (maxEligibleFactor == 100) {\r\n\t\t\tv.completed = true;\r\n\t\t} else {\r\n\t\t\tv.nextReleasePeriod += j;\r\n\t\t}\r\n\t\treturn total;\r\n\t}\r\n\r\n\t// vestings state access\r\n\tfunction getVestingAmount(address _who, uint _idx) public view returns (uint128) {\r\n\t\treturn tokenAccountIndex[_who].vestingIndex[_idx].amount;\r\n\t}\r\n\r\n\tfunction getVestingReleaseRate(address _who, uint _idx) public view returns (uint8) {\r\n\t\treturn tokenAccountIndex[_who].vestingIndex[_idx].releaseRate;\r\n\t}\r\n\r\n\tfunction getVestingReleaseInterval(address _who, uint _idx) public view returns(uint32) {\r\n\t\treturn tokenAccountIndex[_who].vestingIndex[_idx].releaseIntervalSeconds;\r\n\t}\r\n\r\n\tfunction getVestingCreatedAt(address _who, uint _idx) public view returns(uint) {\r\n\t\treturn tokenAccountIndex[_who].vestingIndex[_idx].createdAt;\r\n\t}\r\n\r\n\tfunction getVestingsCount(address _who) public view returns(uint) {\r\n\t\treturn tokenAccountIndex[_who].vestingIndex.length;\r\n\t}\r\n\r\n\tfunction vestingIsCompleted(address _who, uint _idx) public view returns(bool) {\r\n\t\trequire(tokenAccountIndex[_who].vestingIndex.length > _idx);\r\n\r\n\t\treturn tokenAccountIndex[_who].vestingIndex[_idx].completed;\r\n\t}\r\n\r\n\t// implements ERC223 interface\r\n\tfunction transfer(address _to, uint256 _value, bytes _data, string _custom_callback_unimplemented) public returns(bool) {\r\n\t\tuint128 shortValue;\r\n\r\n\t\t// owner can only vest tokens\r\n\t\trequire(_to != owner);\r\n\t\trequire(msg.sender != owner);\r\n\t\r\n\t\t// we use 128 bit data for values\r\n\t\t// make sure it's converted correctly\r\n\t\tshortValue = uint128(_value);\r\n\t\trequire(uint(shortValue) == _value);\r\n\r\n\t\t// check if there is enough in the released balance\r\n\t\trequire(tokenAccountIndex[msg.sender].releasedBalance >= shortValue);\r\n\r\n\t\t// check if the recipient has an account, if not create it\r\n\t\ttokenAccountIndex[msg.sender].releasedBalance -= shortValue;\r\n\t\ttokenAccountIndex[_to].releasedBalance += shortValue;\r\n\r\n\t\t// ERC223 safe token transfer to contract\r\n\t\tif (isContract(_to)) {\r\n\t\t\tERC223Receiver receiver = ERC223Receiver(_to);\r\n\t\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\t}\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// implements ERC20/ERC223 interface\r\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\r\n\t\treturn transfer(_to, _value, _data, \"\");\r\n\t}\r\n\r\n\t// implements ERC20/ERC223 interface\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\tbytes memory empty;\r\n\t\treturn transfer(_to, _value, empty, \"\");\r\n\t}\r\n\r\n\t// not used for this token\r\n\t// implements ERC20 interface\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// not used for this token\r\n\t// implements ERC20 interface\r\n\tfunction approve(address _spender, uint256 _value) public returns(bool) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// not used for this token\r\n\t// implements ERC20 interface\r\n\tfunction allowance(address _owner, address _spender) public view returns(uint256) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t// check the total of vested tokens still locked for a particular address\r\n\tfunction vestedBalanceOf(address _who) public view returns (uint) {\r\n\t\treturn uint(tokenAccountIndex[_who].vestedBalance);\r\n\t}\r\n\r\n\t// check the total of vested and released tokens assigned to a particular addresss\r\n\t// (this is the actual token balance)\r\n\t// implements ERC20/ERC223 interface\r\n\tfunction balanceOf(address _who) public view returns (uint) {\r\n\t\tif (_who == owner) {\r\n\t\t\treturn availableSupply;\r\n\t\t}\r\n\t\treturn uint(tokenAccountIndex[_who].vestedBalance + tokenAccountIndex[_who].releasedBalance);\r\n\t}\r\n\r\n\t// external addresses (wallets) will have codesize 0\r\n\tfunction isContract(address _addr) private view returns (bool) {\r\n\t\tuint l;\r\n\r\n\t\t// Retrieve the size of the code on target address, this needs assembly .\r\n\t\tassembly {\r\n\t\t\tl := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (l > 0);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getVestingReleaseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"vestedBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getVestingCreatedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"getVestingsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint128\"},{\"name\":\"_divisor\",\"type\":\"uint8\"},{\"name\":\"_intervalSeconds\",\"type\":\"uint32\"}],\"name\":\"vestToAddressEx\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getVestingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getVestingReleaseInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_custom_callback_unimplemented\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"checkRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"vestingIsCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CGENToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000b1a2bc2ec500000","Library":"","SwarmSource":"bzzr://889c60d9f2f2c5db00da48b4e22528b22b396e69619453bcaba5dd76c7b7e77d"}]}