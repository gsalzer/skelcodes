{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\n/// @title A base contract to control ownership\r\n/// @author cuilichen\r\ncontract OwnerBase {\r\n\r\n    // The addresses of the accounts that can execute actions within each roles.\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n    \r\n    /// constructor\r\n    function OwnerBase() public {\r\n       ceoAddress = msg.sender;\r\n       cfoAddress = msg.sender;\r\n       cooAddress = msg.sender;\r\n    }\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n    \r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new COO\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n    \r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCOO whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyCOO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n    \r\n    \r\n    /// @dev check wether target address is a contract or not\r\n    function isNormalUser(address addr) internal view returns (bool) {\r\n        if (addr == address(0)) {\r\n            return false;\r\n        }\r\n        uint size = 0;\r\n        assembly { \r\n            size := extcodesize(addr) \r\n        } \r\n        return size == 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Base contract for Chaotic. Holds all common structs, events and base variables.\r\n/// @author cuilichen\r\ncontract BaseFight is OwnerBase {\r\n\r\n    event FighterReady(uint32 season);\r\n    \r\n    // data of fighter\r\n    struct Fighter {\r\n        uint tokenID;\r\n        address hometown;\r\n        address owner;\r\n        uint16 power;\r\n    }\r\n    \r\n    \r\n    mapping (uint => Fighter) public soldiers; // key is (season * 1000 + index)\r\n    \r\n    // time for matches\r\n    mapping (uint32 => uint64 ) public matchTime;// key is season\r\n    \r\n    \r\n    mapping (uint32 => uint64 ) public seedFromCOO; // key is season\r\n    \r\n    \r\n    mapping (uint32 => uint8 ) public finished; // key is season\r\n    \r\n    //\r\n    uint32[] seasonIDs;\r\n    \r\n    \r\n    \r\n    /// @dev get base infomation of the seasons\r\n    function getSeasonInfo(uint32[99] _seasons) view public returns (uint length,uint[99] matchTimes, uint[99] results) {\r\n        for (uint i = 0; i < _seasons.length; i++) {    \r\n            uint32 _season = _seasons[i];\r\n            if(_season >0){\r\n                matchTimes[i] = matchTime[_season];\r\n                results[i] = finished[_season];\r\n            }else{\r\n                length = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    /// @dev check seed form coo\r\n    function checkCooSeed(uint32 _season) public view returns (uint64) {\r\n        require(finished[_season] > 0);\r\n        return seedFromCOO[_season];\r\n    }\r\n\r\n    \r\n    /// @dev set a fighter for a season, prepare for combat.\r\n    function createSeason(uint32 _season, uint64 fightTime, uint64 _seedFromCOO, address[8] _home, uint[8] _tokenID, uint16[8] _power, address[8] _owner) external onlyCOO {\r\n        require(matchTime[_season] <= 0);\r\n        require(fightTime > 0);\r\n        require(_seedFromCOO > 0);\r\n        seasonIDs.push(_season);// a new season\r\n        matchTime[_season] = fightTime;\r\n        seedFromCOO[_season] = _seedFromCOO;\r\n        \r\n        for (uint i = 0; i < 8; i++) {        \r\n            Fighter memory soldier = Fighter({\r\n                hometown:_home[i],\r\n                owner:_owner[i],\r\n                tokenID:_tokenID[i],\r\n                power: _power[i]\r\n            });\r\n                \r\n            uint key = _season * 1000 + i;\r\n            soldiers[key] = soldier;\r\n            \r\n        }\r\n        \r\n        //fire the event\r\n        emit FighterReady(_season);\r\n    }\r\n    \r\n    \r\n    \r\n    /// @dev process a fight\r\n    function _localFight(uint32 _season, uint32 _seed) internal returns (uint8 winner)\r\n    {\r\n        require(finished[_season] == 0);//make sure a season just match once.\r\n        \r\n        uint[] memory powers = new uint[](8);\r\n        \r\n        uint sumPower = 0;\r\n        uint8 i = 0;\r\n        uint key = 0;\r\n        Fighter storage soldier = soldiers[0];\r\n        for (i = 0; i < 8; i++) {\r\n            key = _season * 1000 + i;\r\n            soldier = soldiers[key];\r\n            powers[i] = soldier.power;\r\n            sumPower = sumPower + soldier.power;\r\n        }\r\n        \r\n        uint sumValue = 0;\r\n        uint tmpPower = 0;\r\n        for (i = 0; i < 8; i++) {\r\n            tmpPower = powers[i] ** 5;//\r\n            sumValue += tmpPower;\r\n            powers[i] = sumValue;\r\n        }\r\n        uint singleDeno = sumPower ** 5;\r\n        uint randomVal = _getRandom(_seed);\r\n        \r\n        winner = 0;\r\n        uint shoot = sumValue * randomVal * 10000000000 / singleDeno / 0xffffffff;\r\n        for (i = 0; i < 8; i++) {\r\n            tmpPower = powers[i];\r\n            if (shoot <= tmpPower * 10000000000 / singleDeno) {\r\n                winner = i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        finished[_season] = uint8(100 + winner);\r\n        return winner;\r\n    }\r\n    \r\n    \r\n    /// @dev give a seed and get a random value between 0 and 0xffffffff.\r\n    /// @param _seed an uint32 value from users\r\n    function _getRandom(uint32 _seed) pure internal returns(uint32) {\r\n        return uint32(keccak256(_seed));\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n \r\n}\r\n\r\n\r\n \r\n\r\n/**\r\n * \r\n * @title Interface of contract for partner\r\n * @author cuilichen\r\n */\r\ncontract PartnerHolder {\r\n    //\r\n    function isHolder() public pure returns (bool);\r\n    \r\n    // Required methods\r\n    function bonusAll() payable public ;\r\n    \r\n    \r\n    function bonusOne(uint id) payable public ;\r\n    \r\n}\r\n\r\n\r\n\r\ncontract BetOnMatch is BaseFight, SafeMath {\r\n\r\n    event Betted( uint32 indexed season, uint32 indexed index, address indexed account, uint amount);\r\n    event SeasonNone( uint32 season);\r\n    event SeasonWinner( uint32 indexed season, uint winnerID);\r\n    event LogFighter( uint32 indexed season, address indexed fighterOwner, uint fighterKey, uint fund, address fighterContract, uint fighterTokenID, uint power, uint8 isWin,uint reward, uint64 fightTime);\r\n    event LogMatch( uint32 indexed season, uint sumFund, uint64 fightTime, uint sumSeed, uint fighterKey, address fighterContract, uint fighterTokenID ,bool isRefound);\r\n    event LogBet( uint32 indexed season, address indexed sender, uint fund, uint seed, uint fighterKey, address fighterContract, uint fighterTokenID );\r\n    \r\n    struct Betting {\r\n        // user \r\n        address account;\r\n        \r\n        uint32 season;\r\n        \r\n        uint32 index;\r\n        \r\n        address invitor;\r\n        \r\n        uint seed;\r\n        //\r\n        uint amount;\r\n    }\r\n    \r\n    // contract of partners\r\n    PartnerHolder public partners;\r\n    \r\n    // all betting data\r\n    mapping (uint => Betting[]) public allBittings; // key is season * 1000 + index\r\n    \r\n    // bet on the fighter,\r\n    mapping (uint => uint) public betOnFighter; // key is season * 1000 + index\r\n    \r\n    // address to balance.\r\n    mapping( address => uint) public balances;\r\n    \r\n    \r\n    /// @dev constructor of contract, set partners\r\n    function BetOnMatch(address _partners) public {\r\n        ceoAddress = msg.sender;\r\n        cooAddress = msg.sender;\r\n        cfoAddress = msg.sender;\r\n        \r\n        partners = PartnerHolder(_partners);\r\n    }\r\n        \r\n    \r\n    \r\n    /// @dev bet to the match\r\n    function betOn(\r\n        uint32 _season, \r\n        uint32 _index, \r\n        uint _seed, \r\n        address _invitor) \r\n    payable external returns (bool){\r\n        require(isNormalUser(msg.sender));\r\n        require(matchTime[_season] > 0);\r\n        require(now < matchTime[_season] - 300); // 5 minites before match.\r\n        require(msg.value >= 1 finney && msg.value < 99999 ether );\r\n        \r\n        \r\n        Betting memory tmp = Betting({\r\n            account:msg.sender,\r\n            season:_season,\r\n            index:_index,\r\n            seed:_seed,\r\n            invitor:_invitor,\r\n            amount:msg.value\r\n        });\r\n        \r\n        \r\n        uint key = _season * 1000 + _index;\r\n        betOnFighter[key] = safeAdd(betOnFighter[key], msg.value);\r\n        Betting[] storage items = allBittings[key];\r\n        items.push(tmp);\r\n        \r\n        Fighter storage soldier = soldiers[key];\r\n        \r\n        emit Betted( _season, _index, msg.sender, msg.value);\r\n        emit LogBet( _season, msg.sender, msg.value, _seed, key, soldier.hometown, soldier.tokenID );\r\n    }\r\n    \r\n    \r\n    /// @dev set a fighter for a season, prepare for combat.\r\n    function getFighters( uint32 _season) public view returns (address[8] outHome, uint[8] outTokenID, uint[8] power,  address[8] owner, uint[8] funds) {\r\n        for (uint i = 0; i < 8; i++) {  \r\n            uint key = _season * 1000 + i;\r\n            funds[i] = betOnFighter[key];\r\n            \r\n            Fighter storage soldier = soldiers[key];\r\n            outHome[i] = soldier.hometown;\r\n            outTokenID[i] = soldier.tokenID;\r\n            power[i] = soldier.power;\r\n            owner[i] = soldier.owner;\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /// @notice process a combat, it is expencive, so provide enough gas\r\n    function processSeason(uint32 _season) public onlyCOO\r\n    {\r\n        uint64 fightTime = matchTime[_season];\r\n        require(now >= fightTime && fightTime > 0);\r\n        \r\n        uint sumFund = 0;\r\n        uint sumSeed = 0;\r\n        (sumFund, sumSeed) = _getFightData(_season);\r\n        if (sumFund == 0) {\r\n            finished[_season] = 110;\r\n            doLogFighter(_season,0,0);\r\n            emit SeasonNone(_season);\r\n            emit LogMatch( _season, sumFund, fightTime, sumSeed, 0, 0, 0, false );\r\n        } else {\r\n            uint8 champion = _localFight(_season, uint32(sumSeed));\r\n        \r\n            uint percentile = safeDiv(sumFund, 100);\r\n            uint devCut = percentile * 4; // for developer\r\n            uint partnerCut = percentile * 5; // for partners\r\n            uint fighterCut = percentile * 1; // for fighters\r\n            uint bonusWinner = percentile * 80; // for winner\r\n            // for salesman percentile * 10\r\n            \r\n            _bonusToPartners(partnerCut);\r\n            _bonusToFighters(_season, champion, fighterCut);\r\n            bool isRefound = _bonusToBettor(_season, champion, bonusWinner);\r\n            _addMoney(cfoAddress, devCut);\r\n            \r\n            uint key = _season * 1000 + champion;\r\n            Fighter storage soldier = soldiers[key];\r\n            doLogFighter(_season,key,fighterCut);\r\n            emit SeasonWinner(_season, champion);        \r\n            emit LogMatch( _season, sumFund, fightTime, sumSeed, key, soldier.hometown, soldier.tokenID, isRefound );\r\n        }\r\n        clearTheSeason(_season);\r\n    }\r\n    \r\n    \r\n    \r\n    function clearTheSeason( uint32 _season) internal {\r\n        for (uint i = 0; i < 8; i++){\r\n            uint key = _season * 1000 + i;\r\n            delete soldiers[key];\r\n            delete allBittings[key];\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /// @dev write log about 8 fighters\r\n    function doLogFighter( uint32 _season, uint _winnerKey, uint fighterReward) internal {\r\n        for (uint i = 0; i < 8; i++){\r\n            uint key = _season * 1000 + i;\r\n            uint8 isWin = 0;\r\n            uint64 fightTime = matchTime[_season];\r\n            uint winMoney = safeDiv(fighterReward, 10);\r\n            if(key == _winnerKey){\r\n                isWin = 1;\r\n                winMoney = safeMul(winMoney, 3);\r\n            }\r\n            Fighter storage soldier = soldiers[key];\r\n            emit LogFighter( _season, soldier.owner, key, betOnFighter[key], soldier.hometown, soldier.tokenID, soldier.power, isWin,winMoney,fightTime);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /// @dev caculate fund and seed value\r\n    function _getFightData(uint32 _season) internal returns (uint outFund, uint outSeed){\r\n        outSeed = seedFromCOO[_season];\r\n        for (uint i = 0; i < 8; i++){\r\n            uint key = _season * 1000 + i;\r\n            uint fund = 0;\r\n            Betting[] storage items = allBittings[key]; \r\n            for (uint j = 0; j < items.length; j++) {\r\n                Betting storage item = items[j];\r\n                outSeed += item.seed;\r\n                fund += item.amount;\r\n                \r\n                uint forSaler = safeDiv(item.amount, 10); // 0.1 for salesman\r\n                if (item.invitor == address(0)){\r\n                    _addMoney(cfoAddress, forSaler);\r\n                } else {\r\n                    _addMoney(item.invitor, forSaler);\r\n                }\r\n            }\r\n            outFund += fund;\r\n        }\r\n    }\r\n    \r\n    /// @dev add fund to the address.\r\n    function _addMoney( address user, uint val) internal {\r\n        uint oldValue = balances[user];\r\n        balances[user] = safeAdd(oldValue, val);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    /// @dev bonus to partners.\r\n    function _bonusToPartners(uint _amount) internal {\r\n        if (partners == address(0)) {\r\n            _addMoney(cfoAddress, _amount);\r\n        } else {\r\n            partners.bonusAll.value(_amount)();\r\n        }\r\n    }\r\n    \r\n    \r\n    /// @dev bonus to the fighters in the season.\r\n    function _bonusToFighters(uint32 _season, uint8 _winner, uint _reward) internal {\r\n        for (uint i = 0; i < 8; i++) {\r\n            uint key = _season * 1000 + i;\r\n            Fighter storage item = soldiers[key];\r\n            address owner = item.owner;\r\n            uint fund = safeDiv(_reward, 10);\r\n            if (i == _winner) {\r\n                fund = safeMul(fund, 3);\r\n            }\r\n            if (owner == address(0)) {\r\n                _addMoney(cfoAddress, fund);\r\n            } else {\r\n                _addMoney(owner, fund);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /// @dev bonus to bettors who won.\r\n    function _bonusToBettor(uint32 _season, uint8 _winner, uint bonusWinner) internal returns (bool) {\r\n        uint winnerBet = _getWinnerBetted(_season, _winner);\r\n        uint key = _season * 1000 + _winner;\r\n        Betting[] storage items = allBittings[key];\r\n        if (items.length == 0) {\r\n            backToAll(_season);\r\n            return true;\r\n        } else {\r\n            for (uint j = 0; j < items.length; j++) {\r\n                Betting storage item = items[j];\r\n                address account = item.account;\r\n                uint newFund = safeDiv(safeMul(bonusWinner, item.amount), winnerBet); \r\n                _addMoney(account, newFund);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /// @dev nobody win, return fund back to all bettors.\r\n    function backToAll(uint32 _season) internal {\r\n        for (uint i = 0; i < 8; i++) {\r\n            uint key = _season * 1000 + i;\r\n            Betting[] storage items = allBittings[key];\r\n            for (uint j = 0; j < items.length; j++) {\r\n                Betting storage item = items[j];\r\n                address account = item.account;\r\n                uint backVal = safeDiv(safeMul(item.amount, 8), 10); // amount * 0.8\r\n                _addMoney(account, backVal);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /// @dev caculate total amount betted on winner\r\n    function _getWinnerBetted(uint32 _season, uint32 _winner) internal view returns (uint){\r\n        uint sum = 0;\r\n        uint key = _season * 1000 + _winner;\r\n        Betting[] storage items = allBittings[key];\r\n        for (uint j = 0; j < items.length; j++) {\r\n            Betting storage item = items[j];\r\n            sum += item.amount;\r\n        }\r\n        return sum;\r\n    }\r\n    \r\n    \r\n    \r\n    /// @dev partner withdraw, \r\n    function userWithdraw() public {\r\n        uint fund = balances[msg.sender];\r\n        require (fund > 0);\r\n        delete balances[msg.sender];\r\n        msg.sender.transfer(fund);\r\n    }\r\n    \r\n    \r\n    /// @dev cfo withdraw dead ether. \r\n    function withdrawDeadFund( address addr) external onlyCFO {\r\n        uint fund = balances[addr];\r\n        require (fund > 0);\r\n        delete balances[addr];\r\n        cfoAddress.transfer(fund);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betOnFighter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawDeadFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"finished\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"matchTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint32\"},{\"name\":\"_index\",\"type\":\"uint32\"},{\"name\":\"_seed\",\"type\":\"uint256\"},{\"name\":\"_invitor\",\"type\":\"address\"}],\"name\":\"betOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"seedFromCOO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"soldiers\",\"outputs\":[{\"name\":\"tokenID\",\"type\":\"uint256\"},{\"name\":\"hometown\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"power\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_seasons\",\"type\":\"uint32[99]\"}],\"name\":\"getSeasonInfo\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"},{\"name\":\"matchTimes\",\"type\":\"uint256[99]\"},{\"name\":\"results\",\"type\":\"uint256[99]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allBittings\",\"outputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"season\",\"type\":\"uint32\"},{\"name\":\"index\",\"type\":\"uint32\"},{\"name\":\"invitor\",\"type\":\"address\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint32\"}],\"name\":\"processSeason\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint32\"}],\"name\":\"getFighters\",\"outputs\":[{\"name\":\"outHome\",\"type\":\"address[8]\"},{\"name\":\"outTokenID\",\"type\":\"uint256[8]\"},{\"name\":\"power\",\"type\":\"uint256[8]\"},{\"name\":\"owner\",\"type\":\"address[8]\"},{\"name\":\"funds\",\"type\":\"uint256[8]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint32\"}],\"name\":\"checkCooSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint32\"},{\"name\":\"fightTime\",\"type\":\"uint64\"},{\"name\":\"_seedFromCOO\",\"type\":\"uint64\"},{\"name\":\"_home\",\"type\":\"address[8]\"},{\"name\":\"_tokenID\",\"type\":\"uint256[8]\"},{\"name\":\"_power\",\"type\":\"uint16[8]\"},{\"name\":\"_owner\",\"type\":\"address[8]\"}],\"name\":\"createSeason\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_partners\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"season\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Betted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"season\",\"type\":\"uint32\"}],\"name\":\"SeasonNone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"season\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"winnerID\",\"type\":\"uint256\"}],\"name\":\"SeasonWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"season\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"fighterOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fighterKey\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fighterContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fighterTokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"power\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isWin\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fightTime\",\"type\":\"uint64\"}],\"name\":\"LogFighter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"season\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"sumFund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fightTime\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"sumSeed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fighterKey\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fighterContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fighterTokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isRefound\",\"type\":\"bool\"}],\"name\":\"LogMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"season\",\"type\":\"uint32\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fund\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fighterKey\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fighterContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fighterTokenID\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"season\",\"type\":\"uint32\"}],\"name\":\"FighterReady\",\"type\":\"event\"}]","ContractName":"BetOnMatch","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000c9a488c025db96ce8a834cd3412661f46833a28","Library":"","SwarmSource":"bzzr://654c3d7dccbda0bb479846e55059df15043ba13a6a2a8f6ca672e830bd8f1b8f"}]}