{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract FortuneToken {\r\n    address public admin;\r\n\r\n    uint ethereumTokenInitValue = 5 ether;\r\n\r\n    uint fortuneInitValue = 1 ether;\r\n\r\n    struct EtherFortuneToken {\r\n        address owner;\r\n        uint price;\r\n    }\r\n\r\n    struct Fortune {\r\n        address owner;\r\n        address buyer1;\r\n        address buyer2;\r\n        uint price;\r\n        uint buyers;\r\n    }\r\n\r\n    EtherFortuneToken private EthereumToken;\r\n\r\n    Fortune[] private fortunes;\r\n\r\n    modifier onlyDev() {\r\n    require(msg.sender == admin);\r\n    _;\r\n    }\r\n\r\n    function FortuneToken() public {\r\n      admin = msg.sender;\r\n\r\n      Fortune memory _fortune = Fortune({\r\n          owner: address(this),\r\n          buyer1: address(0),\r\n          buyer2: address(0),\r\n          price: fortuneInitValue,\r\n          buyers: 0\r\n      });\r\n\r\n      fortunes.push(_fortune);\r\n\r\n      EtherFortuneToken memory _fortuneEthereumToken = EtherFortuneToken({\r\n          owner: address(this),\r\n          price: ethereumTokenInitValue\r\n      });\r\n\r\n      EthereumToken = _fortuneEthereumToken;\r\n    }\r\n\r\n    function getFortune(uint id) public view returns (address owner, address buyer1, address buyer2, uint price, uint buyers) {\r\n        Fortune storage _fortune = fortunes[id];\r\n        owner = _fortune.owner;\r\n        buyer1 = _fortune.buyer1;\r\n        buyer2 = _fortune.buyer2;\r\n        price = _fortune.price;\r\n        buyers = _fortune.buyers;\r\n    }\r\n\r\n    function payFortune(uint id) public payable{\r\n        Fortune storage _fortune = fortunes[id];\r\n        require(_fortune.buyer1 == address(0) || _fortune.buyer2 == address(0));\r\n        require(msg.value == _fortune.price);\r\n        if (_fortune.buyer1 == address(0)) {\r\n            _fortune.buyer1 = msg.sender;\r\n            _fortune.buyers++;\r\n        } else {\r\n            _fortune.buyer2 = msg.sender;\r\n            Fortune memory newFortune1 = Fortune({\r\n                owner: _fortune.buyer1,\r\n                buyer1: address(0),\r\n                buyer2: address(0),\r\n                price: SafeMath.div(SafeMath.mul(_fortune.price, 100), 90),\r\n                buyers: 0\r\n            });\r\n            Fortune memory newFortune2 = Fortune({\r\n                owner: _fortune.buyer2,\r\n                buyer1: address(0),\r\n                buyer2: address(0),\r\n                price: SafeMath.div(SafeMath.mul(_fortune.price, 100), 90),\r\n                buyers: 0\r\n            });\r\n            fortunes.push(newFortune1);\r\n            fortunes.push(newFortune2);\r\n            _fortune.buyers++;\r\n        }\r\n        if (_fortune.owner != address(this)) {\r\n            uint256 payment = SafeMath.div(SafeMath.mul(_fortune.price, 90), 100);\r\n            _fortune.owner.transfer(payment);\r\n        }\r\n        if (EthereumToken.owner != address(this)) {\r\n            uint256 paymentEthereumTokenFortune = SafeMath.div(SafeMath.mul(_fortune.price, 5), 100);\r\n            EthereumToken.owner.transfer(paymentEthereumTokenFortune);\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    function buyEthereumToken() public payable {\r\n        require(EthereumToken.price == msg.value);\r\n        require(EthereumToken.owner != msg.sender);\r\n        address newOwner = msg.sender;\r\n        if (EthereumToken.owner != address(this)) {\r\n            uint256 payment = SafeMath.div(SafeMath.mul(EthereumToken.price, 90), 100);\r\n            EthereumToken.owner.transfer(payment);\r\n        }\r\n        EthereumToken.owner = newOwner;\r\n        EthereumToken.price = SafeMath.div(SafeMath.mul(EthereumToken.price, 120), 90);\r\n\r\n    }\r\n\r\n    function getEthereumToken() public view returns (address owner, uint price) {\r\n        EtherFortuneToken storage _fortuneEthereumToken = EthereumToken;\r\n        owner = _fortuneEthereumToken.owner;\r\n        price = _fortuneEthereumToken.price;\r\n    }\r\n\r\n    function totalFortunes() public view returns (uint) {\r\n        return fortunes.length;\r\n    }\r\n\r\n    function getBalance() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function withdraw(address _to) public onlyDev{\r\n        if (_to != address(0)) {\r\n            _to.transfer(this.balance);\r\n        } else {\r\n            admin.transfer(this.balance);\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFortunes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEthereumToken\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getFortune\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"buyer1\",\"type\":\"address\"},{\"name\":\"buyer2\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"buyers\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyEthereumToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"payFortune\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"FortuneToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://631aca4e2dc79969df530fd6fa91ed1abdbb57ecbc15f1734409eb0adae45103"}]}