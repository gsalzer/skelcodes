{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/Marketplace.sol\r\n\r\n// TODO: Add require reasons as soon as Solidity 0.4.22 is out (now commented out)\r\n//   follow progress at https://github.com/ethereum/solidity/projects/6\r\ncontract Marketplace is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // product events\r\n    event ProductCreated(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds);\r\n    event ProductUpdated(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds);\r\n    event ProductDeleted(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds);\r\n    event ProductRedeployed(address indexed owner, bytes32 indexed id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds);\r\n    event ProductOwnershipOffered(address indexed owner, bytes32 indexed id, address indexed to);\r\n    event ProductOwnershipChanged(address indexed newOwner, bytes32 indexed id, address indexed oldOwner);\r\n\r\n    // subscription events\r\n    event Subscribed(bytes32 indexed productId, address indexed subscriber, uint endTimestamp);\r\n    event NewSubscription(bytes32 indexed productId, address indexed subscriber, uint endTimestamp);\r\n    event SubscriptionExtended(bytes32 indexed productId, address indexed subscriber, uint endTimestamp);\r\n    event SubscriptionTransferred(bytes32 indexed productId, address indexed from, address indexed to, uint secondsTransferred, uint datacoinTransferred);    \r\n\r\n    // currency events\r\n    event ExchangeRatesUpdated(uint timestamp, uint dataInUsd);\r\n\r\n    enum ProductState {\r\n        NotDeployed,                // non-existent or deleted\r\n        Deployed                    // created or redeployed\r\n    }\r\n\r\n    enum Currency {\r\n        DATA,                       // data atoms or \"wei\" (10^-18 DATA)\r\n        USD                         // nanodollars (10^-9 USD)\r\n    }\r\n\r\n    struct Product {\r\n        bytes32 id;\r\n        string name;\r\n        address owner;\r\n        address beneficiary;        // account where revenue is directed to\r\n        uint pricePerSecond;\r\n        Currency priceCurrency;\r\n        uint minimumSubscriptionSeconds;\r\n        ProductState state;\r\n        mapping(address => TimeBasedSubscription) subscriptions;\r\n        address newOwnerCandidate;  // Two phase hand-over to minimize the chance that the product ownership is lost to a non-existent address.\r\n    }\r\n\r\n    struct TimeBasedSubscription {        \r\n        uint endTimestamp;\r\n    }\r\n\r\n    mapping (bytes32 => Product) products;\r\n    function getProduct(bytes32 id) public view returns (string name, address owner, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds, ProductState state) {\r\n        return (\r\n            products[id].name,\r\n            products[id].owner,\r\n            products[id].beneficiary,\r\n            products[id].pricePerSecond,\r\n            products[id].priceCurrency,\r\n            products[id].minimumSubscriptionSeconds,\r\n            products[id].state\r\n        );\r\n    }\r\n\r\n    function getSubscription(bytes32 productId, address subscriber) public view returns (bool isValid, uint endTimestamp) {\r\n        TimeBasedSubscription storage sub;\r\n        (isValid, , sub) = _getSubscription(productId, subscriber);\r\n        endTimestamp = sub.endTimestamp;        \r\n    }\r\n\r\n    function getSubscriptionTo(bytes32 productId) public view returns (bool isValid, uint endTimestamp) {\r\n        return getSubscription(productId, msg.sender);\r\n    }\r\n\r\n    ERC20 datacoin;\r\n\r\n    address public currencyUpdateAgent;\r\n\r\n    function Marketplace(address datacoinAddress, address currencyUpdateAgentAddress) Ownable() public {        \r\n        _initialize(datacoinAddress, currencyUpdateAgentAddress);\r\n    }\r\n\r\n    function _initialize(address datacoinAddress, address currencyUpdateAgentAddress) internal {\r\n        currencyUpdateAgent = currencyUpdateAgentAddress;\r\n        datacoin = ERC20(datacoinAddress);\r\n    }\r\n\r\n    ////////////////// Product management /////////////////\r\n\r\n    // also checks that p exists: p.owner == 0 for non-existent products    \r\n    modifier onlyProductOwner(bytes32 productId) {\r\n        Product storage p = products[productId];\r\n        require(p.owner == msg.sender || owner == msg.sender); //, \"Only product owner may call this function\");\r\n        _;\r\n    }\r\n\r\n    function createProduct(bytes32 id, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds) public whenNotHalted {\r\n        require(id != 0); //, \"Product ID can't be empty/null\");\r\n        require(pricePerSecond > 0); //, \"Free streams go through different channel\");\r\n        Product storage p = products[id];\r\n        require(p.id == 0); //, \"Product with this ID already exists\");        \r\n        products[id] = Product(id, name, msg.sender, beneficiary, pricePerSecond, currency, minimumSubscriptionSeconds, ProductState.Deployed, 0);\r\n        emit ProductCreated(msg.sender, id, name, beneficiary, pricePerSecond, currency, minimumSubscriptionSeconds);\r\n    }\r\n\r\n    /**\r\n    * Stop offering the product\r\n    */\r\n    function deleteProduct(bytes32 productId) public onlyProductOwner(productId) {        \r\n        Product storage p = products[productId];\r\n        require(p.state == ProductState.Deployed);\r\n        p.state = ProductState.NotDeployed;\r\n        emit ProductDeleted(p.owner, productId, p.name, p.beneficiary, p.pricePerSecond, p.priceCurrency, p.minimumSubscriptionSeconds);\r\n    }\r\n\r\n    /**\r\n    * Return product to market\r\n    */\r\n    function redeployProduct(bytes32 productId) public onlyProductOwner(productId) {        \r\n        Product storage p = products[productId];\r\n        require(p.state == ProductState.NotDeployed);\r\n        p.state = ProductState.Deployed;\r\n        emit ProductRedeployed(p.owner, productId, p.name, p.beneficiary, p.pricePerSecond, p.priceCurrency, p.minimumSubscriptionSeconds);\r\n    }\r\n\r\n    function updateProduct(bytes32 productId, string name, address beneficiary, uint pricePerSecond, Currency currency, uint minimumSubscriptionSeconds) public onlyProductOwner(productId) {\r\n        require(pricePerSecond > 0); //, \"Free streams go through different channel\");\r\n        Product storage p = products[productId]; \r\n        p.name = name;\r\n        p.beneficiary = beneficiary;\r\n        p.pricePerSecond = pricePerSecond;\r\n        p.priceCurrency = currency;\r\n        p.minimumSubscriptionSeconds = minimumSubscriptionSeconds;        \r\n        emit ProductUpdated(p.owner, p.id, name, beneficiary, pricePerSecond, currency, minimumSubscriptionSeconds);\r\n    }\r\n\r\n    /**\r\n    * Changes ownership of the product. Two phase hand-over minimizes the chance that the product ownership is lost to a non-existent address.\r\n    */\r\n    function offerProductOwnership(bytes32 productId, address newOwnerCandidate) public onlyProductOwner(productId) {\r\n        // that productId exists is already checked in onlyProductOwner\r\n        products[productId].newOwnerCandidate = newOwnerCandidate;\r\n        emit ProductOwnershipOffered(products[productId].owner, productId, newOwnerCandidate);\r\n    }\r\n\r\n    /**\r\n    * Changes ownership of the product. Two phase hand-over minimizes the chance that the product ownership is lost to a non-existent address.\r\n    */\r\n    function claimProductOwnership(bytes32 productId) public whenNotHalted {\r\n        // also checks that productId exists (newOwnerCandidate is zero for non-existent)\r\n        Product storage p = products[productId]; \r\n        require(msg.sender == p.newOwnerCandidate);\r\n        emit ProductOwnershipChanged(msg.sender, productId, p.owner);\r\n        p.owner = msg.sender;\r\n        p.newOwnerCandidate = 0;\r\n    }\r\n\r\n    /////////////// Subscription management ///////////////\r\n\r\n    /**\r\n     * Purchases access to this stream for msg.sender.\r\n     * If the address already has a valid subscription, extends the subscription by the given period.\r\n     */\r\n    function buy(bytes32 productId, uint subscriptionSeconds) public whenNotHalted {\r\n        Product storage product;\r\n        TimeBasedSubscription storage sub;\r\n        (, product, sub) = _getSubscription(productId, msg.sender);\r\n        require(product.state == ProductState.Deployed); //, \"Product has been deleted\");        \r\n        _addSubscription(product, msg.sender, subscriptionSeconds, sub);\r\n\r\n        uint price = _toDatacoin(product.pricePerSecond.mul(subscriptionSeconds), product.priceCurrency);\r\n        require(datacoin.transferFrom(msg.sender, product.beneficiary, price));  //, \"Not enough DATAcoin allowance\");\r\n    }\r\n\r\n    /**\r\n    * Checks if the given address currently has a valid subscription\r\n    */\r\n    function hasValidSubscription(bytes32 productId, address subscriber) public constant returns (bool isValid) {\r\n        (isValid, ,) = _getSubscription(productId, subscriber);\r\n    }\r\n\r\n    /**\r\n    * Transfer a valid subscription from msg.sender to a new address.\r\n    * If the address already has a valid subscription, extends the subscription by the msg.sender's remaining period.\r\n    */\r\n    function transferSubscription(bytes32 productId, address newSubscriber) public whenNotHalted {\r\n        bool isValid = false;\r\n        Product storage product;\r\n        TimeBasedSubscription storage sub;\r\n        (isValid, product, sub) = _getSubscription(productId, msg.sender);\r\n        require(isValid);   //, \"Only valid subscriptions can be transferred\");\r\n        uint secondsLeft = sub.endTimestamp.sub(block.timestamp);\r\n        uint datacoinLeft = secondsLeft.mul(product.pricePerSecond);\r\n        TimeBasedSubscription storage newSub = product.subscriptions[newSubscriber];\r\n        _addSubscription(product, newSubscriber, secondsLeft, newSub);\r\n        delete product.subscriptions[msg.sender];\r\n        emit SubscriptionTransferred(productId, msg.sender, newSubscriber, secondsLeft, datacoinLeft);\r\n    }\r\n\r\n    function _getSubscription(bytes32 productId, address subscriber) internal constant returns (bool subIsValid, Product storage, TimeBasedSubscription storage) {\r\n        Product storage p = products[productId];\r\n        require(p.id != 0); //, \"Product doesn't exist\");\r\n        TimeBasedSubscription storage s = p.subscriptions[subscriber];\r\n        return (s.endTimestamp >= block.timestamp, p, s);\r\n    }\r\n    \r\n    function _addSubscription(Product storage p, address subscriber, uint addSeconds, TimeBasedSubscription storage oldSub) internal {\r\n        uint endTimestamp;\r\n        if (oldSub.endTimestamp > block.timestamp) {\r\n            require(addSeconds > 0); //, \"Must top up worth at least one second\");\r\n            endTimestamp = oldSub.endTimestamp.add(addSeconds);\r\n            oldSub.endTimestamp = endTimestamp;  \r\n            emit SubscriptionExtended(p.id, subscriber, endTimestamp);\r\n        } else {\r\n            require(addSeconds >= p.minimumSubscriptionSeconds); //, \"More ether required to meet the minimum subscription period\");\r\n            endTimestamp = block.timestamp.add(addSeconds);\r\n            TimeBasedSubscription memory newSub = TimeBasedSubscription(endTimestamp);\r\n            p.subscriptions[subscriber] = newSub;\r\n            emit NewSubscription(p.id, subscriber, endTimestamp);\r\n        }\r\n        emit Subscribed(p.id, subscriber, endTimestamp);\r\n    }\r\n\r\n    // TODO: transfer allowance to another Marketplace contract\r\n    // Mechanism basically is that this Marketplace draws from the allowance and credits\r\n    //   the account on another Marketplace; OR that there is a central credit pool (say, an ERC20 token)\r\n    // Creating another ERC20 token for this could be a simple fix: it would need the ability to transfer allowances\r\n\r\n    /////////////// Currency management ///////////////\r\n\r\n    uint public dataPerUsd = 1;\r\n\r\n    /**\r\n    * Update currency exchange rates; all purchases are still billed in DATAcoin\r\n    * @param timestamp in seconds when the exchange rates were last updated\r\n    * @param dataUsd how many data atoms (10^-18 DATA) equal one nanodollar (10^-9 USD)\r\n    */\r\n    function updateExchangeRates(uint timestamp, uint dataUsd) public {\r\n        require(msg.sender == currencyUpdateAgent);\r\n        require(dataUsd > 0);\r\n        dataPerUsd = dataUsd;\r\n        emit ExchangeRatesUpdated(timestamp, dataUsd);\r\n    }\r\n\r\n    /**\r\n    * Allow updating currency exchange rates even if time of exchange rate isn't known\r\n    */\r\n    function updateExchangeRates(uint dataUsd) public {\r\n        require(msg.sender == currencyUpdateAgent);\r\n        dataPerUsd = dataUsd;\r\n        emit ExchangeRatesUpdated(block.timestamp, dataUsd);\r\n    }    \r\n\r\n    function _toDatacoin(uint number, Currency unit) view internal returns (uint datacoinAmount) {\r\n        if (unit == Currency.DATA) {\r\n            return number;\r\n        }\r\n        return number.mul(dataPerUsd);\r\n    }\r\n\r\n    /////////////// Admin functionality ///////////////\r\n    \r\n    event Halted();\r\n    event Resumed();\r\n    bool public halted = false;\r\n\r\n    modifier whenNotHalted() {\r\n        require(!halted || owner == msg.sender);\r\n        _;\r\n    }\r\n    function halt() public onlyOwner {\r\n        halted = true;\r\n        emit Halted();\r\n    }\r\n    function resume() public onlyOwner {\r\n        halted = false;\r\n        emit Resumed();\r\n    }\r\n\r\n    function reInitialize(address datacoinAddress, address currencyUpdateAgentAddress) public onlyOwner {\r\n        _initialize(datacoinAddress, currencyUpdateAgentAddress);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"},{\"name\":\"subscriptionSeconds\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"}],\"name\":\"claimProductOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"},{\"name\":\"newSubscriber\",\"type\":\"address\"}],\"name\":\"transferSubscription\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getProduct\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"pricePerSecond\",\"type\":\"uint256\"},{\"name\":\"currency\",\"type\":\"uint8\"},{\"name\":\"minimumSubscriptionSeconds\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"pricePerSecond\",\"type\":\"uint256\"},{\"name\":\"currency\",\"type\":\"uint8\"},{\"name\":\"minimumSubscriptionSeconds\",\"type\":\"uint256\"}],\"name\":\"updateProduct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"}],\"name\":\"getSubscriptionTo\",\"outputs\":[{\"name\":\"isValid\",\"type\":\"bool\"},{\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"}],\"name\":\"redeployProduct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"},{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"getSubscription\",\"outputs\":[{\"name\":\"isValid\",\"type\":\"bool\"},{\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"datacoinAddress\",\"type\":\"address\"},{\"name\":\"currencyUpdateAgentAddress\",\"type\":\"address\"}],\"name\":\"reInitialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currencyUpdateAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"}],\"name\":\"deleteProduct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"},{\"name\":\"newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"offerProductOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"productId\",\"type\":\"bytes32\"},{\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"hasValidSubscription\",\"outputs\":[{\"name\":\"isValid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"pricePerSecond\",\"type\":\"uint256\"},{\"name\":\"currency\",\"type\":\"uint8\"},{\"name\":\"minimumSubscriptionSeconds\",\"type\":\"uint256\"}],\"name\":\"createProduct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataPerUsd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"dataUsd\",\"type\":\"uint256\"}],\"name\":\"updateExchangeRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataUsd\",\"type\":\"uint256\"}],\"name\":\"updateExchangeRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"datacoinAddress\",\"type\":\"address\"},{\"name\":\"currencyUpdateAgentAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pricePerSecond\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"minimumSubscriptionSeconds\",\"type\":\"uint256\"}],\"name\":\"ProductCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pricePerSecond\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"minimumSubscriptionSeconds\",\"type\":\"uint256\"}],\"name\":\"ProductUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pricePerSecond\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"minimumSubscriptionSeconds\",\"type\":\"uint256\"}],\"name\":\"ProductDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pricePerSecond\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"minimumSubscriptionSeconds\",\"type\":\"uint256\"}],\"name\":\"ProductRedeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ProductOwnershipOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"ProductOwnershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"productId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"Subscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"productId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"NewSubscription\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"productId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"SubscriptionExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"productId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"secondsTransferred\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"datacoinTransferred\",\"type\":\"uint256\"}],\"name\":\"SubscriptionTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dataInUsd\",\"type\":\"uint256\"}],\"name\":\"ExchangeRatesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Halted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Resumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Marketplace","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000cf0ee63788a0849fe5297f3407f701e122cc023000000000000000000000000195d3b9d5954780e1c6107c68965fccbdd2192ff","Library":"","SwarmSource":"bzzr://4eaa7a4e69d5a709267b8673bc887f45979d3f98e4297bc53939bffa67a77a8f"}]}