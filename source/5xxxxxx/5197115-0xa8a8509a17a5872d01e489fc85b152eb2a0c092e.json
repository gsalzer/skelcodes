{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\n//\r\n// SVLightBallotBox\r\n// Single use contract to manage a ballot\r\n// Author: Max Kaye <max@secure.vote>\r\n// License: MIT\r\n//\r\n// Architecture:\r\n// * Ballot authority declares public key with which to encrypt ballots (optional - stored in ballot spec)\r\n// * Users submit encrypted or plaintext ballots as blobs (dependent on above)\r\n// * These ballots are tracked by the ETH address of the sender\r\n// * Following the conclusion of the ballot, the secret key is provided\r\n//   by the ballot authority, and all users may transparently and\r\n//   independently validate the results\r\n//\r\n// Notes:\r\n// * Since ballots are encrypted the only validation we can do is length, but UI takes care of most of the rest\r\n//\r\n\r\n\r\ncontract SVLightBallotBox {\r\n    //// ** Storage Variables\r\n\r\n    // Std owner pattern\r\n    address public owner;\r\n\r\n    // test mode - operations like changing start/end times\r\n    bool public testMode = false;\r\n\r\n    // struct for ballot\r\n    struct Ballot {\r\n        bytes32 ballotData;\r\n        address sender;\r\n        // we use a uint32 here because addresses are 20 bytes and this might help\r\n        // solidity pack the block number well. gives us a little room to expand too if needed.\r\n        uint32 blockN;\r\n    }\r\n\r\n    // Maps to store ballots, along with corresponding log of voters.\r\n    // Should only be modified through `addBallotAndVoter` internal function\r\n    mapping (uint256 => Ballot) public ballotMap;\r\n    mapping (uint256 => bytes32) public associatedPubkeys;\r\n    uint256 public nVotesCast = 0;\r\n\r\n    // Use a map for voters to look up their ballot\r\n    mapping (address => uint256) public voterToBallotID;\r\n\r\n    // NOTE - We don't actually want to include the PublicKey because _it's included in the ballotSpec_.\r\n    // It's better to ensure ppl actually have the ballot spec by not including it in the contract.\r\n    // Plus we're already storing the hash of the ballotSpec anyway...\r\n\r\n    // Private key to be set after ballot conclusion - curve25519\r\n    bytes32 public ballotEncryptionSeckey;\r\n    bool seckeyRevealed = false;\r\n\r\n    // Timestamps for start and end of ballot (UTC)\r\n    uint64 public startTime;\r\n    uint64 public endTime;\r\n    uint64 public creationBlock;\r\n    uint64 public startingBlockAround;\r\n\r\n    // specHash by which to validate the ballots integrity\r\n    bytes32 public specHash;\r\n    bool public useEncryption;\r\n\r\n    // deprecation flag - doesn't actually do anything besides signal that this contract is deprecated;\r\n    bool public deprecated = false;\r\n\r\n    //// ** Events\r\n    event CreatedBallot(address _creator, uint64[2] _openPeriod, bool _useEncryption, bytes32 _specHash);\r\n    event SuccessfulPkVote(address voter, bytes32 ballot, bytes32 pubkey);\r\n    event SuccessfulVote(address voter, bytes32 ballot);\r\n    event SeckeyRevealed(bytes32 secretKey);\r\n    event TestingEnabled();\r\n    event Error(string error);\r\n    event DeprecatedContract();\r\n    event SetOwner(address _owner);\r\n\r\n\r\n    //// ** Modifiers\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier ballotOpen {\r\n        require(uint64(block.timestamp) >= startTime && uint64(block.timestamp) < endTime);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTesting {\r\n        require(testMode);\r\n        _;\r\n    }\r\n\r\n    modifier isTrue(bool _b) {\r\n        require(_b == true);\r\n        _;\r\n    }\r\n\r\n    modifier isFalse(bool _b) {\r\n        require(_b == false);\r\n        _;\r\n    }\r\n\r\n    //// ** Functions\r\n\r\n    uint16 constant F_USE_ENC = 0;\r\n    uint16 constant F_TESTING = 1;\r\n    // Constructor function - init core params on deploy\r\n    // timestampts are uint64s to give us plenty of room for millennia\r\n    // flags are [_useEncryption, enableTesting]\r\n    function SVLightBallotBox(bytes32 _specHash, uint64[2] openPeriod, bool[2] flags) public {\r\n        owner = msg.sender;\r\n\r\n        // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\r\n        // (which someone might be able to do if they could set the timestamp in the past)\r\n        startTime = max(openPeriod[0], uint64(block.timestamp));\r\n        endTime = openPeriod[1];\r\n        useEncryption = flags[F_USE_ENC];\r\n        specHash = _specHash;\r\n        creationBlock = uint64(block.number);\r\n        // add a rough prediction of what block is the starting block\r\n        startingBlockAround = uint64((startTime - block.timestamp) / 15 + block.number);\r\n\r\n        if (flags[F_TESTING]) {\r\n            testMode = true;\r\n            TestingEnabled();\r\n        }\r\n\r\n        CreatedBallot(msg.sender, [startTime, endTime], useEncryption, specHash);\r\n    }\r\n\r\n    // Ballot submission\r\n    function submitBallotWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) isTrue(useEncryption) ballotOpen public {\r\n        addBallotAndVoterWithPk(encryptedBallot, senderPubkey);\r\n        SuccessfulPkVote(msg.sender, encryptedBallot, senderPubkey);\r\n    }\r\n\r\n    function submitBallotNoPk(bytes32 ballot) isFalse(useEncryption) ballotOpen public {\r\n        addBallotAndVoterNoPk(ballot);\r\n        SuccessfulVote(msg.sender, ballot);\r\n    }\r\n\r\n    // Internal function to ensure atomicity of voter log\r\n    function addBallotAndVoterWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) internal {\r\n        uint256 ballotNumber = addBallotAndVoterNoPk(encryptedBallot);\r\n        associatedPubkeys[ballotNumber] = senderPubkey;\r\n    }\r\n\r\n    function addBallotAndVoterNoPk(bytes32 encryptedBallot) internal returns (uint256) {\r\n        uint256 ballotNumber = nVotesCast;\r\n        ballotMap[ballotNumber] = Ballot(encryptedBallot, msg.sender, uint32(block.number));\r\n        voterToBallotID[msg.sender] = ballotNumber;\r\n        nVotesCast += 1;\r\n        return ballotNumber;\r\n    }\r\n\r\n    // Allow the owner to reveal the secret key after ballot conclusion\r\n    function revealSeckey(bytes32 _secKey) onlyOwner public {\r\n        require(block.timestamp > endTime);\r\n\r\n        ballotEncryptionSeckey = _secKey;\r\n        seckeyRevealed = true; // this flag allows the contract to be locked\r\n        SeckeyRevealed(_secKey);\r\n    }\r\n\r\n    function getEncSeckey() public constant returns (bytes32) {\r\n        return ballotEncryptionSeckey;\r\n    }\r\n\r\n    // Test functions\r\n    function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public {\r\n        endTime = newEndTime;\r\n    }\r\n\r\n    function setDeprecated() onlyOwner public {\r\n        deprecated = true;\r\n        DeprecatedContract();\r\n    }\r\n\r\n    function setOwner(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n        SetOwner(newOwner);\r\n    }\r\n\r\n    // utils\r\n    function max(uint64 a, uint64 b) pure internal returns(uint64) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n\r\n\r\n//\r\n// The Index by which democracies and ballots are tracked (and optionally deployed).\r\n// Author: Max Kaye <max@secure.vote>\r\n// License: MIT\r\n//\r\n\r\ncontract SVLightIndex {\r\n\r\n    address public owner;\r\n\r\n    struct Ballot {\r\n        bytes32 specHash;\r\n        bytes32 extraData;\r\n        address votingContract;\r\n        uint64 startTs;\r\n    }\r\n\r\n    struct Democ {\r\n        string name;\r\n        address admin;\r\n        Ballot[] ballots;\r\n    }\r\n\r\n    mapping (bytes32 => Democ) public democs;\r\n    bytes32[] public democList;\r\n\r\n    // addresses that do not have to pay for democs\r\n    mapping (address => bool) public democWhitelist;\r\n    // democs that do not have to pay for issues\r\n    mapping (address => bool) public ballotWhitelist;\r\n\r\n    // payment details\r\n    address public payTo;\r\n    // uint128's used because they account for amounts up to 3.4e38 wei or 3.4e20 ether\r\n    uint128 public democFee = 0.05 ether; // 0.05 ether; about $50 at 3 March 2018\r\n    mapping (address => uint128) democFeeFor;\r\n    uint128 public ballotFee = 0.01 ether; // 0.01 ether; about $10 at 3 March 2018\r\n    mapping (address => uint128) ballotFeeFor;\r\n    bool public paymentEnabled = true;\r\n\r\n    uint8 constant PAY_DEMOC = 0;\r\n    uint8 constant PAY_BALLOT = 1;\r\n\r\n    function getPaymentParams(uint8 paymentType) internal constant returns (bool, uint128, uint128) {\r\n        if (paymentType == PAY_DEMOC) {\r\n            return (democWhitelist[msg.sender], democFee, democFeeFor[msg.sender]);\r\n        } else if (paymentType == PAY_BALLOT) {\r\n            return (ballotWhitelist[msg.sender], ballotFee, ballotFeeFor[msg.sender]);\r\n        } else {\r\n            assert(false);\r\n        }\r\n    }\r\n\r\n    //* EVENTS /\r\n\r\n    event PaymentMade(uint128[2] valAndRemainder);\r\n    event DemocInit(string name, bytes32 democHash, address admin);\r\n    event BallotInit(bytes32 specHash, uint64[2] openPeriod, bool[2] flags);\r\n    event BallotAdded(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract);\r\n    event SetFees(uint128[2] _newFees);\r\n    event PaymentEnabled(bool _feeEnabled);\r\n\r\n    //* MODIFIERS /\r\n\r\n    modifier onlyBy(address _account) {\r\n        require(msg.sender == _account);\r\n        _;\r\n    }\r\n\r\n    modifier payReq(uint8 paymentType) {\r\n        // get our whitelist, generalFee, and fee's for particular addresses\r\n        bool wl;\r\n        uint128 genFee;\r\n        uint128 feeFor;\r\n        (wl, genFee, feeFor) = getPaymentParams(paymentType);\r\n        // init v to something large in case of exploit or something\r\n        uint128 v = 1000 ether;\r\n        // check whitelists - do not require payment in some cases\r\n        if (paymentEnabled && !wl) {\r\n            v = feeFor;\r\n            if (v == 0){\r\n                // if there's no fee for the individual user then set it to the general fee\r\n                v = genFee;\r\n            }\r\n            require(msg.value >= v);\r\n\r\n            // handle payments\r\n            uint128 remainder = uint128(msg.value) - v;\r\n            payTo.transfer(v); // .transfer so it throws on failure\r\n            if (!msg.sender.send(remainder)){\r\n                payTo.transfer(remainder);\r\n            }\r\n            PaymentMade([v, remainder]);\r\n        }\r\n\r\n        // do main\r\n        _;\r\n    }\r\n\r\n\r\n    //* FUNCTIONS /\r\n\r\n\r\n    // constructor\r\n    function SVLightIndex() public {\r\n        owner = msg.sender;\r\n        payTo = msg.sender;\r\n    }\r\n\r\n    //* GLOBAL INFO */\r\n\r\n    function nDemocs() public constant returns (uint256) {\r\n        return democList.length;\r\n    }\r\n\r\n    //* PAYMENT AND OWNER FUNCTIONS */\r\n\r\n    function setPayTo(address newPayTo) onlyBy(owner) public {\r\n        payTo = newPayTo;\r\n    }\r\n\r\n    function setEth(uint128[2] newFees) onlyBy(owner) public {\r\n        democFee = newFees[PAY_DEMOC];\r\n        ballotFee = newFees[PAY_BALLOT];\r\n        SetFees([democFee, ballotFee]);\r\n    }\r\n\r\n    function setOwner(address _owner) onlyBy(owner) public {\r\n        owner = _owner;\r\n    }\r\n\r\n    function setPaymentEnabled(bool _enabled) onlyBy(owner) public {\r\n        paymentEnabled = _enabled;\r\n        PaymentEnabled(_enabled);\r\n    }\r\n\r\n    function setWhitelistDemoc(address addr, bool _free) onlyBy(owner) public {\r\n        democWhitelist[addr] = _free;\r\n    }\r\n\r\n    function setWhitelistBallot(address addr, bool _free) onlyBy(owner) public {\r\n        ballotWhitelist[addr] = _free;\r\n    }\r\n\r\n    function setFeeFor(address addr, uint128[2] fees) onlyBy(owner) public {\r\n        democFeeFor[addr] = fees[PAY_DEMOC];\r\n        ballotFeeFor[addr] = fees[PAY_BALLOT];\r\n    }\r\n\r\n    //* DEMOCRACY FUNCTIONS - INDIVIDUAL */\r\n\r\n    function initDemoc(string democName) payReq(PAY_DEMOC) public payable returns (bytes32) {\r\n        bytes32 democHash = keccak256(democName, msg.sender, democList.length, this);\r\n        democList.push(democHash);\r\n        democs[democHash].name = democName;\r\n        democs[democHash].admin = msg.sender;\r\n        DemocInit(democName, democHash, msg.sender);\r\n        return democHash;\r\n    }\r\n\r\n    function getDemocInfo(bytes32 democHash) public constant returns (string name, address admin, uint256 nBallots) {\r\n        return (democs[democHash].name, democs[democHash].admin, democs[democHash].ballots.length);\r\n    }\r\n\r\n    function setAdmin(bytes32 democHash, address newAdmin) onlyBy(democs[democHash].admin) public {\r\n        democs[democHash].admin = newAdmin;\r\n    }\r\n\r\n    function nBallots(bytes32 democHash) public constant returns (uint256) {\r\n        return democs[democHash].ballots.length;\r\n    }\r\n\r\n    function getNthBallot(bytes32 democHash, uint256 n) public constant returns (bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTime) {\r\n        return (democs[democHash].ballots[n].specHash, democs[democHash].ballots[n].extraData, democs[democHash].ballots[n].votingContract, democs[democHash].ballots[n].startTs);\r\n    }\r\n\r\n    //* ADD BALLOT TO RECORD */\r\n\r\n    function _commitBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTs) internal {\r\n        democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTs));\r\n        BallotAdded(democHash, specHash, extraData, votingContract);\r\n    }\r\n\r\n    function addBallot(bytes32 democHash, bytes32 extraData, address votingContract)\r\n                      onlyBy(democs[democHash].admin)\r\n                      payReq(PAY_BALLOT)\r\n                      public\r\n                      payable\r\n                      {\r\n        SVLightBallotBox bb = SVLightBallotBox(votingContract);\r\n        bytes32 specHash = bb.specHash();\r\n        uint64 startTs = bb.startTime();\r\n        _commitBallot(democHash, specHash, extraData, votingContract, startTs);\r\n    }\r\n\r\n    function deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData,\r\n                          uint64[2] openPeriod, bool[2] flags)\r\n                          onlyBy(democs[democHash].admin)\r\n                          payReq(PAY_BALLOT)\r\n                          public payable {\r\n        // the start time is max(startTime, block.timestamp) to avoid a DoS whereby a malicious electioneer could disenfranchise\r\n        // token holders who have recently acquired tokens.\r\n        uint64 startTs = max(openPeriod[0], uint64(block.timestamp));\r\n        SVLightBallotBox votingContract = new SVLightBallotBox(specHash, [startTs, openPeriod[1]], flags);\r\n        votingContract.setOwner(msg.sender);\r\n        _commitBallot(democHash, specHash, extraData, address(votingContract), startTs);\r\n        BallotInit(specHash, [startTs, openPeriod[1]], flags);\r\n    }\r\n\r\n    // utils\r\n    function max(uint64 a, uint64 b) pure internal returns(uint64) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_free\",\"type\":\"bool\"}],\"name\":\"setWhitelistBallot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"}],\"name\":\"getDemocInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"nBallots\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setPaymentEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"fees\",\"type\":\"uint128[2]\"}],\"name\":\"setFeeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nDemocs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPayTo\",\"type\":\"address\"}],\"name\":\"setPayTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"specHash\",\"type\":\"bytes32\"},{\"name\":\"extraData\",\"type\":\"bytes32\"},{\"name\":\"openPeriod\",\"type\":\"uint64[2]\"},{\"name\":\"flags\",\"type\":\"bool[2]\"}],\"name\":\"deployBallot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"democFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"democWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getNthBallot\",\"outputs\":[{\"name\":\"specHash\",\"type\":\"bytes32\"},{\"name\":\"extraData\",\"type\":\"bytes32\"},{\"name\":\"votingContract\",\"type\":\"address\"},{\"name\":\"startTime\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"democs\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"extraData\",\"type\":\"bytes32\"},{\"name\":\"votingContract\",\"type\":\"address\"}],\"name\":\"addBallot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_free\",\"type\":\"bool\"}],\"name\":\"setWhitelistDemoc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payTo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFees\",\"type\":\"uint128[2]\"}],\"name\":\"setEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ballotWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"}],\"name\":\"nBallots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ballotFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"democList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"democName\",\"type\":\"string\"}],\"name\":\"initDemoc\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"valAndRemainder\",\"type\":\"uint128[2]\"}],\"name\":\"PaymentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"democHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"DemocInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"specHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"openPeriod\",\"type\":\"uint64[2]\"},{\"indexed\":false,\"name\":\"flags\",\"type\":\"bool[2]\"}],\"name\":\"BallotInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"democHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"specHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"extraData\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"votingContract\",\"type\":\"address\"}],\"name\":\"BallotAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newFees\",\"type\":\"uint128[2]\"}],\"name\":\"SetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_feeEnabled\",\"type\":\"bool\"}],\"name\":\"PaymentEnabled\",\"type\":\"event\"}]","ContractName":"SVLightIndex","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2d4ab3817e2d3b679c38d218cb113aa8854e8d847df2c396a408db59a316ac17"}]}