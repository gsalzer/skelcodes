{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract TokenInterface {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function getMaxTotalSupply() public view returns (uint256);\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function transfer(address _to, uint256 _amount) public returns (bool);\r\n\r\n    function allowance(\r\n        address _who,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n\r\ncontract MiningTokenInterface {\r\n    function multiMint(address _to, uint256 _amount) external;\r\n    function getTokenTime(uint256 _tokenId) external returns(uint256);\r\n    function mint(address _to, uint256 _id) external;\r\n    function ownerOf(uint256 _tokenId) public view returns (address);\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function tokenByIndex(uint256 _index) public view returns (uint256);\r\n\r\n    function arrayOfTokensByAddress(address _holder)\r\n        public\r\n        view\r\n        returns(uint256[]);\r\n\r\n    function getTokensCount(address _owner) public returns(uint256);\r\n\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 _tokenId);\r\n}\r\n\r\n\r\ncontract Management {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public startPriceForHLPMT = 10000;\r\n    uint256 public maxHLPMTMarkup = 40000;\r\n    uint256 public stepForPrice = 1000;\r\n\r\n    uint256 public startTime;\r\n    uint256 public lastMiningTime;\r\n\r\n    // default value\r\n    uint256 public decimals = 18;\r\n\r\n    TokenInterface public token;\r\n    MiningTokenInterface public miningToken;\r\n\r\n    address public dao;\r\n    address public fund;\r\n    address public owner;\r\n\r\n    // num of mining times\r\n    uint256 public numOfMiningTimes;\r\n\r\n    mapping(address => uint256) public payments;\r\n    mapping(address => uint256) public paymentsTimestamps;\r\n\r\n    // mining time => mining reward\r\n    mapping(uint256 => uint256) internal miningReward;\r\n\r\n    // id mining token => getting reward last mining\r\n    mapping(uint256 => uint256) internal lastGettingReward;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDao() {\r\n        require(msg.sender == dao);\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _token,\r\n        address _miningToken,\r\n        address _dao,\r\n        address _fund\r\n    )\r\n        public\r\n    {\r\n        require(_token != address(0));\r\n        require(_miningToken != address(0));\r\n        require(_dao != address(0));\r\n        require(_fund != address(0));\r\n\r\n        startTime = now;\r\n        lastMiningTime = startTime - (startTime % (1 days)) - 1 days;\r\n        owner = msg.sender;\r\n\r\n        token = TokenInterface(_token);\r\n        miningToken = MiningTokenInterface(_miningToken);\r\n        dao = _dao;\r\n        fund = _fund;\r\n    }\r\n\r\n    /**\r\n     * @dev Exchanges the HLT tokens to HLPMT tokens. Works up to 48 HLPMT\r\n     * tokens at one-time buying. Should call after approving HLT tokens to\r\n     * manager address.\r\n     */\r\n    function buyHLPMT() external {\r\n\r\n        uint256 _currentTime = now;\r\n        uint256 _allowed = token.allowance(msg.sender, address(this));\r\n        uint256 _currentPrice = getPrice(_currentTime);\r\n        require(_allowed >= _currentPrice);\r\n\r\n        //remove the remainder\r\n        uint256 _hlpmtAmount = _allowed.div(_currentPrice);\r\n        _allowed = _hlpmtAmount.mul(_currentPrice);\r\n\r\n        require(token.transferFrom(msg.sender, fund, _allowed));\r\n\r\n        for (uint256 i = 0; i < _hlpmtAmount; i++) {\r\n            uint256 _id = miningToken.totalSupply();\r\n            miningToken.mint(msg.sender, _id);\r\n            lastGettingReward[_id] = numOfMiningTimes;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Produces the mining process and sends reward to dao and fund.\r\n     */\r\n    function mining() external {\r\n\r\n        uint256 _currentTime = now;\r\n        require(_currentTime > _getEndOfLastMiningDay());\r\n\r\n\r\n        uint256 _missedDays = (_currentTime - lastMiningTime) / (1 days);\r\n\r\n        updateLastMiningTime(_currentTime);\r\n\r\n        for (uint256 i = 0; i < _missedDays; i++) {\r\n            // 0.1% daily from remaining unmined tokens.\r\n            uint256 _dailyTokens = token.getMaxTotalSupply().sub(token.totalSupply()).div(1000);\r\n\r\n            uint256 _tokensToDao = _dailyTokens.mul(3).div(10); // 30 percent\r\n            token.mint(dao, _tokensToDao);\r\n\r\n            uint256 _tokensToFund = _dailyTokens.mul(3).div(10); // 30 percent\r\n            token.mint(fund, _tokensToFund);\r\n\r\n            uint256 _miningTokenSupply = miningToken.totalSupply();\r\n            uint256 _tokensToMiners = _dailyTokens.mul(4).div(10); // 40 percent\r\n            uint256 _tokensPerMiningToken = _tokensToMiners.div(_miningTokenSupply);\r\n\r\n            miningReward[++numOfMiningTimes] = _tokensPerMiningToken;\r\n\r\n            token.mint(address(this), _tokensToMiners);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sends the daily mining reward to HLPMT holder.\r\n     */\r\n    function getReward(uint256[] tokensForReward) external {\r\n        uint256 _rewardAmount = 0;\r\n        for (uint256 i = 0; i < tokensForReward.length; i++) {\r\n            if (\r\n                msg.sender == miningToken.ownerOf(tokensForReward[i]) &&\r\n                numOfMiningTimes > getLastRewardTime(tokensForReward[i])\r\n            ) {\r\n                _rewardAmount += _calculateReward(tokensForReward[i]);\r\n                setLastRewardTime(tokensForReward[i], numOfMiningTimes);\r\n            }\r\n        }\r\n\r\n        require(_rewardAmount > 0);\r\n        token.transfer(msg.sender, _rewardAmount);\r\n    }\r\n\r\n    function checkReward(uint256[] tokensForReward) external view returns (uint256) {\r\n        uint256 reward = 0;\r\n\r\n        for (uint256 i = 0; i < tokensForReward.length; i++) {\r\n            if (numOfMiningTimes > getLastRewardTime(tokensForReward[i])) {\r\n                reward += _calculateReward(tokensForReward[i]);\r\n            }\r\n        }\r\n\r\n        return reward;\r\n    }\r\n\r\n    /**\r\n     * @param _tokenId token id\r\n     * @return timestamp of token creation\r\n     */\r\n    function getLastRewardTime(uint256 _tokenId) public view returns(uint256) {\r\n        return lastGettingReward[_tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev Sends the daily mining reward to HLPMT holder.\r\n    */\r\n    function sendReward(uint256[] tokensForReward) public onlyOwner {\r\n        for (uint256 i = 0; i < tokensForReward.length; i++) {\r\n            if (numOfMiningTimes > getLastRewardTime(tokensForReward[i])) {\r\n                uint256 reward = _calculateReward(tokensForReward[i]);\r\n                setLastRewardTime(tokensForReward[i], numOfMiningTimes);\r\n                token.transfer(miningToken.ownerOf(tokensForReward[i]), reward);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the HLPMT token amount of holder.\r\n     */\r\n    function miningTokensOf(address holder) public view returns (uint256[]) {\r\n        return miningToken.arrayOfTokensByAddress(holder);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the DAO address\r\n     * @param _dao DAO address.\r\n     */\r\n    function setDao(address _dao) public onlyOwner {\r\n        require(_dao != address(0));\r\n        dao = _dao;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the fund address\r\n     * @param _fund Fund address.\r\n     */\r\n    function setFund(address _fund) public onlyOwner {\r\n        require(_fund != address(0));\r\n        fund = _fund;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the token address\r\n     * @param _token Token address.\r\n     */\r\n    function setToken(address _token) public onlyOwner {\r\n        require(_token != address(0));\r\n        token = TokenInterface(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the mining token address\r\n     * @param _miningToken Mining token address.\r\n     */\r\n    function setMiningToken(address _miningToken) public onlyOwner {\r\n        require(_miningToken != address(0));\r\n        miningToken = MiningTokenInterface(_miningToken);\r\n    }\r\n\r\n    /**\r\n     * @return uint256 the current HLPMT token price in HLT (without decimals).\r\n     */\r\n    function getPrice(uint256 _timestamp) public view returns(uint256) {\r\n        uint256 _raising = _timestamp.sub(startTime).div(30 days);\r\n        _raising = _raising.mul(stepForPrice);\r\n        if (_raising > maxHLPMTMarkup) _raising = maxHLPMTMarkup;\r\n        return (startPriceForHLPMT + _raising) * 10 ** 18;\r\n    }\r\n\r\n    /**\r\n     * @param _numOfMiningTime is time\r\n     * @return getting token reward\r\n     */\r\n    function getMiningReward(uint256 _numOfMiningTime) public view returns (uint256) {\r\n        return miningReward[_numOfMiningTime];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the calculated reward amount.\r\n     */\r\n    function _calculateReward(uint256 tokenID)\r\n        internal\r\n        view\r\n        returns (uint256 reward)\r\n    {\r\n        for (uint256 i = getLastRewardTime(tokenID) + 1; i <= numOfMiningTimes; i++) {\r\n            reward += miningReward[i];\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    /**\r\n     * @dev set last getting token reward time\r\n     */\r\n    function setLastRewardTime(uint256 _tokenId, uint256 _num) internal {\r\n        lastGettingReward[_tokenId] = _num;\r\n    }\r\n\r\n    /**\r\n     * @dev set last getting token reward time\r\n     */\r\n    function updateLastMiningTime(uint256 _currentTime) internal {\r\n        lastMiningTime = _currentTime - _currentTime % (1 days);\r\n    }\r\n\r\n    /**\r\n     * @return uint256 the unix timestamp of the end of the last mining day.\r\n     */\r\n    function _getEndOfLastMiningDay() internal view returns(uint256) {\r\n        return lastMiningTime + 1 days;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw accumulated balance, called by payee.\r\n     */\r\n    function withdrawPayments() public {\r\n        address payee = msg.sender;\r\n        uint256 payment = payments[payee];\r\n        uint256 timestamp = paymentsTimestamps[payee];\r\n\r\n        require(payment != 0);\r\n        require(now >= timestamp);\r\n\r\n        payments[payee] = 0;\r\n\r\n        require(token.transfer(msg.sender, payment));\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the payer to store the sent _amount as credit to be pulled.\r\n     * @param _dest The destination address of the funds.\r\n     * @param _amount The amount to transfer.\r\n     */\r\n    function asyncSend(address _dest, uint256 _amount, uint256 _timestamp) external onlyDao {\r\n        payments[_dest] = payments[_dest].add(_amount);\r\n        paymentsTimestamps[_dest] = _timestamp;\r\n        require(token.transferFrom(dao, address(this), _amount));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_fund\",\"type\":\"address\"}],\"name\":\"setFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxHLPMTMarkup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokensForReward\",\"type\":\"uint256[]\"}],\"name\":\"checkReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_numOfMiningTime\",\"type\":\"uint256\"}],\"name\":\"getMiningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensForReward\",\"type\":\"uint256[]\"}],\"name\":\"sendReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stepForPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dao\",\"type\":\"address\"}],\"name\":\"setDao\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensForReward\",\"type\":\"uint256[]\"}],\"name\":\"getReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLastRewardTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_miningToken\",\"type\":\"address\"}],\"name\":\"setMiningToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastMiningTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfMiningTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"paymentsTimestamps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyHLPMT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"miningTokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPriceForHLPMT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"asyncSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_miningToken\",\"type\":\"address\"},{\"name\":\"_dao\",\"type\":\"address\"},{\"name\":\"_fund\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Management","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a809d363a66c576a2a814cdbfefc107c600a55f0000000000000000000000000024008f43b1956e111cdb88a76b517cb4b241c7e0000000000000000000000005c494af65a4ffb845e3bdc7ead982ec1f17512930000000000000000000000003c106def064bdc10408c0a8a6bd9e30c4726408a","Library":"","SwarmSource":"bzzr://e29196431787e014349a30cb50954c0f2d7de76bf714fef6b392650ab58f2a66"}]}