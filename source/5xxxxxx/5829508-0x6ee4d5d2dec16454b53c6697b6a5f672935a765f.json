{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Note for the truffle testversion:\r\n * DragonKingTest inherits from DragonKing and adds one more function for testing the volcano from truffle.\r\n * For deployment on ropsten or mainnet, just deploy the DragonKing contract and remove this comment before verifying on\r\n * etherscan.\r\n * */\r\n\r\n /**\r\n  * Dragonking is a blockchain game in which players may purchase dragons and knights of different levels and values.\r\n  * Once every period of time the volcano erupts and wipes a few of them from the board. The value of the killed characters\r\n  * gets distributed amongst all of the survivors. The dragon king receive a bigger share than the others.\r\n  * In contrast to dragons, knights need to be teleported to the battlefield first with the use of teleport tokens.\r\n  * Additionally, they may attack a dragon once per period.\r\n  * Both character types can be protected from death up to three times.\r\n  * Take a look at dragonking.io for more detailed information.\r\n  * @author: Julia Altenried, Yuriy Kashnikov\r\n  * */\r\n\r\npragma solidity ^0.4.17;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract mortal is Ownable {\r\n\taddress owner;\r\n\r\n\tfunction mortal() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tfunction kill() internal {\r\n\t\tsuicide(owner);\r\n\t}\r\n}\r\n\r\ncontract Token {\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {}\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n}\r\n\r\ncontract DragonKing is mortal {\r\n\r\n\tstruct Character {\r\n\t\tuint8 characterType;\r\n\t\tuint128 value;\r\n\t\taddress owner;\r\n\t\tuint64 purchaseTimestamp;\r\n\t}\r\n\r\n\t/** array holding ids of the curret characters*/\r\n\tuint32[] public ids;\r\n\t/** the id to be given to the next character **/\r\n\tuint32 public nextId;\r\n\t/** the id of the oldest character */\r\n\tuint32 public oldest;\r\n\t/** the character belonging to a given id */\r\n\tmapping(uint32 => Character) characters;\r\n\t/** teleported knights **/\r\n\tmapping(uint32 => bool) teleported;\r\n\t/** the cost of each character type */\r\n\tuint128[] public costs;\r\n\t/** the value of each character type (cost - fee), so it's not necessary to compute it each time*/\r\n\tuint128[] public values;\r\n\t/** the fee to be paid each time an character is bought in percent*/\r\n\tuint8 fee;\r\n\t/** the number of dragon types **/\r\n\tuint8 constant public numDragonTypes = 6;\r\n\t/* the number of balloons types */\r\n\tuint8 constant public numOfBalloonsTypes = 3;\r\n\t/** constant used to signal that there is no King at the moment **/\r\n\tuint32 constant public noKing = ~uint32(0);\r\n\r\n\t/** total number of characters in the game  */\r\n\tuint16 public numCharacters;\r\n\t/** The maximum of characters allowed in the game */\r\n\tuint16 public maxCharacters;\r\n\t/** number of characters per type */\r\n\tmapping(uint8 => uint16) public numCharactersXType;\r\n\r\n\r\n\t/** the amount of time that should pass since last eruption **/\r\n\tuint public eruptionThreshold;\r\n\t/** timestampt of the last eruption event **/\r\n\tuint256 public lastEruptionTimestamp;\r\n\t/** how many characters to kill in %, e.g. 20 will stand for 20%, should be < 100 **/\r\n\tuint8 public percentageToKill;\r\n\r\n\t/** knight cooldown. contains the timestamp of the earliest possible moment to start a fight */\r\n\tmapping(uint32 => uint) public cooldown;\r\n\tuint256 public constant CooldownThreshold = 1 days;\r\n\t/** fight factor, used to compute extra probability in fight **/\r\n\tuint8 public fightFactor;\r\n\r\n\t/** the teleport token contract used to send knights to the game scene */\r\n\tToken public teleportToken;\r\n\t/** the price for teleportation*/\r\n\tuint public teleportPrice;\r\n\t/** the neverdue token contract used to purchase protection from eruptions and fights */\r\n\tToken public neverdieToken;\r\n\t/** the price for protection */\r\n\tuint public protectionPrice;\r\n\t/** tells the number of times a character is protected */\r\n\tmapping(uint32 => uint8) public protection;\r\n\r\n\t/** the SKL token contract **/\r\n\tToken public sklToken;\r\n\t/** the XP token contract **/\r\n\tToken public xperToken;\r\n\r\n\t// EVENTS\r\n\r\n\t/** is fired when new characters are purchased (who bought how many characters of which type?) */\r\n\tevent NewPurchase(address player, uint8 characterType, uint16 amount, uint32 startId);\r\n\t/** is fired when a player leaves the game */\r\n\tevent NewExit(address player, uint256 totalBalance, uint32[] removedCharacters);\r\n\t/** is fired when an eruption occurs */\r\n\tevent NewEruption(uint32[] hitCharacters, uint128 value, uint128 gasCost);\r\n\t/** is fired when a single character is sold **/\r\n\tevent NewSell(uint32 characterId, address player, uint256 value);\r\n\t/** is fired when a knight fights a dragon **/\r\n\tevent NewFight(uint32 winnerID, uint32 loserID, uint256 value, uint16 probability, uint16 dice);\r\n\t/** is fired when a knight is teleported to the field **/\r\n\tevent NewTeleport(uint32 characterId);\r\n\t/** is fired when a protection is purchased **/\r\n\tevent NewProtection(uint32 characterId, uint8 lifes);\r\n\r\n\t/** initializes the contract parameters\t */\r\n\tfunction DragonKing(address teleportTokenAddress,\r\n\t\t\t\t\t\t\t\t\t\t\taddress neverdieTokenAddress,\r\n\t\t\t\t\t\t\t\t\t\t\taddress sklTokenAddress,\r\n\t\t\t\t\t\t\t\t\t\t\taddress xperTokenAddress,\r\n\t\t\t\t\t\t\t\t\t\t\tuint8 eruptionThresholdInHours,\r\n\t\t\t\t\t\t\t\t\t\t\tuint8 percentageOfCharactersToKill,\r\n\t\t\t\t\t\t\t\t\t\t\tuint8 characterFee,\r\n\t\t\t\t\t\t\t\t\t\t\tuint16[] charactersCosts,\r\n\t\t\t\t\t\t\t\t\t\t\tuint16[] balloonsCosts) public onlyOwner {\r\n\t\tfee = characterFee;\r\n\t\tfor (uint8 i = 0; i < charactersCosts.length * 2; i++) {\r\n\t\t\tcosts.push(uint128(charactersCosts[i % numDragonTypes]) * 1 finney);\r\n\t\t\tvalues.push(costs[i] - costs[i] / 100 * fee);\r\n\t\t}\r\n\t\tuint256 balloonsIndex = charactersCosts.length * 2;\r\n\t\tfor (uint8 j = 0; j < balloonsCosts.length; j++) {\r\n\t\t\tcosts.push(uint128(balloonsCosts[j]) * 1 finney);\r\n\t\t\tvalues.push(costs[balloonsIndex + j] - costs[balloonsIndex + j] / 100 * fee);\r\n\t\t}\r\n\t\teruptionThreshold = uint256(eruptionThresholdInHours) * 60 * 60; // convert to seconds\r\n\t\tpercentageToKill = percentageOfCharactersToKill;\r\n\t\tmaxCharacters = 600;\r\n\t\tnextId = 1;\r\n\t\tteleportToken = Token(teleportTokenAddress);\r\n\t\tteleportPrice = 1000000000000000000;\r\n\t\tneverdieToken = Token(neverdieTokenAddress);\r\n\t\tprotectionPrice = 1000000000000000000;\r\n\t\tfightFactor = 4;\r\n\t\tsklToken = Token(sklTokenAddress);\r\n\t\txperToken = Token(xperTokenAddress);\r\n\t}\r\n\r\n\t/**\r\n\t * buys as many characters as possible with the transfered value of the given type\r\n\t * @param characterType the type of the character\r\n\t */\r\n\tfunction addCharacters(uint8 characterType) payable public {\r\n\t\trequire(tx.origin == msg.sender);\r\n\t\tuint16 amount = uint16(msg.value / costs[characterType]);\r\n\t\tuint16 nchars = numCharacters;\r\n\t\tif (characterType >= costs.length || msg.value < costs[characterType] || nchars + amount > maxCharacters) revert();\r\n\t\tuint32 nid = nextId;\r\n\t\t//if type exists, enough ether was transferred and there are less than maxCharacters characters in the game\r\n\t\tif (characterType < numDragonTypes) {\r\n\t\t\t//dragons enter the game directly\r\n\t\t\tif (oldest == 0 || oldest == noKing)\r\n\t\t\t\toldest = nid;\r\n\t\t\tfor (uint8 i = 0; i < amount; i++) {\r\n\t\t\t\taddCharacter(nid + i, nchars + i);\r\n\t\t\t\tcharacters[nid + i] = Character(characterType, values[characterType], msg.sender, uint64(now));\r\n\t\t\t}\r\n\t\t\tnumCharactersXType[characterType] += amount;\r\n\t\t\tnumCharacters += amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// to enter game knights should be teleported later\r\n\t\t\tfor (uint8 j = 0; j < amount; j++) {\r\n\t\t\t\tcharacters[nid + j] = Character(characterType, values[characterType], msg.sender, uint64(now));\r\n\t\t\t}\r\n\t\t}\r\n\t\tnextId = nid + amount;\r\n\t\tNewPurchase(msg.sender, characterType, amount, nid);\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * adds a single dragon of the given type to the ids array, which is used to iterate over all characters\r\n\t * @param nId the id the character is about to receive\r\n\t * @param nchars the number of characters currently in the game\r\n\t */\r\n\tfunction addCharacter(uint32 nId, uint16 nchars) internal {\r\n\t\tif (nchars < ids.length)\r\n\t\t\tids[nchars] = nId;\r\n\t\telse\r\n\t\t\tids.push(nId);\r\n\t}\r\n\r\n\t/**\r\n\t * leave the game.\r\n\t * pays out the sender's balance and removes him and his characters from the game\r\n\t * */\r\n\tfunction exit() public {\r\n\t\tuint32[] memory removed = new uint32[](50);\r\n\t\tuint8 count;\r\n\t\tuint32 lastId;\r\n\t\tuint playerBalance;\r\n\t\tuint16 nchars = numCharacters;\r\n\t\tfor (uint16 i = 0; i < nchars; i++) {\r\n\t\t\tif (characters[ids[i]].owner == msg.sender \r\n\t\t\t\t\t&& characters[ids[i]].purchaseTimestamp + 1 days < now\r\n\t\t\t\t\t&& characters[ids[i]].characterType < 2*numDragonTypes) {\r\n\t\t\t\t//first delete all characters at the end of the array\r\n\t\t\t\twhile (nchars > 0 \r\n\t\t\t\t\t\t&& characters[ids[nchars - 1]].owner == msg.sender \r\n\t\t\t\t\t\t&& characters[ids[nchars - 1]].purchaseTimestamp + 1 days < now\r\n\t\t\t\t\t\t&& characters[ids[nchars - 1]].characterType < 2*numDragonTypes) {\r\n\t\t\t\t\tnchars--;\r\n\t\t\t\t\tlastId = ids[nchars];\r\n\t\t\t\t\tnumCharactersXType[characters[lastId].characterType]--;\r\n\t\t\t\t\tplayerBalance += characters[lastId].value;\r\n\t\t\t\t\tremoved[count] = lastId;\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t\tif (lastId == oldest) oldest = 0;\r\n\t\t\t\t\tdelete characters[lastId];\r\n\t\t\t\t}\r\n\t\t\t\t//replace the players character by the last one\r\n\t\t\t\tif (nchars > i + 1) {\r\n\t\t\t\t\tplayerBalance += characters[ids[i]].value;\r\n\t\t\t\t\tremoved[count] = ids[i];\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t\tnchars--;\r\n\t\t\t\t\treplaceCharacter(i, nchars);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tnumCharacters = nchars;\r\n\t\tNewExit(msg.sender, playerBalance, removed); //fire the event to notify the client\r\n\t\tmsg.sender.transfer(playerBalance);\r\n\t\tif (oldest == 0)\r\n\t\t\tfindOldest();\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces the character with the given id with the last character in the array\r\n\t * @param index the index of the character in the id array\r\n\t * @param nchars the number of characters\r\n\t * */\r\n\tfunction replaceCharacter(uint16 index, uint16 nchars) internal {\r\n\t\tuint32 characterId = ids[index];\r\n\t\tnumCharactersXType[characters[characterId].characterType]--;\r\n\t\tif (characterId == oldest) oldest = 0;\r\n\t\tdelete characters[characterId];\r\n\t\tids[index] = ids[nchars];\r\n\t\tdelete ids[nchars];\r\n\t}\r\n\r\n\t/**\r\n\t * The volcano eruption can be triggered by anybody but only if enough time has passed since the last eription.\r\n\t * The volcano hits up to a certain percentage of characters, but at least one.\r\n\t * The percantage is specified in 'percentageToKill'\r\n\t * */\r\n\r\n\tfunction triggerVolcanoEruption() public {\r\n\t    require(tx.origin == msg.sender);\r\n\t\trequire(now >= lastEruptionTimestamp + eruptionThreshold);\r\n\t\trequire(numCharacters>0);\r\n\t\tlastEruptionTimestamp = now;\r\n\t\tuint128 pot;\r\n\t\tuint128 value;\r\n\t\tuint16 random;\r\n\t\tuint32 nextHitId;\r\n\t\tuint16 nchars = numCharacters;\r\n\t\tuint32 howmany = nchars * percentageToKill / 100;\r\n\t\tuint128 neededGas = 80000 + 10000 * uint32(nchars);\r\n\t\tif(howmany == 0) howmany = 1;//hit at least 1\r\n\t\tuint32[] memory hitCharacters = new uint32[](howmany);\r\n\t\tfor (uint8 i = 0; i < howmany; i++) {\r\n\t\t\trandom = uint16(generateRandomNumber(lastEruptionTimestamp + i) % nchars);\r\n\t\t\tnextHitId = ids[random];\r\n\t\t\thitCharacters[i] = nextHitId;\r\n\t\t\tvalue = hitCharacter(random, nchars);\r\n\t\t\tif (value > 0) {\r\n\t\t\t\tnchars--;\r\n\t\t\t}\r\n\t\t\tpot += value;\r\n\t\t}\r\n\t\tuint128 gasCost = uint128(neededGas * tx.gasprice);\r\n\t\tnumCharacters = nchars;\r\n\t\tif (pot > gasCost){\r\n\t\t\tdistribute(pot - gasCost); //distribute the pot minus the oraclize gas costs\r\n\t\t\tNewEruption(hitCharacters, pot - gasCost, gasCost);\r\n\t\t}\r\n\t\telse\r\n\t\t\tNewEruption(hitCharacters, 0, gasCost);\r\n\t}\r\n\r\n\t/**\r\n\t * A knight may attack a dragon, but not choose which one.\r\n\t * The value of the loser is transfered to the winner.\r\n\t * @param knightID the ID of the knight to perfrom the attack\r\n\t * @param knightIndex the index of the knight in the ids-array. Just needed to save gas costs.\r\n\t *\t\t\t\t\t\tIn case it's unknown or incorrect, the index is looked up in the array.\r\n\t * */\r\n\tfunction fight(uint32 knightID, uint16 knightIndex) public {\r\n\t\trequire(tx.origin == msg.sender);\r\n\t\tif (knightID != ids[knightIndex])\r\n\t\t\tknightIndex = getCharacterIndex(knightID);\r\n\t\tCharacter storage knight = characters[knightID];\r\n\t\trequire(cooldown[knightID] + CooldownThreshold <= now);\r\n\t\trequire(knight.owner == msg.sender);\r\n\t\trequire(knight.characterType < 2*numDragonTypes); // knight is not a balloon\r\n\t\trequire(knight.characterType >= numDragonTypes);\r\n\t\tuint16 dragonIndex = getRandomDragon(knightID);\r\n\t\tassert(dragonIndex < maxCharacters);\r\n\t\tuint32 dragonID = ids[dragonIndex];\r\n\t\tCharacter storage dragon = characters[dragonID];\r\n\t\tuint128 value;\r\n\t\tuint16 base_probability;\r\n\t\tuint16 dice = uint16(generateRandomNumber(knightID) % 100);\r\n\t\tuint256 knightPower = sklToken.balanceOf(knight.owner) / 10**15 + xperToken.balanceOf(knight.owner);\r\n\t\tuint256 dragonPower = sklToken.balanceOf(dragon.owner) / 10**15 + xperToken.balanceOf(dragon.owner);\r\n\t\tif (knight.value == dragon.value) {\r\n\t\t\t\tbase_probability = 50;\r\n\t\t\tif (knightPower > dragonPower) {\r\n\t\t\t\tbase_probability += uint16(100 / fightFactor);\r\n\t\t\t} else if (dragonPower > knightPower) {\r\n\t\t\t\tbase_probability -= uint16(100 / fightFactor);\r\n\t\t\t}\r\n\t\t} else if (knight.value > dragon.value) {\r\n\t\t\tbase_probability = 100;\r\n\t\t\tif (dragonPower > knightPower) {\r\n\t\t\t\tbase_probability -= uint16((100 * dragon.value) / knight.value / fightFactor);\r\n\t\t\t}\r\n\t\t} else if (knightPower > dragonPower) {\r\n\t\t\t\tbase_probability += uint16((100 * knight.value) / dragon.value / fightFactor);\r\n\t\t}\r\n  \r\n\t\tcooldown[knightID] = now;\r\n\t\tif (dice >= base_probability) {\r\n\t\t\t// dragon won\r\n\t\t\tvalue = hitCharacter(knightIndex, numCharacters);\r\n\t\t\tif (value > 0) {\r\n\t\t\t\tnumCharacters--;\r\n\t\t\t}\r\n\t\t\tdragon.value += value;\r\n\t\t\tNewFight(dragonID, knightID, value, base_probability, dice);\r\n\t\t} else {\r\n\t\t\t// knight won\r\n\t\t\tvalue = hitCharacter(dragonIndex, numCharacters);\r\n\t\t\tif (value > 0) {\r\n\t\t\t\tnumCharacters--;\r\n\t\t\t}\r\n\t\t\tknight.value += value;\r\n\t\t\tif (oldest == 0) findOldest();\r\n\t\t\tNewFight(knightID, dragonID, value, base_probability, dice);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * pick a random dragon.\r\n\t * @param nonce a nonce to make sure there's not always the same dragon chosen in a single block.\r\n\t * @return the index of a random dragon\r\n\t * */\r\n\tfunction getRandomDragon(uint256 nonce) internal view returns(uint16) {\r\n\t\tuint16 randomIndex = uint16(generateRandomNumber(nonce) % numCharacters);\r\n\t\t//use 7, 11 or 13 as step size. scales for up to 1000 characters\r\n\t\tuint16 stepSize = numCharacters % 7 == 0 ? (numCharacters % 11 == 0 ? 13 : 11) : 7;\r\n\t\tuint16 i = randomIndex;\r\n\t\t//if the picked character is a knight or belongs to the sender, look at the character + stepSizes ahead in the array (modulo the total number)\r\n\t\t//will at some point return to the startingPoint if no character is suited\r\n\t\tdo {\r\n\t\t\tif (characters[ids[i]].characterType < numDragonTypes && characters[ids[i]].owner != msg.sender) return i;\r\n\t\t\ti = (i + stepSize) % numCharacters;\r\n\t\t} while (i != randomIndex);\r\n\t\treturn maxCharacters + 1; //there is none\r\n\t}\r\n\r\n\t/**\r\n\t * generate a random number.\r\n\t * @param nonce a nonce to make sure there's not always the same number returned in a single block.\r\n\t * @return the random number\r\n\t * */\r\n\tfunction generateRandomNumber(uint256 nonce) internal view returns(uint) {\r\n\t\treturn uint(keccak256(block.blockhash(block.number - 1), now, numCharacters, nonce));\r\n\t}\r\n\r\n\t/**\r\n\t * Hits the character of the given type at the given index.\r\n\t * @param index the index of the character\r\n\t * @param nchars the number of characters\r\n\t * @return the value gained from hitting the characters (zero is the character was protected)\r\n\t * */\r\n\tfunction hitCharacter(uint16 index, uint16 nchars) internal returns(uint128 characterValue) {\r\n\t\tuint32 id = ids[index];\r\n\t\tif (protection[id] > 0) {\r\n\t\t\tprotection[id]--;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tcharacterValue = characters[ids[index]].value;\r\n\t\tnchars--;\r\n\t\treplaceCharacter(index, nchars);\r\n\t}\r\n\r\n\t/**\r\n\t * finds the oldest character\r\n\t * */\r\n\tfunction findOldest() public {\r\n\t\tuint32 newOldest = noKing;\r\n\t\tfor (uint16 i = 0; i < numCharacters; i++) {\r\n\t\t\tif (ids[i] < newOldest && characters[ids[i]].characterType < numDragonTypes)\r\n\t\t\t\tnewOldest = ids[i];\r\n\t\t}\r\n\t\toldest = newOldest;\r\n\t}\r\n\r\n\t/**\r\n\t* distributes the given amount among the surviving characters\r\n\t* @param totalAmount nthe amount to distribute\r\n\t*/\r\n\tfunction distribute(uint128 totalAmount) internal {\r\n\t\tuint128 amount;\r\n\t\tif (oldest == 0)\r\n\t\t\tfindOldest();\r\n\t\tif (oldest != noKing) {\r\n\t\t\t//pay 10% to the oldest dragon\r\n\t\t\tcharacters[oldest].value += totalAmount / 10;\r\n\t\t\tamount\t= totalAmount / 10 * 9;\r\n\t\t} else {\r\n\t\t\tamount\t= totalAmount;\r\n\t\t}\r\n\t\t//distribute the rest according to their type\r\n\t\tuint128 valueSum;\r\n\t\tuint8 size = 2 * numDragonTypes;\r\n\t\tuint128[] memory shares = new uint128[](size);\r\n\t\tfor (uint8 v = 0; v < size; v++) {\r\n\t\t\tif (numCharactersXType[v] > 0) valueSum += values[v];\r\n\t\t}\r\n\t\tfor (uint8 m = 0; m < size; m++) {\r\n\t\t\tif (numCharactersXType[m] > 0)\r\n\t\t\t\tshares[m] = amount * values[m] / valueSum / numCharactersXType[m];\r\n\t\t}\r\n\t\tuint8 cType;\r\n\t\tfor (uint16 i = 0; i < numCharacters; i++) {\r\n\t\t\tcType = characters[ids[i]].characterType;\r\n\t\t\tif(cType < size)\r\n\t\t\t\tcharacters[ids[i]].value += shares[characters[ids[i]].characterType];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * allows the owner to collect the accumulated fees\r\n\t * sends the given amount to the owner's address if the amount does not exceed the\r\n\t * fees (cannot touch the players' balances) minus 100 finney (ensure that oraclize fees can be paid)\r\n\t * @param amount the amount to be collected\r\n\t * */\r\n\tfunction collectFees(uint128 amount) public onlyOwner {\r\n\t\tuint collectedFees = getFees();\r\n\t\tif (amount + 100 finney < collectedFees) {\r\n\t\t\towner.transfer(amount);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* withdraw NDC and TPT tokens\r\n\t*/\r\n\tfunction withdraw() public onlyOwner {\r\n\t\tuint256 ndcBalance = neverdieToken.balanceOf(this);\r\n\t\tassert(neverdieToken.transfer(owner, ndcBalance));\r\n\t\tuint256 tptBalance = teleportToken.balanceOf(this);\r\n\t\tassert(teleportToken.transfer(owner, tptBalance));\r\n\t}\r\n\r\n\t/**\r\n\t * pays out the players.\r\n\t * */\r\n\tfunction payOut() public onlyOwner {\r\n\t\tfor (uint16 i = 0; i < numCharacters; i++) {\r\n\t\t\tcharacters[ids[i]].owner.transfer(characters[ids[i]].value);\r\n\t\t\tdelete characters[ids[i]];\r\n\t\t}\r\n\t\tdelete ids;\r\n\t\tnumCharacters = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * pays out the players and kills the game.\r\n\t * */\r\n\tfunction stop() public onlyOwner {\r\n\t\twithdraw();\r\n\t\tpayOut();\r\n\t\tkill();\r\n\t}\r\n\r\n\t/**\r\n\t * sell the character of the given id\r\n\t * throws an exception in case of a knight not yet teleported to the game\r\n\t * @param characterId the id of the character\r\n\t * */\r\n\tfunction sellCharacter(uint32 characterId) public {\r\n\t\trequire(tx.origin == msg.sender);\r\n\t\trequire(msg.sender == characters[characterId].owner);\r\n\t\trequire(characters[characterId].characterType < 2*numDragonTypes);\r\n\t\trequire(characters[characterId].purchaseTimestamp + 1 days < now);\r\n\t\tuint128 val = characters[characterId].value;\r\n\t\tnumCharacters--;\r\n\t\treplaceCharacter(getCharacterIndex(characterId), numCharacters);\r\n\t\tmsg.sender.transfer(val);\r\n\t\tif (oldest == 0)\r\n\t\t\tfindOldest();\r\n\t\tNewSell(characterId, msg.sender, val);\r\n\t}\r\n\r\n\t/**\r\n\t * receive approval to spend some tokens.\r\n\t * used for teleport and protection.\r\n\t * @param sender the sender address\r\n\t * @param value the transferred value\r\n\t * @param tokenContract the address of the token contract\r\n\t * @param callData the data passed by the token contract\r\n\t * */\r\n\tfunction receiveApproval(address sender, uint256 value, address tokenContract, bytes callData) public {\r\n\t\tuint32 id;\r\n\t\tuint256 price;\r\n\t\tif (msg.sender == address(teleportToken)) {\r\n\t\t\tid = toUint32(callData);\r\n\t\t\tprice = teleportPrice * (characters[id].characterType/numDragonTypes);//double price in case of balloon\r\n\t\t\trequire(value >= price);\r\n\t\t\tassert(teleportToken.transferFrom(sender, this, price));\r\n\t\t\tteleportKnight(id);\r\n\t\t}\r\n\t\telse if (msg.sender == address(neverdieToken)) {\r\n\t\t\tid = toUint32(callData);\r\n\t\t\t// user can purchase extra lifes only right after character purchaes\r\n\t\t\t// in other words, user value should be equal the initial value\r\n\t\t\tuint8 cType = characters[id].characterType;\r\n\t\t\trequire(characters[id].value == values[cType]);\r\n\r\n\t\t\t// calc how many lifes user can actually buy\r\n\t\t\t// the formula is the following:\r\n\r\n\t\t\tuint256 lifePrice;\r\n\t\t\tuint8 max;\r\n\t\t\tif(cType < 2 * numDragonTypes){\r\n\t\t\t\tlifePrice = ((cType % numDragonTypes) + 1) * protectionPrice;\r\n\t\t\t\tmax = 3;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlifePrice = (((cType+3) % numDragonTypes) + 1) * protectionPrice * 2;\r\n\t\t\t\tmax = 6;\r\n\t\t\t}\r\n\r\n\t\t\tprice = 0;\r\n\t\t\tuint8 i = protection[id];\r\n\t\t\tfor (i; i < max && value >= price + lifePrice * (i + 1); i++) {\r\n\t\t\t\tprice += lifePrice * (i + 1);\r\n\t\t\t}\r\n\t\t\tassert(neverdieToken.transferFrom(sender, this, price));\r\n\t\t\tprotectCharacter(id, i);\r\n\t\t}\r\n\t\telse\r\n\t\t\trevert();\r\n\t}\r\n\r\n\t/**\r\n\t * knights are only entering the game completely, when they are teleported to the scene\r\n\t * @param id the character id\r\n\t * */\r\n\tfunction teleportKnight(uint32 id) internal {\r\n\t\t// ensure we do not teleport twice\r\n\t\trequire(teleported[id] == false);\r\n\t\tteleported[id] = true;\r\n\t\tCharacter storage knight = characters[id];\r\n\t\trequire(knight.characterType >= numDragonTypes); //this also makes calls with non-existent ids fail\r\n\t\taddCharacter(id, numCharacters);\r\n\t\tnumCharacters++;\r\n\t\tnumCharactersXType[knight.characterType]++;\r\n\t\tNewTeleport(id);\r\n\t}\r\n\r\n\t/**\r\n\t * adds protection to a character\r\n\t * @param id the character id\r\n\t * @param lifes the number of protections\r\n\t * */\r\n\tfunction protectCharacter(uint32 id, uint8 lifes) internal {\r\n\t\tprotection[id] = lifes;\r\n\t\tNewProtection(id, lifes);\r\n\t}\r\n\r\n\r\n\t/****************** GETTERS *************************/\r\n\r\n\t/**\r\n\t * returns the character of the given id\r\n\t * @param characterId the character id\r\n\t * @return the type, value and owner of the character\r\n\t * */\r\n\tfunction getCharacter(uint32 characterId) constant public returns(uint8, uint128, address) {\r\n\t\treturn (characters[characterId].characterType, characters[characterId].value, characters[characterId].owner);\r\n\t}\r\n\r\n\t/**\r\n\t * returns the index of a character of the given id\r\n\t * @param characterId the character id\r\n\t * @return the character id\r\n\t * */\r\n\tfunction getCharacterIndex(uint32 characterId) constant public returns(uint16) {\r\n\t\tfor (uint16 i = 0; i < ids.length; i++) {\r\n\t\t\tif (ids[i] == characterId) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\trevert();\r\n\t}\r\n\r\n\t/**\r\n\t * returns 10 characters starting from a certain indey\r\n\t * @param startIndex the index to start from\r\n\t * @return 4 arrays containing the ids, types, values and owners of the characters\r\n\t * */\r\n\tfunction get10Characters(uint16 startIndex) constant public returns(uint32[10] characterIds, uint8[10] types, uint128[10] values, address[10] owners) {\r\n\t\tuint32 endIndex = startIndex + 10 > numCharacters ? numCharacters : startIndex + 10;\r\n\t\tuint8 j = 0;\r\n\t\tuint32 id;\r\n\t\tfor (uint16 i = startIndex; i < endIndex; i++) {\r\n\t\t\tid = ids[i];\r\n\t\t\tcharacterIds[j] = id;\r\n\t\t\ttypes[j] = characters[id].characterType;\r\n\t\t\tvalues[j] = characters[id].value;\r\n\t\t\towners[j] = characters[id].owner;\r\n\t\t\tj++;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * returns the number of dragons in the game\r\n\t * @return the number of dragons\r\n\t * */\r\n\tfunction getNumDragons() constant public returns(uint16 numDragons) {\r\n\t\tfor (uint8 i = 0; i < numDragonTypes; i++)\r\n\t\t\tnumDragons += numCharactersXType[i];\r\n\t}\r\n\r\n\t/**\r\n\t * returns the number of knights in the game\r\n\t * @return the number of knights\r\n\t * */\r\n\tfunction getNumKnights() constant public returns(uint16 numKnights) {\r\n\t\tfor (uint8 i = numDragonTypes; i < 2 * numDragonTypes; i++)\r\n\t\t\tnumKnights += numCharactersXType[i];\r\n\t}\r\n\r\n\t/**\r\n\t * @return the accumulated fees\r\n\t * */\r\n\tfunction getFees() constant public returns(uint) {\r\n\t\tuint reserved = 0;\r\n\t\tfor (uint16 j = 0; j < numCharacters; j++)\r\n\t\t\treserved += characters[ids[j]].value;\r\n\t\treturn address(this).balance - reserved;\r\n\t}\r\n\r\n\r\n\t/****************** SETTERS *************************/\r\n\r\n\t/**\r\n\t * sets the prices of the character types\r\n\t * @param prices the prices in finney\r\n\t * */\r\n\tfunction setPrices(uint16[] prices) public onlyOwner {\r\n\t\tfor (uint8 i = 0; i < prices.length; i++) {\r\n\t\t\tcosts[i] = uint128(prices[i]) * 1 finney;\r\n\t\t\tvalues[i] = costs[i] - costs[i] / 100 * fee;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * sets the fight factor\r\n\t * @param _factor the new fight factor\r\n\t * */\r\n\tfunction setFightFactor(uint8 _factor) public onlyOwner {\r\n\t\tfightFactor = _factor;\r\n\t}\r\n\r\n\t/**\r\n\t * sets the fee to charge on each purchase\r\n\t * @param _fee the new fee\r\n\t * */\r\n\tfunction setFee(uint8 _fee) public onlyOwner {\r\n\t\tfee = _fee;\r\n\t}\r\n\r\n\t/**\r\n\t * sets the maximum number of characters allowed in the game\r\n\t * @param number the new maximum\r\n\t * */\r\n\tfunction setMaxCharacters(uint16 number) public onlyOwner {\r\n\t\tmaxCharacters = number;\r\n\t}\r\n\r\n\t/**\r\n\t * sets the teleport price\r\n\t * @param price the price in tokens\r\n\t * */\r\n\tfunction setTeleportPrice(uint price) public onlyOwner {\r\n\t\tteleportPrice = price;\r\n\t}\r\n\r\n\t/**\r\n\t * sets the protection price\r\n\t * @param price the price in tokens\r\n\t * */\r\n\tfunction setProtectionPrice(uint price) public onlyOwner {\r\n\t\tprotectionPrice = price;\r\n\t}\r\n\r\n\t/**\r\n\t * sets the eruption threshold\r\n\t * @param et the new eruption threshold in seconds\r\n\t * */\r\n\tfunction setEruptionThreshold(uint et) public onlyOwner {\r\n\t\teruptionThreshold = et;\r\n\t}\r\n\r\n  function setPercentageToKill(uint8 percentage) public onlyOwner {\r\n    percentageToKill = percentage;\r\n  }\r\n\r\n\t/************* HELPERS ****************/\r\n\r\n\t/**\r\n\t * only works for bytes of length < 32\r\n\t * @param b the byte input\r\n\t * @return the uint\r\n\t * */\r\n\tfunction toUint32(bytes b) internal pure returns(uint32) {\r\n\t\tbytes32 newB;\r\n\t\tassembly {\r\n\t\t\tnewB: = mload(0x80)\r\n\t\t}\r\n\t\treturn uint32(newB);\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"sellCharacter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentageToKill\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protectionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerVolcanoEruption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xperToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"collectFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"numCharactersXType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"getCharacter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint128\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setTeleportPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CooldownThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"costs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fightFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"getCharacterIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"et\",\"type\":\"uint256\"}],\"name\":\"setEruptionThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"values\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint16\"}],\"name\":\"get10Characters\",\"outputs\":[{\"name\":\"characterIds\",\"type\":\"uint32[10]\"},{\"name\":\"types\",\"type\":\"uint8[10]\"},{\"name\":\"values\",\"type\":\"uint128[10]\"},{\"name\":\"owners\",\"type\":\"address[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teleportPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"protection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"knightID\",\"type\":\"uint32\"},{\"name\":\"knightIndex\",\"type\":\"uint16\"}],\"name\":\"fight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prices\",\"type\":\"uint16[]\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"characterType\",\"type\":\"uint8\"}],\"name\":\"addCharacters\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumDragons\",\"outputs\":[{\"name\":\"numDragons\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCharacters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teleportToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setProtectionPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eruptionThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"cooldown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factor\",\"type\":\"uint8\"}],\"name\":\"setFightFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sklToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumKnights\",\"outputs\":[{\"name\":\"numKnights\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numDragonTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastEruptionTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfBalloonsTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint8\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"neverdieToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noKing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"percentage\",\"type\":\"uint8\"}],\"name\":\"setPercentageToKill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numCharacters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"number\",\"type\":\"uint16\"}],\"name\":\"setMaxCharacters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"findOldest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"teleportTokenAddress\",\"type\":\"address\"},{\"name\":\"neverdieTokenAddress\",\"type\":\"address\"},{\"name\":\"sklTokenAddress\",\"type\":\"address\"},{\"name\":\"xperTokenAddress\",\"type\":\"address\"},{\"name\":\"eruptionThresholdInHours\",\"type\":\"uint8\"},{\"name\":\"percentageOfCharactersToKill\",\"type\":\"uint8\"},{\"name\":\"characterFee\",\"type\":\"uint8\"},{\"name\":\"charactersCosts\",\"type\":\"uint16[]\"},{\"name\":\"balloonsCosts\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"characterType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"startId\",\"type\":\"uint32\"}],\"name\":\"NewPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"removedCharacters\",\"type\":\"uint32[]\"}],\"name\":\"NewExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hitCharacters\",\"type\":\"uint32[]\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"gasCost\",\"type\":\"uint128\"}],\"name\":\"NewEruption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winnerID\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"loserID\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"probability\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"dice\",\"type\":\"uint16\"}],\"name\":\"NewFight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"NewTeleport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"lifes\",\"type\":\"uint8\"}],\"name\":\"NewProtection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DragonKing","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c596bd09d652827b0106292d3e378d5938df4b12000000000000000000000000a54ddc7b3cce7fc8b1e3fa0256d0db80d2c10970000000000000000000000000a7bd9d58d22d5e35ec4a08083141e0340ea2ca93000000000000000000000000d28525ad63f337c86843d720dae921228e44f0ac0000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000003e8","Library":"","SwarmSource":"bzzr://d9f942d76418d014d224b2b2e385f1edcfd135312d83ae0a808028fd17d9b4c9"}]}