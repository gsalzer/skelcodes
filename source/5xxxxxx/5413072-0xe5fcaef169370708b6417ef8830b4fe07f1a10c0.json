{"status":"1","message":"OK","result":[{"SourceCode":"// CryptoRabbit Source code\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n/// @title A base contract to control ownership\r\n/// @author cuilichen\r\ncontract OwnerBase {\r\n\r\n    // The addresses of the accounts that can execute actions within each roles.\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n    \r\n    /// constructor\r\n    function OwnerBase() public {\r\n       ceoAddress = msg.sender;\r\n       cfoAddress = msg.sender;\r\n       cooAddress = msg.sender;\r\n    }\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n    \r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new COO\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n    \r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCOO whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyCOO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * \r\n * @title Interface for contracts conforming to fighters camp\r\n * @author cuilichen\r\n */\r\ncontract FighterCamp {\r\n    \r\n    //\r\n    function isCamp() public pure returns (bool);\r\n    \r\n    // Required methods\r\n    function getFighter(uint _tokenId) external view returns (uint32);\r\n    \r\n}\r\n\r\n\r\n/// @title Base contract for combat\r\n/// @author cuilichen\r\ncontract RabbitArena is OwnerBase {\r\n    \r\n\tevent FightersReady(uint32 season);\r\n    event SeasonWinner(uint32 season, uint winnerID);\r\n    \r\n\t\r\n    struct Fighter {\r\n        uint tokenID;\r\n        uint32 strength;\r\n    }\r\n\t\r\n    //where are fighters from\r\n    FighterCamp public theCamp; \r\n\t\r\n\t\r\n\tmapping (uint => Fighter) soldiers;\r\n\t\r\n\t\r\n\tuint32[] public seasons;\r\n    \r\n    \r\n\tuint32 public matchDay;\r\n\t\r\n\t\r\n\t/// @dev constructor\r\n\tfunction RabbitArena(address _camp) public {\r\n\t\tFighterCamp tmp = FighterCamp(_camp);\r\n        require(tmp.isCamp());\r\n        theCamp = tmp;\r\n\t}\r\n    \r\n    \r\n    \r\n    /// @dev set camp for this contract\r\n    function setBaseInfo(address _camp) external onlyCOO {\r\n        FighterCamp tmp = FighterCamp(_camp);\r\n        require(tmp.isCamp());\r\n        theCamp = tmp;\r\n    }\r\n\t\r\n\t\r\n\t/// @dev release storaged data, to save gas fee.\r\n\tfunction releaseOldData() internal {\r\n\t\tfor (uint i = 0; i < seasons.length; i++) {\r\n            uint _season = seasons[i];\r\n\t\t\tfor (uint j = 0; j < 8; j++) {\r\n\t\t\t\tuint key = _season * 1000 + j;\r\n\t\t\t\tdelete soldiers[key];\r\n\t\t\t}\r\n        }\r\n\t\tdelete seasons;// seasons.length --> 0\r\n\t}\r\n\r\n    \r\n    /// @dev set 8 fighters for a season, prepare for combat.\r\n    function setFighters(uint32 _today, uint32 _season, uint[] _tokenIDs) external onlyCOO {\r\n\t\trequire(_tokenIDs.length == 8);\r\n\t\t\r\n\t\tif (matchDay != _today) {\r\n\t\t\treleaseOldData();\r\n\t\t\tmatchDay = _today;\r\n\t\t}\r\n\t\tseasons.push(_season);// a new season\r\n\t\t\r\n        //record fighter datas\r\n        for(uint i = 0; i < 8; i++) {\r\n            uint tmpID = _tokenIDs[i];\r\n            \r\n            Fighter memory soldier = Fighter({\r\n                tokenID: tmpID,\r\n\t\t\t\tstrength: theCamp.getFighter(tmpID)\r\n            });\r\n\t\t\t\r\n\t\t\tuint key = _season * 1000 + i;\r\n            soldiers[key] = soldier;\r\n        }\r\n        \r\n        //fire the event\r\n        emit FightersReady(_season);\r\n    }\r\n    \r\n    \r\n    /// @dev get fighter property\r\n    function getFighterInfo(uint32 _season, uint32 _index) external view returns (\r\n        uint outTokenID,\r\n        uint32 outStrength\r\n    ) {\r\n\t\trequire(_index < 8);\r\n\t\tuint key = _season * 1000 + _index;\r\n        \r\n        Fighter storage soldier = soldiers[key];\r\n\t\trequire(soldier.strength > 0);\r\n        \r\n        outTokenID = soldier.tokenID;\r\n        outStrength = soldier.strength;\r\n    }\r\n    \r\n    \r\n    /// @dev process a combat\r\n    /// @param _season The round for combat\r\n    /// @param _seed The seed from the users\r\n    function processOneCombat(uint32 _season, uint32 _seed) external onlyCOO \r\n    {\r\n        uint[] memory powers = new uint[](8);\r\n        \r\n\t\tuint sumPower = 0;\r\n        uint i = 0;\r\n\t\tuint key = 0;\r\n        for (i = 0; i < 8; i++) {\r\n\t\t\tkey = _season * 1000 + i;\r\n            Fighter storage soldier = soldiers[key];\r\n            powers[i] = soldier.strength;\r\n            sumPower = sumPower + soldier.strength;\r\n        }\r\n        \r\n        uint sumValue = 0;\r\n\t\tuint tmpPower = 0;\r\n        for (i = 0; i < 8; i++) {\r\n            tmpPower = powers[i] ** 5;//\r\n            sumValue += tmpPower;\r\n            powers[i] = sumValue;\r\n        }\r\n        uint singleDeno = sumPower ** 5;\r\n        uint randomVal = _getRandom(_seed);\r\n        \r\n        uint winner = 0;\r\n        uint shoot = sumValue * randomVal * 10000000000 / singleDeno / 0xffffffff;\r\n        for (i = 0; i < 8; i++) {\r\n            tmpPower = powers[i];\r\n            if (shoot <= tmpPower * 10000000000 / singleDeno) {\r\n                winner = i;\r\n                break;\r\n            }\r\n        }\r\n\t\t\r\n\t\tkey = _season * 1000 + winner;\r\n\t\tFighter storage tmp = soldiers[key];        \r\n        emit SeasonWinner(_season, tmp.tokenID);\r\n    }\r\n    \r\n    \r\n    /// @dev give a seed and get a random value between 0 and 0xffffffff.\r\n    /// @param _seed an uint32 value from users\r\n    function _getRandom(uint32 _seed) pure internal returns(uint32) {\r\n        return uint32(keccak256(_seed));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint32\"},{\"name\":\"_index\",\"type\":\"uint32\"}],\"name\":\"getFighterInfo\",\"outputs\":[{\"name\":\"outTokenID\",\"type\":\"uint256\"},{\"name\":\"outStrength\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_today\",\"type\":\"uint32\"},{\"name\":\"_season\",\"type\":\"uint32\"},{\"name\":\"_tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"setFighters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"matchDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_camp\",\"type\":\"address\"}],\"name\":\"setBaseInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint32\"},{\"name\":\"_seed\",\"type\":\"uint32\"}],\"name\":\"processOneCombat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theCamp\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"seasons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_camp\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"season\",\"type\":\"uint32\"}],\"name\":\"FightersReady\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"season\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"winnerID\",\"type\":\"uint256\"}],\"name\":\"SeasonWinner\",\"type\":\"event\"}]","ContractName":"RabbitArena","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000825c1d61a5b170808a31b895c26ee4f24b690d59","Library":"","SwarmSource":"bzzr://1e746a3ce53bcbbbe8eb960686b553e6a3af3aa494bb9c94b26f473e58479e65"}]}