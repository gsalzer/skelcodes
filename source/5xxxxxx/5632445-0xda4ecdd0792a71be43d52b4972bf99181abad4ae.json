{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal pure returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function toWei(uint256 a) internal pure returns (uint256){\r\n    assert(a>0);\r\n    return a * 10 ** 18;\r\n  }\r\n}\r\n\r\ninterface tokenRecipient { \r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; \r\n}\r\n\r\ncontract TokenERC20 is SafeMath{\r\n\r\n    // Token information\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    /**\r\n     * Constrctor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _totalSupply * 10 ** uint256(decimals);\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(safeAdd(balanceOf[_to], _value) > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = safeAdd(balanceOf[_from],balanceOf[_to]);\r\n        // Subtract from the sender\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\n        // Add the same to the recipient\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(safeAdd(balanceOf[_from],balanceOf[_to]) == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender],_value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n      \r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);            // Subtract from the sender\r\n        totalSupply = safeSub(totalSupply,_value);                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);             // Subtract from the sender's allowance\r\n        totalSupply = safeSub(totalSupply,_value);                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n/******************************************/\r\n/*          GAMEREWARD TOKEN              */\r\n/******************************************/\r\n\r\ncontract GameRewardToken is owned, TokenERC20 {\r\n\r\n    // State machine\r\n    enum State{PrivateFunding, PreFunding, Funding, Success, Failure}\r\n\r\n\r\n    mapping (address => bool) public frozenAccount;\r\n    mapping (address => address) public applications;\r\n    mapping (address => uint256) public bounties;\r\n    mapping (address => uint256) public bonus;\r\n    mapping (address => address) public referrals;\r\n    mapping (address => uint256) public investors;\r\n    mapping (address => uint256) public funders;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds(address indexed target, bool frozen);\r\n    event FundTransfer(address indexed to, uint256 eth , uint256 value, uint block);\r\n    event SetApplication(address indexed target, address indexed parent);\r\n    event Fee(address indexed from, address indexed collector, uint256 fee);\r\n    event FreeDistribution(address indexed to, uint256 value, uint block);\r\n    event Refund(address indexed to, uint256 value, uint block);\r\n    event BonusTransfer(address indexed to, uint256 value, uint block);\r\n    event BountyTransfer(address indexed to, uint256 value, uint block);\r\n    event SetReferral(address indexed target, address indexed broker);\r\n    event ChangeCampaign(uint256 fundingStartBlock, uint256 fundingEndBlock);\r\n    event AddBounty(address indexed bountyHunter, uint256 value);\r\n    event ReferralBonus(address indexed investor, address indexed broker, uint256 value);\r\n\r\n     // Crowdsale information\r\n    bool public finalizedCrowdfunding = false;\r\n\r\n    uint256 public fundingStartBlock = 0; // crowdsale start block\r\n    uint256 public fundingEndBlock = 0;   // crowdsale end block\r\n    uint256 public constant lockedTokens =                250000000*10**18; //25% tokens to Vault and locked for 6 months - 250 millions\r\n    uint256 public bonusAndBountyTokens =                  50000000*10**18; //5% tokens for referral bonus and bounty - 50 millions\r\n    uint256 public constant devsTokens =                  100000000*10**18; //10% tokens for team - 100 millions\r\n    uint256 public constant hundredPercent =                           100;\r\n    uint256 public constant tokensPerEther =                         20000; //GRD:ETH exchange rate - 20.000 GRD per ETH\r\n    uint256 public constant tokenCreationMax =            600000000*10**18; //ICO hard target - 600 millions\r\n    uint256 public constant tokenCreationMin =             60000000*10**18; //ICO soft target - 60 millions\r\n\r\n    uint256 public constant tokenPrivateMax =             100000000*10**18; //Private-sale must stop when 100 millions tokens sold\r\n\r\n    uint256 public constant minContributionAmount =             0.1*10**18; //Investor must buy atleast 0.1ETH in open-sale\r\n    uint256 public constant maxContributionAmount =             100*10**18; //Max 100 ETH in open-sale and pre-sale\r\n\r\n    uint256 public constant minPrivateContribution =              5*10**18; //Investor must buy atleast 5ETH in private-sale\r\n    uint256 public constant minPreContribution =                  1*10**18; //Investor must buy atleast 1ETH in pre-sale\r\n\r\n    uint256 public constant minAmountToGetBonus =                 1*10**18; //Investor must buy atleast 1ETH to receive referral bonus\r\n    uint256 public constant referralBonus =                              5; //5% for referral bonus\r\n    uint256 public constant privateBonus =                              40; //40% bonus in private-sale\r\n    uint256 public constant preBonus =                                  20; //20% bonus in pre-sale;\r\n\r\n    uint256 public tokensSold;\r\n    uint256 public collectedETH;\r\n\r\n    uint256 public constant numBlocksLocked = 1110857;  //180 days locked vault tokens\r\n    bool public releasedBountyTokens = false; //bounty release status\r\n    uint256 public unlockedAtBlockNumber;\r\n\r\n    address public lockedTokenHolder;\r\n    address public releaseTokenHolder;\r\n    address public devsHolder;\r\n\r\n\r\n    constructor(address _lockedTokenHolder,\r\n                address _releaseTokenHolder,\r\n                address _devsAddress\r\n    ) TokenERC20(\"GameReward\", // Name\r\n                 \"GRD\",        // Symbol \r\n                  18,          // Decimals\r\n                  1000000000   // Total Supply 1 Billion\r\n                  ) public {\r\n        \r\n        require (_lockedTokenHolder != 0x0);\r\n        require (_releaseTokenHolder != 0x0);\r\n        require (_devsAddress != 0x0);\r\n        lockedTokenHolder = _lockedTokenHolder;\r\n        releaseTokenHolder = _releaseTokenHolder;\r\n        devsHolder = _devsAddress;\r\n    }\r\n\r\n    /* Internal transfer, only can be called by this contract */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require (getState() == State.Success);\r\n        require (_to != 0x0);                                      // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] >= _value);                      // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (safeAdd(balanceOf[_to],_value) > balanceOf[_to]); // Check for overflows\r\n        require (!frozenAccount[_from]);                           // Check if sender is frozen\r\n        require (!frozenAccount[_to]);                             // Check if recipient is frozen\r\n        require (_from != lockedTokenHolder);\r\n        balanceOf[_from] = safeSub(balanceOf[_from],_value);       // Subtract from the sender\r\n        balanceOf[_to] = safeAdd(balanceOf[_to],_value);           // Add the same to the recipient\r\n        emit Transfer(_from, _to, _value);\r\n        if(applications[_to] != 0x0){                              // If this address from an application\r\n            balanceOf[_to] = safeSub(balanceOf[_to],_value);       // Forward tokens to application address \r\n            balanceOf[applications[_to]] =safeAdd(balanceOf[applications[_to]],_value);    \r\n            emit Transfer(_to, applications[_to], _value);\r\n        }\r\n    }\r\n\r\n    ///@notice change token's name and symbol\r\n    function updateNameAndSymbol(string _newname, string _newsymbol) onlyOwner public{\r\n      name = _newname;\r\n      symbol = _newsymbol;\r\n    }\r\n\r\n    ///@notice Application withdraw, only can be called by owner\r\n    ///@param _from address of the sender\r\n    ///@param _to address of the receiver\r\n    ///@param _value the amount to send\r\n    ///@param _fee the amount of transaction fee\r\n    ///@param _collector address of collector to receive fee\r\n    function withdraw(address _from, address _to, uint _value, uint _fee, address _collector) onlyOwner public {\r\n        require (getState() == State.Success);\r\n        require (applications[_from]!=0x0);                             // Check if sender from an application\r\n        address app = applications[_from];\r\n        require (_collector != 0x0);\r\n        require (_to != 0x0);                                           // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[app] >= safeAdd(_value, _fee));              // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (safeAdd(balanceOf[_to], _value)> balanceOf[_to]);      // Check for overflows\r\n        require (!frozenAccount[app]);                                  // Check if sender is frozen\r\n        require (!frozenAccount[_to]);                                  // Check if recipient is frozen\r\n        require (_from != lockedTokenHolder);\r\n        balanceOf[app] = safeSub(balanceOf[app],safeAdd(_value, _fee)); // Subtract from the Application\r\n        balanceOf[_to] = safeAdd(balanceOf[_to],_value);                // Add value to the target\r\n        balanceOf[_collector] = safeAdd(balanceOf[_collector], _fee);   // Add fee to fee collector\r\n        emit Fee(app,_collector,_fee);\r\n        emit Transfer(app, _collector, _fee);\r\n        emit Transfer(app, _to, _value);\r\n    }\r\n    \r\n    ///@notice map an address to its application address\r\n    ///@param _target Address to set parent\r\n    ///@param _parent Address of parent\r\n    function setApplication(address _target, address _parent) onlyOwner public {\r\n        require (getState() == State.Success);\r\n        require(_parent!=0x0);\r\n        applications[_target]=_parent;\r\n        uint256 currentBalance=balanceOf[_target];\r\n        emit SetApplication(_target,_parent);\r\n        if(currentBalance>0x0){\r\n            balanceOf[_target] = safeDiv(balanceOf[_target],currentBalance);\r\n            balanceOf[_parent] = safeAdd(balanceOf[_parent],currentBalance);\r\n            emit Transfer(_target,_parent,currentBalance);\r\n        }\r\n    }\r\n\r\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n    /// @param _target Address to be frozen\r\n    /// @param _freeze either to freeze it or not\r\n    function freezeAccount(address _target, bool _freeze) onlyOwner public {\r\n        frozenAccount[_target] = _freeze;\r\n        emit FrozenFunds(_target, _freeze);\r\n    }\r\n\r\n\r\n\r\n    //Crowdsale Functions\r\n\r\n    /// @notice get early bonus for Investor\r\n    function _getEarlyBonus() internal view returns(uint){\r\n        if(getState()==State.PrivateFunding) return privateBonus;  \r\n        else if(getState()==State.PreFunding) return preBonus; \r\n        else return 0;\r\n    }\r\n\r\n    /// @notice set start and end block for funding\r\n    /// @param _fundingStartBlock start funding\r\n    /// @param _fundingEndBlock  end funding\r\n    function setCampaign(uint256 _fundingStartBlock, uint256 _fundingEndBlock) onlyOwner public{\r\n        if(block.number < _fundingStartBlock){\r\n            fundingStartBlock = _fundingStartBlock;\r\n        }\r\n        if(_fundingEndBlock > fundingStartBlock && _fundingEndBlock > block.number){\r\n            fundingEndBlock = _fundingEndBlock;\r\n        }\r\n        emit ChangeCampaign(_fundingStartBlock,_fundingEndBlock);\r\n    }\r\n\r\n    function releaseBountyTokens() onlyOwner public{\r\n      require(!releasedBountyTokens);\r\n      require(getState()==State.Success);\r\n      releasedBountyTokens = true;\r\n    }\r\n\r\n\r\n    /// @notice set Broker for Investor\r\n    /// @param _target address of Investor\r\n    /// @param _broker address of Broker\r\n    function setReferral(address _target, address _broker, uint256 _amount) onlyOwner public {\r\n        require (_target != 0x0);\r\n        require (_broker != 0x0);\r\n        referrals[_target] = _broker;\r\n        emit SetReferral(_target, _broker);\r\n        if(_amount>0x0){\r\n            uint256 brokerBonus = safeDiv(safeMul(_amount,referralBonus),hundredPercent);\r\n            bonus[_broker] = safeAdd(bonus[_broker],brokerBonus);\r\n            emit ReferralBonus(_target,_broker,brokerBonus);\r\n        }\r\n    }\r\n\r\n    /// @notice set token for bounty hunter to release when ICO success\r\n    function addBounty(address _hunter, uint256 _amount) onlyOwner public{\r\n        require(_hunter!=0x0);\r\n        require(toWei(_amount)<=safeSub(bonusAndBountyTokens,toWei(_amount)));\r\n        bounties[_hunter] = safeAdd(bounties[_hunter],toWei(_amount));\r\n        bonusAndBountyTokens = safeSub(bonusAndBountyTokens,toWei(_amount));\r\n        emit AddBounty(_hunter, toWei(_amount));\r\n    }\r\n\r\n    /// @notice Create tokens when funding is active. This fallback function require 90.000 gas or more\r\n    /// @dev Required state: Funding\r\n    /// @dev State transition: -> Funding Success (only if cap reached)\r\n    function() payable public{\r\n        // Abort if not in Funding Active state.\r\n        // Do not allow creating 0 or more than the cap tokens.\r\n        require (getState() != State.Success);\r\n        require (getState() != State.Failure);\r\n        require (msg.value != 0);\r\n\r\n        if(getState()==State.PrivateFunding){\r\n            require(msg.value>=minPrivateContribution);\r\n        }else if(getState()==State.PreFunding){\r\n            require(msg.value>=minPreContribution && msg.value < maxContributionAmount);\r\n        }else if(getState()==State.Funding){\r\n            require(msg.value>=minContributionAmount && msg.value < maxContributionAmount);\r\n        }\r\n\r\n        // multiply by exchange rate to get newly created token amount\r\n        uint256 createdTokens = safeMul(msg.value, tokensPerEther);\r\n        uint256 brokerBonus = 0;\r\n        uint256 earlyBonus = safeDiv(safeMul(createdTokens,_getEarlyBonus()),hundredPercent);\r\n\r\n        createdTokens = safeAdd(createdTokens,earlyBonus);\r\n\r\n        // don't go over the limit!\r\n        if(getState()==State.PrivateFunding){\r\n            require(safeAdd(tokensSold,createdTokens) <= tokenPrivateMax);\r\n        }else{\r\n            require (safeAdd(tokensSold,createdTokens) <= tokenCreationMax);\r\n        }\r\n\r\n        // we are creating tokens, so increase the tokenSold\r\n        tokensSold = safeAdd(tokensSold, createdTokens);\r\n        collectedETH = safeAdd(collectedETH,msg.value);\r\n        \r\n        // add bonus if has referral\r\n        if(referrals[msg.sender]!= 0x0){\r\n            brokerBonus = safeDiv(safeMul(createdTokens,referralBonus),hundredPercent);\r\n            bonus[referrals[msg.sender]] = safeAdd(bonus[referrals[msg.sender]],brokerBonus);\r\n            emit ReferralBonus(msg.sender,referrals[msg.sender],brokerBonus);\r\n        }\r\n\r\n        // Save funder info for refund and free distribution\r\n        funders[msg.sender] = safeAdd(funders[msg.sender],msg.value);\r\n        investors[msg.sender] = safeAdd(investors[msg.sender],createdTokens);\r\n\r\n        // Assign new tokens to the sender\r\n        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], createdTokens);\r\n        // Log token creation event\r\n        emit FundTransfer(msg.sender,msg.value, createdTokens, block.number);\r\n        emit Transfer(0, msg.sender, createdTokens);\r\n    }\r\n\r\n    /// @notice send bonus token to broker\r\n    function requestBonus() external{\r\n      require(getState()==State.Success);\r\n      uint256 bonusAmount = bonus[msg.sender];\r\n      assert(bonusAmount>0);\r\n      require(bonusAmount<=safeSub(bonusAndBountyTokens,bonusAmount));\r\n      balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender],bonusAmount);\r\n      bonus[msg.sender] = 0;\r\n      bonusAndBountyTokens = safeSub(bonusAndBountyTokens,bonusAmount);\r\n      emit BonusTransfer(msg.sender,bonusAmount,block.number);\r\n      emit Transfer(0,msg.sender,bonusAmount);\r\n    }\r\n\r\n    /// @notice send lockedTokens to devs address\r\n    /// require State == Success\r\n    /// require tokens unlocked\r\n    function releaseLockedToken() external {\r\n        require (getState() == State.Success);\r\n        require (balanceOf[lockedTokenHolder] > 0x0);\r\n        require (block.number >= unlockedAtBlockNumber);\r\n        balanceOf[devsHolder] = safeAdd(balanceOf[devsHolder],balanceOf[lockedTokenHolder]);\r\n        emit Transfer(lockedTokenHolder,devsHolder,balanceOf[lockedTokenHolder]);\r\n        balanceOf[lockedTokenHolder] = 0;\r\n    }\r\n    \r\n    /// @notice request to receive bounty tokens\r\n    /// @dev require State == Succes\r\n    function requestBounty() external{\r\n        require(releasedBountyTokens); //locked bounty hunter's token for 7 days after end of campaign\r\n        require(getState()==State.Success);\r\n        assert (bounties[msg.sender]>0);\r\n        balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender],bounties[msg.sender]);\r\n        emit BountyTransfer(msg.sender,bounties[msg.sender],block.number);\r\n        emit Transfer(0,msg.sender,bounties[msg.sender]);\r\n        bounties[msg.sender] = 0;\r\n    }\r\n\r\n    /// @notice Finalize crowdfunding\r\n    /// @dev If cap was reached or crowdfunding has ended then:\r\n    /// create GRD for the Vault and developer,\r\n    /// transfer ETH to the devs address.\r\n    /// @dev Required state: Success\r\n    function finalizeCrowdfunding() external {\r\n        // Abort if not in Funding Success state.\r\n        require (getState() == State.Success); // don't finalize unless we won\r\n        require (!finalizedCrowdfunding); // can't finalize twice (so sneaky!)\r\n\r\n        // prevent more creation of tokens\r\n        finalizedCrowdfunding = true;\r\n        // Endowment: 25% of total goes to vault, timelocked for 6 months\r\n        balanceOf[lockedTokenHolder] = safeAdd(balanceOf[lockedTokenHolder], lockedTokens);\r\n\r\n        // Transfer lockedTokens to lockedTokenHolder address\r\n        unlockedAtBlockNumber = block.number + numBlocksLocked;\r\n        emit Transfer(0, lockedTokenHolder, lockedTokens);\r\n\r\n        // Endowment: 10% of total goes to devs\r\n        balanceOf[devsHolder] = safeAdd(balanceOf[devsHolder], devsTokens);\r\n        emit Transfer(0, devsHolder, devsTokens);\r\n\r\n        // Transfer ETH to the devs address.\r\n        devsHolder.transfer(address(this).balance);\r\n    }\r\n\r\n    /// @notice send @param _unSoldTokens to all Investor base on their share\r\n    function requestFreeDistribution() external{\r\n      require(getState()==State.Success);\r\n      assert(investors[msg.sender]>0);\r\n      uint256 unSoldTokens = safeSub(tokenCreationMax,tokensSold);\r\n      require(unSoldTokens>0);\r\n      uint256 freeTokens = safeDiv(safeMul(unSoldTokens,investors[msg.sender]),tokensSold);\r\n      balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender],freeTokens);\r\n      investors[msg.sender] = 0;\r\n      emit FreeDistribution(msg.sender,freeTokens,block.number);\r\n      emit Transfer(0,msg.sender, freeTokens);\r\n\r\n    }\r\n\r\n    /// @notice Get back the ether sent during the funding in case the funding\r\n    /// has not reached the soft cap.\r\n    /// @dev Required state: Failure\r\n    function requestRefund() external {\r\n        // Abort if not in Funding Failure state.\r\n        assert (getState() == State.Failure);\r\n        assert (funders[msg.sender]>0);\r\n        msg.sender.transfer(funders[msg.sender]);  \r\n        emit Refund( msg.sender, funders[msg.sender],block.number);\r\n        funders[msg.sender]=0;\r\n    }\r\n\r\n    /// @notice This manages the crowdfunding state machine\r\n    /// We make it a function and do not assign the result to a variable\r\n    /// So there is no chance of the variable being stale\r\n    function getState() public constant returns (State){\r\n      // once we reach success, lock in the state\r\n      if (finalizedCrowdfunding) return State.Success;\r\n      if(fundingStartBlock ==0 && fundingEndBlock==0) return State.PrivateFunding;\r\n      else if (block.number < fundingStartBlock) return State.PreFunding;\r\n      else if (block.number <= fundingEndBlock && tokensSold < tokenCreationMax) return State.Funding;\r\n      else if (tokensSold >= tokenCreationMin) return State.Success;\r\n      else return State.Failure;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"funders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestFreeDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devsTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokenHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxContributionAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdfunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPrivateContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_parent\",\"type\":\"address\"}],\"name\":\"setApplication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_broker\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setReferral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContributionAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBlocksLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedCrowdfunding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"applications\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releasedBountyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrivateMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devsHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusAndBountyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hunter\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hundredPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockedAtBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseBountyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseLockedToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCreationMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmountToGetBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingEndBlock\",\"type\":\"uint256\"}],\"name\":\"setCampaign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bounties\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseTokenHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPreContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newname\",\"type\":\"string\"},{\"name\":\"_newsymbol\",\"type\":\"string\"}],\"name\":\"updateNameAndSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_collector\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_lockedTokenHolder\",\"type\":\"address\"},{\"name\":\"_releaseTokenHolder\",\"type\":\"address\"},{\"name\":\"_devsAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"parent\",\"type\":\"address\"}],\"name\":\"SetApplication\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Fee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"FreeDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"BonusTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"BountyTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"broker\",\"type\":\"address\"}],\"name\":\"SetReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fundingStartBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundingEndBlock\",\"type\":\"uint256\"}],\"name\":\"ChangeCampaign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bountyHunter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AddBounty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"broker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReferralBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"GameRewardToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000204c15369a010fd672008d634b7c8dffce96adbb00000000000000000000000032bf8bb40f1c583ce41426ab19611e77d8af71180000000000000000000000009d170d97d21d91f925e2a7553590359fd2cb2b23","Library":"","SwarmSource":"bzzr://40ba6085b823fdabc7b1f903572837706e5e68eca02d8046f1e4972b138108ba"}]}