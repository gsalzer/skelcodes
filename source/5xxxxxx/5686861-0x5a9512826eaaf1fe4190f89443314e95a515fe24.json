{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary MathUtils {\r\n    using SafeMath for uint256;\r\n\r\n    // Divisor used for representing percentages\r\n    uint256 public constant PERC_DIVISOR = 1000000;\r\n\r\n    /*\r\n     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\r\n     * @param _amount Amount that is supposed to be a percentage\r\n     */\r\n    function validPerc(uint256 _amount) internal pure returns (bool) {\r\n        return _amount <= PERC_DIVISOR;\r\n    }\r\n\r\n    /*\r\n     * @dev Compute percentage of a value with the percentage represented by a fraction\r\n     * @param _amount Amount to take the percentage of\r\n     * @param _fracNum Numerator of fraction representing the percentage\r\n     * @param _fracDenom Denominator of fraction representing the percentage\r\n     */\r\n    function percOf(uint256 _amount, uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\r\n        return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\r\n     * @param _amount Amount to take the percentage of\r\n     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\r\n     */\r\n    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\r\n        return _amount.mul(_fracNum).div(PERC_DIVISOR);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute percentage representation of a fraction\r\n     * @param _fracNum Numerator of fraction represeting the percentage\r\n     * @param _fracDenom Denominator of fraction represeting the percentage\r\n     */\r\n    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\r\n        return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\r\n    }\r\n}\r\n\r\ncontract IController is Pausable {\r\n    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\r\n\r\n    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;\r\n    function updateController(bytes32 _id, address _controller) external;\r\n    function getContract(bytes32 _id) public view returns (address);\r\n}\r\n\r\ncontract IManager {\r\n    event SetController(address controller);\r\n    event ParameterUpdate(string param);\r\n\r\n    function setController(address _controller) external;\r\n}\r\n\r\ncontract Manager is IManager {\r\n    // Controller that contract is registered with\r\n    IController public controller;\r\n\r\n    // Check if sender is controller\r\n    modifier onlyController() {\r\n        require(msg.sender == address(controller));\r\n        _;\r\n    }\r\n\r\n    // Check if sender is controller owner\r\n    modifier onlyControllerOwner() {\r\n        require(msg.sender == controller.owner());\r\n        _;\r\n    }\r\n\r\n    // Check if controller is not paused\r\n    modifier whenSystemNotPaused() {\r\n        require(!controller.paused());\r\n        _;\r\n    }\r\n\r\n    // Check if controller is paused\r\n    modifier whenSystemPaused() {\r\n        require(controller.paused());\r\n        _;\r\n    }\r\n\r\n    function Manager(address _controller) public {\r\n        controller = IController(_controller);\r\n    }\r\n\r\n    /*\r\n     * @dev Set controller. Only callable by current controller\r\n     * @param _controller Controller contract address\r\n     */\r\n    function setController(address _controller) external onlyController {\r\n        controller = IController(_controller);\r\n\r\n        SetController(_controller);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ManagerProxyTarget\r\n * @dev The base contract that target contracts used by a proxy contract should inherit from\r\n * Note: Both the target contract and the proxy contract (implemented as ManagerProxy) MUST inherit from ManagerProxyTarget in order to guarantee\r\n * that both contracts have the same storage layout. Differing storage layouts in a proxy contract and target contract can\r\n * potentially break the delegate proxy upgradeability mechanism\r\n */\r\ncontract ManagerProxyTarget is Manager {\r\n    // Used to look up target contract address in controller's registry\r\n    bytes32 public targetContractId;\r\n}\r\n\r\n/*\r\n * @title A sorted doubly linked list with nodes sorted in descending order. Optionally accepts insert position hints\r\n *\r\n * Given a new node with a `key`, a hint is of the form `(prevId, nextId)` s.t. `prevId` and `nextId` are adjacent in the list.\r\n * `prevId` is a node with a key >= `key` and `nextId` is a node with a key <= `key`. If the sender provides a hint that is a valid insert position\r\n * the insert operation is a constant time storage write. However, the provided hint in a given transaction might be a valid insert position, but if other transactions are included first, when\r\n * the given transaction is executed the provided hint may no longer be a valid insert position. For example, one of the nodes referenced might be removed or their keys may\r\n * be updated such that the the pair of nodes in the hint no longer represent a valid insert position. If one of the nodes in the hint becomes invalid, we still try to use the other\r\n * valid node as a starting point for finding the appropriate insert position. If both nodes in the hint become invalid, we use the head of the list as a starting point\r\n * to find the appropriate insert position.\r\n */\r\nlibrary SortedDoublyLL {\r\n    using SafeMath for uint256;\r\n\r\n    // Information for a node in the list\r\n    struct Node {\r\n        uint256 key;                     // Node's key used for sorting\r\n        address nextId;                  // Id of next node (smaller key) in the list\r\n        address prevId;                  // Id of previous node (larger key) in the list\r\n    }\r\n\r\n    // Information for the list\r\n    struct Data {\r\n        address head;                        // Head of the list. Also the node in the list with the largest key\r\n        address tail;                        // Tail of the list. Also the node in the list with the smallest key\r\n        uint256 maxSize;                     // Maximum size of the list\r\n        uint256 size;                        // Current size of the list\r\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\r\n    }\r\n\r\n    /*\r\n     * @dev Set the maximum size of the list\r\n     * @param _size Maximum size\r\n     */\r\n    function setMaxSize(Data storage self, uint256 _size) public {\r\n        // New max size must be greater than old max size\r\n        require(_size > self.maxSize);\r\n\r\n        self.maxSize = _size;\r\n    }\r\n\r\n    /*\r\n     * @dev Add a node to the list\r\n     * @param _id Node's id\r\n     * @param _key Node's key\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function insert(Data storage self, address _id, uint256 _key, address _prevId, address _nextId) public {\r\n        // List must not be full\r\n        require(!isFull(self));\r\n        // List must not already contain node\r\n        require(!contains(self, _id));\r\n        // Node id must not be null\r\n        require(_id != address(0));\r\n        // Key must be non-zero\r\n        require(_key > 0);\r\n\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (!validInsertPosition(self, _key, prevId, nextId)) {\r\n            // Sender's hint was not a valid insert position\r\n            // Use sender's hint to find a valid insert position\r\n            (prevId, nextId) = findInsertPosition(self, _key, prevId, nextId);\r\n        }\r\n\r\n        self.nodes[_id].key = _key;\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // Insert as head and tail\r\n            self.head = _id;\r\n            self.tail = _id;\r\n        } else if (prevId == address(0)) {\r\n            // Insert before `prevId` as the head\r\n            self.nodes[_id].nextId = self.head;\r\n            self.nodes[self.head].prevId = _id;\r\n            self.head = _id;\r\n        } else if (nextId == address(0)) {\r\n            // Insert after `nextId` as the tail\r\n            self.nodes[_id].prevId = self.tail;\r\n            self.nodes[self.tail].nextId = _id;\r\n            self.tail = _id;\r\n        } else {\r\n            // Insert at insert position between `prevId` and `nextId`\r\n            self.nodes[_id].nextId = nextId;\r\n            self.nodes[_id].prevId = prevId;\r\n            self.nodes[prevId].nextId = _id;\r\n            self.nodes[nextId].prevId = _id;\r\n        }\r\n\r\n        self.size = self.size.add(1);\r\n    }\r\n\r\n    /*\r\n     * @dev Remove a node from the list\r\n     * @param _id Node's id\r\n     */\r\n    function remove(Data storage self, address _id) public {\r\n        // List must contain the node\r\n        require(contains(self, _id));\r\n\r\n        if (self.size > 1) {\r\n            // List contains more than a single node\r\n            if (_id == self.head) {\r\n                // The removed node is the head\r\n                // Set head to next node\r\n                self.head = self.nodes[_id].nextId;\r\n                // Set prev pointer of new head to null\r\n                self.nodes[self.head].prevId = address(0);\r\n            } else if (_id == self.tail) {\r\n                // The removed node is the tail\r\n                // Set tail to previous node\r\n                self.tail = self.nodes[_id].prevId;\r\n                // Set next pointer of new tail to null\r\n                self.nodes[self.tail].nextId = address(0);\r\n            } else {\r\n                // The removed node is neither the head nor the tail\r\n                // Set next pointer of previous node to the next node\r\n                self.nodes[self.nodes[_id].prevId].nextId = self.nodes[_id].nextId;\r\n                // Set prev pointer of next node to the previous node\r\n                self.nodes[self.nodes[_id].nextId].prevId = self.nodes[_id].prevId;\r\n            }\r\n        } else {\r\n            // List contains a single node\r\n            // Set the head and tail to null\r\n            self.head = address(0);\r\n            self.tail = address(0);\r\n        }\r\n\r\n        delete self.nodes[_id];\r\n        self.size = self.size.sub(1);\r\n    }\r\n\r\n    /*\r\n     * @dev Update the key of a node in the list\r\n     * @param _id Node's id\r\n     * @param _newKey Node's new key\r\n     * @param _prevId Id of previous node for the new insert position\r\n     * @param _nextId Id of next node for the new insert position\r\n     */\r\n    function updateKey(Data storage self, address _id, uint256 _newKey, address _prevId, address _nextId) public {\r\n        // List must contain the node\r\n        require(contains(self, _id));\r\n\r\n        // Remove node from the list\r\n        remove(self, _id);\r\n\r\n        if (_newKey > 0) {\r\n            // Insert node if it has a non-zero key\r\n            insert(self, _id, _newKey, _prevId, _nextId);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list contains a node\r\n     * @param _transcoder Address of transcoder\r\n     */\r\n    function contains(Data storage self, address _id) public view returns (bool) {\r\n        // List only contains non-zero keys, so if key is non-zero the node exists\r\n        return self.nodes[_id].key > 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list is full\r\n     */\r\n    function isFull(Data storage self) public view returns (bool) {\r\n        return self.size == self.maxSize;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if the list is empty\r\n     */\r\n    function isEmpty(Data storage self) public view returns (bool) {\r\n        return self.size == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the current size of the list\r\n     */\r\n    function getSize(Data storage self) public view returns (uint256) {\r\n        return self.size;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the maximum size of the list\r\n     */\r\n    function getMaxSize(Data storage self) public view returns (uint256) {\r\n        return self.maxSize;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the key of a node in the list\r\n     * @param _id Node's id\r\n     */\r\n    function getKey(Data storage self, address _id) public view returns (uint256) {\r\n        return self.nodes[_id].key;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first node in the list (node with the largest key)\r\n     */\r\n    function getFirst(Data storage self) public view returns (address) {\r\n        return self.head;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the last node in the list (node with the smallest key)\r\n     */\r\n    function getLast(Data storage self) public view returns (address) {\r\n        return self.tail;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the next node (with a smaller key) in the list for a given node\r\n     * @param _id Node's id\r\n     */\r\n    function getNext(Data storage self, address _id) public view returns (address) {\r\n        return self.nodes[_id].nextId;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the previous node (with a larger key) in the list for a given node\r\n     * @param _id Node's id\r\n     */\r\n    function getPrev(Data storage self, address _id) public view returns (address) {\r\n        return self.nodes[_id].prevId;\r\n    }\r\n\r\n    /*\r\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given key\r\n     * @param _key Node's key\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function validInsertPosition(Data storage self, uint256 _key, address _prevId, address _nextId) public view returns (bool) {\r\n        if (_prevId == address(0) && _nextId == address(0)) {\r\n            // `(null, null)` is a valid insert position if the list is empty\r\n            return isEmpty(self);\r\n        } else if (_prevId == address(0)) {\r\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\r\n            return self.head == _nextId && _key >= self.nodes[_nextId].key;\r\n        } else if (_nextId == address(0)) {\r\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\r\n            return self.tail == _prevId && _key <= self.nodes[_prevId].key;\r\n        } else {\r\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_key` falls between the two nodes' keys\r\n            return self.nodes[_prevId].nextId == _nextId && self.nodes[_prevId].key >= _key && _key >= self.nodes[_nextId].key;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Descend the list (larger keys to smaller keys) to find a valid insert position\r\n     * @param _key Node's key\r\n     * @param _startId Id of node to start ascending the list from\r\n     */\r\n    function descendList(Data storage self, uint256 _key, address _startId) private view returns (address, address) {\r\n        // If `_startId` is the head, check if the insert position is before the head\r\n        if (self.head == _startId && _key >= self.nodes[_startId].key) {\r\n            return (address(0), _startId);\r\n        }\r\n\r\n        address prevId = _startId;\r\n        address nextId = self.nodes[prevId].nextId;\r\n\r\n        // Descend the list until we reach the end or until we find a valid insert position\r\n        while (prevId != address(0) && !validInsertPosition(self, _key, prevId, nextId)) {\r\n            prevId = self.nodes[prevId].nextId;\r\n            nextId = self.nodes[prevId].nextId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Ascend the list (smaller keys to larger keys) to find a valid insert position\r\n     * @param _key Node's key\r\n     * @param _startId Id of node to start descending the list from\r\n     */\r\n    function ascendList(Data storage self, uint256 _key, address _startId) private view returns (address, address) {\r\n        // If `_startId` is the tail, check if the insert position is after the tail\r\n        if (self.tail == _startId && _key <= self.nodes[_startId].key) {\r\n            return (_startId, address(0));\r\n        }\r\n\r\n        address nextId = _startId;\r\n        address prevId = self.nodes[nextId].prevId;\r\n\r\n        // Ascend the list until we reach the end or until we find a valid insertion point\r\n        while (nextId != address(0) && !validInsertPosition(self, _key, prevId, nextId)) {\r\n            nextId = self.nodes[nextId].prevId;\r\n            prevId = self.nodes[nextId].prevId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /*\r\n     * @dev Find the insert position for a new node with the given key\r\n     * @param _key Node's key\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function findInsertPosition(Data storage self, uint256 _key, address _prevId, address _nextId) private view returns (address, address) {\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (prevId != address(0)) {\r\n            if (!contains(self, prevId) || _key > self.nodes[prevId].key) {\r\n                // `prevId` does not exist anymore or now has a smaller key than the given key\r\n                prevId = address(0);\r\n            }\r\n        }\r\n\r\n        if (nextId != address(0)) {\r\n            if (!contains(self, nextId) || _key < self.nodes[nextId].key) {\r\n                // `nextId` does not exist anymore or now has a larger key than the given key\r\n                nextId = address(0);\r\n            }\r\n        }\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // No hint - descend list starting from head\r\n            return descendList(self, _key, self.head);\r\n        } else if (prevId == address(0)) {\r\n            // No `prevId` for hint - ascend list starting from `nextId`\r\n            return ascendList(self, _key, nextId);\r\n        } else if (nextId == address(0)) {\r\n            // No `nextId` for hint - descend list starting from `prevId`\r\n            return descendList(self, _key, prevId);\r\n        } else {\r\n            // Descend list starting from `prevId`\r\n            return descendList(self, _key, prevId);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary EarningsPool {\r\n    using SafeMath for uint256;\r\n\r\n    // Represents rewards and fees to be distributed to delegators\r\n    struct Data {\r\n        uint256 rewardPool;                // Rewards in the pool\r\n        uint256 feePool;                   // Fees in the pool\r\n        uint256 totalStake;                // Transcoder's total stake during the pool's round\r\n        uint256 claimableStake;            // Stake that can be used to claim portions of the fee and reward pool\r\n        uint256 transcoderRewardCut;       // Reward cut for the reward pool\r\n        uint256 transcoderFeeShare;        // Fee share for the fee pool\r\n    }\r\n\r\n    function init(EarningsPool.Data storage earningsPool, uint256 _stake, uint256 _rewardCut, uint256 _feeShare) internal {\r\n        earningsPool.totalStake = _stake;\r\n        earningsPool.claimableStake = _stake;\r\n        earningsPool.transcoderRewardCut = _rewardCut;\r\n        earningsPool.transcoderFeeShare = _feeShare;\r\n    }\r\n\r\n    function hasClaimableShares(EarningsPool.Data storage earningsPool) internal view returns (bool) {\r\n        return earningsPool.claimableStake > 0;\r\n    }\r\n\r\n    function claimShare(EarningsPool.Data storage earningsPool, uint256 _stake, bool _isTranscoder) internal returns (uint256, uint256) {\r\n        uint256 fees = 0;\r\n        uint256 rewards = 0;\r\n\r\n        if (earningsPool.feePool > 0) {\r\n            // Compute fee share\r\n            fees = feePoolShare(earningsPool, _stake, _isTranscoder);\r\n            earningsPool.feePool = earningsPool.feePool.sub(fees);\r\n        }\r\n\r\n        if (earningsPool.rewardPool > 0) {\r\n            // Compute reward share\r\n            rewards = rewardPoolShare(earningsPool, _stake, _isTranscoder);\r\n            earningsPool.rewardPool = earningsPool.rewardPool.sub(rewards);\r\n        }\r\n\r\n        // Update remaning claimable stake for token pools\r\n        earningsPool.claimableStake = earningsPool.claimableStake.sub(_stake);\r\n\r\n        return (fees, rewards);\r\n    }\r\n\r\n    function feePoolShare(EarningsPool.Data storage earningsPool, uint256 _stake, bool _isTranscoder) internal view returns (uint256) {\r\n        uint256 transcoderFees = 0;\r\n        uint256 delegatorFees = 0;\r\n\r\n        if (earningsPool.claimableStake > 0) {\r\n            uint256 delegatorsFees = MathUtils.percOf(earningsPool.feePool, earningsPool.transcoderFeeShare);\r\n            transcoderFees = earningsPool.feePool.sub(delegatorsFees);\r\n            delegatorFees = MathUtils.percOf(delegatorsFees, _stake, earningsPool.claimableStake);\r\n        }\r\n\r\n        if (_isTranscoder) {\r\n            return delegatorFees.add(transcoderFees);\r\n        } else {\r\n            return delegatorFees;\r\n        }\r\n    }\r\n\r\n    function rewardPoolShare(EarningsPool.Data storage earningsPool, uint256 _stake, bool _isTranscoder) internal view returns (uint256) {\r\n        uint256 transcoderRewards = 0;\r\n        uint256 delegatorRewards = 0;\r\n\r\n        if (earningsPool.claimableStake > 0) {\r\n            transcoderRewards = MathUtils.percOf(earningsPool.rewardPool, earningsPool.transcoderRewardCut);\r\n            delegatorRewards = MathUtils.percOf(earningsPool.rewardPool.sub(transcoderRewards), _stake, earningsPool.claimableStake);\r\n        }\r\n\r\n        if (_isTranscoder) {\r\n            return delegatorRewards.add(transcoderRewards);\r\n        } else {\r\n            return delegatorRewards;\r\n        }\r\n    }\r\n}\r\n\r\ncontract ILivepeerToken is ERC20, Ownable {\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function burn(uint256 _amount) public;\r\n}\r\n\r\n/**\r\n * @title Minter interface\r\n */\r\ncontract IMinter {\r\n    // Events\r\n    event SetCurrentRewardTokens(uint256 currentMintableTokens, uint256 currentInflation);\r\n\r\n    // External functions\r\n    function createReward(uint256 _fracNum, uint256 _fracDenom) external returns (uint256);\r\n    function trustedTransferTokens(address _to, uint256 _amount) external;\r\n    function trustedBurnTokens(uint256 _amount) external;\r\n    function trustedWithdrawETH(address _to, uint256 _amount) external;\r\n    function depositETH() external payable returns (bool);\r\n    function setCurrentRewardTokens() external;\r\n\r\n    // Public functions\r\n    function getController() public view returns (IController);\r\n}\r\n\r\n/**\r\n * @title RoundsManager interface\r\n */\r\ncontract IRoundsManager {\r\n    // Events\r\n    event NewRound(uint256 round);\r\n\r\n    // External functions\r\n    function initializeRound() external;\r\n\r\n    // Public functions\r\n    function blockNum() public view returns (uint256);\r\n    function blockHash(uint256 _block) public view returns (bytes32);\r\n    function currentRound() public view returns (uint256);\r\n    function currentRoundStartBlock() public view returns (uint256);\r\n    function currentRoundInitialized() public view returns (bool);\r\n    function currentRoundLocked() public view returns (bool);\r\n}\r\n\r\n/*\r\n * @title Interface for BondingManager\r\n */\r\ncontract IBondingManager {\r\n    event TranscoderUpdate(address indexed transcoder, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment, bool registered);\r\n    event TranscoderEvicted(address indexed transcoder);\r\n    event TranscoderResigned(address indexed transcoder);\r\n    event TranscoderSlashed(address indexed transcoder, address finder, uint256 penalty, uint256 finderReward);\r\n    event Reward(address indexed transcoder, uint256 amount);\r\n    event Bond(address indexed delegate, address indexed delegator);\r\n    event Unbond(address indexed delegate, address indexed delegator);\r\n    event WithdrawStake(address indexed delegator);\r\n    event WithdrawFees(address indexed delegator);\r\n\r\n    // External functions\r\n    function setActiveTranscoders() external;\r\n    function updateTranscoderWithFees(address _transcoder, uint256 _fees, uint256 _round) external;\r\n    function slashTranscoder(address _transcoder, address _finder, uint256 _slashAmount, uint256 _finderFee) external;\r\n    function electActiveTranscoder(uint256 _maxPricePerSegment, bytes32 _blockHash, uint256 _round) external view returns (address);\r\n\r\n    // Public functions\r\n    function transcoderTotalStake(address _transcoder) public view returns (uint256);\r\n    function activeTranscoderTotalStake(address _transcoder, uint256 _round) public view returns (uint256);\r\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool);\r\n    function getTotalBonded() public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title BondingManager\r\n * @dev Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\r\n */\r\ncontract BondingManager is ManagerProxyTarget, IBondingManager {\r\n    using SafeMath for uint256;\r\n    using SortedDoublyLL for SortedDoublyLL.Data;\r\n    using EarningsPool for EarningsPool.Data;\r\n\r\n    // Time between unbonding and possible withdrawl in rounds\r\n    uint64 public unbondingPeriod;\r\n    // Number of active transcoders\r\n    uint256 public numActiveTranscoders;\r\n    // Max number of rounds that a caller can claim earnings for at once\r\n    uint256 public maxEarningsClaimsRounds;\r\n\r\n    // Represents a transcoder's current state\r\n    struct Transcoder {\r\n        uint256 lastRewardRound;                             // Last round that the transcoder called reward\r\n        uint256 rewardCut;                                   // % of reward paid to transcoder by a delegator\r\n        uint256 feeShare;                                    // % of fees paid to delegators by transcoder\r\n        uint256 pricePerSegment;                             // Price per segment (denominated in LPT units) for a stream\r\n        uint256 pendingRewardCut;                            // Pending reward cut for next round if the transcoder is active\r\n        uint256 pendingFeeShare;                             // Pending fee share for next round if the transcoder is active\r\n        uint256 pendingPricePerSegment;                      // Pending price per segment for next round if the transcoder is active\r\n        mapping (uint256 => EarningsPool.Data) earningsPoolPerRound;  // Mapping of round => earnings pool for the round\r\n    }\r\n\r\n    // The various states a transcoder can be in\r\n    enum TranscoderStatus { NotRegistered, Registered }\r\n\r\n    // Represents a delegator's current state\r\n    struct Delegator {\r\n        uint256 bondedAmount;                    // The amount of bonded tokens\r\n        uint256 fees;                            // The amount of fees collected\r\n        address delegateAddress;                 // The address delegated to\r\n        uint256 delegatedAmount;                 // The amount of tokens delegated to the delegator\r\n        uint256 startRound;                      // The round the delegator transitions to bonded phase and is delegated to someone\r\n        uint256 withdrawRound;                   // The round at which a delegator can withdraw\r\n        uint256 lastClaimRound;                  // The last round during which the delegator claimed its earnings\r\n    }\r\n\r\n    // The various states a delegator can be in\r\n    enum DelegatorStatus { Pending, Bonded, Unbonding, Unbonded }\r\n\r\n    // Keep track of the known transcoders and delegators\r\n    mapping (address => Delegator) private delegators;\r\n    mapping (address => Transcoder) private transcoders;\r\n\r\n    // Keep track of total bonded tokens\r\n    uint256 private totalBonded;\r\n\r\n    // Candidate and reserve transcoders\r\n    SortedDoublyLL.Data private transcoderPool;\r\n\r\n    // Represents the active transcoder set\r\n    struct ActiveTranscoderSet {\r\n        address[] transcoders;\r\n        mapping (address => bool) isActive;\r\n        uint256 totalStake;\r\n    }\r\n\r\n    // Keep track of active transcoder set for each round\r\n    mapping (uint256 => ActiveTranscoderSet) public activeTranscoderSet;\r\n\r\n    // Check if sender is JobsManager\r\n    modifier onlyJobsManager() {\r\n        require(msg.sender == controller.getContract(keccak256(\"JobsManager\")));\r\n        _;\r\n    }\r\n\r\n    // Check if sender is RoundsManager\r\n    modifier onlyRoundsManager() {\r\n        require(msg.sender == controller.getContract(keccak256(\"RoundsManager\")));\r\n        _;\r\n    }\r\n\r\n    // Check if current round is initialized\r\n    modifier currentRoundInitialized() {\r\n        require(roundsManager().currentRoundInitialized());\r\n        _;\r\n    }\r\n\r\n    // Automatically claim earnings from lastClaimRound through the current round\r\n    modifier autoClaimEarnings() {\r\n        updateDelegatorWithEarnings(msg.sender, roundsManager().currentRound());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\r\n     * @param _controller Address of Controller that this contract will be registered with\r\n     */\r\n    function BondingManager(address _controller) public Manager(_controller) {}\r\n\r\n    /**\r\n     * @dev Set unbonding period. Only callable by Controller owner\r\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\r\n     */\r\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\r\n        unbondingPeriod = _unbondingPeriod;\r\n\r\n        ParameterUpdate(\"unbondingPeriod\");\r\n    }\r\n\r\n    /**\r\n     * @dev Set max number of registered transcoders. Only callable by Controller owner\r\n     * @param _numTranscoders Max number of registered transcoders\r\n     */\r\n    function setNumTranscoders(uint256 _numTranscoders) external onlyControllerOwner {\r\n        // Max number of transcoders must be greater than or equal to number of active transcoders\r\n        require(_numTranscoders >= numActiveTranscoders);\r\n\r\n        transcoderPool.setMaxSize(_numTranscoders);\r\n\r\n        ParameterUpdate(\"numTranscoders\");\r\n    }\r\n\r\n    /**\r\n     * @dev Set number of active transcoders. Only callable by Controller owner\r\n     * @param _numActiveTranscoders Number of active transcoders\r\n     */\r\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\r\n        // Number of active transcoders cannot exceed max number of transcoders\r\n        require(_numActiveTranscoders <= transcoderPool.getMaxSize());\r\n\r\n        numActiveTranscoders = _numActiveTranscoders;\r\n\r\n        ParameterUpdate(\"numActiveTranscoders\");\r\n    }\r\n\r\n    /**\r\n     * @dev Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner\r\n     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once\r\n     */\r\n    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {\r\n        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;\r\n\r\n        ParameterUpdate(\"maxEarningsClaimsRounds\");\r\n    }\r\n\r\n    /**\r\n     * @dev The sender is declaring themselves as a candidate for active transcoding.\r\n     * @param _rewardCut % of reward paid to transcoder by a delegator\r\n     * @param _feeShare % of fees paid to delegators by a transcoder\r\n     * @param _pricePerSegment Price per segment (denominated in Wei) for a stream\r\n     */\r\n    function transcoder(uint256 _rewardCut, uint256 _feeShare, uint256 _pricePerSegment)\r\n        external\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n    {\r\n        Transcoder storage t = transcoders[msg.sender];\r\n        Delegator storage del = delegators[msg.sender];\r\n\r\n        if (roundsManager().currentRoundLocked()) {\r\n            // If it is the lock period of the current round\r\n            // the lowest price previously set by any transcoder\r\n            // becomes the price floor and the caller can lower its\r\n            // own price to a point greater than or equal to the price floor\r\n\r\n            // Caller must already be a registered transcoder\r\n            require(transcoderStatus(msg.sender) == TranscoderStatus.Registered);\r\n            // Provided rewardCut value must equal the current pendingRewardCut value\r\n            // This value cannot change during the lock period\r\n            require(_rewardCut == t.pendingRewardCut);\r\n            // Provided feeShare value must equal the current pendingFeeShare value\r\n            // This value cannot change during the lock period\r\n            require(_feeShare == t.pendingFeeShare);\r\n\r\n            // Iterate through the transcoder pool to find the price floor\r\n            // Since the caller must be a registered transcoder, the transcoder pool size will always at least be 1\r\n            // Thus, we can safely set the initial price floor to be the pendingPricePerSegment of the first\r\n            // transcoder in the pool\r\n            address currentTranscoder = transcoderPool.getFirst();\r\n            uint256 priceFloor = transcoders[currentTranscoder].pendingPricePerSegment;\r\n            for (uint256 i = 0; i < transcoderPool.getSize(); i++) {\r\n                if (transcoders[currentTranscoder].pendingPricePerSegment < priceFloor) {\r\n                    priceFloor = transcoders[currentTranscoder].pendingPricePerSegment;\r\n                }\r\n\r\n                currentTranscoder = transcoderPool.getNext(currentTranscoder);\r\n            }\r\n\r\n            // Provided pricePerSegment must be greater than or equal to the price floor and\r\n            // less than or equal to the previously set pricePerSegment by the caller\r\n            require(_pricePerSegment >= priceFloor && _pricePerSegment <= t.pendingPricePerSegment);\r\n\r\n            t.pendingPricePerSegment = _pricePerSegment;\r\n\r\n            TranscoderUpdate(msg.sender, t.pendingRewardCut, t.pendingFeeShare, _pricePerSegment, true);\r\n        } else {\r\n            // It is not the lock period of the current round\r\n            // Caller is free to change rewardCut, feeShare, pricePerSegment as it pleases\r\n            // If caller is not a registered transcoder, it can also register and join the transcoder pool\r\n            // if it has sufficient delegated stake\r\n            // If caller is not a registered transcoder and does not have sufficient delegated stake\r\n            // to join the transcoder pool, it can change rewardCut, feeShare, pricePerSegment\r\n            // as information signals to delegators in an effort to camapaign and accumulate\r\n            // more delegated stake\r\n\r\n            // Reward cut must be a valid percentage\r\n            require(MathUtils.validPerc(_rewardCut));\r\n            // Fee share must be a valid percentage\r\n            require(MathUtils.validPerc(_feeShare));\r\n\r\n            // Must have a non-zero amount bonded to self\r\n            require(del.delegateAddress == msg.sender && del.bondedAmount > 0);\r\n\r\n            t.pendingRewardCut = _rewardCut;\r\n            t.pendingFeeShare = _feeShare;\r\n            t.pendingPricePerSegment = _pricePerSegment;\r\n\r\n            uint256 delegatedAmount = del.delegatedAmount;\r\n\r\n            // Check if transcoder is not already registered\r\n            if (transcoderStatus(msg.sender) == TranscoderStatus.NotRegistered) {\r\n                if (!transcoderPool.isFull()) {\r\n                    // If pool is not full add new transcoder\r\n                    transcoderPool.insert(msg.sender, delegatedAmount, address(0), address(0));\r\n                } else {\r\n                    address lastTranscoder = transcoderPool.getLast();\r\n\r\n                    if (delegatedAmount > transcoderPool.getKey(lastTranscoder)) {\r\n                        // If pool is full and caller has more delegated stake than the transcoder in the pool with the least delegated stake:\r\n                        // - Evict transcoder in pool with least delegated stake\r\n                        // - Add caller to pool\r\n                        transcoderPool.remove(lastTranscoder);\r\n                        transcoderPool.insert(msg.sender, delegatedAmount, address(0), address(0));\r\n\r\n                        TranscoderEvicted(lastTranscoder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            TranscoderUpdate(msg.sender, _rewardCut, _feeShare, _pricePerSegment, transcoderPool.contains(msg.sender));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Delegate stake towards a specific address.\r\n     * @param _amount The amount of LPT to stake.\r\n     * @param _to The address of the transcoder to stake towards.\r\n     */\r\n    function bond(\r\n        uint256 _amount,\r\n        address _to\r\n    )\r\n        external\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n        autoClaimEarnings\r\n    {\r\n        Delegator storage del = delegators[msg.sender];\r\n\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        // Amount to delegate\r\n        uint256 delegationAmount = _amount;\r\n\r\n        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded || delegatorStatus(msg.sender) == DelegatorStatus.Unbonding) {\r\n            // New delegate\r\n            // Set start round\r\n            // Don't set start round if delegator is in pending state because the start round would not change\r\n            del.startRound = currentRound.add(1);\r\n            // If transitioning from unbonding or unbonded state\r\n            // make sure to zero out withdraw round\r\n            del.withdrawRound = 0;\r\n            // Unbonded or unbonding state = no existing delegate\r\n            // Thus, delegation amount = bonded stake + provided amount\r\n            // If caller is bonding for the first time or withdrew previously bonded stake, delegation amount = provided amount\r\n            delegationAmount = delegationAmount.add(del.bondedAmount);\r\n        } else if (del.delegateAddress != address(0) && _to != del.delegateAddress) {\r\n            // A registered transcoder cannot delegate its bonded stake toward another address\r\n            // because it can only be delegated toward itself\r\n            // In the future, if delegation towards another registered transcoder as an already\r\n            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\r\n            // could be removed\r\n            require(transcoderStatus(msg.sender) == TranscoderStatus.NotRegistered);\r\n            // Changing delegate\r\n            // Set start round\r\n            del.startRound = currentRound.add(1);\r\n            // Update amount to delegate with previous delegation amount\r\n            delegationAmount = delegationAmount.add(del.bondedAmount);\r\n            // Decrease old delegate's delegated amount\r\n            delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(del.bondedAmount);\r\n\r\n            if (transcoderStatus(del.delegateAddress) == TranscoderStatus.Registered) {\r\n                // Previously delegated to a transcoder\r\n                // Decrease old transcoder's total stake\r\n                transcoderPool.updateKey(del.delegateAddress, transcoderPool.getKey(del.delegateAddress).sub(del.bondedAmount), address(0), address(0));\r\n            }\r\n        }\r\n\r\n        // Delegation amount must be > 0 - cannot delegate to someone without having bonded stake\r\n        require(delegationAmount > 0);\r\n        // Update delegate\r\n        del.delegateAddress = _to;\r\n        // Update current delegate's delegated amount with delegation amount\r\n        delegators[_to].delegatedAmount = delegators[_to].delegatedAmount.add(delegationAmount);\r\n\r\n        if (transcoderStatus(_to) == TranscoderStatus.Registered) {\r\n            // Delegated to a transcoder\r\n            // Increase transcoder's total stake\r\n            transcoderPool.updateKey(_to, transcoderPool.getKey(del.delegateAddress).add(delegationAmount), address(0), address(0));\r\n        }\r\n\r\n        if (_amount > 0) {\r\n            // Update bonded amount\r\n            del.bondedAmount = del.bondedAmount.add(_amount);\r\n            // Update total bonded tokens\r\n            totalBonded = totalBonded.add(_amount);\r\n            // Transfer the LPT to the Minter\r\n            livepeerToken().transferFrom(msg.sender, minter(), _amount);\r\n        }\r\n\r\n        Bond(_to, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Unbond delegator's current stake. Delegator enters unbonding state\r\n     */\r\n    function unbond()\r\n        external\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n        autoClaimEarnings\r\n    {\r\n        // Sender must be in bonded state\r\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded);\r\n\r\n        Delegator storage del = delegators[msg.sender];\r\n\r\n        uint256 currentRound = roundsManager().currentRound();\r\n\r\n        // Transition to unbonding phase\r\n        del.withdrawRound = currentRound.add(unbondingPeriod);\r\n        // Decrease delegate's delegated amount\r\n        delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(del.bondedAmount);\r\n        // Update total bonded tokens\r\n        totalBonded = totalBonded.sub(del.bondedAmount);\r\n\r\n        if (transcoderStatus(msg.sender) == TranscoderStatus.Registered) {\r\n            // If caller is a registered transcoder, resign\r\n            // In the future, with partial unbonding there would be a check for 0 bonded stake as well\r\n            resignTranscoder(msg.sender);\r\n        }\r\n\r\n        if (del.delegateAddress != msg.sender && transcoderStatus(del.delegateAddress) == TranscoderStatus.Registered) {\r\n            // If delegate is not self and is a registered transcoder, decrease its delegated stake\r\n            // We do not need to decrease delegated stake if delegate is self because we would have already removed self\r\n            // from the transcoder pool\r\n            transcoderPool.updateKey(del.delegateAddress, transcoderPool.getKey(del.delegateAddress).sub(del.bondedAmount), address(0), address(0));\r\n        }\r\n\r\n        // Delegator no longer bonded to anyone\r\n        del.delegateAddress = address(0);\r\n        // Unbonding delegator does not have a start round\r\n        del.startRound = 0;\r\n\r\n        Unbond(del.delegateAddress, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws bonded stake to the caller after unbonding period.\r\n     */\r\n    function withdrawStake()\r\n        external\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n    {\r\n        // Delegator must be in the unbonded state\r\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded);\r\n\r\n        uint256 amount = delegators[msg.sender].bondedAmount;\r\n        delegators[msg.sender].bondedAmount = 0;\r\n        delegators[msg.sender].withdrawRound = 0;\r\n\r\n        // Tell Minter to transfer stake (LPT) to the delegator\r\n        minter().trustedTransferTokens(msg.sender, amount);\r\n\r\n        WithdrawStake(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws fees to the caller\r\n     */\r\n    function withdrawFees()\r\n        external\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n        autoClaimEarnings\r\n    {\r\n        // Delegator must have fees\r\n        require(delegators[msg.sender].fees > 0);\r\n\r\n        uint256 amount = delegators[msg.sender].fees;\r\n        delegators[msg.sender].fees = 0;\r\n\r\n        // Tell Minter to transfer fees (ETH) to the delegator\r\n        minter().trustedWithdrawETH(msg.sender, amount);\r\n\r\n        WithdrawFees(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Set active transcoder set for the current round\r\n     */\r\n    function setActiveTranscoders() external whenSystemNotPaused onlyRoundsManager {\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        uint256 activeSetSize = Math.min256(numActiveTranscoders, transcoderPool.getSize());\r\n\r\n        uint256 totalStake = 0;\r\n        address currentTranscoder = transcoderPool.getFirst();\r\n\r\n        for (uint256 i = 0; i < activeSetSize; i++) {\r\n            activeTranscoderSet[currentRound].transcoders.push(currentTranscoder);\r\n            activeTranscoderSet[currentRound].isActive[currentTranscoder] = true;\r\n\r\n            uint256 stake = transcoderPool.getKey(currentTranscoder);\r\n            uint256 rewardCut = transcoders[currentTranscoder].pendingRewardCut;\r\n            uint256 feeShare = transcoders[currentTranscoder].pendingFeeShare;\r\n            uint256 pricePerSegment = transcoders[currentTranscoder].pendingPricePerSegment;\r\n\r\n            Transcoder storage t = transcoders[currentTranscoder];\r\n            // Set pending rates as current rates\r\n            t.rewardCut = rewardCut;\r\n            t.feeShare = feeShare;\r\n            t.pricePerSegment = pricePerSegment;\r\n            // Initialize token pool\r\n            t.earningsPoolPerRound[currentRound].init(stake, rewardCut, feeShare);\r\n\r\n            totalStake = totalStake.add(stake);\r\n\r\n            // Get next transcoder in the pool\r\n            currentTranscoder = transcoderPool.getNext(currentTranscoder);\r\n        }\r\n\r\n        // Update total stake of all active transcoders\r\n        activeTranscoderSet[currentRound].totalStake = totalStake;\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute the token rewards to transcoder and delegates.\r\n     * Active transcoders call this once per cycle when it is their turn.\r\n     */\r\n    function reward() external whenSystemNotPaused currentRoundInitialized {\r\n        uint256 currentRound = roundsManager().currentRound();\r\n\r\n        // Sender must be an active transcoder\r\n        require(activeTranscoderSet[currentRound].isActive[msg.sender]);\r\n\r\n        // Transcoder must not have called reward for this round already\r\n        require(transcoders[msg.sender].lastRewardRound != currentRound);\r\n        // Set last round that transcoder called reward\r\n        transcoders[msg.sender].lastRewardRound = currentRound;\r\n\r\n        // Create reward based on active transcoder's stake relative to the total active stake\r\n        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake\r\n        uint256 rewardTokens = minter().createReward(activeTranscoderTotalStake(msg.sender, currentRound), activeTranscoderSet[currentRound].totalStake);\r\n\r\n        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound);\r\n\r\n        Reward(msg.sender, rewardTokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Update transcoder's fee pool\r\n     * @param _transcoder Transcoder address\r\n     * @param _fees Fees from verified job claims\r\n     */\r\n    function updateTranscoderWithFees(\r\n        address _transcoder,\r\n        uint256 _fees,\r\n        uint256 _round\r\n    )\r\n        external\r\n        whenSystemNotPaused\r\n        onlyJobsManager\r\n    {\r\n        // Transcoder must be registered\r\n        require(transcoderStatus(_transcoder) == TranscoderStatus.Registered);\r\n\r\n        Transcoder storage t = transcoders[_transcoder];\r\n\r\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];\r\n        // Add fees to fee pool\r\n        earningsPool.feePool = earningsPool.feePool.add(_fees);\r\n    }\r\n\r\n    /**\r\n     * @dev Slash a transcoder. Slashing can be invoked by the protocol or a finder.\r\n     * @param _transcoder Transcoder address\r\n     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\r\n     * @param _slashAmount Percentage of transcoder bond to be slashed\r\n     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\r\n     */\r\n    function slashTranscoder(\r\n        address _transcoder,\r\n        address _finder,\r\n        uint256 _slashAmount,\r\n        uint256 _finderFee\r\n    )\r\n        external\r\n        whenSystemNotPaused\r\n        onlyJobsManager\r\n    {\r\n        Delegator storage del = delegators[_transcoder];\r\n\r\n        if (del.bondedAmount > 0) {\r\n            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\r\n\r\n            // Decrease bonded stake\r\n            del.bondedAmount = del.bondedAmount.sub(penalty);\r\n\r\n            // If still bonded\r\n            // - Decrease delegate's delegated amount\r\n            // - Decrease total bonded tokens\r\n            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\r\n                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(penalty);\r\n                totalBonded = totalBonded.sub(penalty);\r\n            }\r\n\r\n            // If registered transcoder, resign it\r\n            if (transcoderStatus(_transcoder) == TranscoderStatus.Registered) {\r\n                resignTranscoder(_transcoder);\r\n            }\r\n\r\n            // Account for penalty\r\n            uint256 burnAmount = penalty;\r\n\r\n            // Award finder fee if there is a finder address\r\n            if (_finder != address(0)) {\r\n                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\r\n                minter().trustedTransferTokens(_finder, finderAmount);\r\n\r\n                // Minter burns the slashed funds - finder reward\r\n                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\r\n\r\n                TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\r\n            } else {\r\n                // Minter burns the slashed funds\r\n                minter().trustedBurnTokens(burnAmount);\r\n\r\n                TranscoderSlashed(_transcoder, address(0), penalty, 0);\r\n            }\r\n        } else {\r\n            TranscoderSlashed(_transcoder, _finder, 0, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Pseudorandomly elect a currently active transcoder that charges a price per segment less than or equal to the max price per segment for a job\r\n     * Returns address of elected active transcoder and its price per segment\r\n     * @param _maxPricePerSegment Max price (in LPT base units) per segment of a stream\r\n     * @param _blockHash Job creation block hash used as a pseudorandom seed for assigning an active transcoder\r\n     * @param _round Job creation round\r\n     */\r\n    function electActiveTranscoder(uint256 _maxPricePerSegment, bytes32 _blockHash, uint256 _round) external view returns (address) {\r\n        uint256 activeSetSize = activeTranscoderSet[_round].transcoders.length;\r\n        // Create array to store available transcoders charging an acceptable price per segment\r\n        address[] memory availableTranscoders = new address[](activeSetSize);\r\n        // Keep track of the actual number of available transcoders\r\n        uint256 numAvailableTranscoders = 0;\r\n        // Keep track of total stake of available transcoders\r\n        uint256 totalAvailableTranscoderStake = 0;\r\n\r\n        for (uint256 i = 0; i < activeSetSize; i++) {\r\n            address activeTranscoder = activeTranscoderSet[_round].transcoders[i];\r\n            // If a transcoder is active and charges an acceptable price per segment add it to the array of available transcoders\r\n            if (activeTranscoderSet[_round].isActive[activeTranscoder] && transcoders[activeTranscoder].pricePerSegment <= _maxPricePerSegment) {\r\n                availableTranscoders[numAvailableTranscoders] = activeTranscoder;\r\n                numAvailableTranscoders++;\r\n                totalAvailableTranscoderStake = totalAvailableTranscoderStake.add(activeTranscoderTotalStake(activeTranscoder, _round));\r\n            }\r\n        }\r\n\r\n        if (numAvailableTranscoders == 0) {\r\n            // There is no currently available transcoder that charges a price per segment less than or equal to the max price per segment for a job\r\n            return address(0);\r\n        } else {\r\n            // Pseudorandomly pick an available transcoder weighted by its stake relative to the total stake of all available transcoders\r\n            uint256 r = uint256(_blockHash) % totalAvailableTranscoderStake;\r\n            uint256 s = 0;\r\n            uint256 j = 0;\r\n\r\n            while (s <= r && j < numAvailableTranscoders) {\r\n                s = s.add(activeTranscoderTotalStake(availableTranscoders[j], _round));\r\n                j++;\r\n            }\r\n\r\n            return availableTranscoders[j - 1];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Claim token pools shares for a delegator from its lastClaimRound through the end round\r\n     * @param _endRound The last round for which to claim token pools shares for a delegator\r\n     */\r\n    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {\r\n        // End round must be after the last claim round\r\n        require(delegators[msg.sender].lastClaimRound < _endRound);\r\n        // End round must not be after the current round\r\n        require(_endRound <= roundsManager().currentRound());\r\n\r\n        updateDelegatorWithEarnings(msg.sender, _endRound);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns pending bonded stake for a delegator from its lastClaimRound through an end round\r\n     * @param _delegator Address of delegator\r\n     * @param _endRound The last round to compute pending stake from\r\n     */\r\n    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        Delegator storage del = delegators[_delegator];\r\n        // End round must be before or equal to current round and after lastClaimRound\r\n        require(_endRound <= currentRound && _endRound > del.lastClaimRound);\r\n\r\n        uint256 currentBondedAmount = del.bondedAmount;\r\n\r\n        for (uint256 i = del.lastClaimRound + 1; i <= _endRound; i++) {\r\n            EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];\r\n\r\n            bool isTranscoder = _delegator == del.delegateAddress;\r\n            if (earningsPool.hasClaimableShares()) {\r\n                // Calculate and add reward pool share from this round\r\n                currentBondedAmount = currentBondedAmount.add(earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder));\r\n            }\r\n        }\r\n\r\n        return currentBondedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns pending fees for a delegator from its lastClaimRound through an end round\r\n     * @param _delegator Address of delegator\r\n     * @param _endRound The last round to compute pending fees from\r\n     */\r\n    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        Delegator storage del = delegators[_delegator];\r\n        // End round must be before or equal to current round and after lastClaimRound\r\n        require(_endRound <= currentRound && _endRound > del.lastClaimRound);\r\n\r\n        uint256 currentFees = del.fees;\r\n        uint256 currentBondedAmount = del.bondedAmount;\r\n\r\n        for (uint256 i = del.lastClaimRound + 1; i <= _endRound; i++) {\r\n            EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];\r\n\r\n            if (earningsPool.hasClaimableShares()) {\r\n                bool isTranscoder = _delegator == del.delegateAddress;\r\n                // Calculate and add fee pool share from this round\r\n                currentFees = currentFees.add(earningsPool.feePoolShare(currentBondedAmount, isTranscoder));\r\n                // Calculate new bonded amount with rewards from this round. Updated bonded amount used\r\n                // to calculate fee pool share in next round\r\n                currentBondedAmount = currentBondedAmount.add(earningsPool.rewardPoolShare(currentBondedAmount, isTranscoder));\r\n            }\r\n        }\r\n\r\n        return currentFees;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total bonded stake for an active transcoder\r\n     * @param _transcoder Address of a transcoder\r\n     */\r\n    function activeTranscoderTotalStake(address _transcoder, uint256 _round) public view returns (uint256) {\r\n        // Must be active transcoder\r\n        require(activeTranscoderSet[_round].isActive[_transcoder]);\r\n\r\n        return transcoders[_transcoder].earningsPoolPerRound[_round].totalStake;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total bonded stake for a transcoder\r\n     * @param _transcoder Address of transcoder\r\n     */\r\n    function transcoderTotalStake(address _transcoder) public view returns (uint256) {\r\n        return transcoderPool.getKey(_transcoder);\r\n    }\r\n\r\n    /*\r\n     * @dev Computes transcoder status\r\n     * @param _transcoder Address of transcoder\r\n     */\r\n    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {\r\n        if (transcoderPool.contains(_transcoder)) {\r\n            return TranscoderStatus.Registered;\r\n        } else {\r\n            return TranscoderStatus.NotRegistered;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes delegator status\r\n     * @param _delegator Address of delegator\r\n     */\r\n    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {\r\n        Delegator storage del = delegators[_delegator];\r\n\r\n        if (del.withdrawRound > 0) {\r\n            // Delegator called unbond\r\n            if (roundsManager().currentRound() >= del.withdrawRound) {\r\n                return DelegatorStatus.Unbonded;\r\n            } else {\r\n                return DelegatorStatus.Unbonding;\r\n            }\r\n        } else if (del.startRound > roundsManager().currentRound()) {\r\n            // Delegator round start is in the future\r\n            return DelegatorStatus.Pending;\r\n        } else if (del.startRound > 0 && del.startRound <= roundsManager().currentRound()) {\r\n            // Delegator round start is now or in the past\r\n            return DelegatorStatus.Bonded;\r\n        } else {\r\n            // Default to unbonded\r\n            return DelegatorStatus.Unbonded;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return transcoder information\r\n     * @param _transcoder Address of transcoder\r\n     */\r\n    function getTranscoder(\r\n        address _transcoder\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 lastRewardRound, uint256 rewardCut, uint256 feeShare, uint256 pricePerSegment, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment)\r\n    {\r\n        Transcoder storage t = transcoders[_transcoder];\r\n\r\n        lastRewardRound = t.lastRewardRound;\r\n        rewardCut = t.rewardCut;\r\n        feeShare = t.feeShare;\r\n        pricePerSegment = t.pricePerSegment;\r\n        pendingRewardCut = t.pendingRewardCut;\r\n        pendingFeeShare = t.pendingFeeShare;\r\n        pendingPricePerSegment = t.pendingPricePerSegment;\r\n    }\r\n\r\n    /**\r\n     * @dev Return transcoder's token pools for a given round\r\n     * @param _transcoder Address of transcoder\r\n     * @param _round Round number\r\n     */\r\n    function getTranscoderEarningsPoolForRound(\r\n        address _transcoder,\r\n        uint256 _round\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 rewardPool, uint256 feePool, uint256 totalStake, uint256 claimableStake)\r\n    {\r\n        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];\r\n\r\n        rewardPool = earningsPool.rewardPool;\r\n        feePool = earningsPool.feePool;\r\n        totalStake = earningsPool.totalStake;\r\n        claimableStake = earningsPool.claimableStake;\r\n    }\r\n\r\n    /**\r\n     * @dev Return delegator info\r\n     * @param _delegator Address of delegator\r\n     */\r\n    function getDelegator(\r\n        address _delegator\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 bondedAmount, uint256 fees, address delegateAddress, uint256 delegatedAmount, uint256 startRound, uint256 withdrawRound, uint256 lastClaimRound)\r\n    {\r\n        Delegator storage del = delegators[_delegator];\r\n\r\n        bondedAmount = del.bondedAmount;\r\n        fees = del.fees;\r\n        delegateAddress = del.delegateAddress;\r\n        delegatedAmount = del.delegatedAmount;\r\n        startRound = del.startRound;\r\n        withdrawRound = del.withdrawRound;\r\n        lastClaimRound = del.lastClaimRound;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns max size of transcoder pool\r\n     */\r\n    function getTranscoderPoolMaxSize() public view returns (uint256) {\r\n        return transcoderPool.getMaxSize();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns size of transcoder pool\r\n     */\r\n    function getTranscoderPoolSize() public view returns (uint256) {\r\n        return transcoderPool.getSize();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns transcoder with most stake in pool\r\n     */\r\n    function getFirstTranscoderInPool() public view returns (address) {\r\n        return transcoderPool.getFirst();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns next transcoder in pool for a given transcoder\r\n     * @param _transcoder Address of a transcoder in the pool\r\n     */\r\n    function getNextTranscoderInPool(address _transcoder) public view returns (address) {\r\n        return transcoderPool.getNext(_transcoder);\r\n    }\r\n\r\n    /**\r\n     * @dev Return total bonded tokens\r\n     */\r\n    function getTotalBonded() public view returns (uint256) {\r\n        return totalBonded;\r\n    }\r\n\r\n    /**\r\n     * @dev Return total active stake for a round\r\n     * @param _round Round number\r\n     */\r\n    function getTotalActiveStake(uint256 _round) public view returns (uint256) {\r\n        return activeTranscoderSet[_round].totalStake;\r\n    }\r\n\r\n    /**\r\n     * @dev Return whether a transcoder was active during a round\r\n     * @param _transcoder Transcoder address\r\n     * @param _round Round number\r\n     */\r\n    function isActiveTranscoder(address _transcoder, uint256 _round) public view returns (bool) {\r\n        return activeTranscoderSet[_round].isActive[_transcoder];\r\n    }\r\n\r\n    /**\r\n     * @dev Return whether a transcoder is registered\r\n     * @param _transcoder Transcoder address\r\n     */\r\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\r\n        return transcoderStatus(_transcoder) == TranscoderStatus.Registered;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove transcoder\r\n     */\r\n    function resignTranscoder(address _transcoder) internal {\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        if (activeTranscoderSet[currentRound].isActive[_transcoder]) {\r\n            // Decrease total active stake for the round\r\n            activeTranscoderSet[currentRound].totalStake = activeTranscoderSet[currentRound].totalStake.sub(activeTranscoderTotalStake(_transcoder, currentRound));\r\n            // Set transcoder as inactive\r\n            activeTranscoderSet[currentRound].isActive[_transcoder] = false;\r\n        }\r\n\r\n        // Remove transcoder from pools\r\n        transcoderPool.remove(_transcoder);\r\n\r\n        TranscoderResigned(_transcoder);\r\n    }\r\n\r\n    /**\r\n     * @dev Update a transcoder with rewards\r\n     * @param _transcoder Address of transcoder\r\n     * @param _rewards Amount of rewards\r\n     * @param _round Round that transcoder is updated\r\n     */\r\n    function updateTranscoderWithRewards(address _transcoder, uint256 _rewards, uint256 _round) internal {\r\n        Transcoder storage t = transcoders[_transcoder];\r\n        Delegator storage del = delegators[_transcoder];\r\n\r\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];\r\n        // Add rewards to reward pool\r\n        earningsPool.rewardPool = earningsPool.rewardPool.add(_rewards);\r\n        // Update transcoder's delegated amount with rewards\r\n        del.delegatedAmount = del.delegatedAmount.add(_rewards);\r\n        // Update transcoder's total stake with rewards\r\n        uint256 newStake = transcoderPool.getKey(_transcoder).add(_rewards);\r\n        transcoderPool.updateKey(_transcoder, newStake, address(0), address(0));\r\n        // Update total bonded tokens with claimable rewards\r\n        totalBonded = totalBonded.add(_rewards);\r\n    }\r\n\r\n    /**\r\n     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round\r\n     * @param _delegator Delegator address\r\n     * @param _endRound The last round for which to update a delegator's stake with token pools shares\r\n     */\r\n    function updateDelegatorWithEarnings(address _delegator, uint256 _endRound) internal {\r\n        Delegator storage del = delegators[_delegator];\r\n\r\n        // Only will have earnings to claim if you have a delegate\r\n        // If not delegated, skip the earnings claim process\r\n        if (del.delegateAddress != address(0)) {\r\n            // Cannot claim earnings for more than maxEarningsClaimsRounds\r\n            // This is a number to cause transactions to fail early if\r\n            // we know they will require too much gas to loop through all the necessary rounds to claim earnings\r\n            // The user should instead manually invoke `claimEarnings` to split up the claiming process\r\n            // across multiple transactions\r\n            require(_endRound.sub(del.lastClaimRound) <= maxEarningsClaimsRounds);\r\n\r\n            uint256 currentBondedAmount = del.bondedAmount;\r\n            uint256 currentFees = del.fees;\r\n\r\n            for (uint256 i = del.lastClaimRound + 1; i <= _endRound; i++) {\r\n                EarningsPool.Data storage earningsPool = transcoders[del.delegateAddress].earningsPoolPerRound[i];\r\n\r\n                if (earningsPool.hasClaimableShares()) {\r\n                    bool isTranscoder = _delegator == del.delegateAddress;\r\n\r\n                    var (fees, rewards) = earningsPool.claimShare(currentBondedAmount, isTranscoder);\r\n\r\n                    currentFees = currentFees.add(fees);\r\n                    currentBondedAmount = currentBondedAmount.add(rewards);\r\n                }\r\n            }\r\n\r\n            // Rewards are bonded by default\r\n            del.bondedAmount = currentBondedAmount;\r\n            del.fees = currentFees;\r\n        }\r\n\r\n        del.lastClaimRound = _endRound;\r\n    }\r\n\r\n    /**\r\n     * @dev Return LivepeerToken interface\r\n     */\r\n    function livepeerToken() internal view returns (ILivepeerToken) {\r\n        return ILivepeerToken(controller.getContract(keccak256(\"LivepeerToken\")));\r\n    }\r\n\r\n    /**\r\n     * @dev Return Minter interface\r\n     */\r\n    function minter() internal view returns (IMinter) {\r\n        return IMinter(controller.getContract(keccak256(\"Minter\")));\r\n    }\r\n\r\n    /**\r\n     * @dev Return RoundsManager interface\r\n     */\r\n    function roundsManager() internal view returns (IRoundsManager) {\r\n        return IRoundsManager(controller.getContract(keccak256(\"RoundsManager\")));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"maxEarningsClaimsRounds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"}],\"name\":\"delegatorStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"},{\"name\":\"_finder\",\"type\":\"address\"},{\"name\":\"_slashAmount\",\"type\":\"uint256\"},{\"name\":\"_finderFee\",\"type\":\"uint256\"}],\"name\":\"slashTranscoder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"}],\"name\":\"getNextTranscoderInPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setActiveTranscoders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getTranscoderEarningsPoolForRound\",\"outputs\":[{\"name\":\"rewardPool\",\"type\":\"uint256\"},{\"name\":\"feePool\",\"type\":\"uint256\"},{\"name\":\"totalStake\",\"type\":\"uint256\"},{\"name\":\"claimableStake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endRound\",\"type\":\"uint256\"}],\"name\":\"claimEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTranscoderPoolSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"},{\"name\":\"_fees\",\"type\":\"uint256\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"updateTranscoderWithFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeTranscoderSet\",\"outputs\":[{\"name\":\"totalStake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"targetContractId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTranscoderPoolMaxSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalBonded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"}],\"name\":\"getTranscoder\",\"outputs\":[{\"name\":\"lastRewardRound\",\"type\":\"uint256\"},{\"name\":\"rewardCut\",\"type\":\"uint256\"},{\"name\":\"feeShare\",\"type\":\"uint256\"},{\"name\":\"pricePerSegment\",\"type\":\"uint256\"},{\"name\":\"pendingRewardCut\",\"type\":\"uint256\"},{\"name\":\"pendingFeeShare\",\"type\":\"uint256\"},{\"name\":\"pendingPricePerSegment\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numTranscoders\",\"type\":\"uint256\"}],\"name\":\"setNumTranscoders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numActiveTranscoders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numActiveTranscoders\",\"type\":\"uint256\"}],\"name\":\"setNumActiveTranscoders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"}],\"name\":\"isRegisteredTranscoder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unbondingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxEarningsClaimsRounds\",\"type\":\"uint256\"}],\"name\":\"setMaxEarningsClaimsRounds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"getTotalActiveStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"isActiveTranscoder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardCut\",\"type\":\"uint256\"},{\"name\":\"_feeShare\",\"type\":\"uint256\"},{\"name\":\"_pricePerSegment\",\"type\":\"uint256\"}],\"name\":\"transcoder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstTranscoderInPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"}],\"name\":\"transcoderStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_maxPricePerSegment\",\"type\":\"uint256\"},{\"name\":\"_blockHash\",\"type\":\"bytes32\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"electActiveTranscoder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_endRound\",\"type\":\"uint256\"}],\"name\":\"pendingStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"}],\"name\":\"transcoderTotalStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"}],\"name\":\"getDelegator\",\"outputs\":[{\"name\":\"bondedAmount\",\"type\":\"uint256\"},{\"name\":\"fees\",\"type\":\"uint256\"},{\"name\":\"delegateAddress\",\"type\":\"address\"},{\"name\":\"delegatedAmount\",\"type\":\"uint256\"},{\"name\":\"startRound\",\"type\":\"uint256\"},{\"name\":\"withdrawRound\",\"type\":\"uint256\"},{\"name\":\"lastClaimRound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"bond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unbondingPeriod\",\"type\":\"uint64\"}],\"name\":\"setUnbondingPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcoder\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"activeTranscoderTotalStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_endRound\",\"type\":\"uint256\"}],\"name\":\"pendingFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pendingRewardCut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pendingFeeShare\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pendingPricePerSegment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"registered\",\"type\":\"bool\"}],\"name\":\"TranscoderUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"}],\"name\":\"TranscoderEvicted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"}],\"name\":\"TranscoderResigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"finder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finderReward\",\"type\":\"uint256\"}],\"name\":\"TranscoderSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transcoder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"Bond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"Unbond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"WithdrawStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"WithdrawFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"SetController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"param\",\"type\":\"string\"}],\"name\":\"ParameterUpdate\",\"type\":\"event\"}]","ContractName":"BondingManager","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f96d54e490317c557a967abfa5d6e33006be69b3","Library":"SortedDoublyLL:1a0b2ca69ca2c7f96e2529faa6d63f881655d81a","SwarmSource":"bzzr://dd0ce954ef7b6a6647e6719eeb9e945b0a8825cdeba54568e24951f487977028"}]}