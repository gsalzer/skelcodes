{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/*\r\nProject: XPA Exchange - https://xpa.exchange\r\nAuthor : Luphia Chang - luphia.chang@isuncloud.com\r\n */\r\n\r\ninterface Token {\r\n    function totalSupply() constant external returns (uint256 ts);\r\n    function balanceOf(address _owner) constant external returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n}\r\n\r\ncontract SafeMath {\r\n    function safeAdd(uint x, uint y)\r\n        internal\r\n        pure\r\n    returns(uint) {\r\n      uint256 z = x + y;\r\n      require((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSub(uint x, uint y)\r\n        internal\r\n        pure\r\n    returns(uint) {\r\n      require(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMul(uint x, uint y)\r\n        internal\r\n        pure\r\n    returns(uint) {\r\n      uint z = x * y;\r\n      require((x == 0) || (z / x == y));\r\n      return z;\r\n    }\r\n    \r\n    function safeDiv(uint x, uint y)\r\n        internal\r\n        pure\r\n    returns(uint) {\r\n        require(y > 0);\r\n        return x / y;\r\n    }\r\n\r\n    function random(uint N, uint salt)\r\n        internal\r\n        view\r\n    returns(uint) {\r\n      bytes32 hash = keccak256(block.number, msg.sender, salt);\r\n      return uint(hash) % N;\r\n    }\r\n}\r\n\r\ncontract Authorization {\r\n    mapping(address => address) public agentBooks;\r\n    address public owner;\r\n    address public operator;\r\n    address public bank;\r\n    bool public powerStatus = true;\r\n\r\n    function Authorization()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n        operator = msg.sender;\r\n        bank = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner\r\n    {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n    modifier onlyOperator\r\n    {\r\n        assert(msg.sender == operator || msg.sender == owner);\r\n        _;\r\n    }\r\n    modifier onlyActive\r\n    {\r\n        assert(powerStatus);\r\n        _;\r\n    }\r\n\r\n    function powerSwitch(\r\n        bool onOff_\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        powerStatus = onOff_;\r\n    }\r\n\r\n    function transferOwnership(address newOwner_)\r\n        onlyOwner\r\n        public\r\n    {\r\n        owner = newOwner_;\r\n    }\r\n    \r\n    function assignOperator(address user_)\r\n        public\r\n        onlyOwner\r\n    {\r\n        operator = user_;\r\n        agentBooks[bank] = user_;\r\n    }\r\n    \r\n    function assignBank(address bank_)\r\n        public\r\n        onlyOwner\r\n    {\r\n        bank = bank_;\r\n    }\r\n\r\n    function assignAgent(\r\n        address agent_\r\n    )\r\n        public\r\n    {\r\n        agentBooks[msg.sender] = agent_;\r\n    }\r\n\r\n    function isRepresentor(\r\n        address representor_\r\n    )\r\n        public\r\n        view\r\n    returns(bool) {\r\n        return agentBooks[representor_] == msg.sender;\r\n    }\r\n\r\n    function getUser(\r\n        address representor_\r\n    )\r\n        internal\r\n        view\r\n    returns(address) {\r\n        return isRepresentor(representor_) ? representor_ : msg.sender;\r\n    }\r\n}\r\n\r\n/*  Error Code\r\n    0: insufficient funds (user)\r\n    1: insufficient funds (contract)\r\n    2: invalid amount\r\n    3: invalid price\r\n */\r\n\r\n/*\r\n    1. 檢驗是否指定代理用戶，若是且為合法代理人則將操作角色轉換為被代理人，否則操作角色不變\r\n    2. 檢驗此操作是否有存入 ETH，有則暫時紀錄存入額度 A，若掛單指定 fromToken 不是 ETH 則直接更新用戶 ETH 帳戶餘額\r\n    3. 檢驗此操作是否有存入 fromToken，有則暫時紀錄存入額度 A\r\n    4. 檢驗用戶 fromToken 帳戶餘額 + 存入額度 A 是否 >= Amount，若是送出 makeOrder 掛單事件，否則結束操作\r\n    5. 依照 fromToken、toToken 尋找可匹配的交易對 P\r\n    6. 找出 P 的最低價格單進行匹配，記錄匹配數量，送出 fillOrder 成交事件，並結算 maker 交易結果，若成交完還有掛單數量有剩且未達迴圈次數上限則重複此步驟\r\n    7. 統計步驟 6 總成交量、交易價差利潤、交易手續費\r\n    8. 若扣除總成交量後 Taker 掛單尚未撮合完，則將剩餘額度轉換為 Maker 單\r\n    9. 結算交易所手續費\r\n    10. 結算 Taker 交易結果\r\n */\r\n\r\ncontract Baliv is SafeMath, Authorization {\r\n    /* struct for exchange data */\r\n    struct linkedBook {\r\n        uint256 amount;\r\n        address nextUser;\r\n    }\r\n\r\n    /* business options */\r\n    mapping(address => uint256) public minAmount;\r\n    uint256[3] public feerate = [0, 1 * (10 ** 15), 1 * (10 ** 15)];\r\n    uint256 public autoMatch = 10;\r\n    uint256 public maxAmount = 10 ** 27;\r\n    uint256 public maxPrice = 10 ** 36;\r\n    address public XPAToken = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;\r\n\r\n    /* exchange data */\r\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => linkedBook)))) public orderBooks;\r\n    mapping(address => mapping(address => mapping(uint256 => uint256))) public nextOrderPrice;\r\n    mapping(address => mapping(address => uint256)) public priceBooks;\r\n    \r\n    /* user data */\r\n    mapping(address => mapping(address => uint256)) public balances;\r\n    mapping(address => bool) internal manualWithdraw;\r\n\r\n    /* event */\r\n    event eDeposit(address user,address token, uint256 amount);\r\n    event eWithdraw(address user,address token, uint256 amount);\r\n    event eMakeOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\r\n    event eFillOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\r\n    event eCancelOrder(address fromToken, address toToken, uint256 price, address user, uint256 amount);\r\n\r\n    event Error(uint256 code);\r\n\r\n    /* constructor */\r\n    function Baliv() public {\r\n        minAmount[0] = 10 ** 16;\r\n    }\r\n\r\n    /* Operator Function\r\n        function setup(uint256 autoMatch, uint256 maxAmount, uint256 maxPrice) external;\r\n        function setMinAmount(address token, uint256 amount) external;\r\n        function setFeerate(uint256[3] [maker, taker, autoWithdraw]) external;\r\n    */\r\n\r\n    /* External Function\r\n        function () public payable;\r\n        function deposit(address token, address representor) external payable;\r\n        function withdraw(address token, uint256 amount, address representor) external returns(bool);\r\n        function userTakeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external payable returns(bool);\r\n        function userCancelOrder(address fromToken, address toToken, uint256 price, uint256 amount, address representor) external returns(bool);\r\n        function caculateFee(address user, uint256 amount, uint8 role) external returns(uint256 remaining, uint256 fee);\r\n        function trade(address fromToken, address toToken) external;\r\n        function setManualWithdraw(bool) external;\r\n        function getMinAmount(address) external returns(uint256);\r\n        function getPrice(address fromToken, address toToken) external returns(uint256);\r\n    */\r\n\r\n    /* Internal Function\r\n        function depositAndFreeze(address token, address user) internal payable returns(uint256 amount);\r\n        function checkBalance(address user, address token, uint256 amount, uint256 depositAmount) internal returns(bool);\r\n        function checkAmount(address token, uint256 amount) internal returns(bool);\r\n        function checkPriceAmount(uint256 price) internal returns(bool);\r\n        function makeOrder(address fromToken, address toToken, uint256 price, uint256 amount, address user, uint256 depositAmount) internal returns(uint256 amount);\r\n        function findAndTrade(address fromToken, address toToken, uint256 price, uint256 amount) internal returns(uint256[2] totalMatchAmount[fromToken, toToken], uint256[2] profit[fromToken, toToken]);\r\n        function makeTrade(address fromToken, address toToken, uint256 price, uint256 bestPrice, uint256 remainingAmount) internal returns(uint256[3] [fillTaker, fillMaker, makerFee]);\r\n        function makeTradeDetail(address fromToken, address toToken, uint256 price, uint256 bestPrice, address maker, uint256 remainingAmount) internal returns(uint256[3] [fillTaker, fillMaker, makerFee], bool makerFullfill);\r\n        function caculateFill(uint256 provide, uint256 require, uint256 price, uint256 pairProvide) internal pure returns(uint256 fillAmount);\r\n        function checkPricePair(uint256 price, uint256 bestPrice) internal pure returns(bool matched);\r\n        function fillOrder(address fromToken, address toToken, uint256 price, uint256 amount) internal returns(uint256 fee);\r\n        function transferToken(address user, address token, uint256 amount) internal returns(bool);\r\n        function updateBalance(address user, address token, uint256 amount, bool addOrSub) internal returns(bool);\r\n        function connectOrderPrice(address fromToken, address toToken, uint256 price, uint256 prevPrice) internal;\r\n        function connectOrderUser(address fromToken, address toToken, uint256 price, address user) internal;\r\n        function disconnectOrderPrice(address fromToken, address toToken, uint256 price) internal;\r\n        function disconnectOrderUser(address fromToken, address toToken, uint256 price, address user) internal;\r\n        function getNextOrderPrice(address fromToken, address toToken, uint256 price) internal view returns(uint256 price);\r\n        function updateNextOrderPrice(address fromToken, address toToken, uint256 price, uint256 nextPrice) internal;\r\n        function getNexOrdertUser(address fromToken, address toToken, uint256 price, address user) internal view returns(address nextUser);\r\n        function getOrderAmount(address fromToken, address toToken, uint256 price, address user) internal view returns(uint256 amount);\r\n        function updateNextOrderUser(address fromToken, address toToken, uint256 price, address user, address nextUser) internal;\r\n        function updateOrderAmount(address fromToken, address toToken, uint256 price, address user, uint256 amount, bool addOrSub) internal;\r\n        function logPrice(address fromToken, address toToken, uint256 price) internal;\r\n    */\r\n\r\n    /* Operator function */\r\n    function setup(\r\n        uint256 autoMatch_,\r\n        uint256 maxAmount_,\r\n        uint256 maxPrice_\r\n    )\r\n        onlyOperator\r\n        public\r\n    {\r\n        autoMatch = autoMatch_;\r\n        maxAmount = maxAmount_;\r\n        maxPrice = maxPrice_;\r\n    }\r\n    \r\n    function setMinAmount(\r\n        address token_,\r\n        uint256 amount_\r\n    )\r\n        onlyOperator\r\n        public\r\n    {\r\n        minAmount[token_] = amount_;\r\n    }\r\n    \r\n    function getMinAmount(\r\n        address token_\r\n    )\r\n        public\r\n        view\r\n    returns(uint256) {\r\n        return minAmount[token_] > 0\r\n            ? minAmount[token_]\r\n            : minAmount[0];\r\n    }\r\n    \r\n    function setFeerate(\r\n        uint256[3] feerate_\r\n    )\r\n        onlyOperator\r\n        public\r\n    {\r\n        require(feerate_[0] < 0.05 ether && feerate_[1] < 0.05 ether && feerate_[2] < 0.05 ether);\r\n        feerate = feerate_;\r\n    }\r\n\r\n    /* External function */\r\n    // fallback\r\n    function ()\r\n        public\r\n        payable\r\n    {\r\n        deposit(0, 0);\r\n    }\r\n\r\n    // deposit all allowance\r\n    function deposit(\r\n        address token_,\r\n        address representor_\r\n    )\r\n        public\r\n        payable\r\n        onlyActive\r\n    {\r\n        address user = getUser(representor_);\r\n        uint256 amount = depositAndFreeze(token_, user);\r\n        if(amount > 0) {\r\n            updateBalance(msg.sender, token_, amount, true);\r\n        }\r\n    }\r\n\r\n    function withdraw(\r\n        address token_,\r\n        uint256 amount_,\r\n        address representor_\r\n    )\r\n        public\r\n    returns(bool) {\r\n        address user = getUser(representor_);\r\n        if(updateBalance(user, token_, amount_, false)) {\r\n            require(transferToken(user, token_, amount_));\r\n            return true;\r\n        }\r\n    }\r\n/*\r\n    function userMakeOrder(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 amount_,\r\n        address representor_\r\n    )\r\n        public\r\n        payable\r\n    returns(bool) {\r\n        // depositToken => makeOrder => updateBalance\r\n        uint256 depositAmount = depositAndFreeze(fromToken_, representor_);\r\n        if(\r\n            checkAmount(fromToken_, amount_) &&\r\n            checkPriceAmount(price_)\r\n        ) {\r\n            address user = getUser(representor_);\r\n            uint256 costAmount = makeOrder(fromToken_, toToken_, price_, amount_, user, depositAmount);\r\n\r\n            // log event: MakeOrder\r\n            eMakeOrder(fromToken_, toToken_, price_, user, amount_);\r\n\r\n            if(costAmount < depositAmount) {\r\n                updateBalance(user, fromToken_, safeSub(depositAmount, costAmount), true);\r\n            } else if(costAmount > depositAmount) {\r\n                updateBalance(user, fromToken_, safeSub(costAmount, depositAmount), false);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n*/\r\n    function userTakeOrder(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 amount_,\r\n        address representor_\r\n    )\r\n        public\r\n        payable\r\n        onlyActive\r\n    returns(bool) {\r\n        // checkBalance => findAndTrade => userMakeOrder => updateBalance\r\n        address user = getUser(representor_);\r\n        uint256 depositAmount = depositAndFreeze(fromToken_, user);\r\n        if(\r\n            checkAmount(fromToken_, amount_) &&\r\n            checkPriceAmount(price_) &&\r\n            checkBalance(user, fromToken_, amount_, depositAmount)\r\n        ) {\r\n            // log event: MakeOrder\r\n            emit eMakeOrder(fromToken_, toToken_, price_, user, amount_);\r\n\r\n            uint256[2] memory fillAmount;\r\n            uint256[2] memory profit;\r\n            (fillAmount, profit) = findAndTrade(fromToken_, toToken_, price_, amount_);\r\n            uint256 fee;\r\n            uint256 toAmount;\r\n            uint256 orderAmount;\r\n\r\n            if(fillAmount[0] > 0) {\r\n                // log event: makeTrade\r\n                emit eFillOrder(fromToken_, toToken_, price_, user, fillAmount[0]);\r\n\r\n                toAmount = safeDiv(safeMul(fillAmount[0], price_), 1 ether);\r\n                if(amount_ > fillAmount[0]) {\r\n                    orderAmount = safeSub(amount_, fillAmount[0]);\r\n                    makeOrder(fromToken_, toToken_, price_, amount_, user, depositAmount);\r\n                }\r\n                if(toAmount > 0) {\r\n                    (toAmount, fee) = caculateFee(user, toAmount, 1);\r\n                    profit[1] = profit[1] + fee;\r\n\r\n                    // save profit\r\n                    updateBalance(bank, fromToken_, profit[0], true);\r\n                    updateBalance(bank, toToken_, profit[1], true);\r\n\r\n                    // transfer to Taker\r\n                    if(manualWithdraw[user]) {\r\n                        updateBalance(user, toToken_, toAmount, true);\r\n                    } else {\r\n                        transferToken(user, toToken_, toAmount);\r\n                    }\r\n                }\r\n            } else {\r\n                orderAmount = amount_;\r\n                makeOrder(fromToken_, toToken_, price_, orderAmount, user, depositAmount);\r\n            }\r\n\r\n            // update balance\r\n            if(amount_ > depositAmount) {\r\n                updateBalance(user, fromToken_, safeSub(amount_, depositAmount), false);\r\n            } else if(amount_ < depositAmount) {\r\n                updateBalance(user, fromToken_, safeSub(depositAmount, amount_), true);\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function userCancelOrder(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 amount_,\r\n        address representor_\r\n    )\r\n        public\r\n    returns(bool) {\r\n        // updateOrderAmount => disconnectOrderUser => withdraw\r\n        address user = getUser(representor_);\r\n        uint256 amount = getOrderAmount(fromToken_, toToken_, price_, user);\r\n        amount = amount > amount_ ? amount_ : amount;\r\n        if(amount > 0) {\r\n            // log event: CancelOrder\r\n            emit eCancelOrder(fromToken_, toToken_, price_, user, amount);\r\n\r\n            updateOrderAmount(fromToken_, toToken_, price_, user, amount, false);\r\n            if(getOrderAmount(fromToken_, toToken_, price_, user) == 0) {\r\n                disconnectOrderUser(fromToken_, toToken_, price_, user);\r\n            }\r\n            if(manualWithdraw[user]) {\r\n                updateBalance(user, fromToken_, amount, true);\r\n            } else {\r\n                transferToken(user, fromToken_, amount);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /* role - 0: maker 1: taker */\r\n    function caculateFee(\r\n        address user_,\r\n        uint256 amount_,\r\n        uint8 role_\r\n    )\r\n        public\r\n        view\r\n    returns(uint256, uint256) {\r\n        uint256 myXPABalance = Token(XPAToken).balanceOf(user_);\r\n        uint256 myFeerate = manualWithdraw[user_]\r\n            ? feerate[role_]\r\n            : feerate[role_] + feerate[2];\r\n        myFeerate =\r\n            myXPABalance > 1000000 ether ? myFeerate * 0.5 ether / 1 ether :\r\n            myXPABalance > 100000 ether ? myFeerate * 0.6 ether / 1 ether :\r\n            myXPABalance > 10000 ether ? myFeerate * 0.8 ether / 1 ether :\r\n            myFeerate;\r\n        uint256 fee = safeDiv(safeMul(amount_, myFeerate), 1 ether);\r\n        uint256 toAmount = safeSub(amount_, fee);\r\n        return(toAmount, fee);\r\n    }\r\n\r\n    function trade(\r\n        address fromToken_,\r\n        address toToken_\r\n    )\r\n        public\r\n        onlyActive\r\n    {\r\n        // Don't worry, this takes maker feerate\r\n        uint256 takerPrice = getNextOrderPrice(fromToken_, toToken_, 0);\r\n        address taker = getNextOrderUser(fromToken_, toToken_, takerPrice, 0);\r\n        uint256 takerAmount = getOrderAmount(fromToken_, toToken_, takerPrice, taker);\r\n        /*\r\n            fillAmount[0] = TakerFill\r\n            fillAmount[1] = MakerFill\r\n            profit[0] = fromTokenProfit\r\n            profit[1] = toTokenProfit\r\n         */\r\n        uint256[2] memory fillAmount;\r\n        uint256[2] memory profit;\r\n        (fillAmount, profit) = findAndTrade(fromToken_, toToken_, takerPrice, takerAmount);\r\n        if(fillAmount[0] > 0) {\r\n            profit[1] = profit[1] + fillOrder(fromToken_, toToken_, takerPrice, taker, fillAmount[0]);\r\n\r\n            // save profit to operator\r\n            updateBalance(msg.sender, fromToken_, profit[0], true);\r\n            updateBalance(msg.sender, toToken_, profit[1], true);\r\n        }\r\n    }\r\n\r\n    function setManualWithdraw(\r\n        bool manual_\r\n    )\r\n        public\r\n    {\r\n        manualWithdraw[msg.sender] = manual_;\r\n    }\r\n\r\n    function getPrice(\r\n        address fromToken_,\r\n        address toToken_\r\n    )\r\n        public\r\n        view\r\n    returns(uint256) {\r\n        if(uint256(fromToken_) >= uint256(toToken_)) {\r\n            return priceBooks[fromToken_][toToken_];            \r\n        } else {\r\n            return priceBooks[toToken_][fromToken_] > 0 ? safeDiv(10 ** 36, priceBooks[toToken_][fromToken_]) : 0;\r\n        }\r\n    }\r\n\r\n    /* Internal Function */\r\n    // deposit all allowance\r\n    function depositAndFreeze(\r\n        address token_,\r\n        address user\r\n    )\r\n        internal\r\n    returns(uint256) {\r\n        uint256 amount;\r\n        if(token_ == address(0)) {\r\n            // log event: Deposit\r\n            emit eDeposit(user, address(0), msg.value);\r\n\r\n            amount = msg.value;\r\n            return amount;\r\n        } else {\r\n            if(msg.value > 0) {\r\n                // log event: Deposit\r\n                emit eDeposit(user, address(0), msg.value);\r\n\r\n                updateBalance(user, address(0), msg.value, true);\r\n            }\r\n            amount = Token(token_).allowance(msg.sender, this);\r\n            if(\r\n                amount > 0 &&\r\n                Token(token_).transferFrom(msg.sender, this, amount)\r\n            ) {\r\n                // log event: Deposit\r\n                emit eDeposit(user, token_, amount);\r\n\r\n                return amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkBalance(\r\n        address user_,\r\n        address token_,\r\n        uint256 amount_,\r\n        uint256 depositAmount_\r\n    )\r\n        internal\r\n    returns(bool) {\r\n        if(safeAdd(balances[user_][token_], depositAmount_) >= amount_) {\r\n            return true;\r\n        } else {\r\n            emit Error(0);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function checkAmount(\r\n        address token_,\r\n        uint256 amount_\r\n    )\r\n        internal\r\n    returns(bool) {\r\n        uint256 min = getMinAmount(token_);\r\n        if(amount_ > maxAmount || amount_ < min) {\r\n            emit Error(2);\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function checkPriceAmount(\r\n        uint256 price_\r\n    )\r\n        internal\r\n    returns(bool) {\r\n        if(price_ == 0 || price_ > maxPrice) {\r\n            emit Error(3);\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function makeOrder(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 amount_,\r\n        address user_,\r\n        uint256 depositAmount_\r\n    )\r\n        internal\r\n    returns(uint256) {\r\n        if(checkBalance(user_, fromToken_, amount_, depositAmount_)) {\r\n            updateOrderAmount(fromToken_, toToken_, price_, user_, amount_, true);\r\n            connectOrderPrice(fromToken_, toToken_, price_, 0);\r\n            connectOrderUser(fromToken_, toToken_, price_, user_);\r\n            return amount_;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function findAndTrade(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 amount_\r\n    )\r\n        internal\r\n    returns(uint256[2], uint256[2]) {\r\n        /*\r\n            totalMatchAmount[0]: Taker total match amount\r\n            totalMatchAmount[1]: Maker total match amount\r\n            profit[0]: fromToken profit\r\n            profit[1]: toToken profit\r\n            matchAmount[0]: Taker match amount\r\n            matchAmount[1]: Maker match amount\r\n         */\r\n        uint256[2] memory totalMatchAmount;\r\n        uint256[2] memory profit;\r\n        uint256[3] memory matchAmount;\r\n        uint256 toAmount;\r\n        uint256 remaining = amount_;\r\n        uint256 matches = 0;\r\n        uint256 prevBestPrice = 0;\r\n        uint256 bestPrice = getNextOrderPrice(toToken_, fromToken_, prevBestPrice);\r\n        for(; matches < autoMatch && remaining > 0;) {\r\n            matchAmount = makeTrade(fromToken_, toToken_, price_, bestPrice, remaining);\r\n            if(matchAmount[0] > 0) {\r\n                remaining = safeSub(remaining, matchAmount[0]);\r\n                totalMatchAmount[0] = safeAdd(totalMatchAmount[0], matchAmount[0]);\r\n                totalMatchAmount[1] = safeAdd(totalMatchAmount[1], matchAmount[1]);\r\n                profit[0] = safeAdd(profit[0], matchAmount[2]);\r\n                \r\n                // for next loop\r\n                matches++;\r\n                prevBestPrice = bestPrice;\r\n                bestPrice = getNextOrderPrice(toToken_, fromToken_, prevBestPrice);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(totalMatchAmount[0] > 0) {\r\n            // log price\r\n            logPrice(toToken_, fromToken_, prevBestPrice);\r\n\r\n            // calculating spread profit\r\n            toAmount = safeDiv(safeMul(totalMatchAmount[0], price_), 1 ether);\r\n            profit[1] = safeSub(totalMatchAmount[1], toAmount);\r\n            if(totalMatchAmount[1] >= safeDiv(safeMul(amount_, price_), 1 ether)) {\r\n                // fromProfit += amount_ - takerFill;\r\n                profit[0] = profit[0] + amount_ - totalMatchAmount[0];\r\n                // fullfill Taker order\r\n                totalMatchAmount[0] = amount_;\r\n            } else {\r\n                toAmount = totalMatchAmount[1];\r\n                // fromProfit += takerFill - (toAmount / price_ * 1 ether)\r\n                profit[0] = profit[0] + totalMatchAmount[0] - (toAmount * 1 ether /price_);\r\n                // (real) takerFill = toAmount / price_ * 1 ether\r\n                totalMatchAmount[0] = safeDiv(safeMul(toAmount, 1 ether), price_);\r\n            }\r\n        }\r\n\r\n        return (totalMatchAmount, profit);\r\n    }\r\n\r\n    function makeTrade(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 bestPrice_,\r\n        uint256 remaining_\r\n    )\r\n        internal\r\n    returns(uint256[3]) {\r\n        if(checkPricePair(price_, bestPrice_)) {\r\n            address prevMaker = address(0);\r\n            address maker = getNextOrderUser(toToken_, fromToken_, bestPrice_, 0);\r\n            uint256 remaining = remaining_;\r\n\r\n            /*\r\n                totalFill[0]: Total Taker fillAmount\r\n                totalFill[1]: Total Maker fillAmount\r\n                totalFill[2]: Total Maker fee\r\n             */\r\n            uint256[3] memory totalFill;\r\n            for(uint256 i = 0; i < autoMatch && remaining > 0 && maker != address(0); i++) {\r\n                uint256[3] memory fill;\r\n                bool fullfill;\r\n                (fill, fullfill) = makeTradeDetail(fromToken_, toToken_, price_, bestPrice_, maker, remaining);\r\n                if(fill[0] > 0) {\r\n                    if(fullfill) {\r\n                        disconnectOrderUser(toToken_, fromToken_, bestPrice_, maker);\r\n                    }\r\n                    remaining = safeSub(remaining, fill[0]);\r\n                    totalFill[0] = safeAdd(totalFill[0], fill[0]);\r\n                    totalFill[1] = safeAdd(totalFill[1], fill[1]);\r\n                    totalFill[2] = safeAdd(totalFill[2], fill[2]);\r\n                    prevMaker = maker;\r\n                    maker = getNextOrderUser(toToken_, fromToken_, bestPrice_, prevMaker);\r\n                    if(maker == address(0)) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return totalFill;\r\n    }\r\n\r\n    function makeTradeDetail(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 bestPrice_,\r\n        address maker_,\r\n        uint256 remaining_\r\n    )\r\n        internal\r\n    returns(uint256[3], bool) {\r\n        /*\r\n            fillAmount[0]: Taker fillAmount\r\n            fillAmount[1]: Maker fillAmount\r\n            fillAmount[2]: Maker fee\r\n         */\r\n        uint256[3] memory fillAmount;\r\n        uint256 takerProvide = remaining_;\r\n        uint256 takerRequire = safeDiv(safeMul(takerProvide, price_), 1 ether);\r\n        uint256 makerProvide = getOrderAmount(toToken_, fromToken_, bestPrice_, maker_);\r\n        uint256 makerRequire = safeDiv(safeMul(makerProvide, bestPrice_), 1 ether);\r\n        fillAmount[0] = caculateFill(takerProvide, takerRequire, price_, makerProvide);\r\n        fillAmount[1] = caculateFill(makerProvide, makerRequire, bestPrice_, takerProvide);\r\n        fillAmount[2] = fillOrder(toToken_, fromToken_, bestPrice_, maker_, fillAmount[1]);\r\n        return (fillAmount, (makerRequire <= takerProvide));\r\n    }\r\n\r\n    function caculateFill(\r\n        uint256 provide_,\r\n        uint256 require_,\r\n        uint256 price_,\r\n        uint256 pairProvide_\r\n    )\r\n        internal\r\n        pure\r\n    returns(uint256) {\r\n        return require_ > pairProvide_ ? safeDiv(safeMul(pairProvide_, 1 ether), price_) : provide_;\r\n    }\r\n\r\n    function checkPricePair(\r\n        uint256 price_,\r\n        uint256 bestPrice_\r\n    )\r\n        internal pure \r\n    returns(bool) {\r\n        if(bestPrice_ < price_) {\r\n            return checkPricePair(bestPrice_, price_);\r\n        } else if(bestPrice_ < 1 ether) {\r\n            return true;\r\n        } else if(price_ > 1 ether) {\r\n            return false;\r\n        } else {\r\n            return price_ * bestPrice_ <= 1 ether * 1 ether;\r\n        }\r\n    }\r\n\r\n    function fillOrder(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        address user_,\r\n        uint256 amount_\r\n    )\r\n        internal\r\n    returns(uint256) {\r\n        // log event: fillOrder\r\n        emit eFillOrder(fromToken_, toToken_, price_, user_, amount_);\r\n\r\n        uint256 toAmount = safeDiv(safeMul(amount_, price_), 1 ether);\r\n        uint256 fee;\r\n        updateOrderAmount(fromToken_, toToken_, price_, user_, amount_, false);\r\n        (toAmount, fee) = caculateFee(user_, toAmount, 0);\r\n        if(manualWithdraw[user_]) {\r\n            updateBalance(user_, toToken_, toAmount, true);\r\n        } else {\r\n            transferToken(user_, toToken_, toAmount);\r\n        }\r\n        return fee;\r\n    }\r\n    function transferToken(\r\n        address user_,\r\n        address token_,\r\n        uint256 amount_\r\n    )\r\n        internal\r\n    returns(bool) {\r\n        if(token_ == address(0)) {\r\n            if(address(this).balance < amount_) {\r\n                emit Error(1);\r\n                return false;\r\n            } else {\r\n                // log event: Withdraw\r\n                emit eWithdraw(user_, token_, amount_);\r\n\r\n                user_.transfer(amount_);\r\n                return true;\r\n            }\r\n        } else if(Token(token_).transfer(user_, amount_)) {\r\n            // log event: Withdraw\r\n            emit eWithdraw(user_, token_, amount_);\r\n\r\n            return true;\r\n        } else {\r\n            emit Error(1);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function updateBalance(\r\n        address user_,\r\n        address token_,\r\n        uint256 amount_,\r\n        bool addOrSub_\r\n    )\r\n        internal\r\n    returns(bool) {\r\n        if(addOrSub_) {\r\n            balances[user_][token_] = safeAdd(balances[user_][token_], amount_);\r\n        } else {\r\n            if(checkBalance(user_, token_, amount_, 0)){\r\n                balances[user_][token_] = safeSub(balances[user_][token_], amount_);\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function connectOrderPrice(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 prev_\r\n    )\r\n        internal\r\n    {\r\n        if(checkPriceAmount(price_)) {\r\n            uint256 prevPrice = getNextOrderPrice(fromToken_, toToken_, prev_);\r\n            uint256 nextPrice = getNextOrderPrice(fromToken_, toToken_, prevPrice);\r\n            if(prev_ != price_ && prevPrice != price_ && nextPrice != price_) {\r\n                if(price_ < prevPrice) {\r\n                    updateNextOrderPrice(fromToken_, toToken_, prev_, price_);\r\n                    updateNextOrderPrice(fromToken_, toToken_, price_, prevPrice);\r\n                } else if(nextPrice == 0) {\r\n                    updateNextOrderPrice(fromToken_, toToken_, prevPrice, price_);\r\n                } else {\r\n                    connectOrderPrice(fromToken_, toToken_, price_, prevPrice);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function connectOrderUser(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        address user_\r\n    )\r\n        internal \r\n    {\r\n        address firstUser = getNextOrderUser(fromToken_, toToken_, price_, 0);\r\n        if(user_ != address(0) && user_ != firstUser) {\r\n            updateNextOrderUser(fromToken_, toToken_, price_, 0, user_);\r\n            if(firstUser != address(0)) {\r\n                updateNextOrderUser(fromToken_, toToken_, price_, user_, firstUser);\r\n            }\r\n        }\r\n    }\r\n\r\n    function disconnectOrderPrice(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_\r\n    )\r\n        internal\r\n    {\r\n        uint256 currPrice = getNextOrderPrice(fromToken_, toToken_, 0);\r\n        uint256 nextPrice = getNextOrderPrice(fromToken_, toToken_, currPrice);\r\n        if(price_ == currPrice) {\r\n            updateNextOrderPrice(fromToken_, toToken_, 0, nextPrice);\r\n        }\r\n    }\r\n\r\n    function disconnectOrderUser(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        address user_\r\n    )\r\n        internal\r\n    {\r\n        if(user_ == address(0)) {\r\n            return;\r\n        }\r\n        address currUser = getNextOrderUser(fromToken_, toToken_, price_, address(0));\r\n        address nextUser = getNextOrderUser(fromToken_, toToken_, price_, currUser);\r\n        if(currUser == user_) {\r\n            updateNextOrderUser(fromToken_, toToken_, price_, address(0), nextUser);\r\n            if(nextUser == address(0)) {\r\n                disconnectOrderPrice(fromToken_, toToken_, price_);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getNextOrderPrice(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_\r\n    )\r\n        internal\r\n        view\r\n    returns(uint256) {\r\n        return nextOrderPrice[fromToken_][toToken_][price_];\r\n    }\r\n\r\n    function updateNextOrderPrice(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        uint256 nextPrice_\r\n    )\r\n        internal\r\n    {\r\n        nextOrderPrice[fromToken_][toToken_][price_] = nextPrice_;\r\n    }\r\n\r\n    function getNextOrderUser(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        address user_\r\n    )\r\n        internal\r\n        view\r\n    returns(address) {\r\n        return orderBooks[fromToken_][toToken_][price_][user_].nextUser;\r\n    }\r\n\r\n    function getOrderAmount(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        address user_\r\n    )\r\n        internal\r\n        view\r\n    returns(uint256) {\r\n        return orderBooks[fromToken_][toToken_][price_][user_].amount;\r\n    }\r\n\r\n    function updateNextOrderUser(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        address user_,\r\n        address nextUser_\r\n    )\r\n        internal\r\n    {\r\n        orderBooks[fromToken_][toToken_][price_][user_].nextUser = nextUser_;\r\n    }\r\n\r\n    function updateOrderAmount(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_,\r\n        address user_,\r\n        uint256 amount_,\r\n        bool addOrSub_\r\n    )\r\n        internal\r\n    {\r\n        if(addOrSub_) {\r\n            orderBooks[fromToken_][toToken_][price_][user_].amount = safeAdd(orderBooks[fromToken_][toToken_][price_][user_].amount, amount_);\r\n        } else {\r\n            orderBooks[fromToken_][toToken_][price_][user_].amount = safeSub(orderBooks[fromToken_][toToken_][price_][user_].amount, amount_);\r\n        }\r\n    }\r\n\r\n    function logPrice(\r\n        address fromToken_,\r\n        address toToken_,\r\n        uint256 price_\r\n    )\r\n        internal\r\n    {\r\n        if(price_ > 0) {\r\n            if(uint256(fromToken_) >= uint256(toToken_)) {\r\n                priceBooks[fromToken_][toToken_] = price_;\r\n            } else  {\r\n                priceBooks[toToken_][fromToken_] = safeDiv(10 ** 36, price_);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"XPAToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceBooks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bank_\",\"type\":\"address\"}],\"name\":\"assignBank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromToken_\",\"type\":\"address\"},{\"name\":\"toToken_\",\"type\":\"address\"},{\"name\":\"price_\",\"type\":\"uint256\"},{\"name\":\"amount_\",\"type\":\"uint256\"},{\"name\":\"representor_\",\"type\":\"address\"}],\"name\":\"userTakeOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextOrderPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromToken_\",\"type\":\"address\"},{\"name\":\"toToken_\",\"type\":\"address\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"minAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"getMinAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"agentBooks\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"orderBooks\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nextUser\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"},{\"name\":\"amount_\",\"type\":\"uint256\"},{\"name\":\"representor_\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feerate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"assignOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user_\",\"type\":\"address\"},{\"name\":\"amount_\",\"type\":\"uint256\"},{\"name\":\"role_\",\"type\":\"uint8\"}],\"name\":\"caculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent_\",\"type\":\"address\"}],\"name\":\"assignAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromToken_\",\"type\":\"address\"},{\"name\":\"toToken_\",\"type\":\"address\"},{\"name\":\"price_\",\"type\":\"uint256\"},{\"name\":\"amount_\",\"type\":\"uint256\"},{\"name\":\"representor_\",\"type\":\"address\"}],\"name\":\"userCancelOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fromToken_\",\"type\":\"address\"},{\"name\":\"toToken_\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"autoMatch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feerate_\",\"type\":\"uint256[3]\"}],\"name\":\"setFeerate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"autoMatch_\",\"type\":\"uint256\"},{\"name\":\"maxAmount_\",\"type\":\"uint256\"},{\"name\":\"maxPrice_\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"representor_\",\"type\":\"address\"}],\"name\":\"isRepresentor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"},{\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"setMinAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"onOff_\",\"type\":\"bool\"}],\"name\":\"powerSwitch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"powerStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_\",\"type\":\"address\"},{\"name\":\"representor_\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manual_\",\"type\":\"bool\"}],\"name\":\"setManualWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eMakeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eFillOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eCancelOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"code\",\"type\":\"uint256\"}],\"name\":\"Error\",\"type\":\"event\"}]","ContractName":"Baliv","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a2d2f06eaefd53a8704766410da9cfcb3da076172dd3f50819a34eaf6eee3dcd"}]}