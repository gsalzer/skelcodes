{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant public returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n \r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    \r\n  using SafeMath for uint256;\r\n \r\n  mapping(address => uint256) balances;\r\n \r\n  \r\n \r\n}\r\n\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n \r\n  mapping (address => mapping (address => uint256)) allowed;\r\n \r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n\r\n \r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n \r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n \r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n \r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n \r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    \r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n \r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  \r\n\r\n \r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function  transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n  \r\n\r\n \r\n}\r\n \r\n \r\n \r\n \r\n\r\n \r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n  \r\n  \r\n   function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    if(b==0) return 1;\r\n    assert(b>=0);\r\n    uint256 c = a ** b;\r\n    assert(c>=a );\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  \r\n\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\nfunction compoundInterest(uint256 depo, uint256 stage2, uint256 start, uint256 current)  internal pure returns (uint256)  {\r\n            if(current<start || start<stage2 || current<stage2) return depo;\r\n\r\n            uint256 ret=depo; uint256 g; uint256 d;\r\n            stage2=stage2/1 days;\r\n            start=start/1 days;\r\n            current=current/1 days;\r\n    \r\n\t\t\tuint256 dpercent=100;\r\n\t\t\tuint256 i=start;\r\n\t\t\t\r\n\t\t\tif(i-stage2>365) dpercent=200;\r\n\t\t\tif(i-stage2>730) dpercent=1000;\t\t\t\r\n\t\t\t\r\n\t\t\twhile(i<current)\r\n\t\t\t{\r\n\r\n\t\t\t\tg=i-stage2;\t\t\t\r\n\t\t\t\tif(g>265 && g<=365) \r\n\t\t\t\t{\t\t\r\n\t\t\t\t    d=365-g;\r\n\t\t\t\t\tif(d>=(current-start))  d=(current-start);\r\n\t\t\t\t\tret=fracExp(ret, dpercent, d, 8);\r\n\t\t\t\t    i+=d;\r\n\t\t\t\t\tdpercent=200;\r\n\t\t\t\t}\r\n\t\t\t\tif(g>630 && g<=730) \r\n\t\t\t\t{\t\t\t\t\r\n\t\t\t\t\td=730-g;\t\r\n\t\t\t\t\tif(d>=(current-start))  d=(current-start);\t\t\t\t\t\r\n\t\t\t\t\tret=fracExp(ret, dpercent, d, 8);\r\n\t\t\t\t\ti+=d;\r\n\t\t\t\t\tdpercent=1000;\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse if(g>730) dpercent=1000;\t\t\t\t\r\n\t\t\t\telse if(g>365) dpercent=200;\r\n\t\t\t\t\r\n\t\t\t\tif(i+100<current) ret=fracExp(ret, dpercent, 100, 8);\r\n\t\t\t\telse return fracExp(ret, dpercent, current-i, 8);\r\n\t\t\t\ti+=100;\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\treturn ret;\r\n\t\t\t\r\n\t\t\t\r\n    \r\n    \r\n\t}\r\n\r\n\r\nfunction fracExp(uint256 depo, uint256 percent, uint256 period, uint256 p)  internal pure returns (uint256) {\r\n  uint256 s = 0;\r\n  uint256 N = 1;\r\n  uint256 B = 1;\r\n  \r\n\r\n  \r\n  for (uint256 i = 0; i < p; ++i){\r\n    s += depo * N / B / (percent**i);\r\n    N  = N * (period-i);\r\n    B  = B * (i+1);\r\n  }\r\n  return s;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract MMMTokenCoin is StandardToken, Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    string public constant name = \"Make More Money\";\r\n    string public constant symbol = \"MMM\";\r\n    uint32 public constant decimals = 2;\r\n    \r\n\t\r\n\t// Dates\r\n\tuint256 public stage2StartTime;\t\t\t\t\t// timestamp when compound interest will begin\r\n    uint256 globalInterestDate;             // last date when amount of tokens with interest was changed\r\n    uint256 globalInterestAmount;           // amount of tokens with interest\r\n\tmapping(address => uint256) dateOfStart;     // timestamp of last operation, from which interest calc will be started\r\n\tuint256 public currentDate;\t\t\t\t\t\t// current date timestamp\r\n\tuint256 public debugNow=0;\r\n\r\n\r\n\r\n    // Crowdsale \r\n    uint256 public totalSupply=99900000000;\t\t\t\r\n uint256 public  softcap;\r\n    uint256 public  step0Rate=100000;       // rate of our tokens. 1 eth = 1000 MMM coins = 100000 tokens (seen as 1000,00 because of decimals)\r\n    uint256 public  currentRate=100000;   \r\n    uint256 public constant tokensForOwner=2000000000;   // tokens for owner won't dealt with compound interest\r\n    uint256 public tokensFromEther=0;\r\n    uint public saleStatus=0;      // 0 - sale is running, 1 - sale failed, 2 - sale successful\r\n    address multisig=0x8216A5958f05ad61898e3A6F97ae5118C0e4b1A6;\r\n    // counters of tokens for futher refund\r\n    mapping(address => uint256) boughtWithEther;                // tokens, bought with ether. can be refunded to ether\r\n    mapping(address => uint256) boughtWithOther;    \t\t\t// tokens, bought with other payment systems. can be refunded to other payment systems, using site\r\n    mapping(address => uint256) bountyAndRefsWithEther;  \t\t// bounty tokens, given to some people. can be converted to ether, if ico is succeed\r\n  \r\n    \r\n\r\n\t\t\r\n\t\t\r\n    // events\r\n    event RefundEther(address indexed to, uint256 tokens, uint256 eth); \r\n    event DateUpdated(uint256 cdate);    \r\n    event DebugLog(string what, uint256 param);\r\n    event Sale(address indexed to, uint256 amount);\r\n    event Step0Finished();\r\n    event RateSet(uint256 newRate);\t\r\n    event Burn(address indexed who, uint256 amount);\r\n   // DEBUG\r\n\r\n    bool bDbgEnabled=false;\r\n\t\r\n\t\r\n\t\r\n    function MMMTokenCoin() public   {  \r\n        // Crowdsale     \r\n        currentDate=(getNow()/1 days)*1 days;\r\n        stage2StartTime=getNow()+61 days;\r\n        \r\n        balances[owner]=tokensForOwner;\r\n        globalInterestAmount=0;\r\n        \r\n        if(bDbgEnabled) softcap=20000;\r\n        else  softcap=50000000;\r\n    }\r\n\t\r\n\t\r\n\tfunction debugSetNow(uint256 n) public\r\n\t{\r\n\t    require(bDbgEnabled);\r\n\t\tdebugNow=n;\r\n\t}\r\n\t\r\n\t\r\n\t /**\r\n     * @dev Returns current timestamp. In case of debugging, this function can return timestamp representing any other time\r\n     */\r\n     \r\n     \r\n\tfunction getNow() public view returns (uint256)\r\n\t{\r\n\t    \r\n\t    if(!bDbgEnabled) return now;\r\n\t    \r\n\t    if(debugNow==0) return now;\r\n\t\telse return debugNow;\r\n//\t\treturn now;\r\n\t}\r\n   \r\n    /**\r\n     * @dev Sets date from which interest will be calculated for specified address\r\n     * @param _owner - address of balance owner\r\n     */\r\n   \r\n    \r\n    function updateDate(address _owner) private {\r\n        if(currentDate<stage2StartTime) dateOfStart[_owner]=stage2StartTime;\r\n        else dateOfStart[_owner]=currentDate;\r\n    }\r\n    \r\n\r\n\t\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of. \r\n    * @return An uint25664 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) \r\n    { \r\n        \r\n         return balanceWithInterest(_owner);\r\n    }   \r\n   \r\n\t\r\n    /**\r\n     * @dev Gets balance including interest for specified address\r\n   \t * @param _owner The address to query the the balance of. \r\n     */\r\n\t\t\r\n\t\t\r\n    function balanceWithInterest(address _owner)  private constant returns (uint256 ret)\r\n    {\r\n        if( _owner==owner || saleStatus!=2) return balances[_owner]; \r\n        return balances[_owner].compoundInterest(stage2StartTime, dateOfStart[_owner], currentDate);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n\t\t \r\n  function transfer(address _to, uint256 _value)  public returns (bool) {\r\n    if(msg.sender==owner) {\r\n    \t// if owner sends tokens before sale finish, consider then as ether-refundable bonus\r\n    \t// else as simple transfer\r\n        if(saleStatus==0) {\r\n            \ttransferFromOwner(_to, _value,1);\r\n            \ttokensFromEther=tokensFromEther.add(_value);\r\n\t\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add(_value);\r\n        \t}\r\n        \telse transferFromOwner(_to, _value,0);\r\n        \t\r\n        \tincreaseGlobalInterestAmount(_value);\r\n        \treturn true;   \r\n    }\r\n    \r\n    balances[msg.sender] = balanceWithInterest(msg.sender).sub(_value);\r\n\r\n    emit Transfer(msg.sender, _to, _value);\r\n    if(_to==address(this)) {\r\n\t\t// make refund if tokens sent to contract\r\n        uint256 left; left=processRefundEther(msg.sender, _value);\r\n        balances[msg.sender]=balances[msg.sender].add(left);\r\n    }\r\n    else {\r\n        balances[_to] = balanceWithInterest(_to).add(_value);\r\n        updateDate(_to);\r\n    }\r\n    \r\n    if(_to==owner) \r\n    {\r\n    \t// before sale finish, tokens can't be sent to owner\r\n        require(saleStatus!=0);\r\n        decreaseGlobalInterestAmount(_value);\r\n    }\r\n    \r\n    updateDate(msg.sender);\r\n    return true;\r\n  }\r\n  \r\n  \r\n  /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transfered\r\n    */\r\n\t  \r\n  \r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n           require(_to!=owner);\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n     allowed[_from][msg.sender] = _allowance.sub(_value);\r\n\r\n    if(_from==owner) {\r\n        if(saleStatus==0) {\r\n            transferFromOwner(_to, _value,1);\r\n            tokensFromEther=tokensFromEther.add(_value);\r\n\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add(_value);\t\t\t\r\n        }\r\n        else transferFromOwner(_to, _value,0);\r\n      \r\n        increaseGlobalInterestAmount(_value);\r\n        return true;\r\n    }\r\n     \r\n     \r\n    balances[_from] = balanceWithInterest(_from).sub(_value);\r\n\r\n     emit Transfer(_from, _to, _value);\r\n\r\n    if(_to==address(this)) {\r\n\t\t// make refund if tokens sent to contract\t\t   \r\n        uint256 left; left=processRefundEther(_from, _value);\r\n        balances[_from]=balances[_from].add(left);\r\n    }\r\n    else {\r\n        balances[_to] = balanceWithInterest(_to).add(_value);\r\n        updateDate(_to);\r\n    }\r\n    \r\n    if(_to==owner) \r\n    {\r\n        require(saleStatus!=0);\r\n        decreaseGlobalInterestAmount(_value);\r\n    }\r\n\r\n    updateDate(_from);\r\n\r\n    return true;\r\n  }\r\n  \r\n  \r\n  \r\n    /**\r\n    * @dev Burns tokens\r\n    * @param _amount amount of tokens to burn\r\n    */\r\n\t  \r\n\t  \r\n\t  \r\n  function burn(uint256 _amount) public \r\n  {\r\n\t  \trequire(_amount>0);\r\n        balances[msg.sender]=balanceOf(msg.sender).sub(_amount);\r\n\t\tdecreaseGlobalInterestAmount(_amount);\r\n        emit Burn(msg.sender, _amount);\r\n  }\r\n   \r\n   //// SALE ////\r\n   \r\n    /**\r\n     * @dev updates rate with whic tokens are being sold\r\n     */\r\n\r\n \tfunction setRate(uint256 r) public {\r\n\t\trequire(saleStatus!=0);\r\n\t\tcurrentRate=r;\r\n\t\temit RateSet(currentRate);\r\n\t}\r\n\r\n    /**\r\n     * @dev updates current date value. For compound interest calculation\r\n     */\r\n    \r\n    function newDay() public   returns (bool b)\r\n    {\r\n        \r\n       uint256 g; uint256 newDate;\r\n       require(getNow()>=stage2StartTime);\r\n       require(getNow()>=currentDate);\r\n       newDate=(getNow()/1 days)*1 days;\r\n        if(getNow()>=stage2StartTime && saleStatus==0)\r\n        {\r\n            if(tokensForOwner.sub(balances[owner])>=softcap) saleStatus=2;\r\n            else saleStatus=1;\r\n         \r\n            emit Step0Finished();\r\n        }\r\n      \r\n\t   // check if overall compound interest of tokens will be less than total supply\r\n\t  \r\n       g=globalInterestAmount.compoundInterest(stage2StartTime, globalInterestDate, newDate);\r\n       if(g<=totalSupply && saleStatus==2) {\r\n             currentDate=(getNow()/1 days)*1 days; \r\n             globalInterestAmount=g;\r\n             globalInterestDate=currentDate;\r\n             emit DateUpdated(currentDate);\r\n             return true;\r\n       }\r\n       else if(saleStatus==1) currentDate=(getNow()/1 days)*1 days; \r\n       \r\n       return false;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev Sends collected ether to owner. If sale is not success, contract will hold ether for half year, and after, ether can be sent to owner\r\n     * @return amount of owner's ether\r\n     */\r\n     \r\n    function sendEtherToMultisig() public  returns(uint256 e) {\r\n        uint256 req;\r\n        require(msg.sender==owner || msg.sender==multisig);\r\n        require(saleStatus!=0);\r\n\r\n        if(saleStatus==2) {\r\n        \t// calculate ether for refunds\r\n        \treq=tokensFromEther.mul(1 ether).div(step0Rate).div(2);\r\n\r\n        \tif(bDbgEnabled) emit DebugLog(\"This balance is\", this.balance);\r\n        \tif(req>=this.balance) return 0;\r\n    \t}\r\n    \telse if(saleStatus==1) {\r\n    \t\trequire(getNow()-stage2StartTime>15768000);\r\n    \t\treq=0; \r\n    \t}\r\n        uint256 amount;\r\n        amount=this.balance.sub(req);\r\n        multisig.transfer(amount);\r\n        return amount;\r\n        \r\n    }\r\n    \r\n\t\r\n\r\n\r\n\t\r\n\t\r\n\t/**\r\n\t\tRefund functions. \r\n\t\tIf ico is success, anyone can get 0.000005 eth for 1 token,  else 00001 eth\r\n\t\t\r\n\t*/\r\n\t\r\n    /**\r\n     * @dev Refunds ether to sender if he trasnfered tokens to contract address. Calculates max possible amount of refund. If sent tokens>refund amound, tokens will be returned to sender.\r\n     * @param _to Address of refund receiver\r\n     * @param _value Tokens requested for refund\r\n     */\r\n\t\r\n    function processRefundEther(address _to, uint256 _value) private returns (uint256 left)\r\n    {\r\n        require(saleStatus!=0);\r\n        require(_value>0);\r\n        uint256 Ether=0; uint256 bounty=0;  uint256 total=0;\r\n\r\n        uint256 rate2=saleStatus;\r\n\r\n        \r\n        if(_value>=boughtWithEther[_to]) {Ether=Ether.add(boughtWithEther[_to]); _value=_value.sub(boughtWithEther[_to]); }\r\n        else {Ether=Ether.add(_value); _value=_value.sub(Ether);}\r\n        boughtWithEther[_to]=boughtWithEther[_to].sub(Ether);\r\n        \r\n        if(rate2==2) {        \r\n            if(_value>=bountyAndRefsWithEther[_to]) {bounty=bounty.add(bountyAndRefsWithEther[_to]); _value=_value.sub(bountyAndRefsWithEther[_to]); }\r\n            else { bounty=bounty.add(_value); _value=_value.sub(bounty); }\r\n            bountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].sub(bounty);\r\n        }\r\n        total=Ether.add(bounty);\r\n     //   if(_value>total) _value=_value.sub(total);\r\n        tokensFromEther=tokensFromEther.sub(total);\r\n       uint256 eth=total.mul(1 ether).div(step0Rate).div(rate2);\r\n         _to.transfer(eth);\r\n        if(bDbgEnabled) emit DebugLog(\"Will refund \", eth);\r\n\r\n        emit RefundEther(_to, total, eth);\r\n        decreaseGlobalInterestAmount(total);\r\n        return _value;\r\n    }\r\n    \r\n    \r\n\t\r\n\r\n\t     /**\r\n     * @dev Returns info about refundable tokens- bought with ether, payment systems, and bonus tokens convertable to ether\r\n     */\r\n\t\r\n\tfunction getRefundInfo(address _to) public returns (uint256, uint256, uint256)\r\n\t{\r\n\t    return  ( boughtWithEther[_to],  boughtWithOther[_to],  bountyAndRefsWithEther[_to]);\r\n\t    \r\n\t}\r\n\t\r\n    \r\n    /**\r\n     * @dev Withdraw tokens  refunded to other payment systems.\r\n     * @param _to Address of refund receiver\r\n     */\r\n    \r\n    function refundToOtherProcess(address _to, uint256 _value) public onlyOwner returns (uint256 o) {\r\n        require(saleStatus!=0);\r\n        //uint256 maxValue=refundToOtherGet(_to);\r\n        uint256 maxValue=0;\r\n        require(_value<=maxValue);\r\n        \r\n        uint256 Other=0; uint256 bounty=0; \r\n\r\n\r\n\r\n        \r\n        if(_value>=boughtWithOther[_to]) {Other=Other.add(boughtWithOther[_to]); _value=_value.sub(boughtWithOther[_to]); }\r\n        else {Other=Other.add(_value); _value=_value.sub(Other);}\r\n        boughtWithOther[_to]=boughtWithOther[_to].sub(Other);\r\n\r\n       \r\n        balances[_to]=balanceOf(_to).sub(Other).sub(bounty);\r\n        updateDate(_to);\r\n        decreaseGlobalInterestAmount(Other.add(bounty));\r\n        return _value;\r\n        \r\n        \r\n    }\r\n    \r\n \r\n    /**\r\n     * @dev Converts ether to our tokens \r\n     */\r\n\t\t  \r\n    \r\n    function createTokensFromEther()  private   {\r\n               \r\n        assert(msg.value >= 1 ether / 1000);\r\n       \r\n         uint256 tokens = currentRate.mul(msg.value).div(1 ether);\r\n\r\n\r\n        transferFromOwner(msg.sender, tokens,2);\r\n      \r\n       if(saleStatus==0) {\r\n           boughtWithEther[msg.sender]=boughtWithEther[msg.sender].add(tokens);\r\n            tokensFromEther=tokensFromEther.add(tokens);\r\n       }\r\n      \r\n    }\r\n\t\r\n\t\r\n    /**\r\n     * @dev Converts other payments system payment to  tokens. Main logic is on site\r\n     */\r\n    \r\n    function createTokensFromOther(address _to, uint256 howMuch, address referer) public  onlyOwner   { \r\n      \r\n        require(_to!=address(this));\r\n         transferFromOwner(_to, howMuch,2);\r\n         if(referer!=0 && referer!=address(this) && referer!=0x0000000000000000000000000000000000000000 && howMuch.div(10)>0) {\r\n             transferFromOwner(referer, howMuch.div(10),1);\r\n\t         if(saleStatus==0) {\r\n\t             \ttokensFromEther=tokensFromEther.add( howMuch.div(10));\r\n\t \t\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add( howMuch.div(10));\r\n\t         \t}\r\n         }\r\n         if(saleStatus==0) boughtWithOther[_to]= boughtWithOther[_to].add(howMuch);\r\n    }\r\n\r\n\t   /**\r\n     * @dev Gives refs tokens through payment on site. Main logic is on site\r\n     * @param _to Address of  receiver\r\n     * @param _amount Amount of tokens\t\t\r\n\t * @param t type of transfer. 0 is transfer, 1 bonus tokens, 2 - sale\r\n     */\r\n\t\r\n\tfunction transferFromOwner(address _to, uint256 _amount, uint t) private {\r\n\t   require(_to!=address(this) && _to!=address(owner) );\r\n        balances[owner]=balances[owner].sub(_amount); \r\n        balances[_to]=balanceOf(_to).add(_amount);\r\n        updateDate(_to);\r\n\r\n        increaseGlobalInterestAmount(_amount);\r\n\t    \r\n\t   \r\n\t     if(t==2) emit Sale(_to, _amount);\r\n        emit Transfer(owner, _to, _amount);\t     \r\n\t}\r\n\t\r\n\r\n    function increaseGlobalInterestAmount(uint256 c) private \r\n    {\r\n        globalInterestAmount=globalInterestAmount.add(c);\r\n\t\t\r\n    }\r\n    \r\n    function decreaseGlobalInterestAmount(uint256 c) private\r\n    {\r\n        if(c<globalInterestAmount) {\r\n            globalInterestAmount=globalInterestAmount.sub(c);\r\n        }\r\n            \r\n        \r\n    }\r\n    \r\n    function() external payable {\r\n        createTokensFromEther();\r\n    }\r\n\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"debugSetNow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendEtherToMultisig\",\"outputs\":[{\"name\":\"e\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debugNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"howMuch\",\"type\":\"uint256\"},{\"name\":\"referer\",\"type\":\"address\"}],\"name\":\"createTokensFromOther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"newDay\",\"outputs\":[{\"name\":\"b\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"refundToOtherProcess\",\"outputs\":[{\"name\":\"o\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage2StartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"step0Rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"getRefundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensFromEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"RefundEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cdate\",\"type\":\"uint256\"}],\"name\":\"DateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"what\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"param\",\"type\":\"uint256\"}],\"name\":\"DebugLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Step0Finished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"RateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MMMTokenCoin","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1ca2dd7d39bc2fb7879305c57eb4ac78b70e3c3fa89bbdfe59f7358f13c877c0"}]}