{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/oraclizeLib.sol\r\n\r\n// <ORACLIZE_API_LIB>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.0;\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\nlibrary oraclizeLib {\r\n    //byte constant internal proofType_NONE = 0x00;\r\n    function proofType_NONE()\r\n    constant\r\n    returns (byte) {\r\n        return 0x00;\r\n    }\r\n    //byte constant internal proofType_TLSNotary = 0x10;\r\n    function proofType_TLSNotary()\r\n    constant\r\n    returns (byte) {\r\n        return 0x10;\r\n    }\r\n    //byte constant internal proofStorage_IPFS = 0x01;\r\n    function proofStorage_IPFS()\r\n    constant\r\n    returns (byte) {\r\n        return 0x01;\r\n    }\r\n\r\n    // *******TRUFFLE + BRIDGE*********\r\n    //OraclizeAddrResolverI constant public OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n\r\n    // *****REALNET DEPLOYMENT******\r\n    OraclizeAddrResolverI constant public OAR = oraclize_setNetwork(); // constant means dont store and re-eval on each call\r\n\r\n    function getOAR()\r\n    constant\r\n    returns (OraclizeAddrResolverI) {\r\n        return OAR;\r\n    }\r\n\r\n    OraclizeI constant public oraclize = OraclizeI(OAR.getAddress());\r\n\r\n    function getCON()\r\n    constant\r\n    returns (OraclizeI) {\r\n        return oraclize;\r\n    }\r\n\r\n    function oraclize_setNetwork()\r\n    public\r\n    returns(OraclizeAddrResolverI){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            return OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n        }\r\n        if (getCodeSize(0xb9b00A7aE2e1D3557d7Ec7e0633e25739A6B510e)>0) { // ropsten custom ethereum bridge\r\n            return OraclizeAddrResolverI(0xb9b00A7aE2e1D3557d7Ec7e0633e25739A6B510e);\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            return OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            return OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            return OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            return OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            return OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            return OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n        }\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource)\r\n    public\r\n    returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource, uint gaslimit)\r\n    public\r\n    returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg)\r\n    public\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, arg);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg)\r\n    public\r\n    returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg, uint gaslimit)\r\n    public\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, arg, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit)\r\n    public\r\n    returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg1, string arg2)\r\n    public\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, arg1, arg2);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2)\r\n    public\r\n    returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit)\r\n    public\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit)\r\n    public\r\n    returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[] argN)\r\n    internal\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, argN);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN)\r\n    internal\r\n    returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[] argN, uint gaslimit)\r\n    internal\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, argN, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit)\r\n    internal\r\n    returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n\r\n    function oraclize_cbAddress()\r\n    public\r\n    constant\r\n    returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n\r\n    function oraclize_setProof(byte proofP)\r\n    public {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n\r\n    function oraclize_setCustomGasPrice(uint gasPrice)\r\n    public {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function oraclize_setConfig(bytes32 config)\r\n    public {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function getCodeSize(address _addr)\r\n    public\r\n    returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function parseAddr(string _a)\r\n    public\r\n    returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string _a, string _b)\r\n    public\r\n    returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function indexOf(string _haystack, string _needle)\r\n    public\r\n    returns (int) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e)\r\n    internal\r\n    returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d)\r\n    internal\r\n    returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c)\r\n    internal\r\n    returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b)\r\n    internal\r\n    returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a)\r\n    public\r\n    constant\r\n    returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b)\r\n    public\r\n    constant\r\n    returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint i)\r\n    internal\r\n    returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] arr)\r\n    internal\r\n    returns (bytes) {\r\n        uint arrlen = arr.length;\r\n\r\n        // get correct cbor output length\r\n        uint outputlen = 0;\r\n        bytes[] memory elemArray = new bytes[](arrlen);\r\n        for (uint i = 0; i < arrlen; i++) {\r\n            elemArray[i] = (bytes(arr[i]));\r\n            outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n        }\r\n        uint ctr = 0;\r\n        uint cborlen = arrlen + 0x80;\r\n        outputlen += byte(cborlen).length;\r\n        bytes memory res = new bytes(outputlen);\r\n\r\n        while (byte(cborlen).length > ctr) {\r\n            res[ctr] = byte(cborlen)[ctr];\r\n            ctr++;\r\n        }\r\n        for (i = 0; i < arrlen; i++) {\r\n            res[ctr] = 0x5F;\r\n            ctr++;\r\n            for (uint x = 0; x < elemArray[i].length; x++) {\r\n                // if there's a bug with larger strings, this may be the culprit\r\n                if (x % 23 == 0) {\r\n                    uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                    elemcborlen += 0x40;\r\n                    uint lctr = ctr;\r\n                    while (byte(elemcborlen).length > ctr - lctr) {\r\n                        res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                        ctr++;\r\n                    }\r\n                }\r\n                res[ctr] = elemArray[i][x];\r\n                ctr++;\r\n            }\r\n            res[ctr] = 0xFF;\r\n            ctr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function b2s(bytes _b)\r\n    internal\r\n    returns (string) {\r\n        bytes memory output = new bytes(_b.length * 2);\r\n        uint len = output.length;\r\n\r\n        assembly {\r\n            let i := 0\r\n            let mem := 0\r\n            loop:\r\n                // isolate octet\r\n                0x1000000000000000000000000000000000000000000000000000000000000000\r\n                exp(0x10, mod(i, 0x40))\r\n                // change offset only if needed\r\n                jumpi(skip, gt(mod(i, 0x40), 0))\r\n                // save offset mem for reuse\r\n                mem := mload(add(_b, add(mul(0x20, div(i, 0x40)), 0x20)))\r\n            skip:\r\n                mem\r\n                mul\r\n                div\r\n                dup1\r\n                // check if alpha or numerical, jump if numerical\r\n                0x0a\r\n                swap1\r\n                lt\r\n                num\r\n                jumpi\r\n                // offset alpha char correctly\r\n                0x0a\r\n                swap1\r\n                sub\r\n            alp:\r\n                0x61\r\n                add\r\n                jump(end)\r\n            num:\r\n                0x30\r\n                add\r\n            end:\r\n                add(output, add(0x20, i))\r\n                mstore8\r\n                i := add(i, 1)\r\n                jumpi(loop, gt(len, i))\r\n        }\r\n\r\n        return string(output);\r\n    }\r\n}\r\n// </ORACLIZE_API_LIB>\r\n\r\n// File: contracts/DogRace.sol\r\n\r\n//contract DogRace is usingOraclize {\r\ncontract DogRace {\r\n    using SafeMath for uint256; \r\n\r\n    string public constant version = \"0.0.5\";\r\n\r\n    uint public constant min_bet = 0.1 ether;\r\n    uint public constant max_bet = 1 ether;\r\n    uint public constant house_fee_pct = 5;\r\n    uint public constant claim_period = 30 days;\r\n\r\n    address public owner;   // owner address\r\n\r\n    // Currencies: BTC, ETH, LTC, BCH, XRP\r\n    uint8 constant dogs_count = 5;\r\n\r\n    // Race states and timing\r\n    struct chronus_struct {\r\n        bool  betting_open;     // boolean: check if betting is open\r\n        bool  race_start;       // boolean: check if race has started\r\n        bool  race_end;         // boolean: check if race has ended\r\n        bool  race_voided;      // boolean: check if race has been voided\r\n        uint  starting_time;    // timestamp of when the race starts\r\n        uint  betting_duration; // duration of betting period\r\n        uint  race_duration;    // duration of the race\r\n    }\r\n    \r\n    // Single bet information\r\n    struct bet_info {\r\n        uint8 dog;       // Dog on which the bet is made\r\n        uint amount;    // Amount of the bet\r\n    }\r\n\r\n    // Dog pool information\r\n    struct pool_info {\r\n        uint bets_total;       // total bets amount\r\n        uint pre;              // start price\r\n        uint post;             // ending price\r\n        int delta;             // price delta\r\n        bool post_check;       // differentiating pre and post prices in oraclize callback\r\n        bool winner;           // has respective dog won the race?\r\n    }\r\n\r\n    // Bettor information\r\n    struct bettor_info {\r\n        uint bets_total;       // total bets amount\r\n        bool rewarded;         // if reward was paid to the bettor\r\n        bet_info[] bets;       // array of bets\r\n    }\r\n\r\n    mapping (bytes32 => uint) oraclize_query_ids;        // mapping oraclize query IDs => dogs\r\n    mapping (address => bettor_info) bettors;       // mapping bettor address => bettor information\r\n    \r\n    pool_info[dogs_count] pools;                    // pools for each currency\r\n\r\n    chronus_struct chronus;                         // states and timing\r\n\r\n    uint public bets_total = 0;                     // total amount of bets\r\n    uint public reward_total = 0;                   // total amount to be distributed among winners\r\n    uint public winning_bets_total = 0;             // total amount of bets in winning pool(s)\r\n    uint prices_remaining = dogs_count;             // variable to check if all prices are received at the end of the race\r\n    int max_delta = int256((uint256(1) << 255));    // winner dog(s) delta; initialize to minimal int value\r\n\r\n    // tracking events\r\n    event OraclizeQuery(string description);\r\n    event PriceTicker(uint dog, uint price);\r\n    event Bet(address from, uint256 _value, uint dog);\r\n    event Reward(address to, uint256 _value);\r\n    event HouseFee(uint256 _value);\r\n\r\n    // constructor\r\n    function DogRace() public {\r\n        owner = msg.sender;\r\n        oraclizeLib.oraclize_setCustomGasPrice(20000000000 wei); // 20GWei\r\n    }\r\n\r\n    // modifiers for restricting access to methods\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier duringBetting {\r\n        require(chronus.betting_open);\r\n        _;\r\n    }\r\n    \r\n    modifier beforeBetting {\r\n        require(!chronus.betting_open && !chronus.race_start);\r\n        _;\r\n    }\r\n\r\n    modifier afterRace {\r\n        require(chronus.race_end);\r\n        _;\r\n    }\r\n\r\n    // ======== Bettor interface ===============================================================================================\r\n\r\n    // place a bet\r\n    function place_bet(uint8 dog) external duringBetting payable  {\r\n        require(msg.value >= min_bet && msg.value <= max_bet && dog < dogs_count);\r\n\r\n        bet_info memory current_bet;\r\n\r\n        // Update bettors info\r\n        current_bet.amount = msg.value;\r\n        current_bet.dog = dog;\r\n        bettors[msg.sender].bets.push(current_bet);\r\n        bettors[msg.sender].bets_total = bettors[msg.sender].bets_total.add(msg.value);\r\n\r\n        // Update pools info\r\n        pools[dog].bets_total = pools[dog].bets_total.add(msg.value);\r\n\r\n        bets_total = bets_total.add(msg.value);\r\n\r\n        Bet(msg.sender, msg.value, dog);\r\n    }\r\n\r\n    // fallback method for accepting payments\r\n    function () private payable {}\r\n\r\n    // method to check the reward amount\r\n    function check_reward() afterRace external constant returns (uint) {\r\n        return bettor_reward(msg.sender);\r\n    }\r\n\r\n    // method to claim the reward\r\n    function claim_reward() afterRace external {\r\n        require(!bettors[msg.sender].rewarded);\r\n        \r\n        uint reward = bettor_reward(msg.sender);\r\n        require(reward > 0 && this.balance >= reward);\r\n        \r\n        bettors[msg.sender].rewarded = true;\r\n        msg.sender.transfer(reward);\r\n\r\n        Reward(msg.sender, reward);\r\n    }\r\n\r\n    // ============================================================================================================================\r\n\r\n    //oraclize callback method\r\n    function __callback(bytes32 myid, string result) public {\r\n        require (msg.sender == oraclizeLib.oraclize_cbAddress());\r\n\r\n        chronus.race_start = true;\r\n        chronus.betting_open = false;\r\n        uint dog_index = oraclize_query_ids[myid];\r\n        require(dog_index > 0);                 // Check if the query id is known\r\n        dog_index--;\r\n        oraclize_query_ids[myid] = 0;                // Prevent duplicate callbacks\r\n\r\n        if (!pools[dog_index].post_check) {\r\n            pools[dog_index].pre = oraclizeLib.parseInt(result, 3); // from Oraclize\r\n            pools[dog_index].post_check = true;        // next check for the coin will be ending price check\r\n\r\n            PriceTicker(dog_index, pools[dog_index].pre);\r\n        } else {\r\n            pools[dog_index].post = oraclizeLib.parseInt(result, 3); // from Oraclize\r\n            // calculating the difference in price with a precision of 5 digits\r\n            pools[dog_index].delta = int(pools[dog_index].post - pools[dog_index].pre) * 10000 / int(pools[dog_index].pre);\r\n            if (max_delta < pools[dog_index].delta) {\r\n                max_delta = pools[dog_index].delta;\r\n            }\r\n            \r\n            PriceTicker(dog_index, pools[dog_index].post);\r\n            \r\n            prices_remaining--;                    // How many end prices are to be received\r\n            if (prices_remaining == 0) {           // If all end prices have been received, then process rewards\r\n                end_race();\r\n            }\r\n        }\r\n    }\r\n\r\n    // calculate bettor's reward\r\n    function bettor_reward(address candidate) internal afterRace constant returns(uint reward) {\r\n        bettor_info storage bettor = bettors[candidate];\r\n\r\n        if (chronus.race_voided) {\r\n            reward = bettor.bets_total;\r\n        } else {\r\n            if (reward_total == 0) {\r\n                return 0;\r\n            }\r\n            uint winning_bets = 0;\r\n            for (uint i = 0; i < bettor.bets.length; i++) {\r\n                if (pools[bettor.bets[i].dog].winner) {\r\n                    winning_bets = winning_bets.add(bettor.bets[i].amount);\r\n                }\r\n            }\r\n            reward = reward_total.mul(winning_bets).div(winning_bets_total);\r\n        }\r\n    }\r\n\r\n    // ============= DApp interface ==============================================================================================\r\n\r\n    // exposing pool details for DApp\r\n    function get_pool(uint dog) external constant returns (uint, uint, uint, int, bool, bool) {\r\n        return (pools[dog].bets_total, pools[dog].pre, pools[dog].post, pools[dog].delta, pools[dog].post_check, pools[dog].winner);\r\n    }\r\n\r\n    // exposing chronus for DApp\r\n    function get_chronus() external constant returns (bool, bool, bool, bool, uint, uint, uint) {\r\n        return (chronus.betting_open, chronus.race_start, chronus.race_end, chronus.race_voided, chronus.starting_time, chronus.betting_duration, chronus.race_duration);\r\n    }\r\n\r\n    // exposing bettor info for DApp\r\n    function get_bettor_nfo() external constant returns (uint, uint, bool) {\r\n        bettor_info info = bettors[msg.sender];\r\n        return (info.bets_total, info.bets.length, info.rewarded);\r\n    }\r\n\r\n    // exposing bets info for DApp\r\n    function get_bet_nfo(uint bet_num) external constant returns (uint, uint) {\r\n        bettor_info info = bettors[msg.sender];\r\n        bet_info b_info = info.bets[bet_num];\r\n        return (b_info.dog, b_info.amount);\r\n    }\r\n\r\n    // =========== race lifecycle management functions ================================================================================\r\n\r\n    // place the oraclize queries and open betting\r\n    function setup_race(uint betting_period, uint racing_period) public onlyOwner beforeBetting payable returns(bool) {\r\n        // We have to send 2 queries for each dog; check if we have enough ether for this\r\n        require (oraclizeLib.oraclize_getPrice(\"URL\", 500000) * 2 * dogs_count < this.balance);\r\n\r\n        chronus.starting_time = block.timestamp;\r\n        chronus.betting_open = true;\r\n        \r\n        uint delay = betting_period.add(60); //slack time 1 minute\r\n        chronus.betting_duration = delay;\r\n\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/bitcoin/).0.price_usd\", 500000)] = 1;\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/ethereum/).0.price_usd\", 500000)] = 2;\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/litecoin/).0.price_usd\", 500000)] = 3;\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/bitcoin-cash/).0.price_usd\", 500000)] = 4;\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/ripple/).0.price_usd\", 500000)] = 5;\r\n\r\n        delay = delay.add(racing_period);\r\n\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/bitcoin/).0.price_usd\", 500000)] = 1;\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/ethereum/).0.price_usd\", 500000)] = 2;\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/litecoin/).0.price_usd\", 500000)] = 3;\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/bitcoin-cash/).0.price_usd\", 500000)] = 4;\r\n        oraclize_query_ids[oraclizeLib.oraclize_query(delay, \"URL\", \"json(https://api.coinmarketcap.com/v1/ticker/ripple/).0.price_usd\", 500000)] = 5;\r\n\r\n        OraclizeQuery(\"Oraclize queries were sent\");\r\n        \r\n        chronus.race_duration = delay;\r\n\r\n        return true;\r\n    }\r\n\r\n    // end race and transfer house fee (called internally by callback)\r\n    function end_race() internal {\r\n\r\n        chronus.race_end = true;\r\n\r\n        // calculate winning pool(s) and their total amount\r\n        for (uint dog = 0; dog < dogs_count; dog++) {\r\n            if (pools[dog].delta == max_delta) {\r\n                pools[dog].winner = true;\r\n                winning_bets_total = winning_bets_total.add(pools[dog].bets_total);\r\n            }\r\n        }\r\n\r\n        // calculate house fee and transfer it to contract owner\r\n        uint house_fee;\r\n\r\n        if (winning_bets_total == 0) {              // No winners => house takes all the money\r\n            reward_total = 0;\r\n            house_fee = this.balance;\r\n        } else {\r\n            if (winning_bets_total == bets_total) {     // All the bettors are winners => void the race => no house fee; everyone gets their bets back\r\n                chronus.race_voided = true;\r\n                house_fee = 0;\r\n            } else {\r\n                house_fee = bets_total.mul(house_fee_pct).div(100);         // calculate house fee as % of total bets\r\n            }\r\n            reward_total = bets_total.sub(house_fee);                       // subtract house_fee from total reward\r\n            house_fee = this.balance.sub(reward_total);                    // this.balance will also include remains of kickcstart ether\r\n        }\r\n\r\n        HouseFee(house_fee);\r\n        owner.transfer(house_fee);\r\n    }\r\n\r\n    // in case of any errors in race, enable full refund for the bettors to claim\r\n    function void_race() external onlyOwner {\r\n        require(now > chronus.starting_time + chronus.race_duration);\r\n        require((chronus.betting_open && !chronus.race_start)\r\n            || (chronus.race_start && !chronus.race_end));\r\n        chronus.betting_open = false;\r\n        chronus.race_voided = true;\r\n        chronus.race_end = true;\r\n    }\r\n\r\n    // method to retrieve unclaimed winnings after claim period has ended\r\n    function recover_unclaimed_bets() external onlyOwner {\r\n        require(now > chronus.starting_time + chronus.race_duration + claim_period);\r\n        require(chronus.race_end);\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    // selfdestruct (returns balance to the owner)\r\n    function kill() external onlyOwner {\r\n        selfdestruct(msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"claim_reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dog\",\"type\":\"uint256\"}],\"name\":\"get_pool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recover_unclaimed_bets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dog\",\"type\":\"uint8\"}],\"name\":\"place_bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"max_bet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"check_reward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bet_num\",\"type\":\"uint256\"}],\"name\":\"get_bet_nfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_bettor_nfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claim_period\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"void_race\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reward_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_chronus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betting_period\",\"type\":\"uint256\"},{\"name\":\"racing_period\",\"type\":\"uint256\"}],\"name\":\"setup_race\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_bet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"house_fee_pct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winning_bets_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bets_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"OraclizeQuery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dog\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceTicker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dog\",\"type\":\"uint256\"}],\"name\":\"Bet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"HouseFee\",\"type\":\"event\"}]","ContractName":"DogRace","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"oraclizeLib:a97462de213aa4e1b24350aa62a3cc6aa5484cda","SwarmSource":"bzzr://5b9322a9dc9227ab14314a78f3eb06195c93687ad80368c7622f1c1b388ebb42"}]}