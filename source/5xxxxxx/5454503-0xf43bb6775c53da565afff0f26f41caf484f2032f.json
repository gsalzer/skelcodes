{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancy_lock);\r\n    reentrancy_lock = true;\r\n    _;\r\n    reentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * EtherButton\r\n *\r\n * A game of financial hot potato. Players pay to click EtherButton.\r\n * Each player is given 105% of their payment by each subsequent player.\r\n * A seven hour timer resets after every click. The round advances once the timer reaches zero.\r\n * \r\n * Bonus:\r\n *  For every player payout, an additional 1% is stored as an end-of-round bonus.\r\n *  Each player is entitled to their bonus if they click EtherButton during the *next* round.\r\n *  0.500 ETH is given to the last player of every round and their bonus is unlocked immediately.\r\n *  Unclaimed bonuses are rolled into future rounds.\r\n **/\r\ncontract EtherButton is Ownable, ReentrancyGuard {\r\n  // Use basic math operators which have integer overflow protection built into them.\r\n  // Simplifies code greatly by reducing the need to constantly check inputs for overflow.\r\n  using SafeMath for uint;\r\n\r\n  // Best practices say to prefix events with Log to avoid confusion.\r\n  // https://consensys.github.io/smart-contract-best-practices/recommendations/#differentiate-functions-and-events\r\n  event LogClick(\r\n    uint _id,\r\n    uint _price,\r\n    uint _previousPrice,\r\n    uint _endTime,\r\n    uint _clickCount,\r\n    uint _totalBonus,\r\n    address _activePlayer,\r\n    uint _activePlayerClickCount,\r\n    uint _previousRoundTotalBonus\r\n  );\r\n  event LogClaimBonus(address _recipient, uint _bonus);\r\n  event LogPlayerPayout(address _recipient, uint _amount);\r\n  event LogSendPaymentFailure(address _recipient, uint _amount);\r\n\r\n  // Represent fractions as numerator/denominator because Solidity doesn't support decimals.\r\n  // It's okay to use \".5 ether\" because it converts to \"500000000000000000 wei\"\r\n  uint public constant INITIAL_PRICE = .5 ether;\r\n  uint public constant ROUND_DURATION = 7 hours;\r\n  // 5% price increase is allocated to the player.\r\n  uint private constant PLAYER_PROFIT_NUMERATOR = 5;\r\n  uint private constant PLAYER_PROFIT_DENOMINATOR = 100;\r\n  // 1% price increase is allocated to player bonuses.\r\n  uint private constant BONUS_NUMERATOR = 1;\r\n  uint private constant BONUS_DENOMINATOR = 100; \r\n  // 2.5% price increase is allocated to the owner.\r\n  uint private constant OWNER_FEE_NUMERATOR = 25;\r\n  uint private constant OWNER_FEE_DENOMINATOR = 1000;\r\n\r\n  // EtherButton is comprised of many rounds. Each round contains\r\n  // an isolated instance of game state.\r\n  struct Round {\r\n    uint id;\r\n    uint price;\r\n    uint previousPrice;\r\n    uint endTime;\r\n    uint clickCount;\r\n    uint totalBonus;\r\n    uint claimedBonus;\r\n    address activePlayer;\r\n    mapping (address => uint) playerClickCounts;\r\n    mapping (address => bool) bonusClaimedList;\r\n  }\r\n\r\n  // A list of all the rounds which have been played as well as\r\n  // the id of the current (active) round.\r\n  mapping (uint => Round) public Rounds;\r\n  uint public RoundId;\r\n\r\n  /**\r\n   * Create the contract with an initial 'Round 0'. This round has already expired which will cause the first\r\n   * player interaction to start Round 1. This is simpler than introducing athe concept of a 'paused' round.\r\n  **/\r\n  function EtherButton() public {\r\n    initializeRound();\r\n    Rounds[RoundId].endTime = now.sub(1);\r\n  }\r\n\r\n  /**\r\n   * Performs a single 'click' of EtherButton.\r\n   *\r\n   * Advances the round if the previous round's endTime has passed. This needs to be done\r\n   * just-in-time because code isn't able to execute on a timer - it needs funding.\r\n   *\r\n   * Refunds the player any extra money they may have sent. Pays the last player and the owner.\r\n   * Marks the player as the active player so that they're next to be paid.\r\n   *\r\n   * Emits an event showing the current state of EtherButton and returns the state, too.\r\n  **/\r\n  function click() nonReentrant external payable {\r\n    // Owner is not allowed to play.\r\n    require(msg.sender != owner);\r\n\r\n    // There's no way to advance the round exactly at a specific time because the contract only runs\r\n    // when value is sent to it. So, round advancement must be done just-in-time whenever a player pays to click.\r\n    // Only advance the round when a player clicks because the next round's timer will begin immediately.\r\n    if (getIsRoundOver(RoundId)) {\r\n      advanceRound(); \r\n    }\r\n\r\n    Round storage round = Rounds[RoundId];\r\n\r\n    // Safe-guard against spam clicks from a single player.\r\n    require(msg.sender != round.activePlayer);\r\n    // Safe-guard against underpayment.\r\n    require(msg.value >= round.price);\r\n\r\n    // Refund player extra value beyond price. If EtherButton is very popular then its price may\r\n    // attempt to increase multiple times in a single block. In this situation, the first attempt\r\n    // would be successful, but subsequent attempts would fail due to insufficient funding. \r\n    // To combat this issue, a player may send more value than necessary to\r\n    // increase the chance of the price being payable with the amount of value they sent.\r\n    if (msg.value > round.price) {\r\n      sendPayment(msg.sender, msg.value.sub(round.price));\r\n    }\r\n\r\n    // Pay the active player and owner for each click past the first.\r\n    if (round.activePlayer != address(0)) {\r\n      // Pay the player first because that seems respectful.\r\n      // Log the player payouts to show on the website.\r\n      uint playerPayout = getPlayerPayout(round.previousPrice);\r\n      sendPayment(round.activePlayer, playerPayout);\r\n      LogPlayerPayout(round.activePlayer, playerPayout);\r\n\r\n      // Pay the contract owner as fee for game creation. Thank you! <3\r\n      sendPayment(owner, getOwnerFee(round.previousPrice));\r\n\r\n      // Keep track of bonuses collected at same time as sending payouts to ensure financial consistency.\r\n      round.totalBonus = round.totalBonus.add(getBonusFee(round.previousPrice));\r\n    }\r\n\r\n    // Update round state to reflect the additional click\r\n    round.activePlayer = msg.sender;\r\n    round.playerClickCounts[msg.sender] = round.playerClickCounts[msg.sender].add(1);\r\n    round.clickCount = round.clickCount.add(1);\r\n    round.previousPrice = round.price;\r\n    // Increment the price by 8.50%\r\n    round.price = getNextPrice(round.price);\r\n    // Reset the round timer\r\n    round.endTime = now.add(ROUND_DURATION);\r\n    \r\n    // Log an event with relevant information from the round's state.\r\n    LogClick(\r\n      round.id,\r\n      round.price,\r\n      round.previousPrice,\r\n      round.endTime,\r\n      round.clickCount,\r\n      round.totalBonus,\r\n      msg.sender,\r\n      round.playerClickCounts[msg.sender],\r\n      Rounds[RoundId.sub(1)].totalBonus\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Provides bonus payments to players who wish to claim them.\r\n   * Bonuses accrue over the course of a round for those playing in the round.\r\n   * Bonuses may be claimed once the next round starts, but will remain locked until\r\n   * players participate in that round. The last active player of the previous round\r\n   * has their bonus unlocked immediately without need to play in the next round.\r\n   **/\r\n  function claimBonus() nonReentrant external {\r\n    // NOTE: The only way to advance the round is to run the 'click' method. When a round is over, it will have expired,\r\n    // but RoundId will not have (yet) incremented. So, claimBonus needs to check the previous round. This allows EtherButton\r\n    // to never enter a 'paused' state, which is less code (aka more reliable) but it does have some edge cases.\r\n    uint roundId = getIsRoundOver(RoundId) ? RoundId.add(1) : RoundId;\r\n    uint previousRoundId = roundId.sub(1);\r\n    bool isBonusClaimed = getIsBonusClaimed(previousRoundId, msg.sender);\r\n\r\n    // If player has already claimed their bonus exit early to keep code simple and cheap to run.\r\n    if (isBonusClaimed) {\r\n      return;\r\n    }\r\n\r\n    // If a player can't claim their bonus because they haven't played during the current round\r\n    // and they were not the last player in the previous round then exit as they're not authorized.\r\n    bool isBonusUnlockExempt = getIsBonusUnlockExempt(previousRoundId, msg.sender);\r\n    bool isBonusUnlocked = getPlayerClickCount(roundId, msg.sender) > 0;\r\n    if (!isBonusUnlockExempt && !isBonusUnlocked) {\r\n      return;\r\n    }\r\n\r\n    // If player is owed money from participation in previous round - send it.\r\n    Round storage previousRound = Rounds[previousRoundId];\r\n    uint playerClickCount = previousRound.playerClickCounts[msg.sender];\r\n    uint roundClickCount = previousRound.clickCount;\r\n    // NOTE: Be sure to multiply first to avoid decimal precision math.\r\n    uint bonus = previousRound.totalBonus.mul(playerClickCount).div(roundClickCount);\r\n\r\n    // If the current player is owed a refund from previous round fulfill that now.\r\n    // This is better than forcing the player to make a separate requests for\r\n    // bonuses and refund payouts.\r\n    if (previousRound.activePlayer == msg.sender) {\r\n      bonus = bonus.add(INITIAL_PRICE);\r\n    }\r\n\r\n    previousRound.bonusClaimedList[msg.sender] = true;\r\n    previousRound.claimedBonus = previousRound.claimedBonus.add(bonus);\r\n    sendPayment(msg.sender, bonus);\r\n\r\n    // Let the EtherButton website know a bonus was claimed successfully so it may update.\r\n    LogClaimBonus(msg.sender, bonus);\r\n  }\r\n\r\n  /**\r\n   * Returns true once the given player has claimed their bonus for the given round.\r\n   * Bonuses are only able to be claimed once per round per player.\r\n   **/\r\n  function getIsBonusClaimed(uint roundId, address player) public view returns (bool) {\r\n    return Rounds[roundId].bonusClaimedList[player];\r\n  }\r\n\r\n  /**\r\n   * Returns the number of times the given player has clicked EtherButton during the given round.\r\n   **/\r\n  function getPlayerClickCount(uint roundId, address player) public view returns (uint) {\r\n    return Rounds[roundId].playerClickCounts[player];\r\n  }\r\n\r\n  /**\r\n   * Returns true if the given player does not need to be unlocked to claim their bonus.\r\n   * This is true when they were the last player to click EtherButton in the previous round.\r\n   * That player deserves freebies for losing. So, they get their bonus unlocked early.\r\n   **/\r\n  function getIsBonusUnlockExempt(uint roundId, address player) public view returns (bool) {\r\n    return Rounds[roundId].activePlayer == player;\r\n  }\r\n\r\n  /**\r\n   * Returns true if enough time has elapsed since the active player clicked the\r\n   * button to consider the given round complete.\r\n   **/\r\n  function getIsRoundOver(uint roundId) private view returns (bool) {\r\n    return now > Rounds[roundId].endTime;\r\n  }\r\n\r\n  /**\r\n   * Signal the completion of a round and the start of the next by moving RoundId forward one.\r\n   * As clean-up before the round change occurs, join all unclaimed player bonuses together and move them\r\n   * forward one round. Just-in-time initialize the next round's state once RoundId is pointing to it because\r\n   * an unknown number of rounds may be played. So, it's impossible to initialize all rounds at contract creation.\r\n   **/\r\n  function advanceRound() private {\r\n    if (RoundId > 1) {\r\n      // Take all of the previous rounds unclaimed bonuses and roll them forward.\r\n      Round storage previousRound = Rounds[RoundId.sub(1)];      \r\n      // If the active player of the previous round didn't claim their refund then they lose the ability to claim it.\r\n      // Their refund is also rolled into the bonuses for the next round.\r\n      uint remainingBonus = previousRound.totalBonus.add(INITIAL_PRICE).sub(previousRound.claimedBonus);\r\n      Rounds[RoundId].totalBonus = Rounds[RoundId].totalBonus.add(remainingBonus);\r\n    }\r\n\r\n    RoundId = RoundId.add(1);\r\n    initializeRound();\r\n  }\r\n\r\n  /**\r\n   * Sets the current round's default values. Initialize the price to 0.500 ETH,\r\n   * the endTime to 7 hours past the current time and sets the round id. The round is\r\n   * also started as the endTime is now ticking down.\r\n   **/\r\n  function initializeRound() private {\r\n    Rounds[RoundId].id = RoundId;\r\n    Rounds[RoundId].endTime = block.timestamp.add(ROUND_DURATION);\r\n    Rounds[RoundId].price = INITIAL_PRICE;\r\n  }\r\n\r\n  /**\r\n   * Sends an amount of Ether to the recipient. Returns true if it was successful.\r\n   * Logs payment failures to provide documentation on attacks against the contract.\r\n   **/\r\n  function sendPayment(address recipient, uint amount) private returns (bool) {\r\n    assert(recipient != address(0));\r\n    assert(amount > 0);\r\n\r\n    // It's considered good practice to require users to pull payments rather than pushing\r\n    // payments to them. Since EtherButton pays the previous player immediately, it has to mitigate\r\n    // a denial-of-service attack. A malicious contract might always reject money which is sent to it.\r\n    // This contract could be used to disrupt EtherButton if an assumption is made that money will\r\n    // always be sent successfully.\r\n    // https://github.com/ConsenSys/smart-contract-best-practices/blob/master/docs/recommendations.md#favor-pull-over-push-for-external-calls\r\n    // Intentionally not using recipient.transfer to prevent this DOS attack vector.\r\n    bool result = recipient.send(amount);\r\n\r\n    // NOTE: Initially, this was written to allow users to reclaim funds on failure.\r\n    // This was removed due to concerns of allowing attackers to retrieve their funds. It is\r\n    // not possible for a regular wallet to reject a payment.\r\n    if (!result) {\r\n      // Log the failure so attempts to compromise the contract are documented.\r\n      LogSendPaymentFailure(recipient, amount);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n    Returns the next price to click EtherButton. The returned value should be \r\n    8.50% larger than the current price:\r\n      - 5.00% is paid to the player.\r\n      - 1.00% is paid as bonuses.\r\n      - 2.50% is paid to the owner.\r\n   **/\r\n  function getNextPrice(uint price) private pure returns (uint) {\r\n    uint playerFee = getPlayerFee(price);\r\n    assert(playerFee > 0);\r\n\r\n    uint bonusFee = getBonusFee(price);\r\n    assert(bonusFee > 0);\r\n\r\n    uint ownerFee = getOwnerFee(price);\r\n    assert(ownerFee > 0);\r\n\r\n    return price.add(playerFee).add(bonusFee).add(ownerFee);\r\n  }\r\n\r\n  /**\r\n   * Returns 1.00% of the given price. Be sure to multiply before dividing to avoid decimals.\r\n   **/\r\n  function getBonusFee(uint price) private pure returns (uint) {\r\n    return price.mul(BONUS_NUMERATOR).div(BONUS_DENOMINATOR);\r\n  }\r\n\r\n  /**\r\n   * Returns 2.50% of the given price. Be sure to multiply before dividing to avoid decimals.\r\n   **/\r\n  function getOwnerFee(uint price) private pure returns (uint) {\r\n    return price.mul(OWNER_FEE_NUMERATOR).div(OWNER_FEE_DENOMINATOR);\r\n  }\r\n\r\n  /**\r\n   * Returns 5.00% of the given price. Be sure to multiply before dividing to avoid decimals.\r\n   **/\r\n  function getPlayerFee(uint price) private pure returns (uint) {\r\n    return price.mul(PLAYER_PROFIT_NUMERATOR).div(PLAYER_PROFIT_DENOMINATOR);\r\n  }\r\n\r\n  /**\r\n   * Returns the total amount of Ether the active player will receive. This is\r\n   * 105.00% of their initial price paid.\r\n   **/\r\n  function getPlayerPayout(uint price) private pure returns (uint) {\r\n    return price.add(getPlayerFee(price));\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerClickCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROUND_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getIsBonusClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getIsBonusUnlockExempt\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"click\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Rounds\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"previousPrice\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"clickCount\",\"type\":\"uint256\"},{\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"name\":\"claimedBonus\",\"type\":\"uint256\"},{\"name\":\"activePlayer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_previousPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_clickCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_activePlayer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_activePlayerClickCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_previousRoundTotalBonus\",\"type\":\"uint256\"}],\"name\":\"LogClick\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"LogClaimBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LogPlayerPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LogSendPaymentFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EtherButton","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://225277642a030ef30ecff46e19aead1d4e032783677f601128538471013012b9"}]}