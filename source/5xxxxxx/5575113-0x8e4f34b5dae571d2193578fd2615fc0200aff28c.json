{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/************************************************************************\r\n*********************** COMPTROLLER *************************************\r\n*************************************************************************\r\n\r\n   The Comptroller creates the DividendToken and DividendTokenLocker,\r\n   runs the CrowdSale, and can raise capital for Treasury.\r\n\r\n\r\nTHE CROWDSALE\r\n------------------------------------------------------------------------\r\n\r\n  The owner can configure the CrowdSale via .initSale().\r\n  Owner is allowed to change the terms of the CrowdSale at any time,\r\n  as long as it hasn't started yet. Configurable parameters are:\r\n    - dateSaleStarted: when the sale will start\r\n    - daleSaleEnded: when the sale will end\r\n    - softCap: amount required for the sale to be considered successful\r\n    - hardCap: maximum amount to be raised\r\n    - bonusCap: how many Ether the bonus period extends to\r\n    - capital: how many Ether to send to Treasury as capital\r\n\r\n  The CrowdSale is started as soon as one user buys tokens, and ends\r\n  if the hardCap is met, or dateSaleEnded is reached. The CrowdSale\r\n  will be considered \"successful\" if the SoftCap is reached. The \r\n  exchange rate is 1 Ether = 1 Token, plus a bonus amount that \r\n  starts at 50% for the 1st Ether, sliding down to 0% at `bonusCap`.\r\n\r\n  Upon a successful CrowdSale:\r\n    - Tokens are unfronzen\r\n    - Owner wallet gets 20% of tokens, which will vest for 600 days.\r\n    - `capitalPct` of raised funds go to Treasury\r\n    - the remaning Ether is sent to the owner wallet\r\n\r\n  Upon an unsuccessful CrowdSale:\r\n    - Tokens remain frozen\r\n    - Investors can call .getRefund() for a full refund\r\n    - Owner gets minted a ton of tokens (to maintain ~100% ownership)\r\n\r\nRAISING CAPITAL\r\n------------------------------------------------------------------------\r\n\r\n  The Treasury has a method called .capitalNeeded(). This value is \r\n  changable by Admin, via a governance described in Treasury. When this\r\n  value is > 0, Comptroller will accept Ether in exchange for tokens at\r\n  a rate of 1 Ether per Token, until Treasury.capitalNeeded() is zero.\r\n\r\n  For each Ether raised, a token is minted, and the Ether is sent to\r\n  the Treasury as Capital.\r\n\r\n\r\nPERMISSIONS\r\n------------------------------------------------------------------------\r\n\r\n  Comptroller owns the Token, and is only address that can call:\r\n    - token.mint(address, amount)\r\n        - Initially mints 1 token for the owner\r\n        - During CrowdSale\r\n        - When raising capital for Treasury\r\n    - token.burn(address, amount)\r\n        - never called\r\n\r\n  The following addresses have permission on Comptroller:\r\n    - Owner Wallet (permanent):\r\n        - Can set CrowdSale parameters, if it hasn't started yet.\r\n    - Anybody:\r\n        - During CrowdSale:\r\n            .fund(): Send Ether, get Tokens. Refunds on failure.\r\n            .endSale(): End the sales, provided conditions are met.\r\n        - After unsuccessful Crowdsale:\r\n            .refund(): Receive a full refund of amount sent to .fund()\r\n        - If Treasury.capitalNeeded() > 0\r\n            .fundCapital(): Send Ether, get Tokens. Refunds on failure.\r\n\r\nCONCLUSION\r\n------------------------------------------------------------------------\r\n\r\n  The above description covers the entirety of this contract. There are\r\n  no emergency features or emergency stop gaps in the contract. All\r\n  addresses in this contract (wallet, treasury, token, locker) are \r\n  unchangable. If you find behavior in this contract that is incorrect,\r\n  do the right thing and let us know. Enjoy.\r\n\r\n  A full suite of tests can be found here:\r\n\r\n\r\n  And, ideally, this contract will have been audited by third parties.\r\n\r\n*************************************************************************/\r\n\r\n// This is the interface to the Treasury.\r\ninterface _ICompTreasury {\r\n    // after CrowdSale, will add funds to bankroll.\r\n    function addCapital() external payable;\r\n    // used to determine if Treasury wants to raise capital.\r\n    function capitalNeeded() external view returns (uint);\r\n}\r\ncontract Comptroller {\r\n    // These values are set in the constructor and can never be changed.\r\n    address public wallet;              // Wallet can call .initSale().\r\n    _ICompTreasury public treasury;     // Location of the treasury.\r\n    DividendToken public token;         // Token contract\r\n    DividendTokenLocker public locker;  // Locker that holds PennyEther's tokens.\r\n\r\n    // These values are set on .initSale()\r\n    uint public dateSaleStarted;    // date sale begins\r\n    uint public dateSaleEnded;      // date sale is endable\r\n    uint public softCap;            // sale considered successfull if amt met\r\n    uint public hardCap;            // will not raise more than this\r\n    uint public bonusCap;           // amt at which bonus ends\r\n    uint public capitalPctBips;     // amt to send to Treasury as capital (100 = 1%)\r\n\r\n    // CrowdSale Variables\r\n    uint public totalRaised;\r\n    bool public wasSaleStarted;             // True if sale was started\r\n    bool public wasSaleEnded;               // True if sale was ended\r\n    bool public wasSoftCapMet;              // True if softCap was met\r\n    // Stores amtFunded for useres contributing before softCap is met\r\n    mapping (address => uint) public amtFunded; \r\n\r\n    event Created(uint time, address wallet, address treasury, address token, address locker);\r\n    // CrowdSale Meta Events\r\n    event SaleInitalized(uint time);        // emitted when wallet calls .initSale()\r\n    event SaleStarted(uint time);           // emitted upon first tokens bought\r\n    event SaleSuccessful(uint time);        // emitted when sale ends (may happen early)\r\n    event SaleFailed(uint time);            // emitted if softCap not reached\r\n    // CrowdSale purchase\r\n    event BuyTokensSuccess(uint time, address indexed account, uint funded, uint numTokens);\r\n    event BuyTokensFailure(uint time, address indexed account, string reason);\r\n    // If user sends too much, or if .refund() called\r\n    event UserRefunded(uint time, address indexed account, uint refund);\r\n\r\n    constructor(address _wallet, address _treasury)\r\n        public\r\n    {\r\n        wallet = _wallet;\r\n        treasury = _ICompTreasury(_treasury);\r\n        token = new DividendToken(\"PennyEtherToken\", \"PENNY\");\r\n        locker = new DividendTokenLocker(token, _wallet);\r\n        token.freeze(true);\r\n        emit Created(now, wallet, treasury, token, locker);\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** WALLET (OWNER) FUNCTIONS *************************/\r\n    /*************************************************************/\r\n\r\n    // Sets parameters of the CrowdSale\r\n    // Cannot be called once the crowdsale has started.\r\n    function initSale(uint _dateStarted, uint _dateEnded, uint _softCap, uint _hardCap, uint _bonusCap, uint _capitalPctBips)\r\n        public\r\n    {\r\n        require(msg.sender == wallet);\r\n        require(!wasSaleStarted);\r\n        require(_softCap <= _hardCap);\r\n        require(_bonusCap <= _hardCap);\r\n        require(_capitalPctBips <= 10000);\r\n        dateSaleStarted = _dateStarted;\r\n        dateSaleEnded = _dateEnded;\r\n        softCap = _softCap;\r\n        hardCap = _hardCap;\r\n        bonusCap = _bonusCap;\r\n        capitalPctBips = _capitalPctBips;\r\n        emit SaleInitalized(now);\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** DURING CROWDSALE *********************************/\r\n    /*************************************************************/\r\n\r\n    function () public payable {\r\n        fund();\r\n    }\r\n\r\n    // Allows the sender to buy tokens.\r\n    //\r\n    // Refunds if:\r\n    //  - CrowdSale start not defined, or time is before it.\r\n    //  - CrowdSale end date reached.\r\n    //  - CrowdSale HardCap has been met.\r\n    //  - Non-even amount of GWei sent.\r\n    //\r\n    // Otherwise:\r\n    //  - Starts sale (if it's not already started)\r\n    //  - Issues tokens to user (takes into account bonus period)\r\n    //  - If SoftCap not yet met, records amtFunded (so can refund)\r\n    //  - Refunds any excess amount sent (if HardCap was just met)\r\n    function fund()\r\n        public\r\n        payable\r\n    {\r\n        if (dateSaleStarted==0 || now < dateSaleStarted)\r\n            return _errorBuyingTokens(\"CrowdSale has not yet started.\");\r\n        if (now > dateSaleEnded)\r\n            return _errorBuyingTokens(\"CrowdSale has ended.\");\r\n        if (totalRaised >= hardCap)\r\n            return _errorBuyingTokens(\"HardCap has been reached.\");\r\n        if (msg.value % 1000000000 != 0)\r\n            return _errorBuyingTokens(\"Must send an even amount of GWei.\");\r\n\r\n        // Mark sale as started if haven't done so already.\r\n        if (!wasSaleStarted) {\r\n            wasSaleStarted = true;\r\n            emit SaleStarted(now);\r\n        }\r\n\r\n        // Only allow up to (hardCap - totalRaised) to be raised.\r\n        uint _amtToFund = (totalRaised + msg.value) > hardCap\r\n            ? hardCap - totalRaised\r\n            : msg.value;\r\n\r\n        // Mint the tokens for the user, increment totalRaised\r\n        uint _numTokens = getTokensFromEth(_amtToFund);\r\n        token.mint(msg.sender, _numTokens);\r\n        totalRaised += _amtToFund;\r\n        emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens);\r\n\r\n        // Increment the amount they funded, if softCap not met.\r\n        if (totalRaised < softCap) {\r\n            amtFunded[msg.sender] += _amtToFund;\r\n        }\r\n\r\n        // Refund the user any amount sent over _amtToFund\r\n        uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0;\r\n        if (_refund > 0){\r\n            require(msg.sender.call.value(_refund)());\r\n            emit UserRefunded(now, msg.sender, _refund);\r\n        }\r\n    }\r\n        \r\n    // Ends the CrowdSale. Callable by anyone.\r\n    //\r\n    // Throws if:\r\n    //   - Sale is not started, or sale is already ended.\r\n    //   - HardCap not met and sale end date not reached.\r\n    //\r\n    // If SoftCap met:\r\n    //   - Unfreezes tokens.\r\n    //   - Gives owners 20% in TokenLocker, vesting 600 days.\r\n    //   - Sends `capitalPctBip` to Treasury, as capital raised.\r\n    //   - Sends remaining funds to Owner Wallet\r\n    //\r\n    // If SoftCap not met:\r\n    //   - Mints a ton of tokens for owner (to maintain 100% ownership)\r\n    //   - Funders will be able to call .refund()\r\n    function endSale()\r\n        public\r\n    {\r\n        // Require sale has been started but not yet ended.\r\n        require(wasSaleStarted && !wasSaleEnded);\r\n        // Require hardCap met, or date is after sale ended.\r\n        require(totalRaised >= hardCap || now > dateSaleEnded);\r\n        \r\n        // Mark sale as over, and if it was successful.\r\n        wasSaleEnded = true;\r\n        wasSoftCapMet = totalRaised >= softCap;\r\n\r\n        // Softcap not met. Mint tokens so wallet owns ~100%.\r\n        if (!wasSoftCapMet) {\r\n            token.mint(wallet, 1e30);\r\n            emit SaleFailed(now);\r\n            return;\r\n        }\r\n\r\n        // Unfreeze tokens\r\n        token.freeze(false);\r\n\r\n        // Mint 1/4 to locker (resuling in 20%), and start vesting.\r\n        uint _lockerAmt = token.totalSupply() / 4;\r\n        token.mint(locker, _lockerAmt);\r\n        locker.startVesting(_lockerAmt, 600);   // vest for 600 days.\r\n\r\n        // Send up to `_capitalAmt` ETH to treasury as capital\r\n        uint _capitalAmt = (totalRaised * capitalPctBips) / 10000;\r\n        if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance;\r\n        treasury.addCapital.value(_capitalAmt)();\r\n        \r\n        // Send remaining balance to wallet\r\n        if (wallet.call.value(address(this).balance)()) {}\r\n        // Emit event once and forever\r\n        emit SaleSuccessful(now);\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** AFTER CROWDSALE **********************************/\r\n    /*************************************************************/\r\n\r\n    // If softCap was not met, allow users to get full refund.\r\n    function refund()\r\n        public\r\n    {\r\n        // Ensure softCap not met, and user funded.\r\n        require(wasSaleEnded && !wasSoftCapMet);\r\n        require(amtFunded[msg.sender] > 0);\r\n        // Send the user the amount they funded, or throw\r\n        uint _amt = amtFunded[msg.sender];\r\n        amtFunded[msg.sender] = 0;\r\n        require(msg.sender.call.value(_amt)());\r\n        emit UserRefunded(now, msg.sender, _amt);\r\n    }\r\n\r\n    // Callable any time Treasury.capitalNeeded() > 0.\r\n    //\r\n    // For each Ether received, 1 Token is minted, and the Ether is sent\r\n    //  to the Treasury as Captial.\r\n    //\r\n    // Raising capital dilutes everyone, owners included, and as such\r\n    //  would only realistically happen if the raised funds are expected\r\n    //  to generate returns. Additionally, the Ether raised only goes to\r\n    //  Treasury -- 0 goes to the owners -- so there is no incentive to\r\n    //  raise capital other than to increase dividends.\r\n    function fundCapital()\r\n        public\r\n        payable\r\n    {\r\n        if (!wasSaleEnded)\r\n            return _errorBuyingTokens(\"Sale has not ended.\");\r\n        if (!wasSoftCapMet)\r\n            return _errorBuyingTokens(\"SoftCap was not met.\");\r\n            \r\n        // Cap _amount to the amount we need. Error if 0.\r\n        uint _amtNeeded = capitalFundable();\r\n        uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value;\r\n        if (_amount == 0) {\r\n            return _errorBuyingTokens(\"No capital is needed.\");\r\n        }\r\n\r\n        // Mint tokens, send capital.\r\n        totalRaised += _amount;\r\n        token.mint(msg.sender, _amount);\r\n        treasury.addCapital.value(_amount)();\r\n        emit BuyTokensSuccess(now, msg.sender, _amount, _amount);\r\n\r\n        // Refund excess\r\n        uint _refund = msg.value > _amount ? msg.value - _amount : 0;\r\n        if (_refund > 0) {\r\n            require(msg.sender.call.value(_refund)());\r\n            emit UserRefunded(now, msg.sender, _refund);\r\n        }\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** PRIVATE ******************************************/\r\n    /*************************************************************/\r\n\r\n    // Called when user cannot buy tokens.\r\n    // Returns nice error message and saves gas.\r\n    function _errorBuyingTokens(string _reason)\r\n        private\r\n    {\r\n        require(msg.sender.call.value(msg.value)());\r\n        emit BuyTokensFailure(now, msg.sender, _reason);\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** PUBLIC VIEWS *************************************/\r\n    /*************************************************************/\r\n\r\n    // Returns the amount of Ether that can be sent to \".fundCapital()\"\r\n    function capitalFundable()\r\n        public\r\n        view\r\n        returns (uint _amt)\r\n    {\r\n        return treasury.capitalNeeded();\r\n    }\r\n\r\n    // Returns the total amount of tokens minted at a given _ethAmt raised.\r\n    // This hard codes the following:\r\n    //   - Start at 50% bonus, linear decay to 0% bonus at bonusCap.\r\n    // The math behind it is explaind in comments.\r\n    function getTokensMintedAt(uint _ethAmt)\r\n        public\r\n        view\r\n        returns (uint _numTokens)\r\n    {\r\n        if (_ethAmt > hardCap) {\r\n            // Past HardCap. Return the full bonus amount, plus the rest\r\n            _numTokens = (5*bonusCap/4) + (hardCap - bonusCap);\r\n        } else if (_ethAmt > bonusCap) {\r\n            // Past Bonus Period. Return the full bonus amount, plus the non-bonus amt.\r\n            _numTokens = (5*bonusCap/4) + (_ethAmt - bonusCap);\r\n        } else {\r\n            // In Bonus period. Use a closed form integral to compute tokens.\r\n            //\r\n            //   First make a function for tokensPerEth:\r\n            //      tokensPerEth(x) = 3/2 - x/(2c), where c is bonusCap\r\n            //      Test: with c=20000: (0, 1.5), (10000, 1.25), (20000, 1)\r\n            //   Next, create a closed form integral:\r\n            //      integral(3/2 - x/(2c), x) = 3x/2 - x^2/(4c)\r\n            //      Test: with c=20000: (0, 0), (10000, 13750), (20000, 25000)\r\n            //\r\n            // Note: if _ethAmt = bonusCap, _numTokens = (5*bonusCap)/4\r\n            // Note: Overflows if _ethAmt^2 > 2^256, or ~3e38 Eth. Bonus Cap << 3e38\r\n            _numTokens = (3*_ethAmt/2) - (_ethAmt*_ethAmt)/(4*bonusCap);\r\n        }\r\n    }\r\n\r\n    // Returns how many tokens would be issued for _ethAmt sent,\r\n    // depending on current totalRaised.\r\n    function getTokensFromEth(uint _amt)\r\n        public\r\n        view\r\n        returns (uint _numTokens)\r\n    {\r\n        return getTokensMintedAt(totalRaised + _amt) - getTokensMintedAt(totalRaised);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n  Standard ERC20 Token.\r\n  https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n*/\r\ncontract ERC20 {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint public totalSupply;\r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n\r\n    event Created(uint time);\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n    event AllowanceUsed(address indexed owner, address indexed spender, uint amount);\r\n\r\n    constructor(string _name, string _symbol)\r\n        public\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        emit Created(now);\r\n    }\r\n\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // Attempts to transfer `_value` from `_from` to `_to`\r\n    //  if `_from` has sufficient allowance for `msg.sender`.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        address _spender = msg.sender;\r\n        require(allowance[_from][_spender] >= _value);\r\n        allowance[_from][_spender] -= _value;\r\n        emit AllowanceUsed(_from, _spender, _value);\r\n        return _transfer(_from, _to, _value);\r\n    }\r\n\r\n    // Transfers balance from `_from` to `_to` if `_to` has sufficient balance.\r\n    // Called from transfer() and transferFrom().\r\n    function _transfer(address _from, address _to, uint _value)\r\n        private\r\n        returns (bool success)\r\n    {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface HasTokenFallback {\r\n    function tokenFallback(address _from, uint256 _amount, bytes _data)\r\n        external\r\n        returns (bool success);\r\n}\r\ncontract ERC667 is ERC20 {\r\n    constructor(string _name, string _symbol)\r\n        public\r\n        ERC20(_name, _symbol)\r\n    {}\r\n\r\n    function transferAndCall(address _to, uint _value, bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(super.transfer(_to, _value));\r\n        require(HasTokenFallback(_to).tokenFallback(msg.sender, _value, _data));\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\n/*********************************************************\r\n******************* DIVIDEND TOKEN ***********************\r\n**********************************************************\r\n\r\nAn ERC20 token that can accept Ether and distribute it\r\nperfectly to all Token Holders relative to each account's\r\nbalance at the time the dividend is received.\r\n\r\nThe Token is owned by the creator, and can be frozen,\r\nminted, and burned by the owner.\r\n\r\nNotes:\r\n    - Accounts can view or receive dividends owed at any time\r\n    - Dividends received are immediately credited to all\r\n      current Token Holders and can be redeemed at any time.\r\n    - Per above, upon transfers, dividends are not\r\n      transferred. They are kept by the original sender, and\r\n      not credited to the receiver.\r\n    - Uses \"pull\" instead of \"push\". Token holders must pull\r\n      their own dividends.\r\n\r\nComptroller Permissions:\r\n    - mintTokens(account, amt): via comp.fund() and comp.fundCapital()\r\n    - burnTokens(account, amt): via comp.burnTokens()\r\n    - setFrozen(true): Called before CrowdSale\r\n    - setFrozen(false): Called after CrowdSale, if softCap met\r\n*/\r\ncontract DividendToken is ERC667\r\n{\r\n    // if true, tokens cannot be transferred\r\n    bool public isFrozen;\r\n\r\n    // Comptroller can call .mintTokens() and .burnTokens().\r\n    address public comptroller = msg.sender;\r\n    modifier onlyComptroller(){ require(msg.sender==comptroller); _; }\r\n\r\n    // How dividends work:\r\n    //\r\n    // - A \"point\" is a fraction of a Wei (1e-32), it's used to reduce rounding errors.\r\n    //\r\n    // - totalPointsPerToken represents how many points each token is entitled to\r\n    //   from all the dividends ever received. Each time a new deposit is made, it\r\n    //   is incremented by the points oweable per token at the time of deposit:\r\n    //     (depositAmtInWei * POINTS_PER_WEI) / totalSupply\r\n    //\r\n    // - Each account has a `creditedPoints` and `lastPointsPerToken`\r\n    //   - lastPointsPerToken:\r\n    //       The value of totalPointsPerToken the last time `creditedPoints` was changed.\r\n    //   - creditedPoints:\r\n    //       How many points have been credited to the user. This is incremented by:\r\n    //         (`totalPointsPerToken` - `lastPointsPerToken` * balance) via\r\n    //         `.updateCreditedPoints(account)`. This occurs anytime the balance changes\r\n    //         (transfer, mint, burn).\r\n    //\r\n    // - .collectOwedDividends() calls .updateCreditedPoints(account), converts points\r\n    //   to wei and pays account, then resets creditedPoints[account] to 0.\r\n    //\r\n    // - \"Credit\" goes to Nick Johnson for the concept.\r\n    //\r\n    uint constant POINTS_PER_WEI = 1e32;\r\n    uint public dividendsTotal;\r\n    uint public dividendsCollected;\r\n    uint public totalPointsPerToken;\r\n    uint public totalBurned;\r\n    mapping (address => uint) public creditedPoints;\r\n    mapping (address => uint) public lastPointsPerToken;\r\n\r\n    // Events\r\n    event Frozen(uint time);\r\n    event UnFrozen(uint time);\r\n    event TokensMinted(uint time, address indexed account, uint amount, uint newTotalSupply);\r\n    event TokensBurned(uint time, address indexed account, uint amount, uint newTotalSupply);\r\n    event CollectedDividends(uint time, address indexed account, uint amount);\r\n    event DividendReceived(uint time, address indexed sender, uint amount);\r\n\r\n    constructor(string _name, string _symbol)\r\n        public\r\n        ERC667(_name, _symbol)\r\n    {}\r\n\r\n    // Upon receiving payment, increment lastPointsPerToken.\r\n    function ()\r\n        payable\r\n        public\r\n    {\r\n        if (msg.value == 0) return;\r\n        // POINTS_PER_WEI is 1e32.\r\n        // So, no multiplication overflow unless msg.value > 1e45 wei (1e27 ETH)\r\n        totalPointsPerToken += (msg.value * POINTS_PER_WEI) / totalSupply;\r\n        dividendsTotal += msg.value;\r\n        emit DividendReceived(now, msg.sender, msg.value);\r\n    }\r\n\r\n    /*************************************************************/\r\n    /******* COMPTROLLER FUNCTIONS *******************************/\r\n    /*************************************************************/\r\n    // Credits dividends, then mints more tokens.\r\n    function mint(address _to, uint _amount)\r\n        onlyComptroller\r\n        public\r\n    {\r\n        _updateCreditedPoints(_to);\r\n        totalSupply += _amount;\r\n        balanceOf[_to] += _amount;\r\n        emit TokensMinted(now, _to, _amount, totalSupply);\r\n    }\r\n    \r\n    // Credits dividends, burns tokens.\r\n    function burn(address _account, uint _amount)\r\n        onlyComptroller\r\n        public\r\n    {\r\n        require(balanceOf[_account] >= _amount);\r\n        _updateCreditedPoints(_account);\r\n        balanceOf[_account] -= _amount;\r\n        totalSupply -= _amount;\r\n        totalBurned += _amount;\r\n        emit TokensBurned(now, _account, _amount, totalSupply);\r\n    }\r\n\r\n    // when set to true, prevents tokens from being transferred\r\n    function freeze(bool _isFrozen)\r\n        onlyComptroller\r\n        public\r\n    {\r\n        if (isFrozen == _isFrozen) return;\r\n        isFrozen = _isFrozen;\r\n        if (_isFrozen) emit Frozen(now);\r\n        else emit UnFrozen(now);\r\n    }\r\n\r\n    /*************************************************************/\r\n    /********** PUBLIC FUNCTIONS *********************************/\r\n    /*************************************************************/\r\n    \r\n    // Normal ERC20 transfer, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {   \r\n        // ensure tokens are not frozen.\r\n        require(!isFrozen);\r\n        _updateCreditedPoints(msg.sender);\r\n        _updateCreditedPoints(_to);\r\n        return ERC20.transfer(_to, _value);\r\n    }\r\n\r\n    // Normal ERC20 transferFrom, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(!isFrozen);\r\n        _updateCreditedPoints(_from);\r\n        _updateCreditedPoints(_to);\r\n        return ERC20.transferFrom(_from, _to, _value);\r\n    }\r\n    \r\n    // Normal ERC667 transferAndCall, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transferAndCall(address _to, uint _value, bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(!isFrozen);\r\n        _updateCreditedPoints(msg.sender);\r\n        _updateCreditedPoints(_to);\r\n        return ERC667.transferAndCall(_to, _value, _data);  \r\n    }\r\n\r\n    // Updates creditedPoints, sends all wei to the owner\r\n    function collectOwedDividends()\r\n        public\r\n        returns (uint _amount)\r\n    {\r\n        // update creditedPoints, store amount, and zero it.\r\n        _updateCreditedPoints(msg.sender);\r\n        _amount = creditedPoints[msg.sender] / POINTS_PER_WEI;\r\n        creditedPoints[msg.sender] = 0;\r\n        dividendsCollected += _amount;\r\n        emit CollectedDividends(now, msg.sender, _amount);\r\n        require(msg.sender.call.value(_amount)());\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** PRIVATE METHODS / VIEWS **************************/\r\n    /*************************************************************/\r\n    // Credits _account with whatever dividend points they haven't yet been credited.\r\n    //  This needs to be called before any user's balance changes to ensure their\r\n    //  \"lastPointsPerToken\" credits their current balance, and not an altered one.\r\n    function _updateCreditedPoints(address _account)\r\n        private\r\n    {\r\n        creditedPoints[_account] += _getUncreditedPoints(_account);\r\n        lastPointsPerToken[_account] = totalPointsPerToken;\r\n    }\r\n\r\n    // For a given account, returns how many Wei they haven't yet been credited.\r\n    function _getUncreditedPoints(address _account)\r\n        private\r\n        view\r\n        returns (uint _amount)\r\n    {\r\n        uint _pointsPerToken = totalPointsPerToken - lastPointsPerToken[_account];\r\n        // The upper bound on this number is:\r\n        //   ((1e32 * TOTAL_DIVIDEND_AMT) / totalSupply) * balances[_account]\r\n        // Since totalSupply >= balances[_account], this will overflow only if\r\n        //   TOTAL_DIVIDEND_AMT is around 1e45 wei. Not ever going to happen.\r\n        return _pointsPerToken * balanceOf[_account];\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********* CONSTANTS *****************************************/\r\n    /*************************************************************/\r\n    // Returns how many wei a call to .collectOwedDividends() would transfer.\r\n    function getOwedDividends(address _account)\r\n        public\r\n        constant\r\n        returns (uint _amount)\r\n    {\r\n        return (_getUncreditedPoints(_account) + creditedPoints[_account])/POINTS_PER_WEI;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/*********************************************************\r\n*************** DIVIDEND TOKEN LOCKER ********************\r\n**********************************************************\r\n\r\nThis contract holds a balance of tokens and enforces that\r\nthe balance of tokens is always above the amount that has\r\nnot yet vested. All dividends are always collectable.\r\n\r\nOwner Permissions:\r\n    - to collect all dividends\r\n    - to transfer tokens, such that some minimum balance\r\n      is maintained, as defined by the vesting parameters\r\n\r\nComptroller Permissions:\r\n    - Specifies the token and owner\r\n    - Specifies the amount to vest, and over what period\r\n*/\r\ncontract IDividendToken {\r\n    function collectOwedDividends() external returns (uint);\r\n    function transfer(address _to, uint _value) external;\r\n    function balanceOf(address _addr) external view returns (uint);\r\n}\r\ncontract DividendTokenLocker {\r\n    // set in the constructor\r\n    address public comptroller;\r\n    address public owner;\r\n    IDividendToken public token;\r\n    // set by comptroller via .setVesting()\r\n    uint public vestingAmt;\r\n    uint public vestingStartDay;\r\n    uint public vestingDays;\r\n\r\n    // events, for transparency\r\n    event Created(uint time, address comptroller, address token, address owner);\r\n    event VestingStarted(uint time, uint numTokens, uint vestingDays);\r\n    event Transferred(uint time, address recipient, uint numTokens);\r\n    event Collected(uint time, address recipient, uint amount);\r\n    \r\n    // Initialize the comptroller, token, and owner addresses.\r\n    constructor(address _token, address _owner)\r\n        public\r\n    {\r\n        comptroller = msg.sender;\r\n        token = IDividendToken(_token);\r\n        owner = _owner;\r\n        emit Created(now, comptroller, token, owner);\r\n    }\r\n\r\n    // Allow this contract to get sent Ether (eg, dividendsOwed)\r\n    function () payable public {}\r\n\r\n\r\n    /***************************************************/\r\n    /*********** CREATOR FUNCTIONS *********************/\r\n    /***************************************************/\r\n\r\n    // Starts the vesting process for the current balance.\r\n    // TokenLocker will ensure a minimum balance is maintained\r\n    //  based off of the vestingAmt and vestingDays.\r\n    function startVesting(uint _numTokens, uint _vestingDays)\r\n        public\r\n    {\r\n        require(msg.sender == comptroller);\r\n        vestingAmt = _numTokens;\r\n        vestingStartDay = _today();\r\n        vestingDays = _vestingDays;\r\n        emit VestingStarted(now, _numTokens, _vestingDays);\r\n    }\r\n\r\n\r\n    /***************************************************/\r\n    /*********** OWNER FUNCTIONS ***********************/\r\n    /***************************************************/\r\n\r\n    // Allows the owner to collect the balance of this contract,\r\n    //  including any owed dividends.\r\n    function collect()\r\n        public\r\n    {\r\n        require(msg.sender == owner);\r\n        // Collect dividends, and get new balance.\r\n        token.collectOwedDividends();\r\n        uint _amount = address(this).balance;\r\n\r\n        // Send amount (if any), emit event.\r\n        if (_amount > 0) require(owner.call.value(_amount)());\r\n        emit Collected(now, owner, _amount);\r\n    }\r\n\r\n    // Allows the owner to transfer tokens, such that the\r\n    //  balance of tokens cannot go below getMinTokenBalance().\r\n    function transfer(address _to, uint _numTokens)\r\n        public\r\n    {\r\n        require(msg.sender == owner);\r\n        uint _available = tokensAvailable();\r\n        if (_numTokens > _available) _numTokens = _available;\r\n\r\n        // Transfer (if _numTokens > 0), and emit event.\r\n        if (_numTokens > 0) {\r\n            token.transfer(_to, _numTokens);\r\n        }\r\n        emit Transferred(now, _to, _numTokens);\r\n    }\r\n\r\n\r\n    /***************************************************/\r\n    /*********** VIEWS *********************************/\r\n    /***************************************************/\r\n\r\n    function tokens()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return token.balanceOf(this);\r\n    }\r\n\r\n    // Returns the minimum allowed tokenBalance.\r\n    // Starts at vestingAmt, goes to 0 after vestingDays.\r\n    function tokensUnvested()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return vestingAmt - tokensVested();\r\n    }\r\n\r\n    // Returns how many tokens have vested.\r\n    // Starts at 0, goes to vestingAmt after vestingDays.\r\n    function tokensVested()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint _daysElapsed = _today() - vestingStartDay;\r\n        return _daysElapsed >= vestingDays\r\n            ? vestingAmt\r\n            : (vestingAmt * _daysElapsed) / vestingDays;\r\n    }\r\n\r\n    // Returns the amount of tokens available to be transferred.\r\n    // This is the balance, minus how many tokens must be maintained due to vesting.\r\n    function tokensAvailable()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        // token.balanceOf() and getMinTokenBalance() can never be greater than\r\n        //   all the Ether in the world, so we dont worry about overflow.\r\n        int _available = int(tokens()) - int(tokensUnvested());\r\n        return _available > 0 ? uint(_available) : 0;\r\n    }\r\n\r\n    // Returns the current day.\r\n    function _today()\r\n        private \r\n        view \r\n        returns (uint)\r\n    {\r\n        return now / 1 days;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"capitalPctBips\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capitalFundable\",\"outputs\":[{\"name\":\"_amt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wasSoftCapMet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wasSaleEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wasSaleStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"amtFunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dateStarted\",\"type\":\"uint256\"},{\"name\":\"_dateEnded\",\"type\":\"uint256\"},{\"name\":\"_softCap\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"name\":\"_bonusCap\",\"type\":\"uint256\"},{\"name\":\"_capitalPctBips\",\"type\":\"uint256\"}],\"name\":\"initSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fundCapital\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateSaleEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethAmt\",\"type\":\"uint256\"}],\"name\":\"getTokensMintedAt\",\"outputs\":[{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"getTokensFromEth\",\"outputs\":[{\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dateSaleStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_treasury\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"treasury\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"locker\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SaleInitalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SaleSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SaleFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"funded\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"BuyTokensSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"BuyTokensFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"UserRefunded\",\"type\":\"event\"}]","ContractName":"Comptroller","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000017d77cdda0df5a9670df804d8aa2b490f760044d000000000000000000000000df08fb2056e0dde21dc623807853811b44c11ac8","Library":"","SwarmSource":"bzzr://816f12d32ad55f53b6b94a2033f313bf7f29c3f752cd153fadbfec5785d1bed5"}]}