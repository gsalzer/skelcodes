{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ContractReceiver {\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\ncontract ERC20Interface {\r\n    //ERC20 with allowance\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    // ERC20 Basic\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract StandardERC20 is ERC20Interface {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n    uint256 totalSupply_;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /*\r\n        Allowance part\r\n    */\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = (\r\n        allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract Token is StandardERC20 {\r\n    \r\n    string public name    = \"Genuine Token\";\r\n    string public symbol  = \"GNU\";\r\n    uint8  public decimals = 18;\r\n\r\n    address owner;\r\n\r\n    bool burnable;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n\r\n    constructor() public {\r\n        balances[msg.sender] = 340000000 * (uint(10) ** decimals);\r\n        totalSupply_ = balances[msg.sender];\r\n        owner = msg.sender;\r\n        burnable = false;\r\n    }\r\n\r\n    function transferOwnership(address tbo) public {\r\n        require(msg.sender == owner, 'Unauthorized');\r\n        owner = tbo;\r\n    }\r\n       \r\n    // Function to access name of token .\r\n    function name() public view returns (string _name) {\r\n        return name;\r\n    }\r\n    \r\n    // Function to access symbol of token .\r\n    function symbol() public view returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n    \r\n    // Function to access decimals of token .\r\n    function decimals() public view returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n    \r\n    // Function to access total supply of tokens .\r\n    function totalSupply() public view returns (uint256 _totalSupply) {\r\n        return totalSupply_;\r\n    }\r\n    \r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n    function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {\r\n        require(_to != address(0));\r\n\r\n        if (isContract(_to)) {\r\n            if (balanceOf(msg.sender) < _value) revert();\r\n            balances[msg.sender] = balanceOf(msg.sender).sub(_value);\r\n            balances[_to] = balanceOf(_to).add(_value);\r\n            assert(_to.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data));\r\n            emit Transfer(msg.sender, _to, _value, _data);\r\n            // ERC20 compliant transfer\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }\r\n  \r\n\r\n    // Function that is called when a user or another contract wants to transfer funds .\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool success) {\r\n        require(_to != address(0));\r\n        \r\n        if (isContract(_to)) {\r\n            return transferToContract(_to, _value, _data);\r\n        }\r\n        else {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }\r\n    \r\n    // Standard function transfer similar to ERC20 transfer with no _data .\r\n    // Added due to backwards compatibility reasons .\r\n    // Overrides the base transfer function of the standard ERC20 token\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        \r\n        //standard function transfer similar to ERC20 transfer with no _data\r\n        //added due to backwards compatibility reasons\r\n        bytes memory empty;\r\n        if (isContract(_to)) {\r\n            return transferToContract(_to, _value, empty);\r\n        }\r\n        else {\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }\r\n\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) private view returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n                //retrieve the size of the code on target address, this needs assembly\r\n                length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n\r\n    //function that is called when transaction target is an address\r\n    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) revert(\"Insufficient balance\");\r\n        balances[msg.sender] = balanceOf(msg.sender).sub(_value);\r\n        balances[_to] = balanceOf(_to).add(_value);\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        // ERC20 compliant transfer\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    //function that is called when transaction target is a contract\r\n    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\n        if (balanceOf(msg.sender) < _value) revert(\"Insufficient balance\");\r\n        balances[msg.sender] = balanceOf(msg.sender).sub(_value);\r\n        balances[_to] = balanceOf(_to).add(_value);\r\n        ContractReceiver receiver = ContractReceiver(_to);\r\n        receiver.tokenFallback(msg.sender, _value, _data);\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        // ERC20 compliant transfer\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function setBurnable(bool _burnable) public {\r\n        require (msg.sender == owner);\r\n        burnable = _burnable;\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        _burn(msg.sender, _value);\r\n    }\r\n\r\n    function _burn(address _who, uint256 _value) internal {\r\n\r\n        require(burnable == true || _who == owner);\r\n\r\n        require(_value <= balances[_who]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit Burn(_who, _value);\r\n        emit Transfer(_who, address(0), _value);\r\n    }\r\n}\r\n\r\nlibrary Array256Lib {\r\n\r\n  /// @dev Sum vector\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return sum The sum of all elements, does not check for overflow\r\n  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the max value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return maxValue The highest value in the array\r\n  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      maxValue := sload(sha3(0x60,0x20))\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\r\n        case 1 {\r\n          maxValue := sload(add(sha3(0x60,0x20),i))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the minimum value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return minValue The highest value in the array\r\n  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      minValue := sload(sha3(0x60,0x20))\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\r\n        case 0 {\r\n          minValue := sload(add(sha3(0x60,0x20),i))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Finds the index of a given value in an array\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @param value The value to search for\r\n  /// @param isSorted True if the array is sorted, false otherwise\r\n  /// @return found True if the value was found, false otherwise\r\n  /// @return index The index of the given value, returns 0 if found is false\r\n  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\r\n           public\r\n           view\r\n           returns(bool found, uint256 index) {\r\n    assembly{\r\n      mstore(0x60,self_slot)\r\n      switch isSorted\r\n      case 1 {\r\n        let high := sub(sload(self_slot),1)\r\n        let mid := 0\r\n        let low := 0\r\n        for { } iszero(gt(low, high)) { } {\r\n          mid := div(add(low,high),2)\r\n\r\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\r\n          case 1 {\r\n             low := add(mid,1)\r\n          }\r\n          case 0 {\r\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\r\n            case 1 {\r\n              high := sub(mid,1)\r\n            }\r\n            case 0 {\r\n              found := 1\r\n              index := mid\r\n              low := add(high,1)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      case 0 {\r\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\r\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\r\n          case 1 {\r\n            found := 1\r\n            index := low\r\n            low := sload(self_slot)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of child node\r\n  /// @return pI The parent node index\r\n  function getParentI(uint256 index) private pure returns (uint256 pI) {\r\n    uint256 i = index - 1;\r\n    pI = i/2;\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of parent node\r\n  /// @return lcI The index of left child\r\n  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {\r\n    uint256 i = index * 2;\r\n    lcI = i + 1;\r\n  }\r\n\r\n  /// @dev Sorts given array in place\r\n  /// @param self Storage array containing uint256 type variables\r\n  function heapSort(uint256[] storage self) public {\r\n    uint256 end = self.length - 1;\r\n    uint256 start = getParentI(end);\r\n    uint256 root = start;\r\n    uint256 lChild;\r\n    uint256 rChild;\r\n    uint256 swap;\r\n    uint256 temp;\r\n    while(start >= 0){\r\n      root = start;\r\n      lChild = getLeftChildI(start);\r\n      while(lChild <= end){\r\n        rChild = lChild + 1;\r\n        swap = root;\r\n        if(self[swap] < self[lChild])\r\n          swap = lChild;\r\n        if((rChild <= end) && (self[swap]<self[rChild]))\r\n          swap = rChild;\r\n        if(swap == root)\r\n          lChild = end+1;\r\n        else {\r\n          temp = self[swap];\r\n          self[swap] = self[root];\r\n          self[root] = temp;\r\n          root = swap;\r\n          lChild = getLeftChildI(root);\r\n        }\r\n      }\r\n      if(start == 0)\r\n        break;\r\n      else\r\n        start = start - 1;\r\n    }\r\n    while(end > 0){\r\n      temp = self[end];\r\n      self[end] = self[0];\r\n      self[0] = temp;\r\n      end = end - 1;\r\n      root = 0;\r\n      lChild = getLeftChildI(0);\r\n      while(lChild <= end){\r\n        rChild = lChild + 1;\r\n        swap = root;\r\n        if(self[swap] < self[lChild])\r\n          swap = lChild;\r\n        if((rChild <= end) && (self[swap]<self[rChild]))\r\n          swap = rChild;\r\n        if(swap == root)\r\n          lChild = end + 1;\r\n        else {\r\n          temp = self[swap];\r\n          self[swap] = self[root];\r\n          self[root] = temp;\r\n          root = swap;\r\n          lChild = getLeftChildI(root);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Removes duplicates from a given array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  function uniq(uint256[] storage self) public returns (uint256 length) {\r\n    bool contains;\r\n    uint256 index;\r\n\r\n    for (uint256 i = 0; i < self.length; i++) {\r\n      (contains, index) = indexOf(self, self[i], false);\r\n\r\n      if (i > index) {\r\n        for (uint256 j = i; j < self.length - 1; j++){\r\n          self[j] = self[j + 1];\r\n        }\r\n\r\n        delete self[self.length - 1];\r\n        self.length--;\r\n        i--;\r\n      }\r\n    }\r\n\r\n    length = self.length;\r\n  }\r\n}\r\n\r\ncontract BytesToTypes {\r\n    \r\n\r\n    function bytesToAddress(uint _offst, bytes memory _input) internal pure returns (address _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n    \r\n    function bytesToBool(uint _offst, bytes memory _input) internal pure returns (bool _output) {\r\n        \r\n        uint8 x;\r\n        assembly {\r\n            x := mload(add(_input, _offst))\r\n        }\r\n        x==0 ? _output = false : _output = true;\r\n    }   \r\n        \r\n    function getStringSize(uint _offst, bytes memory _input) internal pure returns(uint size){\r\n        \r\n        assembly{\r\n            \r\n            size := mload(add(_input,_offst))\r\n            let chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1\r\n            \r\n            if gt(mod(size,32),0) {// if size%32 > 0\r\n                chunk_count := add(chunk_count,1)\r\n            } \r\n            \r\n             size := mul(chunk_count,32)// first 32 bytes reseves for size in strings\r\n        }\r\n    }\r\n\r\n    function bytesToString(uint _offst, bytes memory _input, bytes memory _output) internal  {\r\n\r\n        uint size = 32;\r\n        assembly {\r\n            let loop_index:= 0\r\n                  \r\n            let chunk_count\r\n            \r\n            size := mload(add(_input,_offst))\r\n            chunk_count := add(div(size,32),1) // chunk_count = size/32 + 1\r\n            \r\n            if gt(mod(size,32),0) {\r\n                chunk_count := add(chunk_count,1)  // chunk_count++\r\n            }\r\n                \r\n            \r\n            loop:\r\n                mstore(add(_output,mul(loop_index,32)),mload(add(_input,_offst)))\r\n                _offst := sub(_offst,32)           // _offst -= 32\r\n                loop_index := add(loop_index,1)\r\n                \r\n            jumpi(loop , lt(loop_index , chunk_count))\r\n            \r\n        }\r\n    }\r\n\r\n    function bytesToBytes32(uint _offst, bytes memory  _input, bytes32 _output) internal pure {\r\n        \r\n        assembly {\r\n            mstore(_output , add(_input, _offst))\r\n            mstore(add(_output,32) , add(add(_input, _offst),32))\r\n        }\r\n    }\r\n    \r\n    function bytesToInt8(uint _offst, bytes memory  _input) internal pure returns (int8 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n    \r\n    function bytesToInt16(uint _offst, bytes memory _input) internal pure returns (int16 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt24(uint _offst, bytes memory _input) internal pure returns (int24 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt32(uint _offst, bytes memory _input) internal pure returns (int32 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt40(uint _offst, bytes memory _input) internal pure returns (int40 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt48(uint _offst, bytes memory _input) internal pure returns (int48 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt56(uint _offst, bytes memory _input) internal pure returns (int56 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt64(uint _offst, bytes memory _input) internal pure returns (int64 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt72(uint _offst, bytes memory _input) internal pure returns (int72 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt80(uint _offst, bytes memory _input) internal pure returns (int80 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt88(uint _offst, bytes memory _input) internal pure returns (int88 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt96(uint _offst, bytes memory _input) internal pure returns (int96 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\t\r\n\tfunction bytesToInt104(uint _offst, bytes memory _input) internal pure returns (int104 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n    \r\n    function bytesToInt112(uint _offst, bytes memory _input) internal pure returns (int112 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt120(uint _offst, bytes memory _input) internal pure returns (int120 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt128(uint _offst, bytes memory _input) internal pure returns (int128 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt136(uint _offst, bytes memory _input) internal pure returns (int136 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt144(uint _offst, bytes memory _input) internal pure returns (int144 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt152(uint _offst, bytes memory _input) internal pure returns (int152 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt160(uint _offst, bytes memory _input) internal pure returns (int160 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt168(uint _offst, bytes memory _input) internal pure returns (int168 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt176(uint _offst, bytes memory _input) internal pure returns (int176 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt184(uint _offst, bytes memory _input) internal pure returns (int184 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt192(uint _offst, bytes memory _input) internal pure returns (int192 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt200(uint _offst, bytes memory _input) internal pure returns (int200 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt208(uint _offst, bytes memory _input) internal pure returns (int208 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt216(uint _offst, bytes memory _input) internal pure returns (int216 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt224(uint _offst, bytes memory _input) internal pure returns (int224 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt232(uint _offst, bytes memory _input) internal pure returns (int232 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt240(uint _offst, bytes memory _input) internal pure returns (int240 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt248(uint _offst, bytes memory _input) internal pure returns (int248 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n    function bytesToInt256(uint _offst, bytes memory _input) internal pure returns (int256 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    }\r\n\r\n\tfunction bytesToUint8(uint _offst, bytes memory _input) internal pure returns (uint8 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint16(uint _offst, bytes memory _input) internal pure returns (uint16 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint24(uint _offst, bytes memory _input) internal pure returns (uint24 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint32(uint _offst, bytes memory _input) internal pure returns (uint32 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint40(uint _offst, bytes memory _input) internal pure returns (uint40 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint48(uint _offst, bytes memory _input) internal pure returns (uint48 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint56(uint _offst, bytes memory _input) internal pure returns (uint56 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint64(uint _offst, bytes memory _input) internal pure returns (uint64 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint72(uint _offst, bytes memory _input) internal pure returns (uint72 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint80(uint _offst, bytes memory _input) internal pure returns (uint80 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint88(uint _offst, bytes memory _input) internal pure returns (uint88 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n\tfunction bytesToUint96(uint _offst, bytes memory _input) internal pure returns (uint96 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\t\r\n\tfunction bytesToUint104(uint _offst, bytes memory _input) internal pure returns (uint104 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint112(uint _offst, bytes memory _input) internal pure returns (uint112 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint120(uint _offst, bytes memory _input) internal pure returns (uint120 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint128(uint _offst, bytes memory _input) internal pure returns (uint128 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint136(uint _offst, bytes memory _input) internal pure returns (uint136 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint144(uint _offst, bytes memory _input) internal pure returns (uint144 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint152(uint _offst, bytes memory _input) internal pure returns (uint152 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint160(uint _offst, bytes memory _input) internal pure returns (uint160 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint168(uint _offst, bytes memory _input) internal pure returns (uint168 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint176(uint _offst, bytes memory _input) internal pure returns (uint176 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint184(uint _offst, bytes memory _input) internal pure returns (uint184 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint192(uint _offst, bytes memory _input) internal pure returns (uint192 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint200(uint _offst, bytes memory _input) internal pure returns (uint200 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint208(uint _offst, bytes memory _input) internal pure returns (uint208 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint216(uint _offst, bytes memory _input) internal pure returns (uint216 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint224(uint _offst, bytes memory _input) internal pure returns (uint224 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint232(uint _offst, bytes memory _input) internal pure returns (uint232 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint240(uint _offst, bytes memory _input) internal pure returns (uint240 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint248(uint _offst, bytes memory _input) internal pure returns (uint248 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n\r\n    function bytesToUint256(uint _offst, bytes memory _input) internal pure returns (uint256 _output) {\r\n        \r\n        assembly {\r\n            _output := mload(add(_input, _offst))\r\n        }\r\n    } \r\n    \r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract  SizeOf {\r\n    \r\n    function sizeOfString(string _in) internal pure  returns(uint _size){\r\n        _size = bytes(_in).length / 32;\r\n         if(bytes(_in).length % 32 != 0) \r\n            _size++;\r\n            \r\n        _size++; // first 32 bytes is reserved for the size of the string     \r\n        _size *= 32;\r\n    }\r\n\r\n    function sizeOfInt(uint16 _postfix) internal pure  returns(uint size){\r\n\r\n        assembly{\r\n            switch _postfix\r\n                case 8 { size := 1 }\r\n                case 16 { size := 2 }\r\n                case 24 { size := 3 }\r\n                case 32 { size := 4 }\r\n                case 40 { size := 5 }\r\n                case 48 { size := 6 }\r\n                case 56 { size := 7 }\r\n                case 64 { size := 8 }\r\n                case 72 { size := 9 }\r\n                case 80 { size := 10 }\r\n                case 88 { size := 11 }\r\n                case 96 { size := 12 }\r\n                case 104 { size := 13 }\r\n                case 112 { size := 14 }\r\n                case 120 { size := 15 }\r\n                case 128 { size := 16 }\r\n                case 136 { size := 17 }\r\n                case 144 { size := 18 }\r\n                case 152 { size := 19 }\r\n                case 160 { size := 20 }\r\n                case 168 { size := 21 }\r\n                case 176 { size := 22 }\r\n                case 184 { size := 23 }\r\n                case 192 { size := 24 }\r\n                case 200 { size := 25 }\r\n                case 208 { size := 26 }\r\n                case 216 { size := 27 }\r\n                case 224 { size := 28 }\r\n                case 232 { size := 29 }\r\n                case 240 { size := 30 }\r\n                case 248 { size := 31 }\r\n                case 256 { size := 32 }\r\n                default  { size := 32 }\r\n        }\r\n\r\n    }\r\n    \r\n    function sizeOfUint(uint16 _postfix) internal pure  returns(uint size){\r\n        return sizeOfInt(_postfix);\r\n    }\r\n\r\n    function sizeOfAddress() internal pure  returns(uint8){\r\n        return 20; \r\n    }\r\n    \r\n    function sizeOfBool() internal pure  returns(uint8){\r\n        return 1; \r\n    }\r\n    \r\n\r\n}\r\n\r\ncontract TypesToBytes {\r\n \r\n    function TypesToBytes() internal {\r\n        \r\n    }\r\n    function addressToBytes(uint _offst, address _input, bytes memory _output) internal pure {\r\n\r\n        assembly {\r\n            mstore(add(_output, _offst), _input)\r\n        }\r\n    }\r\n\r\n    function bytes32ToBytes(uint _offst, bytes32 _input, bytes memory _output) internal pure {\r\n\r\n        assembly {\r\n            mstore(add(_output, _offst), _input)\r\n            mstore(add(add(_output, _offst),32), add(_input,32))\r\n        }\r\n    }\r\n    \r\n    function boolToBytes(uint _offst, bool _input, bytes memory _output) internal pure {\r\n        uint8 x = _input == false ? 0 : 1;\r\n        assembly {\r\n            mstore(add(_output, _offst), x)\r\n        }\r\n    }\r\n    \r\n    function stringToBytes(uint _offst, bytes memory _input, bytes memory _output) internal {\r\n        uint256 stack_size = _input.length / 32;\r\n        if(_input.length % 32 > 0) stack_size++;\r\n        \r\n        assembly {\r\n            let index := 0\r\n            stack_size := add(stack_size,1)//adding because of 32 first bytes memory as the length\r\n        loop:\r\n            \r\n            mstore(add(_output, _offst), mload(add(_input,mul(index,32))))\r\n            _offst := sub(_offst , 32)\r\n            index := add(index ,1)\r\n            jumpi(loop , lt(index,stack_size))\r\n        }\r\n    }\r\n\r\n    function intToBytes(uint _offst, int _input, bytes memory  _output) internal pure {\r\n\r\n        assembly {\r\n            mstore(add(_output, _offst), _input)\r\n        }\r\n    } \r\n    \r\n    function uintToBytes(uint _offst, uint _input, bytes memory _output) internal pure {\r\n\r\n        assembly {\r\n            mstore(add(_output, _offst), _input)\r\n        }\r\n    }   \r\n\r\n}\r\n\r\ncontract Seriality is BytesToTypes, TypesToBytes, SizeOf {\r\n\r\n    function Seriality() public {\r\n\r\n    }\r\n}\r\n\r\ncontract TimedEscrow is ContractReceiver, Seriality {\r\n\r\n    using Array256Lib for uint256[];\r\n\r\n    struct Transaction {\r\n        uint256 value;\r\n        address to_address;\r\n        uint256 time;\r\n        bool valid; //we do not want to get rid of transactions that are cancelled, just void them\r\n        bool executed; //we want to separate the concept of executed transactions from the invalid ones which should both be immutable\r\n    }\r\n\r\n    Token tokContract;\r\n    address owner;\r\n\r\n    Transaction[] transactions;\r\n\r\n    mapping(address => uint256[]) transactions_of;\r\n\r\n    // Events\r\n    event addingTransaction(uint256 value, address addr, uint256 time, bool valid, bool executed, uint index);\r\n    event voidingTransaction(uint256 index);\r\n\r\n\r\n    constructor(address _tokContract) public {\r\n        tokContract = Token(_tokContract);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function addTransaction(Transaction transaction) private {\r\n        transactions.push(transaction);\r\n        transactions_of[transaction.to_address].push(transactions.length - 1);\r\n        emit addingTransaction(transaction.value, transaction.to_address, transaction.time, transaction.valid, transaction.executed, transactions.length - 1);\r\n    }\r\n\r\n    function transferOwnership(address tbo){\r\n        require(msg.sender == owner, 'Unauthorized');\r\n        owner = tbo;\r\n    }\r\n\r\n    //ETH has been transfered so we should not be allowed to void transactions\r\n    //Should we allow beneficiary to void his transaction? Maybe they have lost private key to hackers\r\n\r\n    function voidTransaction(uint256 transaction_id){\r\n        require(\r\n            msg.sender == transactions[transaction_id].to_address\r\n            && !transactions[transaction_id].executed\r\n        && transactions[transaction_id].valid\r\n        );\r\n        transactions[transaction_id].valid = false;\r\n        tokContract.transfer(owner, transactions[transaction_id].value);\r\n        emit voidingTransaction(transaction_id);\r\n    }\r\n\r\n    function getTransactionIdsOf(address to_address) public view returns (uint[]){\r\n        return transactions_of[to_address];\r\n    }\r\n\r\n    function getTransaction(uint256 transaction_id) public view returns (uint256 value, address to_address, uint256 time, bool valid, bool executed){\r\n        Transaction memory t = transactions[transaction_id];\r\n        value = t.value;\r\n        to_address = t.to_address;\r\n        time = t.time;\r\n        valid = t.valid;\r\n        executed = t.executed;\r\n        return;\r\n    }\r\n\r\n    function performTransaction(uint256 transaction_id){\r\n        Transaction tbp = transactions[transaction_id];\r\n        require(now > tbp.time && tbp.valid && !tbp.executed, 'Invalid transaction data');\r\n        tbp.executed = true;\r\n        transactions[transaction_id] = tbp;\r\n        tokContract.transfer(tbp.to_address, tbp.value);\r\n    }\r\n\r\n    function transactionStructFromBytesSeriality(bytes data) internal pure returns (Transaction){\r\n        Transaction memory t;\r\n        uint offset = 128;\r\n        bytes memory buffer = new bytes(128);\r\n\r\n        t.value = bytesToUint256(offset, data);\r\n        offset -= sizeOfUint(256);\r\n\r\n        t.to_address = bytesToAddress(offset, data);\r\n        offset -= sizeOfAddress();\r\n\r\n        t.time = bytesToUint256(offset, data);\r\n        offset -= sizeOfUint(256);\r\n\r\n        t.valid = bytesToBool(offset, data);\r\n        offset -= sizeOfBool();\r\n\r\n        t.executed = bytesToBool(offset, data);\r\n        offset -= sizeOfBool();\r\n        return t;\r\n\r\n    }\r\n\r\n    function transactionStructToBytesSeriality(Transaction t) private pure returns (bytes){\r\n        bytes memory buffer = new bytes(128);\r\n        uint offset = 128;\r\n\r\n        uintToBytes(offset, t.value, buffer);\r\n        offset -= sizeOfUint(256);\r\n\r\n        addressToBytes(offset, t.to_address, buffer);\r\n        offset -= sizeOfAddress();\r\n\r\n        uintToBytes(offset, t.time, buffer);\r\n        offset -= sizeOfUint(256);\r\n\r\n        boolToBytes(offset, t.valid, buffer);\r\n        offset -= sizeOfBool();\r\n\r\n        boolToBytes(offset, t.executed, buffer);\r\n        offset -= sizeOfBool();\r\n        return buffer;\r\n    }\r\n\r\n    function transactionRawToBytes(uint256 value, address to_address, uint256 time, bool valid, bool executed) public pure returns (bytes){\r\n        Transaction memory t;\r\n        t.value = value;\r\n        t.to_address = to_address;\r\n        t.time = time;\r\n        t.valid = valid;\r\n        t.executed = executed;\r\n        return transactionStructToBytesSeriality(t);\r\n    }\r\n\r\n    function tokenFallback(address _from, uint _value, bytes _data) public {\r\n        require(_value > 0, 'No transaction was added because value was zero');\r\n        Transaction memory transaction = transactionStructFromBytesSeriality(_data);\r\n        require(transaction.value == _value, 'Token sent were not equal to token to store');\r\n        require(transaction.time > now, 'Time was in the past');\r\n        require(transaction.valid == true && transaction.executed == false, 'Transaction data is invalid');\r\n        addTransaction(transaction);\r\n    }\r\n\r\n    function rescheduleTransaction(uint256 transaction_id, uint256 newtime) public {\r\n        require(msg.sender == owner);\r\n        require(!transactions[transaction_id].executed\r\n        && transactions[transaction_id].valid\r\n        && transactions[transaction_id].time > newtime);\r\n        transactions[transaction_id].time = newtime;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"to_address\",\"type\":\"address\"}],\"name\":\"getTransactionIdsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transaction_id\",\"type\":\"uint256\"}],\"name\":\"getTransaction\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"to_address\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"valid\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"to_address\",\"type\":\"address\"},{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"valid\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"transactionRawToBytes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transaction_id\",\"type\":\"uint256\"}],\"name\":\"performTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transaction_id\",\"type\":\"uint256\"}],\"name\":\"voidTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transaction_id\",\"type\":\"uint256\"},{\"name\":\"newtime\",\"type\":\"uint256\"}],\"name\":\"rescheduleTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tbo\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"valid\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"executed\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"addingTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"voidingTransaction\",\"type\":\"event\"}]","ContractName":"TimedEscrow","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000783d7ed15e1713d87159dfcd7f196056b5cba303","Library":"","SwarmSource":"bzzr://65b57cc54aaba31a3b3d50776ec08b91dc7c3c9bc889a0cd04097df675eca618"}]}