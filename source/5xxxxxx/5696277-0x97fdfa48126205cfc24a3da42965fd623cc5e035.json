{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n// File: contracts/interfaces/IAuctions.sol\r\n\r\ncontract IAuctions {\r\n\r\n    function currentPrice(uint _tokenId) public constant returns (uint256);\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration) public;\r\n    function createReleaseAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _startedAt,\r\n        uint _duration) public;\r\n    function cancelAuction(uint256 _tokenId) external;\r\n    function cancelAuctionWhenPaused(uint256 _tokenId) external;\r\n    function bid(uint256 _tokenId, address _owner) external payable;\r\n    function market() public constant returns (\r\n        uint[] tokens,\r\n        address[] sellers,\r\n        uint8[] generations,\r\n        uint8[] speeds,\r\n        uint[] prices\r\n    );\r\n    function auctionsOf(address _of) public constant returns (\r\n        uint[] tokens,\r\n        uint[] prices\r\n    );\r\n    function signature() external constant returns (uint _signature);\r\n}\r\n\r\n// File: contracts/interfaces/IPaintings.sol\r\n\r\ncontract IPaintings {\r\n    function createPainting(uint _tokenId) external;\r\n    function sendAsGift(address _to, uint _tokenId) external;\r\n    function collectionOf(address _of) public constant returns (\r\n        uint[] tokens,\r\n        bool[] pending,\r\n        bool[] forSale,\r\n        bool[] locked,\r\n        uint8[] generations,\r\n        uint8[] speeds\r\n    );\r\n    function collectionCountsOf(address _of)\r\n        public constant returns (uint total, uint pending, uint forSale);\r\n    function signature() external constant returns (uint _signature);\r\n}\r\n\r\n// File: contracts/interfaces/IStorage.sol\r\n\r\ncontract IStorage {\r\n    function isOwner(address _address) public constant returns (bool);\r\n\r\n    function isAllowed(address _address) external constant returns (bool);\r\n    function developer() public constant returns (address);\r\n    function setDeveloper(address _address) public;\r\n    function addAdmin(address _address) public;\r\n    function isAdmin(address _address) public constant returns (bool);\r\n    function removeAdmin(address _address) public;\r\n    function contracts(uint _signature) public returns (address _address);\r\n\r\n    function exists(uint _tokenId) external constant returns (bool);\r\n    function paintingsCount() public constant returns (uint);\r\n    function increaseOwnershipTokenCount(address _address) public;\r\n    function decreaseOwnershipTokenCount(address _address) public;\r\n    function setOwnership(uint _tokenId, address _address) public;\r\n    function getPainting(uint _tokenId)\r\n        external constant returns (address, uint, uint, uint, uint8, uint8);\r\n    function createPainting(\r\n        address _owner,\r\n        uint _tokenId,\r\n        uint _parentId,\r\n        uint8 _generation,\r\n        uint8 _speed,\r\n        uint _artistId,\r\n        uint _releasedAt) public;\r\n    function approve(uint _tokenId, address _claimant) external;\r\n    function isApprovedFor(uint _tokenId, address _claimant)\r\n        external constant returns (bool);\r\n    function createEditionMeta(uint _tokenId) public;\r\n    function getPaintingOwner(uint _tokenId)\r\n        external constant returns (address);\r\n    function getPaintingGeneration(uint _tokenId)\r\n        public constant returns (uint8);\r\n    function getPaintingSpeed(uint _tokenId)\r\n        external constant returns (uint8);\r\n    function getPaintingArtistId(uint _tokenId)\r\n        public constant returns (uint artistId);\r\n    function getOwnershipTokenCount(address _address)\r\n        external constant returns (uint);\r\n    function isReady(uint _tokenId) public constant returns (bool);\r\n    function getPaintingIdAtIndex(uint _index) public constant returns (uint);\r\n    function lastEditionOf(uint _index) public constant returns (uint);\r\n    function getPaintingOriginal(uint _tokenId)\r\n        external constant returns (uint);\r\n    function canBeBidden(uint _tokenId) public constant returns (bool _can);\r\n\r\n    function addAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _duration,\r\n        address _seller) public;\r\n    function addReleaseAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _startedAt,\r\n        uint _duration) public;\r\n    function initAuction(\r\n        uint _tokenId,\r\n        uint _startingPrice,\r\n        uint _endingPrice,\r\n        uint _startedAt,\r\n        uint _duration,\r\n        address _seller,\r\n        bool _byTeam) public;\r\n    function _isOnAuction(uint _tokenId) internal constant returns (bool);\r\n    function isOnAuction(uint _tokenId) external constant returns (bool);\r\n    function removeAuction(uint _tokenId) public;\r\n    function getAuction(uint256 _tokenId)\r\n        external constant returns (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt);\r\n    function getAuctionSeller(uint256 _tokenId)\r\n        public constant returns (address);\r\n    function getAuctionEnd(uint _tokenId)\r\n        public constant returns (uint);\r\n    function canBeCanceled(uint _tokenId) external constant returns (bool);\r\n    function getAuctionsCount() public constant returns (uint);\r\n    function getTokensOnAuction() public constant returns (uint[]);\r\n    function getTokenIdAtIndex(uint _index) public constant returns (uint);\r\n    function getAuctionStartedAt(uint256 _tokenId) public constant returns (uint);\r\n\r\n    function getOffsetIndex() public constant returns (uint);\r\n    function nextOffsetIndex() public returns (uint);\r\n    function canCreateEdition(uint _tokenId, uint8 _generation)\r\n        public constant returns (bool);\r\n    function isValidGeneration(uint8 _generation)\r\n        public constant returns (bool);\r\n    function increaseGenerationCount(uint _tokenId, uint8 _generation) public;\r\n    function getEditionsCount(uint _tokenId) external constant returns (uint8[3]);\r\n    function setLastEditionOf(uint _tokenId, uint _editionId) public;\r\n    function setEditionLimits(uint _tokenId, uint8 _gen1, uint8 _gen2, uint8 _gen3) public;\r\n    function getEditionLimits(uint _tokenId) external constant returns (uint8[3]);\r\n\r\n    function hasEditionInProgress(uint _tokenId) external constant returns (bool);\r\n    function hasEmptyEditionSlots(uint _tokenId) external constant returns (bool);\r\n\r\n    function setPaintingName(uint _tokenId, string _name) public;\r\n    function setPaintingArtist(uint _tokenId, string _name) public;\r\n    function purgeInformation(uint _tokenId) public;\r\n    function resetEditionLimits(uint _tokenId) public;\r\n    function resetPainting(uint _tokenId) public;\r\n    function decreaseSpeed(uint _tokenId) public;\r\n    function isCanceled(uint _tokenId) public constant returns (bool _is);\r\n    function totalPaintingsCount() public constant returns (uint _total);\r\n    function isSecondary(uint _tokenId) public constant returns (bool _is);\r\n    function secondarySaleCut() public constant returns (uint8 _cut);\r\n    function sealForChanges(uint _tokenId) public;\r\n    function canBeChanged(uint _tokenId) public constant returns (bool _can);\r\n\r\n    function getPaintingName(uint _tokenId) public constant returns (string);\r\n    function getPaintingArtist(uint _tokenId) public constant returns (string);\r\n\r\n    function signature() external constant returns (bytes4);\r\n}\r\n\r\n// File: contracts/libs/Ownable.sol\r\n\r\n/**\r\n* @title Ownable\r\n* @dev Manages ownership of the contracts\r\n*/\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function isOwner(address _address) public constant returns (bool) {\r\n        return _address == owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/libs/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @dev modifier to allow actions only when the contract IS paused\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to allow actions only when the contract IS NOT paused\r\n    */\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function _pause() internal whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function _unpause() internal whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n// File: contracts/libs/BitpaintingBase.sol\r\n\r\ncontract BitpaintingBase is Pausable {\r\n    /*** EVENTS ***/\r\n    event Create(uint _tokenId,\r\n        address _owner,\r\n        uint _parentId,\r\n        uint8 _generation,\r\n        uint _createdAt,\r\n        uint _completedAt);\r\n\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    IStorage public bitpaintingStorage;\r\n\r\n    modifier canPauseUnpause() {\r\n        require(msg.sender == owner || msg.sender == bitpaintingStorage.developer());\r\n        _;\r\n    }\r\n\r\n    function setBitpaintingStorage(address _address) public onlyOwner {\r\n        require(_address != address(0));\r\n        bitpaintingStorage = IStorage(_address);\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public canPauseUnpause whenNotPaused {\r\n        super._pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external canPauseUnpause whenPaused {\r\n        super._unpause();\r\n    }\r\n\r\n    function canUserReleaseArtwork(address _address)\r\n        public constant returns (bool _can) {\r\n        return (bitpaintingStorage.isOwner(_address)\r\n            || bitpaintingStorage.isAdmin(_address)\r\n            || bitpaintingStorage.isAllowed(_address));\r\n    }\r\n\r\n    function canUserCancelArtwork(address _address)\r\n        public constant returns (bool _can) {\r\n        return (bitpaintingStorage.isOwner(_address)\r\n            || bitpaintingStorage.isAdmin(_address));\r\n    }\r\n\r\n    modifier canReleaseArtwork() {\r\n        require(canUserReleaseArtwork(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier canCancelArtwork() {\r\n        require(canUserCancelArtwork(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns ownership of a specific Painting to an address.\r\n    function _transfer(address _from, address _to, uint256 _tokenId)\r\n        internal {\r\n        bitpaintingStorage.setOwnership(_tokenId, _to);\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _createOriginalPainting(uint _tokenId, uint _artistId, uint _releasedAt) internal {\r\n        address _owner = owner;\r\n        uint _parentId = 0;\r\n        uint8 _generation = 0;\r\n        uint8 _speed = 10;\r\n        _createPainting(_owner, _tokenId, _parentId, _generation, _speed, _artistId, _releasedAt);\r\n    }\r\n\r\n    function _createPainting(\r\n        address _owner,\r\n        uint _tokenId,\r\n        uint _parentId,\r\n        uint8 _generation,\r\n        uint8 _speed,\r\n        uint _artistId,\r\n        uint _releasedAt\r\n    )\r\n        internal\r\n    {\r\n        require(_tokenId == uint256(uint32(_tokenId)));\r\n        require(_parentId == uint256(uint32(_parentId)));\r\n        require(_generation == uint256(uint8(_generation)));\r\n\r\n        bitpaintingStorage.createPainting(\r\n            _owner, _tokenId, _parentId, _generation, _speed, _artistId, _releasedAt);\r\n\r\n        uint _createdAt;\r\n        uint _completedAt;\r\n        (,,_createdAt, _completedAt,,) = bitpaintingStorage.getPainting(_tokenId);\r\n\r\n        // emit the create event\r\n        Create(\r\n            _tokenId,\r\n            _owner,\r\n            _parentId,\r\n            _generation,\r\n            _createdAt,\r\n            _completedAt\r\n        );\r\n\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(0, _owner, _tokenId);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/libs/ERC721.sol\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public constant returns (uint256 total);\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external constant returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external constant returns (bool);\r\n}\r\n\r\n// File: contracts/libs/ERC721Metadata.sol\r\n\r\n/// @title The external contract that is responsible for generating metadata for the kitties,\r\n///  it has one function that will return the data as bytes.\r\ncontract ERC721Metadata {\r\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\r\n    function getMetadata(uint256 _tokenId, string) public constant returns (bytes32[4] buffer, uint256 count) {\r\n        if (_tokenId == 1) {\r\n            buffer[0] = \"Hello World! :D\";\r\n            count = 15;\r\n        } else if (_tokenId == 2) {\r\n            buffer[0] = \"I would definitely choose a medi\";\r\n            buffer[1] = \"um length string.\";\r\n            count = 49;\r\n        } else if (_tokenId == 3) {\r\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\r\n            buffer[2] = \" tristique vestibulum id, libero\";\r\n            buffer[3] = \" suscipit varius sapien aliquam.\";\r\n            count = 128;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libs/PaintingOwnership.sol\r\n\r\ncontract PaintingOwnership is BitpaintingBase, ERC721 {\r\n\r\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant name = \"BitPaintings\";\r\n    string public constant symbol = \"BP\";\r\n\r\n    ERC721Metadata public erc721Metadata;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('transfer(address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('tokensOfOwner(address)')) ^\r\n        bytes4(keccak256('tokenMetadata(uint256,string)'));\r\n\r\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\r\n    ///  ERC-165 (obviously!) and ERC-721.\r\n    function supportsInterface(bytes4 _interfaceID) external constant returns (bool)\r\n    {\r\n        // DEBUG ONLY\r\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\r\n\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    /// @dev Set the address of the sibling contract that tracks metadata.\r\n    ///  CEO only.\r\n    function setMetadataAddress(address _contractAddress) public onlyOwner {\r\n        erc721Metadata = ERC721Metadata(_contractAddress);\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal constant returns (bool) {\r\n        return bitpaintingStorage.getPaintingOwner(_tokenId) == _claimant;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 count) {\r\n        return bitpaintingStorage.getOwnershipTokenCount(_owner);\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        bitpaintingStorage.approve(_tokenId, _approved);\r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _tokenId)\r\n        internal constant returns (bool) {\r\n        return bitpaintingStorage.isApprovedFor(_tokenId, _claimant);\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function approve(\r\n      address _to,\r\n      uint256 _tokenId\r\n    )\r\n      external\r\n      whenNotPaused\r\n    {\r\n      require(_owns(msg.sender, _tokenId));\r\n      _approve(_tokenId, _to);\r\n\r\n      Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(\r\n      address _from,\r\n      address _to,\r\n      uint256 _tokenId\r\n    )\r\n        external whenNotPaused {\r\n        _transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _transferFrom(\r\n      address _from,\r\n      address _to,\r\n      uint256 _tokenId\r\n    )\r\n        internal\r\n        whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint) {\r\n      return bitpaintingStorage.paintingsCount();\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external constant returns (address) {\r\n        return _ownerOf(_tokenId);\r\n    }\r\n\r\n    function _ownerOf(uint256 _tokenId)\r\n        internal constant returns (address) {\r\n        return bitpaintingStorage.getPaintingOwner(_tokenId);\r\n    }\r\n\r\n    function tokensOfOwner(address _owner)\r\n        external constant returns(uint256[]) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n          return new uint256[](0);\r\n        }\r\n\r\n        uint256[] memory result = new uint256[](tokenCount);\r\n        uint256 totalCats = totalSupply();\r\n        uint256 resultIndex = 0;\r\n\r\n        uint256 paintingId;\r\n\r\n        for (paintingId = 1; paintingId <= totalCats; paintingId++) {\r\n            if (bitpaintingStorage.getPaintingOwner(paintingId) == _owner) {\r\n                result[resultIndex] = paintingId;\r\n                resultIndex++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _memcpy(uint _dest, uint _src, uint _len) private constant {\r\n      // Copy word-length chunks while possible\r\n      for(; _len >= 32; _len -= 32) {\r\n          assembly {\r\n              mstore(_dest, mload(_src))\r\n          }\r\n          _dest += 32;\r\n          _src += 32;\r\n      }\r\n\r\n      // Copy remaining bytes\r\n      uint256 mask = 256 ** (32 - _len) - 1;\r\n      assembly {\r\n          let srcpart := and(mload(_src), not(mask))\r\n          let destpart := and(mload(_dest), mask)\r\n          mstore(_dest, or(destpart, srcpart))\r\n      }\r\n    }\r\n\r\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private constant returns (string) {\r\n      var outputString = new string(_stringLength);\r\n      uint256 outputPtr;\r\n      uint256 bytesPtr;\r\n\r\n      assembly {\r\n          outputPtr := add(outputString, 32)\r\n          bytesPtr := _rawBytes\r\n      }\r\n\r\n      _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n      return outputString;\r\n    }\r\n\r\n    /// @notice Returns a URI pointing to a metadata package for this token conforming to\r\n    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\r\n    /// @param _tokenId The ID number of the Kitty whose metadata should be returned.\r\n    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external constant returns (string infoUrl) {\r\n      require(erc721Metadata != address(0));\r\n      bytes32[4] memory buffer;\r\n      uint256 count;\r\n      (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\r\n\r\n      return _toString(buffer, count);\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        owner.transfer(this.balance);\r\n    }\r\n}\r\n\r\n// File: contracts/BitpaintingPaintings.sol\r\n\r\ncontract BitpaintingPaintings is PaintingOwnership, IPaintings {\r\n\r\n    uint version = 2;\r\n\r\n    function release(\r\n        uint _tokenId,\r\n        uint _artistId,\r\n        uint _releasedAt,\r\n        uint8[] _gens,\r\n        uint _auctionStartingPrice,\r\n        uint _auctionEndingPrice,\r\n        uint _auctionDuration,\r\n        string _artist,\r\n        string _name\r\n    ) external canReleaseArtwork whenNotPaused {\r\n        _createOriginalPainting(_tokenId, _artistId, _releasedAt);\r\n        _approve(_tokenId, owner);\r\n        bitpaintingStorage.setEditionLimits(_tokenId, _gens[0], _gens[1],_gens[2]);\r\n        auctionsContract().createReleaseAuction(\r\n            _tokenId,\r\n            _auctionStartingPrice,\r\n            _auctionEndingPrice,\r\n            _releasedAt,\r\n            _auctionDuration);\r\n        bitpaintingStorage.setPaintingArtist(_tokenId, _artist);\r\n        bitpaintingStorage.setPaintingName(_tokenId, _name);\r\n    }\r\n\r\n    function releaseNow(\r\n        uint _tokenId,\r\n        uint _artistId,\r\n        uint8[] _gens,\r\n        uint _auctionStartingPrice,\r\n        uint _auctionEndingPrice,\r\n        uint _auctionDuration,\r\n        string _artist,\r\n        string _name\r\n    ) external canReleaseArtwork whenNotPaused {\r\n        uint _releasedAt = now;\r\n        _createOriginalPainting(_tokenId, _artistId, _releasedAt);\r\n        _approve(_tokenId, owner);\r\n        bitpaintingStorage.setEditionLimits(_tokenId, _gens[0], _gens[1],_gens[2]);\r\n        auctionsContract().createReleaseAuction(\r\n            _tokenId,\r\n            _auctionStartingPrice,\r\n            _auctionEndingPrice,\r\n            now, // _releasedAt\r\n            _auctionDuration);\r\n        bitpaintingStorage.setPaintingArtist(_tokenId, _artist);\r\n        bitpaintingStorage.setPaintingName(_tokenId, _name);\r\n    }\r\n\r\n    function cancel(uint _tokenId) external canCancelArtwork whenNotPaused {\r\n        require(bitpaintingStorage.isOnAuction(_tokenId));\r\n        require(bitpaintingStorage.canBeChanged(_tokenId));\r\n\r\n        bitpaintingStorage.resetPainting(_tokenId);\r\n        bitpaintingStorage.removeAuction(_tokenId);\r\n        bitpaintingStorage.resetEditionLimits(_tokenId);\r\n        bitpaintingStorage.purgeInformation(_tokenId);\r\n    }\r\n\r\n    function auctionsContract() internal returns (IAuctions auctions){\r\n        uint _signature = uint(keccak256(\"auctions\"));\r\n        return IAuctions(bitpaintingStorage.contracts(_signature));\r\n    }\r\n\r\n    function createPainting(uint _tokenId)\r\n        external canReleaseArtwork whenNotPaused {\r\n        _createOriginalPainting(_tokenId, 1, now);\r\n        _approve(_tokenId, owner);\r\n    }\r\n\r\n    function sendAsGift(address _to, uint _tokenId) external whenNotPaused {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_owns(msg.sender, _tokenId));\r\n        require(bitpaintingStorage.isReady(_tokenId));\r\n        require(!bitpaintingStorage.hasEditionInProgress(_tokenId));\r\n\r\n        if (bitpaintingStorage.isOnAuction(_tokenId)) {\r\n            bitpaintingStorage.removeAuction(_tokenId);\r\n        }\r\n\r\n        bitpaintingStorage.sealForChanges(_tokenId);\r\n        _transfer(msg.sender, _to, _tokenId);\r\n        bitpaintingStorage.increaseOwnershipTokenCount(_to);\r\n        bitpaintingStorage.decreaseOwnershipTokenCount(msg.sender);\r\n    }\r\n\r\n    function allTokenIds() public constant returns (uint[] tokenIds) {\r\n        uint len = bitpaintingStorage.totalPaintingsCount();\r\n        uint resultLen = bitpaintingStorage.paintingsCount();\r\n        tokenIds = new uint[](resultLen);\r\n        uint pointer = 0;\r\n        for (uint index = 0; index < len; index++) {\r\n            uint token = bitpaintingStorage.getPaintingIdAtIndex(index);\r\n            if (bitpaintingStorage.isCanceled(token)) {\r\n                continue;\r\n            }\r\n            tokenIds[pointer] = token;\r\n            pointer++;\r\n        }\r\n    }\r\n\r\n    function collectionOf(address _of) public constant returns (\r\n            uint[] tokens,\r\n            bool[] pending,\r\n            bool[] forSale,\r\n            bool[] locked,\r\n            uint8[] generations,\r\n            uint8[] speeds\r\n        ) {\r\n\r\n        uint tokenCount = bitpaintingStorage.totalPaintingsCount();\r\n        uint length = balanceOf(_of);\r\n        uint pointer;\r\n\r\n        tokens = new uint[](length);\r\n        pending = new bool[](length);\r\n        forSale = new bool[](length);\r\n        locked = new bool[](length);\r\n        generations = new uint8[](length);\r\n        speeds = new uint8[](length);\r\n\r\n        for(uint index = 0; index < tokenCount; index++) {\r\n            uint tokenId = bitpaintingStorage.getPaintingIdAtIndex(index);\r\n\r\n            if (_ownerOf(tokenId) != _of) {\r\n                continue;\r\n            }\r\n\r\n            uint _createdAt;\r\n            (,,_createdAt,,,) = bitpaintingStorage.getPainting(tokenId);\r\n            if (_createdAt == 0) {\r\n                continue;\r\n            }\r\n\r\n            tokens[pointer] = tokenId;\r\n            pending[pointer] = !bitpaintingStorage.isReady(tokenId);\r\n            forSale[pointer] = (bitpaintingStorage.getAuctionStartedAt(tokenId) > 0);\r\n            uint edition = bitpaintingStorage.lastEditionOf(tokenId);\r\n            if (edition == 0) {\r\n                locked[pointer] = false;\r\n            } else {\r\n                locked[pointer] = !bitpaintingStorage.isReady(edition);\r\n            }\r\n            generations[pointer] = bitpaintingStorage.getPaintingGeneration(tokenId);\r\n            speeds[pointer] = bitpaintingStorage.getPaintingSpeed(tokenId);\r\n\r\n            pointer++;\r\n        }\r\n\r\n    }\r\n\r\n    function collectionCountsOf(address _of) public constant\r\n        returns (uint total, uint pending, uint forSale) {\r\n        uint tokenCount = totalSupply();\r\n\r\n        for(uint index = 0; index < tokenCount; index++) {\r\n            uint tokenId = bitpaintingStorage.getPaintingIdAtIndex(index);\r\n\r\n            if (_ownerOf(tokenId) != _of) {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            if (bitpaintingStorage.isReady(tokenId)) {\r\n                if (bitpaintingStorage.getAuctionStartedAt(tokenId) > 0) {\r\n                    forSale++;\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            if (!bitpaintingStorage.isReady(tokenId)) {\r\n                pending++;\r\n                continue;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function signature() external constant returns (uint _signature) {\r\n        return uint(keccak256(\"paintings\"));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bitpaintingStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"canUserCancelArtwork\",\"outputs\":[{\"name\":\"_can\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setBitpaintingStorage\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_artistId\",\"type\":\"uint256\"},{\"name\":\"_releasedAt\",\"type\":\"uint256\"},{\"name\":\"_gens\",\"type\":\"uint8[]\"},{\"name\":\"_auctionStartingPrice\",\"type\":\"uint256\"},{\"name\":\"_auctionEndingPrice\",\"type\":\"uint256\"},{\"name\":\"_auctionDuration\",\"type\":\"uint256\"},{\"name\":\"_artist\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"collectionOf\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"name\":\"pending\",\"type\":\"bool[]\"},{\"name\":\"forSale\",\"type\":\"bool[]\"},{\"name\":\"locked\",\"type\":\"bool[]\"},{\"name\":\"generations\",\"type\":\"uint8[]\"},{\"name\":\"speeds\",\"type\":\"uint8[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signature\",\"outputs\":[{\"name\":\"_signature\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_artistId\",\"type\":\"uint256\"},{\"name\":\"_gens\",\"type\":\"uint8[]\"},{\"name\":\"_auctionStartingPrice\",\"type\":\"uint256\"},{\"name\":\"_auctionEndingPrice\",\"type\":\"uint256\"},{\"name\":\"_auctionDuration\",\"type\":\"uint256\"},{\"name\":\"_artist\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"releaseNow\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"address\"}],\"name\":\"collectionCountsOf\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"pending\",\"type\":\"uint256\"},{\"name\":\"forSale\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"canUserReleaseArtwork\",\"outputs\":[{\"name\":\"_can\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"sendAsGift\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allTokenIds\",\"outputs\":[{\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"createPainting\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_parentId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_generation\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_createdAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_completedAt\",\"type\":\"uint256\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"BitpaintingPaintings","CompilerVersion":"v0.4.15+commit.bbb8e64f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9f805fd8603b4a497290af0eadbc15cad492abd4053457d1a93edd73f97e2177"}]}