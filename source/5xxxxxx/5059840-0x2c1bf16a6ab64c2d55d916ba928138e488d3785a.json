{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() public constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {}\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    \r\n}\r\n\r\ncontract Owned{\r\n    address public owner;\r\n    function Owned(){\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    //Internal transfer, only can be called by this contract\r\n    function _transfer(address _from, address _to,uint256 _value) internal {\r\n        //prevent transfer to 0x0 address.\r\n        require(_to != 0x0);\r\n        //check if sender has enough tokens\r\n        require(balances[_from] >= _value);\r\n        //check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n\r\n        uint256 previousBalances = balances[_from]+balances[_to];\r\n        //subtract value from sender\r\n        balances[_from] -= _value;\r\n        //add value to receiver\r\n        balances[_to] += _value;\r\n        Transfer(_from,_to,_value);\r\n        //Assert are used for analysing statically if bugs resides\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        \r\n        _transfer(msg.sender,_to,_value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        \r\n        require(_value <= allowed[_from][msg.sender]);\r\n        allowed[_from][msg.sender] -= _value;\r\n        _transfer(_from,_to,_value);\r\n        return true;\r\n    }\r\n\r\n    //Return balance of the owner\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    //Approve the spender ammount\r\n    //set allowance for other address\r\n    // allows _spender to spend no more than _value tokens on your behalf\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n/**************************************/\r\n/*INTRODUCING ADVANCE FUNCTIONALITIES*/\r\n/*************************************/\r\n\r\ncontract XRTStandards is Owned,StandardToken\r\n{\r\n\r\n    //generate a public event on the blockchain\r\n\r\n    function _transfer(address _from, address _to,uint256 _value) internal {\r\n        //prevent transfer to 0x0 address.\r\n        require(_to != 0x0);\r\n        //check if sender has enough tokens\r\n        require(balances[_from] >= _value);\r\n        //check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n        //subtract value from sender\r\n        balances[_from] -= _value;\r\n        //add value to receiver\r\n        balances[_to] += _value;\r\n        Transfer(_from,_to,_value);\r\n    }\r\n\r\n}\r\n\r\ncontract XRTToken is XRTStandards {\r\n\r\n    uint256 public initialSupply;\r\n    string public name;                   // Token Name\r\n    uint8 public decimals;                // How many decimals to show. To be standard complicant keep it 18\r\n    string public symbol;                 // An identifier: eg SBX, XPR etc..\r\n    string public version; \r\n    uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH?\r\n    uint256 public totalEthInWei;         // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here.  \r\n    address public fundsWallet;           // Where should the raised ETH go?\r\n\r\n    // This is a constructor function \r\n    // which means the following function name has to match the contract name declared above\r\n    function XRTToken(uint256 _initialSupply, string t_name, string t_symbol,string t_version, uint8 decimalsUnits,uint256 OneEthValue) public {\r\n        initialSupply = _initialSupply;\r\n        decimals = decimalsUnits;                                               // Amount of decimals for display purposes (CHANGE THIS)\r\n        totalSupply = initialSupply*10**uint256(decimals);                        // Update total supply (1000 for example) (CHANGE THIS)\r\n        balances[msg.sender] = totalSupply;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS)\r\n        name = t_name;                                   // Set the name for display purposes (CHANGE THIS)\r\n        symbol = t_symbol;                                             // Set the symbol for display purposes (CHANGE THIS)\r\n        unitsOneEthCanBuy = OneEthValue*10**uint256(decimals);                                    \r\n        fundsWallet = msg.sender;\r\n        version = t_version;                                  \r\n    }\r\n\r\n    function() payable{\r\n        if (msg.value == 0) { return; }\r\n\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        if (balances[fundsWallet] < amount) {\r\n            return;\r\n        }\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain\r\n\r\n        //Transfer ether to fundsWallet\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(approve(_spender,_value)){\r\n            require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n            return true;\r\n        }    \r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unitsOneEthCanBuy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"t_name\",\"type\":\"string\"},{\"name\":\"t_symbol\",\"type\":\"string\"},{\"name\":\"t_version\",\"type\":\"string\"},{\"name\":\"decimalsUnits\",\"type\":\"uint8\"},{\"name\":\"OneEthValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"XRTToken","CompilerVersion":"v0.4.20-nightly.2018.1.29+commit.a668b9de","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000001312d0000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000001312d00000000000000000000000000000000000000000000000000000000000000000958525420546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035852540000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000458312e3000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://702bd8f19894a09600676042d33c1a656ff79f9b3772194401fe2d2c2cc96edb"}]}