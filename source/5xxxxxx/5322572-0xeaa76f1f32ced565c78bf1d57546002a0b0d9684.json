{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) internal pure  returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure  returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure  returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(address(0) != _newOwner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, msg.sender);\r\n        owner = msg.sender;\r\n        newOwner = address(0);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n\r\n// Crowdsale Smart Contract\r\n// This smart contract collects ETH and in return sends tokens to contributors\r\ncontract Crowdsale is Pausable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Backer {\r\n        uint weiReceived; // amount of ETH contributed\r\n        uint tokensToSend; // amount of tokens  sent\r\n        bool refunded;\r\n    }\r\n\r\n    Token public token; // Token contract reference\r\n    address public multisig; // Multisig contract that will receive the ETH\r\n    address public team; // Address at which the team tokens will be sent\r\n    uint public ethReceivedPresale; // Number of ETH received in presale\r\n    uint public ethReceivedMain; // Number of ETH received in public sale\r\n    uint public tokensSentPresale; // Tokens sent during presale\r\n    uint public tokensSentMain; // Tokens sent during public ICO\r\n    uint public totalTokensSent; // Total number of tokens sent to contributors\r\n    uint public startBlock; // Crowdsale start block\r\n    uint public endBlock; // Crowdsale end block\r\n    uint public maxCap; // Maximum number of tokens to sell\r\n    uint public minInvestETH; // Minimum amount to invest\r\n    bool public crowdsaleClosed; // Is crowdsale still in progress\r\n    Step public currentStep;  // To allow for controlled steps of the campaign\r\n    uint public refundCount;  // Number of refunds\r\n    uint public totalRefunded; // Total amount of Eth refunded\r\n    uint public numOfBlocksInMinute; // number of blocks in one minute * 100. eg.\r\n    WhiteList public whiteList;     // whitelist contract\r\n    uint public tokenPriceWei;      // Price of token in wei\r\n\r\n    mapping(address => Backer) public backers; // contributors list\r\n    address[] public backersIndex; // to be able to iterate through backers for verification.\r\n    uint public priorTokensSent;\r\n    uint public presaleCap;\r\n\r\n\r\n    // @notice to verify if action is not performed out of the campaign range\r\n    modifier respectTimeFrame() {\r\n        require(block.number >= startBlock && block.number <= endBlock);\r\n        _;\r\n    }\r\n\r\n    // @notice to set and determine steps of crowdsale\r\n    enum Step {\r\n        FundingPreSale,     // presale mode\r\n        FundingPublicSale,  // public mode\r\n        Refunding  // in case campaign failed during this step contributors will be able to receive refunds\r\n    }\r\n\r\n    // Events\r\n    event ReceivedETH(address indexed backer, uint amount, uint tokenAmount);\r\n    event RefundETH(address indexed backer, uint amount);\r\n\r\n    // Crowdsale  {constructor}\r\n    // @notice fired when contract is crated. Initializes all constant and initial values.\r\n    // @param _dollarToEtherRatio {uint} how many dollars are in one eth.  $333.44/ETH would be passed as 33344\r\n    function Crowdsale(WhiteList _whiteList) public {\r\n\r\n        require(_whiteList != address(0));\r\n        multisig = 0x10f78f2a70B52e6c3b490113c72Ba9A90ff1b5CA;\r\n        team = 0x10f78f2a70B52e6c3b490113c72Ba9A90ff1b5CA;\r\n        maxCap = 1510000000e8;\r\n        minInvestETH = 1 ether/2;\r\n        currentStep = Step.FundingPreSale;\r\n        numOfBlocksInMinute = 408;          // E.g. 4.38 block/per minute wold be entered as 438\r\n        priorTokensSent = 4365098999e7;     //tokens distributed in private sale and airdrops\r\n        whiteList = _whiteList;             // white list address\r\n        presaleCap = 160000000e8;           // max for sell in presale\r\n        tokenPriceWei = 57142857142857;     // 17500 tokens per ether\r\n    }\r\n\r\n    // @notice Specify address of token contract\r\n    // @param _tokenAddress {address} address of token contract\r\n    // @return res {bool}\r\n    function setTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\r\n        require(token == address(0));\r\n        token = _tokenAddress;\r\n        return true;\r\n    }\r\n\r\n    // @notice set the step of the campaign from presale to public sale\r\n    // contract is deployed in presale mode\r\n    // WARNING: there is no way to go back\r\n    function advanceStep() public onlyOwner() {\r\n        require(Step.FundingPreSale == currentStep);\r\n        currentStep = Step.FundingPublicSale;\r\n        minInvestETH = 1 ether/4;\r\n    }\r\n\r\n    // @notice in case refunds are needed, money can be returned to the contract\r\n    // and contract switched to mode refunding\r\n    function prepareRefund() public payable onlyOwner() {\r\n\r\n        require(crowdsaleClosed);\r\n        require(msg.value == ethReceivedPresale.add(ethReceivedMain)); // make sure that proper amount of ether is sent\r\n        currentStep = Step.Refunding;\r\n    }\r\n\r\n    // @notice return number of contributors\r\n    // @return  {uint} number of contributors\r\n    function numberOfBackers() public view returns(uint) {\r\n        return backersIndex.length;\r\n    }\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handles allocation of Ether and calculates tokens.\r\n    // Contributor will be instructed to specify sufficient amount of gas. e.g. 250,000\r\n    function () external payable {\r\n        contribute(msg.sender);\r\n    }\r\n\r\n    // @notice It will be called by owner to start the sale\r\n    function start(uint _block) external onlyOwner() {\r\n\r\n        require(startBlock == 0);\r\n        require(_block <= (numOfBlocksInMinute * 60 * 24 * 54)/100);  // allow max 54 days for campaign\r\n        startBlock = block.number;\r\n        endBlock = startBlock.add(_block);\r\n    }\r\n\r\n    // @notice Due to changing average of block time\r\n    // this function will allow on adjusting duration of campaign closer to the end\r\n    function adjustDuration(uint _block) external onlyOwner() {\r\n\r\n        require(startBlock > 0);\r\n        require(_block < (numOfBlocksInMinute * 60 * 24 * 60)/100); // allow for max of 60 days for campaign\r\n        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\r\n        endBlock = startBlock.add(_block);\r\n    }\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _backer {address} address of contributor\r\n    // @return res {bool} true if transaction was successful\r\n    function contribute(address _backer) internal whenNotPaused() respectTimeFrame() returns(bool res) {\r\n        require(!crowdsaleClosed);\r\n        require(whiteList.isWhiteListed(_backer));      // ensure that user is whitelisted\r\n\r\n        uint tokensToSend = determinePurchase();\r\n\r\n        Backer storage backer = backers[_backer];\r\n\r\n        if (backer.weiReceived == 0)\r\n            backersIndex.push(_backer);\r\n\r\n        backer.tokensToSend += tokensToSend; // save contributor's total tokens sent\r\n        backer.weiReceived = backer.weiReceived.add(msg.value);  // save contributor's total ether contributed\r\n\r\n        if (Step.FundingPublicSale == currentStep) { // Update the total Ether received and tokens sent during public sale\r\n            ethReceivedMain = ethReceivedMain.add(msg.value);\r\n            tokensSentMain += tokensToSend;\r\n        }else {                                                 // Update the total Ether recived and tokens sent during presale\r\n            ethReceivedPresale = ethReceivedPresale.add(msg.value);\r\n            tokensSentPresale += tokensToSend;\r\n        }\r\n\r\n        totalTokensSent += tokensToSend;     // update the total amount of tokens sent\r\n        multisig.transfer(address(this).balance);   // transfer funds to multisignature wallet\r\n\r\n        require(token.transfer(_backer, tokensToSend));   // Transfer tokens\r\n\r\n        emit ReceivedETH(_backer, msg.value, tokensToSend); // Register event\r\n        return true;\r\n    }\r\n\r\n    // @notice determine if purchase is valid and return proper number of tokens\r\n    // @return tokensToSend {uint} proper number of tokens based on the timline\r\n    function determinePurchase() internal view  returns (uint) {\r\n\r\n        require(msg.value >= minInvestETH);   // ensure that min contributions amount is met\r\n\r\n        uint tokensToSend = msg.value.mul(1e8) / tokenPriceWei;   //1e8 ensures that token gets 8 decimal values\r\n\r\n        if (Step.FundingPublicSale == currentStep) {  // calculate price of token in public sale\r\n            require(totalTokensSent + tokensToSend + priorTokensSent <= maxCap); // Ensure that max cap hasn't been reached\r\n        }else {\r\n            tokensToSend += (tokensToSend * 50) / 100;\r\n            require(totalTokensSent + tokensToSend <= presaleCap); // Ensure that max cap hasn't been reached for presale\r\n        }\r\n        return tokensToSend;\r\n    }\r\n\r\n\r\n    // @notice This function will finalize the sale.\r\n    // It will only execute if predetermined sale time passed or all tokens are sold.\r\n    // it will fail if minimum cap is not reached\r\n    function finalize() external onlyOwner() {\r\n\r\n        require(!crowdsaleClosed);\r\n        // purchasing precise number of tokens might be impractical, thus subtract 1000\r\n        // tokens so finalization is possible near the end\r\n        require(block.number >= endBlock || totalTokensSent + priorTokensSent >= maxCap - 1000);\r\n        crowdsaleClosed = true;\r\n\r\n        require(token.transfer(team, token.balanceOf(this))); // transfer all remaining tokens to team address\r\n        token.unlock();\r\n    }\r\n\r\n    // @notice Fail-safe drain\r\n    function drain() external onlyOwner() {\r\n        multisig.transfer(address(this).balance);\r\n    }\r\n\r\n    // @notice Fail-safe token transfer\r\n    function tokenDrain() external onlyOwner() {\r\n        if (block.number > endBlock) {\r\n            require(token.transfer(multisig, token.balanceOf(this)));\r\n        }\r\n    }\r\n\r\n    // @notice it will allow contributors to get refund in case campaign failed\r\n    // @return {bool} true if successful\r\n    function refund() external whenNotPaused() returns (bool) {\r\n\r\n        require(currentStep == Step.Refunding);\r\n\r\n        Backer storage backer = backers[msg.sender];\r\n\r\n        require(backer.weiReceived > 0);  // ensure that user has sent contribution\r\n        require(!backer.refunded);        // ensure that user hasn't been refunded yet\r\n\r\n        backer.refunded = true;  // save refund status to true\r\n        refundCount++;\r\n        totalRefunded = totalRefunded + backer.weiReceived;\r\n\r\n        require(token.transfer(msg.sender, backer.tokensToSend)); // return allocated tokens\r\n        msg.sender.transfer(backer.weiReceived);  // send back the contribution\r\n        emit RefundETH(msg.sender, backer.weiReceived);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns(uint);\r\n\r\n    function allowance(address owner, address spender) public view returns(uint);\r\n\r\n    function transfer(address to, uint value) public returns(bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) public returns(bool ok);\r\n\r\n    function approve(address spender, uint value) public returns(bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n// The token\r\ncontract Token is ERC20, Ownable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals; // How many decimals to show.\r\n    string public version = \"v0.1\";\r\n    uint public totalSupply;\r\n    bool public locked;\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    address public crowdSaleAddress;\r\n\r\n\r\n    // Lock transfer for contributors during the ICO\r\n    modifier onlyUnlocked() {\r\n        if (msg.sender != crowdSaleAddress && msg.sender != owner && locked)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        if (msg.sender != owner && msg.sender != crowdSaleAddress)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // @notice The Token contract\r\n    function Token(address _crowdsaleAddress) public {\r\n\r\n        require(_crowdsaleAddress != address(0));\r\n        locked = true; // Lock the transfer of tokens during the crowdsale\r\n        totalSupply = 2600000000e8;\r\n        name = \"Kripton\";                           // Set the name for display purposes\r\n        symbol = \"LPK\";                             // Set the symbol for display purposes\r\n        decimals = 8;                               // Amount of decimals\r\n        crowdSaleAddress = _crowdsaleAddress;\r\n        balances[_crowdsaleAddress] = totalSupply;\r\n    }\r\n\r\n    // @notice unlock token for trading\r\n    function unlock() public onlyAuthorized {\r\n        locked = false;\r\n    }\r\n\r\n    // @lock token from trading during ICO\r\n    function lock() public onlyAuthorized {\r\n        locked = true;\r\n    }\r\n\r\n    // @notice transfer tokens to given address\r\n    // @param _to {address} address or recipient\r\n    // @param _value {uint} amount to transfer\r\n    // @return  {bool} true if successful\r\n    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice transfer tokens from given address to another address\r\n    // @param _from {address} from whom tokens are transferred\r\n    // @param _to {address} to whom tokens are transferred\r\n    // @parm _value {uint} amount of tokens to transfer\r\n    // @return  {bool} true if successful\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns(bool success) {\r\n        require(balances[_from] >= _value); // Check if the sender has enough\r\n        require(_value <= allowed[_from][msg.sender]); // Check if allowed is greater or equal\r\n        balances[_from] = balances[_from].sub(_value); // Subtract from the sender\r\n        balances[_to] = balances[_to].add(_value); // Add the same to the recipient\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice to query balance of account\r\n    // @return _owner {address} address of user to query balance\r\n    function balanceOf(address _owner) public view returns(uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) public returns(bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice to query of allowance of one user to the other\r\n    // @param _owner {address} of the owner of the account\r\n    // @param _spender {address} of the spender of the account\r\n    // @return remaining {uint} amount of remaining allowance\r\n    function allowance(address _owner, address _spender) public view returns(uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    */\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// Whitelist smart contract\r\n// This smart contract keeps list of addresses to whitelist\r\ncontract WhiteList is Ownable {\r\n\r\n\r\n    mapping(address => bool) public whiteList;\r\n    uint public totalWhiteListed; //white listed users number\r\n\r\n    event LogWhiteListed(address indexed user, uint whiteListedNum);\r\n    event LogWhiteListedMultiple(uint whiteListedNum);\r\n    event LogRemoveWhiteListed(address indexed user);\r\n\r\n    // @notice it will return status of white listing\r\n    // @return true if user is white listed and false if is not\r\n    function isWhiteListed(address _user) external view returns (bool) {\r\n\r\n        return whiteList[_user];\r\n    }\r\n\r\n    // @notice it will remove whitelisted user\r\n    // @param _contributor {address} of user to unwhitelist\r\n    function removeFromWhiteList(address _user) external onlyOwner() {\r\n\r\n        require(whiteList[_user] == true);\r\n        whiteList[_user] = false;\r\n        totalWhiteListed--;\r\n        emit LogRemoveWhiteListed(_user);\r\n    }\r\n\r\n    // @notice it will white list one member\r\n    // @param _user {address} of user to whitelist\r\n    // @return true if successful\r\n    function addToWhiteList(address _user) external onlyOwner() {\r\n\r\n        if (whiteList[_user] != true) {\r\n            whiteList[_user] = true;\r\n            totalWhiteListed++;\r\n            emit LogWhiteListed(_user, totalWhiteListed);\r\n        }else\r\n\r\n            revert();\r\n    }\r\n\r\n    // @notice it will white list multiple members\r\n    // @param _user {address[]} of users to whitelist\r\n    // @return true if successful\r\n    function addToWhiteListMultiple(address[] _users) external onlyOwner() {\r\n\r\n        for (uint i = 0; i < _users.length; ++i) {\r\n\r\n            if (whiteList[_users[i]] != true) {\r\n                whiteList[_users[i]] = true;\r\n                totalWhiteListed++;\r\n            }\r\n        }\r\n        emit LogWhiteListedMultiple(totalWhiteListed);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"advanceStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"prepareRefund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priorTokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tokenDrain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"adjustDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfBlocksInMinute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSentPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"backers\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"tokensToSend\",\"type\":\"uint256\"},{\"name\":\"refunded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSentMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backersIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_whiteList\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"ReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ced4eb91efe1b708782afd33aa529a6a9ace6671","Library":"","SwarmSource":"bzzr://dcd77f946318d59971d3811a3cdebd9a6e5c19f2e529062fa8e091a14857ce2a"}]}