{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * Joule source codes are available at https://github.com/MyWishPlatform/joule\r\n * Joule UI is available at https://joule.mywish.io\r\n * Joule was made by MyWish team, please welcome to our site https://mywish.io\r\n */\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract JouleAPI {\r\n    event Invoked(address indexed _invoker, address indexed _address, bool _status, uint _usedGas);\r\n    event Registered(address indexed _registrant, address indexed _address, uint _timestamp, uint _gasLimit, uint _gasPrice);\r\n    event Unregistered(address indexed _registrant, address indexed _address, uint _timestamp, uint _gasLimit, uint _gasPrice, uint _amount);\r\n\r\n    /**\r\n     * @dev Registers the specified contract to invoke at the specified time with the specified gas and price.\r\n     * @notice Registration requires the specified amount of ETH in value, to cover invoke bonus. See getPrice method.\r\n     *\r\n     * @param _address      Contract's address. Contract MUST implements Checkable interface.\r\n     * @param _timestamp    Timestamp at what moment contract should be called. It MUST be in future.\r\n     * @param _gasLimit     Gas which will be posted to call.\r\n     * @param _gasPrice     Gas price which is recommended to use for this invocation.\r\n     * @return Amount of change.\r\n     */\r\n    function register(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external payable returns (uint);\r\n\r\n    /**\r\n     * @dev Registers the specified contract to invoke at the specified time with the specified gas and price.\r\n     * @notice Registration requires the specified amount of ETH in value, to cover invoke bonus. See getPrice method.\r\n     * @notice If value would be more then required (see getPrice) change will be returned to msg.sender (not to _registrant!).\r\n     *\r\n     * @param _registrant   Any address which will be owners for this registration. Only he can unregister. Useful for calling from contract.\r\n     * @param _address      Contract's address. Contract MUST implements Checkable interface.\r\n     * @param _timestamp    Timestamp at what moment contract should be called. It MUST be in future.\r\n     * @param _gasLimit     Gas which will be posted to call.\r\n     * @param _gasPrice     Gas price which is recommended to use for this invocation.\r\n     * @return Amount of change.\r\n     */\r\n    function registerFor(address _registrant, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) public payable returns (uint);\r\n\r\n    /**\r\n     * @dev Remove registration of the specified contract (with exact parameters) by the specified key. See findKey method for looking for key.\r\n     * @notice It returns not full amount of ETH.\r\n     * @notice Only registrant can remove their registration.\r\n     * @notice Only registrations in future can be removed.\r\n     *\r\n     * @param _key          Contract key, to fast finding during unregister. See findKey method for getting key.\r\n     * @param _address      Contract's address. Contract MUST implements Checkable interface.\r\n     * @param _timestamp    Timestamp at what moment contract should be called. It MUST be in future.\r\n     * @param _gasLimit     Gas which will be posted to call.\r\n     * @param _gasPrice     Gas price which is recommended to use for this invocation.\r\n     * @return Amount of refund.\r\n     */\r\n    function unregister(bytes32 _key, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external returns (uint);\r\n\r\n    /**\r\n     * @dev Invokes next contracts in the queue.\r\n     * @notice Eth amount to cover gas will be returned if gas price is equal or less then specified for contract. Check getTop for right gas price.\r\n     * @return Reward amount.\r\n     */\r\n    function invoke() public returns (uint);\r\n\r\n    /**\r\n     * @dev Invokes next contracts in the queue.\r\n     * @notice Eth amount to cover gas will be returned if gas price is equal or less then specified for contract. Check getTop for right gas price.\r\n     * @param _invoker Any address from which event will be threw. Useful for calling from contract.\r\n     * @return Reward amount.\r\n     */\r\n    function invokeFor(address _invoker) public returns (uint);\r\n\r\n    /**\r\n     * @dev Invokes the top contract in the queue.\r\n     * @notice Eth amount to cover gas will be returned if gas price is equal or less then specified for contract. Check getTop for right gas price.\r\n     * @return Reward amount.\r\n     */\r\n    function invokeOnce() public returns (uint);\r\n\r\n    /**\r\n     * @dev Invokes the top contract in the queue.\r\n     * @notice Eth amount to cover gas will be returned if gas price is equal or less then specified for contract. Check getTop for right gas price.\r\n     * @param _invoker Any address from which event will be threw. Useful for calling from contract.\r\n     * @return Reward amount.\r\n     */\r\n    function invokeOnceFor(address _invoker) public returns (uint);\r\n\r\n    /**\r\n     * @dev Calculates required to register amount of WEI.\r\n     *\r\n     * @param _gasLimit Gas which will be posted to call.\r\n     * @param _gasPrice Gas price which is recommended to use for this invocation.\r\n     * @return Amount in wei.\r\n     */\r\n    function getPrice(uint _gasLimit, uint _gasPrice) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets how many contracts are registered (and not invoked).\r\n     */\r\n    function getCount() public view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets top contract (the next to invoke).\r\n     *\r\n     * @return contractAddress  The contract address.\r\n     * @return timestamp        The invocation timestamp.\r\n     * @return gasLimit         The contract gas.\r\n     * @return gasPrice         The invocation expected price.\r\n     * @return invokeGas        The minimal amount of gas to invoke (including gas for joule).\r\n     * @return rewardAmount     The amount of reward for invocation.\r\n     */\r\n    function getTopOnce() external view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice,\r\n        uint invokeGas,\r\n        uint rewardAmount\r\n    );\r\n\r\n    /**\r\n     * @dev Gets one next contract by the specified previous in order to invoke.\r\n     *\r\n     * @param _contractAddress  The previous contract address.\r\n     * @param _timestamp        The previous invocation timestamp.\r\n     * @param _gasLimit         The previous invocation maximum gas.\r\n     * @param _gasPrice         The previous invocation expected price.\r\n     * @return contractAddress  The contract address.\r\n     * @return gasLimit         The contract gas.\r\n     * @return gasPrice         The invocation expected price.\r\n     * @return invokeGas        The minimal amount of gas to invoke (including gas for joule).\r\n     * @return rewardAmount     The amount of reward for invocation.\r\n     */\r\n    function getNextOnce(address _contractAddress,\r\n                     uint _timestamp,\r\n                     uint _gasLimit,\r\n                     uint _gasPrice) public view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice,\r\n        uint invokeGas,\r\n        uint rewardAmount\r\n    );\r\n\r\n    /**\r\n     * @dev Gets _count next contracts by the specified previous in order to invoke.\r\n     * @notice Unlike getTop this method return exact _count values.\r\n     *\r\n     * @param _count            The count of result contracts.\r\n     * @param _contractAddress  The previous contract address.\r\n     * @param _timestamp        The previous invocation timestamp.\r\n     * @param _gasLimit         The previous invocation maximum gas.\r\n     * @param _gasPrice         The previous invocation expected price.\r\n     * @return contractAddress  The contract address.\r\n     * @return gasLimit         The contract gas.\r\n     * @return gasPrice         The invocation expected price.\r\n     * @return invokeGas        The minimal amount of gas to invoke (including gas for joule).\r\n     * @return rewardAmount     The amount of reward for invocation.\r\n     */\r\n    function getNext(uint _count,\r\n                address _contractAddress,\r\n                uint _timestamp,\r\n                uint _gasLimit,\r\n                uint _gasPrice) external view returns (\r\n        address[] addresses,\r\n        uint[] timestamps,\r\n        uint[] gasLimits,\r\n        uint[] gasPrices,\r\n        uint[] invokeGases,\r\n        uint[] rewardAmounts\r\n    );\r\n\r\n    /**\r\n     * @dev Gets top _count contracts (in order to invoke).\r\n     *\r\n     * @param _count            How many records will be returned.\r\n     * @return addresses        The contracts addresses.\r\n     * @return timestamps       The invocation timestamps.\r\n     * @return gasLimits        The contract gas.\r\n     * @return gasPrices        The invocation expected price.\r\n     * @return invokeGases      The minimal amount of gas to invoke (including gas for joule).\r\n     * @return rewardAmounts    The amount of reward for invocation.\r\n     */\r\n    function getTop(uint _count) external view returns (\r\n        address[] addresses,\r\n        uint[] timestamps,\r\n        uint[] gasLimits,\r\n        uint[] gasPrices,\r\n        uint[] invokeGases,\r\n        uint[] rewardAmounts\r\n    );\r\n\r\n    /**\r\n     * @dev Finds key for the registration with exact parameters. Be careful, key might be changed because of other registrations.\r\n     * @param _address      Contract's address. Contract MUST implements Checkable interface.\r\n     * @param _timestamp    Timestamp at what moment contract should be called. It MUST be in future.\r\n     * @param _gasLimit     Gas which will be posted to call.\r\n     * @param _gasPrice     Gas price which is recommended to use for this invocation.\r\n     * @return _key         Key of the specified registration.\r\n     */\r\n    function findKey(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) public view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Gets actual code version.\r\n     * @return Code version. Mask: 0xff.0xff.0xffff-0xffffffff (major.minor.build-hash)\r\n     */\r\n    function getVersion() external view returns (bytes8);\r\n\r\n    /**\r\n     * @dev Gets minimal gas price, specified by maintainer.\r\n     */\r\n    function getMinGasPrice() public view returns (uint);\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\ncontract TransferToken is Ownable {\r\n    function transferToken(ERC20Basic _token, address _to, uint _value) public onlyOwner {\r\n        _token.transfer(_to, _value);\r\n    }\r\n}\r\ncontract JouleProxyAPI {\r\n    /**\r\n     * Function hash is: 0x73027f6d\r\n     */\r\n    function callback(address _invoker, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) public returns (bool);\r\n}\r\ncontract CheckableContract {\r\n    event Checked();\r\n    /*\r\n     * Function hash is 0x919840ad.\r\n     */\r\n    function check() public;\r\n}\r\n\r\ncontract usingConsts {\r\n    uint constant GWEI = 0.001 szabo;\r\n\r\n    // this values influence to the reward price! do not change for already registered contracts!\r\n    uint constant TRANSACTION_GAS = 22000;\r\n    // remaining gas - amount of gas to finish transaction after invoke\r\n    uint constant REMAINING_GAS = 30000;\r\n    // joule gas - gas to joule (including proxy and others) invocation, excluding contract gas\r\n    uint constant JOULE_GAS = TRANSACTION_GAS + REMAINING_GAS + 8000;\r\n    // gas required to invoke, but all gas would be returned or not used, so it is rewarded\r\n    uint constant JOULE_INVOKE_GAS = 10000;\r\n    // there is correlation between amount of registered gas and required gas to invoke - 5%\r\n    uint constant JOULE_INVOKE_GAS_PERCENT = 5;\r\n\r\n    // minimal default gas price (because of network load)\r\n    uint32 constant DEFAULT_MIN_GAS_PRICE_GWEI = 20;\r\n    // min gas price\r\n    uint constant MIN_GAS_PRICE = GWEI;\r\n    // max gas price\r\n    uint constant MAX_GAS_PRICE = 0xffffffff * GWEI;\r\n    // not, it mist be less then 0x00ffffff, because high bytes might be used for storing flags\r\n    uint constant MAX_GAS = 4000000;\r\n    // Code version\r\n    bytes8 constant VERSION = 0x010800b10266e773;\r\n    //                          ^^ - major\r\n    //                            ^^ - minor\r\n    //                              ^^^^ - build\r\n    //                                  ^^^^^^^^ - git hash\r\n}\r\n\r\n\r\n\r\nlibrary KeysUtils {\r\n    // Such order is important to load from state\r\n    struct Object {\r\n        uint32 gasPriceGwei;\r\n        uint32 gasLimit;\r\n        uint32 timestamp;\r\n        address contractAddress;\r\n    }\r\n\r\n    function toKey(Object _obj) internal pure returns (bytes32) {\r\n        return toKey(_obj.contractAddress, _obj.timestamp, _obj.gasLimit, _obj.gasPriceGwei);\r\n    }\r\n\r\n    function toKeyFromStorage(Object storage _obj) internal view returns (bytes32 _key) {\r\n        assembly {\r\n            _key := sload(_obj_slot)\r\n        }\r\n    }\r\n\r\n    function toKey(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) internal pure returns (bytes32 result) {\r\n        result = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        //         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ - address (20 bytes)\r\n        //                                                 ^^^^^^^^ - timestamp (4 bytes)\r\n        //                                                         ^^^^^^^^ - gas limit (4 bytes)\r\n        //                                                                 ^^^^^^^^ - gas price (4 bytes)\r\n        assembly {\r\n            result := or(result, mul(_address, 0x1000000000000000000000000))\r\n            result := or(result, mul(and(_timestamp, 0xffffffff), 0x10000000000000000))\r\n            result := or(result, mul(and(_gasLimit, 0xffffffff), 0x100000000))\r\n            result := or(result, and(_gasPrice, 0xffffffff))\r\n        }\r\n    }\r\n\r\n    function toMemoryObject(bytes32 _key, Object memory _dest) internal pure {\r\n        assembly {\r\n            mstore(_dest, and(_key, 0xffffffff))\r\n            mstore(add(_dest, 0x20), and(div(_key, 0x100000000), 0xffffffff))\r\n            mstore(add(_dest, 0x40), and(div(_key, 0x10000000000000000), 0xffffffff))\r\n            mstore(add(_dest, 0x60), div(_key, 0x1000000000000000000000000))\r\n        }\r\n    }\r\n\r\n    function toObject(bytes32 _key) internal pure returns (Object memory _dest) {\r\n        toMemoryObject(_key, _dest);\r\n    }\r\n\r\n    function toStateObject(bytes32 _key, Object storage _dest) internal {\r\n        assembly {\r\n            sstore(_dest_slot, _key)\r\n        }\r\n    }\r\n\r\n    function getTimestamp(bytes32 _key) internal pure returns (uint result) {\r\n        assembly {\r\n            result := and(div(_key, 0x10000000000000000), 0xffffffff)\r\n        }\r\n    }\r\n}\r\n\r\ncontract Restriction {\r\n    mapping (address => bool) internal accesses;\r\n\r\n    function Restriction() public {\r\n        accesses[msg.sender] = true;\r\n    }\r\n\r\n    function giveAccess(address _addr) public restricted {\r\n        accesses[_addr] = true;\r\n    }\r\n\r\n    function removeAccess(address _addr) public restricted {\r\n        delete accesses[_addr];\r\n    }\r\n\r\n    function hasAccess() public constant returns (bool) {\r\n        return accesses[msg.sender];\r\n    }\r\n\r\n    modifier restricted() {\r\n        require(hasAccess());\r\n        _;\r\n    }\r\n}\r\n\r\ncontract JouleStorage is Restriction {\r\n    mapping(bytes32 => bytes32) map;\r\n\r\n    function get(bytes32 _key) public view returns (bytes32 _value) {\r\n        return map[_key];\r\n    }\r\n\r\n    function set(bytes32 _key, bytes32 _value) public restricted {\r\n        map[_key] = _value;\r\n    }\r\n\r\n    function del(bytes32 _key) public restricted {\r\n        delete map[_key];\r\n    }\r\n\r\n    function getAndDel(bytes32 _key) public restricted returns (bytes32 _value) {\r\n        _value = map[_key];\r\n        delete map[_key];\r\n    }\r\n\r\n    function swap(bytes32 _from, bytes32 _to) public restricted returns (bytes32 _value) {\r\n        _value = map[_to];\r\n        map[_to] = map[_from];\r\n        delete map[_from];\r\n    }\r\n}\r\n\r\ncontract JouleIndexCore {\r\n    using KeysUtils for bytes32;\r\n    uint constant YEAR = 0x1DFE200;\r\n    bytes32 constant HEAD = 0x0;\r\n\r\n    // YEAR -> week -> hour -> minute\r\n    JouleStorage public state;\r\n\r\n    function JouleIndexCore(JouleStorage _storage) public {\r\n        state = _storage;\r\n    }\r\n\r\n    function insertIndex(bytes32 _key) internal {\r\n        uint timestamp = _key.getTimestamp();\r\n        bytes32 year = toKey(timestamp, YEAR);\r\n        bytes32 headLow;\r\n        bytes32 headHigh;\r\n        (headLow, headHigh) = fromValue(state.get(HEAD));\r\n        if (year < headLow || headLow == 0 || year > headHigh) {\r\n            if (year < headLow || headLow == 0) {\r\n                headLow = year;\r\n            }\r\n            if (year > headHigh) {\r\n                headHigh = year;\r\n            }\r\n            state.set(HEAD, toValue(headLow, headHigh));\r\n        }\r\n\r\n        bytes32 week = toKey(timestamp, 1 weeks);\r\n        bytes32 low;\r\n        bytes32 high;\r\n        (low, high) = fromValue(state.get(year));\r\n        if (week < low || week > high) {\r\n            if (week < low || low == 0) {\r\n                low = week;\r\n            }\r\n            if (week > high) {\r\n                high = week;\r\n            }\r\n            state.set(year, toValue(low, high));\r\n        }\r\n\r\n        (low, high) = fromValue(state.get(week));\r\n        bytes32 hour = toKey(timestamp, 1 hours);\r\n        if (hour < low || hour > high) {\r\n            if (hour < low || low == 0) {\r\n                low = hour;\r\n            }\r\n            if (hour > high) {\r\n                high = hour;\r\n            }\r\n            state.set(week, toValue(low, high));\r\n        }\r\n\r\n        (low, high) = fromValue(state.get(hour));\r\n        bytes32 minute = toKey(timestamp, 1 minutes);\r\n        if (minute < low || minute > high) {\r\n            if (minute < low || low == 0) {\r\n                low = minute;\r\n            }\r\n            if (minute > high) {\r\n                high = minute;\r\n            }\r\n            state.set(hour, toValue(low, high));\r\n        }\r\n\r\n        (low, high) = fromValue(state.get(minute));\r\n        bytes32 tsKey = toKey(timestamp);\r\n        if (tsKey < low || tsKey > high) {\r\n            if (tsKey < low || low == 0) {\r\n                low = tsKey;\r\n            }\r\n            if (tsKey > high) {\r\n                high = tsKey;\r\n            }\r\n            state.set(minute, toValue(low, high));\r\n        }\r\n\r\n        state.set(tsKey, _key);\r\n    }\r\n\r\n    /**\r\n     * @dev Update key value from the previous state to new. Timestamp MUST be the same on both keys.\r\n     */\r\n    function updateIndex(bytes32 _prev, bytes32 _key) internal {\r\n        uint timestamp = _key.getTimestamp();\r\n        bytes32 tsKey = toKey(timestamp);\r\n        bytes32 prevKey = state.get(tsKey);\r\n        // on the same timestamp might be other key, in that case we do not need to update it\r\n        if (prevKey != _prev) {\r\n            return;\r\n        }\r\n        state.set(tsKey, _key);\r\n    }\r\n\r\n    function findFloorKeyYear(uint _timestamp, bytes32 _low, bytes32 _high) view private returns (bytes32) {\r\n        bytes32 year = toKey(_timestamp, YEAR);\r\n        if (year < _low) {\r\n            return 0;\r\n        }\r\n        if (year > _high) {\r\n            // week\r\n            (low, high) = fromValue(state.get(_high));\r\n            // hour\r\n            (low, high) = fromValue(state.get(high));\r\n            // minute\r\n            (low, high) = fromValue(state.get(high));\r\n            // ts\r\n            (low, high) = fromValue(state.get(high));\r\n            return state.get(high);\r\n        }\r\n\r\n        bytes32 low;\r\n        bytes32 high;\r\n\r\n        while (year >= _low) {\r\n            (low, high) = fromValue(state.get(year));\r\n            if (low != 0) {\r\n                bytes32 key = findFloorKeyWeek(_timestamp, low, high);\r\n                if (key != 0) {\r\n                    return key;\r\n                }\r\n            }\r\n            // 0x1DFE200 = 52 weeks = 31449600\r\n            assembly {\r\n                year := sub(year, 0x1DFE200)\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function findFloorKeyWeek(uint _timestamp, bytes32 _low, bytes32 _high) view private returns (bytes32) {\r\n        bytes32 week = toKey(_timestamp, 1 weeks);\r\n        if (week < _low) {\r\n            return 0;\r\n        }\r\n\r\n        bytes32 low;\r\n        bytes32 high;\r\n\r\n        if (week > _high) {\r\n            // hour\r\n            (low, high) = fromValue(state.get(_high));\r\n            // minute\r\n            (low, high) = fromValue(state.get(high));\r\n            // ts\r\n            (low, high) = fromValue(state.get(high));\r\n            return state.get(high);\r\n        }\r\n\r\n        while (week >= _low) {\r\n            (low, high) = fromValue(state.get(week));\r\n            if (low != 0) {\r\n                bytes32 key = findFloorKeyHour(_timestamp, low, high);\r\n                if (key != 0) {\r\n                    return key;\r\n                }\r\n            }\r\n\r\n            // 1 weeks = 604800\r\n            assembly {\r\n                week := sub(week, 604800)\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\n    function findFloorKeyHour(uint _timestamp, bytes32 _low, bytes32 _high) view private returns (bytes32) {\r\n        bytes32 hour = toKey(_timestamp, 1 hours);\r\n        if (hour < _low) {\r\n            return 0;\r\n        }\r\n\r\n        bytes32 low;\r\n        bytes32 high;\r\n\r\n        if (hour > _high) {\r\n            // minute\r\n            (low, high) = fromValue(state.get(_high));\r\n            // ts\r\n            (low, high) = fromValue(state.get(high));\r\n            return state.get(high);\r\n        }\r\n\r\n        while (hour >= _low) {\r\n            (low, high) = fromValue(state.get(hour));\r\n            if (low != 0) {\r\n                bytes32 key = findFloorKeyMinute(_timestamp, low, high);\r\n                if (key != 0) {\r\n                    return key;\r\n                }\r\n            }\r\n\r\n            // 1 hours = 3600\r\n            assembly {\r\n                hour := sub(hour, 3600)\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function findFloorKeyMinute(uint _timestamp, bytes32 _low, bytes32 _high) view private returns (bytes32) {\r\n        bytes32 minute = toKey(_timestamp, 1 minutes);\r\n        if (minute < _low) {\r\n            return 0;\r\n        }\r\n\r\n        bytes32 low;\r\n        bytes32 high;\r\n\r\n        if (minute > _high) {\r\n            // ts\r\n            (low, high) = fromValue(state.get(_high));\r\n            return state.get(high);\r\n        }\r\n\r\n        while (minute >= _low) {\r\n            (low, high) = fromValue(state.get(minute));\r\n            if (low != 0) {\r\n                bytes32 key = findFloorKeyTimestamp(_timestamp, low, high);\r\n                if (key != 0) {\r\n                    return key;\r\n                }\r\n            }\r\n\r\n            // 1 minutes = 60\r\n            assembly {\r\n                minute := sub(minute, 60)\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function findFloorKeyTimestamp(uint _timestamp, bytes32 _low, bytes32 _high) view private returns (bytes32) {\r\n        bytes32 tsKey = toKey(_timestamp);\r\n        if (tsKey < _low) {\r\n            return 0;\r\n        }\r\n        if (tsKey > _high) {\r\n            return state.get(_high);\r\n        }\r\n\r\n        while (tsKey >= _low) {\r\n            bytes32 key = state.get(tsKey);\r\n            if (key != 0) {\r\n                return key;\r\n            }\r\n            assembly {\r\n                tsKey := sub(tsKey, 1)\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function findFloorKeyIndex(uint _timestamp) view internal returns (bytes32) {\r\n//        require(_timestamp > 0xffffffff);\r\n//        if (_timestamp < 1515612415) {\r\n//            return 0;\r\n//        }\r\n\r\n        bytes32 yearLow;\r\n        bytes32 yearHigh;\r\n        (yearLow, yearHigh) = fromValue(state.get(HEAD));\r\n\r\n        return findFloorKeyYear(_timestamp, yearLow, yearHigh);\r\n    }\r\n\r\n    function toKey(uint _timestamp, uint rounder) pure private returns (bytes32 result) {\r\n        // 0x0...00000000000000000\r\n        //        ^^^^^^^^ - rounder marker (eg, to avoid crossing first day of year with year)\r\n        //                ^^^^^^^^ - rounded moment (year, week, etc)\r\n        assembly {\r\n            result := or(mul(rounder, 0x100000000), mul(div(_timestamp, rounder), rounder))\r\n        }\r\n    }\r\n\r\n    function toValue(bytes32 _lowKey, bytes32 _highKey) pure private returns (bytes32 result) {\r\n        assembly {\r\n            result := or(mul(_lowKey, 0x10000000000000000), _highKey)\r\n        }\r\n    }\r\n\r\n    function fromValue(bytes32 _value) pure private returns (bytes32 _lowKey, bytes32 _highKey) {\r\n        assembly {\r\n            _lowKey := and(div(_value, 0x10000000000000000), 0xffffffffffffffff)\r\n            _highKey := and(_value, 0xffffffffffffffff)\r\n        }\r\n    }\r\n\r\n    function toKey(uint timestamp) pure internal returns (bytes32) {\r\n        return bytes32(timestamp);\r\n    }\r\n}\r\n\r\n\r\ncontract JouleContractHolder is JouleIndexCore, usingConsts {\r\n    using KeysUtils for bytes32;\r\n    uint internal length;\r\n    bytes32 public head;\r\n\r\n    function JouleContractHolder(bytes32 _head, uint _length, JouleStorage _storage) public\r\n            JouleIndexCore(_storage) {\r\n        head = _head;\r\n        length = _length;\r\n    }\r\n\r\n    function insert(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) internal {\r\n        length ++;\r\n        bytes32 id = KeysUtils.toKey(_address, _timestamp, _gasLimit, _gasPrice);\r\n        if (head == 0) {\r\n            head = id;\r\n            insertIndex(id);\r\n//            Found(0xffffffff);\r\n            return;\r\n        }\r\n        bytes32 previous = findFloorKeyIndex(_timestamp);\r\n\r\n        // reject duplicate key on the end\r\n        require(previous != id);\r\n        // reject duplicate in the middle\r\n        require(state.get(id) == 0);\r\n\r\n        uint prevTimestamp = previous.getTimestamp();\r\n//        Found(prevTimestamp);\r\n        uint headTimestamp = head.getTimestamp();\r\n        // add as head, prevTimestamp == 0 or in the past\r\n        if (prevTimestamp < headTimestamp) {\r\n            state.set(id, head);\r\n            head = id;\r\n        }\r\n        // add after the previous\r\n        else {\r\n            state.set(id, state.get(previous));\r\n            state.set(previous, id);\r\n        }\r\n        insertIndex(id);\r\n    }\r\n\r\n    function updateGas(bytes32 _key, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice, uint _newGasLimit) internal {\r\n        bytes32 id = KeysUtils.toKey(_address, _timestamp, _gasLimit, _gasPrice);\r\n        bytes32 newId = KeysUtils.toKey(_address, _timestamp, _newGasLimit, _gasPrice);\r\n        if (id == head) {\r\n            head = newId;\r\n        }\r\n        else {\r\n            require(state.get(_key) == id);\r\n            state.set(_key, newId);\r\n        }\r\n        state.swap(id, newId);\r\n        updateIndex(id, newId);\r\n    }\r\n\r\n    function next() internal {\r\n        head = state.getAndDel(head);\r\n        length--;\r\n    }\r\n\r\n    function getCount() public view returns (uint) {\r\n        return length;\r\n    }\r\n\r\n    function getRecord(bytes32 _parent) internal view returns (bytes32 _record) {\r\n        if (_parent == 0) {\r\n            _record = head;\r\n        }\r\n        else {\r\n            _record = state.get(_parent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Find previous key for existing value.\r\n     */\r\n    function findPrevious(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) internal view returns (bytes32) {\r\n        bytes32 target = KeysUtils.toKey(_address, _timestamp, _gasLimit, _gasPrice);\r\n        bytes32 previous = head;\r\n        if (target == previous) {\r\n            return 0;\r\n        }\r\n        // if it is not head time\r\n        if (_timestamp != previous.getTimestamp()) {\r\n            previous = findFloorKeyIndex(_timestamp - 1);\r\n        }\r\n        bytes32 current = state.get(previous);\r\n        while (current != target) {\r\n            previous = current;\r\n            current = state.get(previous);\r\n        }\r\n        return previous;\r\n    }\r\n}\r\n\r\ncontract JouleVault is Ownable {\r\n    address public joule;\r\n\r\n    function setJoule(address _joule) public onlyOwner {\r\n        joule = _joule;\r\n    }\r\n\r\n    modifier onlyJoule() {\r\n        require(msg.sender == address(joule));\r\n        _;\r\n    }\r\n\r\n    function withdraw(address _receiver, uint _amount) public onlyJoule {\r\n        _receiver.transfer(_amount);\r\n    }\r\n\r\n    function () public payable {\r\n\r\n    }\r\n}\r\n\r\ncontract JouleCore is JouleContractHolder {\r\n    event Gas(uint);\r\n    JouleVault public vault;\r\n    uint32 public minGasPriceGwei = DEFAULT_MIN_GAS_PRICE_GWEI;\r\n    using KeysUtils for bytes32;\r\n\r\n    function JouleCore(JouleVault _vault, bytes32 _head, uint _length, JouleStorage _storage) public\r\n        JouleContractHolder(_head, _length, _storage) {\r\n        vault = _vault;\r\n    }\r\n\r\n    function innerRegister(address _registrant, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) internal returns (uint) {\r\n        uint price = getPriceInner(_gasLimit, _gasPrice);\r\n        require(msg.value >= price);\r\n        vault.transfer(price);\r\n\r\n        // this restriction to avoid attack to brake index tree (crossing key)\r\n        require(_address != 0);\r\n        require(_timestamp > now);\r\n        require(_timestamp < 0x100000000);\r\n        require(_gasLimit <= MAX_GAS);\r\n        require(_gasLimit != 0);\r\n        // from 1 gwei to 0x100000000 gwei\r\n        require(_gasPrice >= minGasPriceGwei * GWEI);\r\n        require(_gasPrice < MAX_GAS_PRICE);\r\n        // 0 means not yet registered\r\n        require(_registrant != 0x0);\r\n\r\n        uint innerGasPrice = _gasPrice / GWEI;\r\n        insert(_address, _timestamp, _gasLimit, innerGasPrice);\r\n        saveRegistrant(_registrant, _address, _timestamp, _gasLimit, innerGasPrice);\r\n\r\n        if (msg.value > price) {\r\n            msg.sender.transfer(msg.value - price);\r\n            return msg.value - price;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function saveRegistrant(address _registrant, address _address, uint _timestamp, uint, uint) internal {\r\n        bytes32 id = KeysUtils.toKey(_address, _timestamp, 0, 0);\r\n        require(state.get(id) == 0);\r\n        state.set(id, bytes32(_registrant));\r\n    }\r\n\r\n    function getRegistrant(address _address, uint _timestamp, uint, uint) internal view returns (address) {\r\n        bytes32 id = KeysUtils.toKey(_address, _timestamp, 0, 0);\r\n        return address(state.get(id));\r\n    }\r\n\r\n    function delRegistrant(KeysUtils.Object memory current) internal {\r\n        bytes32 id = KeysUtils.toKey(current.contractAddress, current.timestamp, 0, 0);\r\n        state.del(id);\r\n    }\r\n\r\n    function findKey(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) public view returns (bytes32) {\r\n        require(_address != 0);\r\n        require(_timestamp > now);\r\n        require(_timestamp < 0x100000000);\r\n        require(_gasLimit <= MAX_GAS);\r\n        require(_gasPrice > GWEI);\r\n        require(_gasPrice < 0x100000000 * GWEI);\r\n        return findPrevious(_address, _timestamp, _gasLimit, _gasPrice / GWEI);\r\n    }\r\n\r\n    function innerUnregister(address _registrant, bytes32 _key, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) internal returns (uint) {\r\n        // only future registrations might be updated, to avoid race condition in block (with invoke)\r\n        require(_timestamp > now);\r\n        // to avoid removing already removed keys\r\n        require(_gasLimit != 0);\r\n        uint innerGasPrice = _gasPrice / GWEI;\r\n        // check registrant\r\n        address registrant = getRegistrant(_address, _timestamp, _gasLimit, innerGasPrice);\r\n        require(registrant == _registrant);\r\n\r\n        updateGas(_key, _address, _timestamp, _gasLimit, innerGasPrice, 0);\r\n        uint amount = _gasLimit * _gasPrice;\r\n        if (amount != 0) {\r\n            vault.withdraw(registrant, amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function getPrice(uint _gasLimit, uint _gasPrice) external view returns (uint) {\r\n        require(_gasLimit <= MAX_GAS);\r\n        require(_gasPrice > GWEI);\r\n        require(_gasPrice < 0x100000000 * GWEI);\r\n\r\n        return getPriceInner(_gasLimit, _gasPrice);\r\n    }\r\n\r\n    function getPriceInner(uint _gasLimit, uint _gasPrice) internal pure returns (uint) {\r\n        // if this logic will be changed, look also to the innerUnregister method\r\n        return (_gasLimit + JOULE_GAS) * _gasPrice;\r\n    }\r\n\r\n    function getVersion() external view returns (bytes8) {\r\n        return VERSION;\r\n    }\r\n\r\n    function getTop(uint _count) external view returns (\r\n        address[] _addresses,\r\n        uint[] _timestamps,\r\n        uint[] _gasLimits,\r\n        uint[] _gasPrices,\r\n        uint[] _invokeGases,\r\n        uint[] _rewardAmounts\r\n    ) {\r\n        uint amount = _count <= length ? _count : length;\r\n\r\n        _addresses = new address[](amount);\r\n        _timestamps = new uint[](amount);\r\n        _gasLimits = new uint[](amount);\r\n        _gasPrices = new uint[](amount);\r\n        _invokeGases = new uint[](amount);\r\n        _rewardAmounts = new uint[](amount);\r\n\r\n        bytes32 current = getRecord(0);\r\n        for (uint i = 0; i < amount; i ++) {\r\n            KeysUtils.Object memory obj = current.toObject();\r\n            _addresses[i] = obj.contractAddress;\r\n            _timestamps[i] = obj.timestamp;\r\n            _gasLimits[i] = obj.gasLimit;\r\n            _gasPrices[i] = obj.gasPriceGwei * GWEI;\r\n            _invokeGases[i] = calcInvokeGas(obj.gasLimit);\r\n            _rewardAmounts[i] = calcReward(obj.gasLimit, obj.gasPriceGwei);\r\n            current = getRecord(current);\r\n        }\r\n    }\r\n\r\n    function getTopOnce() external view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice,\r\n        uint invokeGas,\r\n        uint rewardAmount\r\n    ) {\r\n        KeysUtils.Object memory obj = getRecord(0).toObject();\r\n\r\n        contractAddress = obj.contractAddress;\r\n        timestamp = obj.timestamp;\r\n        gasLimit = obj.gasLimit;\r\n        gasPrice = obj.gasPriceGwei * GWEI;\r\n        invokeGas = calcInvokeGas(obj.gasLimit);\r\n        rewardAmount = calcReward(obj.gasLimit, obj.gasPriceGwei);\r\n    }\r\n\r\n    function getNextOnce(address _contractAddress,\r\n                     uint _timestamp,\r\n                     uint _gasLimit,\r\n                     uint _gasPrice) public view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice,\r\n        uint invokeGas,\r\n        uint rewardAmount\r\n    ) {\r\n        if (_timestamp == 0) {\r\n            return this.getTopOnce();\r\n        }\r\n\r\n        bytes32 prev = KeysUtils.toKey(_contractAddress, _timestamp, _gasLimit, _gasPrice / GWEI);\r\n        bytes32 current = getRecord(prev);\r\n        KeysUtils.Object memory obj = current.toObject();\r\n\r\n        contractAddress = obj.contractAddress;\r\n        timestamp = obj.timestamp;\r\n        gasLimit = obj.gasLimit;\r\n        gasPrice = obj.gasPriceGwei * GWEI;\r\n        invokeGas = calcInvokeGas(obj.gasLimit);\r\n        rewardAmount = calcReward(obj.gasLimit, obj.gasPriceGwei);\r\n    }\r\n\r\n    function getNext(uint _count,\r\n                    address _contractAddress,\r\n                    uint _timestamp,\r\n                    uint _gasLimit,\r\n                    uint _gasPrice) external view returns (address[] _addresses,\r\n                                                        uint[] _timestamps,\r\n                                                        uint[] _gasLimits,\r\n                                                        uint[] _gasPrices,\r\n                                                        uint[] _invokeGases,\r\n                                                        uint[] _rewardAmounts) {\r\n        _addresses = new address[](_count);\r\n        _timestamps = new uint[](_count);\r\n        _gasLimits = new uint[](_count);\r\n        _gasPrices = new uint[](_count);\r\n        _invokeGases = new uint[](_count);\r\n        _rewardAmounts = new uint[](_count);\r\n\r\n        bytes32 prev;\r\n        if (_timestamp != 0) {\r\n            prev = KeysUtils.toKey(_contractAddress, _timestamp, _gasLimit, _gasPrice / GWEI);\r\n        }\r\n\r\n        uint index = 0;\r\n        while (index < _count) {\r\n            bytes32 current = getRecord(prev);\r\n            if (current == 0) {\r\n                break;\r\n            }\r\n            KeysUtils.Object memory obj = current.toObject();\r\n\r\n            _addresses[index] = obj.contractAddress;\r\n            _timestamps[index] = obj.timestamp;\r\n            _gasLimits[index] = obj.gasLimit;\r\n            _gasPrices[index] = obj.gasPriceGwei * GWEI;\r\n            _invokeGases[index] = calcInvokeGas(obj.gasLimit);\r\n            _rewardAmounts[index] = calcReward(obj.gasLimit, obj.gasPriceGwei);\r\n\r\n            prev = current;\r\n            index ++;\r\n        }\r\n    }\r\n\r\n    function next(KeysUtils.Object memory current) internal {\r\n        delRegistrant(current);\r\n        next();\r\n    }\r\n\r\n    function innerInvoke(address _invoker) internal returns (uint _amount) {\r\n        KeysUtils.Object memory current = head.toObject();\r\n        uint amount;\r\n        while (current.timestamp != 0 && current.timestamp < now && msg.gas >= (current.gasLimit + REMAINING_GAS)) {\r\n            if (current.gasLimit != 0) {\r\n                invokeCallback(_invoker, current);\r\n            }\r\n\r\n            amount += getPriceInner(current.gasLimit, current.gasPriceGwei * GWEI);\r\n            next(current);\r\n            current = head.toObject();\r\n        }\r\n        if (amount != 0) {\r\n            vault.withdraw(msg.sender, amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function innerInvokeOnce(address _invoker) internal returns (uint _amount) {\r\n        KeysUtils.Object memory current = head.toObject();\r\n        next(current);\r\n        if (current.gasLimit != 0) {\r\n            invokeCallback(_invoker, current);\r\n        }\r\n\r\n        uint amount = getPriceInner(current.gasLimit, current.gasPriceGwei * GWEI);\r\n\r\n        if (amount > 0) {\r\n            vault.withdraw(msg.sender, amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n\r\n    function invokeCallback(address, KeysUtils.Object memory _record) internal returns (bool) {\r\n        require(msg.gas >= _record.gasLimit);\r\n        return _record.contractAddress.call.gas(_record.gasLimit)(0x919840ad);\r\n    }\r\n\r\n    function calcInvokeGas(uint _contractGasLimit) internal pure returns (uint) {\r\n        return _contractGasLimit + JOULE_GAS + JOULE_INVOKE_GAS + _contractGasLimit * JOULE_INVOKE_GAS_PERCENT / 100;\r\n    }\r\n\r\n    function calcReward(uint _contractGasLimit, uint _gasPriceGwei) internal pure returns (uint) {\r\n        return (_contractGasLimit + JOULE_GAS) * _gasPriceGwei * GWEI;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract JouleBehindProxy is JouleCore, Ownable, TransferToken {\r\n    JouleProxyAPI public proxy;\r\n\r\n    function JouleBehindProxy(JouleVault _vault, bytes32 _head, uint _length, JouleStorage _storage) public\r\n        JouleCore(_vault, _head, _length, _storage) {\r\n    }\r\n\r\n    function setProxy(JouleProxyAPI _proxy) public onlyOwner {\r\n        proxy = _proxy;\r\n    }\r\n\r\n    modifier onlyProxy() {\r\n        require(msg.sender == address(proxy));\r\n        _;\r\n    }\r\n\r\n    function setMinGasPrice(uint _minGasPrice) public onlyOwner {\r\n        require(_minGasPrice >= MIN_GAS_PRICE);\r\n        require(_minGasPrice <= MAX_GAS_PRICE);\r\n        minGasPriceGwei = uint32(_minGasPrice / GWEI);\r\n    }\r\n\r\n    function registerFor(address _registrant, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) public payable onlyProxy returns (uint) {\r\n        return innerRegister(_registrant, _address, _timestamp, _gasLimit, _gasPrice);\r\n    }\r\n\r\n    function unregisterFor(address _registrant, bytes32 _key, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) public onlyProxy returns (uint) {\r\n        return innerUnregister(_registrant, _key, _address, _timestamp, _gasLimit, _gasPrice);\r\n    }\r\n\r\n    function invokeFor(address _invoker) public onlyProxy returns (uint) {\r\n        return innerInvoke(_invoker);\r\n    }\r\n\r\n    function invokeOnceFor(address _invoker) public onlyProxy returns (uint) {\r\n        return innerInvokeOnce(_invoker);\r\n    }\r\n\r\n    function invokeCallback(address _invoker, KeysUtils.Object memory _record) internal returns (bool) {\r\n        return proxy.callback(_invoker, _record.contractAddress, _record.timestamp, _record.gasLimit, _record.gasPriceGwei * GWEI);\r\n    }\r\n}\r\n\r\ncontract JouleProxy is JouleProxyAPI, JouleAPI, Ownable, TransferToken, usingConsts {\r\n    JouleBehindProxy public joule;\r\n\r\n    function setJoule(JouleBehindProxy _joule) public onlyOwner {\r\n        joule = _joule;\r\n    }\r\n\r\n    modifier onlyJoule() {\r\n        require(msg.sender == address(joule));\r\n        _;\r\n    }\r\n\r\n    function () public payable {\r\n    }\r\n\r\n    function getCount() public view returns (uint) {\r\n        return joule.getCount();\r\n    }\r\n\r\n    function register(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external payable returns (uint) {\r\n        return registerFor(msg.sender, _address, _timestamp, _gasLimit, _gasPrice);\r\n    }\r\n\r\n    function registerFor(address _registrant, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) public payable returns (uint) {\r\n        Registered(_registrant, _address, _timestamp, _gasLimit, _gasPrice);\r\n        uint change = joule.registerFor.value(msg.value)(_registrant, _address, _timestamp, _gasLimit, _gasPrice);\r\n        if (change > 0) {\r\n            msg.sender.transfer(change);\r\n        }\r\n        return change;\r\n    }\r\n\r\n    function unregister(bytes32 _key, address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external returns (uint) {\r\n        // unregister will return funds to registrant, not to msg.sender (unlike register)\r\n        uint amount = joule.unregisterFor(msg.sender, _key, _address, _timestamp, _gasLimit, _gasPrice);\r\n        Unregistered(msg.sender, _address, _timestamp, _gasLimit, _gasPrice, amount);\r\n        return amount;\r\n    }\r\n\r\n    function findKey(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) public view returns (bytes32) {\r\n        return joule.findKey(_address, _timestamp, _gasLimit, _gasPrice);\r\n    }\r\n\r\n    function invoke() public returns (uint) {\r\n        return invokeFor(msg.sender);\r\n    }\r\n\r\n    function invokeFor(address _invoker) public returns (uint) {\r\n        uint amount = joule.invokeFor(_invoker);\r\n        if (amount > 0) {\r\n            msg.sender.transfer(amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function invokeOnce() public returns (uint) {\r\n        return invokeOnceFor(msg.sender);\r\n    }\r\n\r\n    function invokeOnceFor(address _invoker) public returns (uint) {\r\n        uint amount = joule.invokeOnceFor(_invoker);\r\n        if (amount > 0) {\r\n            msg.sender.transfer(amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n\r\n    function getPrice(uint _gasLimit, uint _gasPrice) external view returns (uint) {\r\n        return joule.getPrice(_gasLimit, _gasPrice);\r\n    }\r\n\r\n    function getTopOnce() external view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice,\r\n        uint invokeGas,\r\n        uint rewardAmount\r\n    ) {\r\n        (contractAddress, timestamp, gasLimit, gasPrice, invokeGas, rewardAmount) = joule.getTopOnce();\r\n    }\r\n\r\n    function getNextOnce(address _contractAddress,\r\n                     uint _timestamp,\r\n                     uint _gasLimit,\r\n                     uint _gasPrice) public view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice,\r\n        uint invokeGas,\r\n        uint rewardAmount\r\n    ) {\r\n        (contractAddress, timestamp, gasLimit, gasPrice, invokeGas, rewardAmount) = joule.getNextOnce(_contractAddress, _timestamp, _gasLimit, _gasPrice);\r\n    }\r\n\r\n\r\n    function getNext(uint _count,\r\n                    address _contractAddress,\r\n                    uint _timestamp,\r\n                    uint _gasLimit,\r\n                    uint _gasPrice) external view returns (\r\n        address[] _addresses,\r\n        uint[] _timestamps,\r\n        uint[] _gasLimits,\r\n        uint[] _gasPrices,\r\n        uint[] _invokeGases,\r\n        uint[] _rewardAmounts\r\n    ) {\r\n        _addresses = new address[](_count);\r\n        _timestamps = new uint[](_count);\r\n        _gasLimits = new uint[](_count);\r\n        _gasPrices = new uint[](_count);\r\n        _invokeGases = new uint[](_count);\r\n        _rewardAmounts = new uint[](_count);\r\n\r\n        uint i = 0;\r\n\r\n        (_addresses[i], _timestamps[i], _gasLimits[i], _gasPrices[i], _invokeGases[i], _rewardAmounts[i]) = joule.getNextOnce(_contractAddress, _timestamp, _gasLimit, _gasPrice);\r\n\r\n        for (i += 1; i < _count; i ++) {\r\n            if (_timestamps[i - 1] == 0) {\r\n                break;\r\n            }\r\n            (_addresses[i], _timestamps[i], _gasLimits[i], _gasPrices[i], _invokeGases[i], _rewardAmounts[i]) = joule.getNextOnce(_addresses[i - 1], _timestamps[i - 1], _gasLimits[i - 1], _gasPrices[i - 1]);\r\n        }\r\n    }\r\n\r\n\r\n    function getTop(uint _count) external view returns (\r\n        address[] _addresses,\r\n        uint[] _timestamps,\r\n        uint[] _gasLimits,\r\n        uint[] _gasPrices,\r\n        uint[] _invokeGases,\r\n        uint[] _rewardAmounts\r\n    ) {\r\n        uint length = joule.getCount();\r\n        uint amount = _count <= length ? _count : length;\r\n\r\n        _addresses = new address[](amount);\r\n        _timestamps = new uint[](amount);\r\n        _gasLimits = new uint[](amount);\r\n        _gasPrices = new uint[](amount);\r\n        _invokeGases = new uint[](amount);\r\n        _rewardAmounts = new uint[](amount);\r\n\r\n        uint i = 0;\r\n\r\n        (_addresses[i], _timestamps[i], _gasLimits[i], _gasPrices[i], _invokeGases[i], _rewardAmounts[i]) = joule.getTopOnce();\r\n\r\n        for (i += 1; i < amount; i ++) {\r\n            (_addresses[i], _timestamps[i], _gasLimits[i], _gasPrices[i], _invokeGases[i], _rewardAmounts[i]) = joule.getNextOnce(_addresses[i - 1], _timestamps[i - 1], _gasLimits[i - 1], _gasPrices[i - 1]);\r\n        }\r\n    }\r\n\r\n    function getVersion() external view returns (bytes8) {\r\n        return joule.getVersion();\r\n    }\r\n\r\n    function getMinGasPrice() public view returns (uint) {\r\n        return joule.minGasPriceGwei() * GWEI;\r\n    }\r\n\r\n    function callback(address _invoker, address _address, uint, uint _gasLimit, uint) public onlyJoule returns (bool) {\r\n        require(msg.gas >= _gasLimit);\r\n        uint gas = msg.gas;\r\n        bool status = _address.call.gas(_gasLimit)(0x919840ad);\r\n        Invoked(_invoker, _address, status, gas - msg.gas);\r\n        return status;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"getNext\",\"outputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_timestamps\",\"type\":\"uint256[]\"},{\"name\":\"_gasLimits\",\"type\":\"uint256[]\"},{\"name\":\"_gasPrices\",\"type\":\"uint256[]\"},{\"name\":\"_invokeGases\",\"type\":\"uint256[]\"},{\"name\":\"_rewardAmounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTopOnce\",\"outputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"name\":\"invokeGas\",\"type\":\"uint256\"},{\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minGasPriceGwei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getTop\",\"outputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_timestamps\",\"type\":\"uint256[]\"},{\"name\":\"_gasLimits\",\"type\":\"uint256[]\"},{\"name\":\"_gasPrices\",\"type\":\"uint256[]\"},{\"name\":\"_invokeGases\",\"type\":\"uint256[]\"},{\"name\":\"_rewardAmounts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"getNextOnce\",\"outputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"name\":\"invokeGas\",\"type\":\"uint256\"},{\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"findKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_invoker\",\"type\":\"address\"}],\"name\":\"invokeFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_invoker\",\"type\":\"address\"}],\"name\":\"invokeOnceFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"head\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minGasPrice\",\"type\":\"uint256\"}],\"name\":\"setMinGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"setProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"registerFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"unregisterFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_head\",\"type\":\"bytes32\"},{\"name\":\"_length\",\"type\":\"uint256\"},{\"name\":\"_storage\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Gas\",\"type\":\"event\"}]","ContractName":"JouleBehindProxy","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000169ff1286b4b5ad22ffba17ffe82ae5e170f7343696d71eacd2eda67893f7d37dc2142f24b6d29e85a84597c000493e00000001e00000000000000000000000000000000000000000000000000000000000000010000000000000000000000005328de31cb6f7da4c933b0512e2b056a7f460210","Library":"","SwarmSource":"bzzr://be044fa12cef2f42b8005a56a4fcdbeb6a4eefc0ada4ed6f50c9e705aa5501eb"}]}