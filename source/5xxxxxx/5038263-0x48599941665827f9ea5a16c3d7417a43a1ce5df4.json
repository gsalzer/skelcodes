{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n\tuint256 public totalSupply;\r\n\tfunction balanceOf(address who) public view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) public returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n\tfunction allowance(address owner, address spender) public view returns (uint256);\r\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\tfunction approve(address spender, uint256 value) public returns (bool);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract DetailedERC20 is ERC20 {\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\r\n\tfunction DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t\tdecimals = _decimals;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) balances;\r\n\r\n\t/**\r\n\t* @dev transfer token for a specified address\r\n\t* @param _to The address to transfer to.\r\n\t* @param _value The amount to be transferred.\r\n\t*/\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\r\n\t\t// SafeMath.sub will throw if there is not enough balance.\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tTransfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param _owner The address to query the the balance of.\r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t*/\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n\tmapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n\t/**\r\n\t * @dev Transfer tokens from one address to another\r\n\t * @param _from address The address which you want to send tokens from\r\n\t * @param _to address The address which you want to transfer to\r\n\t * @param _value uint256 the amount of tokens to be transferred\r\n\t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[_from]);\r\n\t\trequire(_value <= allowed[_from][msg.sender]);\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\t *\r\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _value The amount of tokens to be spent.\r\n\t */\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t * @param _owner address The address which owns the funds.\r\n\t * @param _spender address The address which will spend the funds.\r\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\r\n\t */\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To increment\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _addedValue The amount of tokens to increase the allowance by.\r\n\t */\r\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n\t *\r\n\t * approve should be called when allowed[_spender] == 0. To decrement\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * From MonolithDAO Token.sol\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n\t */\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n\t\tuint oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\taddress public owner;\r\n\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction Ownable() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\tOwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n\tevent Pause();\r\n\tevent Unpause();\r\n\r\n\tbool public paused = false;\r\n\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is not paused.\r\n\t */\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!paused);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is paused.\r\n\t */\r\n\tmodifier whenPaused() {\r\n\t\trequire(paused);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev called by the owner to pause, triggers stopped state\r\n\t */\r\n\tfunction pause() onlyOwner whenNotPaused public {\r\n\t\tpaused = true;\r\n\t\tPause();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev called by the owner to unpause, returns to normal state\r\n\t */\r\n\tfunction unpause() onlyOwner whenPaused public {\r\n\t\tpaused = false;\r\n\t\tUnpause();\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n\tevent Mint(address indexed to, uint256 amount);\r\n\tevent MintFinished();\r\n\r\n\tbool public mintingFinished = false;\r\n\r\n\r\n\tmodifier canMint() {\r\n\t\trequire(!mintingFinished);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function to mint tokens\r\n\t * @param _to The address that will receive the minted tokens.\r\n\t * @param _amount The amount of tokens to mint.\r\n\t * @return A boolean that indicates if the operation was successful.\r\n\t */\r\n\tfunction mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n\t\ttotalSupply = totalSupply.add(_amount);\r\n\t\tbalances[_to] = balances[_to].add(_amount);\r\n\t\tMint(_to, _amount);\r\n\t\tTransfer(address(0), _to, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function to stop minting new tokens.\r\n\t * @return True if the operation was successful.\r\n\t */\r\n\tfunction finishMinting() onlyOwner canMint public returns (bool) {\r\n\t\tmintingFinished = true;\r\n\t\tMintFinished();\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title Capped token\r\n * @dev Mintable token with a token cap.\r\n */\r\n\r\ncontract CappedToken is MintableToken {\r\n\r\n\tuint256 public cap;\r\n\r\n\tfunction CappedToken(uint256 _cap) public {\r\n\t\trequire(_cap > 0);\r\n\t\tcap = _cap;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Function to mint tokens\r\n\t * @param _to The address that will receive the minted tokens.\r\n\t * @param _amount The amount of tokens to mint.\r\n\t * @return A boolean that indicates if the operation was successful.\r\n\t */\r\n\tfunction mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n\t\trequire(totalSupply.add(_amount) <= cap);\r\n\r\n\t\treturn super.mint(_to, _amount);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n\tevent Burn(address indexed burner, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Burns a specific amount of tokens.\r\n\t * @param _value The amount of token to be burned.\r\n\t */\r\n\tfunction burn(uint256 _value) public {\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\t\t// no need to require value <= totalSupply, since that would imply the\r\n\t\t// sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n\t\taddress burner = msg.sender;\r\n\t\tbalances[burner] = balances[burner].sub(_value);\r\n\t\ttotalSupply = totalSupply.sub(_value);\r\n\t\tBurn(burner, _value);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// The token being sold\r\n\tMintableToken public token;\r\n\r\n\t// start and end timestamps where investments are allowed (both inclusive)\r\n\tuint256 public startTime;\r\n\tuint256 public endTime;\r\n\r\n\t// address where funds are collected\r\n\taddress public wallet;\r\n\r\n\t// how many token units a buyer gets per wei\r\n\tuint256 public rate;\r\n\r\n\t// amount of raised money in wei\r\n\tuint256 public weiRaised;\r\n\r\n\t/**\r\n\t * event for token purchase logging\r\n\t * @param purchaser who paid for the tokens\r\n\t * @param beneficiary who got the tokens\r\n\t * @param value weis paid for purchase\r\n\t * @param amount amount of tokens purchased\r\n\t */\r\n\tevent TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\r\n\tfunction Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {\r\n\t\trequire(_startTime >= now);\r\n\t\trequire(_endTime >= _startTime);\r\n\t\trequire(_rate > 0);\r\n\t\trequire(_wallet != address(0));\r\n\r\n\t\ttoken = createTokenContract();\r\n\t\tstartTime = _startTime;\r\n\t\tendTime = _endTime;\r\n\t\trate = _rate;\r\n\t\twallet = _wallet;\r\n\t}\r\n\r\n\t// creates the token to be sold.\r\n\t// override this method to have crowdsale of a specific mintable token.\r\n\tfunction createTokenContract() internal returns (MintableToken) {\r\n\t\treturn new MintableToken();\r\n\t}\r\n\r\n\r\n\t// fallback function can be used to buy tokens\r\n\tfunction () external payable {\r\n\t\tbuyTokens(msg.sender);\r\n\t}\r\n\r\n\t// low level token purchase function\r\n\tfunction buyTokens(address beneficiary) public payable {\r\n\t\trequire(beneficiary != address(0));\r\n\t\trequire(validPurchase());\r\n\r\n\t\tuint256 weiAmount = msg.value;\r\n\r\n\t\t// calculate token amount to be created\r\n\t\tuint256 tokens = weiAmount.mul(rate);\r\n\r\n\t\t// update state\r\n\t\tweiRaised = weiRaised.add(weiAmount);\r\n\r\n\t\ttoken.mint(beneficiary, tokens);\r\n\t\tTokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n\r\n\t\tforwardFunds();\r\n\t}\r\n\r\n\t// send ether to the fund collection wallet\r\n\t// override to create custom fund forwarding mechanisms\r\n\tfunction forwardFunds() internal {\r\n\t\twallet.transfer(msg.value);\r\n\t}\r\n\r\n\t// @return true if the transaction can buy tokens\r\n\tfunction validPurchase() internal view returns (bool) {\r\n\t\tbool withinPeriod = now >= startTime && now <= endTime;\r\n\t\tbool nonZeroPurchase = msg.value != 0;\r\n\t\treturn withinPeriod && nonZeroPurchase;\r\n\t}\r\n\r\n\t// @return true if crowdsale event has ended\r\n\tfunction hasEnded() public view returns (bool) {\r\n\t\treturn now > endTime;\r\n\t}\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title CappedCrowdsale\r\n * @dev Extension of Crowdsale with a max amount of funds raised\r\n */\r\ncontract CappedCrowdsale is Crowdsale {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public cap;\r\n\r\n\tfunction CappedCrowdsale(uint256 _cap) public {\r\n\t\trequire(_cap > 0);\r\n\t\tcap = _cap;\r\n\t}\r\n\r\n\t// overriding Crowdsale#validPurchase to add extra cap logic\r\n\t// @return true if investors can buy at the moment\r\n\tfunction validPurchase() internal view returns (bool) {\r\n\t\tbool withinCap = weiRaised.add(msg.value) <= cap;\r\n\t\treturn super.validPurchase() && withinCap;\r\n\t}\r\n\r\n\t// overriding Crowdsale#hasEnded to add cap logic\r\n\t// @return true if crowdsale event has ended\r\n\tfunction hasEnded() public view returns (bool) {\r\n\t\tbool capReached = weiRaised >= cap;\r\n\t\treturn super.hasEnded() || capReached;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n *\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n\tfunction transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n\t\treturn super.transfer(_to, _value);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n\t\treturn super.transferFrom(_from, _to, _value);\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n\t\treturn super.approve(_spender, _value);\r\n\t}\r\n\r\n\tfunction increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n\t\treturn super.increaseApproval(_spender, _addedValue);\r\n\t}\r\n\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n\t\treturn super.decreaseApproval(_spender, _subtractedValue);\r\n\t}\r\n}\r\n\r\ncontract BftToken is DetailedERC20, CappedToken, BurnableToken, PausableToken {\r\n\r\n\tCappedCrowdsale public crowdsale;\r\n\r\n\tfunction BftToken(\r\n\t\tuint256 _tokenCap,\r\n\t\tuint8 _decimals,\r\n\t\tCappedCrowdsale _crowdsale\r\n\t)\r\n\tDetailedERC20(\"BF Token\", \"BFT\", _decimals)\r\n\tCappedToken(_tokenCap) public {\r\n\r\n\t\tcrowdsale = _crowdsale;\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------------------------------------------\r\n\t// the following is the functionality to upgrade this token smart contract to a new one\r\n\r\n\tMintableToken public newToken = MintableToken(0x0);\r\n\tevent LogRedeem(address beneficiary, uint256 amount);\r\n\r\n\tmodifier hasUpgrade() {\r\n\t\trequire(newToken != MintableToken(0x0));\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction upgrade(MintableToken _newToken) onlyOwner public {\r\n\t\tnewToken = _newToken;\r\n\t}\r\n\r\n\t// overriding BurnableToken#burn to make disable it for public use\r\n\tfunction burn(uint256 _value) public {\r\n\t\trevert();\r\n\t\t_value = _value; // to silence compiler warning\r\n\t}\r\n\r\n\tfunction redeem() hasUpgrade public {\r\n\r\n\t\tvar balance = balanceOf(msg.sender);\r\n\r\n\t\t// burn the tokens in this token smart contract\r\n\t\tsuper.burn(balance);\r\n\r\n\t\t// mint tokens in the new token smart contract\r\n\t\trequire(newToken.mint(msg.sender, balance));\r\n\t\tLogRedeem(msg.sender, balance);\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------------------------------------------\r\n\t// we override the token transfer functions to block transfers before startTransfersDate timestamp\r\n\r\n\tmodifier canDoTransfers() {\r\n\t\trequire(hasCrowdsaleFinished());\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction hasCrowdsaleFinished() view public returns(bool) {\r\n\t\treturn crowdsale.hasEnded();\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _value) public canDoTransfers returns (bool) {\r\n\t\treturn super.transfer(_to, _value);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public canDoTransfers returns (bool) {\r\n\t\treturn super.transferFrom(_from, _to, _value);\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _value) public canDoTransfers returns (bool) {\r\n\t\treturn super.approve(_spender, _value);\r\n\t}\r\n\r\n\tfunction increaseApproval(address _spender, uint _addedValue) public canDoTransfers returns (bool success) {\r\n\t\treturn super.increaseApproval(_spender, _addedValue);\r\n\t}\r\n\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public canDoTransfers returns (bool success) {\r\n\t\treturn super.decreaseApproval(_spender, _subtractedValue);\r\n\t}\r\n\r\n\t// ----------------------------------------------------------------------------------------------------------------\r\n\t// functionality to change the token ticker - in case of conflict\r\n\r\n\tfunction changeSymbol(string _symbol) onlyOwner public {\r\n\t\tsymbol = _symbol;\r\n\t}\r\n\r\n\tfunction changeName(string _name) onlyOwner public {\r\n\t\tname = _name;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n/**\r\n * @title TokenTimelock\r\n * @dev TokenTimelock is a token holder contract that will allow a\r\n * beneficiary to extract the tokens after a given release time\r\n */\r\ncontract TokenTimelock {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  // ERC20 basic token contract being held\r\n  ERC20Basic public token;\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  // timestamp when token release is enabled\r\n  uint256 public releaseTime;\r\n\r\n  function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {\r\n    require(_releaseTime > now);\r\n    token = _token;\r\n    beneficiary = _beneficiary;\r\n    releaseTime = _releaseTime;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers tokens held by timelock to beneficiary.\r\n   */\r\n  function release() public {\r\n    require(now >= releaseTime);\r\n\r\n    uint256 amount = token.balanceOf(this);\r\n    require(amount > 0);\r\n\r\n    token.safeTransfer(beneficiary, amount);\r\n  }\r\n}\r\n\r\ncontract BftCrowdsale is CappedCrowdsale, Pausable {\r\n\r\n\tuint8 public constant tokenDecimals = 18;\r\n\tuint256 public constant etherInWei = 10**uint256(tokenDecimals);\r\n\tuint256 public constant tokenCap = 1000000000 * etherInWei;\r\n\r\n\tuint256 public SALE_CAP_USD;\r\n\tuint256 public BUYER_CAP_LOW_USD;\r\n\tuint256 public BUYER_CAP_HIGH_USD;\r\n\r\n\tuint256 public constant PRICE_MULTIPLIER = 100;\r\n\tuint256 public constant TOKENS_PER_USD = 10;\r\n\r\n\tuint256 public etherPrice = PRICE_MULTIPLIER;\r\n\tuint256 public buyerCapLowEther = etherInWei;\r\n\tuint256 public buyerCapHighEther = etherInWei;\r\n\tuint256 public saleHardCapEther = etherInWei;\r\n\tuint256 public mintRate = TOKENS_PER_USD;\r\n\r\n\taddress public preSaleBfPlatform;\r\n\taddress public company;\r\n\taddress public rewardPool;\r\n\taddress public shareholders;\r\n\taddress public tokenSaleCosts;\r\n\r\n\t// smart contracts that will lock tokens for a pre-defined time\r\n\tTokenTimelock public companyHolding2y;\r\n\tTokenTimelock public shareholdersHolding1y;\r\n\r\n\t// address permissioned to whitelist public sale addresses\r\n\tmapping(address => bool) whitelist;\r\n\r\n\tmapping(address => bool) operators;\r\n\tevent LogOperatorAdd(address newOperator);\r\n\tevent LogOperatorRem(address newOperator);\r\n\r\n\tmodifier onlyOperator() {\r\n\t\trequire(operators[msg.sender]);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyWhitelisted(address _address) {\r\n\t\trequire(whitelist[_address]);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction BftCrowdsale(\r\n\t\tuint256 _startTime,\r\n\t\tuint256 _endTime,\r\n\t\tuint256 _etherPrice,\r\n\t\taddress _wallet,\r\n\r\n\t// addresses with pre-minted tokens\r\n\t\taddress _preSaleBfPlatform,\r\n\t\taddress _company,\r\n\t\taddress _rewardPool,\r\n\t\taddress _shareholders,\r\n\t\taddress _tokenSaleCosts,\r\n\r\n\t// owner of the whitelist function\r\n\t\taddress _operator,\r\n\t\taddress _admin,\r\n\r\n\t\tuint256 _saleCapUsd,\r\n\t\tuint256 _buyerCapLowUsd,\r\n\t\tuint256 _buyerCapHighUsd\r\n\t)\r\n\tCappedCrowdsale(saleHardCapEther)\r\n\tCrowdsale(_startTime, _endTime, mintRate, _wallet) public {\r\n\r\n\t\trequire(_preSaleBfPlatform != address(0x0));\r\n\t\trequire(_company != address(0x0));\r\n\t\trequire(_rewardPool != address(0x0));\r\n\t\trequire(_shareholders != address(0x0));\r\n\t\trequire(_tokenSaleCosts != address(0x0));\r\n\t\trequire(_operator != address(0x0));\r\n\r\n\t\tSALE_CAP_USD = _saleCapUsd;\r\n\t\tBUYER_CAP_LOW_USD = _buyerCapLowUsd;\r\n\t\tBUYER_CAP_HIGH_USD = _buyerCapHighUsd;\r\n\r\n\t\tpreSaleBfPlatform = _preSaleBfPlatform;\r\n\t\tcompany = _company;\r\n\t\trewardPool = _rewardPool;\r\n\t\tshareholders = _shareholders;\r\n\t\ttokenSaleCosts = _tokenSaleCosts;\r\n\r\n\t\taddOperator(_operator);\r\n\t\tupdateEtherPrice(_etherPrice);\r\n\t\tcreateHoldings();\r\n\t\tpreMintTokens();\r\n\r\n\t\t// transfer ownership the the admin multi-sig\r\n\t\ttransferOwnership(_admin);\r\n\t}\r\n\r\n\tfunction updateEtherPrice(uint256 _price) onlyOwner public {\r\n\t\trequire(_price > 0);\r\n\t\trequire(now < startTime);\r\n\r\n\t\tetherPrice = _price;\r\n\t\tbuyerCapLowEther = BUYER_CAP_LOW_USD.mul(etherInWei).mul(PRICE_MULTIPLIER).div(etherPrice);\r\n\t\tbuyerCapHighEther = BUYER_CAP_HIGH_USD.mul(etherInWei).mul(PRICE_MULTIPLIER).div(etherPrice);\r\n\t\tsaleHardCapEther = SALE_CAP_USD.mul(etherInWei).mul(PRICE_MULTIPLIER).div(etherPrice);\r\n\t\tmintRate = TOKENS_PER_USD.mul(etherPrice).div(PRICE_MULTIPLIER);\r\n\r\n\t\t// update vars on parent contracts\r\n\t\tcap = saleHardCapEther;\r\n\t\trate = mintRate;\r\n\t}\r\n\r\n\tfunction createHoldings() internal {\r\n\t\tcompanyHolding2y = new TokenTimelock(token, company, startTime+2 years);\r\n\t\tshareholdersHolding1y = new TokenTimelock(token, shareholders, startTime+1 years);\r\n\t}\r\n\r\n\tfunction preMintTokens() internal {\r\n\t\ttoken.mint(preSaleBfPlatform, 300000000 * etherInWei);\r\n\t\ttoken.mint(companyHolding2y, 300000000 * etherInWei);\r\n\t\ttoken.mint(rewardPool, 200000000 * etherInWei);\r\n\t\ttoken.mint(shareholdersHolding1y, 100000000 * etherInWei);\r\n\t\ttoken.mint(tokenSaleCosts, 70000000 * etherInWei);\r\n\t}\r\n\r\n\tfunction checkSaleEnded() internal {\r\n\t\t// if no further purchases are possible due to lower buyer cap\r\n\t\tif(saleHardCapEther.sub(weiRaised) < buyerCapLowEther) {\r\n\t\t\ttoken.mint(rewardPool, tokenCap.sub(token.totalSupply()));\r\n\t\t}\r\n\t}\r\n\r\n\t// overriding CappedCrowdsale#validPurchase to add extra low/high limits logic\r\n\t// @return true if investors can buy at the moment\r\n\tfunction validPurchase() whenNotPaused\r\n\tinternal view returns (bool) {\r\n\t\tbool aboveLowBuyerCap = (msg.value >= buyerCapLowEther);\r\n\t\tbool underMaxBuyerCap = (msg.value <= buyerCapHighEther);\r\n\t\treturn super.validPurchase() && aboveLowBuyerCap && underMaxBuyerCap;\r\n\t}\r\n\r\n\t// overriding Crowdsale#hasEnded to add token cap logic\r\n\t// @return true if crowdsale event has ended\r\n\tfunction hasEnded() public view returns (bool) {\r\n\t\tbool tokenCapReached = token.totalSupply() == tokenCap;\r\n\t\treturn super.hasEnded() || tokenCapReached;\r\n\t}\r\n\r\n\tfunction buyTokens(address beneficiary)\r\n\tonlyWhitelisted(beneficiary)\r\n\twhenNotPaused\r\n\tpublic payable {\r\n\t\trequire(token.balanceOf(beneficiary)==0);\r\n\t\tsuper.buyTokens(beneficiary);\r\n\t\tcheckSaleEnded();\r\n\t}\r\n\r\n\t// creates the token to be sold.\r\n\t// override this method to have crowdsale of a specific mintable token.\r\n\tfunction createTokenContract() internal returns (MintableToken) {\r\n\t\treturn new BftToken(tokenCap, tokenDecimals, this);\r\n\t}\r\n\r\n\tfunction addWhitelist(address[] beneficiaries) onlyOperator public {\r\n\t\tfor (uint i = 0; i < beneficiaries.length; i++) {\r\n\t\t\twhitelist[beneficiaries[i]] = true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction remWhitelist(address[] beneficiaries) onlyOperator public {\r\n\t\tfor (uint i = 0; i < beneficiaries.length; i++) {\r\n\t\t\twhitelist[beneficiaries[i]] = false;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction isWhitelisted(address beneficiary) view public returns(bool) {\r\n\t\treturn whitelist[beneficiary];\r\n\t}\r\n\r\n\tfunction addOperator(address _operator) onlyOwner public {\r\n\t\toperators[_operator] = true;\r\n\t\tLogOperatorAdd(_operator);\r\n\t}\r\n\r\n\tfunction remOperator(address _operator) onlyOwner public {\r\n\t\toperators[_operator] = false;\r\n\t\tLogOperatorAdd(_operator);\r\n\t}\r\n\r\n\tfunction isOperator(address _operator) view public returns(bool) {\r\n\t\treturn operators[_operator];\r\n\t}\r\n\r\n\tfunction transferTokenOwnership(address _newOwner) onlyOwner public {\r\n\t\t// only allow transfer at the end of the sale\r\n\t\trequire(hasEnded());\r\n\t\t// stop the minting process on the token as we only allow the crowdsale to mint\r\n\t\ttoken.finishMinting();\r\n\t\ttoken.transferOwnership(_newOwner);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateEtherPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyHolding2y\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiaries\",\"type\":\"address[]\"}],\"name\":\"remWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareholders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_CAP_USD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"company\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleHardCapEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyerCapLowEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"remOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BUYER_CAP_LOW_USD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BUYER_CAP_HIGH_USD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleCosts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyerCapHighEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_PER_USD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleBfPlatform\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"shareholdersHolding1y\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiaries\",\"type\":\"address[]\"}],\"name\":\"addWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_etherPrice\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_preSaleBfPlatform\",\"type\":\"address\"},{\"name\":\"_company\",\"type\":\"address\"},{\"name\":\"_rewardPool\",\"type\":\"address\"},{\"name\":\"_shareholders\",\"type\":\"address\"},{\"name\":\"_tokenSaleCosts\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_saleCapUsd\",\"type\":\"uint256\"},{\"name\":\"_buyerCapLowUsd\",\"type\":\"uint256\"},{\"name\":\"_buyerCapHighUsd\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"LogOperatorAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"LogOperatorRem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"BftCrowdsale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005a875460000000000000000000000000000000000000000000000000000000005a9f0f60000000000000000000000000000000000000000000000000000000000001117000000000000000000000000087a9678952b5d7a7bd450e4695d691e574e26a89000000000000000000000000b8e6935650f490d06c7a203848f2b2118ae23e9600000000000000000000000008017a8f4e946149dc58b9153767c0481f4b4d68000000000000000000000000278407078c667153b60259e9dcaca018e741f7bc00000000000000000000000045ffeae330cfe7a9033decc30b3989e6f72ea36e000000000000000000000000cdd2204320fc58298e5c428bc4ed1bab83813efe0000000000000000000000006a08f5093bb7aaf77f06bb5ffc409c45599a442400000000000000000000000097a63ef2e255d567aa4c412e80e63b97a1b7db5900000000000000000000000000000000000000000000000000000000002dc6c000000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000002710","Library":"","SwarmSource":"bzzr://42212e087512d46abd8a41e77bffcdca88dc5c13d94177a08b67de6b91d0cca9"}]}