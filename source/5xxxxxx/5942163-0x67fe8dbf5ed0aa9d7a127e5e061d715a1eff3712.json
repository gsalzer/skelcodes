{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20\r\n * @dev   ERC20 Contract interface(s)\r\n */\r\ncontract ERC20\r\n{\r\n    function balanceOf    (address _owner) public constant returns (uint256 balance);\r\n    function transfer     (               address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve      (address _spender, uint256 _value) public returns (bool success);\r\n    function allowance    (address _owner, address _spender) public constant returns (uint256 remaining);\r\n    function totalSupply  () public constant returns (uint);\r\n\r\n    event Transfer (address indexed _from,  address indexed _to,      uint _value);\r\n    event Approval (address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n/**\r\n * @title TokenRecipient \r\n */\r\ninterface TokenRecipient\r\n{\r\n    /* fundtion definitions */\r\n    function receiveApproval (address _from, uint256 _value, address _token, bytes _extraData) external;\r\n}\r\n\r\n/**\r\n * @title SafeMath math library\r\n * @dev   Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath\r\n{\r\n    /**\r\n     * @dev 'a + b', Adds two numbers, throws on overflow\r\n     */\r\n    function add (uint256 a, uint256 b) internal pure returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require (c >= a); return c;\r\n    }\r\n\r\n    /**\r\n     * @dev 'a - b', Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend)\r\n     */\r\n    function sub (uint256 a, uint256 b) internal pure returns (uint256 c)\r\n    {\r\n        require (a >= b);\r\n        c = a - b; return c;\r\n    }\r\n\r\n    /**\r\n     * @dev 'a * b', multiplies two numbers, throws on overflow\r\n     */\r\n    function mul (uint256 a, uint256 b) internal pure returns (uint256 c)\r\n    {\r\n        c = a * b;\r\n        require (a == 0 || c / a == b); return c;\r\n    }\r\n\r\n    /**\r\n     * @dev 'a / b', Integer division of two numbers, truncating the quotient\r\n     */\r\n    function div (uint256 a, uint256 b) internal pure returns (uint256 c)\r\n    {\r\n        require (b > 0);\r\n        c = a / b; return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Token\r\n * @dev   Implementation of the ERC20 Token\r\n */\r\ncontract ERC20Token is ERC20\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    /* balance of each account */\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    string  public name;\r\n    string  public symbol;\r\n    uint8   public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    /**\r\n     * @dev   Creates a ERC20 Contract with its name, symbol, decimals, and total supply of token\r\n     * @param _name name of token\r\n     * @param _symbol name of symbol\r\n     * @param _decimals decimals\r\n     * @param _initSupply total supply of tokens\r\n     */\r\n    constructor (string _name, string _symbol, uint8 _decimals, uint256 _initSupply) public\r\n    {\r\n        name        = _name;                                    // set the name   for display purpose\r\n        symbol      = _symbol;                                  // set the symbol for display purpose\r\n        decimals    = _decimals;                                // 18 decimals is the strongly suggested \r\n        totalSupply = _initSupply * (10 ** uint256 (decimals)); // update total supply with the decimal amount\r\n        balances[msg.sender] = totalSupply;                     // give the creator all initial tokens\r\n\r\n        emit Transfer (address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the token balance for account `_owner`\r\n     */\r\n    function balanceOf (address _owner) public view returns (uint256 balance)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /* function to access name, symbol, decimals, total-supply of token. */\r\n    function name        () public view returns (string  _name    ) { return name;        } \r\n    function symbol      () public view returns (string  _symbol  ) { return symbol;      } \r\n    function decimals    () public view returns (uint8   _decimals) { return decimals;    }\r\n    function totalSupply () public view returns (uint256 _supply  ) { return totalSupply; }\r\n\r\n    /**\r\n     * @dev Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer (address _from, address _to, uint256 _value) internal\r\n    {\r\n        require (_to != 0x0);                               // prevent transfer to 0x0 address\r\n        require (balances[_from] >= _value);                // check if the sender has enough\r\n        require (balances[_to  ] +  _value > balances[_to]);// check for overflows\r\n\r\n        uint256 previous = balances[_from] + balances[_to]; // save this for an assertion in the future\r\n\r\n        balances[_from] = balances[_from].sub (_value);     // subtract from the sender\r\n        balances[_to  ] = balances[_to  ].add (_value);     // add the same to the recipient\r\n        emit Transfer (_from, _to, _value);\r\n\r\n        /* Asserts are used to use static analysis to find bugs in your code. They should never fail */\r\n        assert (balances[_from] + balances[_to] == previous);\r\n    }\r\n\r\n    /**\r\n     * @dev    Transfer the balance from owner's account to another account \"_to\" \r\n     *         owner's account must have sufficient balance to transfer\r\n     *         0 value transfers are allowed\r\n     * @param  _to The address of the recipient\r\n     * @param  _value The amount to send\r\n     * @return true if the operation was successful.\r\n     */\r\n    function transfer (address _to, uint256 _value) public returns (bool success)\r\n    {\r\n        _transfer (msg.sender, _to, _value); return true;\r\n    }\r\n\r\n    /**\r\n     * @dev    Send `_value` amount of tokens from `_from` account to `_to` account\r\n     *         The calling account must already have sufficient tokens approved for\r\n     *         spending from the `_from` account\r\n     * @param  _from The address of the sender\r\n     * @param  _to The address of the recipient\r\n     * @param  _value The amount to send\r\n     * @return true if the operation was successful.\r\n     */\r\n    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success)\r\n    {\r\n        require (allowed[_from][msg.sender] >= _value); // check allowance \r\n        allowed [_from][msg.sender] = allowed [_from][msg.sender].sub (_value);\r\n\r\n        _transfer (_from, _to, _value); return true;\r\n    }\r\n\r\n    /**\r\n     * @dev    Get the amount of tokens approved by the owner that can be transferred\r\n     *         to the spender's account\r\n     * @param  _owner The address owner\r\n     * @param  _spender The address authorized to spend\r\n     * @return The amount of tokens remained for the approved by the owner that can\r\n     *         be transferred\r\n     */\r\n    function allowance (address _owner, address _spender) public constant returns (uint remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev    Set allowance for other address\r\n     *         Allow `_spender` to withdraw from your account, multiple times,\r\n     *         up to the `_value` amount. If this function is called again it\r\n     *         overwrites the current allowance with _value.\r\n     *         Token owner can approve for `spender` to transferFrom (...) `tokens`\r\n     *         from the token owner's account\r\n     * @param  _spender The address authorized to spend\r\n     * @param  _value the max amount they can spend\r\n     * @return true if the operation was successful.\r\n     */\r\n    function approve (address _spender, uint256 _value) public returns (bool success)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval (msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev    Set allowance for other address and notify\r\n     *         Allows `_spender` to spend no more than `_value` tokens in your behalf,\r\n     *         and then ping the contract about it\r\n     * @param  _spender   the address authorized to spend\r\n     * @param  _value     the max amount they can spend\r\n     * @param  _extraData some extra information to send to the approved contract\r\n     * @return true if the operation was successful.\r\n     */\r\n    function approveAndCall (address _spender, uint256 _value, bytes _extraData) public returns (bool success)\r\n    {\r\n        TokenRecipient spender = TokenRecipient (_spender);\r\n\r\n        if (approve (_spender, _value))\r\n        {\r\n            spender.receiveApproval (msg.sender, _value, address (this), _extraData);\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title  Ownable\r\n * @notice For user and inter-contract ownership and safe ownership transfers.\r\n * @dev    The Ownable contract has an owner address, and provides basic\r\n *         authorization control functions\r\n */\r\ncontract Ownable\r\n{\r\n    address public owner;   /* the address of the contract's owner  */\r\n\r\n    /* logged on change & renounce of owner */\r\n    event OwnershipTransferred (address indexed _owner, address indexed _to);\r\n    event OwnershipRenounced   (address indexed _owner);\r\n\r\n    /**\r\n     * @dev Sets the original 'owner' of the contract to the sender account\r\n     */\r\n    constructor () public \r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner\r\n     */\r\n    modifier onlyOwner \r\n    {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev   Allows the current owner to transfer control of the contract to a '_to'\r\n     * @param _to The address to transfer ownership to\r\n     */\r\n    function transferOwnership (address _to) public onlyOwner\r\n    {\r\n        require (_to != address(0));\r\n        emit OwnershipTransferred (owner, _to);\r\n        owner = _to;\r\n    }\r\n\r\n    /**\r\n     * @dev   Allows the current owner to relinquish control of the contract.\r\n     *        This will remove all ownership of the contract, _safePhrase must\r\n     *        be equal to \"This contract is to be disowned\"\r\n     * @param _safePhrase Input string to prevent one's mistake\r\n     */\r\n    function renounceOwnership (bytes32 _safePhrase) public onlyOwner\r\n    {\r\n        require (_safePhrase == \"This contract is to be disowned.\");\r\n        emit OwnershipRenounced (owner);\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ExpERC20Token\r\n */\r\ncontract ExpERC20Token is ERC20Token, Ownable\r\n{\r\n    /**\r\n     * @dev   Creates a ERC20 Contract with its name, symbol, decimals, and total supply of token\r\n     * @param _name name of token\r\n     * @param _symbol name of symbol\r\n     * @param _decimals decimals\r\n     * @param _initSupply total supply of tokens\r\n     */\r\n    constructor (\r\n        string   _name,     // name of token\r\n        string   _symbol,   // name of symbol\r\n        uint8    _decimals, // decimals\r\n        uint256 _initSupply // total supply of tokens\r\n    ) ERC20Token (_name, _symbol, _decimals, _initSupply) public {}\r\n\r\n    /**\r\n     * @notice Only the creator can alter the name & symbol\r\n     * @param  _name   newer token name   to be changed\r\n     * @param  _symbol newer token symbol to be changed\r\n     */\r\n    function changeName (string _name, string _symbol) onlyOwner public\r\n    {\r\n        name   = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /* ======================================================================\r\n     * Burnable functions\r\n     */\r\n\r\n    /* This notifies clients about the amount burnt */\r\n    event Burn (address indexed from, uint256 value);\r\n\r\n    /**\r\n     * Internal burn, only can be called by this contract\r\n     */\r\n    function _burn (address _from, uint256 _value) internal\r\n    {\r\n        require (balances[_from] >= _value);            // check if the sender has enough\r\n\r\n        balances[_from] = balances[_from].sub (_value); // subtract from the sender\r\n        totalSupply = totalSupply.sub (_value);         // updates totalSupply\r\n        emit Burn (_from, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev    remove `_value` tokens from the system irreversibly\r\n     * @param  _value the amount of money to burn\r\n     * @return true if the operation was successful.\r\n     */\r\n    function burn (uint256 _value) public returns (bool success)\r\n    {\r\n        _burn (msg.sender, _value); return true;\r\n    }\r\n\r\n    /**\r\n     * @dev    remove `_value` tokens from the system irreversibly on behalf of `_from`\r\n     * @param  _from the address of the sender\r\n     * @param  _value the amount of money to burn\r\n     * @return true if the operation was successful.\r\n     */\r\n    function burnFrom (address _from, uint256 _value) public returns (bool success)\r\n    {\r\n        require (allowed [_from][msg.sender] >= _value);\r\n        allowed [_from][msg.sender] = allowed [_from][msg.sender].sub (_value);\r\n        _burn (_from, _value); return true;\r\n    }\r\n\r\n\r\n    /* ======================================================================\r\n     * Mintable functions\r\n     */\r\n\r\n    /* event for mint's */\r\n    event Mint (address indexed _to, uint256 _amount);\r\n    event MintFinished ();\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    /* Throws if it is not mintable status */\r\n    modifier canMint ()\r\n    {\r\n        require (!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    /* Throws if called by any account other than the owner */\r\n    modifier hasMintPermission ()\r\n    {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev    Function to mint tokens\r\n     * @param  _to The address that will receive the minted tokens.\r\n     * @param  _amount The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint (address _to, uint256 _amount) hasMintPermission canMint public returns (bool)\r\n    {\r\n        totalSupply   = totalSupply.add  (_amount);\r\n        balances[_to] = balances[_to].add (_amount);\r\n\r\n        emit Mint (_to, _amount);\r\n        emit Transfer (address (0), this, _amount);\r\n        emit Transfer (       this,  _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev    Function to stop minting new tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function finishMinting () onlyOwner canMint public returns (bool)\r\n    {\r\n        mintingFinished = true;\r\n        emit MintFinished ();\r\n        return true;\r\n    }\r\n\r\n\r\n    /* ======================================================================\r\n     * Lockable Token\r\n     */\r\n\r\n    bool public tokenLocked = false;\r\n\r\n    /* event for Token's lock or unlock */\r\n    event Lock (address indexed _target, bool _locked);\r\n\r\n    mapping (address => bool) public frozenAccount;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds (address target, bool frozen);\r\n\r\n    /**\r\n     * @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n     * @param  _target address to be frozen\r\n     * @param  _freeze either to freeze it or not\r\n     */\r\n    function freezeAccount (address _target, bool _freeze) onlyOwner public\r\n    {\r\n        frozenAccount[_target] = _freeze;\r\n        emit FrozenFunds (_target, _freeze);\r\n    }\r\n\r\n    /* Throws if it is not locked status */\r\n    modifier whenTokenUnlocked ()\r\n    {\r\n        require (!tokenLocked);\r\n        _;\r\n    }\r\n\r\n    /* Internal token-lock, only can be called by this contract */\r\n    function _lock (bool _value) internal\r\n    {\r\n        require (tokenLocked != _value);\r\n        tokenLocked = _value;\r\n        emit Lock (this, tokenLocked);\r\n    }\r\n\r\n    /**\r\n     * @dev    function to check token is lock or not \r\n     */\r\n    function isTokenLocked () public view returns (bool success)\r\n    {\r\n        return tokenLocked;\r\n    }\r\n\r\n    /**\r\n     * @dev    function to lock/unlock this token\r\n     * @param  _value flag to be locked or not\r\n     */\r\n    function lock (bool _value) onlyOwner public returns (bool)\r\n    {\r\n        _lock (_value); return true;\r\n    }\r\n\r\n    /**\r\n     * @dev    Transfer the balance from owner's account to another account \"_to\" \r\n     *         owner's account must have sufficient balance to transfer\r\n     *         0 value transfers are allowed\r\n     * @param  _to The address of the recipient\r\n     * @param  _value The amount to send\r\n     * @return true if the operation was successful.\r\n     */\r\n    function transfer (address _to, uint256 _value) whenTokenUnlocked public returns (bool success)\r\n    {\r\n        require (!frozenAccount[msg.sender]);   // check if sender is frozen\r\n        require (!frozenAccount[_to  ]);        // check if recipient is frozen\r\n\r\n        return super.transfer (_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev    Send `_value` amount of tokens from `_from` account to `_to` account\r\n     *         The calling account must already have sufficient tokens approved for\r\n     *         spending from the `_from` account\r\n     * @param  _from The address of the sender\r\n     * @param  _to The address of the recipient\r\n     * @param  _value The amount to send\r\n     * @return true if the operation was successful.\r\n     */\r\n    function transferFrom (address _from, address _to, uint256 _value) whenTokenUnlocked public returns (bool success)\r\n    {\r\n        require (!frozenAccount[msg.sender]);   // check if sender is frozen\r\n        require (!frozenAccount[_from]);        // check if token-owner is frozen\r\n        require (!frozenAccount[_to  ]);        // check if recipient is frozen\r\n\r\n        return super.transferFrom (_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev    Set allowance for other address\r\n     *         Allow `_spender` to withdraw from your account, multiple times,\r\n     *         up to the `_value` amount. If this function is called again it\r\n     *         overwrites the current allowance with _value.\r\n     *         Token owner can approve for `spender` to transferFrom (...) `tokens`\r\n     *         from the token owner's account\r\n     * @param  _spender The address authorized to spend\r\n     * @param  _value the max amount they can spend\r\n     * @return true if the operation was successful.\r\n     */\r\n    function approve (address _spender, uint256 _value) whenTokenUnlocked public returns (bool success)\r\n    {\r\n        require (!frozenAccount[msg.sender]);   // check if sender is frozen\r\n        require (!frozenAccount[_spender  ]);   // check if token-owner is frozen\r\n\r\n        return super.approve (_spender, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev    Set allowance for other address and notify\r\n     *         Allows `_spender` to spend no more than `_value` tokens in your behalf,\r\n     *         and then ping the contract about it\r\n     * @param  _spender   the address authorized to spend\r\n     * @param  _value     the max amount they can spend\r\n     * @param  _extraData some extra information to send to the approved contract\r\n     * @return true if the operation was successful.\r\n     */\r\n    function approveAndCall (address _spender, uint256 _value, bytes _extraData) whenTokenUnlocked public returns (bool success)\r\n    {\r\n        require (!frozenAccount[msg.sender]);   // check if sender is frozen\r\n        require (!frozenAccount[_spender  ]);   // check if token-owner is frozen\r\n\r\n        return super.approveAndCall (_spender, _value, _extraData);\r\n    }\r\n\r\n    /* ======================================================================\r\n     * buy & sell functions \r\n     */\r\n\r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n\r\n    /* Internal transfer, only can be called by this contract */\r\n    function _transfer (address _from, address _to, uint _value) internal\r\n    {\r\n        require (_to != 0x0);                                   // prevent transfer to 0x0 address\r\n        require (balances[_from] >= _value);                    // check if the sender has enough\r\n        require (balances[_to  ]  + _value >= balances[_to]);   // check for overflows\r\n\r\n        require (!frozenAccount[_from]);                        // check if sender is frozen\r\n        require (!frozenAccount[_to  ]);                        // check if recipient is frozen\r\n\r\n        balances[_from] = balances[_from].sub (_value);         // Subtract from the sender\r\n        balances[_to  ] = balances[_to  ].add (_value);         // Add the same to the recipient\r\n        emit Transfer (_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\r\n     * @param  _sellPrice Price the users can sell to the contract\r\n     * @param  _buyPrice  Price users can buy from the contract\r\n     */\r\n    function setPrices (uint256 _sellPrice, uint256 _buyPrice) onlyOwner public\r\n    {\r\n        sellPrice = _sellPrice;\r\n        buyPrice  = _buyPrice ;\r\n    }\r\n\r\n    /**\r\n     * @notice Buy tokens from contract by sending ether\r\n     */\r\n    function buy () whenTokenUnlocked payable public\r\n    {\r\n        uint amount = msg.value / buyPrice;     // calculates the amount\r\n        _transfer (this, msg.sender, amount);   // makes the transfers\r\n    }\r\n\r\n    /**\r\n     *  @notice sell `_amount` tokens to contract\r\n     *  @param  _amount amount of tokens to be sold\r\n     */\r\n    function sell (uint256 _amount) whenTokenUnlocked public\r\n    {\r\n        require (balances[this] >= _amount * sellPrice);    // checks if the contract has enough ether to buy\r\n        _transfer (msg.sender, this, _amount);              // makes the transfers\r\n        msg.sender.transfer (_amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"name\":\"_buyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"lock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_safePhrase\",\"type\":\"bytes32\"}],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"changeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTokenLocked\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_initSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ExpERC20Token","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000012a05f200000000000000000000000000000000000000000000000000000000000000000a5061795820546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035041580000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://96e922196fdae4736f0c42d06b827b70b53e4c5672851c6026c2d38f72b130bf"}]}