{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ninterface ISTRegistrar {\r\n\r\n   /**\r\n    * @dev Creates a new Security Token and saves it to the registry\r\n    * @param _name Name of the security token\r\n    * @param _ticker Ticker name of the security\r\n    * @param _totalSupply Total amount of tokens being created\r\n    * @param _owner Ethereum public key address of the security token owner\r\n    * @param _maxPoly Amount of maximum poly issuer want to raise\r\n    * @param _host The host of the security token wizard\r\n    * @param _fee Fee being requested by the wizard host\r\n    * @param _type Type of security being tokenized\r\n    * @param _lockupPeriod Length of time raised POLY will be locked up for dispute\r\n    * @param _quorum Percent of initial investors required to freeze POLY raise\r\n    */\r\n    function createSecurityToken (\r\n        string _name,\r\n        string _ticker,\r\n        uint256 _totalSupply,\r\n        uint8 _decimals,\r\n        address _owner,\r\n        uint256 _maxPoly,\r\n        address _host,\r\n        uint256 _fee,\r\n        uint8 _type,\r\n        uint256 _lockupPeriod,\r\n        uint8 _quorum\r\n    ) external;\r\n\r\n}\r\n\r\n/// ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md)\r\ninterface IERC20 {\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/**\r\n *  SafeMath <https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol/>\r\n *  Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n *  Released under the MIT License (MIT)\r\n */\r\n\r\n/// @title Math operations with safety checks\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ninterface ICustomers {\r\n\r\n  /**\r\n   * @dev Allow new provider applications\r\n   * @param _providerAddress The provider's public key address\r\n   * @param _name The provider's name\r\n   * @param _details A SHA256 hash of the new providers details\r\n   * @param _fee The fee charged for customer verification\r\n   */\r\n  function newProvider(address _providerAddress, string _name, bytes32 _details, uint256 _fee) public returns (bool success);\r\n\r\n  /**\r\n   * @dev Change a providers fee\r\n   * @param _newFee The new fee of the provider\r\n   */\r\n  function changeFee(uint256 _newFee) public returns (bool success);\r\n\r\n  /**\r\n   * @dev Verify an investor\r\n   * @param _customer The customer's public key address\r\n   * @param _countryJurisdiction The country urisdiction code of the customer\r\n   * @param _divisionJurisdiction The subdivision jurisdiction code of the customer\r\n   * @param _role The type of customer - investor:1, delegate:2, issuer:3, marketmaker:4, etc.\r\n   * @param _accredited Whether the customer is accredited or not (only applied to investors)\r\n   * @param _expires The time the verification expires\r\n   */\r\n  function verifyCustomer(\r\n    address _customer,\r\n    bytes32 _countryJurisdiction,\r\n    bytes32 _divisionJurisdiction,\r\n    uint8 _role,\r\n    bool _accredited,\r\n    uint256 _expires\r\n  ) public returns (bool success);\r\n\r\n   ///////////////////\r\n    /// GET Functions\r\n    //////////////////\r\n\r\n  /**\r\n    * @dev Get customer attestation data by KYC provider and customer ethereum address\r\n    * @param _provider Address of the KYC provider.\r\n    * @param _customer Address of the customer ethereum address\r\n    */\r\n  function getCustomer(address _provider, address _customer) public constant returns (\r\n    bytes32,\r\n    bytes32,\r\n    bool,\r\n    uint8,\r\n    bool,\r\n    uint256\r\n  );\r\n\r\n  /**\r\n   * Get provider details and fee by ethereum address\r\n   * @param _providerAddress Address of the KYC provider\r\n   */\r\n  function getProvider(address _providerAddress) public constant returns (\r\n    string name,\r\n    uint256 joined,\r\n    bytes32 details,\r\n    uint256 fee\r\n  );\r\n}\r\n\r\n/*\r\n  Polymath compliance protocol is intended to ensure regulatory compliance\r\n  in the jurisdictions that security tokens are being offered in. The compliance\r\n  protocol allows security tokens remain interoperable so that anyone can\r\n  build on top of the Polymath platform and extend it's functionality.\r\n*/\r\n\r\ninterface ICompliance {\r\n\r\n    /**\r\n     * @dev `setRegsitrarAddress` This function set the SecurityTokenRegistrar contract address. \r\n     * @param _STRegistrar It is the `this` reference of STR contract\r\n     * @return bool\r\n     */\r\n\r\n    function setRegsitrarAddress(address _STRegistrar) public returns (bool);\r\n    \r\n    /**\r\n     * @dev `createTemplate` is a simple function to create a new compliance template\r\n     * @param _offeringType The name of the security being issued\r\n     * @param _issuerJurisdiction The jurisdiction id of the issuer\r\n     * @param _accredited Accreditation status required for investors\r\n     * @param _KYC KYC provider used by the template\r\n     * @param _details Details of the offering requirements\r\n     * @param _expires Timestamp of when the template will expire\r\n     * @param _fee Amount of POLY to use the template (held in escrow until issuance)\r\n     * @param _quorum Minimum percent of shareholders which need to vote to freeze\r\n     * @param _vestingPeriod Length of time to vest funds \r\n     */\r\n    function createTemplate(\r\n        string _offeringType,\r\n        bytes32 _issuerJurisdiction,\r\n        bool _accredited,\r\n        address _KYC,\r\n        bytes32 _details,\r\n        uint256 _expires,\r\n        uint256 _fee,\r\n        uint8 _quorum,\r\n        uint256 _vestingPeriod\r\n    ) public;\r\n\r\n   /**\r\n     * @dev Propose a bid for a security token issuance\r\n     * @param _securityToken The security token being bid on\r\n     * @param _template The unique template address\r\n     * @return bool success \r\n     */\r\n    function proposeTemplate(\r\n        address _securityToken,\r\n        address _template\r\n    ) public returns (bool success);\r\n\r\n    /**\r\n     * @dev Propose a Security Token Offering Contract for an issuance\r\n     * @param _securityToken The security token being bid on\r\n     * @param _stoContract The security token offering contract address\r\n     * @return bool success \r\n     */\r\n    function proposeOfferingContract(\r\n        address _securityToken,\r\n        address _stoContract\r\n    ) public returns (bool success);\r\n\r\n    /**\r\n     * @dev Cancel a Template proposal if the bid hasn't been accepted\r\n     * @param _securityToken The security token being bid on\r\n     * @param _templateProposalIndex The template proposal array index\r\n     * @return bool success \r\n     */\r\n    function cancelTemplateProposal(\r\n        address _securityToken,\r\n        uint256 _templateProposalIndex\r\n    ) public returns (bool success);\r\n\r\n    /**\r\n     * @dev Set the STO contract by the issuer.\r\n     * @param _STOAddress address of the STO contract deployed over the network.\r\n     * @param _fee fee to be paid in poly to use that contract\r\n     * @param _vestingPeriod no. of days investor binded to hold the Security token\r\n     * @param _quorum Minimum percent of shareholders which need to vote to freeze\r\n     */\r\n    function setSTO (\r\n        address _STOAddress,\r\n        uint256 _fee,\r\n        uint256 _vestingPeriod,\r\n        uint8 _quorum\r\n    ) public returns (bool success);\r\n\r\n    /**\r\n     * @dev Cancel a STO contract proposal if the bid hasn't been accepted\r\n     * @param _securityToken The security token being bid on\r\n     * @param _offeringProposalIndex The offering proposal array index\r\n     * @return bool success \r\n     */\r\n    function cancelOfferingProposal(\r\n        address _securityToken,\r\n        uint256 _offeringProposalIndex\r\n    ) public returns (bool success);\r\n\r\n    /**\r\n     * @dev `updateTemplateReputation` is a constant function that updates the\r\n       history of a security token template usage to keep track of previous uses\r\n     * @param _template The unique template id\r\n     * @param _templateIndex The array index of the template proposal \r\n     */\r\n    function updateTemplateReputation (address _template, uint8 _templateIndex) external returns (bool success);\r\n\r\n    /**\r\n     * @dev `updateOfferingReputation` is a constant function that updates the\r\n       history of a security token offering contract to keep track of previous uses\r\n     * @param _stoContract The smart contract address of the STO contract\r\n     * @param _offeringProposalIndex The array index of the security token offering proposal \r\n     */\r\n    function updateOfferingReputation (address _stoContract, uint8 _offeringProposalIndex) external returns (bool success);\r\n\r\n    /**\r\n     * @dev Get template details by the proposal index\r\n     * @param _securityTokenAddress The security token ethereum address\r\n     * @param _templateIndex The array index of the template being checked\r\n     * @return Template struct \r\n     */\r\n    function getTemplateByProposal(address _securityTokenAddress, uint8 _templateIndex) view public returns (\r\n        address _template\r\n    );\r\n\r\n    /** \r\n     * @dev Get security token offering smart contract details by the proposal index\r\n     * @param _securityTokenAddress The security token ethereum address\r\n     * @param _offeringProposalIndex The array index of the STO contract being checked\r\n     * @return Contract struct \r\n     */\r\n    function getOfferingByProposal(address _securityTokenAddress, uint8 _offeringProposalIndex) view public returns (\r\n        address stoContract,\r\n        address auditor,\r\n        uint256 vestingPeriod,\r\n        uint8 quorum,\r\n        uint256 fee\r\n    );\r\n}\r\n\r\ninterface ITemplate {\r\n\r\n  /**\r\n   * @dev `addJurisdiction` allows the adding of new jurisdictions to a template\r\n   * @param _allowedJurisdictions An array of jurisdictions\r\n   * @param _allowed An array of whether the jurisdiction is allowed to purchase the security or not\r\n   */\r\n  function addJurisdiction(bytes32[] _allowedJurisdictions, bool[] _allowed) public;\r\n\r\n  /**\r\n   * @dev `addDivisionJurisdiction` allows the adding of new jurisdictions to a template\r\n   * @param _blockedDivisionJurisdictions An array of jurisdictions\r\n   * @param _blocked An array of whether the jurisdiction is allowed to purchase the security or not\r\n   */\r\n  function addDivisionJurisdiction(bytes32[] _blockedDivisionJurisdictions, bool[] _blocked) public;\r\n\r\n  /**\r\n   * @dev `addRole` allows the adding of new roles to be added to whitelist\r\n   * @param _allowedRoles User roles that can purchase the security\r\n   */\r\n  function addRoles(uint8[] _allowedRoles) public;\r\n\r\n  /**\r\n   * @notice `updateDetails`\r\n   * @param _details details of the template need to change\r\n   * @return allowed boolean variable\r\n   */\r\n  function updateDetails(bytes32 _details) public returns (bool allowed);\r\n\r\n  /**\r\n   * @dev `finalizeTemplate` is used to finalize template.full compliance process/requirements\r\n   * @return success\r\n   */\r\n  function finalizeTemplate() public returns (bool success);\r\n\r\n  /**\r\n   * @dev `checkTemplateRequirements` is a constant function that checks if templates requirements are met\r\n   * @param _countryJurisdiction The ISO-3166 code of the investors country jurisdiction\r\n   * @param _divisionJurisdiction The ISO-3166 code of the investors subdivision jurisdiction\r\n   * @param _accredited Whether the investor is accredited or not\r\n   * @param _role role of the user\r\n   * @return allowed boolean variable\r\n   */\r\n  function checkTemplateRequirements(\r\n      bytes32 _countryJurisdiction,\r\n      bytes32 _divisionJurisdiction,\r\n      bool _accredited,\r\n      uint8 _role\r\n  ) public constant returns (bool allowed);\r\n\r\n  /**\r\n   * @dev getTemplateDetails is a constant function that gets template details\r\n   * @return bytes32 details, bool finalized\r\n   */\r\n  function getTemplateDetails() view public returns (bytes32, bool);\r\n\r\n  /**\r\n   * @dev `getUsageFees` is a function to get all the details on template usage fees\r\n   * @return uint256 fee, uint8 quorum, uint256 vestingPeriod, address owner, address KYC\r\n   */\r\n  function getUsageDetails() view public returns (uint256, uint8, uint256, address, address);\r\n}\r\n\r\ncontract STO20 {\r\n\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    /** \r\n     * @dev Initializes the STO with certain params\r\n     * @dev _tokenAddress Address of the security token\r\n     * @param _startTime Given in UNIX time this is the time that the offering will begin\r\n     * @param _endTime Given in UNIX time this is the time that the offering will end \r\n     */\r\n    function securityTokenOffering(\r\n        address _tokenAddress,\r\n        uint256 _startTime,\r\n        uint256 _endTime\r\n    ) external ;\r\n\r\n}\r\n\r\n/**\r\n * @title SecurityToken\r\n * @dev Contract (A Blueprint) that contains the functionalities of the security token\r\n */\r\n\r\ncontract SecurityToken is IERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string public VERSION = \"1\";\r\n\r\n    IERC20 public POLY;                                               // Instance of the POLY token contract\r\n\r\n    ICompliance public PolyCompliance;                                // Instance of the Compliance contract\r\n\r\n    ITemplate public Template;                                        // Instance of the Template contract\r\n\r\n    ICustomers public PolyCustomers;                                  // Instance of the Customers contract\r\n\r\n    STO20 public STO;\r\n\r\n    // ERC20 Fields\r\n    string public name;                                               // Name of the security token\r\n    uint8 public decimals;                                            // Decimals for the security token it should be 0 as standard\r\n    string public symbol;                                             // Symbol of the security token\r\n    address public owner;                                             // Address of the owner of the security token\r\n    uint256 public totalSupply;                                       // Total number of security token generated\r\n    mapping(address => mapping(address => uint256)) allowed;          // Mapping as same as in ERC20 token\r\n    mapping(address => uint256) balances;                             // Array used to store the balances of the security token holders\r\n\r\n    // Template\r\n    address public delegate;                                          // Address who create the template\r\n    bytes32 public merkleRoot;                                        //\r\n    address public KYC;                                               // Address of the KYC provider which aloowed the roles and jurisdictions in the template\r\n\r\n    // Security token shareholders\r\n    struct Shareholder {                                              // Structure that contains the data of the shareholders\r\n        address verifier;                                             // verifier - address of the KYC oracle\r\n        bool allowed;                                                 // allowed - whether the shareholder is allowed to transfer or recieve the security token\r\n        uint8 role;                                                   // role - role of the shareholder {1,2,3,4}\r\n    }\r\n\r\n    mapping(address => Shareholder) public shareholders;              // Mapping that holds the data of the shareholder corresponding to investor address\r\n\r\n    // STO\r\n    bool public isSTOProposed = false;\r\n    bool public hasOfferingStarted = false;\r\n    uint256 public maxPoly;\r\n\r\n    // The start and end time of the STO\r\n    uint256 public startSTO;                                          // Timestamp when Security Token Offering will be start\r\n    uint256 public endSTO;                                            // Timestamp when Security Token Offering contract will ends\r\n\r\n    // POLY allocations\r\n    struct Allocation {                                               // Structure that contains the allocation of the POLY for stakeholders\r\n        uint256 amount;                                               // stakeholders - delegate, issuer(owner), auditor\r\n        uint256 vestingPeriod;\r\n        uint8 quorum;\r\n        uint256 yayVotes;\r\n        uint256 yayPercent;\r\n        bool frozen;\r\n    }\r\n    mapping(address => mapping(address => bool)) public voted;               // Voting mapping\r\n    mapping(address => Allocation) public allocations;                       // Mapping that contains the data of allocation corresponding to stakeholder address\r\n\r\n\t   // Security Token Offering statistics\r\n    mapping(address => uint256) public contributedToSTO;                     // Mapping for tracking the POLY contribution by the contributor\r\n    uint256 public tokensIssuedBySTO = 0;                             // Flag variable to track the security token issued by the offering contract\r\n\r\n    // Notifications\r\n    event LogTemplateSet(address indexed _delegateAddress, address _template, address indexed _KYC);\r\n    event LogUpdatedComplianceProof(bytes32 _merkleRoot, bytes32 _complianceProofHash);\r\n    event LogSetSTOContract(address _STO, address indexed _STOtemplate, address indexed _auditor, uint256 _startTime, uint256 _endTime);\r\n    event LogNewWhitelistedAddress(address _KYC, address _shareholder, uint8 _role);\r\n    event LogNewBlacklistedAddress(address _KYC, address _shareholder);\r\n    event LogVoteToFreeze(address _recipient, uint256 _yayPercent, uint8 _quorum, bool _frozen);\r\n    event LogTokenIssued(address indexed _contributor, uint256 _stAmount, uint256 _polyContributed, uint256 _timestamp);\r\n\r\n    //Modifiers\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDelegate() {\r\n        require (msg.sender == delegate);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrDelegate() {\r\n        require (msg.sender == delegate || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlySTO() {\r\n        require (msg.sender == address(STO));\r\n        _;\r\n    }\r\n\r\n    modifier onlyShareholder() {\r\n        require (shareholders[msg.sender].allowed);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Set default security token parameters\r\n     * @param _name Name of the security token\r\n     * @param _ticker Ticker name of the security\r\n     * @param _totalSupply Total amount of tokens being created\r\n     * @param _owner Ethereum address of the security token owner\r\n     * @param _maxPoly Amount of maximum poly issuer want to raise\r\n     * @param _lockupPeriod Length of time raised POLY will be locked up for dispute\r\n     * @param _quorum Percent of initial investors required to freeze POLY raise\r\n     * @param _polyTokenAddress Ethereum address of the POLY token contract\r\n     * @param _polyCustomersAddress Ethereum address of the PolyCustomers contract\r\n     * @param _polyComplianceAddress Ethereum address of the PolyCompliance contract\r\n     */\r\n    function SecurityToken(\r\n        string _name,\r\n        string _ticker,\r\n        uint256 _totalSupply,\r\n        uint8 _decimals,\r\n        address _owner,\r\n        uint256 _maxPoly,\r\n        uint256 _lockupPeriod,\r\n        uint8 _quorum,\r\n        address _polyTokenAddress,\r\n        address _polyCustomersAddress,\r\n        address _polyComplianceAddress\r\n    ) public\r\n    {\r\n        decimals = _decimals;\r\n        name = _name;\r\n        symbol = _ticker;\r\n        owner = _owner;\r\n        maxPoly = _maxPoly;\r\n        totalSupply = _totalSupply;\r\n        balances[_owner] = _totalSupply;\r\n        POLY = IERC20(_polyTokenAddress);\r\n        PolyCustomers = ICustomers(_polyCustomersAddress);\r\n        PolyCompliance = ICompliance(_polyComplianceAddress);\r\n        allocations[owner] = Allocation(0, _lockupPeriod, _quorum, 0, 0, false);\r\n        Transfer(0x0, _owner, _totalSupply);\r\n    }\r\n\r\n    /* function initialiseBalances(uint256) */\r\n\r\n    /**\r\n     * @dev `selectTemplate` Select a proposed template for the issuance\r\n     * @param _templateIndex Array index of the delegates proposed template\r\n     * @return bool success\r\n     */\r\n    function selectTemplate(uint8 _templateIndex) public onlyOwner returns (bool success) {\r\n        require(!isSTOProposed);\r\n        address _template = PolyCompliance.getTemplateByProposal(this, _templateIndex);\r\n        require(_template != address(0));\r\n        Template = ITemplate(_template);\r\n        var (_fee, _quorum, _vestingPeriod, _delegate, _KYC) = Template.getUsageDetails();\r\n        require(POLY.balanceOf(this) >= _fee);\r\n        allocations[_delegate] = Allocation(_fee, _vestingPeriod, _quorum, 0, 0, false);\r\n        delegate = _delegate;\r\n        KYC = _KYC;\r\n        PolyCompliance.updateTemplateReputation(_template, _templateIndex);\r\n        LogTemplateSet(_delegate, _template, _KYC);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update compliance proof hash for the issuance\r\n     * @param _newMerkleRoot New merkle root hash of the compliance Proofs\r\n     * @param _merkleRoot Compliance Proof hash\r\n     * @return bool success\r\n     */\r\n    function updateComplianceProof(\r\n        bytes32 _newMerkleRoot,\r\n        bytes32 _merkleRoot\r\n    ) public onlyOwnerOrDelegate returns (bool success)\r\n    {\r\n        merkleRoot = _newMerkleRoot;\r\n        LogUpdatedComplianceProof(merkleRoot, _merkleRoot);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev `selectOfferingProposal` Select an security token offering proposal for the issuance\r\n     * @param _offeringProposalIndex Array index of the STO proposal\r\n     * @return bool success\r\n     */\r\n    function selectOfferingProposal (uint8 _offeringProposalIndex) public onlyDelegate returns (bool success) {\r\n        require(!isSTOProposed);\r\n        var (_stoContract, _auditor, _vestingPeriod, _quorum, _fee) = PolyCompliance.getOfferingByProposal(this, _offeringProposalIndex);\r\n        require(_stoContract != address(0));\r\n        require(merkleRoot != 0x0);\r\n        require(delegate != address(0));\r\n        require(POLY.balanceOf(this) >= allocations[delegate].amount.add(_fee));\r\n        STO = STO20(_stoContract);\r\n        require(STO.startTime() > now && STO.endTime() > STO.startTime());\r\n        allocations[_auditor] = Allocation(_fee, _vestingPeriod, _quorum, 0, 0, false);\r\n        shareholders[address(STO)] = Shareholder(this, true, 5);\r\n        startSTO = STO.startTime();\r\n        endSTO = STO.endTime();\r\n        isSTOProposed = !isSTOProposed;\r\n        PolyCompliance.updateOfferingReputation(_stoContract, _offeringProposalIndex);\r\n        LogSetSTOContract(STO, _stoContract, _auditor, startSTO, endSTO);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Start the offering by sending all the tokens to STO contract\r\n     * @return bool\r\n     */\r\n    function startOffering() onlyOwner external returns (bool success) {\r\n        require(isSTOProposed);\r\n        require(!hasOfferingStarted);\r\n        uint256 tokenAmount = this.balanceOf(msg.sender);\r\n        require(tokenAmount == totalSupply);\r\n        balances[STO] = balances[STO].add(tokenAmount);\r\n        balances[msg.sender] = balances[msg.sender].sub(tokenAmount);\r\n        hasOfferingStarted = true;\r\n        Transfer(owner, STO, tokenAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a verified address to the Security Token whitelist\r\n     * The Issuer can add an address to the whitelist by themselves by\r\n     * creating their own KYC provider and using it to verify the accounts\r\n     * they want to add to the whitelist.\r\n     * @param _whitelistAddress Address attempting to join ST whitelist\r\n     * @return bool success\r\n     */\r\n    function addToWhitelist(address _whitelistAddress) onlyOwner public returns (bool success) {\r\n        var (countryJurisdiction, divisionJurisdiction, accredited, role, verified, expires) = PolyCustomers.getCustomer(KYC, _whitelistAddress);\r\n        require(verified && expires > now);\r\n        require(Template.checkTemplateRequirements(countryJurisdiction, divisionJurisdiction, accredited, role));\r\n        shareholders[_whitelistAddress] = Shareholder(msg.sender, true, role);\r\n        LogNewWhitelistedAddress(msg.sender, _whitelistAddress, role);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a verified address to the Security Token blacklist\r\n     * @param _blacklistAddress Address being added to the blacklist\r\n     * @return bool success\r\n     */\r\n    function addToBlacklist(address _blacklistAddress) onlyOwner public returns (bool success) {\r\n        require(shareholders[_blacklistAddress].allowed);\r\n        shareholders[_blacklistAddress].allowed = false;\r\n        LogNewBlacklistedAddress(msg.sender, _blacklistAddress);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow POLY allocations to be withdrawn by owner, delegate, and the STO auditor at appropriate times\r\n     * @return bool success\r\n     */\r\n    function withdrawPoly() public returns (bool success) {\r\n  \t    if (delegate == address(0)) {\r\n          return POLY.transfer(owner, POLY.balanceOf(this));\r\n        }\r\n        require(now > endSTO + allocations[msg.sender].vestingPeriod);\r\n        require(!allocations[msg.sender].frozen);\r\n        require(allocations[msg.sender].amount > 0);\r\n        require(POLY.transfer(msg.sender, allocations[msg.sender].amount));\r\n        allocations[msg.sender].amount = 0;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Vote to freeze the fee of a certain network participant\r\n     * @param _recipient The fee recipient being protested\r\n     * @return bool success\r\n     */\r\n    function voteToFreeze(address _recipient) public onlyShareholder returns (bool success) {\r\n        require(delegate != address(0));\r\n        require(now > endSTO);\r\n        require(now < endSTO.add(allocations[_recipient].vestingPeriod));\r\n        require(!voted[msg.sender][_recipient]);\r\n        voted[msg.sender][_recipient] = true;\r\n        allocations[_recipient].yayVotes = allocations[_recipient].yayVotes.add(contributedToSTO[msg.sender]);\r\n        allocations[_recipient].yayPercent = allocations[_recipient].yayVotes.mul(100).div(allocations[owner].amount);\r\n        if (allocations[_recipient].yayPercent >= allocations[_recipient].quorum) {\r\n          allocations[_recipient].frozen = true;\r\n        }\r\n        LogVoteToFreeze(_recipient, allocations[_recipient].yayPercent, allocations[_recipient].quorum, allocations[_recipient].frozen);\r\n        return true;\r\n    }\r\n\r\n\t/**\r\n     * @dev `issueSecurityTokens` is used by the STO to keep track of STO investors\r\n     * @param _contributor The address of the person whose contributing\r\n     * @param _amountOfSecurityTokens The amount of ST to pay out.\r\n     * @param _polyContributed The amount of POLY paid for the security tokens.\r\n     */\r\n    function issueSecurityTokens(address _contributor, uint256 _amountOfSecurityTokens, uint256 _polyContributed) public onlySTO returns (bool success) {\r\n        // Check whether the offering active or not\r\n        require(hasOfferingStarted);\r\n        // The _contributor being issued tokens must be in the whitelist\r\n        require(shareholders[_contributor].allowed);\r\n        // Tokens may only be issued while the STO is running\r\n        require(now >= startSTO && now <= endSTO);\r\n        // In order to issue the ST, the _contributor first pays in POLY\r\n        require(POLY.transferFrom(_contributor, this, _polyContributed));\r\n        // ST being issued can't be higher than the totalSupply\r\n        require(tokensIssuedBySTO.add(_amountOfSecurityTokens) <= totalSupply);\r\n        // POLY contributed can't be higher than maxPoly set by STO\r\n        require(maxPoly >= allocations[owner].amount.add(_polyContributed));\r\n        // Update ST balances (transfers ST from STO to _contributor)\r\n        balances[STO] = balances[STO].sub(_amountOfSecurityTokens);\r\n        balances[_contributor] = balances[_contributor].add(_amountOfSecurityTokens);\r\n        // ERC20 Transfer event\r\n        Transfer(STO, _contributor, _amountOfSecurityTokens);\r\n        // Update the amount of tokens issued by STO\r\n        tokensIssuedBySTO = tokensIssuedBySTO.add(_amountOfSecurityTokens);\r\n        // Update the amount of POLY a contributor has contributed and allocated to the owner\r\n        contributedToSTO[_contributor] = contributedToSTO[_contributor].add(_polyContributed);\r\n        allocations[owner].amount = allocations[owner].amount.add(_polyContributed);\r\n        LogTokenIssued(_contributor, _amountOfSecurityTokens, _polyContributed, now);\r\n        return true;\r\n    }\r\n\r\n    // Get token details\r\n    function getTokenDetails() view public returns (address, address, bytes32, address, address) {\r\n        return (Template, delegate, merkleRoot, STO, KYC);\r\n    }\r\n\r\n/////////////////////////////////////////////// Customized ERC20 Functions ////////////////////////////////////////////////////////////\r\n\r\n    /**\r\n     * @dev Trasfer tokens from one address to another\r\n     * @param _to Ethereum public address to transfer tokens to\r\n     * @param _value Amount of tokens to send\r\n     * @return bool success\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (shareholders[_to].allowed && shareholders[msg.sender].allowed && balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allows contracts to transfer tokens on behalf of token holders\r\n     * @param _from Address to transfer tokens from\r\n     * @param _to Address to send tokens to\r\n     * @param _value Number of tokens to transfer\r\n     * @return bool success\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (shareholders[_to].allowed && shareholders[_from].allowed && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            uint256 _allowance = allowed[_from][msg.sender];\r\n            balances[_from] = balances[_from].sub(_value);\r\n            allowed[_from][msg.sender] = _allowance.sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev `balanceOf` used to get the balance of shareholders\r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Approve transfer of tokens manually\r\n     * @param _spender Address to approve transfer to\r\n     * @param _value Amount of tokens to approve for transfer\r\n     * @return bool success\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        require(_value != 0);\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Use to get the allowance provided to the spender\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n/*\r\n  Polymath customer registry is used to ensure regulatory compliance\r\n  of the investors, provider, and issuers. The customers registry is a central\r\n  place where ethereum addresses can be whitelisted to purchase certain security\r\n  tokens based on their verifications by providers.\r\n*/\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Customers\r\n * @dev Contract use to register the user on the Platform platform\r\n */\r\n\r\ncontract Customers is ICustomers {\r\n\r\n    string public VERSION = \"1\";\r\n\r\n    IERC20 POLY;                                                        // Instance of the POLY token\r\n\r\n    struct Customer {                                                   // Structure use to store the details of the customers\r\n        bytes32 countryJurisdiction;                                    // Customers country jurisdiction as ex - ISO3166\r\n        bytes32 divisionJurisdiction;                                   // Customers sub-division jurisdiction as ex - ISO3166\r\n        uint256 joined;                                                 // Timestamp when customer register\r\n        uint8 role;                                                     // role of the customer\r\n        bool verified;                                                  // Boolean variable to check the status of the customer whether it is verified or not\r\n        bool accredited;                                                // Accrediation status of the customer\r\n        bytes32 proof;                                                  // Proof for customer\r\n        uint256 expires;                                                // Timestamp when customer verification expires\r\n    }\r\n\r\n    mapping(address => mapping(address => Customer)) public customers;  // Customers (kyc provider address => customer address)\r\n\r\n    struct Provider {                                                   // KYC/Accreditation Provider\r\n        string name;                                                    // Name of the provider\r\n        uint256 joined;                                                 // Timestamp when provider register\r\n        bytes32 details;                                                // Details of provider\r\n        uint256 fee;                                                    // Fee charged by the KYC providers\r\n    }\r\n\r\n    mapping(address => Provider) public providers;                      // KYC/Accreditation Providers\r\n\r\n    // Notifications\r\n    event LogNewProvider(address providerAddress, string name, bytes32 details);\r\n    event LogCustomerVerified(address customer, address provider, uint8 role);\r\n\r\n    // Modifier\r\n    modifier onlyProvider() {\r\n        require(providers[msg.sender].details != 0x0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor\r\n     */\r\n    function Customers(address _polyTokenAddress) public {\r\n        POLY = IERC20(_polyTokenAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow new provider applications\r\n     * @param _providerAddress The provider's public key address\r\n     * @param _name The provider's name\r\n     * @param _details A SHA256 hash of the new providers details\r\n     * @param _fee The fee charged for customer verification\r\n     */\r\n    function newProvider(address _providerAddress, string _name, bytes32 _details, uint256 _fee) public returns (bool success) {\r\n        require(_providerAddress != address(0));\r\n        require(_details != 0x0);\r\n        require(providers[_providerAddress].details == 0x0);\r\n        providers[_providerAddress] = Provider(_name, now, _details, _fee);\r\n        LogNewProvider(_providerAddress, _name, _details);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Change a providers fee\r\n     * @param _newFee The new fee of the provider\r\n     */\r\n    function changeFee(uint256 _newFee) public returns (bool success) {\r\n        require(providers[msg.sender].details != 0x0);\r\n        providers[msg.sender].fee = _newFee;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Verify an investor\r\n     * @param _customer The customer's public key address\r\n     * @param _countryJurisdiction The jurisdiction country code of the customer\r\n     * @param _divisionJurisdiction The jurisdiction subdivision code of the customer\r\n     * @param _role The type of customer - investor:1, delegate:2, issuer:3, marketmaker:4, etc.\r\n     * @param _accredited Whether the customer is accredited or not (only applied to investors)\r\n     * @param _expires The time the verification expires\r\n     */\r\n    function verifyCustomer(\r\n        address _customer,\r\n        bytes32 _countryJurisdiction,\r\n        bytes32 _divisionJurisdiction,\r\n        uint8 _role,\r\n        bool _accredited,\r\n        uint256 _expires\r\n    ) public onlyProvider returns (bool success)\r\n    {\r\n        require(_expires > now);\r\n        require(POLY.transferFrom(_customer, msg.sender, providers[msg.sender].fee));\r\n        customers[msg.sender][_customer].countryJurisdiction = _countryJurisdiction;\r\n        customers[msg.sender][_customer].divisionJurisdiction = _divisionJurisdiction;\r\n        customers[msg.sender][_customer].role = _role;\r\n        customers[msg.sender][_customer].accredited = _accredited;\r\n        customers[msg.sender][_customer].expires = _expires;\r\n        customers[msg.sender][_customer].verified = true;\r\n        LogCustomerVerified(_customer, msg.sender, _role);\r\n        return true;\r\n    }\r\n\r\n    ///////////////////\r\n    /// GET Functions\r\n    //////////////////\r\n\r\n    /**\r\n     * @dev Get customer attestation data by KYC provider and customer ethereum address\r\n     * @param _provider Address of the KYC provider.\r\n     * @param _customer Address of the customer ethereum address\r\n     */\r\n    function getCustomer(address _provider, address _customer) public constant returns (\r\n        bytes32,\r\n        bytes32,\r\n        bool,\r\n        uint8,\r\n        bool,\r\n        uint256\r\n    ) {\r\n      return (\r\n        customers[_provider][_customer].countryJurisdiction,\r\n        customers[_provider][_customer].divisionJurisdiction,\r\n        customers[_provider][_customer].accredited,\r\n        customers[_provider][_customer].role,\r\n        customers[_provider][_customer].verified,\r\n        customers[_provider][_customer].expires\r\n      );\r\n    }\r\n\r\n    /**\r\n     * Get provider details and fee by ethereum address\r\n     * @param _providerAddress Address of the KYC provider\r\n     */\r\n    function getProvider(address _providerAddress) public constant returns (\r\n        string name,\r\n        uint256 joined,\r\n        bytes32 details,\r\n        uint256 fee\r\n    ) {\r\n      return (\r\n        providers[_providerAddress].name,\r\n        providers[_providerAddress].joined,\r\n        providers[_providerAddress].details,\r\n        providers[_providerAddress].fee\r\n      );\r\n    }\r\n\r\n}\r\n\r\n/*\r\n  Polymath compliance template is intended to ensure regulatory compliance\r\n  in the jurisdictions that security tokens are being offered in. The compliance\r\n  template allows security tokens to enforce purchase restrictions on chain and\r\n  keep a log of documents for future auditing purposes.\r\n*/\r\n\r\n\r\n\r\n/**\r\n * @title Template\r\n * @dev  Template details used for the security token offering to ensure the regulatory compliance\r\n */\r\n\r\ncontract Template is ITemplate {\r\n\r\n    string public VERSION = \"1\";\r\n\r\n    address public owner;                                           // Address of the owner of template\r\n    string public offeringType;                                     // Name of the security being issued\r\n    bytes32 public issuerJurisdiction;                              // Variable contains the jurisdiction of the issuer of the template\r\n    mapping(bytes32 => bool) public allowedJurisdictions;           // Mapping that contains the allowed staus of Jurisdictions\r\n    mapping(bytes32 => bool) public blockedDivisionJurisdictions;   // Mapping that contains the allowed staus of Jurisdictions\r\n    mapping(uint8 => bool) public allowedRoles;                     // Mapping that contains the allowed status of Roles\r\n    bool public accredited;                                         // Variable that define the required level of accrediation for the investor\r\n    address public KYC;                                             // Address of the KYC provider\r\n    bytes32 details;                                                // Details of the offering requirements\r\n    bool finalized;                                                 // Variable to know the status of the template (complete - true, not complete - false)\r\n    uint256 public expires;                                         // Timestamp when template expires\r\n    uint256 fee;                                                    // Amount of POLY to use the template (held in escrow until issuance)\r\n    uint8 quorum;                                                   // Minimum percent of shareholders which need to vote to freeze\r\n    uint256 vestingPeriod;                                          // Length of time to vest funds\r\n\r\n    event DetailsUpdated(bytes32 _prevDetails, bytes32 _newDetails, uint _updateDate);\r\n\r\n    function Template (\r\n        address _owner,\r\n        string _offeringType,\r\n        bytes32 _issuerJurisdiction,\r\n        bool _accredited,\r\n        address _KYC,\r\n        bytes32 _details,\r\n        uint256 _expires,\r\n        uint256 _fee,\r\n        uint8 _quorum,\r\n        uint256 _vestingPeriod\r\n    ) public\r\n    {\r\n        require(_KYC != address(0) && _owner != address(0));\r\n        require(_fee > 0);\r\n        require(_details.length > 0 && _expires > now && _issuerJurisdiction.length > 0);\r\n        require(_quorum > 0 && _quorum <= 100);\r\n        require(_vestingPeriod > 0);\r\n        owner = _owner;\r\n        offeringType = _offeringType;\r\n        issuerJurisdiction = _issuerJurisdiction;\r\n        accredited = _accredited;\r\n        KYC = _KYC;\r\n        details = _details;\r\n        finalized = false;\r\n        expires = _expires;\r\n        fee = _fee;\r\n        quorum = _quorum;\r\n        vestingPeriod = _vestingPeriod;\r\n    }\r\n\r\n    /**\r\n     * @dev `addJurisdiction` allows the adding of new jurisdictions to a template\r\n     * @param _allowedJurisdictions An array of jurisdictions\r\n     * @param _allowed An array of whether the jurisdiction is allowed to purchase the security or not\r\n     */\r\n    function addJurisdiction(bytes32[] _allowedJurisdictions, bool[] _allowed) public {\r\n        require(owner == msg.sender);\r\n        require(_allowedJurisdictions.length == _allowed.length);\r\n        require(!finalized);\r\n        for (uint i = 0; i < _allowedJurisdictions.length; ++i) {\r\n            allowedJurisdictions[_allowedJurisdictions[i]] = _allowed[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev `addJurisdiction` allows the adding of new jurisdictions to a template\r\n     * @param _blockedDivisionJurisdictions An array of subdivision jurisdictions\r\n     * @param _blocked An array of whether the subdivision jurisdiction is blocked to purchase the security or not\r\n     */\r\n    function addDivisionJurisdiction(bytes32[] _blockedDivisionJurisdictions, bool[] _blocked) public {\r\n        require(owner == msg.sender);\r\n        require(_blockedDivisionJurisdictions.length == _blocked.length);\r\n        require(!finalized);\r\n        for (uint i = 0; i < _blockedDivisionJurisdictions.length; ++i) {\r\n            blockedDivisionJurisdictions[_blockedDivisionJurisdictions[i]] = _blocked[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev `addRole` allows the adding of new roles to be added to whitelist\r\n     * @param _allowedRoles User roles that can purchase the security\r\n     */\r\n    function addRoles(uint8[] _allowedRoles) public {\r\n        require(owner == msg.sender);\r\n        require(!finalized);\r\n        for (uint i = 0; i < _allowedRoles.length; ++i) {\r\n            allowedRoles[_allowedRoles[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice `updateDetails`\r\n     * @param _details details of the template need to change\r\n     * @return allowed boolean variable\r\n     */\r\n    function updateDetails(bytes32 _details) public returns (bool allowed) {\r\n        require(_details != 0x0);\r\n        require(owner == msg.sender);\r\n        bytes32 prevDetails = details;\r\n        details = _details;\r\n        DetailsUpdated(prevDetails, details, now);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev `finalizeTemplate` is used to finalize template.full compliance process/requirements\r\n     * @return success\r\n     */\r\n    function finalizeTemplate() public returns (bool success) {\r\n        require(owner == msg.sender);\r\n        finalized = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev `checkTemplateRequirements` is a constant function that checks if templates requirements are met\r\n     * @param _countryJurisdiction The ISO-3166 code of the investors country jurisdiction\r\n     * @param _divisionJurisdiction The ISO-3166 code of the investors subdivision jurisdiction\r\n     * @param _accredited Whether the investor is accredited or not\r\n     * @param _role role of the user\r\n     * @return allowed boolean variable\r\n     */\r\n    function checkTemplateRequirements(\r\n        bytes32 _countryJurisdiction,\r\n        bytes32 _divisionJurisdiction,\r\n        bool _accredited,\r\n        uint8 _role\r\n    ) public constant returns (bool allowed)\r\n    {\r\n        require(_countryJurisdiction != 0x0);\r\n        require(allowedJurisdictions[_countryJurisdiction] || !blockedDivisionJurisdictions[_divisionJurisdiction]);\r\n        require(allowedRoles[_role]);\r\n        if (accredited) {\r\n            require(_accredited);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev getTemplateDetails is a constant function that gets template details\r\n     * @return bytes32 details, bool finalized\r\n     */\r\n    function getTemplateDetails() view public returns (bytes32, bool) {\r\n        require(expires > now);\r\n        return (details, finalized);\r\n    }\r\n\r\n    /**\r\n     * @dev `getUsageFees` is a function to get all the details on template usage fees\r\n     * @return uint256 fee, uint8 quorum, uint256 vestingPeriod, address owner, address KYC\r\n     */\r\n    function getUsageDetails() view public returns (uint256, uint8, uint256, address, address) {\r\n        return (fee, quorum, vestingPeriod, owner, KYC);\r\n    }\r\n}\r\n\r\ninterface ISecurityToken {\r\n\r\n    /**\r\n     * @dev Set default security token parameters\r\n     * @param _name Name of the security token\r\n     * @param _ticker Ticker name of the security\r\n     * @param _totalSupply Total amount of tokens being created\r\n     * @param _decimals Decimals for token\r\n     * @param _owner Ethereum address of the security token owner\r\n     * @param _maxPoly Amount of maximum poly issuer want to raise\r\n     * @param _lockupPeriod Length of time raised POLY will be locked up for dispute\r\n     * @param _quorum Percent of initial investors required to freeze POLY raise\r\n     * @param _polyTokenAddress Ethereum address of the POLY token contract\r\n     * @param _polyCustomersAddress Ethereum address of the PolyCustomers contract\r\n     * @param _polyComplianceAddress Ethereum address of the PolyCompliance contract\r\n     */\r\n    function SecurityToken(\r\n        string _name,\r\n        string _ticker,\r\n        uint256 _totalSupply,\r\n        uint8 _decimals,\r\n        address _owner,\r\n        uint256 _maxPoly,\r\n        uint256 _lockupPeriod,\r\n        uint8 _quorum,\r\n        address _polyTokenAddress,\r\n        address _polyCustomersAddress,\r\n        address _polyComplianceAddress\r\n    ) public;\r\n\r\n   /**\r\n     * @dev `selectTemplate` Select a proposed template for the issuance\r\n     * @param _templateIndex Array index of the delegates proposed template\r\n     * @return bool success\r\n     */\r\n    function selectTemplate(uint8 _templateIndex) public returns (bool success);\r\n\r\n    /**\r\n     * @dev Update compliance proof hash for the issuance\r\n     * @param _newMerkleRoot New merkle root hash of the compliance Proofs\r\n     * @param _complianceProof Compliance Proof hash\r\n     * @return bool success\r\n     */\r\n    function updateComplianceProof(\r\n        bytes32 _newMerkleRoot,\r\n        bytes32 _complianceProof\r\n    ) public returns (bool success);\r\n\r\n    /**\r\n     * @dev `selectOfferingProposal` Select an security token offering proposal for the issuance\r\n     * @param _offeringProposalIndex Array index of the STO proposal\r\n     * @return bool success\r\n     */\r\n    function selectOfferingProposal (\r\n        uint8 _offeringProposalIndex\r\n    ) public returns (bool success);\r\n\r\n    /**\r\n     * @dev Start the offering by sending all the tokens to STO contract\r\n     * @return bool\r\n     */\r\n    function startOffering() external returns (bool success);\r\n\r\n    /**\r\n     * @dev Add a verified address to the Security Token whitelist\r\n     * @param _whitelistAddress Address attempting to join ST whitelist\r\n     * @return bool success\r\n     */\r\n    function addToWhitelist(uint8 KYCProviderIndex, address _whitelistAddress) public returns (bool success);\r\n\r\n     /**\r\n      * @dev Allow POLY allocations to be withdrawn by owner, delegate, and the STO auditor at appropriate times\r\n      * @return bool success \r\n      */\r\n    function withdrawPoly() public returns (bool success);\r\n\r\n    /**\r\n     * @dev Vote to freeze the fee of a certain network participant\r\n     * @param _recipient The fee recipient being protested\r\n     * @return bool success\r\n     */\r\n    function voteToFreeze(address _recipient) public returns (bool success);\r\n\r\n    /**\r\n     * @dev `issueSecurityTokens` is used by the STO to keep track of STO investors\r\n     * @param _contributor The address of the person whose contributing\r\n     * @param _amountOfSecurityTokens The amount of ST to pay out.\r\n     * @param _polyContributed The amount of POLY paid for the security tokens.\r\n     */\r\n    function issueSecurityTokens(address _contributor, uint256 _amountOfSecurityTokens, uint256 _polyContributed) public returns (bool success);\r\n\r\n    /// Get token details\r\n    function getTokenDetails() view public returns (address, address, bytes32, address, address);\r\n\r\n    /**\r\n     * @dev Trasfer tokens from one address to another\r\n     * @param _to Ethereum public address to transfer tokens to\r\n     * @param _value Amount of tokens to send\r\n     * @return bool success\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /**\r\n     * @dev Allows contracts to transfer tokens on behalf of token holders\r\n     * @param _from Address to transfer tokens from\r\n     * @param _to Address to send tokens to\r\n     * @param _value Number of tokens to transfer\r\n     * @return bool success\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /**\r\n     * @dev `balanceOf` used to get the balance of shareholders\r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Approve transfer of tokens manually\r\n     * @param _spender Address to approve transfer to\r\n     * @param _value Amount of tokens to approve for transfer\r\n     * @return bool success\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /**\r\n     * @dev Use to get the allowance provided to the spender\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n  }\r\n\r\n/*\r\n  Polymath compliance protocol is intended to ensure regulatory compliance\r\n  in the jurisdictions that security tokens are being offered in. The compliance\r\n  protocol allows security tokens remain interoperable so that anyone can\r\n  build on top of the Polymath platform and extend it's functionality.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Compilance\r\n * @dev Regulatory details offered by the security token\r\n */\r\n\r\ncontract Compliance is ICompliance {\r\n\r\n    string public VERSION = \"1\";\r\n\r\n    ITemplate template;\r\n\r\n    SecurityTokenRegistrar public STRegistrar;\r\n\r\n    struct TemplateReputation {                                         // Structure contains the compliance template details\r\n        address owner;                                                  // Address of the template owner\r\n        uint256 totalRaised;                                            // Total amount raised by the issuers that used the template\r\n        uint256 timesUsed;                                              // How many times template will be used as the compliance regulator for different security token\r\n        uint256 expires;                                                // Timestamp when template get expire\r\n        address[] usedBy;                                               // Array of security token addresses that used the particular template\r\n    }\r\n    mapping(address => TemplateReputation) public templates;                   // Mapping used for storing the template past records corresponds to template address\r\n    mapping(address => address[]) public templateProposals;             // Template proposals for a specific security token\r\n\r\n    struct Offering {                                                   // Smart contract proposals for a specific security token offering\r\n        address auditor;\r\n        uint256 fee;\r\n        uint256 vestingPeriod;\r\n        uint8 quorum;\r\n        address[] usedBy;\r\n    }\r\n    mapping(address => Offering) offerings;                             // Mapping used for storing the Offering detials corresponds to offering contract address\r\n    mapping(address => address[]) public offeringProposals;             // Security token contract proposals for a specific security token\r\n\r\n    Customers public PolyCustomers;                                      // Instance of the Compliance contract\r\n    uint256 public constant MINIMUM_VESTING_PERIOD = 60 * 60 * 24 * 100; // 100 Day minimum vesting period for POLY earned\r\n\r\n    // Notifications\r\n    event LogTemplateCreated(address indexed _creator, address _template, string _offeringType);\r\n    event LogNewTemplateProposal(address indexed _securityToken, address _template, address _delegate, uint _templateProposalIndex);\r\n    event LogCancelTemplateProposal(address indexed _securityToken, address _template, uint _templateProposalIndex);\r\n    event LogNewContractProposal(address indexed _securityToken, address _offeringContract, address _delegate, uint _offeringProposalIndex);\r\n    event LogCancelContractProposal(address indexed _securityToken, address _offeringContract, uint _offeringProposalIndex);\r\n\r\n    /* @param _polyCustomersAddress The address of the Polymath Customers contract */\r\n    function Compliance(address _polyCustomersAddress) public {\r\n        PolyCustomers = Customers(_polyCustomersAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev `setRegsitrarAddress` This function set the SecurityTokenRegistrar contract address.\r\n     * @param _STRegistrar It is the `this` reference of STR contract\r\n     * @return bool\r\n     */\r\n\r\n    function setRegsitrarAddress(address _STRegistrar) public returns (bool) {\r\n        require(STRegistrar == address(0));\r\n        STRegistrar = SecurityTokenRegistrar(_STRegistrar);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev `createTemplate` is a simple function to create a new compliance template\r\n     * @param _offeringType The name of the security being issued\r\n     * @param _issuerJurisdiction The jurisdiction id of the issuer\r\n     * @param _accredited Accreditation status required for investors\r\n     * @param _KYC KYC provider used by the template\r\n     * @param _details Details of the offering requirements\r\n     * @param _expires Timestamp of when the template will expire\r\n     * @param _fee Amount of POLY to use the template (held in escrow until issuance)\r\n     * @param _quorum Minimum percent of shareholders which need to vote to freeze\r\n     * @param _vestingPeriod Length of time to vest funds\r\n     */\r\n    function createTemplate(\r\n        string _offeringType,\r\n        bytes32 _issuerJurisdiction,\r\n        bool _accredited,\r\n        address _KYC,\r\n        bytes32 _details,\r\n        uint256 _expires,\r\n        uint256 _fee,\r\n        uint8 _quorum,\r\n        uint256 _vestingPeriod\r\n    ) public\r\n    {\r\n      require(_KYC != address(0));\r\n      require(_vestingPeriod >= MINIMUM_VESTING_PERIOD);\r\n      address _template = new Template(\r\n          msg.sender,\r\n          _offeringType,\r\n          _issuerJurisdiction,\r\n          _accredited,\r\n          _KYC,\r\n          _details,\r\n          _expires,\r\n          _fee,\r\n          _quorum,\r\n          _vestingPeriod\r\n      );\r\n      templates[_template] = TemplateReputation({\r\n          owner: msg.sender,\r\n          totalRaised: 0,\r\n          timesUsed: 0,\r\n          expires: _expires,\r\n          usedBy: new address[](0)\r\n      });\r\n      LogTemplateCreated(msg.sender, _template, _offeringType);\r\n    }\r\n\r\n    /**\r\n     * @dev Propose a bid for a security token issuance\r\n     * @param _securityToken The security token being bid on\r\n     * @param _template The unique template address\r\n     * @return bool success\r\n     */\r\n    function proposeTemplate(\r\n        address _securityToken,\r\n        address _template\r\n    ) public returns (bool success)\r\n    {\r\n        // Verifying that provided _securityToken is generated by securityTokenRegistrar only\r\n        var (totalSupply, owner,,) = STRegistrar.getSecurityTokenData(_securityToken);\r\n        require(totalSupply > 0 && owner != address(0));\r\n        // Require that template has not expired, that the caller is the\r\n        // owner of the template and that the template has been finalized\r\n        require(templates[_template].expires > now);\r\n        require(templates[_template].owner == msg.sender);\r\n        // Creating the instance of template to avail the function calling\r\n        template = Template(_template);\r\n        var (,finalized) = template.getTemplateDetails();\r\n        require(finalized);\r\n\r\n        //Get a reference of the template contract and add it to the templateProposals array\r\n        templateProposals[_securityToken].push(_template);\r\n        LogNewTemplateProposal(_securityToken, _template, msg.sender,templateProposals[_securityToken].length -1);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel a Template proposal if the bid hasn't been accepted\r\n     * @param _securityToken The security token being bid on\r\n     * @param _templateProposalIndex The template proposal array index\r\n     * @return bool success\r\n     */\r\n    function cancelTemplateProposal(\r\n        address _securityToken,\r\n        uint256 _templateProposalIndex\r\n    ) public returns (bool success)\r\n    {\r\n        address proposedTemplate = templateProposals[_securityToken][_templateProposalIndex];\r\n        require(templates[proposedTemplate].owner == msg.sender);\r\n        var (chosenTemplate,,,,) = ISecurityToken(_securityToken).getTokenDetails();\r\n        require(chosenTemplate != proposedTemplate);\r\n        templateProposals[_securityToken][_templateProposalIndex] = address(0);\r\n        LogCancelTemplateProposal(_securityToken, proposedTemplate, _templateProposalIndex);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the STO contract by the issuer.\r\n     * @param _STOAddress address of the STO contract deployed over the network.\r\n     * @param _fee fee to be paid in poly to use that contract\r\n     * @param _vestingPeriod no. of days investor binded to hold the Security token\r\n     * @param _quorum Minimum percent of shareholders which need to vote to freeze\r\n     */\r\n    function setSTO (\r\n        address _STOAddress,\r\n        uint256 _fee,\r\n        uint256 _vestingPeriod,\r\n        uint8 _quorum\r\n        ) public returns (bool success)\r\n    {\r\n            require(offerings[_STOAddress].auditor == address(0));\r\n            require(_STOAddress != address(0));\r\n            require(_quorum > 0 && _quorum <= 100);\r\n            require(_vestingPeriod >= MINIMUM_VESTING_PERIOD);\r\n            require(_fee > 0);\r\n            offerings[_STOAddress].auditor = msg.sender;\r\n            offerings[_STOAddress].fee = _fee;\r\n            offerings[_STOAddress].vestingPeriod = _vestingPeriod;\r\n            offerings[_STOAddress].quorum = _quorum;\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Propose a Security Token Offering Contract for an issuance\r\n     * @param _securityToken The security token being bid on\r\n     * @param _stoContract The security token offering contract address\r\n     * @return bool success\r\n     */\r\n    function proposeOfferingContract(\r\n        address _securityToken,\r\n        address _stoContract\r\n    ) public returns (bool success)\r\n    {\r\n        // Verifying that provided _securityToken is generated by securityTokenRegistrar only\r\n        var (totalSupply, owner,,) = STRegistrar.getSecurityTokenData(_securityToken);\r\n        require(totalSupply > 0 && owner != address(0));\r\n\r\n        var (,,,,KYC) = ISecurityToken(_securityToken).getTokenDetails();\r\n        var (,,, verified, expires) = PolyCustomers.getCustomer(KYC, offerings[_stoContract].auditor);\r\n        require(offerings[_stoContract].auditor == msg.sender);\r\n        require(verified);\r\n        require(expires > now);\r\n        offeringProposals[_securityToken].push(_stoContract);\r\n        LogNewContractProposal(_securityToken, _stoContract, msg.sender,offeringProposals[_securityToken].length -1);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel a STO contract proposal if the bid hasn't been accepted\r\n     * @param _securityToken The security token being bid on\r\n     * @param _offeringProposalIndex The offering proposal array index\r\n     * @return bool success\r\n     */\r\n    function cancelOfferingProposal(\r\n        address _securityToken,\r\n        uint256 _offeringProposalIndex\r\n    ) public returns (bool success)\r\n    {\r\n        address proposedOffering = offeringProposals[_securityToken][_offeringProposalIndex];\r\n        require(offerings[proposedOffering].auditor == msg.sender);\r\n        var (,,,,chosenOffering) = ISecurityToken(_securityToken).getTokenDetails();\r\n        require(chosenOffering != proposedOffering);\r\n        offeringProposals[_securityToken][_offeringProposalIndex] = address(0);\r\n        LogCancelContractProposal(_securityToken, proposedOffering, _offeringProposalIndex);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev `updateTemplateReputation` is a constant function that updates the\r\n       history of a security token template usage to keep track of previous uses\r\n     * @param _template The unique template id\r\n     * @param _templateIndex The array index of the template proposal\r\n     */\r\n    function updateTemplateReputation (address _template, uint8 _templateIndex) external returns (bool success) {\r\n        require(templateProposals[msg.sender][_templateIndex] == _template);\r\n        templates[_template].usedBy.push(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev `updateOfferingReputation` is a constant function that updates the\r\n       history of a security token offering contract to keep track of previous uses\r\n     * @param _stoContract The smart contract address of the STO contract\r\n     * @param _offeringProposalIndex The array index of the security token offering proposal\r\n     */\r\n    function updateOfferingReputation (address _stoContract, uint8 _offeringProposalIndex) external returns (bool success) {\r\n        require(offeringProposals[msg.sender][_offeringProposalIndex] == _stoContract);\r\n        offerings[_stoContract].usedBy.push(msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Get template details by the proposal index\r\n     * @param _securityTokenAddress The security token ethereum address\r\n     * @param _templateIndex The array index of the template being checked\r\n     * @return Template struct\r\n     */\r\n    function getTemplateByProposal(address _securityTokenAddress, uint8 _templateIndex) view public returns (\r\n        address _template\r\n    ){\r\n        return templateProposals[_securityTokenAddress][_templateIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Get an array containing the address of all template proposals for a given ST\r\n     * @param _securityTokenAddress The security token ethereum address\r\n     * @return Template proposals array\r\n     */\r\n    function getAllTemplateProposals(address _securityTokenAddress) view public returns (address[]){\r\n        return templateProposals[_securityTokenAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev Get security token offering smart contract details by the proposal index\r\n     * @param _securityTokenAddress The security token ethereum address\r\n     * @param _offeringProposalIndex The array index of the STO contract being checked\r\n     * @return Contract struct\r\n     */\r\n    function getOfferingByProposal(address _securityTokenAddress, uint8 _offeringProposalIndex) view public returns (\r\n        address stoContract,\r\n        address auditor,\r\n        uint256 vestingPeriod,\r\n        uint8 quorum,\r\n        uint256 fee\r\n    ){\r\n        address _stoContract = offeringProposals[_securityTokenAddress][_offeringProposalIndex];\r\n        return (\r\n            _stoContract,\r\n            offerings[_stoContract].auditor,\r\n            offerings[_stoContract].vestingPeriod,\r\n            offerings[_stoContract].quorum,\r\n            offerings[_stoContract].fee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get an array containing the address of all offering proposals for a given ST\r\n     * @param _securityTokenAddress The security token ethereum address\r\n     * @return Offering proposals array\r\n     */\r\n    function getAllOfferingProposals(address _securityTokenAddress) view public returns (address[]){\r\n        return offeringProposals[_securityTokenAddress];\r\n    }\r\n\r\n}\r\n\r\n/*\r\n  The Polymath Security Token Registrar provides a way to lookup security token details\r\n  from a single place and allows wizard creators to earn POLY fees by uploading to the\r\n  registrar.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SecurityTokenRegistrar\r\n * @dev Contract use to register the security token on Polymath platform\r\n */\r\n\r\ncontract SecurityTokenRegistrar is ISTRegistrar {\r\n\r\n    string public VERSION = \"1\";\r\n    SecurityToken securityToken;\r\n    address public polyTokenAddress;                                // Address of POLY token\r\n    address public polyCustomersAddress;                            // Address of the polymath-core Customers contract address\r\n    address public polyComplianceAddress;                           // Address of the polymath-core Compliance contract address\r\n\r\n    // Security Token\r\n    struct SecurityTokenData {                                      // A structure that contains the specific info of each ST\r\n      uint256 totalSupply;                                          // created ever using the Polymath platform\r\n      address owner;\r\n      uint8 decimals;\r\n      string ticker;\r\n      uint8 securityType;\r\n    }\r\n    mapping(address => SecurityTokenData) securityTokens;           // Array contains the details of security token corresponds to security token address\r\n    mapping(string => address) tickers;                             // Mapping of ticker name to Security Token\r\n\r\n    event LogNewSecurityToken(string ticker, address securityTokenAddress, address owner, address host, uint256 fee, uint8 _type);\r\n    /**\r\n     * @dev Constructor use to set the essentials addresses to facilitate\r\n     * the creation of the security token\r\n     */\r\n    function SecurityTokenRegistrar(\r\n      address _polyTokenAddress,\r\n      address _polyCustomersAddress,\r\n      address _polyComplianceAddress\r\n    ) public\r\n    {\r\n      polyTokenAddress = _polyTokenAddress;\r\n      polyCustomersAddress = _polyCustomersAddress;\r\n      polyComplianceAddress = _polyComplianceAddress;\r\n      // Creating the instance of the compliance contract and assign the STR contract \r\n      // address (this) into the compliance contract\r\n      Compliance PolyCompliance = Compliance(polyComplianceAddress);\r\n      require(PolyCompliance.setRegsitrarAddress(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a new Security Token and saves it to the registry\r\n     * @param _name Name of the security token\r\n     * @param _ticker Ticker name of the security\r\n     * @param _totalSupply Total amount of tokens being created\r\n     * @param _decimals Decimals value for token\r\n     * @param _owner Ethereum public key address of the security token owner\r\n     * @param _maxPoly Amount of maximum poly issuer want to raise\r\n     * @param _host The host of the security token wizard\r\n     * @param _fee Fee being requested by the wizard host\r\n     * @param _type Type of security being tokenized\r\n     * @param _lockupPeriod Length of time raised POLY will be locked up for dispute\r\n     * @param _quorum Percent of initial investors required to freeze POLY raise\r\n     */\r\n    function createSecurityToken (\r\n      string _name,\r\n      string _ticker,\r\n      uint256 _totalSupply,\r\n      uint8 _decimals,\r\n      address _owner,\r\n      uint256 _maxPoly,\r\n      address _host,\r\n      uint256 _fee,\r\n      uint8 _type,\r\n      uint256 _lockupPeriod,\r\n      uint8 _quorum\r\n    ) external\r\n    {\r\n      require(_totalSupply > 0 && _maxPoly > 0 && _fee > 0);\r\n      require(tickers[_ticker] == 0x0);\r\n      require(_lockupPeriod >= now);\r\n      require(_owner != address(0) && _host != address(0));\r\n      require(bytes(_name).length > 0 && bytes(_ticker).length > 0);\r\n      IERC20 POLY = IERC20(polyTokenAddress);\r\n      POLY.transferFrom(msg.sender, _host, _fee);\r\n      address newSecurityTokenAddress = initialiseSecurityToken(_name, _ticker, _totalSupply, _decimals, _owner, _maxPoly, _type, _lockupPeriod, _quorum);\r\n      LogNewSecurityToken(_ticker, newSecurityTokenAddress, _owner, _host, _fee, _type);\r\n    }\r\n\r\n    function initialiseSecurityToken(\r\n      string _name,\r\n      string _ticker,\r\n      uint256 _totalSupply,\r\n      uint8 _decimals,\r\n      address _owner,\r\n      uint256 _maxPoly,\r\n      uint8 _type,\r\n      uint256 _lockupPeriod,\r\n      uint8 _quorum\r\n    ) internal returns (address)\r\n    {\r\n      address newSecurityTokenAddress = new SecurityToken(\r\n        _name,\r\n        _ticker,\r\n        _totalSupply,\r\n        _decimals,\r\n        _owner,\r\n        _maxPoly,\r\n        _lockupPeriod,\r\n        _quorum,\r\n        polyTokenAddress,\r\n        polyCustomersAddress,\r\n        polyComplianceAddress\r\n      );\r\n      tickers[_ticker] = newSecurityTokenAddress;\r\n      securityTokens[newSecurityTokenAddress] = SecurityTokenData(\r\n        _totalSupply,\r\n        _owner,\r\n        _decimals,\r\n        _ticker,\r\n        _type\r\n      );\r\n      return newSecurityTokenAddress;\r\n    }\r\n\r\n    //////////////////////////////\r\n    ///////// Get Functions\r\n    //////////////////////////////\r\n    /**\r\n     * @dev Get security token address by ticker name\r\n     * @param _ticker Symbol of the Scurity token\r\n     * @return address _ticker\r\n     */\r\n    function getSecurityTokenAddress(string _ticker) public constant returns (address) {\r\n      return tickers[_ticker];\r\n    }\r\n\r\n    /**\r\n     * @dev Get Security token details by its ethereum address\r\n     * @param _STAddress Security token address\r\n     */\r\n    function getSecurityTokenData(address _STAddress) public constant returns (\r\n      uint256 totalSupply,\r\n      address owner,\r\n      uint8 decimals,\r\n      string ticker,\r\n      uint8 securityType\r\n    ) {\r\n      return (\r\n        securityTokens[_STAddress].totalSupply,\r\n        securityTokens[_STAddress].owner,\r\n        securityTokens[_STAddress].decimals,\r\n        securityTokens[_STAddress].ticker,\r\n        securityTokens[_STAddress].securityType\r\n      );\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"polyCustomersAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_STAddress\",\"type\":\"address\"}],\"name\":\"getSecurityTokenData\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"ticker\",\"type\":\"string\"},{\"name\":\"securityType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyComplianceAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ticker\",\"type\":\"string\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_maxPoly\",\"type\":\"uint256\"},{\"name\":\"_host\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint8\"},{\"name\":\"_lockupPeriod\",\"type\":\"uint256\"},{\"name\":\"_quorum\",\"type\":\"uint8\"}],\"name\":\"createSecurityToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"polyTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ticker\",\"type\":\"string\"}],\"name\":\"getSecurityTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_polyTokenAddress\",\"type\":\"address\"},{\"name\":\"_polyCustomersAddress\",\"type\":\"address\"},{\"name\":\"_polyComplianceAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ticker\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"securityTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"host\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"LogNewSecurityToken\",\"type\":\"event\"}]","ContractName":"SecurityTokenRegistrar","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009992ec3cf6a55b00978cddf2b27bc6882d88d1ec000000000000000000000000eb30a60c199664ab84dec3f8b72de3badf1837f5000000000000000000000000076719c05961a0c3398e558e2199085d32717ca6","Library":"","SwarmSource":"bzzr://06534fc2f55513ff0abf6fbbca8b905ff063767300e67594cbd0d7d77a2bb2cf"}]}