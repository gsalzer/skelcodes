{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\nlibrary SafeMath {\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract Ownable {\r\n\taddress public owner;\r\n\taddress public controller;\r\n\t\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tconstructor() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier onlyController() {\r\n\t\trequire(msg.sender == controller);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n\t\r\n\tfunction setControler(address _controller) public onlyOwner {\r\n\t\tcontroller = _controller;\r\n\t}\r\n}\r\n\r\ncontract OwnableToken {\r\n\taddress public owner;\r\n\taddress public minter;\r\n\taddress public burner;\r\n\taddress public controller;\r\n\t\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\tfunction OwnableToken() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier onlyMinter() {\r\n\t\trequire(msg.sender == minter);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier onlyBurner() {\r\n\t\trequire(msg.sender == burner);\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyController() {\r\n\t\trequire(msg.sender == controller);\r\n\t\t_;\r\n\t}\r\n  \r\n\tmodifier onlyPayloadSize(uint256 numwords) {                                       \r\n\t\tassert(msg.data.length == numwords * 32 + 4);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n\t\r\n\tfunction setMinter(address _minterAddress) public onlyOwner {\r\n\t\tminter = _minterAddress;\r\n\t}\r\n\t\r\n\tfunction setBurner(address _burnerAddress) public onlyOwner {\r\n\t\tburner = _burnerAddress;\r\n\t}\r\n\t\r\n\tfunction setControler(address _controller) public onlyOwner {\r\n\t\tcontroller = _controller;\r\n\t}\r\n}\r\n\r\ncontract KYCControl is OwnableToken {\r\n\tevent KYCApproved(address _user, bool isApproved);\r\n\tmapping(address => bool) public KYCParticipants;\r\n\t\r\n\tfunction isKYCApproved(address _who) view public returns (bool _isAprroved){\r\n\t\treturn KYCParticipants[_who];\r\n\t}\r\n\r\n\tfunction approveKYC(address _userAddress) onlyController public {\r\n\t\tKYCParticipants[_userAddress] = true;\r\n\t\temit KYCApproved(_userAddress, true);\r\n\t}\r\n}\r\n\r\ncontract VernamCrowdSaleToken is OwnableToken, KYCControl {\r\n\tusing SafeMath for uint256;\r\n\t\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n\t/* Public variables of the token */\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tuint256 public _totalSupply;\r\n\t\r\n\t/*Private Variables*/\r\n\tuint256 constant POW = 10 ** 18;\r\n\tuint256 _circulatingSupply;\r\n\t\r\n\t/* This creates an array with all balances */\r\n\tmapping (address => uint256) public balances;\r\n\t\t\r\n\t// This notifies clients about the amount burnt\r\n\tevent Burn(address indexed from, uint256 value);\r\n\tevent Mint(address indexed _participant, uint256 value);\r\n\r\n\t/* Initializes contract with initial supply tokens to the creator of the contract */\r\n\tfunction VernamCrowdSaleToken() public {\r\n\t\tname = \"Vernam Crowdsale Token\";                            // Set the name for display purposes\r\n\t\tsymbol = \"VCT\";                               \t\t\t\t// Set the symbol for display purposes\r\n\t\tdecimals = 18;                            \t\t\t\t\t// Amount of decimals for display purposes\r\n\t\t_totalSupply = SafeMath.mul(1000000000, POW);     \t\t\t//1 Billion Tokens with 18 Decimals\r\n\t\t_circulatingSupply = 0;\r\n\t}\r\n\t\r\n\tfunction mintToken(address _participant, uint256 _mintedAmount) public onlyMinter returns (bool _success) {\r\n\t\trequire(_mintedAmount > 0);\r\n\t\trequire(_circulatingSupply.add(_mintedAmount) <= _totalSupply);\r\n\t\tKYCParticipants[_participant] = false;\r\n\r\n        balances[_participant] =  balances[_participant].add(_mintedAmount);\r\n        _circulatingSupply = _circulatingSupply.add(_mintedAmount);\r\n\t\t\r\n\t\temit Transfer(0, this, _mintedAmount);\r\n        emit Transfer(this, _participant, _mintedAmount);\r\n\t\temit Mint(_participant, _mintedAmount);\r\n\t\t\r\n\t\treturn true;\r\n    }\r\n\t\r\n\tfunction burn(address _participant, uint256 _value) public onlyBurner returns (bool _success) {\r\n        require(_value > 0);\r\n\t\trequire(balances[_participant] >= _value);   \t\t\t\t\t\t\t// Check if the sender has enough\r\n\t\trequire(isKYCApproved(_participant) == true);\r\n\t\tbalances[_participant] = balances[_participant].sub(_value);            // Subtract from the sender\r\n\t\t_circulatingSupply = _circulatingSupply.sub(_value);\r\n        _totalSupply = _totalSupply.sub(_value);                      \t\t\t// Updates totalSupply\r\n\t\temit Transfer(_participant, 0, _value);\r\n        emit Burn(_participant, _value);\r\n        \r\n\t\treturn true;\r\n    }\r\n  \r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\t\r\n\tfunction circulatingSupply() public view returns (uint256) {\r\n\t\treturn _circulatingSupply;\r\n\t}\r\n\t\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n}\r\n\r\ncontract VernamCrowdSale is Ownable {\r\n\tusing SafeMath for uint256;\r\n\t\r\n\t// After day 7 you can contribute only more than 10 ethers \r\n\tuint constant TEN_ETHERS = 10 ether;\r\n\t// Minimum and maximum contribution amount\r\n\tuint constant minimumContribution = 100 finney;\r\n\tuint constant maximumContribution = 500 ether;\r\n\t\r\n\t// \r\n\tuint constant FIRST_MONTH = 0;\r\n\tuint constant SECOND_MONTH = 1;\r\n\tuint constant THIRD_MONTH = 2;\r\n\tuint constant FORTH_MONTH = 3;\r\n\tuint constant FIFTH_MONTH = 4;\r\n\tuint constant SIXTH_MONTH = 5;\t\r\n\t\r\n\taddress public benecifiary;\r\n\t\r\n    // Check if the crowdsale is active\r\n\tbool public isInCrowdsale;\r\n\t\r\n\t// The start time of the crowdsale\r\n\tuint public startTime;\r\n\t// The total sold tokens\r\n\tuint public totalSoldTokens;\r\n\t\r\n\t// The total contributed wei\r\n\tuint public totalContributedWei;\r\n\r\n    // Public parameters for all the stages\r\n\tuint constant public threeHotHoursDuration = 3 hours;\r\n\tuint constant public threeHotHoursPriceOfTokenInWei = 63751115644524 wei; //0.00006375111564452380 ETH per Token // 15686 VRN per ETH\r\n\t\t\r\n\tuint public threeHotHoursTokensCap; \r\n\tuint public threeHotHoursCapInWei; \r\n\tuint public threeHotHoursEnd;\r\n\r\n\tuint public firstStageDuration = 8 days;\r\n\tuint public firstStagePriceOfTokenInWei = 85005100306018 wei;    //0.00008500510030601840 ETH per Token // 11764 VRN per ETH\r\n\r\n\tuint public firstStageEnd;\r\n\t\r\n\tuint constant public secondStageDuration = 12 days;\r\n\tuint constant public secondStagePriceOfTokenInWei = 90000900009000 wei;     //0.00009000090000900010 ETH per Token // 11111 VRN per ETH\r\n    \r\n\tuint public secondStageEnd;\r\n\t\r\n\tuint constant public thirdStageDuration = 41 days;\r\n\tuint constant public thirdStagePriceOfTokenInWei = 106258633513973 wei;          //0.00010625863351397300 ETH per Token // 9411 VRN per ETH\r\n\t\r\n\tuint constant public thirdStageDiscountPriceOfTokenInWei = 95002850085503 wei;  //0.00009500285008550260 ETH per Token // 10526 VRN per ETH\r\n\t\r\n\tuint public thirdStageEnd;\r\n\t\r\n\tuint constant public TOKENS_HARD_CAP = 500000000000000000000000000; // 500 000 000 with 18 decimals\r\n\t\r\n\t// 18 decimals\r\n\tuint constant POW = 10 ** 18;\r\n\t\r\n\t// Constants for Realase Three Hot Hours\r\n\tuint constant public LOCK_TOKENS_DURATION = 30 days;\r\n\tuint public firstMonthEnd;\r\n\tuint public secondMonthEnd;\r\n\tuint public thirdMonthEnd;\r\n\tuint public fourthMonthEnd;\r\n\tuint public fifthMonthEnd;\r\n    \r\n    // Mappings\r\n\tmapping(address => uint) public contributedInWei;\r\n\tmapping(address => uint) public threeHotHoursTokens;\r\n\tmapping(address => mapping(uint => uint)) public getTokensBalance;\r\n\tmapping(address => mapping(uint => bool)) public isTokensTaken;\r\n\tmapping(address => bool) public isCalculated;\r\n\t\r\n\tVernamCrowdSaleToken public vernamCrowdsaleToken;\r\n\t\r\n\t// Modifiers\r\n    modifier afterCrowdsale() {\r\n        require(block.timestamp > thirdStageEnd);\r\n        _;\r\n    }\r\n    \r\n    modifier isAfterThreeHotHours {\r\n\t    require(block.timestamp > threeHotHoursEnd);\r\n\t    _;\r\n\t}\r\n\t\r\n    // Events\r\n    event CrowdsaleActivated(uint startTime, uint endTime);\r\n    event TokensBought(address participant, uint weiAmount, uint tokensAmount);\r\n    event ReleasedTokens(uint _amount);\r\n    event TokensClaimed(address _participant, uint tokensToGetFromWhiteList);\r\n    \r\n    /** @dev Constructor \r\n      * @param _benecifiary \r\n      * @param _vernamCrowdSaleTokenAddress The address of the crowdsale token.\r\n      * \r\n      */\r\n\tconstructor(address _benecifiary, address _vernamCrowdSaleTokenAddress) public {\r\n\t\tbenecifiary = _benecifiary;\r\n\t\tvernamCrowdsaleToken = VernamCrowdSaleToken(_vernamCrowdSaleTokenAddress);\r\n        \r\n\t\tisInCrowdsale = false;\r\n\t}\r\n\t\r\n\t/** @dev Function which activates the crowdsale \r\n      * Only the owner can call the function\r\n      * Activates the threeHotHours and the whole crowdsale\r\n      * Set the duration of crowdsale stages \r\n      * Set the tokens and wei cap of crowdsale stages \r\n      * Set the duration in which the tokens bought in threeHotHours will be locked\r\n      */\r\n\tfunction activateCrowdSale() public onlyOwner {\r\n\t    \t\t\r\n\t\tsetTimeForCrowdsalePeriods();\r\n\t\t\r\n\t\tthreeHotHoursTokensCap = 100000000000000000000000000;\r\n\t\tthreeHotHoursCapInWei = threeHotHoursPriceOfTokenInWei.mul((threeHotHoursTokensCap).div(POW));\r\n\t    \r\n\t\ttimeLock();\r\n\t\t\r\n\t\tisInCrowdsale = true;\r\n\t\t\r\n\t    emit CrowdsaleActivated(startTime, thirdStageEnd);\r\n\t}\r\n\t\r\n\t/** @dev Fallback function.\r\n      * Provides functionality for person to buy tokens.\r\n      */\r\n\tfunction() public payable {\r\n\t\tbuyTokens(msg.sender,msg.value);\r\n\t}\r\n\t\r\n\t/** @dev Buy tokens function\r\n      * Provides functionality for person to buy tokens.\r\n      * @param _participant The investor which want to buy tokens.\r\n      * @param _weiAmount The wei amount which the investor want to contribute.\r\n      * @return success Is the buy tokens function called successfully.\r\n      */\r\n\tfunction buyTokens(address _participant, uint _weiAmount) public payable returns(bool success) {\r\n\t    // Check if the crowdsale is active\r\n\t\trequire(isInCrowdsale == true);\r\n\t\t// Check if the wei amount is between minimum and maximum contribution amount\r\n\t\trequire(_weiAmount >= minimumContribution);\r\n\t\trequire(_weiAmount <= maximumContribution);\r\n\t\t\r\n\t\t// Vaidates the purchase \r\n\t\t// Check if the _participant address is not null and the weiAmount is not zero\r\n\t\tvalidatePurchase(_participant, _weiAmount);\r\n\r\n\t\tuint currentLevelTokens;\r\n\t\tuint nextLevelTokens;\r\n\t\t// Returns the current and next level tokens amount\r\n\t\t(currentLevelTokens, nextLevelTokens) = calculateAndCreateTokens(_weiAmount);\r\n\t\tuint tokensAmount = currentLevelTokens.add(nextLevelTokens);\r\n\t\t\r\n\t\t// If the hard cap is reached the crowdsale is not active anymore\r\n\t\tif(totalSoldTokens.add(tokensAmount) > TOKENS_HARD_CAP) {\r\n\t\t\tisInCrowdsale = false;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// Transfer Ethers\r\n\t\tbenecifiary.transfer(_weiAmount);\r\n\t\t\r\n\t\t// Stores the participant's contributed wei\r\n\t\tcontributedInWei[_participant] = contributedInWei[_participant].add(_weiAmount);\r\n\t\t\r\n\t\t// If it is in threeHotHours tokens will not be minted they will be stored in mapping threeHotHoursTokens\r\n\t\tif(threeHotHoursEnd > block.timestamp) {\r\n\t\t\tthreeHotHoursTokens[_participant] = threeHotHoursTokens[_participant].add(currentLevelTokens);\r\n\t\t\tisCalculated[_participant] = false;\r\n\t\t\t// If we overflow threeHotHours tokens cap the tokens for the next level will not be zero\r\n\t\t\t// So we should deactivate the threeHotHours and mint tokens\r\n\t\t\tif(nextLevelTokens > 0) {\r\n\t\t\t\tvernamCrowdsaleToken.mintToken(_participant, nextLevelTokens);\r\n\t\t\t} \r\n\t\t} else {\t\r\n\t\t\tvernamCrowdsaleToken.mintToken(_participant, tokensAmount);        \r\n\t\t}\r\n\t\t\r\n\t\t// Store total sold tokens amount\r\n\t\ttotalSoldTokens = totalSoldTokens.add(tokensAmount);\r\n\t\t\r\n\t\t// Store total contributed wei amount\r\n\t\ttotalContributedWei = totalContributedWei.add(_weiAmount);\r\n\t\t\r\n\t\temit TokensBought(_participant, _weiAmount, tokensAmount);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t/** @dev Function which gets the tokens amount for current and next level.\r\n\t  * If we did not overflow the current level cap, the next level tokens will be zero.\r\n      * @return _currentLevelTokensAmount and _nextLevelTokensAmount Returns the calculated tokens for the current and next level\r\n      * It is called by calculateAndCreateTokens function\r\n      */\r\n\tfunction calculateAndCreateTokens(uint weiAmount) internal view returns (uint _currentLevelTokensAmount, uint _nextLevelTokensAmount) {\r\n\r\n\t\tif(block.timestamp < threeHotHoursEnd && totalSoldTokens < threeHotHoursTokensCap) {\r\n\t\t    (_currentLevelTokensAmount, _nextLevelTokensAmount) = tokensCalculator(weiAmount, threeHotHoursPriceOfTokenInWei, firstStagePriceOfTokenInWei, threeHotHoursCapInWei);\r\n\t\t\treturn (_currentLevelTokensAmount, _nextLevelTokensAmount);\r\n\t\t}\r\n\t\t\r\n\t\tif(block.timestamp < firstStageEnd) {\r\n\t\t    _currentLevelTokensAmount = weiAmount.div(firstStagePriceOfTokenInWei);\r\n\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\r\n\t        \r\n\t\t    return (_currentLevelTokensAmount, 0);\r\n\t\t}\r\n\t\t\r\n\t\tif(block.timestamp < secondStageEnd) {\t\t\r\n\t\t    _currentLevelTokensAmount = weiAmount.div(secondStagePriceOfTokenInWei);\r\n\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\r\n\t        \r\n\t\t    return (_currentLevelTokensAmount, 0);\r\n\t\t}\r\n\t\t\r\n\t\tif(block.timestamp < thirdStageEnd && weiAmount >= TEN_ETHERS) {\r\n\t\t    _currentLevelTokensAmount = weiAmount.div(thirdStageDiscountPriceOfTokenInWei);\r\n\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\r\n\t        \r\n\t\t    return (_currentLevelTokensAmount, 0);\r\n\t\t}\r\n\t\t\r\n\t\tif(block.timestamp < thirdStageEnd){\t\r\n\t\t    _currentLevelTokensAmount = weiAmount.div(thirdStagePriceOfTokenInWei);\r\n\t        _currentLevelTokensAmount = _currentLevelTokensAmount.mul(POW);\r\n\t        \r\n\t\t    return (_currentLevelTokensAmount, 0);\r\n\t\t}\r\n\t\t\r\n\t\trevert();\r\n\t}\r\n\t\r\n\t/** @dev Realase the tokens from the three hot hours.\r\n      */\r\n\tfunction release() public {\r\n\t    releaseThreeHotHourTokens(msg.sender);\r\n\t}\r\n\t\r\n\t/** @dev Realase the tokens from the three hot hours.\r\n\t  * It can be called after the end of three hot hours\r\n      * @param _participant The investor who want to release his tokens\r\n      * @return success Is the release tokens function called successfully.\r\n      */\r\n\tfunction releaseThreeHotHourTokens(address _participant) public isAfterThreeHotHours returns(bool success) { \r\n\t    // Check if the _participants tokens are realased\r\n\t    // If not calculate his tokens for every month and set the isCalculated to true\r\n\t\tif(isCalculated[_participant] == false) {\r\n\t\t    calculateTokensForMonth(_participant);\r\n\t\t    isCalculated[_participant] = true;\r\n\t\t}\r\n\t\t\r\n\t\t// Unlock the tokens amount for the _participant\r\n\t\tuint _amount = unlockTokensAmount(_participant);\r\n\t\t\r\n\t\t// Substract the _amount from the threeHotHoursTokens mapping\r\n\t\tthreeHotHoursTokens[_participant] = threeHotHoursTokens[_participant].sub(_amount);\r\n\t\t\r\n\t\t// Mint to the _participant vernamCrowdsaleTokens\r\n\t\tvernamCrowdsaleToken.mintToken(_participant, _amount);        \r\n\r\n\t\temit ReleasedTokens(_amount);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t/** @dev Get contributed amount in wei.\r\n      * @return contributedInWei[_participant].\r\n      */\r\n\tfunction getContributedAmountInWei(address _participant) public view returns (uint) {\r\n        return contributedInWei[_participant];\r\n    }\r\n\t\r\n\t/** @dev Function which calculate tokens for every month (6 months).\r\n      * @param weiAmount Participant's contribution in wei.\r\n      * @param currentLevelPrice Price of the tokens for the current level.\r\n      * @param nextLevelPrice Price of the tokens for the next level.\r\n      * @param currentLevelCap Current level cap in wei.\r\n      * @return _currentLevelTokensAmount and _nextLevelTokensAmount Returns the calculated tokens for the current and next level\r\n      * It is called by three hot hours\r\n      */\r\n      \r\n\tfunction tokensCalculator(uint weiAmount, uint currentLevelPrice, uint nextLevelPrice, uint currentLevelCap) internal view returns (uint _currentLevelTokensAmount, uint _nextLevelTokensAmount){\r\n\t    uint currentAmountInWei = 0;\r\n\t\tuint remainingAmountInWei = 0;\r\n\t\tuint currentLevelTokensAmount = 0;\r\n\t\tuint nextLevelTokensAmount = 0;\r\n\t\t\r\n\t\t// Check if the contribution overflows and you should buy tokens on next level price\r\n\t\tif(weiAmount.add(totalContributedWei) > currentLevelCap) {\r\n\t\t    remainingAmountInWei = (weiAmount.add(totalContributedWei)).sub(currentLevelCap);\r\n\t\t    currentAmountInWei = weiAmount.sub(remainingAmountInWei);\r\n            \r\n            currentLevelTokensAmount = currentAmountInWei.div(currentLevelPrice);\r\n            nextLevelTokensAmount = remainingAmountInWei.div(nextLevelPrice); \r\n\t    } else {\r\n\t        currentLevelTokensAmount = weiAmount.div(currentLevelPrice);\r\n\t\t\tnextLevelTokensAmount = 0;\r\n\t    }\r\n\t    currentLevelTokensAmount = currentLevelTokensAmount.mul(POW);\r\n\t    nextLevelTokensAmount = nextLevelTokensAmount.mul(POW);\r\n\t\t\r\n\t\t\r\n\t\treturn (currentLevelTokensAmount, nextLevelTokensAmount);\r\n\t}\r\n\t\r\n\t/** @dev Function which calculate tokens for every month (6 months).\r\n      * @param _participant The investor whose tokens are calculated.\r\n      * It is called once from the releaseThreeHotHourTokens function\r\n      */\r\n\tfunction calculateTokensForMonth(address _participant) internal {\r\n\t    // Get the max balance of the participant  \r\n\t    uint maxBalance = threeHotHoursTokens[_participant];\r\n\t    \r\n\t    // Start from 10% for the first three months\r\n\t    uint percentage = 10;\r\n\t    for(uint month = 0; month < 6; month++) {\r\n\t        // The fourth month the unlock tokens percentage is increased by 10% and for the fourth and fifth month will be 20%\r\n\t        // It will increase one more by 10% in the last month and will become 30% \r\n\t        if(month == 3 || month == 5) {\r\n\t            percentage += 10;\r\n\t        }\r\n\t        \r\n\t        // Set the participant at which month how much he will get\r\n\t        getTokensBalance[_participant][month] = maxBalance.div(percentage);\r\n\t        \r\n\t        // Set for every month false to see the tokens for the month is not get it \r\n\t        isTokensTaken[_participant][month] = false; \r\n\t    }\r\n\t}\r\n\t\r\n\t\t\r\n\t/** @dev Function which validates if the participan is not null address and the wei amount is not zero\r\n      * @param _participant The investor who want to unlock his tokens\r\n      * @return _tokensAmount Tokens which are unlocked\r\n      */\r\n\tfunction unlockTokensAmount(address _participant) internal returns (uint _tokensAmount) {\r\n\t    // Check if the _participant have tokens in threeHotHours stage\r\n\t\trequire(threeHotHoursTokens[_participant] > 0);\r\n\t\t\r\n\t\t// Check if the _participant got his tokens in first month and if the time for the first month end has come \r\n        if(block.timestamp < firstMonthEnd && isTokensTaken[_participant][FIRST_MONTH] == false) {\r\n            // Go and get the tokens for the current month\r\n            return getTokens(_participant, FIRST_MONTH.add(1)); // First month\r\n        } \r\n        \r\n        // Check if the _participant got his tokens in second month and if the time is in the period between first and second month end\r\n        if(((block.timestamp >= firstMonthEnd) && (block.timestamp < secondMonthEnd)) \r\n            && isTokensTaken[_participant][SECOND_MONTH] == false) {\r\n            // Go and get the tokens for the current month\r\n            return getTokens(_participant, SECOND_MONTH.add(1)); // Second month\r\n        } \r\n        \r\n        // Check if the _participant got his tokens in second month and if the time is in the period between second and third month end\r\n        if(((block.timestamp >= secondMonthEnd) && (block.timestamp < thirdMonthEnd)) \r\n            && isTokensTaken[_participant][THIRD_MONTH] == false) {\r\n            // Go and get the tokens for the current month\r\n            return getTokens(_participant, THIRD_MONTH.add(1)); // Third month\r\n        } \r\n        \r\n        // Check if the _participant got his tokens in second month and if the time is in the period between third and fourth month end\r\n        if(((block.timestamp >= thirdMonthEnd) && (block.timestamp < fourthMonthEnd)) \r\n            && isTokensTaken[_participant][FORTH_MONTH] == false) {\r\n            // Go and get the tokens for the current month\r\n            return getTokens(_participant, FORTH_MONTH.add(1)); // Forth month\r\n        } \r\n        \r\n        // Check if the _participant got his tokens in second month and if the time is in the period between forth and fifth month end\r\n        if(((block.timestamp >= fourthMonthEnd) && (block.timestamp < fifthMonthEnd)) \r\n            && isTokensTaken[_participant][FIFTH_MONTH] == false) {\r\n            // Go and get the tokens for the current month\r\n            return getTokens(_participant, FIFTH_MONTH.add(1)); // Fifth month\r\n        } \r\n        \r\n        // Check if the _participant got his tokens in second month and if the time is after the end of the fifth month\r\n        if((block.timestamp >= fifthMonthEnd) \r\n            && isTokensTaken[_participant][SIXTH_MONTH] == false) {\r\n            return getTokens(_participant, SIXTH_MONTH.add(1)); // Last month\r\n        }\r\n    }\r\n    \r\n    /** @dev Function for getting the tokens for unlock\r\n      * @param _participant The investor who want to unlock his tokens\r\n      * @param _period The period for which will be unlocked the tokens\r\n      * @return tokensAmount Returns the amount of tokens for unlocing\r\n      */\r\n    function getTokens(address _participant, uint _period) internal returns(uint tokensAmount) {\r\n        uint tokens = 0;\r\n        for(uint month = 0; month < _period; month++) {\r\n            // Check if the tokens fot the current month unlocked\r\n            if(isTokensTaken[_participant][month] == false) { \r\n                // Set the isTokensTaken to true\r\n                isTokensTaken[_participant][month] = true;\r\n                \r\n                // Calculates the tokens\r\n                tokens += getTokensBalance[_participant][month];\r\n                \r\n                // Set the balance for the curren month to zero\r\n                getTokensBalance[_participant][month] = 0;\r\n            }\r\n        }\r\n        \r\n        return tokens;\r\n    }\r\n\t\r\n\t/** @dev Function which validates if the participan is not null address and the wei amount is not zero\r\n      * @param _participant The investor who want to buy tokens\r\n      * @param _weiAmount The amount of wei which the investor want to contribute\r\n      */\r\n\tfunction validatePurchase(address _participant, uint _weiAmount) pure internal {\r\n        require(_participant != address(0));\r\n        require(_weiAmount != 0);\r\n    }\r\n\t\r\n\t /** @dev Function which set the duration of crowdsale stages\r\n      * Called by the activateCrowdSale function \r\n      */\r\n\tfunction setTimeForCrowdsalePeriods() internal {\r\n\t\tstartTime = block.timestamp;\r\n\t\tthreeHotHoursEnd = startTime.add(threeHotHoursDuration);\r\n\t\tfirstStageEnd = threeHotHoursEnd.add(firstStageDuration);\r\n\t\tsecondStageEnd = firstStageEnd.add(secondStageDuration);\r\n\t\tthirdStageEnd = secondStageEnd.add(thirdStageDuration);\r\n\t}\r\n\t\r\n\t/** @dev Function which set the duration in which the tokens bought in threeHotHours will be locked\r\n      * Called by the activateCrowdSale function \r\n      */\r\n\tfunction timeLock() internal {\r\n\t\tfirstMonthEnd = (startTime.add(LOCK_TOKENS_DURATION)).add(threeHotHoursDuration);\r\n\t\tsecondMonthEnd = firstMonthEnd.add(LOCK_TOKENS_DURATION);\r\n\t\tthirdMonthEnd = secondMonthEnd.add(LOCK_TOKENS_DURATION);\r\n\t\tfourthMonthEnd = thirdMonthEnd.add(LOCK_TOKENS_DURATION);\r\n\t\tfifthMonthEnd = fourthMonthEnd.add(LOCK_TOKENS_DURATION);\r\n\t}\r\n\t\r\n\tfunction getPrice(uint256 time, uint256 weiAmount) public view returns (uint levelPrice) {\r\n\r\n\t\tif(time < threeHotHoursEnd && totalSoldTokens < threeHotHoursTokensCap) {\r\n            return threeHotHoursPriceOfTokenInWei;\r\n\t\t}\r\n\t\t\r\n\t\tif(time < firstStageEnd) {\r\n            return firstStagePriceOfTokenInWei;\r\n\t\t}\r\n\t\t\r\n\t\tif(time < secondStageEnd) {\r\n            return secondStagePriceOfTokenInWei;\r\n\t\t}\r\n\t\t\r\n\t\tif(time < thirdStageEnd && weiAmount > TEN_ETHERS) {\r\n            return thirdStageDiscountPriceOfTokenInWei;\r\n\t\t}\r\n\t\t\r\n\t\tif(time < thirdStageEnd){\t\t\r\n\t\t    return thirdStagePriceOfTokenInWei;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction setBenecifiary(address _newBenecifiary) public onlyOwner {\r\n\t\tbenecifiary = _newBenecifiary;\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTokensTaken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdStagePriceOfTokenInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStagePriceOfTokenInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBenecifiary\",\"type\":\"address\"}],\"name\":\"setBenecifiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContributedWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCalculated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threeHotHoursDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCK_TOKENS_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"threeHotHoursTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStageDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threeHotHoursPriceOfTokenInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"levelPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setControler\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threeHotHoursEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"releaseThreeHotHourTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"benecifiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threeHotHoursCapInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondStageEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributedInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStagePriceOfTokenInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_HARD_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"getContributedAmountInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fifthMonthEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdMonthEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"threeHotHoursTokensCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateCrowdSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdStageDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdStageDiscountPriceOfTokenInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fourthMonthEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getTokensBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdStageEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vernamCrowdsaleToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstMonthEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstStageEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondMonthEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_benecifiary\",\"type\":\"address\"},{\"name\":\"_vernamCrowdSaleTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"TokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ReleasedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensToGetFromWhiteList\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"VernamCrowdSale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000d977af9f1cf2cf615ab7d61c84aabb315b9a03370000000000000000000000006d908a2ef63aeac21cb2b5c3d32a145f14144b38","Library":"","SwarmSource":"bzzr://5319f4c8ec478c1b1cfb4c22205559b6d95b418eab89c8662f9a75c8c31207d0"}]}