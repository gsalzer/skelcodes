{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n/* The authentication manager details user accounts that have access to certain priviledges and keeps a permanent ledger of who has and has had these rights. */\r\ncontract AuthenticationManager {\r\n   \r\n    /* Map addresses to admins */\r\n    mapping (address => bool) adminAddresses;\r\n\r\n    /* Map addresses to account readers */\r\n    mapping (address => bool) accountReaderAddresses;\r\n\r\n    /* Map addresses to account minters */\r\n    mapping (address => bool) accountMinterAddresses;\r\n\r\n    /* Details of all admins that have ever existed */\r\n    address[] adminAudit;\r\n\r\n    /* Details of all account readers that have ever existed */\r\n    address[] accountReaderAudit;\r\n\r\n    /* Details of all account minters that have ever existed */\r\n    address[] accountMinterAudit;\r\n\r\n    /* Fired whenever an admin is added to the contract. */\r\n    event AdminAdded(address addedBy, address admin);\r\n\r\n    /* Fired whenever an admin is removed from the contract. */\r\n    event AdminRemoved(address removedBy, address admin);\r\n\r\n    /* Fired whenever an account-reader contract is added. */\r\n    event AccountReaderAdded(address addedBy, address account);\r\n\r\n    /* Fired whenever an account-reader contract is removed. */\r\n    event AccountReaderRemoved(address removedBy, address account);\r\n\r\n    /* Fired whenever an account-minter contract is added. */\r\n    event AccountMinterAdded(address addedBy, address account);\r\n\r\n    /* Fired whenever an account-minter contract is removed. */\r\n    event AccountMinterRemoved(address removedBy, address account);\r\n\r\n    /* When this contract is first setup we use the creator as the first admin */    \r\n    function AuthenticationManager() {\r\n        /* Set the first admin to be the person creating the contract */\r\n        adminAddresses[msg.sender] = true;\r\n        AdminAdded(0, msg.sender);\r\n        adminAudit.length++;\r\n        adminAudit[adminAudit.length - 1] = msg.sender;\r\n    }\r\n\r\n    /* Gets whether or not the specified address is currently an admin */\r\n    function isCurrentAdmin(address _address) constant returns (bool) {\r\n        return adminAddresses[_address];\r\n    }\r\n\r\n    /* Gets whether or not the specified address has ever been an admin */\r\n    function isCurrentOrPastAdmin(address _address) constant returns (bool) {\r\n        for (uint256 i = 0; i < adminAudit.length; i++)\r\n            if (adminAudit[i] == _address)\r\n                return true;\r\n        return false;\r\n    }\r\n\r\n    /* Gets whether or not the specified address is currently an account reader */\r\n    function isCurrentAccountReader(address _address) constant returns (bool) {\r\n        return accountReaderAddresses[_address];\r\n    }\r\n\r\n    /* Gets whether or not the specified address has ever been an admin */\r\n    function isCurrentOrPastAccountReader(address _address) constant returns (bool) {\r\n        for (uint256 i = 0; i < accountReaderAudit.length; i++)\r\n            if (accountReaderAudit[i] == _address)\r\n                return true;\r\n        return false;\r\n    }\r\n\r\n    /* Gets whether or not the specified address is currently an account minter */\r\n    function isCurrentAccountMinter(address _address) constant returns (bool) {\r\n        return accountMinterAddresses[_address];\r\n    }\r\n\r\n    /* Gets whether or not the specified address has ever been an admin */\r\n    function isCurrentOrPastAccountMinter(address _address) constant returns (bool) {\r\n        for (uint256 i = 0; i < accountMinterAudit.length; i++)\r\n            if (accountMinterAudit[i] == _address)\r\n                return true;\r\n        return false;\r\n    }\r\n\r\n    /* Adds a user to our list of admins */\r\n    function addAdmin(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already admin\r\n        if (adminAddresses[_address])\r\n            throw;\r\n        \r\n        // Add the user\r\n        adminAddresses[_address] = true;\r\n        AdminAdded(msg.sender, _address);\r\n        adminAudit.length++;\r\n        adminAudit[adminAudit.length - 1] = _address;\r\n\r\n    }\r\n\r\n    /* Removes a user from our list of admins but keeps them in the history audit */\r\n    function removeAdmin(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        /* Don't allow removal of self */\r\n        if (_address == msg.sender)\r\n            throw;\r\n\r\n        // Fail if this account is already non-admin\r\n        if (!adminAddresses[_address])\r\n            throw;\r\n\r\n        /* Remove this admin user */\r\n        adminAddresses[_address] = false;\r\n        AdminRemoved(msg.sender, _address);\r\n    }\r\n\r\n    /* Adds a user/contract to our list of account readers */\r\n    function addAccountReader(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already in the list\r\n        if (accountReaderAddresses[_address])\r\n            throw;\r\n        \r\n        // Add the account reader\r\n        accountReaderAddresses[_address] = true;\r\n        AccountReaderAdded(msg.sender, _address);\r\n        accountReaderAudit.length++;\r\n        accountReaderAudit[accountReaderAudit.length - 1] = _address;\r\n    }\r\n\r\n    /* Removes a user/contracts from our list of account readers but keeps them in the history audit */\r\n    function removeAccountReader(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already not in the list\r\n        if (!accountReaderAddresses[_address])\r\n            throw;\r\n\r\n        /* Remove this account reader */\r\n        accountReaderAddresses[_address] = false;\r\n        AccountReaderRemoved(msg.sender, _address);\r\n    }\r\n\r\n    /* Add a contract to our list of account minters */\r\n    function addAccountMinter(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already in the list\r\n        if (accountMinterAddresses[_address])\r\n            throw;\r\n        \r\n        // Add the minter\r\n        accountMinterAddresses[_address] = true;\r\n        AccountMinterAdded(msg.sender, _address);\r\n        accountMinterAudit.length++;\r\n        accountMinterAudit[accountMinterAudit.length - 1] = _address;\r\n    }\r\n\r\n    /* Removes a user/contracts from our list of account readers but keeps them in the history audit */\r\n    function removeAccountMinter(address _address) {\r\n        /* Ensure we're an admin */\r\n        if (!isCurrentAdmin(msg.sender))\r\n            throw;\r\n\r\n        // Fail if this account is already not in the list\r\n        if (!accountMinterAddresses[_address])\r\n            throw;\r\n\r\n        /* Remove this minter account */\r\n        accountMinterAddresses[_address] = false;\r\n        AccountMinterRemoved(msg.sender, _address);\r\n    }\r\n}\r\n\r\n/* The TokenValue Relayer contract is responsible to keep a track of token value that can be audited at a later time. */\r\ncontract TokenValueRelayer {\r\n\r\n    /* Represents the value of the token at a particular moment in time. */\r\n    struct TokenValueRepresentation {\r\n        uint256 value;\r\n        string currency;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    /* An array defining all the token values in history. */\r\n    TokenValueRepresentation[] public values;\r\n    \r\n    /* Defines the admin contract we interface with for credentails. */\r\n    AuthenticationManager authenticationManager;\r\n\r\n    /* Fired when the token value is updated by an admin. */\r\n    event TokenValue(uint256 value, string currency, uint256 timestamp);\r\n\r\n    /* This modifier allows a method to only be called by current admins */\r\n    modifier adminOnly {\r\n        if (!authenticationManager.isCurrentAdmin(msg.sender)) throw;\r\n        _;\r\n    }\r\n\r\n    /* Create our contract and specify the location of other addresses. */\r\n    function TokenValueRelayer(address _authenticationManagerAddress) {\r\n        /* Setup access to our other contracts and validate their versions */\r\n        authenticationManager = AuthenticationManager(_authenticationManagerAddress);\r\n    }\r\n\r\n    /* Returns how many token values are present in the history. */\r\n    function tokenValueCount() constant returns (uint256 _count) {\r\n        _count = values.length;\r\n    }\r\n\r\n    /* Defines the current value of the token. */\r\n    function tokenValuePublish(uint256 _value, string _currency, uint256 _timestamp) adminOnly {\r\n        values.length++;\r\n        values[values.length - 1] = TokenValueRepresentation(_value, _currency,_timestamp);\r\n\r\n        /* Audit this */\r\n        TokenValue(_value, _currency, _timestamp);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"values\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"currency\",\"type\":\"string\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenValueCount\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_currency\",\"type\":\"string\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"tokenValuePublish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_authenticationManagerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currency\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokenValue\",\"type\":\"event\"}]","ContractName":"TokenValueRelayer","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000064c14e2c286918803de6d965174ca6bc9048eafa","Library":"","SwarmSource":"bzzr://bc108d55d7024d0928b46e6bdeb8fad2f5ad4bd790e4c41abc026f1b61e8a572"}]}