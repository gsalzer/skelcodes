{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract CrowdsaleParameters {\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Production Config\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    // ICO period timestamps:\r\n    // 1524182400 = April 20, 2018.\r\n    // 1529452800 = June 20, 2018.\r\n\r\n    uint256 public constant generalSaleStartDate = 1524182400;\r\n    uint256 public constant generalSaleEndDate = 1529452800;\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // QA Config\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Configuration Independent Parameters\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    struct AddressTokenAllocation {\r\n        address addr;\r\n        uint256 amount;\r\n    }\r\n\r\n    AddressTokenAllocation internal generalSaleWallet = AddressTokenAllocation(0x5aCdaeF4fa410F38bC26003d0F441d99BB19265A, 22800000);\r\n    AddressTokenAllocation internal bounty = AddressTokenAllocation(0xc1C77Ff863bdE913DD53fD6cfE2c68Dfd5AE4f7F, 2000000);\r\n    AddressTokenAllocation internal partners = AddressTokenAllocation(0x307744026f34015111B04ea4D3A8dB9FdA2650bb, 3200000);\r\n    AddressTokenAllocation internal team = AddressTokenAllocation(0xCC4271d219a2c33a92aAcB4C8D010e9FBf664D1c, 12000000);\r\n    AddressTokenAllocation internal featureDevelopment = AddressTokenAllocation(0x06281A31e1FfaC1d3877b29150bdBE93073E043B, 0);\r\n}\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Sets contract owner to address of constructor caller\r\n    */\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  Change Owner\r\n    *\r\n    *  Changes ownership of this contract. Only owner can call this method.\r\n    *\r\n    * @param newOwner - new owner's address\r\n    */\r\n    function changeOwner(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        require(newOwner != owner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract SBIToken is Owned, CrowdsaleParameters {\r\n    using SafeMath for uint256;\r\n    /* Public variables of the token */\r\n    string public standard = 'ERC20/SBI';\r\n    string public name = 'Subsoil Blockchain Investitions';\r\n    string public symbol = 'SBI';\r\n    uint8 public decimals = 18;\r\n\r\n    /* Arrays of all balances */\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    mapping (address => mapping (address => bool)) private allowanceUsed;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Issuance(uint256 _amount); // triggered when the total supply is increased\r\n    event Destruction(uint256 _amount); // triggered when the total supply is decreased\r\n\r\n    event NewSBIToken(address _token);\r\n\r\n    /* Miscellaneous */\r\n    uint256 public totalSupply = 0; // 40000000;\r\n    bool public transfersEnabled = true;\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Initializes contract with initial supply tokens to the creator of the contract\r\n    */\r\n\r\n    function SBIToken() public {\r\n        owner = msg.sender;\r\n        mintToken(generalSaleWallet);\r\n        mintToken(bounty);\r\n        mintToken(partners);\r\n        mintToken(team);\r\n        NewSBIToken(address(this));\r\n    }\r\n\r\n    modifier transfersAllowed {\r\n        require(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  1. Associate crowdsale contract address with this Token\r\n    *  2. Allocate general sale amount\r\n    *\r\n    * @param _crowdsaleAddress - crowdsale contract address\r\n    */\r\n    function approveCrowdsale(address _crowdsaleAddress) external onlyOwner {\r\n        approveAllocation(generalSaleWallet, _crowdsaleAddress);\r\n    }\r\n\r\n    function approveAllocation(AddressTokenAllocation tokenAllocation, address _crowdsaleAddress) internal {\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint amount = tokenAllocation.amount * exponent;\r\n\r\n        allowed[tokenAllocation.addr][_crowdsaleAddress] = amount;\r\n        Approval(tokenAllocation.addr, _crowdsaleAddress, amount);\r\n    }\r\n\r\n    /**\r\n    *  Get token balance of an address\r\n    *\r\n    * @param _address - address to query\r\n    * @return Token balance of _address\r\n    */\r\n    function balanceOf(address _address) public constant returns (uint256 balance) {\r\n        return balances[_address];\r\n    }\r\n\r\n    /**\r\n    *  Get token amount allocated for a transaction from _owner to _spender addresses\r\n    *\r\n    * @param _owner - owner address, i.e. address to transfer from\r\n    * @param _spender - spender address, i.e. address to transfer to\r\n    * @return Remaining amount allowed to be transferred\r\n    */\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    *  Send coins from sender's address to address specified in parameters\r\n    *\r\n    * @param _to - address to send to\r\n    * @param _value - amount to send in Wei\r\n    */\r\n\r\n    function transfer(address _to, uint256 _value) public transfersAllowed onlyPayloadSize(2*32) returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Create token and credit it to target address\r\n    *  Created tokens need to vest\r\n    *\r\n    */\r\n    function mintToken(AddressTokenAllocation tokenAllocation) internal {\r\n\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint mintedAmount = tokenAllocation.amount * exponent;\r\n\r\n        // Mint happens right here: Balance becomes non-zero from zero\r\n        balances[tokenAllocation.addr] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n\r\n        // Emit Issue and Transfer events\r\n        Issuance(mintedAmount);\r\n        Transfer(address(this), tokenAllocation.addr, mintedAmount);\r\n    }\r\n\r\n    /**\r\n    *  Allow another contract to spend some tokens on your behalf\r\n    *\r\n    * @param _spender - address to allocate tokens for\r\n    * @param _value - number of tokens to allocate\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\r\n        require(_value == 0 || allowanceUsed[msg.sender][_spender] == false);\r\n        allowed[msg.sender][_spender] = _value;\r\n        allowanceUsed[msg.sender][_spender] = false;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  A contract attempts to get the coins. Tokens should be previously allocated\r\n    *\r\n    * @param _to - address to transfer tokens to\r\n    * @param _from - address to transfer tokens from\r\n    * @param _value - number of tokens to transfer\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed onlyPayloadSize(3*32) returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Default method\r\n    *\r\n    *  This unnamed function is called whenever someone tries to send ether to\r\n    *  it. Just revert transaction because there is nothing that Token can do\r\n    *  with incoming ether.\r\n    *\r\n    *  Missing payable modifier prevents accidental sending of ether\r\n    */\r\n    function() public {}\r\n\r\n    /**\r\n    *  Enable or disable transfers\r\n    *\r\n    * @param _enable - True = enable, False = disable\r\n    */\r\n    function toggleTransfers(bool _enable) external onlyOwner {\r\n        transfersEnabled = _enable;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SBIBank\r\n * @dev Bank contract that supports voting to withdraw money, cancel or refund\r\n * multiple payees claiming funds sent to this contract\r\n * according to the sbi tokens proportions they own and result of voting.\r\n */\r\n\r\ncontract SBIBank is Owned, CrowdsaleParameters {\r\n    using SafeMath for uint256;\r\n    string public name = 'Subsoil Blockchain Investitions Bank';\r\n    SBIToken private token;\r\n    uint256 public currentVotingDate = 0;\r\n    uint public currentVotingAmount = 0;\r\n    uint public allowedWithdraw = 0;\r\n    uint public allowedRefund = 0;\r\n\r\n    uint256 public toAllow = 0;\r\n    uint256 public toCancel = 0;\r\n    uint256 public toRefund = 0;\r\n\r\n    // result of a voiting\r\n    uint8 result = 0;\r\n\r\n    address sbiBank = this;\r\n\r\n    // investors votes\r\n    mapping(address => uint8) public votes;\r\n    // investors votes dates\r\n    mapping(address => uint256) public voteDates;\r\n    // investors refunded amounts of voting\r\n    mapping(address => uint256) public alreadyRefunded;\r\n\r\n    event NewIncomingFunds(uint indexed amount, address indexed sender);\r\n    event NewVoting(uint256 indexed date, uint indexed amount);\r\n    event NewVote(address indexed voter, uint256 indexed date, uint8 indexed proposal);\r\n    event CancelVote(uint256 indexed date, uint indexed amount);\r\n    event AllowVote(uint256 indexed date, uint indexed amount);\r\n    event RefundVote(uint256 indexed date, uint indexed amount);\r\n    event Refund(uint256 indexed date, uint256 indexed amount, address indexed investor);\r\n    event Withdraw(uint256 indexed date, uint indexed amount);\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  function SBIBank(address _tokenAddress) public payable {\r\n     token = SBIToken(_tokenAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Start a new voting.\r\n   * @param _amount The amount of the funds requested to transfer.\r\n   */\r\n  function addVoting(uint _amount) public onlyOwner {\r\n    require(sbiBank.balance >= _amount);\r\n    // can add only if previouse voiting closed\r\n    require(currentVotingDate == 0 && currentVotingAmount == 0);\r\n    currentVotingDate = now;\r\n    currentVotingAmount = _amount;\r\n    NewVoting(now, _amount);\r\n  }\r\n  /*\r\n    returns current vote of investor\r\n  */\r\n  function voteOf(address voter) public constant returns (uint8 vote) {\r\n    return votes[voter];\r\n  }\r\n\r\n   /**\r\n   * @dev vote for only sbi tokens owners\r\n   */\r\n  function vote(uint8 proposal) public returns(uint8 prop) {\r\n      require(token.balanceOf(msg.sender) > 0);\r\n      require(now >= currentVotingDate && now <= currentVotingDate + 3 days);\r\n      require(proposal == 1 || proposal == 2 || proposal == 3);\r\n      // you can vote only once for current voiting\r\n      require(voteDates[msg.sender] != currentVotingDate);\r\n\r\n      alreadyRefunded[msg.sender] = 0;\r\n      votes[msg.sender] = proposal;\r\n      voteDates[msg.sender] = currentVotingDate;\r\n\r\n      if(proposal == 1) {\r\n          toAllow = toAllow + token.balanceOf(msg.sender);\r\n      }\r\n      if(proposal == 2) {\r\n          toCancel = toCancel + token.balanceOf(msg.sender);\r\n      }\r\n      if(proposal == 3) {\r\n          toRefund = toRefund + token.balanceOf(msg.sender);\r\n      }\r\n      NewVote(msg.sender, now, proposal);\r\n      return proposal;\r\n  }\r\n\r\n  /**\r\n   * @dev End current voting with 3 scenarios - toAllow, toCancel or toRefund\r\n   */\r\n  function endVoting() public onlyOwner {\r\n      require(currentVotingDate > 0 && now >= currentVotingDate + 3 days);\r\n      if (toAllow > toCancel && toAllow > toRefund) {\r\n          // toAllow withdraw\r\n          AllowVote(currentVotingDate, toAllow);\r\n          allowedWithdraw = currentVotingAmount;\r\n          allowedRefund = 0;\r\n      }\r\n      if (toCancel > toAllow && toCancel > toRefund) {\r\n          // toCancel voiting\r\n          CancelVote(currentVotingDate, toCancel);\r\n          allowedWithdraw = 0;\r\n          allowedRefund = 0;\r\n      }\r\n      if (toRefund > toAllow && toRefund > toCancel) {\r\n          // toCancel voiting\r\n          RefundVote(currentVotingDate, toRefund);\r\n          allowedRefund = currentVotingAmount;\r\n          allowedWithdraw = 0;\r\n      }\r\n      currentVotingDate = 0;\r\n      currentVotingAmount = 0;\r\n      toAllow = 0;\r\n      toCancel = 0;\r\n      toRefund = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw the current voiting amount\r\n   */\r\n  function withdraw() public onlyOwner {\r\n      require(currentVotingDate == 0);\r\n      require(allowedWithdraw > 0);\r\n      owner.transfer(allowedWithdraw);\r\n      Withdraw(now, allowedWithdraw);\r\n      allowedWithdraw = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev End current voting with 3 scenarios - toAllow, toCancel or refund\r\n   */\r\n  function refund() public {\r\n      require(allowedRefund > 0);\r\n      // allows refund only once thrue the voiting\r\n      require(alreadyRefunded[msg.sender] == 0);\r\n      require(token.balanceOf(msg.sender) > 0);\r\n      // total supply tokens is 40 000 000\r\n      uint256 tokensPercent = token.balanceOf(msg.sender).div(40000000).div(1000000000000000);\r\n      uint256 refundedAmount = tokensPercent.mul(sbiBank.balance).div(1000);\r\n      address sender = msg.sender;\r\n      alreadyRefunded[msg.sender] = refundedAmount;\r\n      token.transferFrom(msg.sender, featureDevelopment.addr, token.balanceOf(msg.sender));\r\n      sender.transfer(refundedAmount);\r\n      Refund(now, refundedAmount, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev payable fallback\r\n   */\r\n  function () external payable {\r\n      NewIncomingFunds(msg.value, msg.sender);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toAllow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalSaleEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowedRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"alreadyRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentVotingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentVotingDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowedWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposal\",\"type\":\"uint8\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"prop\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endVoting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteDates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalSaleStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"voteOf\",\"outputs\":[{\"name\":\"vote\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NewIncomingFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewVoting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"proposal\",\"type\":\"uint8\"}],\"name\":\"NewVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CancelVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AllowVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SBIBank","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f47fcf487177a1f39c4c4f26da5cf762d02bf2ca","Library":"","SwarmSource":"bzzr://1cfa66085f2cce3f670374fcf8d56e7aeb55d83c5abd6f3d0313fa6d0ff45081"}]}