{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/// @title ServiceAllowance.\r\n///\r\n/// Provides a way to delegate operation allowance decision to a service contract\r\ncontract ServiceAllowance {\r\n    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\r\n}\r\n\r\ncontract ATxPlatformInterface {\r\n    mapping(bytes32 => address) public proxies;\r\n    function name(bytes32 _symbol) public view returns (string);\r\n    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\r\n    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\r\n    function totalSupply(bytes32 _symbol) public view returns (uint);\r\n    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\r\n    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\r\n    function baseUnit(bytes32 _symbol) public view returns (uint8);\r\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\r\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\r\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\r\n    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\r\n    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\r\n    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\r\n    function isReissuable(bytes32 _symbol) public view returns (bool);\r\n    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\r\n}\r\n\r\n/**\r\n * @title Owned contract with safe ownership pass.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public contractOwner;\r\n\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public pendingContractOwner;\r\n\r\n    function Owned() {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner check modifier\r\n    */\r\n    modifier onlyContractOwner() {\r\n        if (contractOwner == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can call it\r\n     */\r\n    function destroy() onlyContractOwner {\r\n        suicide(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Prepares ownership pass.\r\n     *\r\n     * Can only be called by current owner.\r\n     *\r\n     * @param _to address of the next owner. 0x0 is not allowed.\r\n     *\r\n     * @return success.\r\n     */\r\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\r\n        if (_to  == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Finalize ownership pass.\r\n     *\r\n     * Can only be called by pending owner.\r\n     *\r\n     * @return success.\r\n     */\r\n    function claimContractOwnership() returns(bool) {\r\n        if (pendingContractOwner != msg.sender) {\r\n            return false;\r\n        }\r\n\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\r\n\r\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\r\n        for(uint i=0;i<tokens.length;i++) {\r\n            address token = tokens[i];\r\n            uint balance = ERC20Interface(token).balanceOf(this);\r\n            if(balance != 0)\r\n                ERC20Interface(token).transfer(_to,balance);\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function checkOnlyContractOwner() internal constant returns(uint) {\r\n        if (contractOwner == msg.sender) {\r\n            return OK;\r\n        }\r\n\r\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\r\n    }\r\n}\r\n\r\n/// @title Provides possibility manage holders? country limits and limits for holders.\r\ncontract DataControllerInterface {\r\n\r\n    /// @notice Checks user is holder.\r\n    /// @param _address - checking address.\r\n    /// @return `true` if _address is registered holder, `false` otherwise.\r\n    function isHolderAddress(address _address) public view returns (bool);\r\n\r\n    function allowance(address _user) public view returns (uint);\r\n\r\n    function changeAllowance(address _holder, uint _value) public returns (uint);\r\n}\r\n\r\n/// @title ServiceController\r\n///\r\n/// Base implementation\r\n/// Serves for managing service instances\r\ncontract ServiceControllerInterface {\r\n\r\n    /// @notice Check target address is service\r\n    /// @param _address target address\r\n    /// @return `true` when an address is a service, `false` otherwise\r\n    function isService(address _address) public view returns (bool);\r\n}\r\n\r\ncontract ATxAssetInterface {\r\n\r\n    DataControllerInterface public dataController;\r\n    ServiceControllerInterface public serviceController;\r\n\r\n    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\r\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\r\n    function __approve(address _spender, uint _value, address _sender) public returns (bool);\r\n    function __process(bytes /*_data*/, address /*_sender*/) payable public {\r\n        revert();\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\ncontract Platform {\r\n    mapping(bytes32 => address) public proxies;\r\n    function name(bytes32 _symbol) public view returns (string);\r\n    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\r\n    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\r\n    function totalSupply(bytes32 _symbol) public view returns (uint);\r\n    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\r\n    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\r\n    function baseUnit(bytes32 _symbol) public view returns (uint8);\r\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\r\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\r\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\r\n    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\r\n    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\r\n    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\r\n    function isReissuable(bytes32 _symbol) public view returns (bool);\r\n    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\r\n}\r\n\r\ncontract ATxAssetProxy is ERC20, Object, ServiceAllowance {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\r\n     */\r\n    event UpgradeProposal(address newVersion);\r\n\r\n    // Current asset implementation contract address.\r\n    address latestVersion;\r\n\r\n    // Assigned platform, immutable.\r\n    Platform public platform;\r\n\r\n    // Assigned symbol, immutable.\r\n    bytes32 public smbl;\r\n\r\n    // Assigned name, immutable.\r\n    string public name;\r\n\r\n    /**\r\n     * Only platform is allowed to call.\r\n     */\r\n    modifier onlyPlatform() {\r\n        if (msg.sender == address(platform)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Only current asset owner is allowed to call.\r\n     */\r\n    modifier onlyAssetOwner() {\r\n        if (platform.isOwner(msg.sender, smbl)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Only asset implementation contract assigned to sender is allowed to call.\r\n     */\r\n    modifier onlyAccess(address _sender) {\r\n        if (getLatestVersion() == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resolves asset implementation contract for the caller and forwards there transaction data,\r\n     * along with the value. This allows for proxy interface growth.\r\n     */\r\n    function() public payable {\r\n        _getAsset().__process.value(msg.value)(msg.data, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Sets platform address, assigns symbol and name.\r\n     *\r\n     * Can be set only once.\r\n     *\r\n     * @param _platform platform contract address.\r\n     * @param _symbol assigned symbol.\r\n     * @param _name assigned name.\r\n     *\r\n     * @return success.\r\n     */\r\n    function init(Platform _platform, string _symbol, string _name) public returns (bool) {\r\n        if (address(platform) != 0x0) {\r\n            return false;\r\n        }\r\n        platform = _platform;\r\n        symbol = _symbol;\r\n        smbl = stringToBytes32(_symbol);\r\n        name = _name;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns asset total supply.\r\n     *\r\n     * @return asset total supply.\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return platform.totalSupply(smbl);\r\n    }\r\n\r\n    /**\r\n     * Returns asset balance for a particular holder.\r\n     *\r\n     * @param _owner holder address.\r\n     *\r\n     * @return holder balance.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return platform.balanceOf(_owner, smbl);\r\n    }\r\n\r\n    /**\r\n     * Returns asset allowance from one holder to another.\r\n     *\r\n     * @param _from holder that allowed spending.\r\n     * @param _spender holder that is allowed to spend.\r\n     *\r\n     * @return holder to spender allowance.\r\n     */\r\n    function allowance(address _from, address _spender) public view returns (uint) {\r\n        return platform.allowance(_from, _spender, smbl);\r\n    }\r\n\r\n    /**\r\n     * Returns asset decimals.\r\n     *\r\n     * @return asset decimals.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return platform.baseUnit(smbl);\r\n    }\r\n\r\n    /**\r\n     * Transfers asset balance from the caller to specified receiver.\r\n     *\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     *\r\n     * @return success.\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        if (_to != 0x0) {\r\n            return _transferWithReference(_to, _value, \"\");\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfers asset balance from the caller to specified receiver adding specified comment.\r\n     *\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a platform's Transfer event.\r\n     *\r\n     * @return success.\r\n     */\r\n    function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {\r\n        if (_to != 0x0) {\r\n            return _transferWithReference(_to, _value, _reference);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs transfer call on the platform by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a platform's Transfer event.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     */\r\n    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\r\n        return platform.proxyTransferWithReference(_to, _value, smbl, _reference, _sender) == OK;\r\n    }\r\n\r\n    /**\r\n     * Prforms allowance transfer of asset balance between holders.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     *\r\n     * @return success.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        if (_to != 0x0) {\r\n            return _getAsset().__transferFromWithReference(_from, _to, _value, \"\", msg.sender);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs allowance transfer call on the platform by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a platform's Transfer event.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     */\r\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\r\n        return platform.proxyTransferFromWithReference(_from, _to, _value, smbl, _reference, _sender) == OK;\r\n    }\r\n\r\n    /**\r\n     * Sets asset spending allowance for a specified spender.\r\n     *\r\n     * @param _spender holder address to set allowance to.\r\n     * @param _value amount to allow.\r\n     *\r\n     * @return success.\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        if (_spender != 0x0) {\r\n            return _getAsset().__approve(_spender, _value, msg.sender);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs allowance setting call on the platform by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _spender holder address to set allowance to.\r\n     * @param _value amount to allow.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     */\r\n    function __approve(address _spender, uint _value, address _sender) public onlyAccess(_sender) returns (bool) {\r\n        return platform.proxyApprove(_spender, _value, smbl, _sender) == OK;\r\n    }\r\n\r\n    /**\r\n     * Emits ERC20 Transfer event on this contract.\r\n     *\r\n     * Can only be, and, called by assigned platform when asset transfer happens.\r\n     */\r\n    function emitTransfer(address _from, address _to, uint _value) public onlyPlatform() {\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Emits ERC20 Approval event on this contract.\r\n     *\r\n     * Can only be, and, called by assigned platform when asset allowance set happens.\r\n     */\r\n    function emitApprove(address _from, address _spender, uint _value) public onlyPlatform() {\r\n        Approval(_from, _spender, _value);\r\n    }\r\n\r\n    /**\r\n     * Returns current asset implementation contract address.\r\n     *\r\n     * @return asset implementation contract address.\r\n     */\r\n    function getLatestVersion() public view returns (address) {\r\n        return latestVersion;\r\n    }\r\n\r\n    /**\r\n     * Propose next asset implementation contract address.\r\n     *\r\n     * Can only be called by current asset owner.\r\n     *\r\n     * Note: freeze-time should not be applied for the initial setup.\r\n     *\r\n     * @param _newVersion asset implementation contract address.\r\n     *\r\n     * @return success.\r\n     */\r\n    function proposeUpgrade(address _newVersion) public onlyAssetOwner returns (bool) {\r\n        // New version address should be other than 0x0.\r\n        if (_newVersion == 0x0) {\r\n            return false;\r\n        }\r\n        \r\n        latestVersion = _newVersion;\r\n\r\n        UpgradeProposal(_newVersion); \r\n        return true;\r\n    }\r\n\r\n    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns asset implementation contract for current caller.\r\n     *\r\n     * @return asset implementation contract.\r\n     */\r\n    function _getAsset() internal view returns (ATxAssetInterface) {\r\n        return ATxAssetInterface(getLatestVersion());\r\n    }\r\n\r\n    /**\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\n     * the caller address.\r\n     *\r\n     * @return success.\r\n     */\r\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns (bool) {\r\n        return _getAsset().__transferWithReference(_to, _value, _reference, msg.sender);\r\n    }\r\n\r\n    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n}\r\n\r\ncontract ATxBuybackInterface {\r\n\r\n\tevent EtherReceived(uint amount);\r\n\tevent TokenExchanged(\r\n\t\taddress recepient, \r\n\t\taddress token, \r\n\t\tuint tokenAmount, \r\n\t\tuint etherAmount, \r\n\t\tuint feeAmount, \r\n\t\taddress feeReceiver, \r\n\t\tuint price\r\n\t);\r\n}\r\n\r\n/// @title Token Buyback contract.\r\n/// @notice Plays role of token exchange to Ether.\r\n/// Has only one token at a contract. To support other tokens\r\n/// there should be created other ATxBuyback contracts.\r\ncontract ATxBuyback is Object, ATxBuybackInterface, ServiceAllowance {\r\n\r\n\tusing SafeMath for uint;\r\n\r\n    struct FeeData {\r\n        uint feeValue;\r\n        uint feeDecimals;\r\n    }\r\n\r\n\t/// @dev Redemption fee collector address\r\n\taddress public rdCollectorAddress;\r\n\t/// @dev Fee value\r\n\tFeeData rdFee;\r\n\r\n\t/// @dev Token to exchange.\r\n\tATxAssetProxy public token;\r\n\t/// @dev Price for 1 token\r\n\tuint public price;\r\n\t/// @dev Active flag\r\n\tbool public active;\r\n\r\n\t/// @dev Guards from invocation only when state is active\r\n\tmodifier onlyActive {\r\n\t\tif (active) {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction ATxBuyback(ATxAssetProxy _token) public {\r\n\t\trequire(address(_token) != 0x0);\r\n\t\ttoken = _token;\r\n\t}\r\n\r\n\t/// @notice Sets a price (in wei) for selling one token\r\n\t/// @param _price \"in wei\" = 1 ATx\r\n\tfunction setPrice(uint _price) onlyContractOwner external returns (uint) {\r\n\t\tprice = _price;\r\n\t\treturn OK;\r\n\t}\r\n\r\n\t/// @notice Sets contract to active/non active state.\r\n\t/// Should be performed only by contract owner.\r\n\t/// @param _active next state of contract. True to activate a contract\r\n\t/// @return result code of an operation\r\n\tfunction setActive(bool _active) onlyContractOwner external returns (uint) {\r\n\t\tif (active == _active) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n        active = _active;\r\n\t\treturn OK;\r\n\t}\r\n\r\n\t/// @notice Setup redemption destination address\r\n\t/// @param _collectorAddress address where all redemptiom fee will be directed\r\n\t/// @return result code of an operation\r\n\tfunction setRdCollectorAddress(address _collectorAddress) onlyContractOwner external returns (uint) {\r\n\t\trequire(_collectorAddress != 0x0);\r\n\t\t\r\n\t\trdCollectorAddress = _collectorAddress;\r\n\t\treturn OK;\r\n\t}\r\n\r\n\t/// @notice Setup redemption fee value\r\n\t/// @param _feeValue fee amount; the minimal value is 1\r\n\t/// @param _feeDecimals fee decimals, sets a precision for fee value\r\n\t/// @return result code of an operation\r\n\tfunction setRdFee(uint _feeValue, uint _feeDecimals) onlyContractOwner external returns (uint) {\r\n\t\trequire(_validFee(_feeValue, _feeDecimals));\r\n\r\n\t\trdFee = FeeData(_feeValue, _feeDecimals);\r\n\t\treturn OK;\r\n\t}\r\n\r\n\t/// @notice Gets redemption fee value\r\n\t/// @return {\r\n\t/// \t\"_value\": \"amount of percents\",\r\n\t///\t\t\"_decimals\": \"percent's precision\"\r\n\t/// }\r\n\tfunction getRdFee() public view returns (uint _value, uint _decimals) {\r\n\t\tFeeData memory _fee = rdFee;\r\n\t\treturn (_fee.feeValue, _fee.feeDecimals);\r\n\t}\r\n\r\n\t/// @notice Withdraws all Ether from buyback contract to specified address.\r\n\t/// Allowed only for contract owner.\r\n\t/// @param _to destination address to send Ether\r\n\t/// @return result code of an operation\r\n\tfunction withdrawAllEth(address _to) onlyContractOwner external returns (uint) {\r\n\t\tuint _balance = address(this).balance;\r\n\t\tif (_balance == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t_to.transfer(_balance);\r\n\r\n\t\treturn OK;\r\n\t}\r\n\r\n\t/// ServiceAllowance\r\n    ///\r\n    /// @notice ServiceAllowance interface implementation\r\n    /// @dev Should cover conditions for allowance of transfers\r\n    function isTransferAllowed(address, address _to, address, address _token, uint) onlyActive public view returns (bool) {\r\n        if (_token == address(token) && _to == address(this)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n\t/// @notice Fallback function for ERC223 standard.\r\n\t/// Allowed to work only in active state.\r\n\t/// @param _sender original sender of token transfer\r\n\t/// @param _value amount of tokens that has been sent\r\n\tfunction tokenFallback(address _sender, uint _value, bytes) external {\r\n\t\t/// Don't allow to transfer and exchange tokens when Buyback contract\r\n\t\t/// is not in 'active' state\r\n\t\tif (!active) {\r\n\t\t\trevert();\r\n\t\t}\r\n\t\t\r\n\t\t/// This call should be produced by AssetProxy's backend - an Asset contract.\r\n\t\t/// Any other call will be followed by revert()\r\n\t\tATxAssetProxy _token = token;\r\n\t\tif (msg.sender != _token.getLatestVersion()) {\r\n\t\t\trevert();\r\n\t\t}\r\n\r\n\t\t/// Need to check available ETH balance in order to fulfill holder's request\r\n\t\t/// about exchanging ATx Token to ETH equivalent\r\n\t\tuint _etherToExchange = _value.mul(price) / (10 ** uint(_token.decimals()));\r\n\t\tif (this.balance < _etherToExchange) {\r\n\t\t\trevert();\r\n\t\t}\r\n\r\n\t\t/// To prevent double spending we revoke transferred assets from foundation platform,\r\n\t\tATxPlatformInterface _platform = ATxPlatformInterface(address(_token.platform()));\r\n\t\trequire(OK == _platform.revokeAsset(_token.smbl(), _value));\r\n\r\n\t\t/// Take redemption fee and return left amount of Ether to transfer it to a holder\r\n\t\tuint _restEther = _takeRdFee(_etherToExchange);\r\n\t\t/// Transfer the rest to holder's account\r\n\t\t_sender.transfer(_restEther);\r\n\r\n\t\t/// Voila! Just emit the event to say to the world that one more exchange action was finished\r\n\t\tTokenExchanged(_sender, _token, _value, _restEther, _etherToExchange.sub(_restEther), rdCollectorAddress, price);\r\n\t}\r\n\r\n\t/// @notice Accepts Ether and emits EtherReceived event\r\n\tfunction() payable external {\r\n\t\tif (msg.value > 0) {\r\n\t\t\tEtherReceived(msg.value);\r\n\t\t}\r\n\t}\r\n\r\n\t/* Internal */\r\n\r\n\tfunction _takeRdFee(uint _fromValue) private returns (uint _restValue) {\r\n\t\t/// Here we check if redemption fee was setup after the contract initialization\r\n\t\tFeeData memory _fee = rdFee;\r\n\t\trequire(_validFee(_fee.feeValue, _fee.feeDecimals));\r\n\r\n\t\t/// Calculate amount of redemption fee that we have to take from the whole sum\r\n\t\tuint _rdFeeEther;\r\n\t\t_rdFeeEther = _fromValue.mul(_fee.feeValue).div(10 ** _fee.feeDecimals);\r\n\t\t_restValue = _fromValue.sub(_rdFeeEther);\r\n\r\n\t\t/// At first use method collector.transfer() to ensure that if this move is not possible\r\n\t\t/// then revert all changes\r\n\t\taddress _rdCollectorAddress = rdCollectorAddress;\r\n\t\trequire(_rdCollectorAddress != 0x0);\r\n\t\t_rdCollectorAddress.transfer(_rdFeeEther);\r\n\t}\r\n\r\n\tfunction _validFee(uint _value, uint _decimals) private pure returns (bool) {\r\n        return _value != 0 && _value / 10 ** _decimals.sub(1) >= 0 && _value / 10 ** _decimals.sub(1) < 10;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"active\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRdFee\",\"outputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_collectorAddress\",\"type\":\"address\"}],\"name\":\"setRdCollectorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setActive\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeValue\",\"type\":\"uint256\"},{\"name\":\"_feeDecimals\",\"type\":\"uint256\"}],\"name\":\"setRdFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rdCollectorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawAllEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recepient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeReceiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"TokenExchanged\",\"type\":\"event\"}]","ContractName":"ATxBuyback","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c72d06eecd98865f4b07cc496c50aca9a1e77e88","Library":"","SwarmSource":"bzzr://85d32c6ddb59d199c38c74c2796e4fb87f23cbd8dbfb24e7901e8c25482736e6"}]}