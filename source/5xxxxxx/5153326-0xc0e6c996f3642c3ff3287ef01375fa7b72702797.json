{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract BitOpterations {\r\n            \r\n        // helper functions set\r\n        // to manipulate on bits \r\n        // with different widht of allocator\r\n        \r\n        function set512(bytes32[2] storage allocator,uint16 pos,uint8 value) internal returns( bytes32[2] storage) {\r\n            \r\n            bytes32 valueBits = (bytes32)(value);\r\n        \r\n            uint8 posOffset = uint8(pos%255);\r\n        \r\n            bytes32 one = 1;\r\n            bytes32 clearBit = (bytes32)(~(one << posOffset));\r\n            \r\n            uint8 bytesIndex = pos>255?1:0;\r\n            \r\n            allocator[bytesIndex] = (allocator[bytesIndex] & clearBit) | (valueBits << posOffset);\r\n            \r\n            return allocator;\r\n            \r\n        }\r\n            \r\n        function get512(bytes32[2] allocator,uint16 pos) internal pure returns(uint8){\r\n            \r\n            uint8 posOffset = uint8(pos%255);\r\n            uint8 bytesIndex = pos>255?1:0;\r\n            \r\n            return (((allocator[bytesIndex] >> posOffset) & 1) == 1)?1:0;   \r\n        }    \r\n        \r\n        function clear512(bytes32[2] storage allocator) internal {\r\n            allocator[0] = 0x0;\r\n            allocator[1] = 0x0;\r\n        }\r\n        \r\n        function set32(bytes4 allocator,uint8 pos, uint8 value) internal pure returns(bytes4) {\r\n            \r\n            bytes4 valueBits = (bytes4)(value);\r\n        \r\n            bytes4 one = 1;\r\n            bytes4 clearBit = (bytes4)(~(one << pos));\r\n            allocator = (allocator & clearBit) | (valueBits << pos);\r\n            \r\n            return allocator;\r\n        }\r\n        \r\n        function get32(bytes4 allocator,uint8 pos) internal pure returns(uint8){\r\n           return (((allocator >> pos) & 1) == 1)?1:0;\r\n        }\r\n}\r\n\r\ncontract Random32BigInteger is BitOpterations {\r\n    \r\n    uint256[10] public randomBlockStart;\r\n    bytes4[10] private numberAllocator;\r\n    bool[10] internal generated;\r\n    \r\n    uint256 private generationNumber = 0;\r\n    \r\n    function generate(uint8 lotteryId) internal returns(bool) {\r\n        \r\n        // to eliminate problem of `same random numbers` lets add \r\n        // some offset on each number generation\r\n        uint8 startOffset = uint8((generationNumber++) % 10); \r\n        \r\n        if (randomBlockStart[lotteryId] == 0) {\r\n            // start random number generation from next block, \r\n            // so we can't influence it \r\n             randomBlockStart[lotteryId] = block.number + startOffset;\r\n        } else {\r\n            uint256 blockDiffNumber = block.number - randomBlockStart[lotteryId];\r\n            \r\n            // revert tx if we haven't enough blocks to calc rand int\r\n            require(blockDiffNumber >= 32);\r\n            \r\n            // its not possible to calc fair random number with start at randomBlockStart\r\n            // because part of blocks or all blocks are not visible from solidity anymore \r\n            // start generation process one more time\r\n            if (blockDiffNumber > 256) {\r\n                randomBlockStart[lotteryId] = block.number + startOffset;\r\n            } else {\r\n                for (uint8 i = 0; i < 32; i++) {\r\n                    \r\n                    // get hash of appropriate block\r\n                    uint256 blockHash = uint256(block.blockhash(randomBlockStart[lotteryId]+i));\r\n                    \r\n                    // set appropriate bit in result number\r\n                    numberAllocator[lotteryId] = set32(numberAllocator[lotteryId],i,uint8(blockHash));\r\n                }\r\n                generated[lotteryId] = true;\r\n                randomBlockStart[lotteryId] = 0;\r\n            }\r\n        }\r\n        return generated[lotteryId];\r\n    }\r\n    \r\n    function clearNumber(uint8 lotteryId) internal {\r\n        randomBlockStart[lotteryId] = 0;\r\n        generated[lotteryId] = false;\r\n    }\r\n    \r\n    function getNumberValue(uint8 lotteryId) internal constant returns(uint32) {\r\n        require(generated[lotteryId]);\r\n        return uint32(numberAllocator[lotteryId]);\r\n    }\r\n}\r\n\r\ncontract EthereumJackpot is Random32BigInteger {\r\n    \r\n    address private owner;\r\n    \r\n    event WinnerPicked(uint8 indexed roomId,address winner,uint16 number);\r\n    event TicketsBought(uint8 indexed roomId,address owner,uint16[] ticketNumbers);\r\n    event LostPayment(address dest,uint256 amount);\r\n    \r\n    struct Winner {\r\n        uint256 prize;\r\n        uint256 timestamp;\r\n        address addr;\r\n        \r\n        uint16 number;\r\n        uint8 percent;\r\n    }\r\n    \r\n    mapping (address => address) public affiliates;\r\n    \r\n    Winner[] private winners;\r\n    \r\n    uint32 public winnersCount;\r\n    \r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    uint8 public affiliatePercent = 1;\r\n    uint8 public maxPercentPerPlayer = 49;\r\n    uint8 public ownerComission = 20;\r\n    \r\n    // time on which lottery has started\r\n    uint256[10] public started;\r\n    \r\n    // last activity time on lottery\r\n    uint256[10] public lastTicketBought;\r\n    \r\n    // one ticket price\r\n    uint256[10] public ticketPrice;\r\n    \r\n    // max number of tickets in this lottery\r\n    uint16[10] public maxTickets;\r\n    \r\n    // time to live before refund can be requested\r\n    uint256[10] public lifetime;\r\n    \r\n    address[][10] ticketsAllocator;\r\n    \r\n    struct Player {\r\n        uint256 changedOn;\r\n        uint16 ticketsCount;\r\n    }\r\n    \r\n    mapping(address => Player)[10] private playerInfoMappings;\r\n    \r\n    bytes32[2][10] bitMaskForPlayFields;\r\n    \r\n    enum State {Uninitialized,Running,Paused,Finished,Refund}\r\n    \r\n    State[10] public state; \r\n    \r\n    // flag that indicates request for pause of lottery[id]\r\n    bool[10] private requestPause; \r\n    \r\n    // number of sold tickets \r\n    uint16[10] public ticketsSold;\r\n    \r\n    // this function set flag to pause room on next clearState call (at the game start)\r\n    function pauseLottery(uint8 lotteryId) public ownerOnly {\r\n        requestPause[lotteryId] = true;\r\n    }\r\n    \r\n    function setOwner(address newOwner) public ownerOnly {\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function getTickets(uint8 lotteryId) public view returns(uint8[]) {\r\n        uint8[] memory result = new uint8[](maxTickets[lotteryId]);\r\n        \r\n        for (uint16 i = 0; i < maxTickets[lotteryId]; i++) {\r\n            result[i] = get512(bitMaskForPlayFields[lotteryId],i);\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    function setLotteryOptions(uint8 lotteryId,uint256 price,uint16 tickets,uint256 timeToRefund) public ownerOnly {\r\n        \r\n        require(lotteryId >= 0 && lotteryId < 10);\r\n        // only allow change of lottery opts when it's in pause state, unitialized or no tickets are sold there yet\r\n        require(state[lotteryId] == State.Paused || state[lotteryId] == State.Uninitialized || ticketsSold[lotteryId] == 0);\r\n        require(price > 0);\r\n        require(tickets > 0 && tickets <= 500);\r\n        require(timeToRefund >= 86400); // require at least one day to sell all tickets\r\n        \r\n        ticketPrice[lotteryId] = price;\r\n        maxTickets[lotteryId] = tickets;\r\n        lifetime[lotteryId] = timeToRefund;\r\n        \r\n        ticketsAllocator[lotteryId].length = tickets;\r\n        \r\n        clearState(lotteryId);\r\n    }\r\n    \r\n    // this methods clears the state \r\n    // of current lottery\r\n    function clearState(uint8 lotteryId) private {\r\n        \r\n        if (!requestPause[lotteryId]) {\r\n            \r\n            // set state of lottery to `running`\r\n            state[lotteryId] = State.Running;\r\n            \r\n            // clear random number data\r\n            clearNumber(lotteryId);\r\n        \r\n            // set current timestamp as start time\r\n            started[lotteryId]  = block.timestamp;\r\n            \r\n            // clear time of last ticket bought\r\n            lastTicketBought[lotteryId] = 0;\r\n            \r\n            // clear number of sold tickets\r\n            ticketsSold[lotteryId] = 0;\r\n           \r\n            // remove previous tickets owner info\r\n            clear512(bitMaskForPlayFields[lotteryId]);\r\n            \r\n        } else {\r\n            // set state to `pause`\r\n            state[lotteryId] = State.Paused;\r\n            requestPause[lotteryId] = false;\r\n        }\r\n    }\r\n    function isInList(address element,address[] memory list) private pure returns (bool) {\r\n        for (uint16 i =0; i < list.length; i++) {\r\n            if (list[i] == element) {\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    function getPlayers(uint8 lotteryId) external view returns (uint16,address[],uint16[]) {\r\n        \r\n        if (ticketsSold[lotteryId] == 0) {\r\n            return;\r\n        }\r\n        \r\n        uint16 currentUser = 0;\r\n        address[] memory resultAddr = new address[](maxTickets[lotteryId]);\r\n        uint16[] memory resultCount = new uint16[](maxTickets[lotteryId]);\r\n        \r\n        for (uint16 t = 0; t < maxTickets[lotteryId]; t++) {\r\n            uint8 ticketBoughtHere = get512(bitMaskForPlayFields[lotteryId],t);\r\n            \r\n            if (ticketBoughtHere != 0) {\r\n                \r\n                address currentAddr = ticketsAllocator[lotteryId][t];\r\n                \r\n                if (!isInList(currentAddr,resultAddr)) {\r\n                \r\n                    Player storage pInfo = playerInfoMappings[lotteryId][currentAddr];\r\n                    \r\n                    resultAddr[currentUser] = currentAddr;\r\n                    resultCount[currentUser] = pInfo.ticketsCount;\r\n                    ++currentUser;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return (currentUser,resultAddr,resultCount);\r\n    }\r\n    \r\n    // in case lottery tickets weren't sold due some time \r\n    // anybody who bought a ticket can \r\n    // ask to refund money (- comission to send them) \r\n    // function refund(uint8 lotteryId) public {\r\n        \r\n    //     // refund state could be reached only from `running` state\r\n    //     require (state[lotteryId] == State.Running);\r\n    //     require (block.timestamp > (started[lotteryId] + lifetime[lotteryId]));\r\n    //     require (ticketsSold[lotteryId] < maxTickets[lotteryId]);\r\n        \r\n    //     // check if its a person which plays this lottery\r\n    //     // or it's a lottery owner\r\n        \r\n    //     require(msg.sender == owner  || playerInfoMappings[lotteryId][msg.sender].changedOn > started[lotteryId]);\r\n        \r\n    //     uint256 notSend = 0;\r\n        \r\n    //     // disallow re-entrancy\r\n    //     // refund process\r\n    //     state[lotteryId] = State.Refund; \r\n        \r\n    //     for (uint16 i = 0; i < maxTickets[lotteryId]; i++) {\r\n            \r\n    //         address tOwner = ticketsAllocator[lotteryId][i];\r\n            \r\n    //         if (tOwner != address(0)) {\r\n    //             uint256 value = playerInfoMappings[lotteryId][tOwner].ticketsCount*ticketPrice[lotteryId];\r\n                    \r\n    //             bool sendResult = tOwner.send(value);\r\n    //             if (!sendResult) {\r\n    //                 LostPayment(tOwner,value);\r\n    //                 notSend += value;\r\n    //             }\r\n    //         }\r\n    //     }\r\n        \r\n    //     // send rest to owner if there any\r\n    //     if (notSend > 0) {\r\n    //         owner.send(notSend);\r\n    //     }\r\n        \r\n    //     // start new lottery \r\n    //     clearState(lotteryId);\r\n    // }\r\n    \r\n    // this method determines current game winner\r\n    function getWinner(uint8 lotteryId) private view returns(uint16,address) {\r\n        \r\n        require(state[lotteryId] == State.Finished);\r\n      \r\n        // apply modulo operation \r\n        // so any ticket number would be within 0 and totalTickets sold\r\n        uint16 winningTicket = uint16(getNumberValue(lotteryId)) % maxTickets[lotteryId];\r\n        \r\n        return (winningTicket,ticketsAllocator[lotteryId][winningTicket]);\r\n    }\r\n    \r\n    // this method is used to finalize Lottery\r\n    // it generates random number and sends prize\r\n    // it uses 32 blocks to generate pseudo random \r\n    // value to determine winner of lottery\r\n    function finalizeRoom(uint8 lotteryId) public {\r\n        \r\n        // here we check for re-entrancy\r\n        require(state[lotteryId] == State.Running);\r\n        \r\n        // only if all tickets are sold\r\n        if (ticketsSold[lotteryId] == maxTickets[lotteryId]) {\r\n            \r\n            // if rand number is not yet generated\r\n            if (generate(lotteryId)) {\r\n                \r\n                // rand number is generated\r\n                // set flag to allow getting winner\r\n                // disable re-entrancy\r\n                state[lotteryId] = State.Finished;\r\n                \r\n                var (winNumber, winner) = getWinner(lotteryId);\r\n                \r\n                uint256 prizeTotal = ticketsSold[lotteryId]*ticketPrice[lotteryId];\r\n                \r\n                // at start, owner commision value equals to the approproate percent of the jackpot\r\n                uint256 ownerComValue = ((prizeTotal*ownerComission)/100);\r\n                \r\n                // winner prize equals total jackpot sum - owner commision value in any case\r\n                uint256 prize = prizeTotal - ownerComValue;\r\n                \r\n                address affiliate = affiliates[winner];\r\n                if (affiliate != address(0)) {\r\n                    uint256 affiliatePrize = (prizeTotal*affiliatePercent)/100;\r\n                    \r\n                    bool afPResult = affiliate.send(affiliatePrize);\r\n                    \r\n                    if (!afPResult) {\r\n                        LostPayment(affiliate,affiliatePrize);\r\n                    } else {\r\n                        // minus affiliate prize and \"gas price\" for that tx from owners com value\r\n                        ownerComValue -= affiliatePrize;\r\n                    }\r\n                }\r\n                \r\n                // pay prize\r\n                \r\n                bool prizeSendResult = winner.send(prize);\r\n                if (!prizeSendResult) {\r\n                    LostPayment(winner,prize);\r\n                    ownerComValue += prize;\r\n                }\r\n                \r\n                // put winner to winners\r\n                uint8 winPercent = uint8(((playerInfoMappings[lotteryId][winner].ticketsCount*100)/maxTickets[lotteryId]));\r\n                \r\n                addWinner(prize,winner,winNumber,winPercent);\r\n                WinnerPicked(lotteryId,winner,winNumber);\r\n                \r\n                // send owner commision\r\n                owner.send(ownerComValue);\r\n                \r\n                clearState(lotteryId);\r\n            }\r\n        }\r\n    }\r\n         \r\n    function buyTicket(uint8 lotteryId,uint16[] tickets,address referer) payable public {\r\n        \r\n        // we're actually in `running` state\r\n        require(state[lotteryId] == State.Running);\r\n        \r\n        // not all tickets are sold yet\r\n        require(maxTickets[lotteryId] > ticketsSold[lotteryId]);\r\n        \r\n        if (referer != address(0)) {\r\n            setReferer(referer);\r\n        }\r\n        \r\n        uint16 ticketsToBuy = uint16(tickets.length);\r\n        \r\n        // check payment for ticket\r\n        uint256 valueRequired = ticketsToBuy*ticketPrice[lotteryId];\r\n        require(valueRequired <= msg.value);\r\n        \r\n        // soft check if player want to buy free tickets\r\n        require((maxTickets[lotteryId] - ticketsSold[lotteryId]) >= ticketsToBuy); \r\n        \r\n        Player storage pInfo = playerInfoMappings[lotteryId][msg.sender];\r\n        if (pInfo.changedOn < started[lotteryId]) {\r\n            pInfo.changedOn = block.timestamp;\r\n            pInfo.ticketsCount = 0;\r\n        }\r\n        \r\n        // check percentage of user's tickets\r\n        require ((pInfo.ticketsCount+ticketsToBuy) <= ((maxTickets[lotteryId]*maxPercentPerPlayer)/100));\r\n        \r\n        for (uint16 i; i < ticketsToBuy; i++) {\r\n            \r\n            require((tickets[i] - 1) >= 0);\r\n            \r\n            // if the ticket is taken you would get your ethers back\r\n            require (get512(bitMaskForPlayFields[lotteryId],tickets[i]-1) == 0);\r\n            set512(bitMaskForPlayFields[lotteryId],tickets[i]-1,1);\r\n            ticketsAllocator[lotteryId][tickets[i]-1] = msg.sender;\r\n        }\r\n            \r\n        pInfo.ticketsCount += ticketsToBuy;\r\n\r\n        // set last time of buy\r\n        lastTicketBought[lotteryId] = block.timestamp;\r\n        \r\n        // set new amount of tickets\r\n        ticketsSold[lotteryId] +=  ticketsToBuy;\r\n        \r\n        // start process of random number generation if last ticket was sold \r\n        if (ticketsSold[lotteryId] == maxTickets[lotteryId]) {\r\n            finalizeRoom(lotteryId);\r\n        }\r\n        \r\n        // fire event\r\n        TicketsBought(lotteryId,msg.sender,tickets);\r\n    }\r\n    \r\n    function roomNeedsFinalization(uint8 lotteryId) internal view  returns (bool){\r\n          return (state[lotteryId] == State.Running && (ticketsSold[lotteryId] >= maxTickets[lotteryId]) && ((randomBlockStart[lotteryId] == 0) || ((randomBlockStart[lotteryId] > 0) && (block.number - randomBlockStart[lotteryId]) >= 32)));\r\n    }\r\n    \r\n    function EthereumJackpot(address ownerAddress) public {\r\n        \r\n        require(ownerAddress != address(0));\r\n            \r\n        owner = ownerAddress;\r\n        \r\n        winners.length = 5;\r\n        winnersCount = 0;\r\n        \r\n    }\r\n    \r\n    function addWinner(uint256 prize,address winner,uint16 number,uint8 percent) private {\r\n        \r\n        // check winners size  and resize it if needed\r\n        if (winners.length == winnersCount) {\r\n            winners.length += 10;\r\n        }\r\n        \r\n        winners[winnersCount++] =  Winner(prize,block.timestamp,winner,number,percent);\r\n    }\r\n    \r\n    function setReferer(address a) private {\r\n        if (a != msg.sender) {\r\n            address addr = affiliates[msg.sender];\r\n            if (addr == address(0)) {\r\n                affiliates[msg.sender] = a;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // // returns only x last winners to prevent stack overflow of vm\r\n    function getWinners(uint256 page) public view returns(uint256[],address[],uint256[],uint16[],uint8[]) {\r\n        \r\n        int256 start = winnersCount - int256(10*(page+1));\r\n        int256 end = start+10;\r\n        \r\n        if (start < 0) {\r\n            start = 0;\r\n        }\r\n        \r\n        if (end <= 0) {\r\n            return;\r\n        }\r\n         \r\n        address[] memory addr = new address[](uint256(end- start));\r\n        uint256[] memory sum = new uint256[](uint256(end- start));\r\n        uint256[] memory time = new uint256[](uint256(end- start));\r\n        uint16[] memory number = new uint16[](uint256(end- start));\r\n        uint8[] memory percent = new uint8[](uint256(end- start));\r\n        \r\n        for (uint256 i = uint256(start); i < uint256(end); i++) {\r\n            \r\n            Winner storage winner = winners[i];\r\n            addr[i - uint256(start)] = winner.addr;\r\n            sum[i - uint256(start)] = winner.prize;\r\n            time[i - uint256(start)] = winner.timestamp;\r\n            number[i - uint256(start)] = winner.number;\r\n            percent[i - uint256(start)] = winner.percent;\r\n        }\r\n        \r\n        return (sum,addr,time,number,percent);\r\n    }\r\n    \r\n    \r\n    function getRomms() public view returns(bool[] active,uint256[] price,uint16[] tickets,uint16[] ticketsBought,uint256[] prize,uint256[] lastActivity,uint8[] comission) {\r\n        \r\n        uint8 roomsCount = 10;\r\n        \r\n        price = new uint256[](roomsCount);\r\n        tickets = new uint16[](roomsCount);\r\n        lastActivity = new uint256[](roomsCount);\r\n        prize = new uint256[](roomsCount);\r\n        comission = new uint8[](roomsCount);\r\n        active = new bool[](roomsCount);\r\n        ticketsBought = new uint16[](roomsCount);\r\n        \r\n        for (uint8 i = 0; i < roomsCount; i++) {\r\n            price[i] = ticketPrice[i];\r\n            ticketsBought[i] = ticketsSold[i];\r\n            tickets[i] = maxTickets[i];\r\n            prize[i] = maxTickets[i]*ticketPrice[i];\r\n            lastActivity[i]  = lastTicketBought[i];\r\n            comission[i] = ownerComission;\r\n            active[i] = state[i] != State.Paused && state[i] != State.Uninitialized;\r\n        }\r\n        \r\n        return (active,price,tickets,ticketsBought,prize,lastActivity,comission);\r\n    }\r\n    \r\n    // this function allows to destroy current contract in case all rooms are paused or not used\r\n    function destroy() public ownerOnly {\r\n        \r\n        for (uint8 i = 0; i < 10; i++) {\r\n            // paused or uninitialized \r\n            require(state[i] == State.Paused || state[i] == State.Uninitialized);\r\n        }\r\n        \r\n        selfdestruct(owner);\r\n    }\r\n    \r\n    // finalize methods\r\n    function needsFinalization() public view returns(bool) {\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            if (roomNeedsFinalization(i)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function finalize() public {\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            if (roomNeedsFinalization(i)) {\r\n                finalizeRoom(i);\r\n            }\r\n        }\r\n        \r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint8\"}],\"name\":\"pauseLottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRomms\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool[]\"},{\"name\":\"price\",\"type\":\"uint256[]\"},{\"name\":\"tickets\",\"type\":\"uint16[]\"},{\"name\":\"ticketsBought\",\"type\":\"uint16[]\"},{\"name\":\"prize\",\"type\":\"uint256[]\"},{\"name\":\"lastActivity\",\"type\":\"uint256[]\"},{\"name\":\"comission\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"started\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTicketBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint8\"}],\"name\":\"getTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliates\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"getWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint16[]\"},{\"name\":\"\",\"type\":\"uint8[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lifetime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerComission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint8\"},{\"name\":\"tickets\",\"type\":\"uint16[]\"},{\"name\":\"referer\",\"type\":\"address\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint8\"}],\"name\":\"getPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint8\"}],\"name\":\"finalizeRoom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needsFinalization\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPercentPerPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomBlockStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ticketsSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lotteryId\",\"type\":\"uint8\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"tickets\",\"type\":\"uint16\"},{\"name\":\"timeToRefund\",\"type\":\"uint256\"}],\"name\":\"setLotteryOptions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affiliatePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"roomId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"number\",\"type\":\"uint16\"}],\"name\":\"WinnerPicked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"roomId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketNumbers\",\"type\":\"uint16[]\"}],\"name\":\"TicketsBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LostPayment\",\"type\":\"event\"}]","ContractName":"EthereumJackpot","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009c95afd14e9ac873f8a42da3daf660b4de8924d5","Library":"","SwarmSource":"bzzr://c337639012ec41ec3bd844ec735361152a152c0cc1dbf91b58c4da1025183e62"}]}