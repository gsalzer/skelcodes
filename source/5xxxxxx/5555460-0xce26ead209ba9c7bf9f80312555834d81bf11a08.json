{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract StorageBase is Ownable {\r\n\r\n    function withdrawBalance() external onlyOwner returns (bool) {\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = msg.sender.send(address(this).balance);\r\n        return res;\r\n    }\r\n}\r\n\r\n// owner of ActivityStorage should be ActivityCore contract address\r\ncontract ActivityStorage is StorageBase {\r\n\r\n    struct Activity {\r\n        // accept bid or not\r\n        bool isPause;\r\n        // limit max num of monster buyable per address\r\n        uint16 buyLimit;\r\n        // price (in wei)\r\n        uint128 packPrice;\r\n        // startDate (in seconds)\r\n        uint64 startDate;\r\n        // endDate (in seconds)\r\n        uint64 endDate;\r\n        // packId => address of bid winner\r\n        mapping(uint16 => address) soldPackToAddress;\r\n        // address => number of success bid\r\n        mapping(address => uint16) addressBoughtCount;\r\n    }\r\n\r\n    // limit max activityId to 65536, big enough\r\n    mapping(uint16 => Activity) public activities;\r\n\r\n    function createActivity(\r\n        uint16 _activityId,\r\n        uint16 _buyLimit,\r\n        uint128 _packPrice,\r\n        uint64 _startDate,\r\n        uint64 _endDate\r\n    ) \r\n        external\r\n        onlyOwner\r\n    {\r\n        // activity should not exist and can only be initialized once\r\n        require(activities[_activityId].buyLimit == 0);\r\n\r\n        activities[_activityId] = Activity({\r\n            isPause: false,\r\n            buyLimit: _buyLimit,\r\n            packPrice: _packPrice,\r\n            startDate: _startDate,\r\n            endDate: _endDate\r\n        });\r\n    }\r\n\r\n    function sellPackToAddress(\r\n        uint16 _activityId, \r\n        uint16 _packId, \r\n        address buyer\r\n    ) \r\n        external \r\n        onlyOwner\r\n    {\r\n        Activity storage activity = activities[_activityId];\r\n        activity.soldPackToAddress[_packId] = buyer;\r\n        activity.addressBoughtCount[buyer]++;\r\n    }\r\n\r\n    function pauseActivity(uint16 _activityId) external onlyOwner {\r\n        activities[_activityId].isPause = true;\r\n    }\r\n\r\n    function unpauseActivity(uint16 _activityId) external onlyOwner {\r\n        activities[_activityId].isPause = false;\r\n    }\r\n\r\n    function deleteActivity(uint16 _activityId) external onlyOwner {\r\n        delete activities[_activityId];\r\n    }\r\n\r\n    function getAddressBoughtCount(uint16 _activityId, address buyer) external view returns (uint16) {\r\n        return activities[_activityId].addressBoughtCount[buyer];\r\n    }\r\n\r\n    function getBuyerAddress(uint16 _activityId, uint16 packId) external view returns (address) {\r\n        return activities[_activityId].soldPackToAddress[packId];\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract HasNoContracts is Pausable {\r\n\r\n    function reclaimContract(address _contractAddr) external onlyOwner whenPaused {\r\n        Ownable contractInst = Ownable(_contractAddr);\r\n        contractInst.transferOwnership(owner);\r\n    }\r\n}\r\n\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract LogicBase is HasNoContracts {\r\n\r\n    /// The ERC-165 interface signature for ERC-721.\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\r\n    bytes4 constant InterfaceSignature_NFC = bytes4(0x9f40b779);\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    ERC721 public nonFungibleContract;\r\n\r\n    // Reference to storage contract\r\n    StorageBase public storageContract;\r\n\r\n    function LogicBase(address _nftAddress, address _storageAddress) public {\r\n        // paused by default\r\n        paused = true;\r\n\r\n        setNFTAddress(_nftAddress);\r\n\r\n        require(_storageAddress != address(0));\r\n        storageContract = StorageBase(_storageAddress);\r\n    }\r\n\r\n    // Very dangerous action, only when new contract has been proved working\r\n    // Requires storageContract already transferOwnership to the new contract\r\n    // This method is only used to transfer the balance to owner\r\n    function destroy() external onlyOwner whenPaused {\r\n        address storageOwner = storageContract.owner();\r\n        // owner of storageContract must not be the current contract otherwise the storageContract will forever not accessible\r\n        require(storageOwner != address(this));\r\n        // Transfers the current balance to the owner and terminates the contract\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // Very dangerous action, only when new contract has been proved working\r\n    // Requires storageContract already transferOwnership to the new contract\r\n    // This method is only used to transfer the balance to the new contract\r\n    function destroyAndSendToStorageOwner() external onlyOwner whenPaused {\r\n        address storageOwner = storageContract.owner();\r\n        // owner of storageContract must not be the current contract otherwise the storageContract will forever not accessible\r\n        require(storageOwner != address(this));\r\n        // Transfers the current balance to the new owner of the storage contract and terminates the contract\r\n        selfdestruct(storageOwner);\r\n    }\r\n\r\n    // override to make sure everything is initialized before the unpause\r\n    function unpause() public onlyOwner whenPaused {\r\n        // can not unpause when the logic contract is not initialzed\r\n        require(nonFungibleContract != address(0));\r\n        require(storageContract != address(0));\r\n        // can not unpause when ownership of storage contract is not the current contract\r\n        require(storageContract.owner() == address(this));\r\n\r\n        super.unpause();\r\n    }\r\n\r\n    function setNFTAddress(address _nftAddress) public onlyOwner {\r\n        require(_nftAddress != address(0));\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        require(candidateContract.supportsInterface(InterfaceSignature_NFC));\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    // Withdraw balance to the Core Contract\r\n    function withdrawBalance() external returns (bool) {\r\n        address nftAddress = address(nonFungibleContract);\r\n        // either Owner or Core Contract can trigger the withdraw\r\n        require(msg.sender == owner || msg.sender == nftAddress);\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = nftAddress.send(address(this).balance);\r\n        return res;\r\n    }\r\n\r\n    function withdrawBalanceFromStorageContract() external returns (bool) {\r\n        address nftAddress = address(nonFungibleContract);\r\n        // either Owner or Core Contract can trigger the withdraw\r\n        require(msg.sender == owner || msg.sender == nftAddress);\r\n        // The owner has a method to withdraw balance from multiple contracts together,\r\n        // use send here to make sure even if one withdrawBalance fails the others will still work\r\n        bool res = storageContract.withdrawBalance();\r\n        return res;\r\n    }\r\n}\r\n\r\ncontract ActivityCore is LogicBase {\r\n\r\n    bool public isActivityCore = true;\r\n\r\n    ActivityStorage activityStorage;\r\n\r\n    event ActivityCreated(uint16 activityId);\r\n    event ActivityBidSuccess(uint16 activityId, uint16 packId, address winner);\r\n\r\n    function ActivityCore(address _nftAddress, address _storageAddress) \r\n        LogicBase(_nftAddress, _storageAddress) public {\r\n            \r\n        activityStorage = ActivityStorage(_storageAddress);\r\n    }\r\n\r\n    function createActivity(\r\n        uint16 _activityId,\r\n        uint16 _buyLimit,\r\n        uint128 _packPrice,\r\n        uint64 _startDate,\r\n        uint64 _endDate\r\n    ) \r\n        external\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n        activityStorage.createActivity(_activityId, _buyLimit, _packPrice, _startDate, _endDate);\r\n\r\n        emit ActivityCreated(_activityId);\r\n    }\r\n\r\n    // Very dangerous action and should be only used for testing\r\n    // Must pause the contract first \r\n    function deleteActivity(\r\n        uint16 _activityId\r\n    )\r\n        external \r\n        onlyOwner\r\n        whenPaused\r\n    {\r\n        activityStorage.deleteActivity(_activityId);\r\n    }\r\n\r\n    function getActivity(\r\n        uint16 _activityId\r\n    ) \r\n        external \r\n        view  \r\n        returns (\r\n            bool isPause,\r\n            uint16 buyLimit,\r\n            uint128 packPrice,\r\n            uint64 startDate,\r\n            uint64 endDate\r\n        )\r\n    {\r\n        return activityStorage.activities(_activityId);\r\n    }\r\n    \r\n    function bid(uint16 _activityId, uint16 _packId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        bool isPause;\r\n        uint16 buyLimit;\r\n        uint128 packPrice;\r\n        uint64 startDate;\r\n        uint64 endDate;\r\n        (isPause, buyLimit, packPrice, startDate, endDate) = activityStorage.activities(_activityId);\r\n        // not allow to bid when activity is paused\r\n        require(!isPause);\r\n        // not allow to bid when activity is not initialized (buyLimit == 0)\r\n        require(buyLimit > 0);\r\n        // should send enough ether\r\n        require(msg.value >= packPrice);\r\n        // verify startDate & endDate\r\n        require(now >= startDate && now <= endDate);\r\n        // this pack is not sold out\r\n        require(activityStorage.getBuyerAddress(_activityId, _packId) == address(0));\r\n        // buyer not exceed buyLimit\r\n        require(activityStorage.getAddressBoughtCount(_activityId, msg.sender) < buyLimit);\r\n        // record in blockchain\r\n        activityStorage.sellPackToAddress(_activityId, _packId, msg.sender);\r\n        // emit the success event\r\n        emit ActivityBidSuccess(_activityId, _packId, msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"storageContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_activityId\",\"type\":\"uint16\"},{\"name\":\"_packId\",\"type\":\"uint16\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_activityId\",\"type\":\"uint16\"}],\"name\":\"getActivity\",\"outputs\":[{\"name\":\"isPause\",\"type\":\"bool\"},{\"name\":\"buyLimit\",\"type\":\"uint16\"},{\"name\":\"packPrice\",\"type\":\"uint128\"},{\"name\":\"startDate\",\"type\":\"uint64\"},{\"name\":\"endDate\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"setNFTAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActivityCore\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_activityId\",\"type\":\"uint16\"}],\"name\":\"deleteActivity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_activityId\",\"type\":\"uint16\"},{\"name\":\"_buyLimit\",\"type\":\"uint16\"},{\"name\":\"_packPrice\",\"type\":\"uint128\"},{\"name\":\"_startDate\",\"type\":\"uint64\"},{\"name\":\"_endDate\",\"type\":\"uint64\"}],\"name\":\"createActivity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyAndSendToStorageOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalanceFromStorageContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_storageAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"activityId\",\"type\":\"uint16\"}],\"name\":\"ActivityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"activityId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"packId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"ActivityBidSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ActivityCore","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a9e3440d5c64e99c77410ec4b15746b835add59e000000000000000000000000acfbc0cac678a020b919cbd17d3beb20b7c4c8f3","Library":"","SwarmSource":"bzzr://a9d99fcea9fa0f1182d4755154fbafaec89a7fbaab397bbf64ffe80fd4cbd296"}]}