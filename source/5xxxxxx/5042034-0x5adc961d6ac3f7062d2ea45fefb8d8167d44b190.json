{"status":"1","message":"OK","result":[{"SourceCode":"library SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract Whitelistable is Ownable {\r\n    \r\n    event LogUserRegistered(address indexed sender, address indexed userAddress);\r\n    event LogUserUnregistered(address indexed sender, address indexed userAddress);\r\n    \r\n    mapping(address => bool) public whitelisted;\r\n\r\n    function registerUser(address userAddress) \r\n        public \r\n        onlyOwner \r\n    {\r\n        require(userAddress != 0);\r\n        whitelisted[userAddress] = true;\r\n        LogUserRegistered(msg.sender, userAddress);\r\n    }\r\n\r\n    function unregisterUser(address userAddress) \r\n        public \r\n        onlyOwner \r\n    {\r\n        require(whitelisted[userAddress] == true);\r\n        whitelisted[userAddress] = false;\r\n        LogUserUnregistered(msg.sender, userAddress);\r\n    }\r\n}\r\n\r\ncontract DisbursementHandler is Ownable {\r\n\r\n    struct Disbursement {\r\n        uint256 timestamp;\r\n        uint256 tokens;\r\n    }\r\n\r\n    event LogSetup(address indexed vestor, uint256 tokens, uint256 timestamp);\r\n    event LogChangeTimestamp(address indexed vestor, uint256 index, uint256 timestamp);\r\n    event LogWithdraw(address indexed to, uint256 value);\r\n\r\n    ERC20 public token;\r\n    mapping(address => Disbursement[]) public disbursements;\r\n    mapping(address => uint256) public withdrawnTokens;\r\n\r\n    function DisbursementHandler(address _token) public {\r\n        token = ERC20(_token);\r\n    }\r\n\r\n    /// @dev Called by the sale contract to create a disbursement.\r\n    /// @param vestor The address of the beneficiary.\r\n    /// @param tokens Amount of tokens to be locked.\r\n    /// @param timestamp Funds will be locked until this timestamp.\r\n    function setupDisbursement(\r\n        address vestor,\r\n        uint256 tokens,\r\n        uint256 timestamp\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(block.timestamp < timestamp);\r\n        disbursements[vestor].push(Disbursement(timestamp, tokens));\r\n        LogSetup(vestor, timestamp, tokens);\r\n    }\r\n\r\n    /// @dev Change an existing disbursement.\r\n    /// @param vestor The address of the beneficiary.\r\n    /// @param timestamp Funds will be locked until this timestamp.\r\n    /// @param index Index of the DisbursementVesting in the vesting array.\r\n    function changeTimestamp(\r\n        address vestor,\r\n        uint256 index,\r\n        uint256 timestamp\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(block.timestamp < timestamp);\r\n        require(index < disbursements[vestor].length);\r\n        disbursements[vestor][index].timestamp = timestamp;\r\n        LogChangeTimestamp(vestor, index, timestamp);\r\n    }\r\n\r\n    /// @dev Transfers tokens to a given address\r\n    /// @param to Address of token receiver\r\n    /// @param value Number of tokens to transfer\r\n    function withdraw(address to, uint256 value)\r\n        public\r\n    {\r\n        uint256 maxTokens = calcMaxWithdraw();\r\n        uint256 withdrawAmount = value < maxTokens ? value : maxTokens;\r\n        withdrawnTokens[msg.sender] = SafeMath.add(withdrawnTokens[msg.sender], withdrawAmount);\r\n        token.transfer(to, withdrawAmount);\r\n        LogWithdraw(to, value);\r\n    }\r\n\r\n    /// @dev Calculates the maximum amount of vested tokens\r\n    /// @return Number of vested tokens to withdraw\r\n    function calcMaxWithdraw()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        uint256 maxTokens = 0;\r\n        Disbursement[] storage temp = disbursements[msg.sender];\r\n        for (uint256 i = 0; i < temp.length; i++) {\r\n            if (block.timestamp > temp[i].timestamp) {\r\n                maxTokens = SafeMath.add(maxTokens, temp[i].tokens);\r\n            }\r\n        }\r\n        maxTokens = SafeMath.sub(maxTokens, withdrawnTokens[msg.sender]);\r\n        return maxTokens;\r\n    }\r\n}\r\n\r\nlibrary StateMachineLib {\r\n\r\n    struct Stage {\r\n        // The id of the next stage\r\n        bytes32 nextId;\r\n\r\n        // The identifiers for the available functions in each stage\r\n        mapping(bytes4 => bool) allowedFunctions;\r\n    }\r\n\r\n    struct State {\r\n        // The current stage id\r\n        bytes32 currentStageId;\r\n\r\n        // A callback that is called when entering this stage\r\n        function(bytes32) internal onTransition;\r\n\r\n        // Checks if a stage id is valid\r\n        mapping(bytes32 => bool) validStage;\r\n\r\n        // Maps stage ids to their Stage structs\r\n        mapping(bytes32 => Stage) stages;\r\n    }\r\n\r\n    /// @dev Creates and sets the initial stage. It has to be called before creating any transitions.\r\n    /// @param stageId The id of the (new) stage to set as initial stage.\r\n    function setInitialStage(State storage self, bytes32 stageId) internal {\r\n        self.validStage[stageId] = true;\r\n        self.currentStageId = stageId;\r\n    }\r\n\r\n    /// @dev Creates a transition from 'fromId' to 'toId'. If fromId already had a nextId, it deletes the now unreachable stage.\r\n    /// @param fromId The id of the stage from which the transition begins.\r\n    /// @param toId The id of the stage that will be reachable from \"fromId\".\r\n    function createTransition(State storage self, bytes32 fromId, bytes32 toId) internal {\r\n        require(self.validStage[fromId]);\r\n\r\n        Stage storage from = self.stages[fromId];\r\n\r\n        // Invalidate the stage that won't be reachable any more\r\n        if (from.nextId != 0) {\r\n            self.validStage[from.nextId] = false;\r\n            delete self.stages[from.nextId];\r\n        }\r\n\r\n        from.nextId = toId;\r\n        self.validStage[toId] = true;\r\n    }\r\n\r\n    /// @dev Goes to the next stage if posible (if the next stage is valid)\r\n    function goToNextStage(State storage self) internal {\r\n        Stage storage current = self.stages[self.currentStageId];\r\n\r\n        require(self.validStage[current.nextId]);\r\n\r\n        self.currentStageId = current.nextId;\r\n\r\n        self.onTransition(current.nextId);\r\n    }\r\n\r\n    /// @dev Checks if the a function is allowed in the current stage.\r\n    /// @param selector A function selector (bytes4[keccak256(functionSignature)])\r\n    /// @return true If the function is allowed in the current stage\r\n    function checkAllowedFunction(State storage self, bytes4 selector) internal constant returns(bool) {\r\n        return self.stages[self.currentStageId].allowedFunctions[selector];\r\n    }\r\n\r\n    /// @dev Allow a function in the given stage.\r\n    /// @param stageId The id of the stage\r\n    /// @param selector A function selector (bytes4[keccak256(functionSignature)])\r\n    function allowFunction(State storage self, bytes32 stageId, bytes4 selector) internal {\r\n        require(self.validStage[stageId]);\r\n        self.stages[stageId].allowedFunctions[selector] = true;\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract StateMachine {\r\n    using StateMachineLib for StateMachineLib.State;\r\n\r\n    event LogTransition(bytes32 indexed stageId, uint256 blockNumber);\r\n\r\n    StateMachineLib.State internal state;\r\n\r\n    /* This modifier performs the conditional transitions and checks that the function \r\n     * to be executed is allowed in the current stage\r\n     */\r\n    modifier checkAllowed {\r\n        conditionalTransitions();\r\n        require(state.checkAllowedFunction(msg.sig));\r\n        _;\r\n    }\r\n\r\n    function StateMachine() public {\r\n        // Register the startConditions function and the onTransition callback\r\n        state.onTransition = onTransition;\r\n    }\r\n\r\n    /// @dev Gets the current stage id.\r\n    /// @return The current stage id.\r\n    function getCurrentStageId() public view returns(bytes32) {\r\n        return state.currentStageId;\r\n    }\r\n\r\n    /// @dev Performs conditional transitions. Can be called by anyone.\r\n    function conditionalTransitions() public {\r\n\r\n        bytes32 nextId = state.stages[state.currentStageId].nextId;\r\n\r\n        while (state.validStage[nextId]) {\r\n            StateMachineLib.Stage storage next = state.stages[nextId];\r\n            // If the next stage's condition is true, go to next stage and continue\r\n            if (startConditions(nextId)) {\r\n                state.goToNextStage();\r\n                nextId = next.nextId;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Determines whether the conditions for transitioning to the given stage are met.\r\n    /// @return true if the conditions are met for the given stageId. False by default (must override in child contracts).\r\n    function startConditions(bytes32) internal constant returns(bool) {\r\n        return false;\r\n    }\r\n\r\n    /// @dev Callback called when there is a stage transition. It should be overridden for additional functionality.\r\n    function onTransition(bytes32 stageId) internal {\r\n        LogTransition(stageId, block.number);\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract TimedStateMachine is StateMachine {\r\n\r\n    event LogSetStageStartTime(bytes32 indexed stageId, uint256 startTime);\r\n\r\n    // Stores the start timestamp for each stage (the value is 0 if the stage doesn't have a start timestamp).\r\n    mapping(bytes32 => uint256) internal startTime;\r\n\r\n    /// @dev This function overrides the startConditions function in the parent contract in order to enable automatic transitions that depend on the timestamp.\r\n    function startConditions(bytes32 stageId) internal constant returns(bool) {\r\n        // Get the startTime for stage\r\n        uint256 start = startTime[stageId];\r\n        // If the startTime is set and has already passed, return true.\r\n        return start != 0 && block.timestamp > start;\r\n    }\r\n\r\n    /// @dev Sets the starting timestamp for a stage.\r\n    /// @param stageId The id of the stage for which we want to set the start timestamp.\r\n    /// @param timestamp The start timestamp for the given stage. It should be bigger than the current one.\r\n    function setStageStartTime(bytes32 stageId, uint256 timestamp) internal {\r\n        require(state.validStage[stageId]);\r\n        require(timestamp > block.timestamp);\r\n\r\n        startTime[stageId] = timestamp;\r\n        LogSetStageStartTime(stageId, timestamp);\r\n    }\r\n\r\n    /// @dev Returns the timestamp for the given stage id.\r\n    /// @param stageId The id of the stage for which we want to set the start timestamp.\r\n    function getStageStartTime(bytes32 stageId) public view returns(uint256) {\r\n        return startTime[stageId];\r\n    }\r\n}\r\n\r\ncontract Sale is Ownable, TimedStateMachine {\r\n    using SafeMath for uint256;\r\n\r\n    event LogContribution(address indexed contributor, uint256 amountSent, uint256 excessRefunded);\r\n    event LogTokenAllocation(address indexed contributor, uint256 contribution, uint256 tokens);\r\n    event LogDisbursement(address indexed beneficiary, uint256 tokens);\r\n\r\n    // Stages for the state machine\r\n    bytes32 public constant SETUP = \"setup\";\r\n    bytes32 public constant SETUP_DONE = \"setupDone\";\r\n    bytes32 public constant SALE_IN_PROGRESS = \"saleInProgress\";\r\n    bytes32 public constant SALE_ENDED = \"saleEnded\";\r\n\r\n    mapping(address => uint256) public contributions;\r\n\r\n    uint256 public weiContributed = 0;\r\n    uint256 public contributionCap;\r\n\r\n    // Wallet where funds will be sent\r\n    address public wallet;\r\n\r\n    MintableToken public token;\r\n\r\n    DisbursementHandler public disbursementHandler;\r\n\r\n    function Sale(\r\n        address _wallet, \r\n        uint256 _contributionCap\r\n    ) \r\n        public \r\n    {\r\n        require(_wallet != 0);\r\n        require(_contributionCap != 0);\r\n\r\n        wallet = _wallet;\r\n\r\n        token = createTokenContract();\r\n        disbursementHandler = new DisbursementHandler(token);\r\n\r\n        contributionCap = _contributionCap;\r\n\r\n        setupStages();\r\n    }\r\n\r\n    function() external payable {\r\n        contribute();\r\n    }\r\n\r\n    /// @dev Sets the start timestamp for the SALE_IN_PROGRESS stage.\r\n    /// @param timestamp The start timestamp.\r\n    function setSaleStartTime(uint256 timestamp) \r\n        external \r\n        onlyOwner \r\n        checkAllowed\r\n    {\r\n        // require(_startTime < getStageStartTime(SALE_ENDED));\r\n        setStageStartTime(SALE_IN_PROGRESS, timestamp);\r\n    }\r\n\r\n    /// @dev Sets the start timestamp for the SALE_ENDED stage.\r\n    /// @param timestamp The start timestamp.\r\n    function setSaleEndTime(uint256 timestamp) \r\n        external \r\n        onlyOwner \r\n        checkAllowed\r\n    {\r\n        require(getStageStartTime(SALE_IN_PROGRESS) < timestamp);\r\n        setStageStartTime(SALE_ENDED, timestamp);\r\n    }\r\n\r\n    /// @dev Called in the SETUP stage, check configurations and to go to the SETUP_DONE stage.\r\n    function setupDone() \r\n        public \r\n        onlyOwner \r\n        checkAllowed\r\n    {\r\n        uint256 _startTime = getStageStartTime(SALE_IN_PROGRESS);\r\n        uint256 _endTime = getStageStartTime(SALE_ENDED);\r\n        require(block.timestamp < _startTime);\r\n        require(_startTime < _endTime);\r\n\r\n        state.goToNextStage();\r\n    }\r\n\r\n    /// @dev Called by users to contribute ETH to the sale.\r\n    function contribute() \r\n        public \r\n        payable\r\n        checkAllowed \r\n    {\r\n        require(msg.value > 0);   \r\n\r\n        uint256 contributionLimit = getContributionLimit(msg.sender);\r\n        require(contributionLimit > 0);\r\n\r\n        // Check that the user is allowed to contribute\r\n        uint256 totalContribution = contributions[msg.sender].add(msg.value);\r\n        uint256 excess = 0;\r\n\r\n        // Check if it goes over the eth cap for the sale.\r\n        if (weiContributed.add(msg.value) > contributionCap) {\r\n            // Subtract the excess\r\n            excess = weiContributed.add(msg.value).sub(contributionCap);\r\n            totalContribution = totalContribution.sub(excess);\r\n        }\r\n\r\n        // Check if it goes over the contribution limit of the user. \r\n        if (totalContribution > contributionLimit) {\r\n            excess = excess.add(totalContribution).sub(contributionLimit);\r\n            contributions[msg.sender] = contributionLimit;\r\n        } else {\r\n            contributions[msg.sender] = totalContribution;\r\n        }\r\n\r\n        // We are only able to refund up to msg.value because the contract will not contain ether\r\n        // excess = excess < msg.value ? excess : msg.value;\r\n        require(excess <= msg.value);\r\n\r\n        weiContributed = weiContributed.add(msg.value).sub(excess);\r\n\r\n        if (excess > 0) {\r\n            msg.sender.transfer(excess);\r\n        }\r\n\r\n        wallet.transfer(this.balance);\r\n\r\n        assert(contributions[msg.sender] <= contributionLimit);\r\n        LogContribution(msg.sender, msg.value, excess);\r\n    }\r\n\r\n    /// @dev Create a disbursement of tokens.\r\n    /// @param beneficiary The beneficiary of the disbursement.\r\n    /// @param tokenAmount Amount of tokens to be locked.\r\n    /// @param timestamp Tokens will be locked until this timestamp.\r\n    function distributeTimelockedTokens(\r\n        address beneficiary,\r\n        uint256 tokenAmount,\r\n        uint256 timestamp\r\n    ) \r\n        public\r\n        onlyOwner\r\n        checkAllowed\r\n    { \r\n        disbursementHandler.setupDisbursement(\r\n            beneficiary,\r\n            tokenAmount,\r\n            timestamp\r\n        );\r\n        token.mint(disbursementHandler, tokenAmount);\r\n        LogDisbursement(beneficiary, tokenAmount);\r\n    }\r\n    \r\n    function setupStages() internal {\r\n        // Set the stages\r\n        state.setInitialStage(SETUP);\r\n        state.createTransition(SETUP, SETUP_DONE);\r\n        state.createTransition(SETUP_DONE, SALE_IN_PROGRESS);\r\n        state.createTransition(SALE_IN_PROGRESS, SALE_ENDED);\r\n\r\n        state.allowFunction(SETUP, this.distributeTimelockedTokens.selector);\r\n        state.allowFunction(SETUP, this.setSaleStartTime.selector);\r\n        state.allowFunction(SETUP, this.setSaleEndTime.selector);\r\n        state.allowFunction(SETUP, this.setupDone.selector);\r\n        state.allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\r\n        state.allowFunction(SALE_IN_PROGRESS, 0); // fallback\r\n    }\r\n\r\n    // Override in the child sales\r\n    function createTokenContract() internal returns (MintableToken);\r\n    function getContributionLimit(address userAddress) public view returns (uint256);\r\n\r\n    /// @dev Stage start conditions.\r\n    function startConditions(bytes32 stageId) internal constant returns (bool) {\r\n        // If the cap has been reached, end the sale.\r\n        if (stageId == SALE_ENDED && contributionCap <= weiContributed) {\r\n            return true;\r\n        }\r\n        return super.startConditions(stageId);\r\n    }\r\n\r\n    /// @dev State transitions callbacks.\r\n    function onTransition(bytes32 stageId) internal {\r\n        if (stageId == SALE_ENDED) { \r\n            onSaleEnded(); \r\n        }\r\n        super.onTransition(stageId);\r\n    }\r\n\r\n    /// @dev Callback that gets called when entering the SALE_ENDED stage.\r\n    function onSaleEnded() internal {}\r\n}\r\n\r\ncontract ERC223ReceivingContract {\r\n\r\n    /// @dev Standard ERC223 function that will handle incoming token transfers.\r\n    /// @param _from  Token sender address.\r\n    /// @param _value Amount of tokens.\r\n    /// @param _data  Transaction metadata.\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n\r\n}\r\n\r\ncontract ERC223Basic is ERC20Basic {\r\n\r\n    /**\r\n      * @dev Transfer the specified amount of tokens to the specified address.\r\n      *      Now with a new parameter _data.\r\n      *\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      * @param _data  Transaction metadata.\r\n      */\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool);\r\n\r\n    /**\r\n      * @dev triggered when transfer is successfully called.\r\n      *\r\n      * @param _from  Sender address.\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      * @param _data  Transaction metadata.\r\n      */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\r\n}\r\n\r\n\r\ncontract ERC223BasicToken is ERC223Basic, BasicToken {\r\n\r\n    /**\r\n      * @dev Transfer the specified amount of tokens to the specified address.\r\n      *      Invokes the `tokenFallback` function if the recipient is a contract.\r\n      *      The token transfer fails if the recipient is a contract\r\n      *      but does not implement the `tokenFallback` function\r\n      *      or the fallback function to receive funds.\r\n      *\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      * @param _data  Transaction metadata.\r\n      */\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly .\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        require(super.transfer(_to, _value));\r\n\r\n        if(codeLength>0) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n\r\n      /**\r\n      * @dev Transfer the specified amount of tokens to the specified address.\r\n      *      Invokes the `tokenFallback` function if the recipient is a contract.\r\n      *      The token transfer fails if the recipient is a contract\r\n      *      but does not implement the `tokenFallback` function\r\n      *      or the fallback function to receive funds.\r\n      *\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        bytes memory empty;\r\n        require(transfer(_to, _value, empty));\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\ncontract DetherToken is DetailedERC20, MintableToken, ERC223BasicToken {\r\n    string constant NAME = \"Dether\";\r\n    string constant SYMBOL = \"DTH\";\r\n    uint8 constant DECIMALS = 18;\r\n\r\n    /**\r\n      *@dev Constructor that set Detailed of the ERC20 token.\r\n      */\r\n    function DetherToken()\r\n        DetailedERC20(NAME, SYMBOL, DECIMALS)\r\n        public\r\n    {}\r\n}\r\n\r\n\r\ncontract DetherSale is Sale, Whitelistable {\r\n\r\n    uint256 public constant PRESALE_WEI = 3956 ether * 1.15 + 490 ether; // Amount raised in the presale including bonus\r\n\r\n    uint256 public constant DECIMALS_MULTIPLIER = 1000000000000000000;\r\n    uint256 public constant MAX_DTH = 100000000 * DECIMALS_MULTIPLIER;\r\n\r\n    // MAX_WEI - PRESALE_WEI\r\n    // TODO: change to actual amount\r\n    uint256 public constant WEI_CAP = 10554 ether;\r\n\r\n    // Duration of the whitelisting phase\r\n    uint256 public constant WHITELISTING_DURATION = 2 days;\r\n\r\n    // Contribution limit for the whitelisting phase\r\n    uint256 public constant WHITELISTING_MAX_CONTRIBUTION = 5 ether;\r\n\r\n    // Contribution limit for the public sale\r\n    uint256 public constant PUBLIC_MAX_CONTRIBUTION = 2**256 - 1;\r\n\r\n    // Minimum contribution allowed\r\n    uint256 public constant MIN_CONTRIBUTION = 0.1 ether;\r\n\r\n    // wei per DTH\r\n    uint256 public weiPerDTH;\r\n    // true if the locked tokens have been distributed\r\n    bool private lockedTokensDistributed;\r\n    // true if the presale tokens have been allocated\r\n    bool private presaleAllocated;\r\n\r\n    // Address for the presale buyers (Dether team will distribute manually)\r\n    address public presaleAddress;\r\n\r\n    uint256 private weiAllocated;\r\n\r\n    // Contribution limits specified for the presale\r\n    mapping(address => uint256) public presaleMaxContribution;\r\n\r\n    function DetherSale(address _wallet, address _presaleAddress) Sale(_wallet, WEI_CAP) public {\r\n      presaleAddress = _presaleAddress;\r\n    }\r\n\r\n    /// @dev Distributes timed locked tokens\r\n    function performInitialAllocations() external onlyOwner checkAllowed {\r\n        require(lockedTokensDistributed == false);\r\n        lockedTokensDistributed = true;\r\n\r\n        // Advisors\r\n        distributeTimelockedTokens(0x4dc976cEd66d1B87C099B338E1F1388AE657377d, MAX_DTH.mul(3).div(100), now + 6 * 4 weeks);\r\n\r\n        // Bounty\r\n        distributeTimelockedTokens(0xfEF675cC3068Ee798f2312e82B12c841157A0A0E, MAX_DTH.mul(3).div(100), now + 1 weeks);\r\n\r\n        // Early Contributors\r\n        distributeTimelockedTokens(0x8F38C4ddFE09Bd22545262FE160cf441D43d2489, MAX_DTH.mul(25).div(1000), now + 6 * 4 weeks);\r\n\r\n        distributeTimelockedTokens(0x87a4eb1c9fdef835DC9197FAff3E09b8007ADe5b, MAX_DTH.mul(25).div(1000), now + 6 * 4 weeks);\r\n\r\n        // Strategic Partnerships\r\n        distributeTimelockedTokens(0x6f63D5DF2D8644851cBb5F8607C845704C008284, MAX_DTH.mul(11).div(100), now + 1 weeks);\r\n\r\n        // Team (locked 3 years, 6 months release)\r\n        distributeTimelockedTokens(0x24c14796f401D77fc401F9c2FA1dF42A136EbF83, MAX_DTH.mul(3).div(100), now + 6 * 4 weeks);\r\n        distributeTimelockedTokens(0x24c14796f401D77fc401F9c2FA1dF42A136EbF83, MAX_DTH.mul(3).div(100), now + 2 * 6 * 4 weeks);\r\n        distributeTimelockedTokens(0x24c14796f401D77fc401F9c2FA1dF42A136EbF83, MAX_DTH.mul(3).div(100), now + 3 * 6 * 4 weeks);\r\n        distributeTimelockedTokens(0x24c14796f401D77fc401F9c2FA1dF42A136EbF83, MAX_DTH.mul(3).div(100), now + 4 * 6 * 4 weeks);\r\n        distributeTimelockedTokens(0x24c14796f401D77fc401F9c2FA1dF42A136EbF83, MAX_DTH.mul(3).div(100), now + 5 * 6 * 4 weeks);\r\n        distributeTimelockedTokens(0x24c14796f401D77fc401F9c2FA1dF42A136EbF83, MAX_DTH.mul(3).div(100), now + 6 * 6 * 4 weeks);\r\n    }\r\n\r\n    /// @dev Registers a user and sets the maximum contribution amount for the whitelisting period\r\n    function registerPresaleContributor(address userAddress, uint256 maxContribution)\r\n        external\r\n        onlyOwner\r\n    {\r\n        // Specified contribution has to be lower than the max\r\n        require(maxContribution <= WHITELISTING_MAX_CONTRIBUTION);\r\n\r\n        // Register user (Whitelistable contract)\r\n        registerUser(userAddress);\r\n\r\n        // Set contribution\r\n        presaleMaxContribution[userAddress] = maxContribution;\r\n    }\r\n\r\n    /// @dev Called to allocate the tokens depending on eth contributed.\r\n    /// @param contributor The address of the contributor.\r\n    function allocateTokens(address contributor)\r\n        external\r\n        checkAllowed\r\n    {\r\n        require(presaleAllocated);\r\n        require(contributions[contributor] != 0);\r\n\r\n        // We keep a record of how much wei contributed has already been used for allocations\r\n        weiAllocated = weiAllocated.add(contributions[contributor]);\r\n\r\n        // Mint the respective tokens to the contributor\r\n        token.mint(contributor, contributions[contributor].mul(DECIMALS_MULTIPLIER).div(weiPerDTH));\r\n\r\n        // Set contributions to 0\r\n        contributions[contributor] = 0;\r\n\r\n        // If all tokens were allocated, stop minting functionality\r\n        // and send the remaining (rounding errors) tokens to the owner\r\n        if (weiAllocated == weiContributed) {\r\n          uint256 remaining = MAX_DTH.sub(token.totalSupply());\r\n          token.mint(owner, remaining);\r\n          token.finishMinting();\r\n        }\r\n    }\r\n\r\n    /// @dev Called to allocate the tokens for presale address.\r\n    function presaleAllocateTokens()\r\n        external\r\n        checkAllowed\r\n    {\r\n        require(!presaleAllocated);\r\n        presaleAllocated = true;\r\n\r\n        // Mint the respective tokens to the contributor\r\n        token.mint(presaleAddress, PRESALE_WEI.mul(DECIMALS_MULTIPLIER).div(weiPerDTH));\r\n    }\r\n\r\n    function contribute()\r\n        public\r\n        payable\r\n        checkAllowed\r\n    {\r\n        require(msg.value >= MIN_CONTRIBUTION);\r\n\r\n        super.contribute();\r\n    }\r\n\r\n    /// @dev The limit will be different for every address during the whitelist period, and after that phase there is no limit for contributions.\r\n    function getContributionLimit(address userAddress) public view returns (uint256) {\r\n        uint256 saleStartTime = getStageStartTime(SALE_IN_PROGRESS);\r\n\r\n        // If not whitelisted or sale has not started, return 0\r\n        if (!whitelisted[userAddress] || block.timestamp < saleStartTime) {\r\n            return 0;\r\n        }\r\n\r\n        // Are we in the first two days?\r\n        bool whitelistingPeriod = block.timestamp - saleStartTime <= WHITELISTING_DURATION;\r\n\r\n        // If we are in the whitelisting period, return the contribution limit for the user\r\n        // If not, return the public max contribution\r\n        return whitelistingPeriod ? presaleMaxContribution[userAddress] : PUBLIC_MAX_CONTRIBUTION;\r\n    }\r\n\r\n    function createTokenContract() internal returns(MintableToken) {\r\n        return new DetherToken();\r\n    }\r\n\r\n    function setupStages() internal {\r\n        super.setupStages();\r\n        state.allowFunction(SETUP, this.performInitialAllocations.selector);\r\n        state.allowFunction(SALE_ENDED, this.allocateTokens.selector);\r\n        state.allowFunction(SALE_ENDED, this.presaleAllocateTokens.selector);\r\n    }\r\n\r\n    /// @dev The price will be the total wei contributed divided by the amount of tokens to be allocated to contributors.\r\n    function calculatePrice() public view returns(uint256) {\r\n        return weiContributed.add(PRESALE_WEI).div(60000000).add(1);\r\n    }\r\n\r\n    function onSaleEnded() internal {\r\n        // Calculate DTH per Wei\r\n        weiPerDTH = calculatePrice();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"DetherToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://31679c746f39dbdd5c090cd5514df308ef9098903284459826a5c4f30a8510bd"}]}