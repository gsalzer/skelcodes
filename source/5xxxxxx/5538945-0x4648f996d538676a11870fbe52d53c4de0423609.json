{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Allows EDG token holders to lend the Edgeless Casino tokens for the bankroll.\r\n * Users may pay in their tokens at any time, but they will only be used for the bankroll\r\n * begining from the next cycle. When the cycle is closed (at the end of the month), they may\r\n * withdraw their stake of the bankroll. The casino may decide to limit the number of tokens\r\n * used for the bankroll. The user will be able to withdraw the remaining tokens along with the\r\n * bankroll tokens once per cycle.\r\n * author: Julia Altenried\r\n * */\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract Token {\r\n  function transfer(address receiver, uint amount) public returns(bool);\r\n  function transferFrom(address sender, address receiver, uint amount) public returns(bool);\r\n  function balanceOf(address holder) public view returns(uint);\r\n}\r\n\r\ncontract Casino {\r\n  mapping(address => bool) public authorized;\r\n}\r\n\r\ncontract Owned {\r\n  address public owner;\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function Owned() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function changeOwner(address newOwner) onlyOwner public {\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract SafeMath {\r\n\r\n\tfunction safeSub(uint a, uint b) pure internal returns(uint) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction safeAdd(uint a, uint b) pure internal returns(uint) {\r\n\t\tuint c = a + b;\r\n\t\tassert(c >= a && c >= b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction safeMul(uint a, uint b) pure internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract BankrollLending is Owned, SafeMath {\r\n  /** The set of lending contracts state phases **/\r\n  enum StatePhases { deposit, bankroll, update, withdraw }\r\n  /** The number of the current cycle. Increases by 1 each month.**/\r\n  uint public cycle;\r\n  /** The address of the casino contract.**/\r\n  Casino public casino;\r\n  /** The Edgeless casino token contract **/\r\n  Token public token;\r\n  /** The sum of the initial stakes per cycle **/\r\n  mapping(uint => uint) public initialStakes;\r\n  /** The sum of the final stakes per cycle **/\r\n  mapping(uint => uint) public finalStakes;\r\n  /** The sum of the user stakes currently on the contract **/\r\n  uint public totalStakes; //note: uint is enough because the Edgeless Token Contract has 0 decimals and a total supply of 132,046,997 EDG\r\n  /** the number of stake holders **/\r\n  uint public numHolders;\r\n  /** List of all stakeholders **/\r\n  address[] public stakeholders;\r\n  /** Stake per user address **/\r\n  mapping(address => uint) public stakes;\r\n  /** the gas cost if the casino helps the user with the deposit in full EDG **/\r\n  uint8 public depositGasCost;\r\n  /** the gas cost if the casino helps the user with the withdrawal in full EDG **/\r\n  uint8 public withdrawGasCost;\r\n  /** the gas cost for balance update at the end of the cycle per user in EDG with 2 decimals\r\n  * (updates are made for all users at once, so it's possible to subtract all gas costs from the paid back tokens before\r\n  * setting the final stakes of the cycle.) **/\r\n  uint public updateGasCost;\r\n  /** The minimum staking amount required **/\r\n  uint public minStakingAmount;\r\n  /** The maximum number of addresses to process in one batch of stake updates **/\r\n  uint public maxUpdates; \r\n  /** The maximum number of addresses that can be assigned in one batch **/\r\n  uint public maxBatchAssignment;\r\n  /** remembers the last index updated per cycle **/\r\n  mapping(uint => uint) lastUpdateIndex;\r\n  /** notifies listeners about a stake update **/\r\n  event StakeUpdate(address holder, uint stake);\r\n\r\n  /**\r\n   * Constructor.\r\n   * @param tokenAddr the address of the edgeless token contract\r\n   *        casinoAddr the address of the edgeless casino contract\r\n   * */\r\n  function BankrollLending(address tokenAddr, address casinoAddr) public {\r\n    token = Token(tokenAddr);\r\n    casino = Casino(casinoAddr);\r\n    maxUpdates = 200;\r\n    maxBatchAssignment = 200;\r\n    cycle = 1;\r\n  }\r\n\r\n  /**\r\n   * Sets the casino contract address.\r\n   * @param casinoAddr the new casino contract address\r\n   * */\r\n  function setCasinoAddress(address casinoAddr) public onlyOwner {\r\n    casino = Casino(casinoAddr);\r\n  }\r\n\r\n  /**\r\n   * Sets the deposit gas cost.\r\n   * @param gasCost the new deposit gas cost\r\n   * */\r\n  function setDepositGasCost(uint8 gasCost) public onlyAuthorized {\r\n    depositGasCost = gasCost;\r\n  }\r\n\r\n  /**\r\n   * Sets the withdraw gas cost.\r\n   * @param gasCost the new withdraw gas cost\r\n   * */\r\n  function setWithdrawGasCost(uint8 gasCost) public onlyAuthorized {\r\n    withdrawGasCost = gasCost;\r\n  }\r\n\r\n  /**\r\n   * Sets the update gas cost.\r\n   * @param gasCost the new update gas cost\r\n   * */\r\n  function setUpdateGasCost(uint gasCost) public onlyAuthorized {\r\n    updateGasCost = gasCost;\r\n  }\r\n  \r\n  /**\r\n   * Sets the maximum number of user stakes to update at once\r\n   * @param newMax the new maximum\r\n   * */\r\n  function setMaxUpdates(uint newMax) public onlyAuthorized{\r\n    maxUpdates = newMax;\r\n  }\r\n  \r\n  /**\r\n   * Sets the minimum amount of user stakes\r\n   * @param amount the new minimum\r\n   * */\r\n  function setMinStakingAmount(uint amount) public onlyAuthorized {\r\n    minStakingAmount = amount;\r\n  }\r\n  \r\n  /**\r\n   * Sets the maximum number of addresses that can be assigned at once\r\n   * @param newMax the new maximum\r\n   * */\r\n  function setMaxBatchAssignment(uint newMax) public onlyAuthorized {\r\n    maxBatchAssignment = newMax;\r\n  }\r\n  \r\n  /**\r\n   * Allows the user to deposit funds, where the sender address and max allowed value have to be signed together with the cycle\r\n   * number by the casino. The method verifies the signature and makes sure, the deposit was made in time, before updating\r\n   * the storage variables.\r\n   * @param value the number of tokens to deposit\r\n   *        allowedMax the maximum deposit allowed this cycle\r\n   *        v, r, s the signature of an authorized casino wallet\r\n   * */\r\n  function deposit(uint value, uint allowedMax, uint8 v, bytes32 r, bytes32 s) public depositPhase {\r\n    require(verifySignature(msg.sender, allowedMax, v, r, s));\r\n    if (addDeposit(msg.sender, value, numHolders, allowedMax))\r\n      numHolders = safeAdd(numHolders, 1);\r\n    totalStakes = safeSub(safeAdd(totalStakes, value), depositGasCost);\r\n  }\r\n\r\n  /**\r\n   * Allows an authorized casino wallet to assign some tokens held by the lending contract to the given addresses.\r\n   * Only allows to assign token which do not already belong to any other user.\r\n   * Caller needs to make sure that the number of assignments can be processed in a single batch!\r\n   * @param to array containing the addresses of the holders\r\n   *        value array containing the number of tokens per address\r\n   * */\r\n  function batchAssignment(address[] to, uint[] value) public onlyAuthorized depositPhase {\r\n    require(to.length == value.length);\r\n    require(to.length <= maxBatchAssignment);\r\n    uint newTotalStakes = totalStakes;\r\n    uint numSH = numHolders;\r\n    for (uint8 i = 0; i < to.length; i++) {\r\n      newTotalStakes = safeSub(safeAdd(newTotalStakes, value[i]), depositGasCost);\r\n      if(addDeposit(to[i], value[i], numSH, 0))\r\n        numSH = safeAdd(numSH, 1);//save gas costs by increasing a memory variable instead of the storage variable per iteration\r\n    }\r\n    numHolders = numSH;\r\n    //rollback if more tokens have been assigned than the contract possesses\r\n    assert(newTotalStakes < tokenBalance());\r\n    totalStakes = newTotalStakes;\r\n  }\r\n  \r\n  /**\r\n   * updates the stake of an address.\r\n   * @param to the address\r\n   *        value the value to add to the stake\r\n   *        numSH the number of stakeholders\r\n   *        allowedMax the maximum amount a user may stake (0 in case the casino is making the assignment)\r\n   * */\r\n  function addDeposit(address to, uint value, uint numSH, uint allowedMax) internal returns (bool newHolder) {\r\n    require(value > 0);\r\n    uint newStake = safeSub(safeAdd(stakes[to], value), depositGasCost);\r\n    require(newStake >= minStakingAmount);\r\n    if(allowedMax > 0){//if allowedMax > 0 the caller is the user himself\r\n      require(newStake <= allowedMax);\r\n      assert(token.transferFrom(to, address(this), value));\r\n    }\r\n    if(stakes[to] == 0){\r\n      addHolder(to, numSH);\r\n      newHolder = true;\r\n    }\r\n    stakes[to] = newStake;\r\n    emit StakeUpdate(to, newStake);\r\n  }\r\n\r\n  /**\r\n   * Transfers the total stakes to the casino contract to be used as bankroll.\r\n   * Callabe only once per cycle and only after a cycle was started.\r\n   * */\r\n  function useAsBankroll() public onlyAuthorized depositPhase {\r\n    initialStakes[cycle] = totalStakes;\r\n    totalStakes = 0; //withdrawals are unlocked until this value is > 0 again and the final stakes have been set\r\n    assert(token.transfer(address(casino), initialStakes[cycle]));\r\n  }\r\n\r\n  /**\r\n   * Initiates the next cycle. Callabe only once per cycle and only after the last one was closed.\r\n   * */\r\n  function startNextCycle() public onlyAuthorized {\r\n    // make sure the last cycle was closed, can be called in update or withdraw phase\r\n    require(finalStakes[cycle] > 0);\r\n    cycle = safeAdd(cycle, 1);\r\n  }\r\n\r\n  /**\r\n   * Sets the final sum of user stakes for history and profit computation. Callable only once per cycle.\r\n   * The token balance of the contract may not be set as final stake, because there might have occurred unapproved deposits.\r\n   * @param value the number of EDG tokens that were transfered from the bankroll\r\n   * */\r\n  function closeCycle(uint value) public onlyAuthorized bankrollPhase {\r\n    require(tokenBalance() >= value);\r\n    finalStakes[cycle] = safeSub(value, safeMul(updateGasCost, numHolders)/100);//updateGasCost is using 2 decimals\r\n  }\r\n\r\n  /**\r\n   * Updates the user shares depending on the difference between final and initial stake.\r\n   * For doing so, it iterates over the array of stakeholders, while it processes max 500 addresses at once.\r\n   * If the array length is bigger than that, the contract remembers the position to start with on the next invocation.\r\n   * Therefore, this method might need to be called multiple times.\r\n   * It does consider the gas costs and subtracts them from the final stakes before computing the profit/loss.\r\n   * As soon as the last stake has been updated, withdrawals are unlocked by setting the totalStakes to the height of final stakes of the cycle.\r\n   * */\r\n  function updateUserShares() public onlyAuthorized updatePhase {\r\n    uint limit = safeAdd(lastUpdateIndex[cycle], maxUpdates);\r\n    if(limit >= numHolders) {\r\n      limit = numHolders;\r\n      totalStakes = finalStakes[cycle]; //enable withdrawals after this method call was processed\r\n      if (cycle > 1) {\r\n        lastUpdateIndex[cycle - 1] = 0;\r\n      }\r\n    }\r\n    address holder;\r\n    uint newStake;\r\n    for(uint i = lastUpdateIndex[cycle]; i < limit; i++){\r\n      holder = stakeholders[i];\r\n      newStake = computeFinalStake(stakes[holder]);\r\n      stakes[holder] = newStake;\r\n      emit StakeUpdate(holder, newStake);\r\n    }\r\n    lastUpdateIndex[cycle] = limit;\r\n  }\r\n\r\n  /**\r\n  * In case something goes wrong above, enable the users to withdraw their tokens.\r\n  * Should never be necessary.\r\n  * @param value the number of tokens to release\r\n  **/\r\n  function unlockWithdrawals(uint value) public onlyOwner {\r\n    require(value <= tokenBalance());\r\n    totalStakes = value;\r\n  }\r\n\r\n  /**\r\n   * If withdrawals are unlocked (final stakes of the cycle > 0 and totalStakes > 0), this function withdraws tokens from the sender’s balance to\r\n   * the specified address. If no balance remains, the user is removed from the stakeholder array.\r\n   * @param to the receiver\r\n   *        value the number of tokens\r\n   *        index the index of the message sender in the stakeholder array (save gas costs by not looking it up on the contract)\r\n   * */\r\n  function withdraw(address to, uint value, uint index) public withdrawPhase{\r\n    makeWithdrawal(msg.sender, to, value, index);\r\n  }\r\n\r\n  /**\r\n   * An authorized casino wallet may use this function to make a withdrawal for the user.\r\n   * The value is subtracted from the signer’s balance and transferred to the specified address.\r\n   * If no balance remains, the signer is removed from the stakeholder array.\r\n   * @param to the receiver\r\n   *        value the number of tokens\r\n   *        index the index of the signer in the stakeholder array (save gas costs by not looking it up on the contract)\r\n   *        v, r, s the signature of the stakeholder\r\n   * */\r\n  function withdrawFor(address to, uint value, uint index, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized withdrawPhase{\r\n    address from = ecrecover(keccak256(to, value, cycle), v, r, s);\r\n    makeWithdrawal(from, to, value, index);\r\n  }\r\n  \r\n  /**\r\n   * internal method for processing the withdrawal.\r\n   * @param from the stakeholder\r\n   *        to the receiver\r\n   *        value the number of tokens\r\n   *        index the index of the message sender in the stakeholder array (save gas costs by not looking it up on the contract)\r\n   * */\r\n  function makeWithdrawal(address from, address to, uint value, uint index) internal{\r\n    if(value == stakes[from]){\r\n      stakes[from] = 0;\r\n      removeHolder(from, index);\r\n      emit StakeUpdate(from, 0);\r\n    }\r\n    else{\r\n      uint newStake = safeSub(stakes[from], value);\r\n      require(newStake >= minStakingAmount);\r\n      stakes[from] = newStake;\r\n      emit StakeUpdate(from, newStake);\r\n    }\r\n    totalStakes = safeSub(totalStakes, value);\r\n    assert(token.transfer(to, safeSub(value, withdrawGasCost)));\r\n  }\r\n\r\n  /**\r\n   * Allows the casino to withdraw tokens which do not belong to any stakeholder.\r\n   * This is the case for gas-payback-tokens and if people send their tokens directly to the contract\r\n   * without the approval of the casino.\r\n   * */\r\n  function withdrawExcess() public onlyAuthorized {\r\n    uint value = safeSub(tokenBalance(), totalStakes);\r\n    token.transfer(owner, value);\r\n  }\r\n\r\n  /**\r\n   * Closes the contract in state of emergency or on contract update.\r\n   * Transfers all tokens held by the contract to the owner before doing so.\r\n   **/\r\n  function kill() public onlyOwner {\r\n    assert(token.transfer(owner, tokenBalance()));\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  /**\r\n   * @return the current token balance of the contract.\r\n   * */\r\n  function tokenBalance() public view returns(uint) {\r\n    return token.balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n  * Adds a new stakeholder to the list.\r\n  * @param holder the address of the stakeholder\r\n  *        numSH  the current number of stakeholders\r\n  **/\r\n  function addHolder(address holder, uint numSH) internal{\r\n    if(numSH < stakeholders.length)\r\n      stakeholders[numSH] = holder;\r\n    else\r\n      stakeholders.push(holder);\r\n  }\r\n  \r\n  /**\r\n  * Removes a stakeholder from the list.\r\n  * @param holder the address of the stakeholder\r\n  *        index  the index of the holder\r\n  **/\r\n  function removeHolder(address holder, uint index) internal{\r\n    require(stakeholders[index] == holder);\r\n    numHolders = safeSub(numHolders, 1);\r\n    stakeholders[index] = stakeholders[numHolders];\r\n  }\r\n\r\n  /**\r\n   * computes the final stake.\r\n   * @param initialStake the initial number of tokens the user invested\r\n   * @return finalStake  the final number of tokens the user receives\r\n   * */\r\n  function computeFinalStake(uint initialStake) internal view returns(uint) {\r\n    return safeMul(initialStake, finalStakes[cycle]) / initialStakes[cycle];\r\n  }\r\n\r\n  /**\r\n   * verifies if the withdrawal request was signed by an authorized wallet\r\n   * @param to      the receiver address\r\n   *        value   the number of tokens\r\n   *        v, r, s the signature of an authorized wallet\r\n   * */\r\n  function verifySignature(address to, uint value, uint8 v, bytes32 r, bytes32 s) internal view returns(bool) {\r\n    address signer = ecrecover(keccak256(to, value, cycle), v, r, s);\r\n    return casino.authorized(signer);\r\n  }\r\n\r\n  /**\r\n   * computes state based on the initial, total and final stakes of the current cycle.\r\n   * @return current state phase\r\n   * */\r\n  function getPhase() internal view returns (StatePhases) {\r\n    if (initialStakes[cycle] == 0) {\r\n      return StatePhases.deposit;\r\n    } else if (finalStakes[cycle] == 0) {\r\n      return StatePhases.bankroll;\r\n    } else if (totalStakes == 0) {\r\n      return StatePhases.update;\r\n    }\r\n    return StatePhases.withdraw;\r\n  }\r\n  \r\n  //check if the sender is an authorized casino wallet\r\n  modifier onlyAuthorized {\r\n    require(casino.authorized(msg.sender));\r\n    _;\r\n  }\r\n\r\n  // deposit phase: initialStakes[cycle] == 0\r\n  modifier depositPhase {\r\n    require(getPhase() == StatePhases.deposit);\r\n    _;\r\n  }\r\n\r\n  // bankroll phase: initialStakes[cycle] > 0 and finalStakes[cycle] == 0\r\n  modifier bankrollPhase {\r\n    require(getPhase() == StatePhases.bankroll);\r\n    _;\r\n  }\r\n\r\n  // update phase: finalStakes[cycle] > 0 and totalStakes == 0\r\n  modifier updatePhase {\r\n    require(getPhase() == StatePhases.update);\r\n    _;\r\n  }\r\n\r\n  // withdraw phase: finalStakes[cycle] > 0 and totalStakes > 0\r\n  modifier withdrawPhase {\r\n    require(getPhase() == StatePhases.withdraw);\r\n    _;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeholders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minStakingAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateUserShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address[]\"},{\"name\":\"value\",\"type\":\"uint256[]\"}],\"name\":\"batchAssignment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"closeCycle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNextCycle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"setUpdateGasCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinStakingAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"updateGasCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"finalStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"unlockWithdrawals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxUpdates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"allowedMax\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaxUpdates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"casino\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawGasCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBatchAssignment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawExcess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasCost\",\"type\":\"uint8\"}],\"name\":\"setDepositGasCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasCost\",\"type\":\"uint8\"}],\"name\":\"setWithdrawGasCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositGasCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initialStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaxBatchAssignment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"useAsBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"casinoAddr\",\"type\":\"address\"}],\"name\":\"setCasinoAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"casinoAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"StakeUpdate\",\"type\":\"event\"}]","ContractName":"BankrollLending","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000008711d3b02c8758f2fb3ab4e80228418a7f8e39c0000000000000000000000006ba29728e955ff970c94d7ab0a4ff17c628f325a","Library":"","SwarmSource":"bzzr://44c203e5c12e58a71a24443ef146de3911b82c19df583ff802027dc63125f7e9"}]}