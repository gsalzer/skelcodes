{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract CrowdsaleParameters {\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Production Config\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    // ICO period timestamps:\r\n    // 1524182400 = April 20, 2018.\r\n    // 1529452800 = June 20, 2018.\r\n\r\n    uint256 public constant generalSaleStartDate = 1524182400;\r\n    uint256 public constant generalSaleEndDate = 1529452800;\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // QA Config\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Configuration Independent Parameters\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    struct AddressTokenAllocation {\r\n        address addr;\r\n        uint256 amount;\r\n    }\r\n\r\n    AddressTokenAllocation internal generalSaleWallet = AddressTokenAllocation(0x5aCdaeF4fa410F38bC26003d0F441d99BB19265A, 22800000);\r\n    AddressTokenAllocation internal bounty = AddressTokenAllocation(0xc1C77Ff863bdE913DD53fD6cfE2c68Dfd5AE4f7F, 2000000);\r\n    AddressTokenAllocation internal partners = AddressTokenAllocation(0x307744026f34015111B04ea4D3A8dB9FdA2650bb, 3200000);\r\n    AddressTokenAllocation internal team = AddressTokenAllocation(0xCC4271d219a2c33a92aAcB4C8D010e9FBf664D1c, 12000000);\r\n    AddressTokenAllocation internal featureDevelopment = AddressTokenAllocation(0x06281A31e1FfaC1d3877b29150bdBE93073E043B, 0);\r\n}\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Sets contract owner to address of constructor caller\r\n    */\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  Change Owner\r\n    *\r\n    *  Changes ownership of this contract. Only owner can call this method.\r\n    *\r\n    * @param newOwner - new owner's address\r\n    */\r\n    function changeOwner(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        require(newOwner != owner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract SBIToken is Owned, CrowdsaleParameters {\r\n    using SafeMath for uint256;\r\n    /* Public variables of the token */\r\n    string public standard = 'ERC20/SBI';\r\n    string public name = 'Subsoil Blockchain Investitions';\r\n    string public symbol = 'SBI';\r\n    uint8 public decimals = 18;\r\n\r\n    /* Arrays of all balances */\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    mapping (address => mapping (address => bool)) private allowanceUsed;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Issuance(uint256 _amount); // triggered when the total supply is increased\r\n    event Destruction(uint256 _amount); // triggered when the total supply is decreased\r\n\r\n    event NewSBIToken(address _token);\r\n\r\n    /* Miscellaneous */\r\n    uint256 public totalSupply = 0; // 40000000;\r\n    bool public transfersEnabled = true;\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Initializes contract with initial supply tokens to the creator of the contract\r\n    */\r\n\r\n    function SBIToken() public {\r\n        owner = msg.sender;\r\n        mintToken(generalSaleWallet);\r\n        mintToken(bounty);\r\n        mintToken(partners);\r\n        mintToken(team);\r\n        emit NewSBIToken(address(this));\r\n    }\r\n\r\n    modifier transfersAllowed {\r\n        require(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  1. Associate crowdsale contract address with this Token\r\n    *  2. Allocate general sale amount\r\n    *\r\n    * @param _crowdsaleAddress - crowdsale contract address\r\n    */\r\n    function approveCrowdsale(address _crowdsaleAddress) external onlyOwner {\r\n        approveAllocation(generalSaleWallet, _crowdsaleAddress);\r\n    }\r\n\r\n    function approveAllocation(AddressTokenAllocation tokenAllocation, address _crowdsaleAddress) internal {\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint amount = tokenAllocation.amount * exponent;\r\n\r\n        allowed[tokenAllocation.addr][_crowdsaleAddress] = amount;\r\n        emit Approval(tokenAllocation.addr, _crowdsaleAddress, amount);\r\n    }\r\n\r\n    /**\r\n    *  Get token balance of an address\r\n    *\r\n    * @param _address - address to query\r\n    * @return Token balance of _address\r\n    */\r\n    function balanceOf(address _address) public constant returns (uint256 balance) {\r\n        return balances[_address];\r\n    }\r\n\r\n    /**\r\n    *  Get token amount allocated for a transaction from _owner to _spender addresses\r\n    *\r\n    * @param _owner - owner address, i.e. address to transfer from\r\n    * @param _spender - spender address, i.e. address to transfer to\r\n    * @return Remaining amount allowed to be transferred\r\n    */\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    *  Send coins from sender's address to address specified in parameters\r\n    *\r\n    * @param _to - address to send to\r\n    * @param _value - amount to send in Wei\r\n    */\r\n\r\n    function transfer(address _to, uint256 _value) public transfersAllowed onlyPayloadSize(2*32) returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Create token and credit it to target address\r\n    *  Created tokens need to vest\r\n    *\r\n    */\r\n    function mintToken(AddressTokenAllocation tokenAllocation) internal {\r\n\r\n        uint uintDecimals = decimals;\r\n        uint exponent = 10**uintDecimals;\r\n        uint mintedAmount = tokenAllocation.amount * exponent;\r\n\r\n        // Mint happens right here: Balance becomes non-zero from zero\r\n        balances[tokenAllocation.addr] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n\r\n        // Emit Issue and Transfer events\r\n        emit Issuance(mintedAmount);\r\n        emit Transfer(address(this), tokenAllocation.addr, mintedAmount);\r\n    }\r\n\r\n    /**\r\n    *  Allow another contract to spend some tokens on your behalf\r\n    *\r\n    * @param _spender - address to allocate tokens for\r\n    * @param _value - number of tokens to allocate\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {\r\n        require(_value == 0 || allowanceUsed[msg.sender][_spender] == false);\r\n        allowed[msg.sender][_spender] = _value;\r\n        allowanceUsed[msg.sender][_spender] = false;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  A contract attempts to get the coins. Tokens should be previously allocated\r\n    *\r\n    * @param _to - address to transfer tokens to\r\n    * @param _from - address to transfer tokens from\r\n    * @param _value - number of tokens to transfer\r\n    * @return True in case of success, otherwise false\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed onlyPayloadSize(3*32) returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *  Default method\r\n    *\r\n    *  This unnamed function is called whenever someone tries to send ether to\r\n    *  it. Just revert transaction because there is nothing that Token can do\r\n    *  with incoming ether.\r\n    *\r\n    *  Missing payable modifier prevents accidental sending of ether\r\n    */\r\n    function() public {}\r\n\r\n    /**\r\n    *  Enable or disable transfers\r\n    *\r\n    * @param _enable - True = enable, False = disable\r\n    */\r\n    function toggleTransfers(bool _enable) external onlyOwner {\r\n        transfersEnabled = _enable;\r\n    }\r\n}\r\n\r\ncontract SBITokenCrowdsale is Owned, CrowdsaleParameters {\r\n    using SafeMath for uint256;\r\n    string public name = 'Subsoil Blockchain Investitions Crowdsale';\r\n    /* Token and records */\r\n    SBIToken private token;\r\n    address public bank;\r\n    address saleWalletAddress;\r\n    uint private tokenMultiplier = 10;\r\n    uint public totalCollected = 0;\r\n    uint public saleStartTimestamp;\r\n    uint public saleStopTimestamp;\r\n    uint public saleGoal;\r\n    bool public goalReached = false;\r\n    uint public preicoTokensPerEth = 27314;\r\n    uint public tokensPerEth = 10500;\r\n    mapping (address => uint256) private investmentRecords;\r\n    address crowdsaleAddress = this;\r\n    uint256 public constant saleStartDate = 1530403200;\r\n    uint256 public constant saleEndDate = 1535759940;\r\n    uint256 public constant preSaleStartDate = 1529020800;\r\n    uint256 public constant preSaleEndDate = 1530403140;\r\n    uint public preSaleAmount = 5800000;\r\n\r\n    /* Events */\r\n    event TokenSale(address indexed tokenReceiver, uint indexed etherAmount, uint indexed tokenAmount, uint tokensPerEther);\r\n    event FundTransfer(address indexed from, address indexed to, uint indexed amount);\r\n\r\n    /**\r\n    * Constructor\r\n    *\r\n    * @param _tokenAddress - address of token (deployed before this contract)\r\n    */\r\n    function SBITokenCrowdsale(address _tokenAddress, address _bankAddress) public {\r\n        token = SBIToken(_tokenAddress);\r\n        bank = _bankAddress;\r\n        tokenMultiplier = tokenMultiplier ** token.decimals();\r\n        saleWalletAddress = generalSaleWallet.addr;\r\n        // Initialize sale goal\r\n        saleGoal = generalSaleWallet.amount;\r\n    }\r\n\r\n    /**\r\n    * Is sale active\r\n    *\r\n    * @return active - True, if sale is active\r\n    */\r\n    function isICOActive() public constant returns (bool active) {\r\n        active = ((preSaleStartDate <= now) && (now <= saleEndDate) && (!goalReached));\r\n        return active;\r\n    }\r\n\r\n    /*\r\n        eth rate is very volatile\r\n    */\r\n    function setTokenRate(uint rate) public onlyOwner {\r\n        tokensPerEth = rate;\r\n    }\r\n\r\n    /**\r\n    *  Process received payment\r\n    *\r\n    *  Determine the integer number of tokens that was purchased considering current\r\n    *  stage, tier bonus, and remaining amount of tokens in the sale wallet.\r\n    *  Transfer purchased tokens to investorAddress and return unused portion of\r\n    *  ether (change)\r\n    *\r\n    * @param investorAddress - address that ether was sent from\r\n    * @param amount - amount of Wei received\r\n    */\r\n    function processPayment(address investorAddress, uint amount) internal {\r\n        require(isICOActive());\r\n        assert(msg.value > 0 finney);\r\n\r\n        // Fund transfer event\r\n        emit FundTransfer(investorAddress, address(this), amount);\r\n        uint remainingTokenBalance = token.balanceOf(saleWalletAddress) / tokenMultiplier;\r\n\r\n        // Calculate token amount that is purchased,\r\n        // truncate to integer\r\n\r\n        uint tokensRate = 0;\r\n        uint tokenAmount = 0;\r\n        uint acceptedAmount = 0;\r\n        uint mainTokens = 0;\r\n        uint discountTokens = 0;\r\n\r\n        if (preSaleStartDate <= now && now <= preSaleEndDate && remainingTokenBalance > 17000000) {\r\n          tokensRate = preicoTokensPerEth;\r\n          discountTokens = remainingTokenBalance - 17000000;\r\n\r\n          uint acceptedPreicoAmount = discountTokens * 1e18 / preicoTokensPerEth; // 212\r\n          uint acceptedMainAmount = 17000000 * 1e18 / tokensPerEth; // 1619\r\n          acceptedAmount = acceptedPreicoAmount + acceptedMainAmount;\r\n\r\n          if (acceptedPreicoAmount < amount) {\r\n            mainTokens = (amount - acceptedPreicoAmount) * tokensPerEth / 1e18;\r\n            tokenAmount = discountTokens + mainTokens;\r\n          } else {\r\n            tokenAmount = preicoTokensPerEth * amount / 1e18;\r\n          }\r\n\r\n        } else {\r\n          tokensRate = tokensPerEth;\r\n          tokenAmount = amount * tokensPerEth / 1e18;\r\n          acceptedAmount = remainingTokenBalance * tokensPerEth * 1e18;\r\n        }\r\n\r\n        // Check that stage wallet has enough tokens. If not, sell the rest and\r\n        // return change.\r\n        if (remainingTokenBalance <= tokenAmount) {\r\n            tokenAmount = remainingTokenBalance;\r\n            goalReached = true;\r\n        }\r\n\r\n        // Transfer tokens to baker and return ETH change\r\n        token.transferFrom(saleWalletAddress, investorAddress, tokenAmount * tokenMultiplier);\r\n        emit TokenSale(investorAddress, amount, tokenAmount, tokensRate);\r\n\r\n        // Return change\r\n        if (amount > acceptedAmount) {\r\n            uint change = amount - acceptedAmount;\r\n            investorAddress.transfer(change);\r\n            emit FundTransfer(address(this), investorAddress, change);\r\n        }\r\n\r\n        // Update crowdsale performance\r\n        investmentRecords[investorAddress] += acceptedAmount;\r\n        totalCollected += acceptedAmount;\r\n    }\r\n\r\n    /**\r\n    *  Transfer ETH amount from contract to bank's address.\r\n    */\r\n    function safeWithdrawal() external onlyOwner {\r\n        bank.transfer(crowdsaleAddress.balance);\r\n        emit FundTransfer(crowdsaleAddress, bank, crowdsaleAddress.balance);\r\n    }\r\n\r\n    /**\r\n    *  Default method\r\n    *\r\n    *  Processes all ETH that it receives and credits SBI tokens to sender\r\n    *  according to current stage bonus\r\n    */\r\n    function () external payable {\r\n        processPayment(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n    *  Kill method\r\n    *\r\n    *  Destructs this contract\r\n    */\r\n    function kill() external onlyOwner {\r\n        require(!isICOActive());\r\n        if (crowdsaleAddress.balance > 0) {\r\n            revert();\r\n        }\r\n        if (now < preSaleStartDate) {\r\n            selfdestruct(owner);\r\n        }\r\n        // save the not sold tokens to featureDevelopment wallet\r\n        uint featureDevelopmentAmount = token.balanceOf(saleWalletAddress);\r\n        // Transfer tokens to baker and return ETH change\r\n        token.transferFrom(saleWalletAddress, featureDevelopment.addr, featureDevelopmentAmount);\r\n        emit FundTransfer(crowdsaleAddress, msg.sender, crowdsaleAddress.balance);\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStopTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalSaleEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStartTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setTokenRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generalSaleStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isICOActive\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preicoTokensPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_bankAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenReceiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensPerEther\",\"type\":\"uint256\"}],\"name\":\"TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SBITokenCrowdsale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f47fcf487177a1f39c4c4f26da5cf762d02bf2ca00000000000000000000000028ac77611bf3ae7b776ac7ecd79119d3c161574d","Library":"","SwarmSource":"bzzr://2edf955fa20e8b59866856134c6f7d8f2bbc3df8724cd83bb6b64135420f1601"}]}