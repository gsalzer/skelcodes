{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract EtherTower {\r\n  using SafeMath for uint256;\r\n\r\n  // Contract owner address\r\n  address public owner;\r\n\r\n  // Game constants\r\n  uint256 private constant TOWER_BOSS_TOKEN_ID = 0;\r\n  uint256 private constant APARTMENT_MANAGER_ID = 1;\r\n  uint256 private constant HOTEL_MANAGER_ID = 2;\r\n  uint256 private constant CONDO_MANAGER_ID = 3;\r\n\r\n  uint256 private constant BOTTOM_FLOOR_ID = 4;\r\n  uint256 private constant APARTMENT_INDEX_MIN = 4;\r\n  uint256 private constant APARTMENT_INDEX_MAX = 9;\r\n  uint256 private constant HOTEL_INDEX_MIN = 10;\r\n  uint256 private constant HOTEL_INDEX_MAX = 15;\r\n  uint256 private constant CONDO_INDEX_MIN = 16;\r\n  uint256 private constant CONDO_INDEX_MAX = 21;\r\n\r\n  uint256 private firstStepLimit = 0.04 ether;\r\n  uint256 private secondStepLimit = 0.2 ether;\r\n\r\n  // Game start time\r\n  uint256 public gameStartTime = 1520647080;\r\n\r\n  // Tokens\r\n  struct Token {\r\n    uint256 price;\r\n    address owner;\r\n  }\r\n\r\n  mapping (uint256 => Token) public tokens;\r\n\r\n  // Player earnings\r\n  mapping (address => uint256) public earnings;\r\n\r\n  event TokenPurchased(\r\n    uint256 tokenId,\r\n    address oldOwner,\r\n    address newOwner,\r\n    uint256 oldPrice,\r\n    uint256 newPrice,\r\n    uint256 timestamp\r\n  );\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyGameStarted {\r\n    require(now >= gameStartTime);\r\n    _;\r\n  }\r\n\r\n  function EtherTower() public {\r\n    owner = msg.sender;\r\n    createToken(0, 2 ether); // Tower Boss\r\n    createToken(1, 0.5 ether); // Apartment Manager\r\n    createToken(2, 0.5 ether); // Hotel Manager\r\n    createToken(3, 0.5 ether); // Condo Manager\r\n\r\n    // Apartments\r\n    createToken(4, 0.05 ether);\r\n    createToken(5, 0.005 ether);\r\n    createToken(6, 0.005 ether);\r\n    createToken(7, 0.005 ether);\r\n    createToken(8, 0.005 ether);\r\n    createToken(9, 0.05 ether);\r\n\r\n    // Hotel\r\n    createToken(10, 0.05 ether);\r\n    createToken(11, 0.005 ether);\r\n    createToken(12, 0.005 ether);\r\n    createToken(13, 0.005 ether);\r\n    createToken(14, 0.005 ether);\r\n    createToken(15, 0.05 ether);\r\n\r\n    // Condos\r\n    createToken(16, 0.05 ether);\r\n    createToken(17, 0.005 ether);\r\n    createToken(18, 0.005 ether);\r\n    createToken(19, 0.005 ether);\r\n    createToken(20, 0.005 ether);\r\n    createToken(21, 0.1 ether); // Penthouse\r\n  }\r\n\r\n  // PUBLIC\r\n\r\n  function createToken(uint256 _tokenId, uint256 _startingPrice) public onlyOwner {\r\n    Token memory token = Token({\r\n      price: _startingPrice,\r\n      owner: owner\r\n    });\r\n\r\n    tokens[_tokenId] = token;\r\n  }\r\n\r\n  function getToken(uint256 _tokenId) public view returns (\r\n    uint256 _price,\r\n    uint256 _nextPrice,\r\n    address _owner\r\n  ) {\r\n    Token memory token = tokens[_tokenId];\r\n    _price = token.price;\r\n    _nextPrice = getNextPrice(token.price);\r\n    _owner = token.owner;\r\n  }\r\n\r\n  function setGameStartTime(uint256 _gameStartTime) public onlyOwner {\r\n    gameStartTime = _gameStartTime;\r\n  }\r\n\r\n  function purchase(uint256 _tokenId) public payable onlyGameStarted {\r\n    Token storage token = tokens[_tokenId];\r\n\r\n    // Value must be greater than or equal to the token price\r\n    require(msg.value >= token.price);\r\n\r\n    // Prevent user from buying their own token\r\n    require(msg.sender != token.owner);\r\n\r\n    uint256 purchaseExcess = msg.value.sub(token.price);\r\n\r\n    address newOwner = msg.sender;\r\n    address oldOwner = token.owner;\r\n\r\n    uint256 devCut = token.price.mul(4).div(100); // 4%\r\n    uint256 towerBossCut = token.price.mul(3).div(100); // 3%\r\n    uint256 managerCut = getManagerCut(_tokenId, token.price); // 0% - 3%\r\n    uint256 oldOwnerProfit = token.price.sub(devCut).sub(towerBossCut).sub(managerCut);\r\n\r\n    // Update token\r\n    uint256 oldPrice = token.price;\r\n    token.owner = newOwner;\r\n    token.price = getNextPrice(token.price);\r\n\r\n    // send funds to the dev\r\n    earnings[owner] = earnings[owner].add(devCut);\r\n\r\n    // send funds to the big boss\r\n    earnings[tokens[TOWER_BOSS_TOKEN_ID].owner] = earnings[tokens[TOWER_BOSS_TOKEN_ID].owner].add(towerBossCut);\r\n\r\n    // send funds to the manager (if applicable)\r\n    if (managerCut > 0) {\r\n      address managerAddress = getManagerAddress(_tokenId);\r\n      earnings[managerAddress] = earnings[managerAddress].add(managerCut);\r\n    }\r\n\r\n    // send profit to the previous owner\r\n    sendFunds(oldOwner, oldOwnerProfit);\r\n\r\n    // refund any excess to the sender\r\n    if (purchaseExcess > 0) {\r\n      sendFunds(newOwner, purchaseExcess);\r\n    }\r\n\r\n    TokenPurchased(_tokenId, oldOwner, newOwner, oldPrice, token.price, now);\r\n  }\r\n\r\n  function withdrawEarnings() public {\r\n    uint256 amount = earnings[msg.sender];\r\n    earnings[msg.sender] = 0;\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n  /// PRIVATE\r\n\r\n  /// @dev Managers only get a cut of floor sales\r\n  function getManagerCut(uint256 _tokenId, uint256 _price) private pure returns (uint256) {\r\n    if (_tokenId >= BOTTOM_FLOOR_ID) {\r\n      return _price.mul(3).div(100); // 3%\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function getManagerAddress(uint256 _tokenId) private view returns (address) {\r\n    if (_tokenId >= APARTMENT_INDEX_MIN && _tokenId <= APARTMENT_INDEX_MAX) {\r\n      return tokens[APARTMENT_MANAGER_ID].owner;\r\n    } else if (_tokenId >= HOTEL_INDEX_MIN && _tokenId <= HOTEL_INDEX_MAX) {\r\n      return tokens[HOTEL_MANAGER_ID].owner;\r\n    } else if (_tokenId >= CONDO_INDEX_MIN && _tokenId <= CONDO_INDEX_MAX) {\r\n      return tokens[CONDO_MANAGER_ID].owner;\r\n    } else {\r\n      // This should never happen\r\n      return owner;\r\n    }\r\n  }\r\n\r\n  function getNextPrice(uint256 _price) private view returns (uint256) {\r\n    if (_price <= firstStepLimit) {\r\n      return _price.mul(2); // increase by 100%\r\n    } else if (_price <= secondStepLimit) {\r\n      return _price.mul(125).div(100); // increase by 25%\r\n    } else {\r\n      return _price.mul(118).div(100); // increase by 18%\r\n    }\r\n  }\r\n\r\n  /**\r\n    * @dev Attempt to send the funds immediately.\r\n    * If that fails for any reason, force the user\r\n    * to manually withdraw.\r\n    */\r\n  function sendFunds(address _recipient, uint256 _amount) private {\r\n    if (!_recipient.send(_amount)) {\r\n      earnings[_recipient] = earnings[_recipient].add(_amount);\r\n    }\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"gameStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameStartTime\",\"type\":\"uint256\"}],\"name\":\"setGameStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"}],\"name\":\"createToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_nextPrice\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TokenPurchased\",\"type\":\"event\"}]","ContractName":"EtherTower","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://da2be84e3cc379eeb8caafc0386ddb0e72dd8e1d6a333470206067a15bf5ee08"}]}