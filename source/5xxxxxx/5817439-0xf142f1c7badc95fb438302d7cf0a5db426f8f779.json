{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\ncontract TripioToken {\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n}\r\n/**\r\n * Owned contract\r\n */\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Only the owner of contract\r\n     */ \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * transfer the ownership to other\r\n     * - Only the owner can operate\r\n     */ \r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /** \r\n     * Accept the ownership from last owner\r\n     */ \r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\ncontract TPTData {\r\n    address public trioContract;\r\n\r\n    struct Contributor {\r\n        uint256 next;\r\n        uint256 prev;\r\n        uint256 cid;\r\n        address contributor;\r\n        bytes32 name;\r\n    }\r\n    \r\n    struct ContributorChain {\r\n        uint256 balance;\r\n        uint256 head;\r\n        uint256 tail;\r\n        uint256 index;\r\n        mapping(uint256 => Contributor) nodes; // cid -> Contributor\r\n    }\r\n\r\n    struct Schedule {\r\n        uint256 next;\r\n        uint256 prev;\r\n        uint256 sid;\r\n        uint32 timestamp;\r\n        uint256 trio;\r\n    }\r\n\r\n    struct ScheduleChain {\r\n        uint256 balance;\r\n        uint256 head;\r\n        uint256 tail;\r\n        uint256 index;\r\n        mapping (uint256 => Schedule) nodes;\r\n    }\r\n\r\n    // The contributors chain\r\n    ContributorChain contributorChain;\r\n\r\n    // The schedules chains\r\n    mapping (uint256 => ScheduleChain) scheduleChains;\r\n\r\n    /**\r\n     * The contributor is valid\r\n     */\r\n    modifier contributorValid(uint256 _cid) {\r\n        require(contributorChain.nodes[_cid].cid == _cid);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * The schedule is valid\r\n     */\r\n    modifier scheduleValid(uint256 _cid, uint256 _sid) {\r\n        require(scheduleChains[_cid].nodes[_sid].sid == _sid);\r\n        _;\r\n    }\r\n}\r\ncontract TPTContributors is TPTData, Owned {\r\n    function TPTContributors() public {\r\n        \r\n    }\r\n\r\n    /**\r\n     * This emits when contributors are added\r\n     */\r\n    event ContributorsAdded(address[] indexed _contributors);\r\n\r\n    /**\r\n     * This emits when contributors are removed\r\n     */\r\n    event ContributorsRemoved(uint256[] indexed _cids);\r\n\r\n\r\n    /**\r\n     * Record `_contributor`\r\n     */\r\n    function _pushContributor(address _contributor, bytes32 _name) internal {\r\n        require(_contributor != address(0));\r\n        uint256 prev = 0;\r\n        uint256 cid = contributorChain.index + 1;\r\n        if (contributorChain.balance == 0) {\r\n            contributorChain = ContributorChain(1, cid, cid, cid);\r\n            contributorChain.nodes[cid] = Contributor(0, 0, cid, _contributor, _name);\r\n        } else {\r\n            contributorChain.index = cid;\r\n            prev = contributorChain.tail;\r\n            contributorChain.balance++;\r\n\r\n            contributorChain.nodes[cid] = Contributor(0, prev, cid, _contributor, _name);\r\n            contributorChain.nodes[prev].next = cid;\r\n            contributorChain.tail = cid;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove contributor by `_cid`\r\n     */\r\n    function _removeContributor(uint _cid) internal contributorValid(_cid) {\r\n        require(_cid != 0);\r\n        uint256 next = 0;\r\n        uint256 prev = 0;\r\n        require(contributorChain.nodes[_cid].cid == _cid);\r\n        next = contributorChain.nodes[_cid].next;\r\n        prev = contributorChain.nodes[_cid].prev;\r\n        if (next == 0) {\r\n            if(prev != 0) {\r\n                contributorChain.nodes[prev].next = 0;\r\n                delete contributorChain.nodes[_cid];\r\n                contributorChain.tail = prev;\r\n            }else {\r\n                delete contributorChain.nodes[_cid];\r\n                delete contributorChain;\r\n            }\r\n        } else {\r\n            if (prev == 0) {\r\n                contributorChain.head = next;\r\n                contributorChain.nodes[next].prev = 0;\r\n                delete contributorChain.nodes[_cid];\r\n            } else {\r\n                contributorChain.nodes[prev].next = next;\r\n                contributorChain.nodes[next].prev = prev;\r\n                delete contributorChain.nodes[_cid];\r\n            }\r\n        }\r\n        if(contributorChain.balance > 0) {\r\n            contributorChain.balance--;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Record `_contributors`\r\n     * @param _contributors The contributor\r\n     */\r\n    function addContributors(address[] _contributors, bytes32[] _names) external onlyOwner {\r\n        require(_contributors.length == _names.length && _contributors.length > 0);\r\n        for(uint256 i = 0; i < _contributors.length; i++) {\r\n            _pushContributor(_contributors[i], _names[i]);\r\n        }\r\n\r\n        // Event\r\n        emit ContributorsAdded(_contributors);\r\n    }\r\n\r\n    /**\r\n     * Remove contributor by `_cids`\r\n     * @param _cids The contributor's ids\r\n     */\r\n    function removeContributors(uint256[] _cids) external onlyOwner {\r\n        for(uint256 i = 0; i < _cids.length; i++) {\r\n            _removeContributor(_cids[i]);\r\n        }\r\n\r\n        // Event\r\n        emit ContributorsRemoved(_cids);\r\n    }\r\n\r\n    /**\r\n     * Returns all the contributors\r\n     * @return All the contributors\r\n     */\r\n    function contributors() public view returns(uint256[]) {\r\n        uint256 count;\r\n        uint256 index;\r\n        uint256 next;\r\n        index = 0;\r\n        next = contributorChain.head;\r\n        count = contributorChain.balance;\r\n        if (count > 0) {\r\n            uint256[] memory result = new uint256[](count);\r\n            while(next != 0 && index < count) {\r\n                result[index] = contributorChain.nodes[next].cid;\r\n                next = contributorChain.nodes[next].next;\r\n                index++;\r\n            }\r\n            return result;\r\n        } else {\r\n            return new uint256[](0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the contributor by `_cid`\r\n     * @return The contributor\r\n     */\r\n    function contributor(uint _cid) external view returns(address, bytes32) {\r\n        return (contributorChain.nodes[_cid].contributor, contributorChain.nodes[_cid].name);\r\n    }  \r\n}\r\ncontract TPTSchedules is TPTData, Owned {\r\n    function TPTSchedules() public {\r\n        \r\n    }\r\n\r\n    /**\r\n     * This emits when schedules are inserted\r\n     */\r\n    event SchedulesInserted(uint256 _cid);\r\n\r\n    /**\r\n     * This emits when schedules are removed\r\n     */\r\n    event SchedulesRemoved(uint _cid, uint256[] _sids);\r\n\r\n    /**\r\n     * Record TRIO transfer schedule to  `_contributor`\r\n     * @param _cid The contributor\r\n     * @param _timestamps The transfer timestamps\r\n     * @param _trios The transfer trios\r\n     */\r\n    function insertSchedules(uint256 _cid, uint32[] _timestamps, uint256[] _trios) \r\n        external \r\n        onlyOwner \r\n        contributorValid(_cid) {\r\n        require(_timestamps.length > 0 && _timestamps.length == _trios.length);\r\n        for (uint256 i = 0; i < _timestamps.length; i++) {\r\n            uint256 prev = 0;\r\n            uint256 next = 0;\r\n            uint256 sid = scheduleChains[_cid].index + 1;\r\n            if (scheduleChains[_cid].balance == 0) {\r\n                scheduleChains[_cid] = ScheduleChain(1, sid, sid, sid);\r\n                scheduleChains[_cid].nodes[sid] = Schedule(0, 0, sid, _timestamps[i], _trios[i]);\r\n            } else {\r\n                scheduleChains[_cid].index = sid;\r\n                scheduleChains[_cid].balance++;\r\n                prev = scheduleChains[_cid].tail;\r\n                while(scheduleChains[_cid].nodes[prev].timestamp > _timestamps[i] && prev != 0) {\r\n                    prev = scheduleChains[_cid].nodes[prev].prev;\r\n                }\r\n                if (prev == 0) {\r\n                    next = scheduleChains[_cid].head;\r\n                    scheduleChains[_cid].nodes[sid] = Schedule(next, 0, sid, _timestamps[i], _trios[i]);\r\n                    scheduleChains[_cid].nodes[next].prev = sid;\r\n                    scheduleChains[_cid].head = sid;\r\n                } else {\r\n                    next = scheduleChains[_cid].nodes[prev].next;\r\n                    scheduleChains[_cid].nodes[sid] = Schedule(next, prev, sid, _timestamps[i], _trios[i]);\r\n                    scheduleChains[_cid].nodes[prev].next = sid;\r\n                    if (next == 0) {\r\n                        scheduleChains[_cid].tail = sid;\r\n                    }else {\r\n                        scheduleChains[_cid].nodes[next].prev = sid;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Event\r\n        emit SchedulesInserted(_cid);\r\n    }\r\n\r\n    /**\r\n     * Remove schedule by `_cid` and `_sids`\r\n     * @param _cid The contributor's id\r\n     * @param _sids The schedule's ids\r\n     */\r\n    function removeSchedules(uint _cid, uint256[] _sids) \r\n        public \r\n        onlyOwner \r\n        contributorValid(_cid) {\r\n        uint256 next = 0;\r\n        uint256 prev = 0;\r\n        uint256 sid;\r\n        for (uint256 i = 0; i < _sids.length; i++) {\r\n            sid = _sids[i];\r\n            require(scheduleChains[_cid].nodes[sid].sid == sid);\r\n            next = scheduleChains[_cid].nodes[sid].next;\r\n            prev = scheduleChains[_cid].nodes[sid].prev;\r\n            if (next == 0) {\r\n                if(prev != 0) {\r\n                    scheduleChains[_cid].nodes[prev].next = 0;\r\n                    delete scheduleChains[_cid].nodes[sid];\r\n                    scheduleChains[_cid].tail = prev;\r\n                }else {\r\n                    delete scheduleChains[_cid].nodes[sid];\r\n                    delete scheduleChains[_cid];\r\n                }\r\n            } else {\r\n                if (prev == 0) {\r\n                    scheduleChains[_cid].head = next;\r\n                    scheduleChains[_cid].nodes[next].prev = 0;\r\n                    delete scheduleChains[_cid].nodes[sid];\r\n                } else {\r\n                    scheduleChains[_cid].nodes[prev].next = next;\r\n                    scheduleChains[_cid].nodes[next].prev = prev;\r\n                    delete scheduleChains[_cid].nodes[sid];\r\n                }\r\n            }\r\n            if(scheduleChains[_cid].balance > 0) {\r\n                scheduleChains[_cid].balance--;\r\n            }   \r\n        }\r\n\r\n        // Event\r\n        emit SchedulesRemoved(_cid, _sids);\r\n    }\r\n\r\n    /**\r\n     * Return all the schedules of `_cid`\r\n     * @param _cid The contributor's id \r\n     * @return All the schedules of `_cid`\r\n     */\r\n    function schedules(uint256 _cid) \r\n        public \r\n        contributorValid(_cid) \r\n        view \r\n        returns(uint256[]) {\r\n        uint256 count;\r\n        uint256 index;\r\n        uint256 next;\r\n        index = 0;\r\n        next = scheduleChains[_cid].head;\r\n        count = scheduleChains[_cid].balance;\r\n        if (count > 0) {\r\n            uint256[] memory result = new uint256[](count);\r\n            while(next != 0 && index < count) {\r\n                result[index] = scheduleChains[_cid].nodes[next].sid;\r\n                next = scheduleChains[_cid].nodes[next].next;\r\n                index++;\r\n            }\r\n            return result;\r\n        } else {\r\n            return new uint256[](0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the schedule by `_cid` and `_sid`\r\n     * @param _cid The contributor's id\r\n     * @param _sid The schedule's id\r\n     * @return The schedule\r\n     */\r\n    function schedule(uint256 _cid, uint256 _sid) \r\n        public\r\n        scheduleValid(_cid, _sid) \r\n        view \r\n        returns(uint32, uint256) {\r\n        return (scheduleChains[_cid].nodes[_sid].timestamp, scheduleChains[_cid].nodes[_sid].trio);\r\n    }\r\n}\r\ncontract TPTTransfer is TPTContributors, TPTSchedules {\r\n    function TPTTransfer() public {\r\n        \r\n    }\r\n\r\n    /**\r\n     * This emits when transfer \r\n     */\r\n    event AutoTransfer(address indexed _to, uint256 _trio);\r\n\r\n    /**\r\n     * This emits when \r\n     */\r\n    event AutoTransferCompleted();\r\n\r\n    /**\r\n     * Withdraw TRIO TOKEN balance from contract account, the balance will transfer to the contract owner\r\n     */\r\n    function withdrawToken() external onlyOwner {\r\n        TripioToken tripio = TripioToken(trioContract);\r\n        uint256 tokens = tripio.balanceOf(address(this));\r\n        tripio.transfer(owner, tokens);\r\n    }\r\n\r\n    /**\r\n     * Auto Transfer All Schedules\r\n     */\r\n    function autoTransfer() external onlyOwner {\r\n        // TRIO contract\r\n        TripioToken tripio = TripioToken(trioContract);\r\n        \r\n        // All contributors\r\n        uint256[] memory _contributors = contributors();\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            // cid and contributor address\r\n            uint256 _cid = _contributors[i];\r\n            address _contributor = contributorChain.nodes[_cid].contributor;\r\n            \r\n            // All schedules\r\n            uint256[] memory _schedules = schedules(_cid);\r\n            for (uint256 j = 0; j < _schedules.length; j++) {\r\n                // sid, trio and timestamp\r\n                uint256 _sid = _schedules[j];\r\n                uint256 _trio = scheduleChains[_cid].nodes[_sid].trio;\r\n                uint256 _timestamp = scheduleChains[_cid].nodes[_sid].timestamp;\r\n\r\n                // hasn't arrived\r\n                if(_timestamp > now) {\r\n                    break;\r\n                }\r\n                // Transfer TRIO to contributor\r\n                tripio.transfer(_contributor, _trio);\r\n\r\n                // Remove schedule of contributor\r\n                uint256[] memory _sids = new uint256[](1);\r\n                _sids[0] = _sid;\r\n                removeSchedules(_cid, _sids);\r\n                emit AutoTransfer(_contributor, _trio);\r\n            }\r\n        }\r\n\r\n        emit AutoTransferCompleted();\r\n    }\r\n\r\n    /**\r\n     * Is there any transfer in schedule\r\n     */\r\n    function totalTransfersInSchedule() external view returns(uint256,uint256) {\r\n        // All contributors\r\n        uint256[] memory _contributors = contributors();\r\n        uint256 total = 0;\r\n        uint256 amount = 0;\r\n        for (uint256 i = 0; i < _contributors.length; i++) {\r\n            // cid and contributor address\r\n            uint256 _cid = _contributors[i];            \r\n            // All schedules\r\n            uint256[] memory _schedules = schedules(_cid);\r\n            for (uint256 j = 0; j < _schedules.length; j++) {\r\n                // sid, trio and timestamp\r\n                uint256 _sid = _schedules[j];\r\n                uint256 _timestamp = scheduleChains[_cid].nodes[_sid].timestamp;\r\n                if(_timestamp < now) {\r\n                    total++;\r\n                    amount += scheduleChains[_cid].nodes[_sid].trio;\r\n                }\r\n            }\r\n        }\r\n        return (total,amount);\r\n    }\r\n}\r\n\r\ncontract TrioPeriodicTransfer is TPTTransfer {\r\n    function TrioPeriodicTransfer(address _trio) public {\r\n        trioContract = _trio;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"autoTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cid\",\"type\":\"uint256\"},{\"name\":\"_sid\",\"type\":\"uint256\"}],\"name\":\"schedule\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTransfersInSchedule\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cid\",\"type\":\"uint256\"},{\"name\":\"_sids\",\"type\":\"uint256[]\"}],\"name\":\"removeSchedules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cid\",\"type\":\"uint256\"}],\"name\":\"contributor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cid\",\"type\":\"uint256\"},{\"name\":\"_timestamps\",\"type\":\"uint32[]\"},{\"name\":\"_trios\",\"type\":\"uint256[]\"}],\"name\":\"insertSchedules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cid\",\"type\":\"uint256\"}],\"name\":\"schedules\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cids\",\"type\":\"uint256[]\"}],\"name\":\"removeContributors\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributors\",\"type\":\"address[]\"},{\"name\":\"_names\",\"type\":\"bytes32[]\"}],\"name\":\"addContributors\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trioContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_trio\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_trio\",\"type\":\"uint256\"}],\"name\":\"AutoTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AutoTransferCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_cid\",\"type\":\"uint256\"}],\"name\":\"SchedulesInserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_cid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_sids\",\"type\":\"uint256[]\"}],\"name\":\"SchedulesRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributors\",\"type\":\"address[]\"}],\"name\":\"ContributorsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_cids\",\"type\":\"uint256[]\"}],\"name\":\"ContributorsRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TrioPeriodicTransfer","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008b40761142b9aa6dc8964e61d0585995425c3d94","Library":"","SwarmSource":"bzzr://23b28f949377710d9fbaaee0711860063109f2499274aaf2b7217b3309ffbc1f"}]}