{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/*\r\n  https://cryptogs.io\r\n  --Austin Thomas Griffith for ETHDenver\r\n  ( PS this gas guzzling beast is still unaudited )\r\n*/\r\n\r\n\r\n//adapted from https://github.com/ethereum/EIPs/issues/721\r\n// thanks to Dieter Shirley && http://axiomzen.co\r\n\r\ncontract NFT {\r\n\r\n  function NFT() public { }\r\n\r\n  mapping (uint256 => address) public tokenIndexToOwner;\r\n  mapping (address => uint256) ownershipTokenCount;\r\n  mapping (uint256 => address) public tokenIndexToApproved;\r\n\r\n  function transfer(address _to,uint256 _tokenId) external {\r\n      require(_to != address(0));\r\n      require(_to != address(this));\r\n      require(_owns(msg.sender, _tokenId));\r\n      _transfer(msg.sender, _to, _tokenId);\r\n  }\r\n  function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n      ownershipTokenCount[_to]++;\r\n      tokenIndexToOwner[_tokenId] = _to;\r\n      if (_from != address(0)) {\r\n          ownershipTokenCount[_from]--;\r\n          delete tokenIndexToApproved[_tokenId];\r\n      }\r\n      Transfer(_from, _to, _tokenId);\r\n  }\r\n  event Transfer(address from, address to, uint256 tokenId);\r\n\r\n  function transferFrom(address _from,address _to,uint256 _tokenId) external {\r\n      require(_to != address(0));\r\n      require(_to != address(this));\r\n      require(_approvedFor(msg.sender, _tokenId));\r\n      require(_owns(_from, _tokenId));\r\n      _transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n      return tokenIndexToOwner[_tokenId] == _claimant;\r\n  }\r\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n      return tokenIndexToApproved[_tokenId] == _claimant;\r\n  }\r\n  function _approve(uint256 _tokenId, address _approved) internal {\r\n      tokenIndexToApproved[_tokenId] = _approved;\r\n  }\r\n\r\n  function approve(address _to,uint256 _tokenId) public returns (bool) {\r\n      require(_owns(msg.sender, _tokenId));\r\n      _approve(_tokenId, _to);\r\n      Approval(msg.sender, _to, _tokenId);\r\n      return true;\r\n  }\r\n  event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 count) {\r\n      return ownershipTokenCount[_owner];\r\n  }\r\n\r\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\r\n      owner = tokenIndexToOwner[_tokenId];\r\n      require(owner != address(0));\r\n  }\r\n\r\n  function allowance(address _claimant, uint256 _tokenId) public view returns (bool) {\r\n      return _approvedFor(_claimant,_tokenId);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Cryptogs is NFT, Ownable {\r\n\r\n    string public constant name = \"Cryptogs\";\r\n    string public constant symbol = \"POGS\";\r\n\r\n    string public constant purpose = \"ETHDenver\";\r\n    string public constant contact = \"https://cryptogs.io\";\r\n    string public constant author = \"Austin Thomas Griffith\";\r\n\r\n    uint8 public constant FLIPPINESS = 64;\r\n    uint8 public constant FLIPPINESSROUNDBONUS = 16;\r\n    uint8 public constant TIMEOUTBLOCKS = 180;\r\n    uint8 public constant BLOCKSUNTILCLEANUPSTACK=1;\r\n\r\n    string public ipfs;\r\n    function setIpfs(string _ipfs) public onlyOwner returns (bool){\r\n      ipfs=_ipfs;\r\n      IPFS(ipfs);\r\n      return true;\r\n    }\r\n    event IPFS(string ipfs);\r\n\r\n    function Cryptogs() public {\r\n      //0 index should be a blank item owned by no one\r\n      Item memory _item = Item({\r\n        image: \"\"\r\n      });\r\n      items.push(_item);\r\n    }\r\n\r\n    address public slammerTime;\r\n    function setSlammerTime(address _slammerTime) public onlyOwner returns (bool){\r\n      //in order to trust that this contract isn't sending a players tokens\r\n      // to a different contract, the slammertime contract is set once and\r\n      // only once -- at deploy\r\n      require(slammerTime==address(0));\r\n      slammerTime=_slammerTime;\r\n      return true;\r\n    }\r\n\r\n    struct Item{\r\n      bytes32 image;\r\n      //perhaps some are harder to flip over?\r\n      //perhaps some have magical metadata?\r\n      //I don't know, it's late and I'm weird\r\n    }\r\n\r\n    Item[] private items;\r\n\r\n    function mint(bytes32 _image,address _owner) public onlyOwner returns (uint){\r\n      uint256 newId = _mint(_image);\r\n      _transfer(0, _owner, newId);\r\n      Mint(items[newId].image,tokenIndexToOwner[newId],newId);\r\n      return newId;\r\n    }\r\n    event Mint(bytes32 _image,address _owner,uint256 _id);\r\n\r\n    function mintBatch(bytes32 _image1,bytes32 _image2,bytes32 _image3,bytes32 _image4,bytes32 _image5,address _owner) public onlyOwner returns (bool){\r\n      uint256 newId = _mint(_image1);\r\n      _transfer(0, _owner, newId);\r\n      Mint(_image1,tokenIndexToOwner[newId],newId);\r\n      newId=_mint(_image2);\r\n      _transfer(0, _owner, newId);\r\n      Mint(_image2,tokenIndexToOwner[newId],newId);\r\n      newId=_mint(_image3);\r\n      _transfer(0, _owner, newId);\r\n      Mint(_image3,tokenIndexToOwner[newId],newId);\r\n      newId=_mint(_image4);\r\n      _transfer(0, _owner, newId);\r\n      Mint(_image4,tokenIndexToOwner[newId],newId);\r\n      newId=_mint(_image5);\r\n      _transfer(0, _owner, newId);\r\n      Mint(_image5,tokenIndexToOwner[newId],newId);\r\n      return true;\r\n    }\r\n\r\n    function _mint(bytes32 _image) internal returns (uint){\r\n      Item memory _item = Item({\r\n        image: _image\r\n      });\r\n      uint256 newId = items.push(_item) - 1;\r\n      tokensOfImage[items[newId].image]++;\r\n      return newId;\r\n    }\r\n\r\n    Pack[] private packs;\r\n    struct Pack{\r\n      uint256[10] tokens;\r\n      uint256 price;\r\n    }\r\n    function mintPack(uint256 _price,bytes32 _image1,bytes32 _image2,bytes32 _image3,bytes32 _image4,bytes32 _image5,bytes32 _image6,bytes32 _image7,bytes32 _image8,bytes32 _image9,bytes32 _image10) public onlyOwner returns (bool){\r\n      uint256[10] memory tokens;\r\n      tokens[0] = _mint(_image1);\r\n      tokens[1] = _mint(_image2);\r\n      tokens[2] = _mint(_image3);\r\n      tokens[3] = _mint(_image4);\r\n      tokens[4] = _mint(_image5);\r\n      tokens[5] = _mint(_image6);\r\n      tokens[6] = _mint(_image7);\r\n      tokens[7] = _mint(_image8);\r\n      tokens[8] = _mint(_image9);\r\n      tokens[9] = _mint(_image10);\r\n      Pack memory _pack = Pack({\r\n        tokens: tokens,\r\n        price: _price\r\n      });\r\n      MintPack(packs.push(_pack) - 1, _price,tokens[0],tokens[1],tokens[2],tokens[3],tokens[4],tokens[5],tokens[6],tokens[7],tokens[8],tokens[9]);\r\n      return true;\r\n    }\r\n    event MintPack(uint256 packId,uint256 price,uint256 token1,uint256 token2,uint256 token3,uint256 token4,uint256 token5,uint256 token6,uint256 token7,uint256 token8,uint256 token9,uint256 token10);\r\n\r\n    function buyPack(uint256 packId) public payable returns (bool) {\r\n      //make sure pack is for sale\r\n      require( packs[packId].price > 0 );\r\n      //make sure they sent in enough value\r\n      require( msg.value >= packs[packId].price );\r\n      //right away set price to 0 to avoid some sort of reentrance\r\n      packs[packId].price=0;\r\n      //give tokens to owner\r\n      for(uint8 i=0;i<10;i++){\r\n        tokenIndexToOwner[packs[packId].tokens[i]]=msg.sender;\r\n        _transfer(0, msg.sender, packs[packId].tokens[i]);\r\n      }\r\n      //clear the price so it is no longer for sale\r\n      delete packs[packId];\r\n      BuyPack(msg.sender,packId,msg.value);\r\n    }\r\n    event BuyPack(address sender, uint256 packId, uint256 price);\r\n\r\n    //lets keep a count of how many of a specific image is created too\r\n    //that will allow us to calculate rarity on-chain if we want\r\n    mapping (bytes32 => uint256) public tokensOfImage;\r\n\r\n    function getToken(uint256 _id) public view returns (address owner,bytes32 image,uint256 copies) {\r\n      image = items[_id].image;\r\n      copies = tokensOfImage[image];\r\n      return (\r\n        tokenIndexToOwner[_id],\r\n        image,\r\n        copies\r\n      );\r\n    }\r\n\r\n    uint256 nonce = 0;\r\n\r\n    struct Stack{\r\n      //this will be an array of ids but for now just doing one for simplicity\r\n      uint256[5] ids;\r\n      address owner;\r\n      uint32 block;\r\n\r\n    }\r\n\r\n    mapping (bytes32 => Stack) public stacks;\r\n    mapping (bytes32 => bytes32) public stackCounter;\r\n\r\n    function stackOwner(bytes32 _stack) public constant returns (address owner) {\r\n      return stacks[_stack].owner;\r\n    }\r\n\r\n    function getStack(bytes32 _stack) public constant returns (address owner,uint32 block,uint256 token1,uint256 token2,uint256 token3,uint256 token4,uint256 token5) {\r\n      return (stacks[_stack].owner,stacks[_stack].block,stacks[_stack].ids[0],stacks[_stack].ids[1],stacks[_stack].ids[2],stacks[_stack].ids[3],stacks[_stack].ids[4]);\r\n    }\r\n\r\n    //tx 1: of a game, player one approves the SlammerTime contract to take their tokens\r\n    //this triggers an event to broadcast to other players that there is an open challenge\r\n    function submitStack(uint256 _id,uint256 _id2,uint256 _id3,uint256 _id4,uint256 _id5, bool _public) public returns (bool) {\r\n      //make sure slammerTime was set at deploy\r\n      require(slammerTime!=address(0));\r\n      //the sender must own the token\r\n      require(tokenIndexToOwner[_id]==msg.sender);\r\n      require(tokenIndexToOwner[_id2]==msg.sender);\r\n      require(tokenIndexToOwner[_id3]==msg.sender);\r\n      require(tokenIndexToOwner[_id4]==msg.sender);\r\n      require(tokenIndexToOwner[_id5]==msg.sender);\r\n      //they approve the slammertime contract to take the token away from them\r\n      require(approve(slammerTime,_id));\r\n      require(approve(slammerTime,_id2));\r\n      require(approve(slammerTime,_id3));\r\n      require(approve(slammerTime,_id4));\r\n      require(approve(slammerTime,_id5));\r\n\r\n      bytes32 stack = keccak256(nonce++,msg.sender);\r\n      uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5];\r\n      stacks[stack] = Stack(ids,msg.sender,uint32(block.number));\r\n\r\n      //the event is triggered to the frontend to display the stack\r\n      //the frontend will check if they want it public or not\r\n      SubmitStack(msg.sender,now,stack,_id,_id2,_id3,_id4,_id5,_public);\r\n    }\r\n    event SubmitStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5,bool _public);\r\n\r\n    //tx 2: of a game, player two approves the SlammerTime contract to take their tokens\r\n    //this triggers an event to broadcast to player one that this player wants to rumble\r\n    function submitCounterStack(bytes32 _stack, uint256 _id, uint256 _id2, uint256 _id3, uint256 _id4, uint256 _id5) public returns (bool) {\r\n      //make sure slammerTime was set at deploy\r\n      require(slammerTime!=address(0));\r\n      //the sender must own the token\r\n      require(tokenIndexToOwner[_id]==msg.sender);\r\n      require(tokenIndexToOwner[_id2]==msg.sender);\r\n      require(tokenIndexToOwner[_id3]==msg.sender);\r\n      require(tokenIndexToOwner[_id4]==msg.sender);\r\n      require(tokenIndexToOwner[_id5]==msg.sender);\r\n      //they approve the slammertime contract to take the token away from them\r\n      require(approve(slammerTime,_id));\r\n      require(approve(slammerTime,_id2));\r\n      require(approve(slammerTime,_id3));\r\n      require(approve(slammerTime,_id4));\r\n      require(approve(slammerTime,_id5));\r\n      //stop playing with yourself\r\n      require(msg.sender!=stacks[_stack].owner);\r\n\r\n      bytes32 counterstack = keccak256(nonce++,msg.sender,_id);\r\n      uint256[5] memory ids = [_id,_id2,_id3,_id4,_id5];\r\n      stacks[counterstack] = Stack(ids,msg.sender,uint32(block.number));\r\n      stackCounter[counterstack] = _stack;\r\n\r\n      //the event is triggered to the frontend to display the stack\r\n      //the frontend will check if they want it public or not\r\n      CounterStack(msg.sender,now,_stack,counterstack,_id,_id2,_id3,_id4,_id5);\r\n    }\r\n    event CounterStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack, bytes32 _counterStack, uint256 _token1, uint256 _token2, uint256 _token3, uint256 _token4, uint256 _token5);\r\n\r\n    // if someone creates a stack they should be able to clean it up\r\n    // its not really that big of a deal because we will have a timeout\r\n    // in the frontent, but still...\r\n    function cancelStack(bytes32 _stack) public returns (bool) {\r\n      //it must be your stack\r\n      require(msg.sender==stacks[_stack].owner);\r\n      //make sure there is no mode set yet\r\n      require(mode[_stack]==0);\r\n      //make sure they aren't trying to cancel a counterstack using this function\r\n      require(stackCounter[_stack]==0x00000000000000000000000000000000);\r\n\r\n      delete stacks[_stack];\r\n\r\n      CancelStack(msg.sender,now,_stack);\r\n    }\r\n    event CancelStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack);\r\n\r\n    function cancelCounterStack(bytes32 _stack,bytes32 _counterstack) public returns (bool) {\r\n      //it must be your stack\r\n      require(msg.sender==stacks[_counterstack].owner);\r\n      //the counter must be a counter of stack 1\r\n      require(stackCounter[_counterstack]==_stack);\r\n      //make sure there is no mode set yet\r\n      require(mode[_stack]==0);\r\n\r\n      delete stacks[_counterstack];\r\n      delete stackCounter[_counterstack];\r\n\r\n      CancelCounterStack(msg.sender,now,_stack,_counterstack);\r\n    }\r\n    event CancelCounterStack(address indexed _sender,uint256 indexed timestamp,bytes32 indexed _stack,bytes32 _counterstack);\r\n\r\n    mapping (bytes32 => bytes32) public counterOfStack;\r\n    mapping (bytes32 => uint8) public mode;\r\n    mapping (bytes32 => uint8) public round;\r\n    mapping (bytes32 => uint32) public lastBlock;\r\n    mapping (bytes32 => uint32) public commitBlock;\r\n    mapping (bytes32 => address) public lastActor;\r\n    mapping (bytes32 => uint256[10]) public mixedStack;\r\n\r\n    //tx 3: of a game, player one approves counter stack and transfers everything in\r\n    function acceptCounterStack(bytes32 _stack, bytes32 _counterStack) public returns (bool) {\r\n      //sender must be owner of stack 1\r\n      require(msg.sender==stacks[_stack].owner);\r\n      //the counter must be a counter of stack 1\r\n      require(stackCounter[_counterStack]==_stack);\r\n      //make sure there is no mode set yet\r\n      require(mode[_stack]==0);\r\n\r\n      //do the transfer\r\n      SlammerTime slammerTimeContract = SlammerTime(slammerTime);\r\n      require( slammerTimeContract.startSlammerTime(msg.sender,stacks[_stack].ids,stacks[_counterStack].owner,stacks[_counterStack].ids) );\r\n\r\n      //save the block for a timeout\r\n      lastBlock[_stack]=uint32(block.number);\r\n      lastActor[_stack]=stacks[_counterStack].owner;\r\n      mode[_stack]=1;\r\n      counterOfStack[_stack]=_counterStack;\r\n\r\n      //// LOL @\r\n      mixedStack[_stack][0] = stacks[_stack].ids[0];\r\n      mixedStack[_stack][1] = stacks[_counterStack].ids[0];\r\n      mixedStack[_stack][2] = stacks[_stack].ids[1];\r\n      mixedStack[_stack][3] = stacks[_counterStack].ids[1];\r\n      mixedStack[_stack][4] = stacks[_stack].ids[2];\r\n      mixedStack[_stack][5] = stacks[_counterStack].ids[2];\r\n      mixedStack[_stack][6] = stacks[_stack].ids[3];\r\n      mixedStack[_stack][7] = stacks[_counterStack].ids[3];\r\n      mixedStack[_stack][8] = stacks[_stack].ids[4];\r\n      mixedStack[_stack][9] = stacks[_counterStack].ids[4];\r\n\r\n      //let the front end know that the transfer is good and we are ready for the coin flip\r\n      AcceptCounterStack(msg.sender,_stack,_counterStack);\r\n    }\r\n    event AcceptCounterStack(address indexed _sender,bytes32 indexed _stack, bytes32 indexed _counterStack);\r\n\r\n    mapping (bytes32 => bytes32) public commit;\r\n\r\n    function getMixedStack(bytes32 _stack) external view returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256){\r\n      uint256[10] thisStack = mixedStack[_stack];\r\n      return (thisStack[0],thisStack[1],thisStack[2],thisStack[3],thisStack[4],thisStack[5],thisStack[6],thisStack[7],thisStack[8],thisStack[9]);\r\n    }\r\n\r\n    //tx 4: player one commits and flips coin up\r\n    //at this point, the timeout goes into effect and if any transaction including\r\n    //the coin flip don't come back in time, we need to allow the other party\r\n    //to withdraw all tokens... this keeps either player from refusing to\r\n    //reveal their commit. (every tx from here on out needs to update the lastBlock and lastActor)\r\n    //and in the withdraw function you check currentblock-lastBlock > timeout = refund to lastActor\r\n    //and by refund I mean let them withdraw if they want\r\n    //we could even have a little timer on the front end that tells you how long your opponnet has\r\n    //before they will forfet\r\n    function startCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _commit) public returns (bool) {\r\n      //make sure it's the owner of the first stack (player one) doing the flip\r\n      require(stacks[_stack].owner==msg.sender);\r\n      //the counter must be a counter of stack 1\r\n      require(stackCounter[_counterStack]==_stack);\r\n      require(counterOfStack[_stack]==_counterStack);\r\n      //make sure that we are in mode 1\r\n      require(mode[_stack]==1);\r\n      //store the commit for the next tx\r\n      commit[_stack]=_commit;\r\n      commitBlock[_stack]=uint32(block.number);\r\n      //inc the mode to 2\r\n      mode[_stack]=2;\r\n      StartCoinFlip(_stack,_commit);\r\n    }\r\n    event StartCoinFlip(bytes32 stack, bytes32 commit);\r\n\r\n    //tx5: player one ends coin flip with reveal\r\n    function endCoinFlip(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) {\r\n      //make sure it's the owner of the first stack (player one) doing the flip\r\n      require(stacks[_stack].owner==msg.sender);\r\n      //the counter must be a counter of stack 1\r\n      require(stackCounter[_counterStack]==_stack);\r\n      require(counterOfStack[_stack]==_counterStack);\r\n      //make sure that we are in mode 2\r\n      require(mode[_stack]==2);\r\n\r\n      //make sure that we are on a later block than the commit block\r\n      // (added 3/5/2018)\r\n      require(uint32(block.number)>commitBlock[_stack]);\r\n\r\n      //make sure hash of reveal == commit\r\n      if(keccak256(_reveal)!=commit[_stack]){\r\n        //commit/reveal failed.. this can happen if they\r\n        //reload, so don't punish, just go back to the\r\n        //start of the coin flip stage\r\n        mode[_stack]=1;\r\n        CoinFlipFail(_stack);\r\n        return false;\r\n      }else{\r\n        //successful coin flip, ready to get random\r\n        mode[_stack]=3;\r\n        round[_stack]=1;\r\n        bytes32 pseudoRandomHash = keccak256(_reveal,block.blockhash(commitBlock[_stack]));\r\n        if(uint256(pseudoRandomHash)%2==0){\r\n          //player1 goes first\r\n          lastBlock[_stack]=uint32(block.number);\r\n          lastActor[_stack]=stacks[_counterStack].owner;\r\n          CoinFlipSuccess(_stack,stacks[_stack].owner,true);\r\n        }else{\r\n          //player2 goes first\r\n          lastBlock[_stack]=uint32(block.number);\r\n          lastActor[_stack]=stacks[_stack].owner;\r\n          CoinFlipSuccess(_stack,stacks[_counterStack].owner,false);\r\n        }\r\n        return true;\r\n      }\r\n\r\n    }\r\n    event CoinFlipSuccess(bytes32 indexed stack,address whosTurn,bool heads);\r\n    event CoinFlipFail(bytes32 stack);\r\n\r\n\r\n    //tx6 next player raises slammer\r\n    function raiseSlammer(bytes32 _stack, bytes32 _counterStack, bytes32 _commit) public returns (bool) {\r\n      if(lastActor[_stack]==stacks[_stack].owner){\r\n        //it is player2's turn\r\n        require(stacks[_counterStack].owner==msg.sender);\r\n      }else{\r\n        //it is player1's turn\r\n        require(stacks[_stack].owner==msg.sender);\r\n      }\r\n      //the counter must be a counter of stack 1\r\n      require(stackCounter[_counterStack]==_stack);\r\n      require(counterOfStack[_stack]==_counterStack);\r\n      //make sure that we are in mode 3\r\n      require(mode[_stack]==3);\r\n      //store the commit for the next tx\r\n      commit[_stack]=_commit;\r\n      commitBlock[_stack]=uint32(block.number);\r\n      //inc the mode to 2\r\n      mode[_stack]=4;\r\n      RaiseSlammer(_stack,_commit);\r\n    }\r\n    event RaiseSlammer(bytes32 stack, bytes32 commit);\r\n\r\n\r\n    //tx7 player throws slammer\r\n    function throwSlammer(bytes32 _stack, bytes32 _counterStack, bytes32 _reveal) public returns (bool) {\r\n      if(lastActor[_stack]==stacks[_stack].owner){\r\n        //it is player2's turn\r\n        require(stacks[_counterStack].owner==msg.sender);\r\n      }else{\r\n        //it is player1's turn\r\n        require(stacks[_stack].owner==msg.sender);\r\n      }\r\n      //the counter must be a counter of stack 1\r\n      require(stackCounter[_counterStack]==_stack);\r\n      require(counterOfStack[_stack]==_counterStack);\r\n      //make sure that we are in mode 4\r\n      require(mode[_stack]==4);\r\n\r\n      //make sure that we are on a later block than the commit block\r\n      // (added 3/5/2018)\r\n      require(uint32(block.number)>commitBlock[_stack]);\r\n\r\n      uint256[10] memory flipped;\r\n      if(keccak256(_reveal)!=commit[_stack]){\r\n        //commit/reveal failed.. this can happen if they\r\n        //reload, so don't punish, just go back to the\r\n        //start of the slammer raise\r\n        mode[_stack]=3;\r\n        throwSlammerEvent(_stack,msg.sender,address(0),flipped);\r\n        return false;\r\n      }else{\r\n        //successful slam!!!!!!!!!!!! At this point I have officially been awake for 24 hours !!!!!!!!!!\r\n        mode[_stack]=3;\r\n\r\n        address previousLastActor = lastActor[_stack];\r\n\r\n        bytes32 pseudoRandomHash = keccak256(_reveal,block.blockhash(commitBlock[_stack]));\r\n        //Debug(_reveal,block.blockhash(block.number-1),pseudoRandomHash);\r\n        if(lastActor[_stack]==stacks[_stack].owner){\r\n          //player1 goes next\r\n          lastBlock[_stack]=uint32(block.number);\r\n          lastActor[_stack]=stacks[_counterStack].owner;\r\n        }else{\r\n          //player2 goes next\r\n          lastBlock[_stack]=uint32(block.number);\r\n          lastActor[_stack]=stacks[_stack].owner;\r\n        }\r\n\r\n        //look through the stack of remaining pogs and compare to byte to see if less than FLIPPINESS and transfer back to correct owner\r\n        // oh man, that smells like reentrance --  I think the mode would actually break that right?\r\n        bool done=true;\r\n        uint8 randIndex = 0;\r\n        for(uint8 i=0;i<10;i++){\r\n          if(mixedStack[_stack][i]>0){\r\n            //there is still a pog here, check for flip\r\n            uint8 thisFlipper = uint8(pseudoRandomHash[randIndex++]);\r\n            //DebugFlip(pseudoRandomHash,i,randIndex,thisFlipper,FLIPPINESS);\r\n            if(thisFlipper<(FLIPPINESS+round[_stack]*FLIPPINESSROUNDBONUS)){\r\n              //ITS A FLIP!\r\n               uint256 tempId = mixedStack[_stack][i];\r\n               flipped[i]=tempId;\r\n               mixedStack[_stack][i]=0;\r\n               SlammerTime slammerTimeContract = SlammerTime(slammerTime);\r\n               //require( slammerTimeContract.transferBack(msg.sender,tempId) );\r\n               slammerTimeContract.transferBack(msg.sender,tempId);\r\n            }else{\r\n              done=false;\r\n            }\r\n          }\r\n        }\r\n\r\n        throwSlammerEvent(_stack,msg.sender,previousLastActor,flipped);\r\n\r\n        if(done){\r\n          FinishGame(_stack);\r\n          mode[_stack]=9;\r\n          delete mixedStack[_stack];\r\n          delete stacks[_stack];\r\n          delete stackCounter[_counterStack];\r\n          delete stacks[_counterStack];\r\n          delete lastBlock[_stack];\r\n          delete lastActor[_stack];\r\n          delete counterOfStack[_stack];\r\n          delete round[_stack];\r\n          delete commitBlock[_stack];\r\n          delete commit[_stack];\r\n        }else{\r\n          round[_stack]++;\r\n        }\r\n\r\n        return true;\r\n      }\r\n    }\r\n    event ThrowSlammer(bytes32 indexed stack, address indexed whoDoneIt, address indexed otherPlayer, uint256 token1Flipped, uint256 token2Flipped, uint256 token3Flipped, uint256 token4Flipped, uint256 token5Flipped, uint256 token6Flipped, uint256 token7Flipped, uint256 token8Flipped, uint256 token9Flipped, uint256 token10Flipped);\r\n    event FinishGame(bytes32 stack);\r\n\r\n    function throwSlammerEvent(bytes32 stack,address whoDoneIt,address otherAccount, uint256[10] flipArray) internal {\r\n      ThrowSlammer(stack,whoDoneIt,otherAccount,flipArray[0],flipArray[1],flipArray[2],flipArray[3],flipArray[4],flipArray[5],flipArray[6],flipArray[7],flipArray[8],flipArray[9]);\r\n    }\r\n\r\n\r\n    function drainStack(bytes32 _stack, bytes32 _counterStack) public returns (bool) {\r\n      //this function is for the case of a timeout in the commit / reveal\r\n      // if a player realizes they are going to lose, they can refuse to reveal\r\n      // therefore we must have a timeout of TIMEOUTBLOCKS and if that time is reached\r\n      // the other player can get in and drain the remaining tokens from the game\r\n      require( stacks[_stack].owner==msg.sender || stacks[_counterStack].owner==msg.sender );\r\n      //the counter must be a counter of stack 1\r\n      require( stackCounter[_counterStack]==_stack );\r\n      require( counterOfStack[_stack]==_counterStack );\r\n      //the bad guy shouldn't be able to drain\r\n      require( lastActor[_stack]==msg.sender );\r\n      //must be after timeout period\r\n      require( block.number - lastBlock[_stack] >= TIMEOUTBLOCKS);\r\n      //game must still be going\r\n      require( mode[_stack]<9 );\r\n\r\n      for(uint8 i=0;i<10;i++){\r\n        if(mixedStack[_stack][i]>0){\r\n          uint256 tempId = mixedStack[_stack][i];\r\n          mixedStack[_stack][i]=0;\r\n          SlammerTime slammerTimeContract = SlammerTime(slammerTime);\r\n          slammerTimeContract.transferBack(msg.sender,tempId);\r\n        }\r\n      }\r\n\r\n      FinishGame(_stack);\r\n      mode[_stack]=9;\r\n\r\n      delete mixedStack[_stack];\r\n      delete stacks[_stack];\r\n      delete stackCounter[_counterStack];\r\n      delete stacks[_counterStack];\r\n      delete lastBlock[_stack];\r\n      delete lastActor[_stack];\r\n      delete counterOfStack[_stack];\r\n      delete round[_stack];\r\n      delete commitBlock[_stack];\r\n      delete commit[_stack];\r\n\r\n      DrainStack(_stack,_counterStack,msg.sender);\r\n    }\r\n    event DrainStack(bytes32 stack,bytes32 counterStack,address sender);\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return items.length - 1;\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) external view returns(uint256[]) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n        if (tokenCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 total = totalSupply();\r\n            uint256 resultIndex = 0;\r\n            uint256 id;\r\n            for (id = 1; id <= total; id++) {\r\n                if (tokenIndexToOwner[id] == _owner) {\r\n                    result[resultIndex] = id;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) public onlyOwner returns (bool) {\r\n      require(this.balance >= _amount);\r\n      assert(owner.send(_amount));\r\n      return true;\r\n    }\r\n\r\n    function withdrawToken(address _token,uint256 _amount) public onlyOwner returns (bool) {\r\n      StandardToken token = StandardToken(_token);\r\n      token.transfer(msg.sender,_amount);\r\n      return true;\r\n    }\r\n}\r\n\r\ncontract StandardToken {\r\n  function transfer(address _to, uint256 _value) public returns (bool) { }\r\n}\r\n\r\ncontract SlammerTime {\r\n  function startSlammerTime(address _player1,uint256[5] _id1,address _player2,uint256[5] _id2) public returns (bool) { }\r\n  function transferBack(address _toWhom, uint256 _id) public returns (bool) { }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"}],\"name\":\"stackOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"},{\"name\":\"_counterStack\",\"type\":\"bytes32\"}],\"name\":\"acceptCounterStack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_image\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_id2\",\"type\":\"uint256\"},{\"name\":\"_id3\",\"type\":\"uint256\"},{\"name\":\"_id4\",\"type\":\"uint256\"},{\"name\":\"_id5\",\"type\":\"uint256\"}],\"name\":\"submitCounterStack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contact\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FLIPPINESS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_image1\",\"type\":\"bytes32\"},{\"name\":\"_image2\",\"type\":\"bytes32\"},{\"name\":\"_image3\",\"type\":\"bytes32\"},{\"name\":\"_image4\",\"type\":\"bytes32\"},{\"name\":\"_image5\",\"type\":\"bytes32\"},{\"name\":\"_image6\",\"type\":\"bytes32\"},{\"name\":\"_image7\",\"type\":\"bytes32\"},{\"name\":\"_image8\",\"type\":\"bytes32\"},{\"name\":\"_image9\",\"type\":\"bytes32\"},{\"name\":\"_image10\",\"type\":\"bytes32\"}],\"name\":\"mintPack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BLOCKSUNTILCLEANUPSTACK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stacks\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"block\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"},{\"name\":\"_counterStack\",\"type\":\"bytes32\"},{\"name\":\"_commit\",\"type\":\"bytes32\"}],\"name\":\"raiseSlammer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"}],\"name\":\"getMixedStack\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"},{\"name\":\"_counterStack\",\"type\":\"bytes32\"},{\"name\":\"_reveal\",\"type\":\"bytes32\"}],\"name\":\"endCoinFlip\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FLIPPINESSROUNDBONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tokensOfImage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lastActor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"},{\"name\":\"_counterStack\",\"type\":\"bytes32\"}],\"name\":\"drainStack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"purpose\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lastBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slammerTime\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"mode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"author\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"}],\"name\":\"getStack\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"block\",\"type\":\"uint32\"},{\"name\":\"token1\",\"type\":\"uint256\"},{\"name\":\"token2\",\"type\":\"uint256\"},{\"name\":\"token3\",\"type\":\"uint256\"},{\"name\":\"token4\",\"type\":\"uint256\"},{\"name\":\"token5\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mixedStack\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"},{\"name\":\"_counterstack\",\"type\":\"bytes32\"}],\"name\":\"cancelCounterStack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ipfs\",\"type\":\"string\"}],\"name\":\"setIpfs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ipfs\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stackCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"packId\",\"type\":\"uint256\"}],\"name\":\"buyPack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_image1\",\"type\":\"bytes32\"},{\"name\":\"_image2\",\"type\":\"bytes32\"},{\"name\":\"_image3\",\"type\":\"bytes32\"},{\"name\":\"_image4\",\"type\":\"bytes32\"},{\"name\":\"_image5\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"mintBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_claimant\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"},{\"name\":\"_counterStack\",\"type\":\"bytes32\"},{\"name\":\"_reveal\",\"type\":\"bytes32\"}],\"name\":\"throwSlammer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIMEOUTBLOCKS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"image\",\"type\":\"bytes32\"},{\"name\":\"copies\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"},{\"name\":\"_counterStack\",\"type\":\"bytes32\"},{\"name\":\"_commit\",\"type\":\"bytes32\"}],\"name\":\"startCoinFlip\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stack\",\"type\":\"bytes32\"}],\"name\":\"cancelStack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_id2\",\"type\":\"uint256\"},{\"name\":\"_id3\",\"type\":\"uint256\"},{\"name\":\"_id4\",\"type\":\"uint256\"},{\"name\":\"_id5\",\"type\":\"uint256\"},{\"name\":\"_public\",\"type\":\"bool\"}],\"name\":\"submitStack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commit\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_slammerTime\",\"type\":\"address\"}],\"name\":\"setSlammerTime\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"counterOfStack\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ipfs\",\"type\":\"string\"}],\"name\":\"IPFS\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_image\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"packId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token4\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token5\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token6\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token7\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token8\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token9\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token10\",\"type\":\"uint256\"}],\"name\":\"MintPack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"packId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BuyPack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_stack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_token1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token4\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token5\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_public\",\"type\":\"bool\"}],\"name\":\"SubmitStack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_stack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_counterStack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_token1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token4\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token5\",\"type\":\"uint256\"}],\"name\":\"CounterStack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_stack\",\"type\":\"bytes32\"}],\"name\":\"CancelStack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_stack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_counterstack\",\"type\":\"bytes32\"}],\"name\":\"CancelCounterStack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_stack\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_counterStack\",\"type\":\"bytes32\"}],\"name\":\"AcceptCounterStack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"bytes32\"}],\"name\":\"StartCoinFlip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"stack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"whosTurn\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"heads\",\"type\":\"bool\"}],\"name\":\"CoinFlipSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stack\",\"type\":\"bytes32\"}],\"name\":\"CoinFlipFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"commit\",\"type\":\"bytes32\"}],\"name\":\"RaiseSlammer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"stack\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"whoDoneIt\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"otherPlayer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token1Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token2Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token3Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token4Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token5Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token6Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token7Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token8Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token9Flipped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token10Flipped\",\"type\":\"uint256\"}],\"name\":\"ThrowSlammer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stack\",\"type\":\"bytes32\"}],\"name\":\"FinishGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"counterStack\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"DrainStack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Cryptogs","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c8dd2edfbc1265b42e6361e8cbc5dadc3d836f6f3908e2fbf4d2244876567806"}]}