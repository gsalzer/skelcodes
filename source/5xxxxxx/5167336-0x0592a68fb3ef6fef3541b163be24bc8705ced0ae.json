{"status":"1","message":"OK","result":[{"SourceCode":"contract SafeMath {\r\n    \r\n    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x <= MAX_UINT256 - y);\r\n        return x + y;\r\n    }\r\n\r\n    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        require(x >= y);\r\n        return x - y;\r\n    }\r\n\r\n    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        if (y == 0) {\r\n            return 0;\r\n        }\r\n        require(x <= (MAX_UINT256 / y));\r\n        return x * y;\r\n    }\r\n}\r\n\r\ncontract ReentrancyHandlingContract{\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\n\r\ncontract Lockable is Owned {\r\n\r\n    uint256 public lockedUntilBlock;\r\n\r\n    event ContractLocked(uint256 _untilBlock, string _reason);\r\n\r\n    modifier lockAffected {\r\n        require(block.number > lockedUntilBlock);\r\n        _;\r\n    }\r\n\r\n    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }\r\n\r\n\r\n    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\r\n        lockedUntilBlock = _untilBlock;\r\n        ContractLocked(_untilBlock, _reason);\r\n    }\r\n}\r\n\r\ncontract LinkedList {\r\n\r\n\tstruct Element {\r\n    \tuint previous;\r\n    \tuint next;\r\n\r\n    \taddress data;\r\n  \t}\r\n\r\n  \tuint public size;\r\n  \tuint public tail;\r\n  \tuint public head;\r\n  \tmapping(uint => Element) elements;\r\n  \tmapping(address => uint) elementLocation;\r\n\r\n\tfunction addItem(address _newItem) returns (bool) {\r\n\t\tElement memory elem = Element(0, 0, _newItem);\r\n\r\n\t\tif (size == 0) {\r\n        \thead = 1;\r\n      \t} else {\r\n        \telements[tail].next = tail + 1;\r\n        \telem.previous = tail;\r\n      \t}\r\n\r\n      \telementLocation[_newItem] = tail + 1;\r\n      \telements[tail + 1] = elem;\r\n      \tsize++;\r\n      \ttail++;\r\n      \treturn true;\r\n\t}\r\n\r\n    function removeItem(address _item) returns (bool) {\r\n        uint key;\r\n        if (elementLocation[_item] == 0) {\r\n            return false;\r\n        }else {\r\n            key = elementLocation[_item];\r\n        }\r\n\r\n        if (size == 1) {\r\n            tail = 0;\r\n            head = 0;\r\n        }else if (key == head) {\r\n            head = elements[head].next;\r\n        }else if (key == tail) {\r\n            tail = elements[tail].previous;\r\n            elements[tail].next = 0;\r\n        }else {\r\n            elements[key - 1].next = elements[key].next;\r\n            elements[key + 1].previous = elements[key].previous;\r\n        }\r\n\r\n        size--;\r\n        delete elements[key];\r\n        elementLocation[_item] = 0;\r\n        return true;\r\n    }\r\n\r\n    function getAllElements() constant returns(address[]) {\r\n        address[] memory tempElementArray = new address[](size);\r\n        uint cnt = 0;\r\n        uint currentElemId = head;\r\n        while (cnt < size) {\r\n            tempElementArray[cnt] = elements[currentElemId].data;\r\n            currentElemId = elements[currentElemId].next;\r\n            cnt += 1;\r\n        }\r\n        return tempElementArray;\r\n    }\r\n\r\n    function getElementAt(uint _index) constant returns (address) {\r\n        return elements[_index].data;\r\n    }\r\n\r\n    function getElementLocation(address _element) constant returns (uint) {\r\n        return elementLocation[_element];\r\n    }\r\n\r\n    function getNextElement(uint _currElementId) constant returns (uint) {\r\n        return elements[_currElementId].next;\r\n    }\r\n}\r\n\r\ncontract RootDonationsContract is Owned {\r\n\r\n    LinkedList donationsList = new LinkedList();\r\n\r\n    function addNewDonation(address _donationAddress) public onlyOwner {\r\n        require(donationsList.getElementLocation(_donationAddress) != 0);\r\n        donationsList.addItem(_donationAddress);\r\n    }\r\n\r\n    function removeDonation(address _donationAddress) public onlyOwner {\r\n        require(donationsList.getElementLocation(_donationAddress) == 0);\r\n        donationsList.removeItem(_donationAddress);\r\n    }\r\n\r\n    function getDonations() constant public returns (address[]) {\r\n        address[] memory tempElementArray = new address[](donationsList.size());\r\n        uint cnt = 0;\r\n        uint tempArrayCnt = 0;\r\n        uint currentElemId = donationsList.head();\r\n        while (cnt < donationsList.size()) {\r\n            tempElementArray[tempArrayCnt] = donationsList.getElementAt(currentElemId);\r\n            \r\n            currentElemId = donationsList.getNextElement(currentElemId);\r\n            cnt++;\r\n            return tempElementArray;\r\n        }\r\n        \r\n    }\r\n}\r\n\r\ncontract DonationContract is Owned {\r\n\r\n    struct ContributorData {\r\n        bool active;\r\n        uint contributionAmount;\r\n        bool hasVotedForDisable;\r\n    }\r\n    mapping(address => ContributorData) public contributorList;\r\n    uint public nextContributorIndex;\r\n    mapping(uint => address) public contributorIndexes;\r\n    uint public nextContributorToReturn;\r\n\r\n    enum phase { pendingStart, started, EndedFail, EndedSucess, disabled, finished}\r\n    phase public donationPhase;\r\n\r\n    uint public maxCap;\r\n    uint public minCap;\r\n\r\n    uint public donationsStartTime;\r\n    uint public donationsEndedTime;\r\n\r\n    address tokenAddress;\r\n    uint public tokensDonated;\r\n\r\n    event MinCapReached(uint blockNumber);\r\n    event MaxCapReached(uint blockNumber);\r\n    event FundsClaimed(address athlete, uint _value, uint blockNumber);\r\n\r\n    uint public athleteCanClaimPercent;\r\n    uint public tick;\r\n    uint public lastClaimed;\r\n    uint public athleteAlreadyClaimed;\r\n    address public athlete;\r\n    uint public contractFee;\r\n    address public feeWallet;\r\n\r\n    uint public tokensVotedForDisable;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function DonationContract(  address _tokenAddress,\r\n                                uint _minCap,\r\n                                uint _maxCap,\r\n                                uint _donationsStartTime,\r\n                                uint _donationsEndedTime,\r\n                                uint _athleteCanClaimPercent,\r\n                                uint _tick,\r\n                                address _athlete,\r\n                                uint _contractFee,\r\n                                address _feeWallet) {\r\n        tokenAddress = _tokenAddress;\r\n        minCap = _minCap;\r\n        maxCap = _maxCap;\r\n        donationsStartTime = _donationsStartTime;\r\n        donationsEndedTime = _donationsEndedTime;\r\n        donationPhase = phase.pendingStart;\r\n        require(_athleteCanClaimPercent <= 100);\r\n        athleteCanClaimPercent = _athleteCanClaimPercent;\r\n        tick = _tick;\r\n        athlete = _athlete;\r\n        require(_athleteCanClaimPercent <= 100);\r\n        contractFee = _contractFee;\r\n        feeWallet = _feeWallet;\r\n    }\r\n\r\n    function receiveApproval(address _from, uint256 _value, address _to, bytes _extraData) public {\r\n        require(_to == tokenAddress);\r\n        require(_value != 0);\r\n\r\n        if (donationPhase == phase.pendingStart) {\r\n            if (now >= donationsStartTime) {\r\n                donationPhase = phase.started;\r\n            } else {\r\n                revert();\r\n            }\r\n        }\r\n\r\n        if(donationPhase == phase.started) {\r\n            if (now > donationsEndedTime){\r\n                if(tokensDonated >= minCap){\r\n                    donationPhase = phase.EndedSucess;\r\n                }else{\r\n                    donationPhase = phase.EndedFail;\r\n                }\r\n            }else{\r\n                uint tokensToTake = processTransaction(_from, _value);\r\n                ERC20TokenInterface(tokenAddress).transferFrom(_from, address(this), tokensToTake);\r\n            }\r\n        }else{\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function processTransaction(address _from, uint _value) internal returns (uint) {\r\n        uint valueToProcess = 0;\r\n        if (tokensDonated + _value >= maxCap) {\r\n            valueToProcess = maxCap - tokensDonated;\r\n            donationPhase = phase.EndedSucess;\r\n            MaxCapReached(block.number);\r\n        } else {\r\n            valueToProcess = _value;\r\n            if (tokensDonated < minCap && tokensDonated + valueToProcess >= minCap) {\r\n                MinCapReached(block.number);\r\n            }\r\n        }\r\n        if (!contributorList[_from].active) {\r\n            contributorList[_from].active = true;\r\n            contributorList[_from].contributionAmount = valueToProcess;\r\n            contributorIndexes[nextContributorIndex] = _from;\r\n            nextContributorIndex++;\r\n        }else{\r\n            contributorList[_from].contributionAmount += valueToProcess;\r\n        }\r\n        tokensDonated += valueToProcess;\r\n        return valueToProcess;\r\n    }\r\n\r\n    function manuallyProcessTransaction(address _from, uint _value) onlyOwner public {\r\n        require(_value != 0);\r\n        require(ERC20TokenInterface(tokenAddress).balanceOf(address(this)) >= _value + tokensDonated);\r\n\r\n        if (donationPhase == phase.pendingStart) {\r\n            if (now >= donationsStartTime) {\r\n                donationPhase = phase.started;\r\n            } else {\r\n                ERC20TokenInterface(tokenAddress).transfer(_from, _value);\r\n            }\r\n        }\r\n\r\n        if(donationPhase == phase.started) {\r\n            uint tokensToTake = processTransaction(_from, _value);\r\n            ERC20TokenInterface(tokenAddress).transfer(_from, _value - tokensToTake);\r\n        }else{\r\n            ERC20TokenInterface(tokenAddress).transfer(_from, _value);\r\n        }\r\n    }\r\n\r\n    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\r\n        require(_tokenAddress != tokenAddress);\r\n        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n\r\n    function claimFunds() public {\r\n        require(donationPhase == phase.EndedSucess);\r\n        require(athleteAlreadyClaimed < tokensDonated);\r\n        require(athlete == msg.sender);\r\n        if (lastClaimed == 0) {\r\n            lastClaimed = now;\r\n        } else {\r\n            require(lastClaimed + tick <= now);\r\n        }\r\n        uint claimAmount = (athleteCanClaimPercent * tokensDonated) / 100;\r\n        if (athleteAlreadyClaimed + claimAmount >= tokensDonated) {\r\n            claimAmount = tokensDonated - athleteAlreadyClaimed;\r\n            donationPhase = phase.finished;\r\n        }\r\n        athleteAlreadyClaimed += claimAmount;\r\n        lastClaimed += tick;\r\n        uint fee = (claimAmount * contractFee) / 100;\r\n        ERC20TokenInterface(tokenAddress).transfer(athlete, claimAmount - fee);\r\n        ERC20TokenInterface(tokenAddress).transfer(feeWallet, fee);\r\n        FundsClaimed(athlete, claimAmount, block.number);\r\n    }\r\n\r\n    function disableDonationContract() public {\r\n        require(msg.sender == athlete);\r\n        require(donationPhase == phase.EndedSucess);\r\n\r\n        donationPhase = phase.disabled;\r\n    }\r\n\r\n    function voteForDisable() public {\r\n        require(donationPhase == phase.EndedSucess);\r\n        require(contributorList[msg.sender].active);\r\n        require(!contributorList[msg.sender].hasVotedForDisable);\r\n\r\n        tokensVotedForDisable += contributorList[msg.sender].contributionAmount;\r\n        contributorList[msg.sender].hasVotedForDisable = true;\r\n\r\n        if (tokensVotedForDisable >= tokensDonated/2) {\r\n            donationPhase = phase.disabled;\r\n        }\r\n    }\r\n\r\n    function batchReturnTokensIfFailed(uint _numberOfReturns) public {\r\n        require(donationPhase == phase.EndedFail);\r\n        address currentParticipantAddress;\r\n        uint contribution;\r\n        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n            currentParticipantAddress = contributorIndexes[nextContributorToReturn];\r\n            if (currentParticipantAddress == 0x0) {\r\n                donationPhase = phase.finished;\r\n                return;\r\n            }\r\n            contribution = contributorList[currentParticipantAddress].contributionAmount;\r\n            ERC20TokenInterface(tokenAddress).transfer(currentParticipantAddress, contribution);\r\n            nextContributorToReturn += 1;\r\n        }\r\n    }\r\n\r\n    function batchReturnTokensIfDisabled(uint _numberOfReturns) public {\r\n        require(donationPhase == phase.disabled);\r\n        address currentParticipantAddress;\r\n        uint contribution;\r\n        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n            currentParticipantAddress = contributorIndexes[nextContributorToReturn];\r\n            if (currentParticipantAddress == 0x0) {\r\n                donationPhase = phase.finished;\r\n                return;\r\n            }\r\n            contribution = (contributorList[currentParticipantAddress].contributionAmount * (tokensDonated - athleteAlreadyClaimed)) / tokensDonated;\r\n            ERC20TokenInterface(tokenAddress).transfer(currentParticipantAddress, contribution);\r\n            nextContributorToReturn += 1;\r\n        }\r\n    }\r\n\r\n    function getSaleFinancialData() public constant returns(uint,uint){\r\n        return (tokensDonated, maxCap);\r\n    }\r\n\r\n    function getClaimedFinancialData() public constant returns(uint,uint){\r\n        return (athleteAlreadyClaimed, tokensDonated);\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20TokenInterface {\r\n  function totalSupply() public constant returns (uint256 _totalSupply);\r\n  function balanceOf(address _owner) public constant returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\ncontract tokenRecipientInterface {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\ncontract SportifyTokenInterface {\r\n    function mint(address _to, uint256 _amount) public;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributorIndexes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationsEndedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextContributorToReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tick\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"athlete\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getClaimedFinancialData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"athleteAlreadyClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnTokensIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorList\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"name\":\"hasVotedForDisable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextContributorIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensVotedForDisable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleFinancialData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"manuallyProcessTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableDonationContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnTokensIfDisabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensDonated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationsStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"athleteCanClaimPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"voteForDisable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_minCap\",\"type\":\"uint256\"},{\"name\":\"_maxCap\",\"type\":\"uint256\"},{\"name\":\"_donationsStartTime\",\"type\":\"uint256\"},{\"name\":\"_donationsEndedTime\",\"type\":\"uint256\"},{\"name\":\"_athleteCanClaimPercent\",\"type\":\"uint256\"},{\"name\":\"_tick\",\"type\":\"uint256\"},{\"name\":\"_athlete\",\"type\":\"address\"},{\"name\":\"_contractFee\",\"type\":\"uint256\"},{\"name\":\"_feeWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MinCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"MaxCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"athlete\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"FundsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"DonationContract","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000085089389c14bd9c77fc2b8f0c3d1dc3363bf06ef0000000000000000000000000000000000000000000000bdbc41e0348b3000000000000000000000000000000000000000000000000000bdbc41e0348b300000000000000000000000000000000000000000000000000000000000005a95aab0000000000000000000000000000000000000000000000000000000005aba4050000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b8c77100eec2494803afb4934856123dc8c5f9c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000a99ac9afcfd63623ba221dd6313ccd2c1a571ac","Library":"","SwarmSource":"bzzr://cca5b0d68f6b36f4fb0fe1e0bdc2bf7b3c3486e10efe6c522311d883f0579140"}]}