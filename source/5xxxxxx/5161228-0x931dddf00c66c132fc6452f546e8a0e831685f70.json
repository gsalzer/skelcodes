{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ninterface FundInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PortfolioContent(uint holdings, uint price, uint decimals);\r\n    event RequestUpdated(uint id);\r\n    event Invested(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event SpendingApproved(address onConsigned, address ofAsset, uint amount);\r\n    event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);\r\n    event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);\r\n    event OrderUpdated(uint id);\r\n    event LogError(uint ERROR_CODE);\r\n    event ErrorMessage(string errorMessage);\r\n\r\n    // EXTERNAL METHODS\r\n    // Compliance by Investor\r\n    function requestInvestment(uint giveQuantity, uint shareQuantity, bool isNativeAsset) external;\r\n    function requestRedemption(uint shareQuantity, uint receiveQuantity, bool isNativeAsset) external;\r\n    function executeRequest(uint requestId) external;\r\n    function cancelRequest(uint requestId) external;\r\n    function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);\r\n    // Administration by Manager\r\n    function enableInvestment() external;\r\n    function disableInvestment() external;\r\n    function enableRedemption() external;\r\n    function disableRedemption() external;\r\n    function shutDown() external;\r\n    // Managing by Manager\r\n    function makeOrder(uint exchangeId, address sellAsset, address buyAsset, uint sellQuantity, uint buyQuantity) external;\r\n    function takeOrder(uint exchangeId, uint id, uint quantity) external;\r\n    function cancelOrder(uint exchangeId, uint id) external;\r\n\r\n    // PUBLIC METHODS\r\n    function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);\r\n    function calcSharePriceAndAllocateFees() public returns (uint);\r\n\r\n\r\n    // PUBLIC VIEW METHODS\r\n    // Get general information\r\n    function getModules() view returns (address, address, address);\r\n    function getLastOrderId() view returns (uint);\r\n    function getLastRequestId() view returns (uint);\r\n    function getNameHash() view returns (bytes32);\r\n    function getManager() view returns (address);\r\n\r\n    // Get accounting information\r\n    function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);\r\n    function calcSharePrice() view returns (uint);\r\n}\r\n\r\ninterface AssetInterface {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    // Events\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n\r\n    //ERC 223\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\r\n\r\n    // ERC 20\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    // PUBLIC VIEW METHODS\r\n    function balanceOf(address _owner) view public returns (uint balance);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n}\r\n\r\ninterface ERC223Interface {\r\n    function balanceOf(address who) constant returns (uint);\r\n    function transfer(address to, uint value) returns (bool);\r\n    function transfer(address to, uint value, bytes data) returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\ninterface ERC223ReceivingContract {\r\n\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param _from Transaction initiator, analogue of msg.sender\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @param _data Data containing a function signature and/or parameters\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) public;\r\n}\r\n\r\ninterface NativeAssetInterface {\r\n\r\n    // PUBLIC METHODS\r\n    function deposit() public payable;\r\n    function withdraw(uint wad) public;\r\n}\r\n\r\ninterface SharesInterface {\r\n\r\n    event Created(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event Annihilated(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n\r\n    // VIEW METHODS\r\n\r\n    function getName() view returns (string);\r\n    function getSymbol() view returns (string);\r\n    function getDecimals() view returns (uint);\r\n    function getCreationTime() view returns (uint);\r\n    function toSmallestShareUnit(uint quantity) view returns (uint);\r\n    function toWholeShareUnit(uint quantity) view returns (uint);\r\n\r\n}\r\n\r\ninterface ComplianceInterface {\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks whether investment is permitted for a participant\r\n    /// @param ofParticipant Address requesting to invest in a Melon fund\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    /// @return Whether identity is eligible to invest in a Melon fund.\r\n    function isInvestmentPermitted(\r\n        address ofParticipant,\r\n        uint256 giveQuantity,\r\n        uint256 shareQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks whether redemption is permitted for a participant\r\n    /// @param ofParticipant Address requesting to redeem from a Melon fund\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\r\n    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\r\n    /// @return Whether identity is eligible to redeem from a Melon fund.\r\n    function isRedemptionPermitted(\r\n        address ofParticipant,\r\n        uint256 shareQuantity,\r\n        uint256 receiveQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ncontract DBC {\r\n\r\n    // MODIFIERS\r\n\r\n    modifier pre_cond(bool condition) {\r\n        require(condition);\r\n        _;\r\n    }\r\n\r\n    modifier post_cond(bool condition) {\r\n        _;\r\n        assert(condition);\r\n    }\r\n\r\n    modifier invariant(bool condition) {\r\n        require(condition);\r\n        _;\r\n        assert(condition);\r\n    }\r\n}\r\n\r\ncontract Owned is DBC {\r\n\r\n    // FIELDS\r\n\r\n    address public owner;\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    function isOwner() internal returns (bool) { return msg.sender == owner; }\r\n\r\n}\r\n\r\ninterface ExchangeInterface {\r\n\r\n    // EVENTS\r\n\r\n    event OrderUpdated(uint id);\r\n\r\n    // METHODS\r\n    // EXTERNAL METHODS\r\n\r\n    function makeOrder(\r\n        address onExchange,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) external returns (uint);\r\n    function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);\r\n    function cancelOrder(address onExchange, uint id) external returns (bool);\r\n\r\n\r\n    // PUBLIC METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function isApproveOnly() view returns (bool);\r\n    function getLastOrderId(address onExchange) view returns (uint);\r\n    function isActive(address onExchange, uint id) view returns (bool);\r\n    function getOwner(address onExchange, uint id) view returns (address);\r\n    function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);\r\n    function getTimestamp(address onExchange, uint id) view returns (uint);\r\n\r\n}\r\n\r\ninterface PriceFeedInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PriceUpdated(uint timestamp);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function update(address[] ofAssets, uint[] newPrices);\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get asset specific information\r\n    function getName(address ofAsset) view returns (string);\r\n    function getSymbol(address ofAsset) view returns (string);\r\n    function getDecimals(address ofAsset) view returns (uint);\r\n    // Get price feed operation specific information\r\n    function getQuoteAsset() view returns (address);\r\n    function getInterval() view returns (uint);\r\n    function getValidity() view returns (uint);\r\n    function getLastUpdateId() view returns (uint);\r\n    // Get asset specific information as updated in price feed\r\n    function hasRecentPrice(address ofAsset) view returns (bool isRecent);\r\n    function hasRecentPrices(address[] ofAssets) view returns (bool areRecent);\r\n    function getPrice(address ofAsset) view returns (bool isRecent, uint price, uint decimal);\r\n    function getPrices(address[] ofAssets) view returns (bool areRecent, uint[] prices, uint[] decimals);\r\n    function getInvertedPrice(address ofAsset) view returns (bool isRecent, uint invertedPrice, uint decimal);\r\n    function getReferencePrice(address ofBase, address ofQuote) view returns (bool isRecent, uint referencePrice, uint decimal);\r\n    function getOrderPrice(\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (uint orderPrice);\r\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset) view returns (bool isExistent);\r\n}\r\n\r\ninterface RiskMgmtInterface {\r\n\r\n    // METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks if the makeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If makeOrder is permitted\r\n    function isMakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks if the takeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If takeOrder is permitted\r\n    function isTakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ninterface VersionInterface {\r\n\r\n    // EVENTS\r\n\r\n    event FundUpdated(uint id);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function shutDown() external;\r\n\r\n    function setupFund(\r\n        string ofFundName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address ofPriceFeed,\r\n        address[] ofExchanges,\r\n        address[] ofExchangeAdapters,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n    function shutDownFund(address ofFund);\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getNativeAsset() view returns (address);\r\n    function getFundById(uint withId) view returns (address);\r\n    function getLastFundId() view returns (uint);\r\n    function getFundByManager(address ofManager) view returns (address);\r\n    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\r\n\r\n}\r\n\r\ncontract Version is DBC, Owned, VersionInterface {\r\n    // FIELDS\r\n\r\n    // Constant fields\r\n    bytes32 public constant TERMS_AND_CONDITIONS = 0xAA9C907B0D6B4890E7225C09CBC16A01CB97288840201AA7CDCB27F4ED7BF159; // Hashed terms and conditions as displayed on IPFS, decoded from base 58\r\n    address public COMPLIANCE = 0xFb5978C7ca78074B2044034CbdbC3f2E03Dfe2bA; // restrict to OnlyManager compliance module for this version\r\n\r\n    // Constructor fields\r\n    string public VERSION_NUMBER; // SemVer of Melon protocol version\r\n    address public NATIVE_ASSET; // Address of wrapped native asset contract\r\n    address public GOVERNANCE; // Address of Melon protocol governance contract\r\n    bool public IS_MAINNET;  // whether this contract is on the mainnet (to use hardcoded module)\r\n\r\n    // Methods fields\r\n    bool public isShutDown; // Governance feature, if yes than setupFund gets blocked and shutDownFund gets opened\r\n    address[] public listOfFunds; // A complete list of fund addresses created using this version\r\n    mapping (address => address) public managerToFunds; // Links manager address to fund address created using this version\r\n\r\n    // EVENTS\r\n\r\n    event FundUpdated(address ofFund);\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param versionNumber SemVer of Melon protocol version\r\n    /// @param ofGovernance Address of Melon governance contract\r\n    /// @param ofNativeAsset Address of wrapped native asset contract\r\n    function Version(\r\n        string versionNumber,\r\n        address ofGovernance,\r\n        address ofNativeAsset,\r\n        bool isMainnet\r\n    ) {\r\n        VERSION_NUMBER = versionNumber;\r\n        GOVERNANCE = ofGovernance;\r\n        NATIVE_ASSET = ofNativeAsset;\r\n        IS_MAINNET = isMainnet;\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    function shutDown() external pre_cond(msg.sender == GOVERNANCE) { isShutDown = true; }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @param ofFundName human-readable descriptive name (not necessarily unique)\r\n    /// @param ofQuoteAsset Asset against which performance fee is measured against\r\n    /// @param ofManagementFee A time based fee, given in a number which is divided by 10 ** 15\r\n    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 10 ** 15\r\n    /// @param ofCompliance Address of participation module\r\n    /// @param ofRiskMgmt Address of risk management module\r\n    /// @param ofPriceFeed Address of price feed module\r\n    /// @param ofExchanges Addresses of exchange on which this fund can trade\r\n    /// @param ofExchangeAdapters Addresses of exchange adapters\r\n    /// @param v ellipitc curve parameter v\r\n    /// @param r ellipitc curve parameter r\r\n    /// @param s ellipitc curve parameter s\r\n    function setupFund(\r\n        string ofFundName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address ofPriceFeed,\r\n        address[] ofExchanges,\r\n        address[] ofExchangeAdapters,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) {\r\n        require(!isShutDown);\r\n        require(termsAndConditionsAreSigned(v, r, s));\r\n        // Either novel fund name or previous owner of fund name\r\n        require(managerToFunds[msg.sender] == 0); // Add limitation for simpler migration process of shutting down and setting up fund\r\n        if (IS_MAINNET) {\r\n            ofCompliance = COMPLIANCE;  // only for this version, with restricted compliance module on mainnet\r\n        }\r\n        address ofFund = new Fund(\r\n            msg.sender,\r\n            ofFundName,\r\n            ofQuoteAsset,\r\n            ofManagementFee,\r\n            ofPerformanceFee,\r\n            NATIVE_ASSET,\r\n            ofCompliance,\r\n            ofRiskMgmt,\r\n            ofPriceFeed,\r\n            ofExchanges,\r\n            ofExchangeAdapters\r\n        );\r\n        listOfFunds.push(ofFund);\r\n        managerToFunds[msg.sender] = ofFund;\r\n        FundUpdated(ofFund);\r\n    }\r\n\r\n    /// @dev Dereference Fund and trigger selfdestruct\r\n    /// @param ofFund Address of the fund to be shut down\r\n    function shutDownFund(address ofFund)\r\n        pre_cond(isShutDown || managerToFunds[msg.sender] == ofFund)\r\n    {\r\n        Fund fund = Fund(ofFund);\r\n        delete managerToFunds[msg.sender];\r\n        fund.shutDown();\r\n        FundUpdated(ofFund);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @dev Proof that terms and conditions have been read and understood\r\n    /// @param v ellipitc curve parameter v\r\n    /// @param r ellipitc curve parameter r\r\n    /// @param s ellipitc curve parameter s\r\n    /// @return signed Whether or not terms and conditions have been read and understood\r\n    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) {\r\n        return ecrecover(\r\n            // Parity does prepend \\x19Ethereum Signed Message:\\n{len(message)} before signing.\r\n            //  Signature order has also been changed in 1.6.7 and upcoming 1.7.x,\r\n            //  it will return rsv (same as geth; where v is [27, 28]).\r\n            // Note that if you are using ecrecover, v will be either \"00\" or \"01\".\r\n            //  As a result, in order to use this value, you will have to parse it to an\r\n            //  integer and then add 27. This will result in either a 27 or a 28.\r\n            //  https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsign\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", TERMS_AND_CONDITIONS),\r\n            v,\r\n            r,\r\n            s\r\n        ) == msg.sender; // Has sender signed TERMS_AND_CONDITIONS\r\n    }\r\n\r\n    function getNativeAsset() view returns (address) { return NATIVE_ASSET; }\r\n    function getFundById(uint withId) view returns (address) { return listOfFunds[withId]; }\r\n    function getLastFundId() view returns (uint) { return listOfFunds.length - 1; }\r\n    function getFundByManager(address ofManager) view returns (address) { return managerToFunds[ofManager]; }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Asset is DSMath, AssetInterface, ERC223Interface {\r\n\r\n    // DATA STRUCTURES\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint codeLength;\r\n        bytes memory empty;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n \r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        // if (codeLength > 0) {\r\n        //     ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n        //     receiver.tokenFallback(msg.sender, _value, empty);\r\n        // }\r\n        Transfer(msg.sender, _to, _value, empty);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender` and trigger tokenFallback if sender is a contract\r\n     * @dev Function that is called when a user or contract wants to transfer funds\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @param _data Data to be sent to tokenFallback\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value, bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        // if (codeLength > 0) {\r\n        //     ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n        //     receiver.tokenFallback(msg.sender, _value, _data);\r\n        // }\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    /// @notice Restriction: An account can only use this function to send to itself\r\n    /// @dev Allows for an approved third party to transfer tokens from one\r\n    /// address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_from != 0x0);\r\n        require(_to != 0x0);\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n        // require(_to == msg.sender); // can only use transferFrom to send to self\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(_spender != 0x0);\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        // allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        // already 0 to mitigate the race condition described here:\r\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        // require(_value == 0 || allowed[msg.sender][_spender] == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @dev Returns number of allowed tokens that a spender can transfer on\r\n    /// behalf of a token owner.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    /// @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by the given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns balance of owner.\r\n    function balanceOf(address _owner) constant public returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\ncontract Shares is Asset, SharesInterface {\r\n\r\n    // FIELDS\r\n\r\n    // Constructor fields\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimal;\r\n    uint public creationTime;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param _name Name these shares\r\n    /// @param _symbol Symbol of shares\r\n    /// @param _decimal Amount of decimals sharePrice is denominated in, defined to be equal as deciamls in REFERENCE_ASSET contract\r\n    /// @param _creationTime Timestamp of share creation\r\n    function Shares(string _name, string _symbol, uint _decimal, uint _creationTime) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimal = _decimal;\r\n        creationTime = _creationTime;\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getName() view returns (string) { return name; }\r\n    function getSymbol() view returns (string) { return symbol; }\r\n    function getDecimals() view returns (uint) { return decimal; }\r\n    function getCreationTime() view returns (uint) { return creationTime; }\r\n    function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }\r\n    function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }\r\n    function transfer(address _to, uint256 _value) public returns (bool) { require(_to == address(this)); }\r\n    function transfer(address _to, uint256 _value, bytes _data) public returns (bool) { require(_to == address(this)); }\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to == address(this)); }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @param recipient Address the new shares should be sent to\r\n    /// @param shareQuantity Number of shares to be created\r\n    function createShares(address recipient, uint shareQuantity) internal {\r\n        totalSupply = add(totalSupply, shareQuantity);\r\n        balances[recipient] = add(balances[recipient], shareQuantity);\r\n        Created(msg.sender, now, shareQuantity);\r\n    }\r\n\r\n    /// @param recipient Address the new shares should be taken from when destroyed\r\n    /// @param shareQuantity Number of shares to be annihilated\r\n    function annihilateShares(address recipient, uint shareQuantity) internal {\r\n        totalSupply = sub(totalSupply, shareQuantity);\r\n        balances[recipient] = sub(balances[recipient], shareQuantity);\r\n        Annihilated(msg.sender, now, shareQuantity);\r\n    }\r\n}\r\n\r\ncontract RestrictedShares is Shares {\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param _name Name these shares\r\n    /// @param _symbol Symbol of shares\r\n    /// @param _decimal Amount of decimals sharePrice is denominated in, defined to be equal as deciamls in REFERENCE_ASSET contract\r\n    /// @param _creationTime Timestamp of share creation\r\n    function RestrictedShares(\r\n        string _name,\r\n        string _symbol,\r\n        uint _decimal,\r\n        uint _creationTime\r\n    ) Shares(_name, _symbol, _decimal, _creationTime) {}\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(msg.sender == address(this) || _to == address(this));\r\n        uint codeLength;\r\n        bytes memory empty;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        if (codeLength > 0) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, empty);\r\n        }\r\n        Transfer(msg.sender, _to, _value, empty);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender` and trigger tokenFallback if sender is a contract\r\n     * @dev Function that is called when a user or contract wants to transfer funds\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @param _data Data to be sent to tokenFallback\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value, bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(msg.sender == address(this) || _to == address(this));\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        if (codeLength > 0) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(msg.sender == address(this));\r\n        require(_spender != 0x0);\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        // allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        // already 0 to mitigate the race condition described here:\r\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require(_value == 0 || allowed[msg.sender][_spender] == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract Fund is DSMath, DBC, Owned, RestrictedShares, FundInterface, ERC223ReceivingContract {\r\n    // TYPES\r\n\r\n    struct Modules { // Describes all modular parts, standardised through an interface\r\n        PriceFeedInterface pricefeed; // Provides all external data\r\n        ComplianceInterface compliance; // Boolean functions regarding invest/redeem\r\n        RiskMgmtInterface riskmgmt; // Boolean functions regarding make/take orders\r\n    }\r\n\r\n    struct Calculations { // List of internal calculations\r\n        uint gav; // Gross asset value\r\n        uint managementFee; // Time based fee\r\n        uint performanceFee; // Performance based fee measured against QUOTE_ASSET\r\n        uint unclaimedFees; // Fees not yet allocated to the fund manager\r\n        uint nav; // Net asset value\r\n        uint highWaterMark; // A record of best all-time fund performance\r\n        uint totalSupply; // Total supply of shares\r\n        uint timestamp; // Time when calculations are performed in seconds\r\n    }\r\n\r\n    enum RequestStatus { active, cancelled, executed }\r\n    enum RequestType { invest, redeem, tokenFallbackRedeem }\r\n    struct Request { // Describes and logs whenever asset enter and leave fund due to Participants\r\n        address participant; // Participant in Melon fund requesting investment or redemption\r\n        RequestStatus status; // Enum: active, cancelled, executed; Status of request\r\n        RequestType requestType; // Enum: invest, redeem, tokenFallbackRedeem\r\n        address requestAsset; // Address of the asset being requested\r\n        uint shareQuantity; // Quantity of Melon fund shares\r\n        uint giveQuantity; // Quantity in Melon asset to give to Melon fund to receive shareQuantity\r\n        uint receiveQuantity; // Quantity in Melon asset to receive from Melon fund for given shareQuantity\r\n        uint timestamp;     // Time of request creation in seconds\r\n        uint atUpdateId;    // Pricefeed updateId when this request was created\r\n    }\r\n\r\n    enum OrderStatus { active, partiallyFilled, fullyFilled, cancelled }\r\n    enum OrderType { make, take }\r\n    struct Order { // Describes and logs whenever assets enter and leave fund due to Manager\r\n        uint exchangeId; // Id as returned from exchange\r\n        OrderStatus status; // Enum: active, partiallyFilled, fullyFilled, cancelled\r\n        OrderType orderType; // Enum: make, take\r\n        address sellAsset; // Asset (as registered in Asset registrar) to be sold\r\n        address buyAsset; // Asset (as registered in Asset registrar) to be bought\r\n        uint sellQuantity; // Quantity of sellAsset to be sold\r\n        uint buyQuantity; // Quantity of sellAsset to be bought\r\n        uint timestamp; // Time of order creation in seconds\r\n        uint fillQuantity; // Buy quantity filled; Always less than buy_quantity\r\n    }\r\n\r\n    struct Exchange {\r\n        address exchange; // Address of the exchange\r\n        ExchangeInterface exchangeAdapter; //Exchange adapter contracts respective to the exchange\r\n        bool isApproveOnly; // True in case of exchange implementation which requires  are approved when an order is made instead of transfer\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // Constant fields\r\n    uint public constant MAX_FUND_ASSETS = 4; // Max ownable assets by the fund supported by gas limits\r\n    // Constructor fields\r\n    uint public MANAGEMENT_FEE_RATE; // Fee rate in QUOTE_ASSET per delta improvement in WAD\r\n    uint public PERFORMANCE_FEE_RATE; // Fee rate in QUOTE_ASSET per managed seconds in WAD\r\n    address public VERSION; // Address of Version contract\r\n    Asset public QUOTE_ASSET; // QUOTE asset as ERC20 contract\r\n    NativeAssetInterface public NATIVE_ASSET; // Native asset as ERC20 contract\r\n    // Methods fields\r\n    Modules public module; // Struct which holds all the initialised module instances\r\n    Exchange[] public exchanges; // Array containing exchanges this fund supports\r\n    Calculations public atLastUnclaimedFeeAllocation; // Calculation results at last allocateUnclaimedFees() call\r\n    bool public isShutDown; // Security feature, if yes than investing, managing, allocateUnclaimedFees gets blocked\r\n    Request[] public requests; // All the requests this fund received from participants\r\n    bool public isInvestAllowed; // User option, if false fund rejects Melon investments\r\n    bool public isRedeemAllowed; // User option, if false fund rejects Melon redemptions; Redemptions using slices always possible\r\n    Order[] public orders; // All the orders this fund placed on exchanges\r\n    mapping (uint => mapping(address => uint)) public exchangeIdsToOpenMakeOrderIds; // exchangeIndex to: asset to open make order ID ; if no open make orders, orderID is zero\r\n    address[] public ownedAssets; // List of all assets owned by the fund or for which the fund has open make orders\r\n    mapping (address => bool) public isInAssetList; // Mapping from asset to whether the asset exists in ownedAssets\r\n    mapping (address => bool) public isInOpenMakeOrder; // Mapping from asset to whether the asset is in a open make order as buy asset\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Should only be called via Version.setupFund(..)\r\n    /// @param withName human-readable descriptive name (not necessarily unique)\r\n    /// @param ofQuoteAsset Asset against which mgmt and performance fee is measured against and which can be used to invest/redeem using this single asset\r\n    /// @param ofManagementFee A time based fee expressed, given in a number which is divided by 1 WAD\r\n    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 1 WAD\r\n    /// @param ofCompliance Address of compliance module\r\n    /// @param ofRiskMgmt Address of risk management module\r\n    /// @param ofPriceFeed Address of price feed module\r\n    /// @param ofExchanges Addresses of exchange on which this fund can trade\r\n    /// @param ofExchangeAdapters Addresses of exchange adapters\r\n    /// @return Deployed Fund with manager set as ofManager\r\n    function Fund(\r\n        address ofManager,\r\n        string withName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofNativeAsset,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address ofPriceFeed,\r\n        address[] ofExchanges,\r\n        address[] ofExchangeAdapters\r\n    )\r\n        RestrictedShares(withName, \"MLNF\", 18, now)\r\n    {\r\n        isInvestAllowed = true;\r\n        isRedeemAllowed = true;\r\n        owner = ofManager;\r\n        require(ofManagementFee < 10 ** 18); // Require management fee to be less than 100 percent\r\n        MANAGEMENT_FEE_RATE = ofManagementFee; // 1 percent is expressed as 0.01 * 10 ** 18\r\n        require(ofPerformanceFee < 10 ** 18); // Require performance fee to be less than 100 percent\r\n        PERFORMANCE_FEE_RATE = ofPerformanceFee; // 1 percent is expressed as 0.01 * 10 ** 18\r\n        VERSION = msg.sender;\r\n        module.compliance = ComplianceInterface(ofCompliance);\r\n        module.riskmgmt = RiskMgmtInterface(ofRiskMgmt);\r\n        module.pricefeed = PriceFeedInterface(ofPriceFeed);\r\n        // Bridged to Melon exchange interface by exchangeAdapter library\r\n        for (uint i = 0; i < ofExchanges.length; ++i) {\r\n            ExchangeInterface adapter = ExchangeInterface(ofExchangeAdapters[i]);\r\n            bool isApproveOnly = adapter.isApproveOnly();\r\n            exchanges.push(Exchange({\r\n                exchange: ofExchanges[i],\r\n                exchangeAdapter: adapter,\r\n                isApproveOnly: isApproveOnly\r\n            }));\r\n        }\r\n        // Require Quote assets exists in pricefeed\r\n        QUOTE_ASSET = Asset(ofQuoteAsset);\r\n        NATIVE_ASSET = NativeAssetInterface(ofNativeAsset);\r\n        // Quote Asset and Native asset always in owned assets list\r\n        ownedAssets.push(ofQuoteAsset);\r\n        isInAssetList[ofQuoteAsset] = true;\r\n        ownedAssets.push(ofNativeAsset);\r\n        isInAssetList[ofNativeAsset] = true;\r\n        require(address(QUOTE_ASSET) == module.pricefeed.getQuoteAsset()); // Sanity check\r\n        atLastUnclaimedFeeAllocation = Calculations({\r\n            gav: 0,\r\n            managementFee: 0,\r\n            performanceFee: 0,\r\n            unclaimedFees: 0,\r\n            nav: 0,\r\n            highWaterMark: 10 ** getDecimals(),\r\n            totalSupply: totalSupply,\r\n            timestamp: now\r\n        });\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    // EXTERNAL : ADMINISTRATION\r\n\r\n    function enableInvestment() external pre_cond(isOwner()) { isInvestAllowed = true; }\r\n    function disableInvestment() external pre_cond(isOwner()) { isInvestAllowed = false; }\r\n    function enableRedemption() external pre_cond(isOwner()) { isRedeemAllowed = true; }\r\n    function disableRedemption() external pre_cond(isOwner()) { isRedeemAllowed = false; }\r\n    function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }\r\n\r\n\r\n    // EXTERNAL : PARTICIPATION\r\n\r\n    /// @notice Give melon tokens to receive shares of this fund\r\n    /// @dev Recommended to give some leeway in prices to account for possibly slightly changing prices\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    function requestInvestment(\r\n        uint giveQuantity,\r\n        uint shareQuantity,\r\n        bool isNativeAsset\r\n    )\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(isInvestAllowed) // investment using Melon has not been deactivated by the Manager\r\n        pre_cond(module.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))    // Compliance Module: Investment permitted\r\n    {\r\n        requests.push(Request({\r\n            participant: msg.sender,\r\n            status: RequestStatus.active,\r\n            requestType: RequestType.invest,\r\n            requestAsset: isNativeAsset ? address(NATIVE_ASSET) : address(QUOTE_ASSET),\r\n            shareQuantity: shareQuantity,\r\n            giveQuantity: giveQuantity,\r\n            receiveQuantity: shareQuantity,\r\n            timestamp: now,\r\n            atUpdateId: module.pricefeed.getLastUpdateId()\r\n        }));\r\n        RequestUpdated(getLastRequestId());\r\n    }\r\n\r\n    /// @notice Give shares of this fund to receive melon tokens\r\n    /// @dev Recommended to give some leeway in prices to account for possibly slightly changing prices\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\r\n    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\r\n    function requestRedemption(\r\n        uint shareQuantity,\r\n        uint receiveQuantity,\r\n        bool isNativeAsset\r\n      )\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(isRedeemAllowed) // Redemption using Melon has not been deactivated by Manager\r\n        pre_cond(module.compliance.isRedemptionPermitted(msg.sender, shareQuantity, receiveQuantity)) // Compliance Module: Redemption permitted\r\n    {\r\n        requests.push(Request({\r\n            participant: msg.sender,\r\n            status: RequestStatus.active,\r\n            requestType: RequestType.redeem,\r\n            requestAsset: isNativeAsset ? address(NATIVE_ASSET) : address(QUOTE_ASSET),\r\n            shareQuantity: shareQuantity,\r\n            giveQuantity: shareQuantity,\r\n            receiveQuantity: receiveQuantity,\r\n            timestamp: now,\r\n            atUpdateId: module.pricefeed.getLastUpdateId()\r\n        }));\r\n        RequestUpdated(getLastRequestId());\r\n    }\r\n\r\n    /// @notice Executes active investment and redemption requests, in a way that minimises information advantages of investor\r\n    /// @dev Distributes melon and shares according to the request\r\n    /// @param id Index of request to be executed\r\n    /// @dev Active investment or redemption request executed\r\n    function executeRequest(uint id)\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(requests[id].status == RequestStatus.active)\r\n        pre_cond(requests[id].requestType != RequestType.redeem || requests[id].shareQuantity <= balances[requests[id].participant]) // request owner does not own enough shares\r\n        pre_cond(\r\n            totalSupply == 0 ||\r\n            (\r\n                now >= add(requests[id].timestamp, module.pricefeed.getInterval()) &&\r\n                module.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)\r\n            )\r\n        )   // PriceFeed Module: Wait at least one interval time and two updates before continuing (unless it is the first investment)\r\n\r\n    {\r\n        Request request = requests[id];\r\n        // PriceFeed Module: No recent updates for fund asset list\r\n        require(module.pricefeed.hasRecentPrice(address(request.requestAsset)));\r\n\r\n        // sharePrice quoted in QUOTE_ASSET and multiplied by 10 ** fundDecimals\r\n        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees())); // By definition quoteDecimals == fundDecimals\r\n        if (request.requestAsset == address(NATIVE_ASSET)) {\r\n            var (isPriceRecent, invertedNativeAssetPrice, nativeAssetDecimal) = module.pricefeed.getInvertedPrice(address(NATIVE_ASSET));\r\n            if (!isPriceRecent) {\r\n                revert();\r\n            }\r\n            costQuantity = mul(costQuantity, invertedNativeAssetPrice) / 10 ** nativeAssetDecimal;\r\n        }\r\n\r\n        if (\r\n            isInvestAllowed &&\r\n            request.requestType == RequestType.invest &&\r\n            costQuantity <= request.giveQuantity\r\n        ) {\r\n            request.status = RequestStatus.executed;\r\n            assert(AssetInterface(request.requestAsset).transferFrom(request.participant, this, costQuantity)); // Allocate Value\r\n            createShares(request.participant, request.shareQuantity); // Accounting\r\n        } else if (\r\n            isRedeemAllowed &&\r\n            request.requestType == RequestType.redeem &&\r\n            request.receiveQuantity <= costQuantity\r\n        ) {\r\n            request.status = RequestStatus.executed;\r\n            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity)); // Return value\r\n            annihilateShares(request.participant, request.shareQuantity); // Accounting\r\n        } else if (\r\n            isRedeemAllowed &&\r\n            request.requestType == RequestType.tokenFallbackRedeem &&\r\n            request.receiveQuantity <= costQuantity\r\n        ) {\r\n            request.status = RequestStatus.executed;\r\n            assert(AssetInterface(request.requestAsset).transfer(request.participant, costQuantity)); // Return value\r\n            annihilateShares(this, request.shareQuantity); // Accounting\r\n        } else {\r\n            revert(); // Invalid Request or invalid giveQuantity / receiveQuantity\r\n        }\r\n    }\r\n\r\n    /// @notice Cancels active investment and redemption requests\r\n    /// @param id Index of request to be executed\r\n    function cancelRequest(uint id)\r\n        external\r\n        pre_cond(requests[id].status == RequestStatus.active) // Request is active\r\n        pre_cond(requests[id].participant == msg.sender || isShutDown) // Either request creator or fund is shut down\r\n    {\r\n        requests[id].status = RequestStatus.cancelled;\r\n    }\r\n\r\n    /// @notice Redeems by allocating an ownership percentage of each asset to the participant\r\n    /// @dev Independent of running price feed!\r\n    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for individual assets\r\n    /// @return Whether all assets sent to shareholder or not\r\n    function redeemAllOwnedAssets(uint shareQuantity)\r\n        external\r\n        returns (bool success)\r\n    {\r\n        return emergencyRedeem(shareQuantity, ownedAssets);\r\n    }\r\n\r\n    // EXTERNAL : MANAGING\r\n\r\n    /// @notice Makes an order on the selected exchange\r\n    /// @dev These are orders that are not expected to settle immediately.  Sufficient balance (== sellQuantity) of sellAsset\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    function makeOrder(\r\n        uint exchangeNumber,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        external\r\n        pre_cond(isOwner())\r\n        pre_cond(!isShutDown)\r\n    {\r\n        require(buyAsset != address(this)); // Prevent buying of own fund token\r\n        require(quantityHeldInCustodyOfExchange(sellAsset) == 0); // Curr only one make order per sellAsset allowed. Please wait or cancel existing make order.\r\n        require(module.pricefeed.existsPriceOnAssetPair(sellAsset, buyAsset)); // PriceFeed module: Requested asset pair not valid\r\n        var (isRecent, referencePrice, ) = module.pricefeed.getReferencePrice(sellAsset, buyAsset);\r\n        require(isRecent);  // Reference price is required to be recent\r\n        require(\r\n            module.riskmgmt.isMakePermitted(\r\n                module.pricefeed.getOrderPrice(\r\n                    sellAsset,\r\n                    buyAsset,\r\n                    sellQuantity,\r\n                    buyQuantity\r\n                ),\r\n                referencePrice,\r\n                sellAsset,\r\n                buyAsset,\r\n                sellQuantity,\r\n                buyQuantity\r\n            )\r\n        ); // RiskMgmt module: Make order not permitted\r\n        require(isInAssetList[buyAsset] || ownedAssets.length < MAX_FUND_ASSETS); // Limit for max ownable assets by the fund reached\r\n        require(AssetInterface(sellAsset).approve(exchanges[exchangeNumber].exchange, sellQuantity)); // Approve exchange to spend assets\r\n\r\n        // Since there is only one openMakeOrder allowed for each asset, we can assume that openMakeOrderId is set as zero by quantityHeldInCustodyOfExchange() function\r\n        require(address(exchanges[exchangeNumber].exchangeAdapter).delegatecall(bytes4(keccak256(\"makeOrder(address,address,address,uint256,uint256)\")), exchanges[exchangeNumber].exchange, sellAsset, buyAsset, sellQuantity, buyQuantity));\r\n        exchangeIdsToOpenMakeOrderIds[exchangeNumber][sellAsset] = exchanges[exchangeNumber].exchangeAdapter.getLastOrderId(exchanges[exchangeNumber].exchange);\r\n\r\n        // Success defined as non-zero order id\r\n        require(exchangeIdsToOpenMakeOrderIds[exchangeNumber][sellAsset] != 0);\r\n\r\n        // Update ownedAssets array and isInAssetList, isInOpenMakeOrder mapping\r\n        isInOpenMakeOrder[buyAsset] = true;\r\n        if (!isInAssetList[buyAsset]) {\r\n            ownedAssets.push(buyAsset);\r\n            isInAssetList[buyAsset] = true;\r\n        }\r\n\r\n        orders.push(Order({\r\n            exchangeId: exchangeIdsToOpenMakeOrderIds[exchangeNumber][sellAsset],\r\n            status: OrderStatus.active,\r\n            orderType: OrderType.make,\r\n            sellAsset: sellAsset,\r\n            buyAsset: buyAsset,\r\n            sellQuantity: sellQuantity,\r\n            buyQuantity: buyQuantity,\r\n            timestamp: now,\r\n            fillQuantity: 0\r\n        }));\r\n\r\n        OrderUpdated(exchangeIdsToOpenMakeOrderIds[exchangeNumber][sellAsset]);\r\n    }\r\n\r\n    /// @notice Takes an active order on the selected exchange\r\n    /// @dev These are orders that are expected to settle immediately\r\n    /// @param id Active order id\r\n    /// @param receiveQuantity Buy quantity of what others are selling on selected Exchange\r\n    function takeOrder(uint exchangeNumber, uint id, uint receiveQuantity)\r\n        external\r\n        pre_cond(isOwner())\r\n        pre_cond(!isShutDown)\r\n    {\r\n        // Get information of order by order id\r\n        Order memory order; // Inverse variable terminology! Buying what another person is selling\r\n        (\r\n            order.sellAsset,\r\n            order.buyAsset,\r\n            order.sellQuantity,\r\n            order.buyQuantity\r\n        ) = exchanges[exchangeNumber].exchangeAdapter.getOrder(exchanges[exchangeNumber].exchange, id);\r\n        // Check pre conditions\r\n        require(order.sellAsset != address(this)); // Prevent buying of own fund token\r\n        require(module.pricefeed.existsPriceOnAssetPair(order.buyAsset, order.sellAsset)); // PriceFeed module: Requested asset pair not valid\r\n        require(isInAssetList[order.sellAsset] || ownedAssets.length < MAX_FUND_ASSETS); // Limit for max ownable assets by the fund reached\r\n        var (isRecent, referencePrice, ) = module.pricefeed.getReferencePrice(order.buyAsset, order.sellAsset);\r\n        require(isRecent); // Reference price is required to be recent\r\n        require(receiveQuantity <= order.sellQuantity); // Not enough quantity of order for what is trying to be bought\r\n        uint spendQuantity = mul(receiveQuantity, order.buyQuantity) / order.sellQuantity;\r\n        require(AssetInterface(order.buyAsset).approve(exchanges[exchangeNumber].exchange, spendQuantity)); // Could not approve spending of spendQuantity of order.buyAsset\r\n        require(\r\n            module.riskmgmt.isTakePermitted(\r\n            module.pricefeed.getOrderPrice(\r\n                order.buyAsset,\r\n                order.sellAsset,\r\n                order.buyQuantity, // spendQuantity\r\n                order.sellQuantity // receiveQuantity\r\n            ),\r\n            referencePrice,\r\n            order.buyAsset,\r\n            order.sellAsset,\r\n            order.buyQuantity,\r\n            order.sellQuantity\r\n        )); // RiskMgmt module: Take order not permitted\r\n\r\n        // Execute request\r\n        require(address(exchanges[exchangeNumber].exchangeAdapter).delegatecall(bytes4(keccak256(\"takeOrder(address,uint256,uint256)\")), exchanges[exchangeNumber].exchange, id, receiveQuantity));\r\n\r\n        // Update ownedAssets array and isInAssetList mapping\r\n        if (!isInAssetList[order.sellAsset]) {\r\n            ownedAssets.push(order.sellAsset);\r\n            isInAssetList[order.sellAsset] = true;\r\n        }\r\n\r\n        order.exchangeId = id;\r\n        order.status = OrderStatus.fullyFilled;\r\n        order.orderType = OrderType.take;\r\n        order.timestamp = now;\r\n        order.fillQuantity = receiveQuantity;\r\n        orders.push(order);\r\n        OrderUpdated(id);\r\n    }\r\n\r\n    /// @notice Cancels orders that were not expected to settle immediately, i.e. makeOrders\r\n    /// @dev Reduce exposure with exchange interaction\r\n    /// @param id Active order id of this order array with order owner of this contract on selected Exchange\r\n    function cancelOrder(uint exchangeNumber, uint id)\r\n        external\r\n        pre_cond(isOwner() || isShutDown)\r\n    {\r\n        // Get information of fund order by order id\r\n        Order order = orders[id];\r\n\r\n        // Execute request\r\n        require(address(exchanges[exchangeNumber].exchangeAdapter).delegatecall(bytes4(keccak256(\"cancelOrder(address,uint256)\")), exchanges[exchangeNumber].exchange, order.exchangeId));\r\n\r\n        order.status = OrderStatus.cancelled;\r\n        OrderUpdated(id);\r\n    }\r\n\r\n\r\n    // PUBLIC METHODS\r\n\r\n    // PUBLIC METHODS : ERC223\r\n\r\n    /// @dev Standard ERC223 function that handles incoming token transfers.\r\n    /// @dev This type of redemption can be seen as a \"market order\", where price is calculated at execution time\r\n    /// @param ofSender  Token sender address.\r\n    /// @param tokenAmount Amount of tokens sent.\r\n    /// @param metadata  Transaction metadata.\r\n    function tokenFallback(\r\n        address ofSender,\r\n        uint tokenAmount,\r\n        bytes metadata\r\n    ) {\r\n        if (msg.sender != address(this)) {\r\n            // when ofSender is a recognized exchange, receive tokens, otherwise revert\r\n            for (uint i; i < exchanges.length; i++) {\r\n                if (exchanges[i].exchange == ofSender) return; // receive tokens and do nothing\r\n            }\r\n            revert();\r\n        } else {    // otherwise, make a redemption request\r\n            requests.push(Request({\r\n                participant: ofSender,\r\n                status: RequestStatus.active,\r\n                requestType: RequestType.tokenFallbackRedeem,\r\n                requestAsset: address(QUOTE_ASSET), // redeem in QUOTE_ASSET\r\n                shareQuantity: tokenAmount,\r\n                giveQuantity: tokenAmount,              // shares being sent\r\n                receiveQuantity: 0,          // value of the shares at request time\r\n                timestamp: now,\r\n                atUpdateId: module.pricefeed.getLastUpdateId()\r\n            }));\r\n            RequestUpdated(getLastRequestId());\r\n        }\r\n    }\r\n\r\n\r\n    // PUBLIC METHODS : ACCOUNTING\r\n\r\n    /// @notice Calculates gross asset value of the fund\r\n    /// @dev Decimals in assets must be equal to decimals in PriceFeed for all entries in AssetRegistrar\r\n    /// @dev Assumes that module.pricefeed.getPrice(..) returns recent prices\r\n    /// @return gav Gross asset value quoted in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcGav() returns (uint gav) {\r\n        // prices quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        address[] memory tempOwnedAssets; // To store ownedAssets\r\n        tempOwnedAssets = ownedAssets;\r\n        delete ownedAssets;\r\n        for (uint i = 0; i < tempOwnedAssets.length; ++i) {\r\n            address ofAsset = tempOwnedAssets[i];\r\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\r\n            uint assetHoldings = add(\r\n                uint(AssetInterface(ofAsset).balanceOf(this)), // asset base units held by fund\r\n                quantityHeldInCustodyOfExchange(ofAsset)\r\n            );\r\n            // assetPrice formatting: mul(exchangePrice, 10 ** assetDecimal)\r\n            var (isRecent, assetPrice, assetDecimals) = module.pricefeed.getPrice(ofAsset);\r\n            if (!isRecent) {\r\n                revert();\r\n            }\r\n            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\r\n            gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));   // Sum up product of asset holdings of this vault and asset prices\r\n            if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || ofAsset == address(NATIVE_ASSET) || isInOpenMakeOrder[ofAsset]) { // Check if asset holdings is not zero or is address(QUOTE_ASSET) or in open make order\r\n                ownedAssets.push(ofAsset);\r\n            } else {\r\n                isInAssetList[ofAsset] = false; // Remove from ownedAssets if asset holdings are zero\r\n            }\r\n            PortfolioContent(assetHoldings, assetPrice, assetDecimals);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Calculates unclaimed fees of the fund manager\r\n    @param gav Gross asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    @return {\r\n      \"managementFees\": \"A time (seconds) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\",\r\n      \"performanceFees\": \"A performance (rise of sharePrice measured in QUOTE_ASSET) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\",\r\n      \"unclaimedfees\": \"The sum of both managementfee and performancefee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\"\r\n    }\r\n    */\r\n    function calcUnclaimedFees(uint gav)\r\n        view\r\n        returns (\r\n            uint managementFee,\r\n            uint performanceFee,\r\n            uint unclaimedFees)\r\n    {\r\n        // Management fee calculation\r\n        uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);\r\n        uint gavPercentage = mul(timePassed, gav) / (1 years);\r\n        managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);\r\n\r\n        // Performance fee calculation\r\n        // Handle potential division through zero by defining a default value\r\n        uint valuePerShareExclMgmtFees = totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), totalSupply) : toSmallestShareUnit(1);\r\n        if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {\r\n            uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);\r\n            uint investmentProfits = wmul(gainInSharePrice, totalSupply);\r\n            performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);\r\n        }\r\n\r\n        // Sum of all FEES\r\n        unclaimedFees = add(managementFee, performanceFee);\r\n    }\r\n\r\n    /// @notice Calculates the Net asset value of this fund\r\n    /// @param gav Gross asset value of this fund in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @param unclaimedFees The sum of both managementFee and performanceFee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @return nav Net asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcNav(uint gav, uint unclaimedFees)\r\n        view\r\n        returns (uint nav)\r\n    {\r\n        nav = sub(gav, unclaimedFees);\r\n    }\r\n\r\n    /// @notice Calculates the share price of the fund\r\n    /// @dev Convention for valuePerShare (== sharePrice) formatting: mul(totalValue / numShares, 10 ** decimal), to avoid floating numbers\r\n    /// @dev Non-zero share supply; value denominated in [base unit of melonAsset]\r\n    /// @param totalValue the total value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @param numShares the number of shares multiplied by 10 ** shareDecimals\r\n    /// @return valuePerShare Share price denominated in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcValuePerShare(uint totalValue, uint numShares)\r\n        view\r\n        pre_cond(numShares > 0)\r\n        returns (uint valuePerShare)\r\n    {\r\n        valuePerShare = toSmallestShareUnit(totalValue) / numShares;\r\n    }\r\n\r\n    /**\r\n    @notice Calculates essential fund metrics\r\n    @return {\r\n      \"gav\": \"Gross asset value of this fund denominated in [base unit of melonAsset]\",\r\n      \"managementFee\": \"A time (seconds) based fee\",\r\n      \"performanceFee\": \"A performance (rise of sharePrice measured in QUOTE_ASSET) based fee\",\r\n      \"unclaimedFees\": \"The sum of both managementFee and performanceFee denominated in [base unit of melonAsset]\",\r\n      \"feesShareQuantity\": \"The number of shares to be given as fees to the manager\",\r\n      \"nav\": \"Net asset value denominated in [base unit of melonAsset]\",\r\n      \"sharePrice\": \"Share price denominated in [base unit of melonAsset]\"\r\n    }\r\n    */\r\n    function performCalculations()\r\n        view\r\n        returns (\r\n            uint gav,\r\n            uint managementFee,\r\n            uint performanceFee,\r\n            uint unclaimedFees,\r\n            uint feesShareQuantity,\r\n            uint nav,\r\n            uint sharePrice\r\n        )\r\n    {\r\n        gav = calcGav(); // Reflects value independent of fees\r\n        (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);\r\n        nav = calcNav(gav, unclaimedFees);\r\n\r\n        // The value of unclaimedFees measured in shares of this fund at current value\r\n        feesShareQuantity = (gav == 0) ? 0 : mul(totalSupply, unclaimedFees) / gav;\r\n        // The total share supply including the value of unclaimedFees, measured in shares of this fund\r\n        uint totalSupplyAccountingForFees = add(totalSupply, feesShareQuantity);\r\n        sharePrice = nav > 0 ? calcValuePerShare(gav, totalSupplyAccountingForFees) : toSmallestShareUnit(1); // Handle potential division through zero by defining a default value\r\n    }\r\n\r\n    /// @notice Converts unclaimed fees of the manager into fund shares\r\n    /// @return sharePrice Share price denominated in [base unit of melonAsset]\r\n    function calcSharePriceAndAllocateFees() public returns (uint)\r\n    {\r\n        var (\r\n            gav,\r\n            managementFee,\r\n            performanceFee,\r\n            unclaimedFees,\r\n            feesShareQuantity,\r\n            nav,\r\n            sharePrice\r\n        ) = performCalculations();\r\n\r\n        createShares(owner, feesShareQuantity); // Updates totalSupply by creating shares allocated to manager\r\n\r\n        // Update Calculations\r\n        uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;\r\n        atLastUnclaimedFeeAllocation = Calculations({\r\n            gav: gav,\r\n            managementFee: managementFee,\r\n            performanceFee: performanceFee,\r\n            unclaimedFees: unclaimedFees,\r\n            nav: nav,\r\n            highWaterMark: highWaterMark,\r\n            totalSupply: totalSupply,\r\n            timestamp: now\r\n        });\r\n\r\n        FeesConverted(now, feesShareQuantity, unclaimedFees);\r\n        CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, totalSupply);\r\n\r\n        return sharePrice;\r\n    }\r\n\r\n    // PUBLIC : REDEEMING\r\n\r\n    /// @notice Redeems by allocating an ownership percentage only of requestedAssets to the participant\r\n    /// @dev Independent of running price feed! Note: if requestedAssets != ownedAssets then participant misses out on some owned value\r\n    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for individual assets\r\n    /// @param requestedAssets List of addresses that consitute a subset of ownedAssets.\r\n    /// @return Whether all assets sent to shareholder or not\r\n    function emergencyRedeem(uint shareQuantity, address[] requestedAssets)\r\n        public\r\n        pre_cond(balances[msg.sender] >= shareQuantity)  // sender owns enough shares\r\n        returns (bool)\r\n    {\r\n        address ofAsset;\r\n        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\r\n\r\n        // Check whether enough assets held by fund\r\n        for (uint i = 0; i < requestedAssets.length; ++i) {\r\n            ofAsset = requestedAssets[i];\r\n            uint assetHoldings = add(\r\n                uint(AssetInterface(ofAsset).balanceOf(this)),\r\n                quantityHeldInCustodyOfExchange(ofAsset)\r\n            );\r\n\r\n            if (assetHoldings == 0) continue;\r\n\r\n            // participant's ownership percentage of asset holdings\r\n            ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / totalSupply;\r\n\r\n            // CRITICAL ERR: Not enough fund asset balance for owed ownershipQuantitiy, eg in case of unreturned asset quantity at address(exchanges[i].exchange) address\r\n            if (uint(AssetInterface(ofAsset).balanceOf(this)) < ownershipQuantities[i]) {\r\n                isShutDown = true;\r\n                ErrorMessage(\"CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy\");\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Annihilate shares before external calls to prevent reentrancy\r\n        annihilateShares(msg.sender, shareQuantity);\r\n\r\n        // Transfer ownershipQuantity of Assets\r\n        for (uint j = 0; j < requestedAssets.length; ++j) {\r\n            // Failed to send owed ownershipQuantity from fund to participant\r\n            ofAsset = requestedAssets[j];\r\n            if (ownershipQuantities[j] == 0) {\r\n                continue;\r\n            } else if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[j])) {\r\n                revert();\r\n            }\r\n        }\r\n        Redeemed(msg.sender, now, shareQuantity);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC : FEES\r\n\r\n    /// @dev Quantity of asset held in exchange according to associated order id\r\n    /// @param ofAsset Address of asset\r\n    /// @return Quantity of input asset held in exchange\r\n    function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {\r\n        uint totalSellQuantity;     // quantity in custody across exchanges\r\n        uint totalSellQuantityInApprove; // quantity of asset in approve (allowance) but not custody of exchange\r\n        for (uint i; i < exchanges.length; i++) {\r\n            if (exchangeIdsToOpenMakeOrderIds[i][ofAsset] == 0) {\r\n                continue;\r\n            }\r\n            var (sellAsset, , sellQuantity, ) = exchanges[i].exchangeAdapter.getOrder(exchanges[i].exchange, exchangeIdsToOpenMakeOrderIds[i][ofAsset]);\r\n            if (sellQuantity == 0) {\r\n                exchangeIdsToOpenMakeOrderIds[i][ofAsset] = 0;\r\n            }\r\n            totalSellQuantity = add(totalSellQuantity, sellQuantity);\r\n            if (exchanges[i].isApproveOnly) {\r\n                totalSellQuantityInApprove += sellQuantity;\r\n            }\r\n        }\r\n        if (totalSellQuantity == 0) {\r\n            isInOpenMakeOrder[sellAsset] = false;\r\n        }\r\n        return sub(totalSellQuantity, totalSellQuantityInApprove); // Since quantity in approve is not actually in custody\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Calculates sharePrice denominated in [base unit of melonAsset]\r\n    /// @return sharePrice Share price denominated in [base unit of melonAsset]\r\n    function calcSharePrice() view returns (uint sharePrice) {\r\n        (, , , , , sharePrice) = performCalculations();\r\n        return sharePrice;\r\n    }\r\n\r\n    function getModules() view returns (address, address, address) {\r\n        return (\r\n            address(module.pricefeed),\r\n            address(module.compliance),\r\n            address(module.riskmgmt)\r\n        );\r\n    }\r\n\r\n    function getLastOrderId() view returns (uint) { return orders.length - 1; }\r\n    function getLastRequestId() view returns (uint) { return requests.length - 1; }\r\n    function getNameHash() view returns (bytes32) { return bytes32(keccak256(name)); }\r\n    function getManager() view returns (address) { return owner; }\r\n}\r\n\r\ncontract WETH9_ {\r\n    string public name     = \"Wrapped Ether\";\r\n    string public symbol   = \"WETH\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function() public payable {\r\n        deposit();\r\n    }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"TERMS_AND_CONDITIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shutDown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GOVERNANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"withId\",\"type\":\"uint256\"}],\"name\":\"getFundById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastFundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IS_MAINNET\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofManager\",\"type\":\"address\"}],\"name\":\"getFundByManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofFund\",\"type\":\"address\"}],\"name\":\"shutDownFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMPLIANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofFundName\",\"type\":\"string\"},{\"name\":\"ofQuoteAsset\",\"type\":\"address\"},{\"name\":\"ofManagementFee\",\"type\":\"uint256\"},{\"name\":\"ofPerformanceFee\",\"type\":\"uint256\"},{\"name\":\"ofCompliance\",\"type\":\"address\"},{\"name\":\"ofRiskMgmt\",\"type\":\"address\"},{\"name\":\"ofPriceFeed\",\"type\":\"address\"},{\"name\":\"ofExchanges\",\"type\":\"address[]\"},{\"name\":\"ofExchangeAdapters\",\"type\":\"address[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"setupFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION_NUMBER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofNewOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NATIVE_ASSET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listOfFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNativeAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"termsAndConditionsAreSigned\",\"outputs\":[{\"name\":\"signed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managerToFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isShutDown\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"versionNumber\",\"type\":\"string\"},{\"name\":\"ofGovernance\",\"type\":\"address\"},{\"name\":\"ofNativeAsset\",\"type\":\"address\"},{\"name\":\"isMainnet\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ofFund\",\"type\":\"address\"}],\"name\":\"FundUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"FundUpdated\",\"type\":\"event\"}]","ContractName":"Version","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000073185bc2a1aa75ec49ba9239b28ea22fda5940fa000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000005302e372e30000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://a9b9a0f222d51d198c3a0c7101e8d13f83301101ea151059946f8d5c785139cf"}]}