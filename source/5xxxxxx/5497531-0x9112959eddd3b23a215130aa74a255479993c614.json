{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract HoldersList is Ownable{\r\n   uint256 public _totalTokens;\r\n   \r\n   struct TokenHolder {\r\n        uint256 balance;\r\n        uint       regTime;\r\n        bool isValue;\r\n    }\r\n    \r\n    mapping(address => TokenHolder) holders;\r\n    address[] public payees;\r\n    \r\n    function changeBalance(address _who, uint _amount)  public onlyOwner {\r\n        \r\n            holders[_who].balance = _amount;\r\n            if (notInArray(_who)){\r\n                payees.push(_who);\r\n                holders[_who].regTime = now;\r\n                holders[_who].isValue = true;\r\n            }\r\n            \r\n        //}\r\n    }\r\n    function notInArray(address _who) internal view returns (bool) {\r\n        if (holders[_who].isValue) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n  /**\r\n   * @dev Defines number of issued tokens. \r\n   */\r\n  \r\n    function setTotal(uint _amount) public onlyOwner {\r\n      _totalTokens = _amount;\r\n  }\r\n  \r\n  /**\r\n   * @dev Returnes number of issued tokens.\r\n   */\r\n  \r\n   function getTotal() public constant returns (uint)  {\r\n     return  _totalTokens;\r\n  }\r\n  \r\n  /**\r\n   * @dev Returnes holders balance.\r\n   \r\n   */\r\n  function returnBalance (address _who) public constant returns (uint){\r\n      uint _balance;\r\n      \r\n      _balance= holders[_who].balance;\r\n      return _balance;\r\n  }\r\n  \r\n  \r\n  /**\r\n   * @dev Returnes number of holders in array.\r\n   \r\n   */\r\n  function returnPayees () public constant returns (uint){\r\n      uint _ammount;\r\n      \r\n      _ammount= payees.length;\r\n      return _ammount;\r\n  }\r\n  \r\n  \r\n  /**\r\n   * @dev Returnes holders address.\r\n   \r\n   */\r\n  function returnHolder (uint _num) public constant returns (address){\r\n      address _addr;\r\n      \r\n      _addr= payees[_num];\r\n      return _addr;\r\n  }\r\n  \r\n  /**\r\n   * @dev Returnes registration date of holder.\r\n   \r\n   */\r\n  function returnRegDate (address _who) public constant returns (uint){\r\n      uint _redData;\r\n      \r\n      _redData= holders[_who].regTime;\r\n      return _redData;\r\n  }\r\n    \r\n}\r\n\r\n\r\n\r\ncontract Dividend is Ownable   {\r\n  using SafeMath for uint256;  \r\n  //address multisig;\r\n  uint _totalDivid=0;\r\n  uint _newDivid=0;\r\n  uint public _totalTokens;\r\n  uint pointMultiplier = 10e18;\r\n  HoldersList list;\r\n  bool public PaymentFinished = false;\r\n  \r\n \r\n  \r\n \r\n address[] payees;\r\n \r\n struct ETHHolder {\r\n        uint256 balance;\r\n        uint       balanceUpdateTime;\r\n        uint       rewardWithdrawTime;\r\n }\r\n mapping(address => ETHHolder) eholders;\r\n \r\n   function returnMyEthBalance (address _who) public constant returns (uint){\r\n      //require(msg.sender == _who);\r\n      uint _eBalance;\r\n      \r\n      _eBalance= eholders[_who].balance;\r\n      return _eBalance;\r\n  }\r\n  \r\n  \r\n  function returnTotalDividend () public constant returns (uint){\r\n      return _totalDivid;\r\n  }\r\n  \r\n  \r\n  function changeEthBalance(address _who, uint256 _amount) internal {\r\n    //require(_who != address(0));\r\n    //require(_amount > 0);\r\n    eholders[_who].balanceUpdateTime = now;\r\n    eholders[_who].balance += _amount;\r\n\r\n  }\r\n  \r\n   /**\r\n   * @dev Allows the owner to set the List of token holders.\r\n   * @param _holdersList the List address\r\n   */\r\n  function setHoldersList(address _holdersList) public onlyOwner {\r\n    list = HoldersList(_holdersList);\r\n  }\r\n  \r\n  \r\n  function Withdraw() public returns (bool){\r\n    uint _eBalance;\r\n    address _who;\r\n    _who = msg.sender;\r\n    _eBalance= eholders[_who].balance;\r\n    require(_eBalance>0);\r\n    eholders[_who].balance = 0;\r\n    eholders[_who].rewardWithdrawTime = now;\r\n    _who.transfer(_eBalance);\r\n    return true;\r\n    \r\n   \r\n  }\r\n  \r\n  /**\r\n   * @dev Function to stop payments.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishDividend() onlyOwner public returns (bool) {\r\n    PaymentFinished = true;\r\n    return true;\r\n  }\r\n  \r\n  function() external payable {\r\n     \r\n     require(PaymentFinished==false);\r\n     \r\n     _newDivid= msg.value;\r\n     _totalDivid += _newDivid;\r\n     \r\n     uint _myTokenBalance=0;\r\n     uint _myRegTime;\r\n     uint _myEthShare=0;\r\n     //uint _myTokenPer=0;\r\n     uint256 _length;\r\n     address _addr;\r\n     \r\n     _length=list.returnPayees();\r\n     _totalTokens=list.getTotal();\r\n     \r\n     for (uint256 i = 0; i < _length; i++) {\r\n        _addr =list.returnHolder(i);\r\n        _myTokenBalance=list.returnBalance(_addr);\r\n        _myRegTime=list.returnRegDate(_addr);\r\n        _myEthShare=_myTokenBalance.mul(_newDivid).div(_totalTokens);\r\n          changeEthBalance(_addr, _myEthShare);\r\n        }\r\n    \r\n  }\r\n \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PaymentFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holdersList\",\"type\":\"address\"}],\"name\":\"setHoldersList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnTotalDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"returnMyEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Dividend","CompilerVersion":"v0.4.22+commit.4cb486ee","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2f87aefbeaa1ffff4eb18b5661cfc949943892420b30793f49ae3a633881d2ae"}]}