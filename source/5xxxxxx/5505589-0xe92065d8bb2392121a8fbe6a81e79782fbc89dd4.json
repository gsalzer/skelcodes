{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// File: contracts/auth/AuthorizedList.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract AuthorizedList {\r\n\r\n    bytes32 constant APHRODITE = keccak256(\"Goddess of Love!\");\r\n    bytes32 constant CUPID = keccak256(\"Aphrodite's Little Helper.\");\r\n    bytes32 constant BULKTRANSFER = keccak256(\"Bulk Transfer User.\");\r\n    mapping (address => mapping(bytes32 => bool)) internal authorized;\r\n    mapping (bytes32 => bool) internal contractPermissions;\r\n\r\n}\r\n\r\n// File: contracts/auth/Authorized.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract Authorized is AuthorizedList {\r\n\r\n    function Authorized() public {\r\n        /// Set the initial permission for msg.sender (contract creator), it can then add permissions for others\r\n        authorized[msg.sender][APHRODITE] = true;\r\n    }\r\n\r\n    /// Check if _address is authorized to access functionality with _authorization level\r\n    modifier ifAuthorized(address _address, bytes32 _authorization) {\r\n        require(authorized[_address][_authorization] || authorized[_address][APHRODITE]);\r\n        _;\r\n    }\r\n\r\n    /// @dev Check if _address is authorized for _authorization\r\n    function isAuthorized(address _address, bytes32 _authorization) public view returns (bool) {\r\n        return authorized[_address][_authorization];\r\n    }\r\n\r\n    /// @dev Change authorization for _address \r\n    /// @param _address Address whose permission is to be changed\r\n    /// @param _authorization Authority to be changed\r\n    function toggleAuthorization(address _address, bytes32 _authorization) public ifAuthorized(msg.sender, APHRODITE) {\r\n\r\n        /// Prevent inadvertent self locking out, cannot change own authority\r\n        require(_address != msg.sender);\r\n\r\n        /// No need for lower level authorization to linger\r\n        if (_authorization == APHRODITE && !authorized[_address][APHRODITE]) {\r\n            authorized[_address][CUPID] = false;\r\n        }\r\n\r\n        authorized[_address][_authorization] = !authorized[_address][_authorization];\r\n    }\r\n}\r\n\r\n// File: contracts/managed/Pausable.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract Pausable is AuthorizedList, Authorized {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n\r\n    /// @dev We deploy in UNpaused state, should it be paused?\r\n    bool public paused = false;\r\n\r\n    /// Make sure access control is initialized\r\n    function Pausable() public AuthorizedList() Authorized() { }\r\n\r\n\r\n    /// @dev modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev modifier to allow actions only when the contract is paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev called by an authorized msg.sender to pause, triggers stopped state\r\n    /// Multiple addresses may be authorized to call this method\r\n    function pause() public whenNotPaused ifAuthorized(msg.sender, CUPID) returns (bool) {\r\n        emit Pause();\r\n        paused = true;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @dev called by an authorized msg.sender to unpause, returns to normal state\r\n    /// Multiple addresses may be authorized to call this method\r\n    function unpause() public whenPaused ifAuthorized(msg.sender, CUPID) returns (bool) {\r\n        emit Unpause();\r\n        paused = false;\r\n    \r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /* Not needed\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // require(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    */\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/token/IERC20Basic.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract IERC20Basic {\r\n\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address _who) public view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n}\r\n\r\n// File: contracts/token/IERC20.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract IERC20 is IERC20Basic {\r\n\r\n    function allowance(address _tokenholder, address _tokenspender) view public returns (uint256);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function approve(address _tokenspender, uint256 _value) public returns (bool);\r\n    event Approval(address indexed _tokenholder, address indexed _tokenspender, uint256 _value);\r\n\r\n}\r\n\r\n// File: contracts/token/RecoverCurrency.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/// @title Authorized account can reclaim ERC20Basic tokens.\r\ncontract RecoverCurrency is AuthorizedList, Authorized {\r\n\r\n    event EtherRecovered(address indexed _to, uint256 _value);\r\n\r\n    function recoverEther() external ifAuthorized(msg.sender, APHRODITE) {\r\n        msg.sender.transfer(address(this).balance);\r\n        emit EtherRecovered(msg.sender, address(this).balance);\r\n    }\r\n\r\n    /// @dev Reclaim all ERC20Basic compatible tokens\r\n    /// @param _address The address of the token contract\r\n    function recoverToken(address _address) external ifAuthorized(msg.sender, APHRODITE) {\r\n        require(_address != address(0));\r\n        IERC20Basic token = IERC20Basic(_address);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(msg.sender, balance);\r\n    }\r\n}\r\n\r\n// File: contracts/managed/Freezable.sol\r\n\r\n/*\r\n * Created by Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title Freezable\r\n * @dev allows authorized accounts to add/remove other accounts to the list of fozen accounts.\r\n * Accounts in the list cannot transfer and approve and their balances and allowances cannot be retrieved.\r\n */\r\ncontract Freezable is AuthorizedList, Authorized {\r\n\r\n    event Frozen(address indexed _account);\r\n    event Unfrozen(address indexed _account);\r\n    \r\n    mapping (address => bool) public frozenAccounts;\r\n\r\n    /// Make sure access control is initialized\r\n    function Freezable() public AuthorizedList() Authorized() { }\r\n\r\n    /**\r\n    * @dev Throws if called by any account that's frozen.\r\n    */\r\n    modifier notFrozen {\r\n        require(!frozenAccounts[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev check if an account is frozen\r\n    * @param account address to check\r\n    * @return true iff the address is in the list of frozen accounts and hasn't been unfrozen\r\n    */\r\n    function isFrozen(address account) public view returns (bool) {\r\n        return frozenAccounts[account];\r\n    }\r\n\r\n    /**\r\n    * @dev add an address to the list of frozen accounts\r\n    * @param account address to freeze\r\n    * @return true if the address was added to the list of frozen accounts, false if the address was already in the list \r\n    */\r\n    function freezeAccount(address account) public ifAuthorized(msg.sender, APHRODITE) returns (bool success) {\r\n        if (!frozenAccounts[account]) {\r\n            frozenAccounts[account] = true;\r\n            emit Frozen(account);\r\n            success = true; \r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev remove an address from the list of frozen accounts\r\n    * @param account address to unfreeze\r\n    * @return true if the address was removed from the list of frozen accounts, \r\n    * false if the address wasn't in the list in the first place \r\n    */\r\n    function unfreezeAccount(address account) public ifAuthorized(msg.sender, APHRODITE) returns (bool success) {\r\n        if (frozenAccounts[account]) {\r\n            frozenAccounts[account] = false;\r\n            emit Unfrozen(account);\r\n            success = true;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/storage/AllowancesLedger.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, \r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE \r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, \r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract AllowancesLedger {\r\n\r\n    mapping (address => mapping (address => uint256)) public allowances;\r\n\r\n}\r\n\r\n// File: contracts/storage/TokenLedger.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract TokenLedger is AuthorizedList, Authorized {\r\n\r\n    mapping(address => uint256) public balances;\r\n    uint256 public totalsupply;\r\n\r\n    struct SeenAddressRecord {\r\n        bool seen;\r\n        uint256 accountArrayIndex;\r\n    }\r\n\r\n    // Iterable accounts\r\n    address[] internal accounts;\r\n    mapping(address => SeenAddressRecord) internal seenBefore;\r\n\r\n    /// @dev Keeping track of addresses in an array is useful as mappings are not iterable\r\n    /// @return Number of addresses holding this token\r\n    function numberAccounts() public view ifAuthorized(msg.sender, APHRODITE) returns (uint256) {\r\n        return accounts.length;\r\n    }\r\n\r\n    /// @dev Keeping track of addresses in an array is useful as mappings are not iterable\r\n    function returnAccounts() public view ifAuthorized(msg.sender, APHRODITE) returns (address[] holders) {\r\n        return accounts;\r\n    }\r\n\r\n    function balanceOf(uint256 _id) public view ifAuthorized(msg.sender, CUPID) returns (uint256 balance) {\r\n        require (_id < accounts.length);\r\n        return balances[accounts[_id]];\r\n    }\r\n}\r\n\r\n// File: contracts/storage/TokenSettings.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract TokenSettings is AuthorizedList, Authorized {\r\n\r\n    /// These strings should be set temporarily for testing on Rinkeby/Ropsten/Kovan to somethin else\r\n    /// to avoid people squatting on names\r\n    /// Change back to \"intimate\" and \"ITM\" for mainnet deployment\r\n\r\n    string public name = \"intimate\";\r\n    string public symbol = \"ITM\";\r\n\r\n    uint256 public INITIAL_SUPPLY = 100000000 * 10**18;  // 100 million of subdivisible tokens\r\n    uint8 public constant decimals = 18;\r\n\r\n\r\n    /// @dev Change token name\r\n    /// @param _name string\r\n    function setName(string _name) public ifAuthorized(msg.sender, APHRODITE) {\r\n        name = _name;\r\n    }\r\n\r\n    /// @dev Change token symbol\r\n    /// @param _symbol string\r\n    function setSymbol(string _symbol) public ifAuthorized(msg.sender, APHRODITE) {\r\n        symbol = _symbol;\r\n    }\r\n}\r\n\r\n// File: contracts/storage/BasicTokenStorage.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\n/// Collect all the state variables for the token's functions into a single contract\r\ncontract BasicTokenStorage is AuthorizedList, Authorized, TokenSettings, AllowancesLedger, TokenLedger {\r\n\r\n    /// @dev Ensure that authorization is set\r\n    function BasicTokenStorage() public Authorized() TokenSettings() AllowancesLedger() TokenLedger() { }\r\n\r\n    /// @dev Keep track of addresses seen before, push new ones into accounts list\r\n    /// @param _tokenholder address to check for \"newness\"\r\n    function trackAddresses(address _tokenholder) internal {\r\n        if (!seenBefore[_tokenholder].seen) {\r\n            seenBefore[_tokenholder].seen = true;\r\n            accounts.push(_tokenholder);\r\n            seenBefore[_tokenholder].accountArrayIndex = accounts.length - 1;\r\n        }\r\n    }\r\n\r\n    /// @dev remove address from seenBefore and accounts\r\n    /// @param _tokenholder address to remove\r\n    function removeSeenAddress(address _tokenholder) internal {\r\n        uint index = seenBefore[_tokenholder].accountArrayIndex;\r\n        require(index < accounts.length);\r\n\r\n        if (index != accounts.length - 1) {\r\n            accounts[index] = accounts[accounts.length - 1];\r\n        } \r\n        accounts.length--;\r\n        delete seenBefore[_tokenholder];\r\n    }\r\n}\r\n\r\n// File: contracts/token/BasicToken.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BasicToken is IERC20Basic, BasicTokenStorage, Pausable, Freezable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(address indexed _tokenholder, address indexed _tokenrecipient, uint256 _value);\r\n    event BulkTransfer(address indexed _tokenholder, uint256 _howmany);\r\n\r\n    /// @dev Return the total token supply\r\n    function totalSupply() public view whenNotPaused returns (uint256) {\r\n        return totalsupply;\r\n    }\r\n\r\n    /// @dev transfer token for a specified address\r\n    /// @param _to The address to transfer to.\r\n    /// @param _value The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public whenNotPaused notFrozen returns (bool) {\r\n\r\n        /// No transfers to 0x0 address, use burn instead, if implemented\r\n        require(_to != address(0));\r\n\r\n        /// No useless operations\r\n        require(msg.sender != _to);\r\n\r\n        /// This will revert if not enough funds\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n\r\n        if (balances[msg.sender] == 0) {\r\n            removeSeenAddress(msg.sender);\r\n        }\r\n\r\n        /// _to might be a completely new address, so check and store if so\r\n        trackAddresses(_to);\r\n\r\n        /// This will revert on overflow\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        /// Emit the Transfer event\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev bulkTransfer tokens to a list of specified addresses, not an ERC20 function\r\n    /// @param _tos The list of addresses to transfer to.\r\n    /// @param _values The list of amounts to be transferred.\r\n    function bulkTransfer(address[] _tos, uint256[] _values) public whenNotPaused notFrozen ifAuthorized(msg.sender, BULKTRANSFER) returns (bool) {\r\n\r\n        require (_tos.length == _values.length);\r\n\r\n        uint256 sourceBalance = balances[msg.sender];\r\n\r\n        /// Temporarily set balance to 0 to mitigate the possibility of re-entrancy attacks\r\n        balances[msg.sender] = 0;\r\n\r\n        for (uint256 i = 0; i < _tos.length; i++) {\r\n            uint256 currentValue = _values[i];\r\n            address _to = _tos[i];\r\n            require(_to != address(0));\r\n            require(currentValue <= sourceBalance);\r\n            require(msg.sender != _to);\r\n\r\n            sourceBalance = sourceBalance.sub(currentValue);\r\n            balances[_to] = balances[_to].add(currentValue);\r\n\r\n            trackAddresses(_to);\r\n\r\n            emit Transfer(msg.sender, _tos[i], currentValue);\r\n        }\r\n\r\n        /// Set to the remaining balance\r\n        balances[msg.sender] = sourceBalance;\r\n\r\n        emit BulkTransfer(msg.sender, _tos.length);\r\n\r\n        if (balances[msg.sender] == 0) {\r\n            removeSeenAddress(msg.sender);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @dev Gets balance of the specified account.\r\n    /// @param _tokenholder Address of interest\r\n    /// @return Balance for the passed address\r\n    function balanceOf(address _tokenholder) public view whenNotPaused returns (uint256 balance) {\r\n        require(!isFrozen(_tokenholder));\r\n        return balances[_tokenholder];\r\n    }\r\n}\r\n\r\n// File: contracts/token/StandardToken.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract StandardToken is IERC20Basic, BasicToken, IERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Approval(address indexed _tokenholder, address indexed _tokenspender, uint256 _value);\r\n\r\n    /// @dev Implements ERC20 transferFrom from one address to another\r\n    /// @param _from The source address  for tokens\r\n    /// @param _to The destination address for tokens\r\n    /// @param _value The number/amount to transfer\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused notFrozen returns (bool) {\r\n\r\n        // Don't send tokens to 0x0 address, use burn function that updates totalSupply\r\n        // and don't waste gas sending tokens to yourself\r\n        require(_to != address(0) && _from != _to);\r\n\r\n        require(!isFrozen(_from) && !isFrozen(_to));\r\n\r\n        /// This will revert if _value is larger than the allowance\r\n        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n\r\n        /// _to might be a completely new address, so check and store if so\r\n        trackAddresses(_to);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        /// Emit the Transfer event\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _tokenspender The address which will spend the funds.\r\n    /// @param _value The amount of tokens to be spent.\r\n    function approve(address _tokenspender, uint256 _value) public whenNotPaused notFrozen returns (bool) {\r\n\r\n        require(_tokenspender != address(0) && msg.sender != _tokenspender);\r\n\r\n        require(!isFrozen(_tokenspender));\r\n\r\n        /// To mitigate reentrancy race condition, set allowance for _tokenspender to 0\r\n        /// first and then set the new value\r\n        /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowances[msg.sender][_tokenspender] == 0));\r\n\r\n        /// Allow _tokenspender to transfer up to _value in tokens from msg.sender\r\n        allowances[msg.sender][_tokenspender] = _value;\r\n\r\n        /// Emit the Approval event\r\n        emit Approval(msg.sender, _tokenspender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @dev Function to check the amount of tokens that a spender can spend\r\n    /// @param _tokenholder Token owner account address\r\n    /// @param _tokenspender Account address authorized to transfer tokens\r\n    /// @return Amount of tokens still available to _tokenspender to transfer.\r\n    function allowance(address _tokenholder, address _tokenspender) public view whenNotPaused returns (uint256) {\r\n        require(!isFrozen(_tokenholder) && !isFrozen(_tokenspender));\r\n        return allowances[_tokenholder][_tokenspender];\r\n    }\r\n}\r\n\r\n// File: contracts/sales/IntimateShoppe.sol\r\n\r\n/*\r\n * Created by: alexo (Big Deeper Advisors, Inc)\r\n * For: Input Strategic Partners (ISP) and Intimate.io\r\n *\r\n * Derived from some public sources and substantially extended/adapted for intimate's use.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\r\n * TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE\r\n * SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\r\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract IntimateShoppe is Pausable, RecoverCurrency {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /// List of contributors, i.e. msg.sender(s) who has sent in Ether\r\n    address[] internal contributors;\r\n\r\n    /// List of contributions for each contributor\r\n    mapping (address => uint256[]) internal contributions;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /// @dev event for token purchase logging\r\n    /// @param _seller_wallet_address account that sends tokens\r\n    /// @param _buyer_address who got the tokens in exchange for ether\r\n    /// @param _value weis paid for purchase\r\n    /// @param _amount of tokens purchased\r\n    event ITMTokenPurchase(address indexed _seller_wallet_address, address indexed _buyer_address, uint256 _value, uint256 _amount);\r\n\r\n    /// @dev Starting and ending times for sale period\r\n    event SetPeriod(uint256 _startTime, uint256 _endTime);\r\n\r\n\r\n    /// The ITM token object\r\n    StandardToken public token;\r\n\r\n    /// address of the ITM token\r\n    address public token_address;\r\n\r\n    /// start and end timestamps in between which investments are allowed (both inclusive)\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    /// address where funds are collected, it could a simple address or multi-sig wallet contract\r\n    address public wallet_address;\r\n\r\n    /// how many token units a buyer gets per wei\r\n    uint256 public rate = 600;\r\n\r\n    /// upper limit for tokens to be sold in this public offering\r\n    /// NOTE: Since decimals are set at 1e18, if one sets a limit of one(1) ITM, this number should be\r\n    /// 1 * 1e18\r\n    uint256 public capTokens;\r\n\r\n    /// Maxiumum acceptable Ether amount \r\n    uint256 public maxValue = 100 ether;\r\n\r\n    /// Minimum acceptable Ether amount, 1 ITM worth\r\n    uint256 public minValue = uint256(1 ether)/600;\r\n\r\n    /// amount of raised money in wei\r\n    uint256 public weiRaised = 0;\r\n    uint256 public tokensSold = 0;\r\n\r\n    /// High water line for contract balance\r\n    uint256 internal highWater = 1 ether;\r\n\r\n    /// What round it is\r\n    uint8 public round = 0;\r\n\r\n    /// @param _startTime is the absolute time from which to start accepting Ether\r\n    /// @param _duration is the period of time in seconds how long the sale would last, so if a sale lasts 1 month\r\n    /// then the _duration = 30(31)*24*60*60 seconds\r\n    function IntimateShoppe(\r\n        uint256 _startTime, \r\n        uint256 _duration, \r\n        uint256 _rate, \r\n        address _wallet_address, \r\n        address _token_address, \r\n        uint256 _cap,\r\n        uint8 _round) public Authorized() {\r\n\r\n        require(_startTime >= 0 && _duration > 0);\r\n        require(_rate > 0);\r\n        require(_wallet_address != address(0x0));\r\n        require(_token_address != address(0x0));\r\n        require(_cap > 0);\r\n\r\n        round = _round;\r\n\r\n        startTime = _startTime;\r\n        endTime = startTime + _duration;\r\n\r\n        rate = _rate;\r\n        minValue = uint256(1 ether)/_rate;\r\n        capTokens = _cap;\r\n        wallet_address = _wallet_address;\r\n        token_address = _token_address;\r\n        token = StandardToken(token_address);\r\n    }\r\n\r\n    /// @dev Log contributors and their contributions\r\n    /// @param _sender A Contributor's address\r\n    /// @param _value Amount of Ether said contributor sent\r\n    function trackContributions(address _sender, uint256 _value) internal {\r\n        if (contributions[_sender].length == 0) {\r\n            contributors.push(_sender);\r\n        }\r\n        contributions[_sender].push(_value);\r\n    }\r\n\r\n    /// @dev Retrieve contributors\r\n    /// @return A list of contributors\r\n    function getContributors() external view ifAuthorized(msg.sender, APHRODITE) returns (address[]) {\r\n        return contributors;\r\n    }\r\n\r\n    /// @dev Retrieve contributions by a single contributor \r\n    /// @param _contributor The account associated with contributions\r\n    /// @return A list of ether amounts that _contributor sent in\r\n    /// Using the function above one can get a list first, and then get individual Ether payments\r\n    /// and aggregate them if needed\r\n    function getContributionsForAddress(address _contributor) external view ifAuthorized(msg.sender, APHRODITE) returns (uint256[]) {\r\n        return contributions[_contributor];\r\n    }\r\n\r\n    /// @dev If a sale is done using multiple rounds, allowing for better pricing structure, depending on\r\n    /// on market demand and value of the ITM token. Is also set via the constructor\r\n    /// @param _round Round label/count\r\n    function setRound(uint8 _round) public ifAuthorized(msg.sender, APHRODITE) {\r\n        round = _round;\r\n    }\r\n\r\n    /// @dev Sets the maximum Value in Ether to purchase tokens\r\n    /// @param _maxValue Amount in wei\r\n    function setMaxValue(uint256 _maxValue) public ifAuthorized(msg.sender, APHRODITE) {\r\n        /// Cannot be modified once sale is ongoing\r\n        require(now < startTime || now > endTime);\r\n        maxValue = _maxValue;\r\n    }\r\n\r\n    /// @dev Sets the mininum Value in Ether to purchase tokens\r\n    /// @param _minValue Amount in wei\r\n    function setMinValue(uint256 _minValue) public ifAuthorized(msg.sender, APHRODITE) {\r\n        /// Cannot be modified once sale is ongoing\r\n        require(now < startTime || now > endTime);\r\n        minValue = _minValue;\r\n    }\r\n\r\n\r\n    /// @dev Reset the starting and ending times for the next round\r\n    /// @param _startTime Start of the sale round\r\n    /// @param _duration End of the sale round\r\n    function setTimes(uint256 _startTime, uint256 _duration) public ifAuthorized(msg.sender, APHRODITE) {\r\n        /// Can't reset times if sale ongoing already, make sure everything else is set before\r\n        require(now < startTime || now > endTime);\r\n\r\n        require(_startTime >= 0 && _duration > 0);\r\n        startTime = _startTime;\r\n        endTime = startTime + _duration;\r\n        emit SetPeriod(startTime, endTime);\r\n    }\r\n\r\n\r\n    /// @dev Set the cap, i.e. how many token units  we will sell in this round\r\n    /// @param _capTokens How many token units are offered in a round\r\n    function setCap(uint256 _capTokens) public ifAuthorized(msg.sender, APHRODITE) {\r\n        /// Cannot be modified once sale is ongoing\r\n        require(now < startTime || now > endTime);\r\n        require(_capTokens > 0);\r\n        capTokens = _capTokens;\r\n    }\r\n\r\n    /// @dev Set the rate, i.e. how many units per wei do we give\r\n    /// @param _rate How many token units are offered for 1 wei, 1 or more.\r\n    function setRate(uint256 _rate) public ifAuthorized(msg.sender, APHRODITE) {\r\n        require(_rate > 0);\r\n        rate = _rate;\r\n    }\r\n\r\n    /// @dev Change the wallet address\r\n    /// @param _wallet_address replacement wallet address\r\n    function changeCompanyWallet(address _wallet_address) public ifAuthorized(msg.sender, APHRODITE) {\r\n        wallet_address = _wallet_address;\r\n    }\r\n\r\n    /// @dev highWater determines at what contract balance Ether is forwarded to wallet_address\r\n    /// @return highWater\r\n    function getHighWater() public view ifAuthorized(msg.sender, APHRODITE) returns (uint256) {\r\n        return highWater;\r\n    }\r\n\r\n    /// @dev Set the high water line/ceiling\r\n    /// @param _highWater Sets the threshold to shift Ether to another address\r\n    function setHighWater(uint256 _highWater) public ifAuthorized(msg.sender, APHRODITE) {\r\n        highWater = _highWater;\r\n    }\r\n\r\n\r\n    /// fallback function used to buy tokens\r\n    function () payable public {\r\n        /// Make certain msg.value sent is within permitted bounds\r\n        require(msg.value >= minValue && msg.value <= maxValue);\r\n        backTokenOwner();\r\n    }\r\n\r\n    /// @dev Main purchase function\r\n    function backTokenOwner() whenNotPaused internal {\r\n\r\n        // Within the current sale period\r\n        require(now >= startTime && now <= endTime);\r\n\r\n        // Transfer Ether from this contract to the company's or foundation's wallet_address\r\n\r\n        if (address(this).balance >= highWater) {\r\n            //wallet_address.transfer(msg.value);\r\n            wallet_address.transfer(address(this).balance);\r\n            emit Transfer(this, wallet_address, address(this).balance);\r\n        }\r\n\r\n        /// Keep data about buyers's addresses and amounts\r\n        /// If this functionality is not wanted, comment out the next line\r\n        trackContributions(msg.sender, msg.value);\r\n\r\n        uint256 tokens = msg.value.mul(rate);\r\n\r\n        /// Transfer purchased tokens to the public buyer\r\n\r\n        /// Note that the address authorized to control the token contract needs to set \"wallet_address\" allowance\r\n        /// using ERC20 approve function before this contract can transfer tokens.\r\n   \r\n        if (token.transferFrom(wallet_address, msg.sender, tokens)) {\r\n\r\n            token.freezeAccount(msg.sender);\r\n\r\n            weiRaised = weiRaised.add(msg.value);\r\n            tokensSold = tokensSold.add(tokens);\r\n            emit ITMTokenPurchase(wallet_address, msg.sender, msg.value, tokens);\r\n\r\n            // Check the cap and revert if exceeded\r\n            require(tokensSold <= capTokens);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setTimes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHighWater\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_authorization\",\"type\":\"bytes32\"}],\"name\":\"toggleAuthorization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_highWater\",\"type\":\"uint256\"}],\"name\":\"setHighWater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_capTokens\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recoverEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxValue\",\"type\":\"uint256\"}],\"name\":\"setMaxValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"recoverToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContributors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet_address\",\"type\":\"address\"}],\"name\":\"changeCompanyWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint8\"}],\"name\":\"setRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minValue\",\"type\":\"uint256\"}],\"name\":\"setMinValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_authorization\",\"type\":\"bytes32\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"getContributionsForAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet_address\",\"type\":\"address\"},{\"name\":\"_token_address\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_round\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_seller_wallet_address\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_buyer_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ITMTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"SetPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"EtherRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"IntimateShoppe","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005ae195100000000000000000000000000000000000000000000000000000000000375f000000000000000000000000000000000000000000000000000000000000000258000000000000000000000000f7bc09414afc7e078b45f7c7668f58736161897d0000000000000000000000001dbed266d20d27d0bd1c4707fc002defe7e0267b000000000000000000000000000000000000000001ebf3164ee6fd5706f000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://bd9542ce379dd18f7ac753a652782fbfbc3863663a2de8a4cb59a26f98d6c489"}]}