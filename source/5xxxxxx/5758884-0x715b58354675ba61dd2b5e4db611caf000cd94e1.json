{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n/**\r\n * @title Ownable Contract\r\n * @dev contract that has a user and can implement user access restrictions based on it\r\n */\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev sets owner of contract\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev changes owner of contract\r\n   * @param newOwner New owner\r\n   */\r\n  function changeOwner(address newOwner) public ownerOnly {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by other account than owner\r\n   */\r\n  modifier ownerOnly() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Emergency Safety contract\r\n * @dev Allows token and ether drain and pausing of contract\r\n */ \r\ncontract EmergencySafe is Ownable{ \r\n\r\n  event PauseToggled(bool isPaused);\r\n\r\n  bool public paused;\r\n\r\n\r\n  /**\r\n   * @dev Throws if contract is paused\r\n   */\r\n  modifier isNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if contract is not paused\r\n   */\r\n  modifier isPaused() {\r\n    require(paused);\r\n    _; \r\n  }\r\n\r\n  /**\r\n   * @dev Initialises contract to non-paused\r\n   */\r\n  function EmergencySafe() public {\r\n    paused = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows draining of tokens (to owner) that might accidentally be sent to this address\r\n   * @param token Address of ERC20 token\r\n   * @param amount Amount to drain\r\n   */\r\n  function emergencyERC20Drain(ERC20Interface token, uint amount) public ownerOnly{\r\n    token.transfer(owner, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows draining of Ether\r\n   * @param amount Amount to drain\r\n   */\r\n  function emergencyEthDrain(uint amount) public ownerOnly returns (bool){\r\n    return owner.send(amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Switches the contract from paused to non-paused or vice-versa\r\n   */\r\n  function togglePause() public ownerOnly {\r\n    paused = !paused;\r\n    emit PauseToggled(paused);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Upgradeable Conract\r\n * @dev contract that implements doubly linked list to keep track of old and new \r\n * versions of this contract\r\n */ \r\ncontract Upgradeable is Ownable{\r\n\r\n  address public lastContract;\r\n  address public nextContract;\r\n  bool public isOldVersion;\r\n  bool public allowedToUpgrade;\r\n\r\n  /**\r\n   * @dev makes contract upgradeable \r\n   */\r\n  function Upgradeable() public {\r\n    allowedToUpgrade = true;\r\n  }\r\n\r\n  /**\r\n   * @dev signals that new upgrade is available, contract must be most recent \r\n   * upgrade and allowed to upgrade\r\n   * @param newContract Address of upgraded contract \r\n   */\r\n  function upgradeTo(Upgradeable newContract) public ownerOnly{\r\n    require(allowedToUpgrade && !isOldVersion);\r\n    nextContract = newContract;\r\n    isOldVersion = true;\r\n    newContract.confirmUpgrade();   \r\n  }\r\n\r\n  /**\r\n   * @dev confirmation that this is indeed the next version,\r\n   * called from previous version of contract. Anyone can call this function,\r\n   * which basically makes this instance unusable if that happens. Once called,\r\n   * this contract can not serve as upgrade to another contract. Not an ideal solution\r\n   * but will work until we have a more sophisticated approach using a dispatcher or similar\r\n   */\r\n  function confirmUpgrade() public {\r\n    require(lastContract == address(0));\r\n    lastContract = msg.sender;\r\n  }\r\n}\r\n\r\n/**\r\n * @title IXT payment contract in charge of administaring IXT payments \r\n * @dev contract looks up price for appropriate tasks and sends transferFrom() for user,\r\n * user must approve this contract to spend IXT for them before being able to use it\r\n */ \r\ncontract IXTPaymentContract is Ownable, EmergencySafe, Upgradeable{\r\n\r\n  event IXTPayment(address indexed from, address indexed to, uint value, string indexed action);\r\n\r\n  ERC20Interface public tokenContract;\r\n\r\n  mapping(string => uint) private actionPrices;\r\n  mapping(address => bool) private allowed;\r\n\r\n  /**\r\n   * @dev Throws if called by non-allowed contract\r\n   */\r\n  modifier allowedOnly() {\r\n    require(allowed[msg.sender] || msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev sets up token address of IXT token\r\n   * adds owner to allowds, if owner is changed in the future, remember to remove old\r\n   * owner if desired\r\n   * @param tokenAddress IXT token address\r\n   */\r\n  function IXTPaymentContract(address tokenAddress) public {\r\n    tokenContract = ERC20Interface(tokenAddress);\r\n    allowed[owner] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev transfers IXT \r\n   * @param from User address\r\n   * @param to Recipient\r\n   * @param action Service the user is paying for \r\n   */\r\n  function transferIXT(address from, address to, string action) public allowedOnly isNotPaused returns (bool) {\r\n    if (isOldVersion) {\r\n      IXTPaymentContract newContract = IXTPaymentContract(nextContract);\r\n      return newContract.transferIXT(from, to, action);\r\n    } else {\r\n      uint price = actionPrices[action];\r\n\r\n      if(price != 0 && !tokenContract.transferFrom(from, to, price)){\r\n        return false;\r\n      } else {\r\n        emit IXTPayment(from, to, price, action);     \r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev sets new token address in case of update\r\n   * @param erc20Token Token address\r\n   */\r\n  function setTokenAddress(address erc20Token) public ownerOnly isNotPaused {\r\n    tokenContract = ERC20Interface(erc20Token);\r\n  }\r\n\r\n  /**\r\n   * @dev creates/updates action\r\n   * @param action Action to be paid for \r\n   * @param price Price (in units * 10 ^ (<decimal places of token>))\r\n   */\r\n  function setAction(string action, uint price) public ownerOnly isNotPaused {\r\n    actionPrices[action] = price;\r\n  }\r\n\r\n  /**\r\n   * @dev retrieves price for action\r\n   * @param action Name of action, e.g. 'create_insurance_contract'\r\n   */\r\n  function getActionPrice(string action) public view returns (uint) {\r\n    return actionPrices[action];\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev add account to allow calling of transferIXT\r\n   * @param allowedAddress Address of account \r\n   */\r\n  function setAllowed(address allowedAddress) public ownerOnly {\r\n    allowed[allowedAddress] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove account from allowed accounts\r\n   * @param allowedAddress Address of account \r\n   */\r\n  function removeAllowed(address allowedAddress) public ownerOnly {\r\n    allowed[allowedAddress] = false;\r\n  }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    uint public totalSupply;\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n/**\r\n * @title Insurance Contract\r\n * @dev Insurance Contract that is created by broker/client, functions mainly as permament record store\r\n */ \r\ncontract Policy is Ownable, EmergencySafe, Upgradeable{\r\n\r\n  struct InsuranceProduct {\r\n    uint inceptionDate;\r\n    uint expirationDate;\r\n    uint limitOfLiability;\r\n    string limitOfLiabilityCurrency;\r\n    string insuranceType;\r\n    bytes32 policyDocumentReference;\r\n  }\r\n\r\n  struct PolicyInfo {\r\n    uint blockNumber;\r\n    uint numInsuranceProducts;\r\n    string clientInfo;\r\n    string ixlEnquiryId;\r\n    string status;\r\n    address brokerEtherAddress;\r\n    address clientEtherAddress;\r\n  }\r\n\r\n  InsuranceProduct[] public insuranceProducts;\r\n  PolicyInfo public policyInfo;\r\n  mapping(address => bool) private cancellations;\r\n\r\n  /**\r\n   * @dev Throws if called by other account than broker or client\r\n   */\r\n  modifier participantOnly() {\r\n    require(msg.sender == policyInfo.clientEtherAddress || msg.sender == policyInfo.brokerEtherAddress);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by other account than broker or client,\r\n   * core parameters kept as fields for future logic and for quick reference upon lookup\r\n   */\r\n  function Policy(string _clientInfo, address _brokerEtherAddress, address _clientEtherAddress, string _enquiryId) public {\r\n\r\n    policyInfo = PolicyInfo({\r\n      blockNumber: block.number,\r\n      numInsuranceProducts: 0,\r\n      clientInfo: _clientInfo,\r\n      ixlEnquiryId: _enquiryId,\r\n      status: 'In Force',\r\n      clientEtherAddress: _clientEtherAddress,\r\n      brokerEtherAddress: _brokerEtherAddress\r\n    });\r\n\r\n    allowedToUpgrade = false;\r\n  }\r\n\r\n  function addInsuranceProduct (uint _inceptionDate, uint _expirationDate, uint _limitOfLiability, string _limitOfLiabilityCurrency, string _insuranceType, bytes32 _policyDocReference) public ownerOnly isNotPaused {\r\n\r\n    insuranceProducts.push(InsuranceProduct({\r\n      policyDocumentReference: _policyDocReference,\r\n      inceptionDate: _inceptionDate,\r\n      expirationDate: _expirationDate,\r\n      limitOfLiability: _limitOfLiability,\r\n      limitOfLiabilityCurrency: _limitOfLiabilityCurrency,\r\n      insuranceType: _insuranceType\r\n    }));\r\n\r\n    policyInfo.numInsuranceProducts++;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows broker and client to cancel contract, when both have cancelled,\r\n   * status is updated and contract becomes upgradeable\r\n   */\r\n  function revokeContract() public participantOnly {\r\n    cancellations[msg.sender] = true;\r\n\r\n    if (((cancellations[policyInfo.brokerEtherAddress] && (cancellations[policyInfo.clientEtherAddress] || cancellations[owner]))\r\n        || (cancellations[policyInfo.clientEtherAddress] && cancellations[owner]))){\r\n      policyInfo.status = \"REVOKED\";\r\n      allowedToUpgrade = true;\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\n * @title Policy Registry \r\n * @dev Registry that is in charge of tracking and creating insurance contracts\r\n */ \r\ncontract PolicyRegistry is Ownable, EmergencySafe, Upgradeable{\r\n\r\n  event PolicyCreated(address at, address by);\r\n\r\n  IXTPaymentContract public IXTPayment;\r\n\r\n  mapping (address => address[]) private policiesByParticipant;\r\n  address[] private policies;\r\n\r\n\r\n  /**\r\n   * @dev Creates Registry\r\n   * @param paymentAddress The address of the payment contract used when creating insurance contracts\r\n   */\r\n  function PolicyRegistry(address paymentAddress) public {\r\n    IXTPayment = IXTPaymentContract(paymentAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Creates Policy, transfers ownership to msg.sender, registers address for all parties involved,\r\n   * and transfers IXT \r\n   */\r\n  function createContract(string _clientInfo, address _brokerEtherAddress, address _clientEtherAddress, string _enquiryId) public isNotPaused {\r\n\r\n    Policy policy = new Policy(_clientInfo, _brokerEtherAddress, _clientEtherAddress, _enquiryId);\r\n    policy.changeOwner(msg.sender);\r\n    policiesByParticipant[_brokerEtherAddress].push(policy);\r\n\r\n    if (_clientEtherAddress != _brokerEtherAddress) {\r\n      policiesByParticipant[_clientEtherAddress].push(policy);\r\n    }\r\n\r\n    if (msg.sender != _clientEtherAddress && msg.sender != _brokerEtherAddress) {\r\n      policiesByParticipant[msg.sender].push(policy);\r\n    }\r\n\r\n    policies.push(policy);\r\n\r\n    IXTPayment.transferIXT(_clientEtherAddress, owner, \"create_insurance\");\r\n    emit PolicyCreated(policy, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Retrieve all contracts that msg.sender is either broker, client or owner for\r\n   */\r\n  function getMyPolicies() public view returns (address[]) {\r\n    return policiesByParticipant[msg.sender];\r\n  }\r\n\r\n  /**\r\n   * @dev Retrieve all contracts ever created\r\n   */\r\n  function getAllPolicies() public view ownerOnly returns (address[]){\r\n    return policies;\r\n  }\r\n\r\n  /**\r\n   * @dev change address of payment contract\r\n   * @param contractAddress Address of payment contract\r\n   */\r\n  function changePaymentContract(address contractAddress) public ownerOnly{\r\n    IXTPayment = IXTPaymentContract(contractAddress);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isOldVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyEthDrain\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_clientInfo\",\"type\":\"string\"},{\"name\":\"_brokerEtherAddress\",\"type\":\"address\"},{\"name\":\"_clientEtherAddress\",\"type\":\"address\"},{\"name\":\"_enquiryId\",\"type\":\"string\"}],\"name\":\"createContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllPolicies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"changePaymentContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyPolicies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowedToUpgrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"togglePause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyERC20Drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IXTPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"paymentAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"at\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"PolicyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseToggled\",\"type\":\"event\"}]","ContractName":"PolicyRegistry","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000077542b6fc95dc03Ccd3E52E0B13753DC2fCeDA4B","Library":"","SwarmSource":"bzzr://cc4d050c66aeb70dfe9af71e7f46648db49d4a499a73accae5c58392aae047c0"}]}