{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/* ==================================================================== */\r\n/* Copyright (c) 2018 The Priate Conquest Project.  All rights reserved.\r\n/* \r\n/* https://www.pirateconquest.com One of the world's slg games of blockchain \r\n/*  \r\n/* authors rainy@livestar.com/Jonny.Fu@livestar.com\r\n/*                 \r\n/* ==================================================================== */\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\ncontract ERC721 /* is ERC165 */ {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n  function ownerOf(uint256 _tokenId) external view returns (address);\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n  function approve(address _approved, uint256 _tokenId) external payable;\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n  function getApproved(uint256 _tokenId) external view returns (address);\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n     function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\ninterface ERC721TokenReceiver {\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    function name() external view returns (string _name);\r\n    function symbol() external view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /*\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() external onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() external onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint32 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function div32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function add32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract AccessAdmin is Pausable {\r\n\r\n  /// @dev Admin Address\r\n  mapping (address => bool) adminContracts;\r\n\r\n  /// @dev Trust contract\r\n  mapping (address => bool) actionContracts;\r\n\r\n  function setAdminContract(address _addr, bool _useful) public onlyOwner {\r\n    require(_addr != address(0));\r\n    adminContracts[_addr] = _useful;\r\n  }\r\n\r\n  modifier onlyAdmin {\r\n    require(adminContracts[msg.sender]); \r\n    _;\r\n  }\r\n\r\n  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\r\n    actionContracts[_actionAddr] = _useful;\r\n  }\r\n\r\n  modifier onlyAccess() {\r\n    require(actionContracts[msg.sender]);\r\n    _;\r\n  }\r\n}\r\n\r\ninterface CaptainGameConfigInterface {\r\n  function getLevelConfig(uint32 cardId, uint32 level) external view returns (uint32 atk,uint32 defense,uint32 atk_min,uint32 atk_max);\r\n}\r\ncontract CaptainToken is AccessAdmin, ERC721 {\r\n  using SafeMath for SafeMath;\r\n  //event \r\n  event CreateCaptain(uint tokenId,uint32 captainId, address _owner, uint256 _price);\r\n  //ERC721\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n  event LevelUP(address indexed _owner,uint32 oldLevel, uint32 newLevel);\r\n\r\n  struct Captain {\r\n    uint32 captainId;  \r\n    uint32 color; // 1,2,3,4  \r\n    uint32 atk; \r\n    uint32 defense;\r\n    uint32 level;\r\n    uint256 exp;\r\n  }\r\n  CaptainGameConfigInterface public config;\r\n\r\n  Captain[] public captains; //dynamic Array\r\n  function CaptainToken() public {\r\n    captains.length += 1;\r\n    setAdminContract(msg.sender,true);\r\n    setActionContract(msg.sender,true);\r\n  }\r\n  //setting configuration\r\n  function setGameConfigContract(address _address) external onlyOwner {\r\n    config = CaptainGameConfigInterface(_address);\r\n  }\r\n\r\n  /**MAPPING**/\r\n  /// @dev tokenId to owner  tokenId -> address\r\n  mapping (uint256 => address) public captainTokenIdToOwner;\r\n  /// @dev Equipment token ID search in owner array captainId -> tokenId\r\n  mapping (uint256 => uint256) captainIdToOwnerIndex;  \r\n  /// @dev captains owner by the owner (array)\r\n  mapping (address => uint256[]) ownerToCaptainArray;\r\n  /// @dev price of each token\r\n  mapping (uint256 => uint256) captainTokenIdToPrice;\r\n  /// @dev token count of captain\r\n  mapping (uint32 => uint256) tokenCountOfCaptain;\r\n  /// @dev tokens by the captain\r\n  mapping (uint256 => uint32) IndexToCaptain;\r\n  /// @dev The authorized address for each Captain\r\n  mapping (uint256 => address) captainTokenIdToApprovals;\r\n  /// @dev The authorized operators for each address\r\n  mapping (address => mapping (address => bool)) operatorToApprovals;\r\n  mapping(uint256 => bool) tokenToSell;\r\n  \r\n\r\n  /*** CONSTRUCTOR ***/\r\n  /// @dev Amount of tokens destroyed\r\n  uint256 destroyCaptainCount;\r\n  \r\n  // modifier\r\n  /// @dev Check if token ID is valid\r\n  modifier isValidToken(uint256 _tokenId) {\r\n    require(_tokenId >= 1 && _tokenId <= captains.length);\r\n    require(captainTokenIdToOwner[_tokenId] != address(0)); \r\n    _;\r\n  }\r\n  modifier canTransfer(uint256 _tokenId) {\r\n    require(msg.sender == captainTokenIdToOwner[_tokenId] || msg.sender == captainTokenIdToApprovals[_tokenId]);\r\n    _;\r\n  }\r\n  /// @dev Creates a new Captain with the given name.\r\n  function CreateCaptainToken(address _owner,uint256 _price, uint32 _captainId, uint32 _color,uint32 _atk,uint32 _defense,uint32 _level,uint256 _exp) public onlyAccess {\r\n    _createCaptainToken(_owner,_price,_captainId,_color,_atk,_defense,_level,_exp);\r\n  }\r\n\r\n  /// For creating CaptainToken\r\n  function _createCaptainToken(address _owner, uint256 _price, uint32 _captainId, uint32 _color, uint32 _atk, uint32 _defense,uint32 _level,uint256 _exp) \r\n  internal {\r\n    uint256 newTokenId = captains.length;\r\n    Captain memory _captain = Captain({\r\n      captainId: _captainId,\r\n      color: _color,\r\n      atk: _atk,\r\n      defense: _defense,\r\n      level: _level,\r\n      exp: _exp \r\n    });\r\n    captains.push(_captain);\r\n    //event\r\n    CreateCaptain(newTokenId, _captainId, _owner, _price);\r\n    captainTokenIdToPrice[newTokenId] = _price;\r\n    IndexToCaptain[newTokenId] = _captainId;\r\n    tokenCountOfCaptain[_captainId] = SafeMath.add(tokenCountOfCaptain[_captainId],1);\r\n    // This will assign ownership, and also emit the Transfer event as\r\n    // per ERC721 draft\r\n    _transfer(address(0), _owner, newTokenId);\r\n  } \r\n  /// @dev set the token price\r\n  function setTokenPrice(uint256 _tokenId, uint256 _price) external onlyAccess {\r\n    captainTokenIdToPrice[_tokenId] = _price;\r\n  }\r\n\r\n  /// @dev let owner set the token price\r\n  function setTokenPriceByOwner(uint256 _tokenId, uint256 _price) external {\r\n    require(captainTokenIdToOwner[_tokenId] == msg.sender);\r\n    captainTokenIdToPrice[_tokenId] = _price;\r\n  }\r\n\r\n  /// @dev set sellable\r\n  function setSelled(uint256 _tokenId, bool fsell) external onlyAccess {\r\n    tokenToSell[_tokenId] = fsell;\r\n  }\r\n\r\n  function getSelled(uint256 _tokenId) external view returns (bool) {\r\n    return tokenToSell[_tokenId];\r\n  }\r\n\r\n  /// @dev Do the real transfer with out any condition checking\r\n  /// @param _from The old owner of this Captain(If created: 0x0)\r\n  /// @param _to The new owner of this Captain \r\n  /// @param _tokenId The tokenId of the Captain\r\n  function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n    if (_from != address(0)) {\r\n      uint256 indexFrom = captainIdToOwnerIndex[_tokenId];  // tokenId -> captainId\r\n      uint256[] storage cpArray = ownerToCaptainArray[_from];\r\n      require(cpArray[indexFrom] == _tokenId);\r\n\r\n      // If the Captain is not the element of array, change it to with the last\r\n      if (indexFrom != cpArray.length - 1) {\r\n        uint256 lastTokenId = cpArray[cpArray.length - 1];\r\n        cpArray[indexFrom] = lastTokenId; \r\n        captainIdToOwnerIndex[lastTokenId] = indexFrom;\r\n      }\r\n      cpArray.length -= 1; \r\n    \r\n      if (captainTokenIdToApprovals[_tokenId] != address(0)) {\r\n        delete captainTokenIdToApprovals[_tokenId];\r\n      }      \r\n    }\r\n\r\n    // Give the Captain to '_to'\r\n    captainTokenIdToOwner[_tokenId] = _to;\r\n    ownerToCaptainArray[_to].push(_tokenId);\r\n    captainIdToOwnerIndex[_tokenId] = ownerToCaptainArray[_to].length - 1;\r\n        \r\n    Transfer(_from != address(0) ? _from : this, _to, _tokenId);\r\n  }\r\n\r\n\r\n  /// @notice Returns all the relevant information about a specific tokenId.\r\n  /// @param _tokenId The tokenId of the captain\r\n  function getCaptainInfo(uint256 _tokenId) external view returns (\r\n    uint32 captainId,  \r\n    uint32 color, \r\n    uint32 atk,\r\n    uint32 defense,\r\n    uint32 level,\r\n    uint256 exp, \r\n    uint256 price,\r\n    address owner,\r\n    bool selled\r\n  ) {\r\n    Captain storage captain = captains[_tokenId];\r\n    captainId = captain.captainId;\r\n    color = captain.color;\r\n    atk = captain.atk;\r\n    defense = captain.defense;\r\n    level = captain.level;\r\n    exp = captain.exp;\r\n    price = captainTokenIdToPrice[_tokenId];\r\n    owner = captainTokenIdToOwner[_tokenId];\r\n    selled = tokenToSell[_tokenId];\r\n  }\r\n\r\n  /// @dev levelUp \r\n  function LevelUp(uint256 _tokenId,uint32 _level) external payable {\r\n    require(msg.sender == captainTokenIdToOwner[_tokenId]);\r\n    Captain storage captain = captains[_tokenId];\r\n    uint32 captainId = captain.captainId;\r\n    uint32 level = captain.level;\r\n    uint256 cur_exp = SafeMath.mul(SafeMath.mul(level,SafeMath.sub(level,1)),25); // level*(level-1)*25\r\n    uint256 req_exp = SafeMath.mul(SafeMath.mul(_level,SafeMath.sub(_level,1)),25);\r\n    require(captain.exp>=SafeMath.sub(req_exp,cur_exp));\r\n    uint256 exp = SafeMath.sub(captain.exp,SafeMath.sub(req_exp,cur_exp));\r\n    if (SafeMath.add32(level,_level)>=99) {\r\n      captains[_tokenId].level = 99;\r\n    } else {\r\n      captains[_tokenId].level = _level;\r\n    }\r\n\r\n    (captains[_tokenId].atk,captains[_tokenId].defense,,) = config.getLevelConfig(captainId,captains[_tokenId].level);\r\n    captains[_tokenId].exp = exp;\r\n    //event tell the world\r\n    LevelUP(msg.sender,level,captain.level);\r\n  }\r\n\r\n  /// ERC721 \r\n\r\n  function balanceOf(address _owner) external view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownerToCaptainArray[_owner].length;\r\n  }\r\n\r\n  function ownerOf(uint256 _tokenId) external view returns (address) {\r\n    return captainTokenIdToOwner[_tokenId];\r\n  }\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {\r\n    _safeTransferFrom(_from, _to, _tokenId, data);\r\n  }\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /// @dev Actually perform the safeTransferFrom\r\n  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) \r\n    internal\r\n    isValidToken(_tokenId) \r\n    canTransfer(_tokenId)\r\n    {\r\n    address owner = captainTokenIdToOwner[_tokenId];\r\n    require(owner != address(0) && owner == _from);\r\n    require(_to != address(0));\r\n        \r\n    _transfer(_from, _to, _tokenId);\r\n\r\n    // Do the callback after everything is done to avoid reentrancy attack\r\n    /*uint256 codeSize;\r\n    assembly { codeSize := extcodesize(_to) }\r\n    if (codeSize == 0) {\r\n      return;\r\n    }*/\r\n    bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\r\n    // bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")) = 0xf0b9e5ba;\r\n    require(retval == 0xf0b9e5ba);\r\n  }\r\n    \r\n  /// @dev Transfer ownership of an Captain, '_to' must be a vaild address, or the WAR will lost\r\n  /// @param _from The current owner of the Captain\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The Captain to transfer\r\n  function transferFrom(address _from, address _to, uint256 _tokenId)\r\n        external\r\n        whenNotPaused\r\n        isValidToken(_tokenId)\r\n        canTransfer(_tokenId)\r\n        payable\r\n    {\r\n    address owner = captainTokenIdToOwner[_tokenId];\r\n    require(owner != address(0));\r\n    require(owner == _from);\r\n    require(_to != address(0));\r\n        \r\n    _transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /// @dev Safe transfer by trust contracts\r\n  function safeTransferByContract(address _from,address _to, uint256 _tokenId) \r\n  external\r\n  whenNotPaused\r\n  {\r\n    require(actionContracts[msg.sender]);\r\n\r\n    require(_tokenId >= 1 && _tokenId <= captains.length);\r\n    address owner = captainTokenIdToOwner[_tokenId];\r\n    require(owner != address(0));\r\n    require(_to != address(0));\r\n    require(owner != _to);\r\n    require(_from == owner);\r\n\r\n    _transfer(owner, _to, _tokenId);\r\n  }\r\n\r\n  /// @dev Set or reaffirm the approved address for an captain\r\n  /// @param _approved The new approved captain controller\r\n  /// @param _tokenId The captain to approve\r\n  function approve(address _approved, uint256 _tokenId)\r\n    external\r\n    whenNotPaused \r\n    payable\r\n  {\r\n    address owner = captainTokenIdToOwner[_tokenId];\r\n    require(owner != address(0));\r\n    require(msg.sender == owner || operatorToApprovals[owner][msg.sender]);\r\n\r\n    captainTokenIdToApprovals[_tokenId] = _approved;\r\n    Approval(owner, _approved, _tokenId);\r\n  }\r\n\r\n  /// @dev Enable or disable approval for a third party (\"operator\") to manage all your asset.\r\n  /// @param _operator Address to add to the set of authorized operators.\r\n  /// @param _approved True if the operators is approved, false to revoke approval\r\n  function setApprovalForAll(address _operator, bool _approved) \r\n    external \r\n    whenNotPaused\r\n  {\r\n    operatorToApprovals[msg.sender][_operator] = _approved;\r\n    ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /// @dev Get the approved address for a single Captain\r\n  /// @param _tokenId The WAR to find the approved address for\r\n  /// @return The approved address for this WAR, or the zero address if there is none\r\n  function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) {\r\n    return captainTokenIdToApprovals[_tokenId];\r\n  }\r\n  \r\n  /// @dev Query if an address is an authorized operator for another address\r\n  /// @param _owner The address that owns the WARs\r\n  /// @param _operator The address that acts on behalf of the owner\r\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n    return operatorToApprovals[_owner][_operator];\r\n  }\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() public pure returns(string) {\r\n    return \"Pirate Conquest Token\";\r\n  }\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() public pure returns(string) {\r\n    return \"PCT\";\r\n  }\r\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n  ///  Metadata JSON Schema\".\r\n  //function tokenURI(uint256 _tokenId) external view returns (string);\r\n\r\n  /// @notice Count NFTs tracked by this contract\r\n  /// @return A count of valid NFTs tracked by this contract, where each one of\r\n  ///  them has an assigned and queryable owner not equal to the zero address\r\n  function totalSupply() external view returns (uint256) {\r\n    return captains.length - destroyCaptainCount -1;\r\n  }\r\n  /// @notice Enumerate valid NFTs\r\n  /// @dev Throws if `_index` >= `totalSupply()`.\r\n  /// @param _index A counter less than `totalSupply()`\r\n  /// @return The token identifier for the `_index`th NFT,\r\n  ///  (sort order not specified)\r\n  function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n    require(_index<(captains.length - destroyCaptainCount));\r\n    //return captainIdToOwnerIndex[_index];\r\n    return _index;\r\n  }\r\n  /// @notice Enumerate NFTs assigned to an owner\r\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  ///  `_owner` is the zero address, representing invalid NFTs.\r\n  /// @param _owner An address where we are interested in NFTs owned by them\r\n  /// @param _index A counter less than `balanceOf(_owner)`\r\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  ///   (sort order not specified)\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n    require(_index < ownerToCaptainArray[_owner].length);\r\n    if (_owner != address(0)) {\r\n      uint256 tokenId = ownerToCaptainArray[_owner][_index];\r\n      return tokenId;\r\n    }\r\n  }\r\n\r\n  /// @param _owner The owner whose celebrity tokens we are interested in.\r\n  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\r\n  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n  ///  not contract-to-contract calls.\r\n  function tokensOfOwner(address _owner) external view returns (uint256[],uint32[]) {\r\n    uint256 len = ownerToCaptainArray[_owner].length;\r\n    uint256[] memory tokens = new uint256[](len);\r\n    uint32[] memory captainss = new uint32[](len);\r\n    uint256 icount;\r\n    if (_owner != address(0)) {\r\n      for (uint256 i=0;i<len;i++) {\r\n        tokens[i] = ownerToCaptainArray[_owner][icount];\r\n        captainss[i] = IndexToCaptain[ownerToCaptainArray[_owner][icount]];\r\n        icount++;\r\n      }\r\n    }\r\n    return (tokens,captainss);\r\n  }\r\n\r\n  /// @param _captainId The captain whose celebrity tokens we are interested in.\r\n  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\r\n  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n  ///  not contract-to-contract calls.\r\n  function tokensOfCaptain(uint32 _captainId) public view returns(uint256[] captainTokens) {\r\n    uint256 tokenCount = tokenCountOfCaptain[_captainId];\r\n    if (tokenCount == 0) {\r\n        // Return an empty array\r\n      return new uint256[](0);\r\n    } else {\r\n      uint256[] memory result = new uint256[](tokenCount);\r\n      uint256 totalcaptains = captains.length - destroyCaptainCount - 1;\r\n      uint256 resultIndex = 0;\r\n\r\n      uint256 tokenId;\r\n      for (tokenId = 0; tokenId <= totalcaptains; tokenId++) {\r\n        if (IndexToCaptain[tokenId] == _captainId) {\r\n          result[resultIndex] = tokenId;\r\n          resultIndex++;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  } \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGameConfigContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setAdminContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_level\",\"type\":\"uint32\"}],\"name\":\"LevelUp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setTokenPriceByOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCaptainInfo\",\"outputs\":[{\"name\":\"captainId\",\"type\":\"uint32\"},{\"name\":\"color\",\"type\":\"uint32\"},{\"name\":\"atk\",\"type\":\"uint32\"},{\"name\":\"defense\",\"type\":\"uint32\"},{\"name\":\"level\",\"type\":\"uint32\"},{\"name\":\"exp\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"selled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_captainId\",\"type\":\"uint32\"},{\"name\":\"_color\",\"type\":\"uint32\"},{\"name\":\"_atk\",\"type\":\"uint32\"},{\"name\":\"_defense\",\"type\":\"uint32\"},{\"name\":\"_level\",\"type\":\"uint32\"},{\"name\":\"_exp\",\"type\":\"uint256\"}],\"name\":\"CreateCaptainToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_actionAddr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setActionContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"captainTokenIdToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"fsell\",\"type\":\"bool\"}],\"name\":\"setSelled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getSelled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_captainId\",\"type\":\"uint32\"}],\"name\":\"tokensOfCaptain\",\"outputs\":[{\"name\":\"captainTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"captains\",\"outputs\":[{\"name\":\"captainId\",\"type\":\"uint32\"},{\"name\":\"color\",\"type\":\"uint32\"},{\"name\":\"atk\",\"type\":\"uint32\"},{\"name\":\"defense\",\"type\":\"uint32\"},{\"name\":\"level\",\"type\":\"uint32\"},{\"name\":\"exp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferByContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"captainId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"CreateCaptain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldLevel\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"newLevel\",\"type\":\"uint32\"}],\"name\":\"LevelUP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CaptainToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b340bb259e855d4d494aa1ac592b30de84d838294bf66506d8f6aebd5184c13d"}]}