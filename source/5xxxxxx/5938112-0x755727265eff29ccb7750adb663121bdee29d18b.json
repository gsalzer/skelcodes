{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\npragma experimental \"v0.5.0\";\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract ERC20 {\r\n  function balanceOf (address owner) public view returns (uint256);\r\n  function allowance (address owner, address spender) public view returns (uint256);\r\n  function transfer (address to, uint256 value) public returns (bool);\r\n  function transferFrom (address from, address to, uint256 value) public returns (bool);\r\n  function approve (address spender, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract SalesPool {\r\n  using Math for uint256;\r\n\r\n  address public owner;\r\n\r\n  ERC20         public smartToken;\r\n  Math.Fraction public tokenPrice;\r\n\r\n  uint256 public pipeIndex = 1;\r\n  mapping (uint256 => SalesPipe) public indexToPipe;\r\n  mapping (address => uint256)   public pipeToIndex;\r\n\r\n  struct Commission {\r\n    uint256 gt;\r\n    uint256 lte;\r\n    uint256 pa;\r\n  }\r\n\r\n  struct Commissions {\r\n    Commission[] array;\r\n    uint256      length;\r\n  }\r\n\r\n  uint256 termsIndex = 1;\r\n  mapping (uint256 => Commissions) public terms;\r\n\r\n  event CreateSalesPipe(address salesPipe);\r\n\r\n  constructor (\r\n    address _smartTokenAddress,\r\n    uint256 _priceNumerator,\r\n    uint256 _priceDenominator\r\n  ) public {\r\n    owner      = msg.sender;\r\n    smartToken = ERC20(_smartTokenAddress);\r\n\r\n    tokenPrice.numerator   = _priceNumerator;\r\n    tokenPrice.denominator = _priceDenominator;\r\n\r\n    uint256 maxUint256 =\r\n      115792089237316195423570985008687907853269984665640564039457584007913129639935;\r\n\r\n    terms[1].array.push(Commission(0 ether, 2000 ether, 5));\r\n    terms[1].array.push(Commission(2000 ether, 10000 ether, 8));\r\n    terms[1].array.push(Commission(10000 ether, maxUint256, 10));\r\n    terms[1].length = terms[1].array.length;\r\n\r\n    terms[2].array.push(Commission(0 ether, maxUint256, 5));\r\n    terms[2].length = terms[2].array.length;\r\n\r\n    terms[3].array.push(Commission(0 ether, maxUint256, 15));\r\n    terms[3].length = terms[3].array.length;\r\n\r\n    termsIndex = 4;\r\n  }\r\n\r\n  function pushTerms (Commission[] _array) public {\r\n    require(msg.sender == owner);\r\n\r\n    for (uint256 i = 0; i < _array.length; i++) {\r\n      terms[termsIndex].array.push(Commission(_array[i].gt, _array[i].lte, _array[i].pa));\r\n    }\r\n\r\n    terms[termsIndex].length = terms[termsIndex].array.length;\r\n\r\n    termsIndex++;\r\n  }\r\n\r\n  function createPipe (\r\n    uint256 _termsNumber,\r\n    uint256 _allowance,\r\n    bytes32 _secretHash\r\n  ) public {\r\n    require(msg.sender == owner);\r\n\r\n    SalesPipe pipe = new SalesPipe(owner, _termsNumber, smartToken, _secretHash);\r\n\r\n    address pipeAddress = address(pipe);\r\n\r\n    smartToken.approve(pipeAddress, _allowance);\r\n\r\n    indexToPipe[pipeIndex]   = pipe;\r\n    pipeToIndex[pipeAddress] = pipeIndex;\r\n    pipeIndex++;\r\n\r\n    emit CreateSalesPipe(pipeAddress);\r\n  }\r\n\r\n  function setSalesPipeAllowance (address _pipeAddress, uint256 _value) public {\r\n    require(msg.sender == owner);\r\n    smartToken.approve(_pipeAddress, _value);\r\n  }\r\n\r\n  function poolTokenAmount () public view returns (uint256) {\r\n    return smartToken.balanceOf(address(this));\r\n  }\r\n\r\n  function transferEther(address _to, uint256 _value) public {\r\n    require(msg.sender == owner);\r\n    _to.transfer(_value);\r\n  }\r\n\r\n  function transferToken(ERC20 erc20, address _to, uint256 _value) public {\r\n    require(msg.sender == owner);\r\n    erc20.transfer(_to, _value);\r\n  }\r\n\r\n  function setOwner (address _owner) public {\r\n    require(msg.sender == owner);\r\n    owner = _owner;\r\n  }\r\n\r\n  function setSmartToken(address _smartTokenAddress) public {\r\n    require(msg.sender == owner);\r\n    smartToken = ERC20(_smartTokenAddress);\r\n  }\r\n\r\n  function setTokenPrice(uint256 numerator, uint256 denominator) public {\r\n    require(msg.sender == owner);\r\n    require(\r\n      numerator   > 0 &&\r\n      denominator > 0\r\n    );\r\n\r\n    tokenPrice.numerator   = numerator;\r\n    tokenPrice.denominator = denominator;\r\n  }\r\n\r\n  function getTokenPrice () public view returns (uint256, uint256) {\r\n    return (tokenPrice.numerator, tokenPrice.denominator);\r\n  }\r\n\r\n  function getCommissions (uint256 _termsNumber) public view returns (Commissions) {\r\n    return terms[_termsNumber];\r\n  }\r\n  \r\n  function () payable external {}\r\n\r\n}\r\n\r\ncontract SalesPipe {\r\n  using Math for uint256;\r\n\r\n  SalesPool public pool;\r\n  address   public owner;\r\n\r\n  uint256 public termsNumber;\r\n\r\n  ERC20 public smartToken;\r\n\r\n  address public rf = address(0);\r\n  bytes32 public secretHash;\r\n\r\n  bool public available = true;\r\n  bool public finalized = false;\r\n\r\n  uint256 public totalEtherReceived = 0;\r\n\r\n  event TokenPurchase(\r\n    ERC20 indexed smartToken,\r\n    address indexed buyer,\r\n    address indexed receiver,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n\r\n  event RFDeclare (address rf);\r\n  event Finalize  (uint256 fstkRevenue, uint256 rfReceived);\r\n\r\n  constructor (\r\n    address _owner,\r\n    uint256 _termsNumber,\r\n    ERC20   _smartToken,\r\n    bytes32 _secretHash\r\n  ) public {\r\n    pool  = SalesPool(msg.sender);\r\n    owner = _owner;\r\n\r\n    termsNumber = _termsNumber;\r\n    smartToken  = _smartToken;\r\n\r\n    secretHash = _secretHash;\r\n  }\r\n\r\n  function () external payable {\r\n    Math.Fraction memory tokenPrice;\r\n    (tokenPrice.numerator, tokenPrice.denominator) = pool.getTokenPrice();\r\n\r\n    address poolAddress = address(pool);\r\n\r\n    uint256 availableAmount =\r\n      Math.min(\r\n        smartToken.allowance(poolAddress, address(this)),\r\n        smartToken.balanceOf(poolAddress)\r\n      );\r\n    uint256 revenue;\r\n    uint256 purchaseAmount = msg.value.div(tokenPrice);\r\n\r\n    require(\r\n      available &&\r\n      finalized == false &&\r\n      availableAmount > 0 &&\r\n      purchaseAmount  > 0\r\n    );\r\n\r\n    if (availableAmount >= purchaseAmount) {\r\n      revenue = msg.value;\r\n\r\n      if (availableAmount == purchaseAmount) {\r\n        available = false;\r\n      }\r\n    } else {\r\n      purchaseAmount = availableAmount;\r\n      revenue = availableAmount.mulCeil(tokenPrice);\r\n      available = false;\r\n\r\n      msg.sender.transfer(msg.value - revenue);\r\n    }\r\n\r\n    smartToken.transferFrom(poolAddress, msg.sender, purchaseAmount);\r\n\r\n    emit TokenPurchase(smartToken, msg.sender, msg.sender, revenue, purchaseAmount);\r\n\r\n    totalEtherReceived += revenue;\r\n  }\r\n\r\n  function declareRF(string _secret) public {\r\n    require(\r\n      secretHash == keccak256(abi.encodePacked(_secret)) &&\r\n      rf         == address(0)\r\n    );\r\n\r\n    rf = msg.sender;\r\n\r\n    emit RFDeclare(rf);\r\n  }\r\n\r\n  function finalize () public {\r\n    require(\r\n      msg.sender == owner &&\r\n      available  == false &&\r\n      finalized  == false &&\r\n      rf         != address(0)\r\n    );\r\n\r\n    finalized = true;\r\n\r\n    address poolAddress = address(pool);\r\n\r\n    uint256 rfEther   = calculateCommission(address(this).balance, termsNumber);\r\n    uint256 fstkEther = address(this).balance - rfEther;\r\n\r\n    rf.transfer(rfEther);\r\n    poolAddress.transfer(fstkEther);\r\n\r\n    emit Finalize(fstkEther, rfEther);\r\n  }\r\n\r\n  function calculateCommission (\r\n    uint256 _totalReceivedEther,\r\n    uint256 _termsNumber\r\n  ) public view returns (uint256) {\r\n    SalesPool.Commissions memory commissions = pool.getCommissions(_termsNumber);\r\n\r\n    for (uint256 i = 0; i < commissions.length; i++) {\r\n      SalesPool.Commission memory commission = commissions.array[i];\r\n      if (_totalReceivedEther > commission.gt && _totalReceivedEther <= commission.lte) {\r\n        return _totalReceivedEther * commission.pa / 100;\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function setOwner (address _owner) public {\r\n    require(msg.sender == owner);\r\n    owner = _owner;\r\n  }\r\n\r\n  function setTermsNumber (uint256 _termsNumber) public {\r\n    require(msg.sender == owner);\r\n    termsNumber = _termsNumber;\r\n  }\r\n\r\n  function setAvailability (bool _available) public {\r\n    require(msg.sender == owner);\r\n    available = _available;\r\n  }\r\n\r\n}\r\n\r\nlibrary Math {\r\n\r\n  struct Fraction {\r\n    uint256 numerator;\r\n    uint256 denominator;\r\n  }\r\n\r\n  function isPositive(Fraction memory fraction) internal pure returns (bool) {\r\n    return fraction.numerator > 0 && fraction.denominator > 0;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    r = a * b;\r\n    require((a == 0) || (r / a == b));\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    r = a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    require((r = a - b) <= a);\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\r\n    require((r = a + b) >= a);\r\n  }\r\n\r\n  function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n    return x <= y ? x : y;\r\n  }\r\n\r\n  function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n    return x >= y ? x : y;\r\n  }\r\n\r\n  function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\r\n    // try mul\r\n    r = value * m;\r\n    if (r / value == m) {\r\n      // if mul not overflow\r\n      r /= d;\r\n    } else {\r\n      // else div first\r\n      r = mul(value / d, m);\r\n    }\r\n  }\r\n\r\n  function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\r\n    // try mul\r\n    r = value * m;\r\n    if (r / value == m) {\r\n      // mul not overflow\r\n      if (r % d == 0) {\r\n        r /= d;\r\n      } else {\r\n        r = (r / d) + 1;\r\n      }\r\n    } else {\r\n      // mul overflow then div first\r\n      r = mul(value / d, m);\r\n      if (value % d != 0) {\r\n        r += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDiv(x, f.numerator, f.denominator);\r\n  }\r\n\r\n  function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDivCeil(x, f.numerator, f.denominator);\r\n  }\r\n\r\n  function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDiv(x, f.denominator, f.numerator);\r\n  }\r\n\r\n  function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\r\n    return mulDivCeil(x, f.denominator, f.numerator);\r\n  }\r\n\r\n  function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\r\n    return Math.Fraction({\r\n      numerator: mul(x.numerator, y.numerator),\r\n      denominator: mul(x.denominator, y.denominator)\r\n    });\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_available\",\"type\":\"bool\"}],\"name\":\"setAvailability\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"available\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"termsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"smartToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalReceivedEther\",\"type\":\"uint256\"},{\"name\":\"_termsNumber\",\"type\":\"uint256\"}],\"name\":\"calculateCommission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_termsNumber\",\"type\":\"uint256\"}],\"name\":\"setTermsNumber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"declareRF\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_termsNumber\",\"type\":\"uint256\"},{\"name\":\"_smartToken\",\"type\":\"address\"},{\"name\":\"_secretHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"smartToken\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rf\",\"type\":\"address\"}],\"name\":\"RFDeclare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fstkRevenue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rfReceived\",\"type\":\"uint256\"}],\"name\":\"Finalize\",\"type\":\"event\"}]","ContractName":"SalesPipe","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"878","ConstructorArguments":"00000000000000000000000011ef4e91607766a19e544a2f8d0ca68837cad01200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000216a774d40296b54d95352ce5b0460343b7d199312623661fd4b4a57b6efb580dac77a75627e013f8e6e074237cff0b392a28be","Library":"","SwarmSource":""}]}