{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Only the owner may call this method.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0), \"Invalid owner address\");\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract ReviewThisPlease is Ownable \r\n{\r\n    /*******************************************\r\n     * Data\r\n     *******************************************/\r\n    event Accept(string topic, uint256 value);\r\n    event Decline(string topic, uint256 value);\r\n    event NewTopic(string topic, address from, uint256 value);\r\n    event ContributeToTopic(string topic, address from, uint256 value);\r\n    \r\n    struct Supporter \r\n    {\r\n        address addr;\r\n        uint256 value;\r\n    }\r\n    struct SupporterList\r\n    {\r\n        mapping(uint256 => Supporter) idToSupporter;\r\n        uint256 length;\r\n    }\r\n    struct TopicList\r\n    {\r\n        mapping(uint256 => string) idToTopic;\r\n        uint256 length;\r\n    }\r\n    \r\n    uint256 public minForNewTopic;\r\n    uint256 public minForExistingTopic;\r\n   \r\n    mapping(string => SupporterList) private topicToSupporterList;\r\n    mapping(address => TopicList) private supporterToTopicList;\r\n    TopicList private allTopics;\r\n    \r\n    /*******************************************\r\n     * Admin\r\n     *******************************************/\r\n    constructor() public \r\n    {\r\n        minForNewTopic = 0.05 ether;\r\n        minForExistingTopic = 0.001 ether;\r\n    }\r\n    \r\n    function setMins(uint256 _minForNewTopic, uint256 _minForExistingTopic)\r\n        onlyOwner public \r\n    {\r\n        require(_minForNewTopic > 0, \r\n            \"The _minForNewTopic should be > 0.\");\r\n        require(_minForExistingTopic > 0, \r\n            \"The _minForExistingTopic should be > 0.\");\r\n        \r\n        minForNewTopic = _minForNewTopic;\r\n        minForExistingTopic = _minForExistingTopic;\r\n    }\r\n    \r\n    /*******************************************\r\n     * Read only\r\n     *******************************************/\r\n    function getTopicCount() public view returns (uint256)\r\n    {\r\n        return allTopics.length;\r\n    }\r\n    \r\n    function getTopic(uint256 id) public view returns (string)\r\n    {\r\n        return allTopics.idToTopic[id];\r\n    }\r\n    \r\n    function getSupportersForTopic(string topic) public view \r\n        returns (address[], uint256[])\r\n    {\r\n        SupporterList storage supporterList = topicToSupporterList[topic];\r\n        \r\n        address[] memory addressList = new address[](supporterList.length);\r\n        uint256[] memory valueList = new uint256[](supporterList.length);\r\n        \r\n        for(uint i = 0; i < supporterList.length; i++)\r\n        {\r\n            Supporter memory supporter = supporterList.idToSupporter[i];\r\n            addressList[i] = supporter.addr;\r\n            valueList[i] = supporter.value;\r\n        }\r\n        \r\n        return (addressList, valueList);\r\n    }\r\n    \r\n    /*******************************************\r\n     * Public write\r\n     *******************************************/\r\n    function requestTopic(string topic) public payable\r\n    {\r\n        require(bytes(topic).length > 0, \r\n            \"Please specify a topic.\");\r\n        require(bytes(topic).length <= 500, \r\n            \"The topic is too long (max 500 characters).\");\r\n            \r\n        SupporterList storage supporterList = topicToSupporterList[topic];\r\n        \r\n        if(supporterList.length == 0)\r\n        { // New topic\r\n            require(msg.value >= minForNewTopic, \r\n                \"Please send at least 'minForNewTopic' to request a new topic.\");\r\n          \r\n            allTopics.idToTopic[allTopics.length++] = topic;\r\n            emit NewTopic(topic, msg.sender, msg.value);\r\n        }\r\n        else\r\n        { // Existing topic\r\n            require(msg.value >= minForExistingTopic, \r\n                \"Please send at least 'minForExistingTopic' to add support to an existing topic.\");\r\n        \r\n            emit ContributeToTopic(topic, msg.sender, msg.value);\r\n        }\r\n        \r\n        supporterList.idToSupporter[supporterList.length++] = \r\n            Supporter(msg.sender, msg.value);\r\n    }\r\n\r\n    function refund(string topic) public returns (bool)\r\n    {\r\n        SupporterList storage supporterList = topicToSupporterList[topic];\r\n        uint256 amountToRefund = 0;\r\n        for(uint i = 0; i < supporterList.length; i++)\r\n        {\r\n            Supporter memory supporter = supporterList.idToSupporter[i];\r\n            if(supporter.addr == msg.sender)\r\n            {\r\n                amountToRefund += supporter.value;\r\n                supporterList.idToSupporter[i] = supporterList.idToSupporter[--supporterList.length];\r\n                i--;\r\n            }\r\n        }\r\n        \r\n        bool topicWasRemoved = false;\r\n        if(supporterList.length == 0)\r\n        {\r\n            _removeTopic(topic);\r\n            topicWasRemoved = true;\r\n        }\r\n        \r\n        msg.sender.transfer(amountToRefund);\r\n        \r\n        return (topicWasRemoved);\r\n    }\r\n    \r\n    function refundAll() public\r\n    {\r\n        for(uint i = 0; i < allTopics.length; i++)\r\n        {\r\n            if(refund(allTopics.idToTopic[i]))\r\n            {\r\n                i--;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /*******************************************\r\n     * Owner only write\r\n     *******************************************/\r\n    function accept(string topic) public onlyOwner\r\n    {\r\n        SupporterList storage supporterList = topicToSupporterList[topic];\r\n        uint256 totalValue = 0;\r\n        for(uint i = 0; i < supporterList.length; i++)\r\n        {\r\n            totalValue += supporterList.idToSupporter[i].value;\r\n        }\r\n       \r\n        _removeTopic(topic);\r\n        emit Accept(topic, totalValue);\r\n        \r\n        owner.transfer(totalValue);\r\n    }\r\n    \r\n    function decline(string topic) public onlyOwner\r\n    {\r\n        SupporterList storage supporterList = topicToSupporterList[topic];\r\n        uint256 totalValue = 0;\r\n        for(uint i = 0; i < supporterList.length; i++)\r\n        {\r\n            totalValue += supporterList.idToSupporter[i].value;\r\n            supporterList.idToSupporter[i].addr.transfer(\r\n                supporterList.idToSupporter[i].value);\r\n        }\r\n        \r\n        _removeTopic(topic);\r\n        emit Decline(topic, totalValue);\r\n    }\r\n    \r\n    function declineAll() public onlyOwner\r\n    {\r\n        for(uint i = 0; i < allTopics.length; i++)\r\n        {\r\n            decline(allTopics.idToTopic[i]);\r\n        }\r\n    }\r\n    \r\n    /*******************************************\r\n     * Private helpers\r\n     *******************************************/\r\n    function _removeTopic(string topic) private\r\n    {\r\n        delete topicToSupporterList[topic];\r\n        bytes32 topicHash = keccak256(abi.encodePacked(topic));\r\n        for(uint i = 0; i < allTopics.length; i++)\r\n        {\r\n            string memory _topic = allTopics.idToTopic[i];\r\n            if(keccak256(abi.encodePacked(_topic)) == topicHash)\r\n            {\r\n                allTopics.idToTopic[i] = allTopics.idToTopic[--allTopics.length];\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"topic\",\"type\":\"string\"}],\"name\":\"accept\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"declineAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"topic\",\"type\":\"string\"}],\"name\":\"decline\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minForNewTopic\",\"type\":\"uint256\"},{\"name\":\"_minForExistingTopic\",\"type\":\"uint256\"}],\"name\":\"setMins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minForNewTopic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTopic\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minForExistingTopic\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTopicCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"topic\",\"type\":\"string\"}],\"name\":\"getSupportersForTopic\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"topic\",\"type\":\"string\"}],\"name\":\"requestTopic\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"topic\",\"type\":\"string\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"topic\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Accept\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"topic\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Decline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"topic\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewTopic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"topic\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ContributeToTopic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ReviewThisPlease","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7f30dd5be4e01e57742ec83e09a54eb9ba6cc4910128936e8250d3812926476f"}]}