{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract DigixConstants {\r\n  /// general constants\r\n  uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\r\n\r\n  /// asset events\r\n  uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\r\n  uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\r\n  uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\r\n  uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\r\n  uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\r\n  uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\r\n  uint256 constant ASSET_EVENT_MINTED = 7;\r\n  uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\r\n  uint256 constant ASSET_EVENT_RECASTED = 9;\r\n  uint256 constant ASSET_EVENT_REDEEMED = 10;\r\n  uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\r\n  uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\r\n  uint256 constant ASSET_EVENT_REMINTED = 13;\r\n\r\n  /// roles\r\n  uint256 constant ROLE_ZERO_ANYONE = 0;\r\n  uint256 constant ROLE_ROOT = 1;\r\n  uint256 constant ROLE_VENDOR = 2;\r\n  uint256 constant ROLE_XFERAUTH = 3;\r\n  uint256 constant ROLE_POPADMIN = 4;\r\n  uint256 constant ROLE_CUSTODIAN = 5;\r\n  uint256 constant ROLE_AUDITOR = 6;\r\n  uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\r\n  uint256 constant ROLE_KYC_ADMIN = 8;\r\n  uint256 constant ROLE_FEES_ADMIN = 9;\r\n  uint256 constant ROLE_DOCS_UPLOADER = 10;\r\n  uint256 constant ROLE_KYC_RECASTER = 11;\r\n  uint256 constant ROLE_FEES_DISTRIBUTION_ADMIN = 12;\r\n\r\n  /// states\r\n  uint256 constant STATE_ZERO_UNDEFINED = 0;\r\n  uint256 constant STATE_CREATED = 1;\r\n  uint256 constant STATE_VENDOR_ORDER = 2;\r\n  uint256 constant STATE_TRANSFER = 3;\r\n  uint256 constant STATE_CUSTODIAN_DELIVERY = 4;\r\n  uint256 constant STATE_MINTED = 5;\r\n  uint256 constant STATE_AUDIT_FAILURE = 6;\r\n  uint256 constant STATE_REPLACEMENT_ORDER = 7;\r\n  uint256 constant STATE_REPLACEMENT_DELIVERY = 8;\r\n  uint256 constant STATE_RECASTED = 9;\r\n  uint256 constant STATE_REDEEMED = 10;\r\n  uint256 constant STATE_ADMIN_FAILURE = 11;\r\n\r\n  /// interactive contracts\r\n  bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER = \"i:asset:explorer\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_DIGIX_DIRECTORY = \"i:directory\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE = \"i:mp\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN = \"i:mpadmin\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_POPADMIN = \"i:popadmin\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_PRODUCTS_LIST = \"i:products\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_TOKEN = \"i:token\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_BULK_WRAPPER = \"i:bulk-wrapper\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_TOKEN_CONFIG = \"i:token:config\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_TOKEN_INFORMATION = \"i:token:information\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION = \"i:mp:information\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_IDENTITY = \"i:identity\";\r\n\r\n  /// controller contracts\r\n  bytes32 constant CONTRACT_CONTROLLER_ASSETS = \"c:asset\";\r\n  bytes32 constant CONTRACT_CONTROLLER_ASSETS_RECAST = \"c:asset:recast\";\r\n  bytes32 constant CONTRACT_CONTROLLER_ASSETS_EXPLORER = \"c:explorer\";\r\n  bytes32 constant CONTRACT_CONTROLLER_DIGIX_DIRECTORY = \"c:directory\";\r\n  bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE = \"c:mp\";\r\n  bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN = \"c:mpadmin\";\r\n  bytes32 constant CONTRACT_CONTROLLER_PRODUCTS_LIST = \"c:products\";\r\n\r\n  bytes32 constant CONTRACT_CONTROLLER_TOKEN_APPROVAL = \"c:token:approval\";\r\n  bytes32 constant CONTRACT_CONTROLLER_TOKEN_CONFIG = \"c:token:config\";\r\n  bytes32 constant CONTRACT_CONTROLLER_TOKEN_INFO = \"c:token:info\";\r\n  bytes32 constant CONTRACT_CONTROLLER_TOKEN_TRANSFER = \"c:token:transfer\";\r\n\r\n  bytes32 constant CONTRACT_CONTROLLER_JOB_ID = \"c:jobid\";\r\n  bytes32 constant CONTRACT_CONTROLLER_IDENTITY = \"c:identity\";\r\n\r\n  /// storage contracts\r\n  bytes32 constant CONTRACT_STORAGE_ASSETS = \"s:asset\";\r\n  bytes32 constant CONTRACT_STORAGE_ASSET_EVENTS = \"s:asset:events\";\r\n  bytes32 constant CONTRACT_STORAGE_DIGIX_DIRECTORY = \"s:directory\";\r\n  bytes32 constant CONTRACT_STORAGE_MARKETPLACE = \"s:mp\";\r\n  bytes32 constant CONTRACT_STORAGE_PRODUCTS_LIST = \"s:products\";\r\n  bytes32 constant CONTRACT_STORAGE_GOLD_TOKEN = \"s:goldtoken\";\r\n  bytes32 constant CONTRACT_STORAGE_JOB_ID = \"s:jobid\";\r\n  bytes32 constant CONTRACT_STORAGE_IDENTITY = \"s:identity\";\r\n\r\n  /// service contracts\r\n  bytes32 constant CONTRACT_SERVICE_TOKEN_DEMURRAGE = \"sv:tdemurrage\";\r\n  bytes32 constant CONTRACT_SERVICE_MARKETPLACE = \"sv:mp\";\r\n  bytes32 constant CONTRACT_SERVICE_DIRECTORY = \"sv:directory\";\r\n\r\n  /// fees distributors\r\n  bytes32 constant CONTRACT_DEMURRAGE_FEES_DISTRIBUTOR = \"fees:distributor:demurrage\";\r\n  bytes32 constant CONTRACT_RECAST_FEES_DISTRIBUTOR = \"fees:distributor:recast\";\r\n  bytes32 constant CONTRACT_TRANSFER_FEES_DISTRIBUTOR = \"fees:distributor:transfer\";\r\n}\r\n\r\ncontract ContractResolver {\r\n  address public owner;\r\n  bool public locked;\r\n  function init_register_contract(bytes32 _key, address _contract_address) public returns (bool _success);\r\n  function unregister_contract(bytes32 _key) public returns (bool _success);\r\n  function get_contract(bytes32 _key) public constant returns (address _contract);\r\n}\r\n\r\ncontract ResolverClient {\r\n\r\n  /// The address of the resolver contract for this project\r\n  address public resolver;\r\n  /// The key to identify this contract\r\n  bytes32 public key;\r\n\r\n  /// Make our own address available to us as a constant\r\n  address public CONTRACT_ADDRESS;\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == ContractResolver(resolver).get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check resolver's locking status.\r\n  modifier unless_resolver_is_locked() {\r\n    require(is_locked() == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev Initialize new contract\r\n  /// @param _key the resolver key for this contract\r\n  /// @return _success if the initialization is successful\r\n  function init(bytes32 _key, address _resolver)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(_resolver).locked();\r\n    if (_is_locked == false) {\r\n      CONTRACT_ADDRESS = address(this);\r\n      resolver = _resolver;\r\n      key = _key;\r\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\r\n      _success = true;\r\n    }  else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Destroy the contract and unregister self from the ContractResolver\r\n  /// @dev Can only be called by the owner of ContractResolver\r\n  function destroy()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(resolver).locked();\r\n    require(!_is_locked);\r\n\r\n    address _owner_of_contract_resolver = ContractResolver(resolver).owner();\r\n    require(msg.sender == _owner_of_contract_resolver);\r\n\r\n    _success = ContractResolver(resolver).unregister_contract(key);\r\n    require(_success);\r\n\r\n    selfdestruct(_owner_of_contract_resolver);\r\n  }\r\n\r\n  /// @dev Check if resolver is locked\r\n  /// @return _locked if the resolver is currently locked\r\n  function is_locked()\r\n           private\r\n           constant\r\n           returns (bool _locked)\r\n  {\r\n    _locked = ContractResolver(resolver).locked();\r\n  }\r\n\r\n  /// @dev Get the address of a contract\r\n  /// @param _key the resolver key to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           constant\r\n           returns (address _contract)\r\n  {\r\n    _contract = ContractResolver(resolver).get_contract(_key);\r\n  }\r\n}\r\n\r\n/**\r\n  @title Indexed Bytes Iterator Interactive\r\n  @author Digix Holdings Pte Ltd\r\n*/\r\ncontract IndexedBytesIteratorInteractive {\r\n\r\n  /**\r\n    @notice Lists an indexed Bytes collection from start or end\r\n    @param _collection_index Index of the Collection to list\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_last Function that returns the last Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @param _function_previous Function that returns previous Bytes item in the list\r\n    @param _from_start whether to read from start (or end) of the list\r\n    @return {\"_bytes_items\" : \"Collection of reversed Bytes list\"}\r\n  */\r\n  function list_indexed_bytesarray(bytes32 _collection_index, uint256 _count,\r\n                              function (bytes32) external constant returns (bytes32) _function_first,\r\n                              function (bytes32) external constant returns (bytes32) _function_last,\r\n                              function (bytes32, bytes32) external constant returns (bytes32) _function_next,\r\n                              function (bytes32, bytes32) external constant returns (bytes32) _function_previous,\r\n                              bool _from_start)\r\n           internal\r\n           constant\r\n           returns (bytes32[] _indexed_bytes_items)\r\n  {\r\n    if (_from_start) {\r\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _function_first(_collection_index), _count, true, _function_last, _function_next);\r\n    } else {\r\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _function_last(_collection_index), _count, true, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice Lists an indexed Bytes collection from some `_current_item`, going forwards or backwards depending on `_from_start`\r\n    @param _collection_index Index of the Collection to list\r\n    @param _current_item The current Item\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_last Function that returns the last Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @param _function_previous Function that returns previous Bytes item in the list\r\n    @param _from_start whether to read in the forwards ( or backwards) direction\r\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  function list_indexed_bytesarray_from(bytes32 _collection_index, bytes32 _current_item, uint256 _count,\r\n                                function (bytes32) external constant returns (bytes32) _function_first,\r\n                                function (bytes32) external constant returns (bytes32) _function_last,\r\n                                function (bytes32, bytes32) external constant returns (bytes32) _function_next,\r\n                                function (bytes32, bytes32) external constant returns (bytes32) _function_previous,\r\n                                bool _from_start)\r\n           internal\r\n           constant\r\n           returns (bytes32[] _indexed_bytes_items)\r\n  {\r\n    if (_from_start) {\r\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _current_item, _count, false, _function_last, _function_next);\r\n    } else {\r\n      _indexed_bytes_items = private_list_indexed_bytes_from_bytes(_collection_index, _current_item, _count, false, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice a private function to lists an indexed Bytes collection starting from some `_current_item` (which could be included or excluded), in the forwards or backwards direction\r\n    @param _collection_index Index of the Collection to list\r\n    @param _current_item The item where we start reading from the list\r\n    @param _count Total number of Bytes items to return\r\n    @param _including_current Whether the `_current_item` should be included in the result\r\n    @param _function_last Function that returns the bytes where we stop reading more bytes\r\n    @param _function_next Function that returns the next bytes to read after another bytes (could be backwards or forwards in the physical collection)\r\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  function private_list_indexed_bytes_from_bytes(bytes32 _collection_index, bytes32 _current_item, uint256 _count, bool _including_current,\r\n                                         function (bytes32) external constant returns (bytes32) _function_last,\r\n                                         function (bytes32, bytes32) external constant returns (bytes32) _function_next)\r\n           private\r\n           constant\r\n           returns (bytes32[] _indexed_bytes_items)\r\n  {\r\n    uint256 _i;\r\n    uint256 _real_count = 0;\r\n    bytes32 _last_item;\r\n\r\n    _last_item = _function_last(_collection_index);\r\n    if (_count == 0 || _last_item == bytes32(0x0)) {  // if count is 0 or the collection is empty, returns empty array\r\n      _indexed_bytes_items = new bytes32[](0);\r\n    } else {\r\n      bytes32[] memory _items_temp = new bytes32[](_count);\r\n      bytes32 _this_item;\r\n      if (_including_current) {\r\n        _items_temp[0] = _current_item;\r\n        _real_count = 1;\r\n      }\r\n      _this_item = _current_item;\r\n      for (_i = _real_count; (_i < _count) && (_this_item != _last_item);_i++) {\r\n        _this_item = _function_next(_collection_index, _this_item);\r\n        if (_this_item != bytes32(0x0)) {\r\n          _real_count++;\r\n          _items_temp[_i] = _this_item;\r\n        }\r\n      }\r\n\r\n      _indexed_bytes_items = new bytes32[](_real_count);\r\n      for(_i = 0;_i < _real_count;_i++) {\r\n        _indexed_bytes_items[_i] = _items_temp[_i];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n  @title Bytes Iterator Interactive\r\n  @author Digix Holdings Pte Ltd\r\n*/\r\ncontract BytesIteratorInteractive {\r\n\r\n  /**\r\n    @notice Lists a Bytes collection from start or end\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_last Function that returns the last Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @param _function_previous Function that returns previous Bytes item in the list\r\n    @param _from_start whether to read from start (or end) of the list\r\n    @return {\"_bytes_items\" : \"Collection of reversed Bytes list\"}\r\n  */\r\n  function list_bytesarray(uint256 _count,\r\n                                 function () external constant returns (bytes32) _function_first,\r\n                                 function () external constant returns (bytes32) _function_last,\r\n                                 function (bytes32) external constant returns (bytes32) _function_next,\r\n                                 function (bytes32) external constant returns (bytes32) _function_previous,\r\n                                 bool _from_start)\r\n           internal\r\n           constant\r\n           returns (bytes32[] _bytes_items)\r\n  {\r\n    if (_from_start) {\r\n      _bytes_items = private_list_bytes_from_bytes(_function_first(), _count, true, _function_last, _function_next);\r\n    } else {\r\n      _bytes_items = private_list_bytes_from_bytes(_function_last(), _count, true, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice Lists a Bytes collection from some `_current_item`, going forwards or backwards depending on `_from_start`\r\n    @param _current_item The current Item\r\n    @param _count Total number of Bytes items to return\r\n    @param _function_first Function that returns the First Bytes item in the list\r\n    @param _function_last Function that returns the last Bytes item in the list\r\n    @param _function_next Function that returns the Next Bytes item in the list\r\n    @param _function_previous Function that returns previous Bytes item in the list\r\n    @param _from_start whether to read in the forwards ( or backwards) direction\r\n    @return {\"_bytes_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  function list_bytesarray_from(bytes32 _current_item, uint256 _count,\r\n                                function () external constant returns (bytes32) _function_first,\r\n                                function () external constant returns (bytes32) _function_last,\r\n                                function (bytes32) external constant returns (bytes32) _function_next,\r\n                                function (bytes32) external constant returns (bytes32) _function_previous,\r\n                                bool _from_start)\r\n           internal\r\n           constant\r\n           returns (bytes32[] _bytes_items)\r\n  {\r\n    if (_from_start) {\r\n      _bytes_items = private_list_bytes_from_bytes(_current_item, _count, false, _function_last, _function_next);\r\n    } else {\r\n      _bytes_items = private_list_bytes_from_bytes(_current_item, _count, false, _function_first, _function_previous);\r\n    }\r\n  }\r\n\r\n  /**\r\n    @notice A private function to lists a Bytes collection starting from some `_current_item` (which could be included or excluded), in the forwards or backwards direction\r\n    @param _current_item The current Item\r\n    @param _count Total number of Bytes items to return\r\n    @param _including_current Whether the `_current_item` should be included in the result\r\n    @param _function_last Function that returns the bytes where we stop reading more bytes\r\n    @param _function_next Function that returns the next bytes to read after some bytes (could be backwards or forwards in the physical collection)\r\n    @return {\"_address_items\" :\"Collection/list of Bytes\"}\r\n  */\r\n  function private_list_bytes_from_bytes(bytes32 _current_item, uint256 _count, bool _including_current,\r\n                                 function () external constant returns (bytes32) _function_last,\r\n                                 function (bytes32) external constant returns (bytes32) _function_next)\r\n           private\r\n           constant\r\n           returns (bytes32[] _bytes32_items)\r\n  {\r\n    uint256 _i;\r\n    uint256 _real_count = 0;\r\n    bytes32 _last_item;\r\n\r\n    _last_item = _function_last();\r\n    if (_count == 0 || _last_item == bytes32(0x0)) {\r\n      _bytes32_items = new bytes32[](0);\r\n    } else {\r\n      bytes32[] memory _items_temp = new bytes32[](_count);\r\n      bytes32 _this_item;\r\n      if (_including_current == true) {\r\n        _items_temp[0] = _current_item;\r\n        _real_count = 1;\r\n      }\r\n      _this_item = _current_item;\r\n      for (_i = _real_count; (_i < _count) && (_this_item != _last_item);_i++) {\r\n        _this_item = _function_next(_this_item);\r\n        if (_this_item != bytes32(0x0)) {\r\n          _real_count++;\r\n          _items_temp[_i] = _this_item;\r\n        }\r\n      }\r\n\r\n      _bytes32_items = new bytes32[](_real_count);\r\n      for(_i = 0;_i < _real_count;_i++) {\r\n        _bytes32_items[_i] = _items_temp[_i];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ncontract AssetsStorage {\r\n}\r\n\r\ncontract GoldTokenStorage {\r\n  function read_supply() constant public returns (uint256 _total_supply, uint256 _effective_total_supply);\r\n}\r\n\r\ncontract MarketplaceStorage {\r\n}\r\n\r\ncontract AssetsController {\r\n}\r\n\r\ncontract AssetsExplorerController {\r\n  function get_first_item_in_state(bytes32 _state_id) public constant returns (bytes32 _item);\r\n  function get_last_item_in_state(bytes32 _state_id) public constant returns (bytes32 _item);\r\n  function get_next_item_in_state_from_item(bytes32 _state_id, bytes32 _current_item) public constant returns (bytes32 _item);\r\n  function get_previous_item_in_state_from_item(bytes32 _state_id, bytes32 _current_item) public constant returns (bytes32 _item);\r\n  function get_first_global_audit_document() public constant returns (bytes32 _document);\r\n  function get_last_global_audit_document() public constant returns (bytes32 _document);\r\n  function get_next_global_audit_document(bytes32 _current_document) public constant returns (bytes32 _document);\r\n  function get_previous_global_audit_document(bytes32 _current_document) public constant returns (bytes32 _document);\r\n  function get_first_asset_document(bytes32 _item) public constant returns (bytes32 _document);\r\n  function get_last_asset_document(bytes32 _item) public constant returns (bytes32 _document);\r\n  function get_next_asset_document_from_document(bytes32 _item, bytes32 _current_document) public constant returns (bytes32 _document);\r\n  function get_previous_asset_document_from_document(bytes32 _item, bytes32 _current_document) public constant returns (bytes32 _document);\r\n  function get_first_user_recast(bytes32 _user_key) public constant returns (bytes32 _item);\r\n  function get_last_user_recast(bytes32 _user_key) public constant returns (bytes32 _item);\r\n  function get_next_user_recast_from_item(bytes32 _user_key, bytes32 _current_item) public constant returns (bytes32 _item);\r\n  function get_previous_user_recast_from_item(bytes32 _user_key, bytes32 _current_item) public constant returns (bytes32 _item);\r\n  function get_asset_info(bytes32 _item) public constant returns (uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight, bytes32 _serial, uint256 _state_id, uint256 _documents_count, uint256 _time_minted, uint256 _redeem_deadline);\r\n  function get_asset_details(bytes32 _item) public constant returns (address _mint_target, address _redeem_for, bytes32 _replaced_by, bytes32 _replaces);\r\n  function get_total_items_in_state(bytes32 _state_id) public constant returns (uint256 _total_items);\r\n  function get_asset_events_count(bytes32 _item) public constant returns (uint256 _count);\r\n  function get_asset_event_details(bytes32 _item, uint256 _event_index) public constant returns (uint256 _event_type, uint256 _timestamp);\r\n  function get_last_global_audit_time() public constant returns (uint256 _last_global_audit_time);\r\n}\r\n\r\n/// @title Assets-Related Information\r\n/// @author Digix Holdings Pte Ltd\r\n/// @notice This contract is used to read all information related to the assets in the Proof of Provenance protocol\r\ncontract AssetsExplorer is ResolverClient, IndexedBytesIteratorInteractive, BytesIteratorInteractive, DigixConstants {\r\n\r\n  function AssetsExplorer(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_INTERACTIVE_ASSETS_EXPLORER, _resolver));\r\n  }\r\n\r\n  function assets_controller()\r\n           internal\r\n           constant\r\n           returns (AssetsController _contract)\r\n  {\r\n    _contract = AssetsController(get_contract(CONTRACT_CONTROLLER_ASSETS));\r\n  }\r\n\r\n  function gold_token_storage()\r\n           internal\r\n           constant\r\n           returns (GoldTokenStorage _contract)\r\n  {\r\n    _contract = GoldTokenStorage(get_contract(CONTRACT_STORAGE_GOLD_TOKEN));\r\n  }\r\n\r\n  function marketplace_storage()\r\n           internal\r\n           constant\r\n           returns (MarketplaceStorage _contract)\r\n  {\r\n    _contract = MarketplaceStorage(get_contract(CONTRACT_STORAGE_MARKETPLACE));\r\n  }\r\n\r\n  function assets_explorer_controller()\r\n           internal\r\n           constant\r\n           returns (AssetsExplorerController _contract)\r\n  {\r\n    _contract = AssetsExplorerController(get_contract(CONTRACT_CONTROLLER_ASSETS_EXPLORER));\r\n  }\r\n\r\n  /// @dev List Assets in a particular state\r\n  /// @param  _state_id The state ID at which we fetch assets\r\n  /// @param _count The number of assets to be listed\r\n  /// @param _from_start List from start or end\r\n  /// @return _assets the assets to be listed\r\n  function listAssets(uint256 _state_id, uint256 _count, bool _from_start)\r\n           public\r\n           constant\r\n           returns (bytes32[] _assets)\r\n  {\r\n    bytes32 _collection = bytes32(_state_id);\r\n    _assets = list_indexed_bytesarray(_collection, _count,\r\n                                            assets_explorer_controller().get_first_item_in_state,\r\n                                            assets_explorer_controller().get_last_item_in_state,\r\n                                            assets_explorer_controller().get_next_item_in_state_from_item,\r\n                                            assets_explorer_controller().get_previous_item_in_state_from_item,\r\n                                            _from_start);\r\n  }\r\n\r\n  /// @dev List assets in a particular state starting from an asset item\r\n  /// @param _state_id state id at which we list assets\r\n  /// @param _current_item list assets from this item\r\n  /// @param _count number of assets to list\r\n  /// @param _from_start whether to list in forward or backward direction\r\n  /// @return _assets the assets to be listed\r\n  function listAssetsFrom(uint256 _state_id, bytes32 _current_item, uint256 _count, bool _from_start)\r\n           public\r\n           constant\r\n           returns (bytes32[] _assets)\r\n  {\r\n    bytes32 _collection = bytes32(_state_id);\r\n    _assets = list_indexed_bytesarray_from(_collection, _current_item, _count,\r\n                                          assets_explorer_controller().get_first_item_in_state,\r\n                                          assets_explorer_controller().get_last_item_in_state,\r\n                                          assets_explorer_controller().get_next_item_in_state_from_item,\r\n                                          assets_explorer_controller().get_previous_item_in_state_from_item,\r\n                                          _from_start);\r\n  }\r\n\r\n  /// @dev list global audit documents\r\n  /// @param _count number of documents to list\r\n  /// @param _from_start whether to list from start or end\r\n  /// @return _documents the documents to be listed\r\n  function listGlobalAuditDocuments(uint256 _count, bool _from_start)\r\n           public\r\n           constant\r\n           returns (bytes32[] _documents)\r\n  {\r\n    _documents =  list_bytesarray(_count,\r\n                                        assets_explorer_controller().get_first_global_audit_document,\r\n                                        assets_explorer_controller().get_last_global_audit_document,\r\n                                        assets_explorer_controller().get_next_global_audit_document,\r\n                                        assets_explorer_controller().get_previous_global_audit_document,\r\n                                        _from_start);\r\n  }\r\n\r\n  /// @dev list global audit documents from a specific document\r\n  /// @param _current_document list documents from this document\r\n  /// @param _count number of documents to list\r\n  /// @param _from_start whether to list forward or backward\r\n  /// @return _documents the list of documents\r\n  function listGlobalAuditDocumentsFrom(bytes32 _current_document, uint256 _count, bool _from_start)\r\n           public\r\n           constant\r\n           returns (bytes32[] _documents)\r\n  {\r\n    _documents = list_bytesarray_from(_current_document, _count,\r\n                                      assets_explorer_controller().get_first_global_audit_document,\r\n                                      assets_explorer_controller().get_last_global_audit_document,\r\n                                      assets_explorer_controller().get_next_global_audit_document,\r\n                                      assets_explorer_controller().get_previous_global_audit_document,\r\n                                      _from_start);\r\n  }\r\n\r\n  /// @dev list supporting documents of an asset\r\n  /// @param _item assets item for which to list documents\r\n  /// @param _count number of documents to list\r\n  /// @param _from_start whether to list from start or end\r\n  /// @return _documents the list of documents for the asset\r\n  function listAssetDocuments(bytes32 _item, uint256 _count, bool _from_start)\r\n           public\r\n           constant\r\n           returns (bytes32[] _documents)\r\n  {\r\n    _documents = list_indexed_bytesarray(_item, _count,\r\n                                               assets_explorer_controller().get_first_asset_document,\r\n                                               assets_explorer_controller().get_last_asset_document,\r\n                                               assets_explorer_controller().get_next_asset_document_from_document,\r\n                                               assets_explorer_controller().get_previous_asset_document_from_document,\r\n                                               _from_start);\r\n  }\r\n\r\n  /// @dev list supporting documents of an asset, from a specific document\r\n  /// @param _item the asset item for which to list documents\r\n  /// @param _current_document the document from which to list documents\r\n  /// @param _count the number of documents to be listed\r\n  /// @param _from_start whether to list forward or backward\r\n  /// @return _documents the list of documents\r\n  function listAssetDocumentsFrom(bytes32 _item, bytes32 _current_document, uint256 _count, bool _from_start)\r\n           public\r\n           constant\r\n           returns (bytes32[] _documents)\r\n  {\r\n    _documents = list_indexed_bytesarray_from(_item, _current_document, _count,\r\n                                              assets_explorer_controller().get_first_asset_document,\r\n                                              assets_explorer_controller().get_last_asset_document,\r\n                                              assets_explorer_controller().get_next_asset_document_from_document,\r\n                                              assets_explorer_controller().get_previous_asset_document_from_document,\r\n                                              _from_start);\r\n  }\r\n\r\n  /// @dev list recast items by a user\r\n  /// @param _user the user for which to list recasts\r\n  /// @param _count the number of recasts to list\r\n  /// @param _from_start whether to list from start or end\r\n  /// return _items the list of user recasts\r\n  function listUserRecasts(address _user, uint256 _count, bool _from_start)\r\n           public\r\n           constant\r\n           returns (bytes32[] _items)\r\n  {\r\n    bytes32 _user_key = bytes32(_user);\r\n    _items = list_indexed_bytesarray(_user_key, _count,\r\n                                           assets_explorer_controller().get_first_user_recast,\r\n                                           assets_explorer_controller().get_last_user_recast,\r\n                                           assets_explorer_controller().get_next_user_recast_from_item,\r\n                                           assets_explorer_controller().get_previous_user_recast_from_item,\r\n                                           _from_start);\r\n  }\r\n\r\n  /// @dev list recast items by a user from a specific item\r\n  /// @param _user the user for which to list recast items\r\n  /// @param _current_item the item from which to list the recast items\r\n  /// @param _count the number of items to be listed\r\n  /// @param _from_start whether to list forward or backward\r\n  /// @return _items the list of recast items for the user\r\n  function listUserRecastsFrom(address _user, bytes32 _current_item, uint256 _count, bool _from_start)\r\n           public\r\n           constant\r\n           returns (bytes32[] _items)\r\n  {\r\n    bytes32 _user_key = bytes32(_user);\r\n    _items = list_indexed_bytesarray_from(_user_key, _current_item, _count,\r\n                                          assets_explorer_controller().get_first_user_recast,\r\n                                          assets_explorer_controller().get_last_user_recast,\r\n                                          assets_explorer_controller().get_next_user_recast_from_item,\r\n                                          assets_explorer_controller().get_previous_user_recast_from_item,\r\n                                          _from_start);\r\n  }\r\n\r\n  /// @dev show asset information\r\n  /// @param _item asset item\r\n  /// @return {\r\n  ///   \"_product_id\": \"product ID of the asset\",\r\n  ///   \"_ng_weight\": \"weight of asset, in nanograms\",\r\n  ///   \"_effective_ng_weight\": \"equivalent weight in nanograms of .9999 gold (which is also the number of DGX minted for this asset)\",\r\n  ///   \"_serial\": \"serial ID of the asset\",\r\n  ///   \"_state_id\": \"the current state id of the asset\",\r\n  ///   \"_documents_count\": \"the number of supporting documents for this asset\",\r\n  ///   \"_time_minted\": \"time at which the DGX tokens were minted for this asset\",\r\n  ///   \"_replaced_by\": \"if audit failure happened, this original asset was replaced by this item\"\r\n  /// }\r\n  function showAssetInfo(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _product_id, uint256 _ng_weight, uint256 _effective_ng_weight,\r\n                    bytes32 _serial, uint256 _state_id, uint256 _documents_count, uint256 _time_minted, bytes32 _replaced_by)\r\n  {\r\n    (_product_id, _ng_weight, _effective_ng_weight,\r\n     _serial, _state_id, _documents_count, _time_minted,) = assets_explorer_controller().get_asset_info(_item);\r\n    (,,_replaced_by,) = assets_explorer_controller().get_asset_details(_item);\r\n  }\r\n\r\n  /// @dev show asset details\r\n  /// @param _item asset item\r\n  /// @return {\r\n  ///   \"_mint_target\": \"asset was minted to this address\",\r\n  ///   \"_redeem_for\": \"asset can be redeemed by this address\",\r\n  ///   \"_replaced_by\": \"if audit failure happened, this original asset was replaced by this item\",\r\n  ///   \"_replaces\": \"the failed item which this item replaces\",\r\n  ///   \"_redeem_deadline\": \"asset can be redeemed before this deadline\"\r\n  /// }\r\n  function showAssetDetails(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (address _mint_target, address _redeem_for, bytes32 _replaced_by, bytes32 _replaces, uint256 _redeem_deadline)\r\n  {\r\n    (_mint_target, _redeem_for, _replaced_by, _replaces) = assets_explorer_controller().get_asset_details(_item);\r\n    (,,,,,,,_redeem_deadline) = assets_explorer_controller().get_asset_info(_item);\r\n  }\r\n\r\n  /// @dev returns the number of assets in a state\r\n  /// @param _state_id the state ID\r\n  /// @return _count the number of assets in _state_id\r\n  function countAssets(uint256 _state_id)\r\n           public\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = assets_explorer_controller().get_total_items_in_state(bytes32(_state_id));\r\n  }\r\n\r\n  /// @dev the total supply of DGX tokens and .9999 gold in the vaults\r\n  /// @return {\r\n  ///   \"_total_supply\": \"total supply of DGX tokens\",\r\n  ///   \"_effective_total_supply\": \"total amount of .9999 gold in the vaults. This will only be temporarily smaller than _total_supply when an audit failure happens\"\r\n  /// }\r\n  function showSupply()\r\n           public\r\n           constant\r\n           returns (uint256 _total_supply, uint256 _effective_total_supply)\r\n  {\r\n    (_total_supply, _effective_total_supply) = gold_token_storage().read_supply();\r\n  }\r\n\r\n  /// @dev returns the number of asset events that has happened to an asset item\r\n  /// @param _item the asset item\r\n  /// return _count the number of events\r\n  function countAssetEvents(bytes32 _item)\r\n           public\r\n           constant\r\n           returns (uint256 _count)\r\n  {\r\n    _count = assets_explorer_controller().get_asset_events_count(_item);\r\n  }\r\n\r\n  /// @dev returns the information of a particular asset event of an asset item\r\n  /// @param _item the asset item\r\n  /// @param _event_index the index of the asset event (index goes from 0)\r\n  /// @return {\r\n  ///   \"_event_type\": \"the type of event\",\r\n  ///   \"_timestamp\": \"time at which the event happened\"\r\n  /// }\r\n  function showAssetEvent(bytes32 _item, uint256 _event_index)\r\n           public\r\n           constant\r\n           returns (uint256 _event_type, uint256 _timestamp)\r\n  {\r\n    (_event_type, _timestamp) = assets_explorer_controller().get_asset_event_details(_item, _event_index);\r\n  }\r\n\r\n  /// @dev return the time at which last global audit was done\r\n  /// @return _last_global_audit_time The time of last global audit\r\n  function showLastGlobalAuditTime()\r\n           public\r\n           constant\r\n           returns (uint256 _last_global_audit_time)\r\n  {\r\n    _last_global_audit_time = assets_explorer_controller().get_last_global_audit_time();\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_from_start\",\"type\":\"bool\"}],\"name\":\"listGlobalAuditDocuments\",\"outputs\":[{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_item\",\"type\":\"bytes32\"}],\"name\":\"countAssetEvents\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_state_id\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_from_start\",\"type\":\"bool\"}],\"name\":\"listAssets\",\"outputs\":[{\"name\":\"_assets\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_item\",\"type\":\"bytes32\"}],\"name\":\"showAssetInfo\",\"outputs\":[{\"name\":\"_product_id\",\"type\":\"uint256\"},{\"name\":\"_ng_weight\",\"type\":\"uint256\"},{\"name\":\"_effective_ng_weight\",\"type\":\"uint256\"},{\"name\":\"_serial\",\"type\":\"bytes32\"},{\"name\":\"_state_id\",\"type\":\"uint256\"},{\"name\":\"_documents_count\",\"type\":\"uint256\"},{\"name\":\"_time_minted\",\"type\":\"uint256\"},{\"name\":\"_replaced_by\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showSupply\",\"outputs\":[{\"name\":\"_total_supply\",\"type\":\"uint256\"},{\"name\":\"_effective_total_supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_state_id\",\"type\":\"uint256\"}],\"name\":\"countAssets\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_item\",\"type\":\"bytes32\"},{\"name\":\"_current_document\",\"type\":\"bytes32\"},{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_from_start\",\"type\":\"bool\"}],\"name\":\"listAssetDocumentsFrom\",\"outputs\":[{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_from_start\",\"type\":\"bool\"}],\"name\":\"listUserRecasts\",\"outputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_item\",\"type\":\"bytes32\"},{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_from_start\",\"type\":\"bool\"}],\"name\":\"listAssetDocuments\",\"outputs\":[{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_item\",\"type\":\"bytes32\"}],\"name\":\"showAssetDetails\",\"outputs\":[{\"name\":\"_mint_target\",\"type\":\"address\"},{\"name\":\"_redeem_for\",\"type\":\"address\"},{\"name\":\"_replaced_by\",\"type\":\"bytes32\"},{\"name\":\"_replaces\",\"type\":\"bytes32\"},{\"name\":\"_redeem_deadline\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_item\",\"type\":\"bytes32\"},{\"name\":\"_event_index\",\"type\":\"uint256\"}],\"name\":\"showAssetEvent\",\"outputs\":[{\"name\":\"_event_type\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_current_item\",\"type\":\"bytes32\"},{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_from_start\",\"type\":\"bool\"}],\"name\":\"listUserRecastsFrom\",\"outputs\":[{\"name\":\"_items\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_state_id\",\"type\":\"uint256\"},{\"name\":\"_current_item\",\"type\":\"bytes32\"},{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_from_start\",\"type\":\"bool\"}],\"name\":\"listAssetsFrom\",\"outputs\":[{\"name\":\"_assets\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_current_document\",\"type\":\"bytes32\"},{\"name\":\"_count\",\"type\":\"uint256\"},{\"name\":\"_from_start\",\"type\":\"bool\"}],\"name\":\"listGlobalAuditDocumentsFrom\",\"outputs\":[{\"name\":\"_documents\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"showLastGlobalAuditTime\",\"outputs\":[{\"name\":\"_last_global_audit_time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"AssetsExplorer","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000db2ddb220b8a55e0e4412130e6ae74d136c04ba2","Library":"","SwarmSource":"bzzr://bc4bf8e625e2fb5f2ae09f24de3b3ffb402259a2c2fe0ded0b02718a0f40d594"}]}