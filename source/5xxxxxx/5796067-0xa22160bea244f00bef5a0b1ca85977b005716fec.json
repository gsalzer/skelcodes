{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// File: deploy/contracts/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error.\r\n * Note, the div and mul methods were removed as they are not currently needed\r\n */\r\nlibrary SafeMath {\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: deploy/contracts/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    uint256 public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: deploy/contracts/Stampable.sol\r\n\r\ncontract Stampable is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    // A struct that represents a particular token balance\r\n    struct TokenBalance {\r\n        uint256 amount;\r\n        uint index;\r\n    }\r\n\r\n    // A struct that represents a particular address balance\r\n    struct AddressBalance {\r\n        mapping (uint256 => TokenBalance) tokens;\r\n        uint256[] tokenIndex;\r\n    }\r\n\r\n    // A mapping of address to balances\r\n    mapping (address => AddressBalance) balances;\r\n\r\n    // The total number of tokens owned per address\r\n    mapping (address => uint256) ownershipCount;\r\n\r\n    // Whitelist for addresses allowed to stamp tokens\r\n    mapping (address => bool) public stampingWhitelist;\r\n\r\n    /**\r\n    * Modifier for only whitelisted addresses\r\n    */\r\n    modifier onlyStampingWhitelisted() {\r\n        require(stampingWhitelist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    // Event for token stamping\r\n    event TokenStamp (address indexed from, uint256 tokenStamped, uint256 stamp, uint256 amt);\r\n\r\n    /**\r\n    * @dev Function to stamp a token in the msg.sender's wallet\r\n    * @param _tokenToStamp uint256 The tokenId of theirs to stamp (0 for unstamped tokens)\r\n    * @param _stamp uint256 The new stamp to apply\r\n    * @param _amt uint256 The quantity of tokens to stamp\r\n    */\r\n    function stampToken (uint256 _tokenToStamp, uint256 _stamp, uint256 _amt)\r\n        onlyStampingWhitelisted\r\n        public returns (bool) {\r\n        require(_amt <= balances[msg.sender].tokens[_tokenToStamp].amount);\r\n\r\n        // Subtract balance of 0th token ID _amt value.\r\n        removeToken(msg.sender, _tokenToStamp, _amt);\r\n\r\n        // \"Stamp\" the token\r\n        addToken(msg.sender, _stamp, _amt);\r\n\r\n        // Emit the stamping event\r\n        emit TokenStamp(msg.sender, _tokenToStamp, _stamp, _amt);\r\n\r\n        return true;\r\n    }\r\n\r\n    function addToken(address _owner, uint256 _token, uint256 _amount) internal {\r\n        // If they don't yet have any, assign this token an index\r\n        if (balances[_owner].tokens[_token].amount == 0) {\r\n            balances[_owner].tokens[_token].index = balances[_owner].tokenIndex.push(_token) - 1;\r\n        }\r\n\r\n        // Increase their balance of said token\r\n        balances[_owner].tokens[_token].amount = balances[_owner].tokens[_token].amount.add(_amount);\r\n\r\n        // Increase their ownership count\r\n        ownershipCount[_owner] = ownershipCount[_owner].add(_amount);\r\n    }\r\n\r\n    function removeToken(address _owner, uint256 _token, uint256 _amount) internal {\r\n        // Decrease their ownership count\r\n        ownershipCount[_owner] = ownershipCount[_owner].sub(_amount);\r\n\r\n        // Decrease their balance of the token\r\n        balances[_owner].tokens[_token].amount = balances[_owner].tokens[_token].amount.sub(_amount);\r\n\r\n        // If they don't have any left, remove it\r\n        if (balances[_owner].tokens[_token].amount == 0) {\r\n            uint index = balances[_owner].tokens[_token].index;\r\n            uint256 lastCoin = balances[_owner].tokenIndex[balances[_owner].tokenIndex.length - 1];\r\n            balances[_owner].tokenIndex[index] = lastCoin;\r\n            balances[_owner].tokens[lastCoin].index = index;\r\n            balances[_owner].tokenIndex.length--;\r\n            // Make sure the user's token is removed\r\n            delete balances[_owner].tokens[_token];\r\n        }\r\n    }\r\n}\r\n\r\n// File: deploy/contracts/FanCoin.sol\r\n\r\ncontract FanCoin is Stampable {\r\n    using SafeMath for uint256;\r\n\r\n    // The owner of this token\r\n    address public owner;\r\n\r\n    // Keeps track of allowances for particular address. - ERC20 Method\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    event TokenTransfer (address indexed from, address indexed to, uint256 tokenId, uint256 value);\r\n    event MintTransfer  (address indexed from, address indexed to, uint256 originalTokenId, uint256 tokenId, uint256 value);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * The constructor for the FanCoin token\r\n    */\r\n    function FanCoin() public {\r\n        owner = 0x7DDf115B8eEf3058944A3373025FB507efFAD012;\r\n        name = \"FanChain\";\r\n        symbol = \"FANZ\";\r\n        decimals = 4;\r\n\r\n        // Total supply is one billion tokens\r\n        totalSupply = 6e8 * uint256(10) ** decimals;\r\n\r\n        // Add the owner to the stamping whitelist\r\n        stampingWhitelist[owner] = true;\r\n\r\n        // Initially give all of the tokens to the owner\r\n        addToken(owner, 0, totalSupply);\r\n    }\r\n\r\n    /** ERC 20\r\n    * @dev Retrieves the balance of a specified address\r\n    * @param _owner address The address to query the balance of.\r\n    * @return A uint256 representing the amount owned by the _owner\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return ownershipCount[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the balance of a specified address for a specific token\r\n    * @param _owner address The address to query the balance of\r\n    * @param _tokenId uint256 The token being queried\r\n    * @return A uint256 representing the amount owned by the _owner\r\n    */\r\n    function balanceOfToken(address _owner, uint256 _tokenId) public view returns (uint256 balance) {\r\n        return balances[_owner].tokens[_tokenId].amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns all of the tokens owned by a particular address\r\n    * @param _owner address The address to query\r\n    * @return A uint256 array representing the tokens owned\r\n    */\r\n    function tokensOwned(address _owner) public view returns (uint256[] tokens) {\r\n        return balances[_owner].tokenIndex;\r\n    }\r\n\r\n    /** ERC 20\r\n    * @dev Transfers tokens to a specific address\r\n    * @param _to address The address to transfer tokens to\r\n    * @param _value unit256 The amount to be transferred\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= totalSupply);\r\n        require(_value <= ownershipCount[msg.sender]);\r\n\r\n        // Cast the value as the ERC20 standard uses uint256\r\n        uint256 _tokensToTransfer = uint256(_value);\r\n\r\n        // Do the transfer\r\n        require(transferAny(msg.sender, _to, _tokensToTransfer));\r\n\r\n        // Notify that a transfer has occurred\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer a specific kind of token to another address\r\n    * @param _to address The address to transfer to\r\n    * @param _tokenId address The type of token to transfer\r\n    * @param _value uint256 The number of tokens to transfer\r\n    */\r\n    function transferToken(address _to, uint256 _tokenId, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender].tokens[_tokenId].amount);\r\n\r\n        // Do the transfer\r\n        internalTransfer(msg.sender, _to, _tokenId, _value);\r\n\r\n        // Notify that a transfer happened\r\n        emit TokenTransfer(msg.sender, _to, _tokenId, _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer a list of token kinds and values to another address\r\n    * @param _to address The address to transfer to\r\n    * @param _tokenIds uint256[] The list of tokens to transfer\r\n    * @param _values uint256[] The list of amounts to transfer\r\n    */\r\n    function transferTokens(address _to, uint256[] _tokenIds, uint256[] _values) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_tokenIds.length == _values.length);\r\n        require(_tokenIds.length < 100); // Arbitrary limit\r\n\r\n        // Do verification first\r\n        for (uint i = 0; i < _tokenIds.length; i++) {\r\n            require(_values[i] > 0);\r\n            require(_values[i] <= balances[msg.sender].tokens[_tokenIds[i]].amount);\r\n        }\r\n\r\n        // Transfer every type of token specified\r\n        for (i = 0; i < _tokenIds.length; i++) {\r\n            require(internalTransfer(msg.sender, _to, _tokenIds[i], _values[i]));\r\n            emit TokenTransfer(msg.sender, _to, _tokenIds[i], _values[i]);\r\n            emit Transfer(msg.sender, _to, _values[i]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the given number of tokens regardless of how they are stamped\r\n    * @param _from address The address to transfer from\r\n    * @param _to address The address to transfer to\r\n    * @param _value uint256 The number of tokens to send\r\n    */\r\n    function transferAny(address _from, address _to, uint256 _value) private returns (bool) {\r\n        // Iterate through all of the tokens owned, and transfer either the\r\n        // current balance of that token, or the remaining total amount to be\r\n        // transferred (`_value`), whichever is smaller. Because tokens are completely removed\r\n        // as their balances reach 0, we just run the loop until we have transferred all\r\n        // of the tokens we need to\r\n        uint256 _tokensToTransfer = _value;\r\n        while (_tokensToTransfer > 0) {\r\n            uint256 tokenId = balances[_from].tokenIndex[0];\r\n            uint256 tokenBalance = balances[_from].tokens[tokenId].amount;\r\n\r\n            if (tokenBalance >= _tokensToTransfer) {\r\n                require(internalTransfer(_from, _to, tokenId, _tokensToTransfer));\r\n                _tokensToTransfer = 0;\r\n            } else {\r\n                _tokensToTransfer = _tokensToTransfer - tokenBalance;\r\n                require(internalTransfer(_from, _to, tokenId, tokenBalance));\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Internal function for transferring a specific type of token\r\n    */\r\n    function internalTransfer(address _from, address _to, uint256 _tokenId, uint256 _value) private returns (bool) {\r\n        // Decrease the amount being sent first\r\n        removeToken(_from, _tokenId, _value);\r\n\r\n        // Increase receivers token balances\r\n        addToken(_to, _tokenId, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** ERC 20\r\n    * @dev Transfer on behalf of another address\r\n    * @param _from address The address to send tokens from\r\n    * @param _to address The address to send tokens to\r\n    * @param _value uint256 The amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= ownershipCount[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        // Get the uint256 version of value\r\n        uint256 _castValue = uint256(_value);\r\n\r\n        // Decrease the spending limit\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        // Actually perform the transfer\r\n        require(transferAny(_from, _to, _castValue));\r\n\r\n        // Notify that a transfer has occurred\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer and stamp tokens from a mint in one step\r\n    * @param _to address To send the tokens to\r\n    * @param _tokenToStamp uint256 The token to stamp (0 is unstamped tokens)\r\n    * @param _stamp uint256 The new stamp to apply\r\n    * @param _amount uint256 The number of tokens to stamp and transfer\r\n    */\r\n    function mintTransfer(address _to, uint256 _tokenToStamp, uint256 _stamp, uint256 _amount) public\r\n        onlyStampingWhitelisted returns (bool) {\r\n        require(_to != address(0));\r\n        require(_amount <= balances[msg.sender].tokens[_tokenToStamp].amount);\r\n\r\n        // Decrease the amount being sent first\r\n        removeToken(msg.sender, _tokenToStamp, _amount);\r\n\r\n        // Increase receivers token balances\r\n        addToken(_to, _stamp, _amount);\r\n\r\n        emit MintTransfer(msg.sender, _to, _tokenToStamp, _stamp, _amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Add an address to the whitelist\r\n     * @param _addr address The address to add\r\n     */\r\n    function addToWhitelist(address _addr) public\r\n        onlyOwner {\r\n        stampingWhitelist[_addr] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an address from the whitelist\r\n     * @param _addr address The address to remove\r\n     */\r\n    function removeFromWhitelist(address _addr) public\r\n        onlyOwner {\r\n        stampingWhitelist[_addr] = false;\r\n    }\r\n\r\n    /** ERC 20\r\n    * @dev Approve sent address to spend the specified amount of tokens on\r\n    * behalf of msg.sender\r\n    *\r\n    * See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * for any potential security concerns\r\n    *\r\n    * @param _spender address The address that will spend funds\r\n    * @param _value uint256 The number of tokens they are allowed to spend\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(allowed[msg.sender][_spender] == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /** ERC 20\r\n    * @dev Returns the amount a spender is allowed to spend for a particular\r\n    * address\r\n    * @param _owner address The address which owns the funds\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return uint256 The number of tokens still available for the spender\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /** ERC 20\r\n    * @dev Increases the number of tokens a spender is allowed to spend for\r\n    * `msg.sender`\r\n    * @param _spender address The address of the spender\r\n    * @param _addedValue uint256 The amount to increase the spenders approval by\r\n    */\r\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /** ERC 20\r\n    * @dev Decreases the number of tokens a spender is allowed to spend for\r\n    * `msg.sender`\r\n    * @param _spender address The address of the spender\r\n    * @param _subtractedValue uint256 The amount to decrease the spenders approval by\r\n    */\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        uint _value = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > _value) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = _value.sub(_subtractedValue);\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenToStamp\",\"type\":\"uint256\"},{\"name\":\"_stamp\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stampingWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"transferTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOwned\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenToStamp\",\"type\":\"uint256\"},{\"name\":\"_stamp\",\"type\":\"uint256\"},{\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"stampToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"balanceOfToken\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"originalTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MintTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenStamped\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"TokenStamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FanCoin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e0a39e2a3ae84b03190a6e9bea47ad4f4139933274c98aee8d816033d4036531"}]}