{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string self) internal pure returns (slice) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-termintaed utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice self) internal pure returns (slice) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice self) internal pure returns (string) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice self, slice other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint256 mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                uint256 diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice self, slice other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice self, slice rune) internal pure returns (slice) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if(b < 0xE0) {\r\n            l = 2;\r\n        } else if(b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice self) internal pure returns (slice ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice self, slice needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice self, slice needle) internal pure returns (slice) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice self, slice needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice self, slice needle) internal pure returns (slice) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    event log_bytemask(bytes32 mask);\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end) \r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := sha3(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := sha3(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr) \r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := sha3(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := sha3(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice self, slice needle) internal pure returns (slice) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice self, slice needle) internal pure returns (slice) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice self, slice needle, slice token) internal pure returns (slice) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice self, slice needle) internal pure returns (slice token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice self, slice needle) internal pure returns (slice token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice self, slice needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice self, slice needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice self, slice other) internal pure returns (string) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice self, slice[] parts) internal pure returns (string) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n\r\ncontract CryptoMyWord {\r\n  using SafeMath for uint256;\r\n  using strings for *;\r\n\r\n  event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price);\r\n  event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event NewWord(uint wordId, string name, uint price);\r\n\r\n  address private owner;\r\n  uint256 nameTokenId;\r\n  uint256 tokenId;\r\n  mapping (address => bool) private admins;\r\n  //IItemRegistry private itemRegistry;\r\n  bool private erc721Enabled = false;\r\n\r\n  uint256 private increaseLimit1 = 0.8 ether;\r\n  uint256 private increaseLimit2 = 1.5 ether;\r\n  uint256 private increaseLimit3 = 2.0 ether;\r\n  uint256 private increaseLimit4 = 5.0 ether;\r\n\r\n  uint256[] private listedItems;\r\n  mapping (uint256 => address) public ownerOfItem;\r\n  mapping (address => string) public nameOfOwner;\r\n  mapping (address => string) public snsOfOwner;\r\n  mapping (uint256 => uint256) private startingPriceOfItem;\r\n  mapping (uint256 => uint256) private priceOfItem;\r\n  mapping (uint256 => string) private nameOfItem;\r\n  mapping (uint256 => string) private urlOfItem;\r\n  mapping (uint256 => address[]) private borrowerOfItem;\r\n  mapping (string => uint256[]) private nameToItems;\r\n  mapping (uint256 => address) private approvedOfItem;\r\n  mapping (string => uint256) private nameToParents;\r\n  mapping (string => uint256) private nameToNameToken;\r\n  mapping (string => string) private firstIdOfName;\r\n  mapping (string => string) private secondIdOfName;\r\n\r\n  function CryptoMyWord () public {\r\n    owner = msg.sender;\r\n    admins[owner] = true;\r\n  }\r\n\r\n  struct Token {\r\n    address firstMintedBy;\r\n    uint64 mintedAt;\r\n    uint256 startingPrice;\r\n    uint256 priceOfItem;\r\n    string name;\r\n    string url;\r\n    string firstIdOfName;\r\n    string secondIdOfName;\r\n    address owner;\r\n  }\r\n  Token[] public tokens;\r\n  struct Name {\r\n    string name;\r\n    uint256 parent;\r\n  }\r\n  Name[] public names;\r\n  /* Modifiers */\r\n  modifier onlyOwner() {\r\n    require(owner == msg.sender);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAdmins() {\r\n    require(admins[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  modifier onlyERC721() {\r\n    require(erc721Enabled);\r\n    _;\r\n  }\r\n\r\n  /* Owner */\r\n  function setOwner (address _owner) onlyOwner() public {\r\n    owner = _owner;\r\n  }\r\n\r\n  function getOwner () view public returns(address) {\r\n    return owner;\r\n  }\r\n\r\n  function addAdmin (address _admin) onlyOwner() public {\r\n    admins[_admin] = true;\r\n  }\r\n\r\n  function removeAdmin (address _admin) onlyOwner() public {\r\n    delete admins[_admin];\r\n  }\r\n\r\n  // Unlocks ERC721 behaviour, allowing for trading on third party platforms.\r\n  function enableERC721 () onlyOwner() public {\r\n    erc721Enabled = true;\r\n  }\r\n\r\n  // locks ERC721 behaviour, allowing for trading on third party platforms.\r\n  function disableERC721 () onlyOwner() public {\r\n    erc721Enabled = false;\r\n  }\r\n\r\n  /* Withdraw */\r\n  /*\r\n    NOTICE: These functions withdraw the developer's cut which is left\r\n    in the contract by `buy`. User funds are immediately sent to the old\r\n    owner in `buy`, no user funds are left in the contract.\r\n  */\r\n  function withdrawAll () onlyOwner() public {\r\n    owner.transfer(this.balance);\r\n  }\r\n\r\n  function withdrawAmount (uint256 _amount) onlyOwner() public {\r\n    owner.transfer(_amount);\r\n  }\r\n\r\n\r\n  function listItem (uint256 _price, address _owner, string _name) onlyAdmins() public {\r\n    require(nameToItems[_name].length == 0);\r\n    Token memory token = Token({\r\n      firstMintedBy: _owner,\r\n      mintedAt: uint64(now),\r\n      startingPrice: _price,\r\n      priceOfItem: _price,\r\n      name: _name,\r\n      url: \"\",\r\n      firstIdOfName: \"\",\r\n      secondIdOfName: \"\",\r\n      owner: _owner\r\n    });\r\n    tokenId = tokens.push(token) - 1;\r\n    Name memory namesval = Name({\r\n      name: _name,\r\n      parent: tokenId\r\n    });\r\n    ownerOfItem[tokenId] = _owner;\r\n    priceOfItem[tokenId] = _price;\r\n    startingPriceOfItem[tokenId] = _price;\r\n    nameOfItem[tokenId] = _name;\r\n    nameToItems[_name].push(tokenId);\r\n    listedItems.push(tokenId);\r\n    nameToParents[_name] = tokenId;\r\n    nameTokenId = names.push(namesval) - 1;\r\n    nameToNameToken[_name] = nameTokenId;\r\n  }\r\n\r\n  function _mint (uint256 _price, address _owner, string _name, string _url) internal {\r\n    address firstOwner = _owner;\r\n    if(nameToItems[_name].length != 0){\r\n      firstOwner = ownerOf(nameToParents[_name]);\r\n      if(admins[firstOwner]){\r\n        firstOwner = _owner;\r\n      }\r\n    }\r\n    Token memory token = Token({\r\n      firstMintedBy: firstOwner,\r\n      mintedAt: uint64(now),\r\n      startingPrice: _price,\r\n      priceOfItem: _price,\r\n      name: _name,\r\n      url: \"\",\r\n      firstIdOfName: \"\",\r\n      secondIdOfName: \"\",\r\n      owner: _owner\r\n    });\r\n    tokenId = tokens.push(token) - 1;\r\n    Name memory namesval = Name({\r\n      name: _name,\r\n      parent: tokenId\r\n    });\r\n    if(nameToItems[_name].length != 0){\r\n      names[nameToNameToken[_name]] = namesval;\r\n    }\r\n    ownerOfItem[tokenId] = _owner;\r\n    priceOfItem[tokenId] = _price;\r\n    startingPriceOfItem[tokenId] = _price;\r\n    nameOfItem[tokenId] = _name;\r\n    urlOfItem[tokenId] = _url;\r\n    nameToItems[_name].push(tokenId);\r\n    listedItems.push(tokenId);\r\n    nameToParents[_name] = tokenId;\r\n  }\r\n\r\n  function composite (uint256 _firstId, uint256 _secondId, uint8 _space) public {\r\n    int counter1 = 0;\r\n    for (uint i = 0; i < borrowerOfItem[_firstId].length; i++) {\r\n      if (borrowerOfItem[_firstId][i] == msg.sender) {\r\n        counter1++;\r\n      }\r\n    }\r\n    int counter2 = 0;\r\n    for (uint i2 = 0; i2 < borrowerOfItem[_secondId].length; i2++) {\r\n      if (borrowerOfItem[_secondId][i2] == msg.sender) {\r\n        counter2++;\r\n      }\r\n    }\r\n    require(ownerOfItem[_firstId] == msg.sender || counter1 > 0);\r\n    require(ownerOfItem[_secondId] == msg.sender || counter2 > 0);\r\n    string memory compositedName1 = nameOfItem[_firstId];\r\n    string memory space = \" \";\r\n    if(_space > 0){\r\n      compositedName1 = nameOfItem[_firstId].toSlice().concat(space.toSlice());\r\n    }\r\n    string memory compositedName = compositedName1.toSlice().concat(nameOfItem[_secondId].toSlice());\r\n    require(nameToItems[compositedName].length == 0);\r\n    firstIdOfName[compositedName] = nameOfItem[_firstId];\r\n    secondIdOfName[compositedName] = nameOfItem[_secondId];\r\n    _mint(0.01 ether, msg.sender, compositedName, \"\");\r\n  }\r\n\r\n  function setUrl (uint256 _tokenId, string _url) public {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    tokens[_tokenId].url = _url;\r\n  }\r\n\r\n  /* Buying */\r\n  function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\r\n    if (_price < increaseLimit1) {\r\n      return _price.mul(200).div(95); // 1.95\r\n    } else if (_price < increaseLimit2) {\r\n      return _price.mul(135).div(95); //1.3\r\n    } else if (_price < increaseLimit3) {\r\n      return _price.mul(125).div(95); //1.2\r\n    } else if (_price < increaseLimit4) {\r\n      return _price.mul(120).div(95); //1.12\r\n    } else {\r\n      return _price.mul(115).div(95); //1.1\r\n    }\r\n  }\r\n\r\n  function calculateDevCut (uint256 _price) public pure returns (uint256 _devCut) {\r\n    return _price.mul(4).div(100);\r\n  }\r\n  function calculateFirstCut (uint256 _price) public pure returns (uint256 _firstCut) {\r\n    return _price.mul(1).div(100);\r\n  }\r\n  function ceil(uint a) public pure returns (uint ) {\r\n    return uint(int(a * 100) / 100);\r\n  }\r\n  /*\r\n     Buy a country directly from the contract for the calculated price\r\n     which ensures that the owner gets a profit.  All countries that\r\n     have been listed can be bought by this method. User funds are sent\r\n     directly to the previous owner and are never stored in the contract.\r\n  */\r\n  function buy (uint256 _itemId) payable public {\r\n    require(priceOf(_itemId) > 0);\r\n    require(ownerOf(_itemId) != address(0));\r\n    require(msg.value >= priceOf(_itemId));\r\n    require(ownerOf(_itemId) != msg.sender);\r\n    require(!isContract(msg.sender));\r\n    require(msg.sender != address(0));\r\n    address firstOwner = tokens[_itemId].firstMintedBy;\r\n    address oldOwner = ownerOf(_itemId);\r\n    address newOwner = msg.sender;\r\n    uint256 price = ceil(priceOf(_itemId));\r\n    uint256 excess = msg.value.sub(price);\r\n    string memory name = nameOf(_itemId);\r\n    uint256 nextPrice = ceil(nextPriceOf(_itemId));\r\n    //_transfer(oldOwner, newOwner, _itemId);\r\n    _mint(nextPrice, newOwner, name, \"\");\r\n    priceOfItem[_itemId] = nextPrice;\r\n\r\n    Bought(_itemId, newOwner, price);\r\n    Sold(_itemId, oldOwner, price);\r\n\r\n    // Devevloper's cut which is left in contract and accesed by\r\n    // `withdrawAll` and `withdrawAmountTo` methods.\r\n    uint256 devCut = ceil(calculateDevCut(price));\r\n    uint256 firstCut = ceil(calculateFirstCut(price));\r\n    // Transfer payment to old owner minus the developer's cut.\r\n    oldOwner.transfer(price.sub(devCut));\r\n    firstOwner.transfer(price.sub(firstCut));\r\n    if (excess > 0) {\r\n      newOwner.transfer(excess);\r\n    }\r\n  }\r\n\r\n  /* ERC721 */\r\n  function implementsERC721() public view returns (bool _implements) {\r\n    return erc721Enabled;\r\n  }\r\n\r\n  function name() public pure returns (string _name) {\r\n    return \"CryptoMyWord\";\r\n  }\r\n\r\n  function symbol() public pure returns (string _symbol) {\r\n    return \"CMW\";\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256 _totalSupply) {\r\n    return listedItems.length;\r\n  }\r\n\r\n  function balanceOf (address _owner) public view returns (uint256 _balance) {\r\n    uint256 counter = 0;\r\n\r\n    for (uint256 i = 0; i < listedItems.length; i++) {\r\n      if (ownerOf(listedItems[i]) == _owner) {\r\n        counter++;\r\n      }\r\n    }\r\n\r\n    return counter;\r\n  }\r\n\r\n  function ownerOf (uint256 _itemId) public view returns (address _owner) {\r\n    return ownerOfItem[_itemId];\r\n  }\r\n\r\n  function tokensOf (address _owner) external view returns (uint256[] _tokenIds) {\r\n    uint256[] memory result = new uint256[](balanceOf(_owner));\r\n\r\n    uint256 itemCounter = 0;\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      if (ownerOfItem[i] == _owner) {\r\n        result[itemCounter] = i;\r\n        itemCounter++;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function getNames () external view returns (uint256[] _tokenIds){\r\n    uint256[] memory result = new uint256[](names.length);\r\n    uint256 itemCounter = 0;\r\n    for (uint i = 0; i < names.length; i++) {\r\n      result[itemCounter] = nameToNameToken[names[itemCounter].name];\r\n      itemCounter++;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function tokenExists (uint256 _itemId) public view returns (bool _exists) {\r\n    return priceOf(_itemId) > 0;\r\n  }\r\n\r\n  function approvedFor(uint256 _itemId) public view returns (address _approved) {\r\n    return approvedOfItem[_itemId];\r\n  }\r\n\r\n  function approve(address _to, uint256 _itemId) onlyERC721() public {\r\n    require(msg.sender != _to);\r\n    require(tokenExists(_itemId));\r\n    require(ownerOf(_itemId) == msg.sender);\r\n\r\n    if (_to == 0) {\r\n      if (approvedOfItem[_itemId] != 0) {\r\n        delete approvedOfItem[_itemId];\r\n        Approval(msg.sender, 0, _itemId);\r\n      }\r\n    } else {\r\n      approvedOfItem[_itemId] = _to;\r\n      Approval(msg.sender, _to, _itemId);\r\n    }\r\n  }\r\n\r\n  /* Transferring a country to another owner will entitle the new owner the profits from `buy` */\r\n  function transfer(address _to, uint256 _itemId) onlyERC721() public {\r\n    require(msg.sender == ownerOf(_itemId));\r\n    _transfer(msg.sender, _to, _itemId);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _itemId) onlyERC721() public {\r\n    require(approvedFor(_itemId) == msg.sender);\r\n    _transfer(_from, _to, _itemId);\r\n  }\r\n\r\n  function _transfer(address _from, address _to, uint256 _itemId) internal {\r\n    require(tokenExists(_itemId));\r\n    require(ownerOf(_itemId) == _from);\r\n    require(_to != address(0));\r\n    require(_to != address(this));\r\n\r\n    ownerOfItem[_itemId] = _to;\r\n    approvedOfItem[_itemId] = 0;\r\n\r\n    Transfer(_from, _to, _itemId);\r\n  }\r\n\r\n  /* Read */\r\n  function isAdmin (address _admin) public view returns (bool _isAdmin) {\r\n    return admins[_admin];\r\n  }\r\n\r\n  function startingPriceOf (uint256 _itemId) public view returns (uint256 _startingPrice) {\r\n    return startingPriceOfItem[_itemId];\r\n  }\r\n\r\n  function priceOf (uint256 _itemId) public view returns (uint256 _price) {\r\n    return priceOfItem[_itemId];\r\n  }\r\n\r\n  function nextPriceOf (uint256 _itemId) public view returns (uint256 _nextPrice) {\r\n    return calculateNextPrice(priceOf(_itemId));\r\n  }\r\n\r\n  function nameOf (uint256 _itemId) public view returns (string _name) {\r\n    return nameOfItem[_itemId];\r\n  }\r\n\r\n  function itemsByName (string _name) public view returns (uint256[] _items){\r\n    return nameToItems[_name];\r\n  }\r\n\r\n  function allOf (uint256 _itemId) external view returns (address _owner, uint256 _startingPrice, uint256 _price, uint256 _nextPrice) {\r\n    return (ownerOf(_itemId), startingPriceOf(_itemId), priceOf(_itemId), nextPriceOf(_itemId));\r\n  }\r\n\r\n  function allForPopulate (uint256 _itemId) onlyOwner() external view returns (address _owner, uint256 _startingPrice, uint256 _price, uint256 _nextPrice) {\r\n    return (ownerOf(_itemId), startingPriceOf(_itemId), priceOf(_itemId), nextPriceOf(_itemId));\r\n  }\r\n\r\n  function selfDestruct () onlyOwner() public{\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function itemsForSaleLimit (uint256 _from, uint256 _take) public view returns (uint256[] _items) {\r\n    uint256[] memory items = new uint256[](_take);\r\n\r\n    for (uint256 i = 0; i < _take; i++) {\r\n      items[i] = listedItems[_from + i];\r\n    }\r\n\r\n    return items;\r\n  }\r\n\r\n  /* Util */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) } // solium-disable-line\r\n    return size > 0;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"tokenExists\",\"outputs\":[{\"name\":\"_exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOfItem\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"calculateFirstCut\",\"outputs\":[{\"name\":\"_firstCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"nameOf\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"_implements\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableERC721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"_isAdmin\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"approvedFor\",\"outputs\":[{\"name\":\"_approved\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"allOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"ceil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"listItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"names\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"parent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"firstMintedBy\",\"type\":\"address\"},{\"name\":\"mintedAt\",\"type\":\"uint64\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"priceOfItem\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"firstIdOfName\",\"type\":\"string\"},{\"name\":\"secondIdOfName\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"snsOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_take\",\"type\":\"uint256\"}],\"name\":\"itemsForSaleLimit\",\"outputs\":[{\"name\":\"_items\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"nextPriceOf\",\"outputs\":[{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"calculateDevCut\",\"outputs\":[{\"name\":\"_devCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"allForPopulate\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableERC721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nameOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"setUrl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"startingPriceOf\",\"outputs\":[{\"name\":\"_startingPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNames\",\"outputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_firstId\",\"type\":\"uint256\"},{\"name\":\"_secondId\",\"type\":\"uint256\"},{\"name\":\"_space\",\"type\":\"uint8\"}],\"name\":\"composite\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"calculateNextPrice\",\"outputs\":[{\"name\":\"_nextPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"itemsByName\",\"outputs\":[{\"name\":\"_items\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_itemId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_itemId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wordId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewWord\",\"type\":\"event\"}]","ContractName":"CryptoMyWord","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1b3e1ef5cfee32b4064672b7dda68c94e68f53f09736367cba3361baa6b37100"}]}