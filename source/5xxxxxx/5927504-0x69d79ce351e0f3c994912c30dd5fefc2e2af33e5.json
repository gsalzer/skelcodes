{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary Utils {\r\n\r\n    uint  constant PRECISION = (10**18);\r\n    uint  constant MAX_DECIMALS = 18;\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        if( dstDecimals >= srcDecimals ) {\r\n            require((dstDecimals-srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals-srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals-dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals-dstDecimals)));\r\n        }\r\n    }\r\n\r\n    // function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n    //     if( srcDecimals >= dstDecimals ) {\r\n    //         require((srcDecimals-dstDecimals) <= MAX_DECIMALS);\r\n    //         return (PRECISION * dstQty * (10**(srcDecimals - dstDecimals))) / rate;\r\n    //     } else {\r\n    //         require((dstDecimals-srcDecimals) <= MAX_DECIMALS);\r\n    //         return (PRECISION * dstQty) / (rate * (10**(dstDecimals - srcDecimals)));\r\n    //     }\r\n    // }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract ERC20Extended is ERC20 {\r\n    uint256 public decimals;\r\n    string public name;\r\n    string public symbol;\r\n\r\n}\r\n\r\ncontract ComponentInterface {\r\n    string public name;\r\n    string public description;\r\n    string public category;\r\n    string public version;\r\n}\r\n\r\ncontract ExchangeInterface is ComponentInterface {\r\n    /*\r\n     * @dev Checks if a trading pair is available\r\n     * For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\r\n     * @param address _sourceAddress The token to sell for the destAddress.\r\n     * @param address _destAddress The token to buy with the source token.\r\n     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\r\n     * @return boolean whether or not the trading pair is supported by this exchange provider\r\n     */\r\n    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId)\r\n        external view returns(bool supported);\r\n\r\n    /*\r\n     * @dev Buy a single token with ETH.\r\n     * @param ERC20Extended _token The token to buy, should be an ERC20Extended address.\r\n     * @param uint _amount Amount of ETH used to buy this token. Make sure the value sent to this function is the same as the _amount.\r\n     * @param uint _minimumRate The minimum amount of tokens to receive for 1 ETH.\r\n     * @param address _depositAddress The address to send the bought tokens to.\r\n     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\r\n     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here.\r\n     * @return boolean whether or not the trade succeeded.\r\n     */\r\n    function buyToken\r\n        (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress, bytes32 _exchangeId, address _partnerId\r\n        ) external payable returns(bool success);\r\n\r\n    /*\r\n     * @dev Sell a single token for ETH. Make sure the token is approved beforehand.\r\n     * @param ERC20Extended _token The token to sell, should be an ERC20Extended address.\r\n     * @param uint _amount Amount of tokens to sell.\r\n     * @param uint _minimumRate The minimum amount of ETH to receive for 1 ERC20Extended token.\r\n     * @param address _depositAddress The address to send the bought tokens to.\r\n     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\r\n     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\r\n     * @return boolean boolean whether or not the trade succeeded.\r\n     */\r\n    function sellToken\r\n        (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress, bytes32 _exchangeId, address _partnerId\r\n        ) external returns(bool success);\r\n}\r\n\r\ncontract KyberNetworkInterface {\r\n\r\n    function getExpectedRate(ERC20Extended src, ERC20Extended dest, uint srcQty)\r\n        external view returns (uint expectedRate, uint slippageRate);\r\n\r\n    function trade(\r\n        ERC20Extended source,\r\n        uint srcAmount,\r\n        ERC20Extended dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId)\r\n        external payable returns(uint);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract OlympusExchangeAdapterInterface is Ownable {\r\n\r\n    function supportsTradingPair(address _srcAddress, address _destAddress)\r\n        external view returns(bool supported);\r\n\r\n    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount)\r\n        external view returns(uint expectedRate, uint slippageRate);\r\n\r\n    function sellToken\r\n        (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress\r\n        ) external returns(bool success);\r\n\r\n    function buyToken\r\n        (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress\r\n        ) external payable returns(bool success);\r\n\r\n    function enable() external returns(bool);\r\n    function disable() external returns(bool);\r\n    function isEnabled() external view returns (bool success);\r\n\r\n    function setExchangeDetails(bytes32 _id, bytes32 _name) external returns(bool success);\r\n    function getExchangeDetails() external view returns(bytes32 _name, bool _enabled);\r\n\r\n}\r\n\r\ncontract BancorConverterInterface {\r\n    string public converterType;\r\n    ERC20Extended[] public quickBuyPath;\r\n    /**\r\n        @dev returns the length of the quick buy path array\r\n        @return quick buy path length\r\n    */\r\n    function getQuickBuyPathLength() public view returns (uint256);\r\n    /**\r\n        @dev returns the expected return for converting a specific amount of _fromToken to _toToken\r\n\r\n        @param _fromToken  ERC20 token to convert from\r\n        @param _toToken    ERC20 token to convert to\r\n        @param _amount     amount to convert, in fromToken\r\n\r\n        @return expected conversion return amount\r\n    */\r\n    function getReturn(ERC20Extended _fromToken, ERC20Extended _toToken, uint256 _amount) public view returns (uint256);\r\n    /**\r\n        @dev converts the token to any other token in the bancor network by following a predefined conversion path\r\n        note that when converting from an ERC20 token (as opposed to a smart token), allowance must be set beforehand\r\n\r\n        @param _path        conversion path, see conversion path format in the BancorNetwork contract\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function quickConvert(ERC20Extended[] _path, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        payable\r\n        returns (uint256);\r\n\r\n}\r\n\r\ncontract ERC20NoReturn {\r\n    uint256 public decimals;\r\n    string public name;\r\n    string public symbol;\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public;\r\n    function approve(address spender, uint tokens) public;\r\n    function transferFrom(address from, address to, uint tokens) public;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract BancorNetworkAdapter is OlympusExchangeAdapterInterface {\r\n    using SafeMath for uint256;\r\n\r\n    address public exchangeAdapterManager;\r\n    bytes32 public exchangeId;\r\n    bytes32 public name;\r\n    ERC20Extended public constant ETH_TOKEN_ADDRESS = ERC20Extended(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n    ERC20Extended public constant bancorToken = ERC20Extended(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C);\r\n    ERC20Extended public constant bancorETHToken = ERC20Extended(0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315);\r\n    mapping(address => BancorConverterInterface) public tokenToConverter;\r\n    mapping(address => address) public tokenToRelay;\r\n\r\n    bool public adapterEnabled;\r\n\r\n    modifier checkArrayLengths(address[] tokenAddresses, BancorConverterInterface[] converterAddresses, address[] relayAddresses) {\r\n        require(tokenAddresses.length == converterAddresses.length && relayAddresses.length == converterAddresses.length);\r\n        _;\r\n    }\r\n\r\n    modifier checkTokenSupported(address _token) {\r\n        BancorConverterInterface bancorConverter = tokenToConverter[_token];\r\n        require(address(bancorConverter) != 0x0, \"Token not supported\");\r\n        _;\r\n    }\r\n\r\n    constructor (address _exchangeAdapterManager, address[] _tokenAddresses,\r\n    BancorConverterInterface[] _converterAddresses, address[] _relayAddresses)\r\n    checkArrayLengths(_tokenAddresses, _converterAddresses, _relayAddresses) public {\r\n        updateSupportedTokenList(_tokenAddresses, _converterAddresses, _relayAddresses);\r\n        exchangeAdapterManager = _exchangeAdapterManager;\r\n        adapterEnabled = true;\r\n    }\r\n\r\n    modifier onlyExchangeAdapterManager() {\r\n        require(msg.sender == address(exchangeAdapterManager));\r\n        _;\r\n    }\r\n\r\n    function updateSupportedTokenList(address[] _tokenAddresses, BancorConverterInterface[] _converterAddresses, address[] _relayAddresses)\r\n    checkArrayLengths(_tokenAddresses, _converterAddresses, _relayAddresses)\r\n    public onlyOwner returns (bool success) {\r\n        for(uint i = 0; i < _tokenAddresses.length; i++){\r\n            tokenToConverter[_tokenAddresses[i]] = _converterAddresses[i];\r\n            tokenToRelay[_tokenAddresses[i]] = _relayAddresses[i];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function supportsTradingPair(address _srcAddress, address _destAddress) external view returns(bool supported){\r\n        address _tokenAddress = ETH_TOKEN_ADDRESS == _srcAddress ? _destAddress : _srcAddress;\r\n        BancorConverterInterface bancorConverter = tokenToConverter[_tokenAddress];\r\n        return address(bancorConverter) != 0x0;\r\n    }\r\n\r\n    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount)\r\n    external view returns(uint expectedRate, uint slippageRate) {\r\n        require(_amount > 0);\r\n        bool isBuying = _sourceAddress == ETH_TOKEN_ADDRESS;\r\n        ERC20Extended targetToken = isBuying ? _destAddress : _sourceAddress;\r\n        BancorConverterInterface BNTConverter = tokenToConverter[address(bancorToken)];\r\n\r\n        uint rate;\r\n        BancorConverterInterface targetTokenConverter = tokenToConverter[address(targetToken)];\r\n\r\n        uint ETHToBNTRate = BNTConverter.getReturn(bancorETHToken, bancorToken, _amount);\r\n\r\n\r\n        // Bancor is a special case, it's their token\r\n        if (targetToken == bancorToken){\r\n            if(isBuying) {\r\n                rate = ((ETHToBNTRate * 10**18) / _amount);\r\n            } else {\r\n                rate = BNTConverter.getReturn(bancorToken, bancorETHToken, _amount);\r\n                rate = ((rate * 10**_sourceAddress.decimals()) / _amount);\r\n            }\r\n        } else {\r\n            if(isBuying){\r\n                // Get amount of tokens for the amount of BNT for amount ETH\r\n                rate = targetTokenConverter.getReturn(bancorToken, targetToken, ETHToBNTRate);\r\n                // Convert rate to 1ETH to token or token to 1 ETH\r\n                rate = ((rate * 10**18) / _amount);\r\n            } else {\r\n                uint targetTokenToBNTRate = targetTokenConverter.getReturn(targetToken, bancorToken, 10**targetToken.decimals());\r\n                rate = BNTConverter.getReturn(bancorToken, bancorETHToken, targetTokenToBNTRate);\r\n                // Convert rate to 1ETH to token or token to 1 ETH\r\n                rate = ((rate * 10**_sourceAddress.decimals()) / _amount);\r\n            }\r\n        }\r\n\r\n        // TODO slippage?\r\n        return (rate,0);\r\n    }\r\n\r\n    // https://support.bancor.network/hc/en-us/articles/360000878832-How-to-use-the-quickConvert-function\r\n    function getPath(ERC20Extended _token, bool isBuying) public view returns(ERC20Extended[] tokenPath, uint resultPathLength) {\r\n        BancorConverterInterface bancorConverter = tokenToConverter[_token];\r\n        uint pathLength;\r\n        ERC20Extended[] memory path;\r\n\r\n        // When buying, we can get the path from Bancor easily, by getting the quickBuyPath from the converter address\r\n        if(isBuying){\r\n            pathLength = bancorConverter.getQuickBuyPathLength();\r\n            require(pathLength > 0, \"Error with pathLength\");\r\n            path = new ERC20Extended[](pathLength);\r\n\r\n            for (uint i = 0; i < pathLength; i++) {\r\n                path[i] = bancorConverter.quickBuyPath(i);\r\n            }\r\n            return (path, pathLength);\r\n        }\r\n\r\n        // When selling, we need to make the path ourselves\r\n\r\n        address relayAddress = tokenToRelay[_token];\r\n\r\n        if(relayAddress == 0x0){\r\n            // Bancor is a special case, it's their token\r\n            if(_token == bancorToken){\r\n                path = new ERC20Extended[](3);\r\n                path[0] = _token;\r\n                path[1] = _token;\r\n                path[2] = bancorETHToken;\r\n                return (path, 3);\r\n            }\r\n            // It's a Bancor smart token, handle it accordingly\r\n            path = new ERC20Extended[](5);\r\n            path[0] = _token;\r\n            path[1] = _token;\r\n            path[2] = bancorToken;\r\n            path[3] = bancorToken;\r\n            path[4] = bancorETHToken;\r\n            return (path, 5);\r\n        }\r\n\r\n        // It's a relay token, handle it accordingly\r\n        path = new ERC20Extended[](5);\r\n        path[0] = _token;                              // ERC20 Token to sell\r\n        path[1] = ERC20Extended(relayAddress);         // Relay address (automatically converted to converter address)\r\n        path[2] = bancorToken;                         // BNT Smart token address, as converter\r\n        path[3] = bancorToken;                         // BNT Smart token address, as \"to\" and \"from\" token\r\n        path[4] = bancorETHToken;                      // The Bancor ETH token, this will signal we want our return in ETH\r\n\r\n        return (path, 5);\r\n    }\r\n\r\n    // In contrast to Kyber, Bancor uses a minimum return for the complete trade, instead of a minimum rate for 1 ETH (for buying) or token (when selling)\r\n    function convertMinimumRateToMinimumReturn(ERC20Extended _token, uint _minimumRate, uint _amount, bool isBuying)\r\n    private view returns(uint minimumReturn) {\r\n        if(_minimumRate == 0){\r\n            return 1;\r\n        }\r\n\r\n        if(isBuying){\r\n            return (_amount * 10**18) / _minimumRate;\r\n        }\r\n\r\n        return (_amount * 10**_token.decimals()) / _minimumRate;\r\n    }\r\n\r\n    function sellToken\r\n    (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress\r\n    ) checkTokenSupported(_token) external returns(bool success) {\r\n        require(_token.balanceOf(address(this)) >= _amount, \"Balance of token is not sufficient in adapter\");\r\n        ERC20Extended[] memory internalPath;\r\n        ERC20Extended[] memory path;\r\n        uint pathLength;\r\n        (internalPath,pathLength) = getPath(_token, false);\r\n\r\n        path = new ERC20Extended[](pathLength);\r\n        for(uint i = 0; i < pathLength; i++) {\r\n            path[i] = internalPath[i];\r\n        }\r\n\r\n        BancorConverterInterface bancorConverter = tokenToConverter[_token];\r\n\r\n        ERC20NoReturn(_token).approve(address(bancorConverter), 0);\r\n        ERC20NoReturn(_token).approve(address(bancorConverter), _amount);\r\n        uint minimumReturn = convertMinimumRateToMinimumReturn(_token,_amount,_minimumRate, false);\r\n        uint returnedAmountOfETH = bancorConverter.quickConvert(path,_amount,minimumReturn);\r\n        require(returnedAmountOfETH > 0, \"BancorConverter did not return any ETH\");\r\n        _depositAddress.transfer(returnedAmountOfETH);\r\n        return true;\r\n    }\r\n\r\n    function buyToken (\r\n        ERC20Extended _token, uint _amount, uint _minimumRate,\r\n        address _depositAddress\r\n    ) checkTokenSupported(_token) external payable returns(bool success){\r\n        require(msg.value == _amount, \"Amount of Ether sent is not the same as the amount parameter\");\r\n        ERC20Extended[] memory internalPath;\r\n        ERC20Extended[] memory path;\r\n        uint pathLength;\r\n        (internalPath,pathLength) = getPath(_token, true);\r\n        path = new ERC20Extended[](pathLength);\r\n        for(uint i = 0; i < pathLength; i++) {\r\n            path[i] = internalPath[i];\r\n        }\r\n\r\n        uint minimumReturn = convertMinimumRateToMinimumReturn(_token,_amount,_minimumRate, true);\r\n        uint returnedAmountOfTokens = tokenToConverter[address(bancorToken)].quickConvert.value(_amount)(path,_amount,minimumReturn);\r\n        require(returnedAmountOfTokens > 0, \"BancorConverter did not return any tokens\");\r\n        ERC20NoReturn(_token).transfer(_depositAddress, returnedAmountOfTokens);\r\n        return true;\r\n    }\r\n\r\n    function enable() external onlyOwner returns(bool){\r\n        adapterEnabled = true;\r\n        return true;\r\n    }\r\n\r\n    function disable() external onlyOwner returns(bool){\r\n        adapterEnabled = false;\r\n        return true;\r\n    }\r\n\r\n    function isEnabled() external view returns (bool success) {\r\n        return adapterEnabled;\r\n    }\r\n\r\n    function setExchangeAdapterManager(address _exchangeAdapterManager) external onlyOwner {\r\n        exchangeAdapterManager = _exchangeAdapterManager;\r\n    }\r\n\r\n    function setExchangeDetails(bytes32 _id, bytes32 _name)\r\n    external onlyExchangeAdapterManager returns(bool)\r\n    {\r\n        exchangeId = _id;\r\n        name = _name;\r\n        return true;\r\n    }\r\n\r\n    function getExchangeDetails()\r\n    external view returns(bytes32 _name, bool _enabled)\r\n    {\r\n        return (name, adapterEnabled);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_TOKEN_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeAdapterManager\",\"type\":\"address\"}],\"name\":\"setExchangeAdapterManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adapterEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_srcAddress\",\"type\":\"address\"},{\"name\":\"_destAddress\",\"type\":\"address\"}],\"name\":\"supportsTradingPair\",\"outputs\":[{\"name\":\"supported\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeDetails\",\"outputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_enabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEnabled\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minimumRate\",\"type\":\"uint256\"},{\"name\":\"_depositAddress\",\"type\":\"address\"}],\"name\":\"buyToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sourceAddress\",\"type\":\"address\"},{\"name\":\"_destAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"expectedRate\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeAdapterManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minimumRate\",\"type\":\"uint256\"},{\"name\":\"_depositAddress\",\"type\":\"address\"}],\"name\":\"sellToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddresses\",\"type\":\"address[]\"},{\"name\":\"_converterAddresses\",\"type\":\"address[]\"},{\"name\":\"_relayAddresses\",\"type\":\"address[]\"}],\"name\":\"updateSupportedTokenList\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"isBuying\",\"type\":\"bool\"}],\"name\":\"getPath\",\"outputs\":[{\"name\":\"tokenPath\",\"type\":\"address[]\"},{\"name\":\"resultPathLength\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"bytes32\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"setExchangeDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bancorETHToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_exchangeAdapterManager\",\"type\":\"address\"},{\"name\":\"_tokenAddresses\",\"type\":\"address[]\"},{\"name\":\"_converterAddresses\",\"type\":\"address[]\"},{\"name\":\"_relayAddresses\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BancorNetworkAdapter","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005a54a48e453fcf0c6bdfecd992640e5c09ef1d39000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002c0000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000110000000000000000000000001f573d6fb3f13d689ff844b4ce37794d79a7ff1c000000000000000000000000d0a4b8946cb52f0661273bfbc6fd0e0c75fc64330000000000000000000000003d1ba9be9f66b8ee101911bc36d3fb562eac22440000000000000000000000009b68bfae21df5a510931a262cecf63f41338f2640000000000000000000000000e0989b1f9b8a38983c2ba8053269ca62ec9b195000000000000000000000000df6ef343350780bf8c3410bf062e0c015b1dd6710000000000000000000000006758b7d441a9739b98552b373703d8d3d14f9e62000000000000000000000000818fc6c2ec5986bc6e2cbf00939d90556ab12ce50000000000000000000000004162178b78d6985480a308b2190ee5517460406d0000000000000000000000009a0242b7a33dacbe40edb927834f96eb39f8fbcb000000000000000000000000aaaf91d9b90df800df4f55c205fd6989c977e73a0000000000000000000000000d8775f648430679a709e98d2b0cb6250d2887ef000000000000000000000000d26114cd6ee289accf82350c8d8487fedb8a0c07000000000000000000000000bf2179859fc6d5bee9bf9158632dc51678a4100e00000000000000000000000080bc5512561c7f85a3a9508c7df7901b370fa1df000000000000000000000000c5bbae50781be1669306b9e001eff57a2957b09d000000000000000000000000006bea43baa3f7a6f765f14f10a1a1b08334ef4500000000000000000000000000000000000000000000000000000000000000110000000000000000000000003839416bd0095d97be9b354cbfb0f6807d4d609e00000000000000000000000058b249b613ce917b6ccc2f66787856ef39f4f0b6000000000000000000000000635c9c9940d512bf5cb455706a28f9c7174d307f000000000000000000000000f4327c919854cb099ac574a22f5fba901e2025c40000000000000000000000008c2036ce61648fcddffb06d6d11fe0b479ed63fe00000000000000000000000094c654fef85b8b0a982909a6ca45b66bb23842360000000000000000000000006758b7d441a9739b98552b373703d8d3d14f9e62000000000000000000000000e9800c0b73a71be61d49a61fa3b2320ee524fb3d000000000000000000000000f346a9884bf8f858848268fb9d8ab31dae4b323f000000000000000000000000c02d4bd00f642d2821e4279c810dd7b6e49264f8000000000000000000000000c04b5a4556d00bca8eac5f5acca31981a659740900000000000000000000000046ffcdc6d8e6ed69f124d944bbfe0ac74f8fcf7f00000000000000000000000011614c5f1eb215ecffe657da56d3dd12df395dc8000000000000000000000000645a3f2fa86be27a4d9a3cc93a73f27b33df766f000000000000000000000000af6a5b0998ff41355f3b4fe1ab96d89bd2c487d3000000000000000000000000e88d6d63389d5c91e6348e379913f330739ad2c40000000000000000000000008606704880234178125b2d44cbbe190ccdbde01500000000000000000000000000000000000000000000000000000000000000110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000cad4da66e00fdecabec137a24e12af8edf303a1d0000000000000000000000005039f60594ffa3f1a5acbe85e1ebe12dc8da7c5c000000000000000000000000fe9e6111e45a6066374bf33e831e80b1949a9faa000000000000000000000000a5f2a49aafa052e28a50a575cd9e7488fa598e780000000000000000000000001bce0e684a1607fd86407909073eea2336042bf7000000000000000000000000564c07255afe5050d82c8816f78da13f2b17ac6d00000000000000000000000026b5748f9253363f95e37767e9ed7986877a4b1b000000000000000000000000eb027349398de19d925defc15c4302fe92fc69f9000000000000000000000000a9de5935ae3eae8a7f943c9329940eda160267f4000000000000000000000000497ec0d6ba2080f0ed7ecf7a79a2a907401b3239000000000000000000000000131da075a2832549128e93acc2b54174045232cf00000000000000000000000099ebd396ce7aa095412a4cd1a0c959d6fd67b3400000000000000000000000000f2318565f1996cb1ed2f88e172135791bc1fcbf0000000000000000000000001b30042b537b30b1254ce84b27b332be523e974a000000000000000000000000c4938292ea2d3085fffc11c46b87ca068a83be010000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://5ae3119759005eca6ec1005e2750548fba1c4825953cac8096dc6ff1cca3547e"}]}