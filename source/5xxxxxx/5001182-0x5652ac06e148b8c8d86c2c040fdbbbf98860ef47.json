{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract DBC {\r\n\r\n    // MODIFIERS\r\n\r\n    modifier pre_cond(bool condition) {\r\n        require(condition);\r\n        _;\r\n    }\r\n\r\n    modifier post_cond(bool condition) {\r\n        _;\r\n        assert(condition);\r\n    }\r\n\r\n    modifier invariant(bool condition) {\r\n        require(condition);\r\n        _;\r\n        assert(condition);\r\n    }\r\n}\r\n\r\ncontract Competition is DBC {\r\n\r\n    // TYPES\r\n\r\n    struct Hopeful { // Someone who wants to succeed or who seems likely to win\r\n        address fund; // Address of the Melon fund\r\n        address manager; // Address of the fund manager, as used in the ipfs-frontend\r\n        address registrant; // Manager (== owner) of above Melon fund\r\n        bool hasSigned; // Whether initial requirements passed and Hopeful signed Terms and Conditions; Does not mean Hopeful is competing yet\r\n        address buyinAsset; // Asset (ERC20 Token) spent to take part in competition\r\n        address payoutAsset; // Asset (usually Melon Token) to be received as prize\r\n        uint buyinQuantity; // Quantity of buyinAsset spent\r\n        uint payoutQuantity; // Quantity of payoutAsset received as prize\r\n        address payoutAddress; // Address to payout in main chain\r\n        bool isCompeting; // Whether outside oracle verified remaining requirements; If yes Hopeful is taking part in a competition\r\n        bool isDisqualified; // Whether participant is disqualified\r\n        uint finalSharePrice; // Performance of Melon fund at competition endTime; Can be changed for any other comparison metric\r\n        uint finalCompetitionRank; // Rank of Hopeful at end of competition; Calculate by logic as set in terms and conditions\r\n    }\r\n\r\n    struct HopefulId {\r\n      uint id; // Actual Hopeful Id\r\n      bool exists; // Used to check if the mapping exists\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // Constant fields\r\n    // Competition terms and conditions as displayed on https://ipfs.io/ipfs/QmQ7DqjpxmTDbaxcH5qwv8QmGvJY7rhb8UV2QRfCEFBp8V\r\n    // IPFS hash encoded using http://lenschulwitz.com/base58\r\n    bytes32 public constant TERMS_AND_CONDITIONS = 0x1A46B45CC849E26BB3159298C3C218EF300D015ED3E23495E77F0E529CE9F69E;\r\n    uint public MELON_BASE_UNIT = 10 ** 18;\r\n    // Constructor fields\r\n    address public oracle; // Information e.g. from Kovan can be passed to contract from this address\r\n    uint public startTime; // Competition start time in seconds (Temporarily Set)\r\n    uint public endTime; // Competition end time in seconds\r\n    uint public maxbuyinQuantity; // Limit amount of deposit to participate in competition\r\n    uint public maxHopefulsNumber; // Limit number of participate in competition\r\n    uint public prizeMoneyAsset; // Equivalent to payoutAsset\r\n    uint public prizeMoneyQuantity; // Total prize money pool\r\n    address public MELON_ASSET; // Adresss of Melon asset contract\r\n    ERC20Interface public MELON_CONTRACT; // Melon as ERC20 contract\r\n    Certifier public CERTIFIER; // Parity KYC verification contract\r\n    // Methods fields\r\n    Hopeful[] public hopefuls; // List of all hopefuls, can be externally accessed\r\n    mapping (address => address) public registeredFundToRegistrants; // For fund address indexed accessing of registrant addresses\r\n    mapping(address => HopefulId) public registrantToHopefulIds; // For registrant address indexed accessing of hopeful ids\r\n\r\n    //EVENTS\r\n\r\n    event Register(uint withId, address fund, address manager);\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    /// @dev Proofs that terms and conditions have been read and understood\r\n    /// @param byManager Address of the fund manager, as used in the ipfs-frontend\r\n    /// @param v ellipitc curve parameter v\r\n    /// @param r ellipitc curve parameter r\r\n    /// @param s ellipitc curve parameter s\r\n    /// @return Whether or not terms and conditions have been read and understood\r\n    function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool) {\r\n        return ecrecover(\r\n            // Parity does prepend \\x19Ethereum Signed Message:\\n{len(message)} before signing.\r\n            //  Signature order has also been changed in 1.6.7 and upcoming 1.7.x,\r\n            //  it will return rsv (same as geth; where v is [27, 28]).\r\n            // Note that if you are using ecrecover, v will be either \"00\" or \"01\".\r\n            //  As a result, in order to use this value, you will have to parse it to an\r\n            //  integer and then add 27. This will result in either a 27 or a 28.\r\n            //  https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsign\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", TERMS_AND_CONDITIONS),\r\n            v,\r\n            r,\r\n            s\r\n        ) == byManager; // Has sender signed TERMS_AND_CONDITIONS\r\n    }\r\n\r\n    /// @return Whether message sender is oracle or not\r\n    function isOracle() view returns (bool) { return msg.sender == oracle; }\r\n\r\n    /// @dev Whether message sender is KYC verified through CERTIFIER\r\n    /// @param x Address to be checked for KYC verification\r\n    function isKYCVerified(address x) view returns (bool) { return CERTIFIER.certified(x); }\r\n\r\n    // CONSTANT METHODS\r\n\r\n    function getMelonAsset() view returns (address) { return MELON_ASSET; }\r\n\r\n    /// @return Get HopefulId from registrant address\r\n    function getHopefulId(address x) view returns (uint) { return registrantToHopefulIds[x].id; }\r\n\r\n    /**\r\n    @notice Returns an array of fund addresses and an associated array of whether competing and whether disqualified\r\n    @return {\r\n      \"fundAddrs\": \"Array of addresses of Melon Funds\",\r\n      \"fundManagers\": \"Array of addresses of Melon fund managers, as used in the ipfs-frontend\",\r\n      \"areCompeting\": \"Array of boolean of whether or not fund is competing\"\r\n      \"areDisqualified\": \"Array of boolean of whether or not fund is disqualified\"\r\n    }\r\n    */\r\n    function getCompetitionStatusOfHopefuls()\r\n        view\r\n        returns(\r\n            address[] fundAddrs,\r\n            address[] fundManagers,\r\n            bool[] areCompeting,\r\n            bool[] areDisqualified\r\n        )\r\n    {\r\n        for (uint i = 0; i <= hopefuls.length - 1; i++) {\r\n            fundAddrs[i] = hopefuls[i].fund;\r\n            fundManagers[i] = hopefuls[i].manager;\r\n            areCompeting[i] = hopefuls[i].isCompeting;\r\n            areDisqualified[i] = hopefuls[i].isDisqualified;\r\n        }\r\n        return (fundAddrs, fundManagers, areCompeting, areDisqualified);\r\n    }\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    function Competition(\r\n        address ofMelonAsset,\r\n        address ofOracle,\r\n        address ofCertifier,\r\n        uint ofStartTime,\r\n        uint ofMaxbuyinQuantity,\r\n        uint ofMaxHopefulsNumber\r\n    ) {\r\n        MELON_ASSET = ofMelonAsset;\r\n        MELON_CONTRACT = ERC20Interface(MELON_ASSET);\r\n        oracle = ofOracle;\r\n        CERTIFIER = Certifier(ofCertifier);\r\n        startTime = ofStartTime;\r\n        endTime = startTime + 2 weeks;\r\n        maxbuyinQuantity = ofMaxbuyinQuantity;\r\n        maxHopefulsNumber = ofMaxHopefulsNumber;\r\n    }\r\n\r\n    /// @notice Register to take part in the competition\r\n    /// @param fund Address of the Melon fund\r\n    /// @param buyinAsset Asset (ERC20 Token) spent to take part in competition\r\n    /// @param payoutAsset Asset (usually Melon Token) to be received as prize\r\n    /// @param buyinQuantity Quantity of buyinAsset spent\r\n    /// @param v ellipitc curve parameter v\r\n    /// @param r ellipitc curve parameter r\r\n    /// @param s ellipitc curve parameter s\r\n    function registerForCompetition(\r\n        address fund,\r\n        address manager,\r\n        address buyinAsset,\r\n        address payoutAsset,\r\n        address payoutAddress,\r\n        uint buyinQuantity,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        pre_cond(termsAndConditionsAreSigned(manager, v, r, s) && isKYCVerified(msg.sender))\r\n        pre_cond(registeredFundToRegistrants[fund] == address(0) && registrantToHopefulIds[msg.sender].exists == false)\r\n    {\r\n        require(buyinAsset == MELON_ASSET && payoutAsset == MELON_ASSET);\r\n        require(buyinQuantity <= maxbuyinQuantity && hopefuls.length <= maxHopefulsNumber);\r\n        registeredFundToRegistrants[fund] = msg.sender;\r\n        registrantToHopefulIds[msg.sender] = HopefulId({id: hopefuls.length, exists: true});\r\n        Register(hopefuls.length, fund, msg.sender);\r\n        hopefuls.push(Hopeful({\r\n          fund: fund,\r\n          manager: manager,\r\n          registrant: msg.sender,\r\n          hasSigned: true,\r\n          buyinAsset: buyinAsset,\r\n          payoutAsset: payoutAsset,\r\n          payoutAddress: payoutAddress,\r\n          buyinQuantity: buyinQuantity,\r\n          payoutQuantity: 0,\r\n          isCompeting: true,\r\n          isDisqualified: false,\r\n          finalSharePrice: 0,\r\n          finalCompetitionRank: 0\r\n        }));\r\n    }\r\n\r\n    /// @notice Disqualify and participant\r\n    /// @dev Only the oracle can call this function\r\n    /// @param withId Index of Hopeful to disqualify\r\n    function disqualifyHopeful(\r\n        uint withId\r\n    )\r\n        pre_cond(isOracle())\r\n    {\r\n        hopefuls[withId].isDisqualified = true;\r\n    }\r\n\r\n    /// @notice Closing oracle service, inputs final stats and triggers payouts\r\n    /// @dev Only the oracle can call this function\r\n    /// @param withId Index of Hopeful to be attest for\r\n    /// @param payoutQuantity Quantity of payoutAsset received as prize\r\n    /// @param finalSharePrice Performance of Melon fund at competition endTime; Can be changed for any other comparison metric\r\n    /// @param finalCompetitionRank Rank of Hopeful at end of competition; Calculate by logic as set in terms and conditions\r\n    function finalizeAndPayoutForHopeful(\r\n        uint withId,\r\n        uint payoutQuantity, // Quantity of payoutAsset received as prize\r\n        uint finalSharePrice, // Performance of Melon fund at competition endTime; Can be changed for any other comparison metric\r\n        uint finalCompetitionRank // Rank of Hopeful at end of competition; Calculate by logic as set in terms and conditions\r\n    )\r\n        pre_cond(isOracle())\r\n        pre_cond(hopefuls[withId].isDisqualified == false)\r\n        pre_cond(block.timestamp >= endTime)\r\n    {\r\n        hopefuls[withId].finalSharePrice = finalSharePrice;\r\n        hopefuls[withId].finalCompetitionRank = finalCompetitionRank;\r\n        hopefuls[withId].payoutQuantity = payoutQuantity;\r\n        require(MELON_CONTRACT.transfer(hopefuls[withId].registrant, payoutQuantity));\r\n    }\r\n\r\n    /// @notice Changes certifier contract address\r\n    /// @dev Only the oracle can call this function\r\n    /// @param newCertifier Address of the new certifier\r\n    function changeCertifier(\r\n        address newCertifier\r\n    )\r\n        pre_cond(isOracle())\r\n    {\r\n        CERTIFIER = Certifier(newCertifier);\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20Interface {\r\n\r\n    // EVENTS\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // CONSTANT METHODS\r\n\r\n    function totalSupply() constant returns (uint256 totalSupply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n}\r\n\r\ncontract Owned {\r\n\tmodifier only_owner { if (msg.sender != owner) return; _; }\r\n\r\n\tevent NewOwner(address indexed old, address indexed current);\r\n\r\n\tfunction setOwner(address _new) only_owner { NewOwner(owner, _new); owner = _new; }\r\n\r\n\taddress public owner = msg.sender;\r\n}\r\n\r\ncontract Certifier {\r\n\tevent Confirmed(address indexed who);\r\n\tevent Revoked(address indexed who);\r\n\tfunction certified(address _who) constant returns (bool);\r\n\tfunction get(address _who, string _field) constant returns (bytes32) {}\r\n\tfunction getAddress(address _who, string _field) constant returns (address) {}\r\n\tfunction getUint(address _who, string _field) constant returns (uint) {}\r\n}\r\n\r\ncontract SimpleCertifier is Owned, Certifier {\r\n\tmodifier only_delegate { if (msg.sender != delegate) return; _; }\r\n\tmodifier only_certified(address _who) { if (!certs[_who].active) return; _; }\r\n\r\n\tstruct Certification {\r\n\t\tbool active;\r\n\t\tmapping (string => bytes32) meta;\r\n\t}\r\n\r\n\tfunction certify(address _who) only_delegate {\r\n\t\tcerts[_who].active = true;\r\n\t\tConfirmed(_who);\r\n\t}\r\n\tfunction revoke(address _who) only_delegate only_certified(_who) {\r\n\t\tcerts[_who].active = false;\r\n\t\tRevoked(_who);\r\n\t}\r\n\tfunction certified(address _who) constant returns (bool) { return certs[_who].active; }\r\n\tfunction get(address _who, string _field) constant returns (bytes32) { return certs[_who].meta[_field]; }\r\n\tfunction getAddress(address _who, string _field) constant returns (address) { return address(certs[_who].meta[_field]); }\r\n\tfunction getUint(address _who, string _field) constant returns (uint) { return uint(certs[_who].meta[_field]); }\r\n\tfunction setDelegate(address _new) only_owner { delegate = _new; }\r\n\r\n\tmapping (address => Certification) certs;\r\n\t// So that the server posting puzzles doesn't have access to the ETH.\r\n\taddress public delegate = msg.sender;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"TERMS_AND_CONDITIONS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registeredFundToRegistrants\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"withId\",\"type\":\"uint256\"},{\"name\":\"payoutQuantity\",\"type\":\"uint256\"},{\"name\":\"finalSharePrice\",\"type\":\"uint256\"},{\"name\":\"finalCompetitionRank\",\"type\":\"uint256\"}],\"name\":\"finalizeAndPayoutForHopeful\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"address\"}],\"name\":\"getHopefulId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"registrantToHopefulIds\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxbuyinQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeMoneyAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMelonAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"address\"}],\"name\":\"isKYCVerified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxHopefulsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeMoneyQuantity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MELON_ASSET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MELON_BASE_UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fund\",\"type\":\"address\"},{\"name\":\"manager\",\"type\":\"address\"},{\"name\":\"buyinAsset\",\"type\":\"address\"},{\"name\":\"payoutAsset\",\"type\":\"address\"},{\"name\":\"payoutAddress\",\"type\":\"address\"},{\"name\":\"buyinQuantity\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"registerForCompetition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCompetitionStatusOfHopefuls\",\"outputs\":[{\"name\":\"fundAddrs\",\"type\":\"address[]\"},{\"name\":\"fundManagers\",\"type\":\"address[]\"},{\"name\":\"areCompeting\",\"type\":\"bool[]\"},{\"name\":\"areDisqualified\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CERTIFIER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MELON_CONTRACT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"withId\",\"type\":\"uint256\"}],\"name\":\"disqualifyHopeful\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"byManager\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"termsAndConditionsAreSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCertifier\",\"type\":\"address\"}],\"name\":\"changeCertifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hopefuls\",\"outputs\":[{\"name\":\"fund\",\"type\":\"address\"},{\"name\":\"manager\",\"type\":\"address\"},{\"name\":\"registrant\",\"type\":\"address\"},{\"name\":\"hasSigned\",\"type\":\"bool\"},{\"name\":\"buyinAsset\",\"type\":\"address\"},{\"name\":\"payoutAsset\",\"type\":\"address\"},{\"name\":\"buyinQuantity\",\"type\":\"uint256\"},{\"name\":\"payoutQuantity\",\"type\":\"uint256\"},{\"name\":\"payoutAddress\",\"type\":\"address\"},{\"name\":\"isCompeting\",\"type\":\"bool\"},{\"name\":\"isDisqualified\",\"type\":\"bool\"},{\"name\":\"finalSharePrice\",\"type\":\"uint256\"},{\"name\":\"finalCompetitionRank\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ofMelonAsset\",\"type\":\"address\"},{\"name\":\"ofOracle\",\"type\":\"address\"},{\"name\":\"ofCertifier\",\"type\":\"address\"},{\"name\":\"ofStartTime\",\"type\":\"uint256\"},{\"name\":\"ofMaxbuyinQuantity\",\"type\":\"uint256\"},{\"name\":\"ofMaxHopefulsNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fund\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"}]","ContractName":"Competition","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000beb9ef514a379b997e0798fdcc901ee474b6d9a1000000000000000000000000009b25796a57ae8c418bba130d5b78ddf25dbb2300000000000000000000000019d9d9d2066753f0929b51b64643a5ef899a6d3c000000000000000000000000000000000000000000000000000000005a71a1b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002710","Library":"","SwarmSource":"bzzr://9576135d6f8561492eade29a9e5d577ba27dc26c91d9470ea03552753ce7a59f"}]}