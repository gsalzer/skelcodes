{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract ERC20Basic\r\n{\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public constant returns(uint256);\r\n    function transfer(address to,uint256 value) public returns(bool);\r\n    event Transfer(address indexedfrom,address indexedto,uint256 value);\r\n}\r\ncontract IERC20 is ERC20Basic\r\n{\r\n    function allowance(address owner,address spender) public constant returns(uint256);\r\n    function transferFrom(address from,address to,uint256 value) public returns(bool);\r\n    function approve(address spender,uint256 value) public returns(bool);\r\n    event Approval(address indexedowner,address indexedspender,uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256){\r\n        uint256 c=a*b;\r\n        assert(a==0||c/a==b);\r\n        return c;\r\n    }\r\n    function div(uint256 a,uint256 b) internal constant returns(uint256)\r\n    {\r\n        //assert(b>0);//Solidityautomaticallythrowswhendividingby0\r\n        uint256 c=a/b;\r\n        //assert(a==b*c+a%b);//Thereisnocaseinwhichthisdoesn'thold\r\n        return c;\r\n    }\r\n    function sub(uint256 a,uint256 b) internal constant returns(uint256)\r\n    {\r\n        assert(b<=a);\r\n        return a-b;\r\n    }\r\n    function add(uint256 a,uint256 b) internal constant returns(uint256)\r\n    {\r\n        uint256 c=a+b;\r\n        assert(c>=a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract KPRToken is IERC20 {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n\r\n    \r\n    //public variables\r\n    string public constant symbol=\"KPR\"; \r\n    string public constant name=\"KPR Coin\"; \r\n    uint8 public constant decimals=18;\r\n\r\n    //1 ETH = 2,500 KPR\r\n    uint56 public  RATE = 2500;\r\n\r\n    //totalsupplyoftoken \r\n    uint public totalSupply = 100000000 * 10 ** uint(decimals);\r\n    \r\n    uint public buyabletoken = 90000000 * 10 ** uint(decimals);\r\n    //where the ETH goes \r\n    address public owner;\r\n    \r\n    //map the addresses\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    // 1514764800 : Jan 1 2018\r\n    uint phase1starttime = 1517443200; // Phase 1 Start Date Feb 1 2018\r\n    uint phase1endtime = 1519257600;  // Phase 1 End Date Feb 22 2018\r\n    uint phase2starttime = 1519862400;  // Phase 2 Start Date March 1 2018\r\n    uint phase2endtime = 1521676800; // Phase 2 End Date March 22 2018\r\n    uint phase3starttime = 1522540800;  // Phase 3 Start Date May 1 2018\r\n    uint phase3endtime = 1524355200; // Phase 3 End Date May 22 2018\r\n    \r\n  \r\n    //create token function = check\r\n\r\n    function() payable {\r\n        buyTokens();\r\n    }\r\n\r\n    function KPRToken() {\r\n        owner = msg.sender;\r\n        balances[owner] = totalSupply;\r\n    }\r\n\r\n    function buyTokens() payable {\r\n        \r\n        require(msg.value > 0);\r\n        require(now > phase1starttime && now < phase3endtime);\r\n        uint256 tokens;\r\n    \r\n        if (now > phase1starttime && now < phase1endtime){\r\n            \r\n            RATE = 3000;\r\n            setPrice(msg.sender, msg.value);\r\n        } else if(now > phase2starttime && now < phase2endtime){\r\n            RATE = 2000;\r\n            setPrice(msg.sender, msg.value);\r\n            // tokens = msg.value.mul(RATE);\r\n            // require(tokens < buyabletoken);\r\n            // balances[msg.sender]=balances[msg.sender].add(tokens);\r\n            // balances[owner] = balances[owner].sub(tokens);\r\n            // buyabletoken = buyabletoken.sub(tokens);\r\n            // owner.transfer(msg.value);\r\n            \r\n        } else if(now > phase3starttime && now < phase3endtime){\r\n            \r\n            RATE = 1000;\r\n            setPrice(msg.sender, msg.value);\r\n        }\r\n    }\r\n    \r\n    function setPrice(address receipt, uint256 value){\r\n        uint256 tokens;\r\n        tokens = value.mul(RATE);\r\n        require(tokens < buyabletoken);\r\n        balances[receipt]=balances[receipt].add(tokens);\r\n        balances[owner] = balances[owner].sub(tokens);\r\n        buyabletoken = buyabletoken.sub(tokens);\r\n        owner.transfer(value);\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns(uint256 balance) {\r\n        \r\n        return balances[_owner];\r\n        \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) returns(bool success) {\r\n        \r\n        //require is the same as an if statement = checks \r\n        require(balances[msg.sender] >= _value && _value > 0 );\r\n        \r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        \r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        \r\n        //checking if the spender has permission to spend and how much \r\n        require( allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);\r\n        \r\n        //updating the spenders balance \r\n        balances[_from] = balances[_from].sub(_value); \r\n        balances[_to] = balances[_to].add(_value); \r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); \r\n        Transfer(_from, _to, _value); \r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns(bool success) {\r\n        \r\n        //if above require is true,approve the spending \r\n        allowed[msg.sender][_spender] = _value; \r\n        Approval(msg.sender, _spender, _value); \r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n        \r\n        return allowed[_owner][_spender];\r\n        \r\n    }\r\n    \r\n    event Transfer(address indexed_from, address indexed_to, uint256 _value);\r\n    event Approval(address indexed_owner, address indexed_spender, uint256 _value);\r\n    \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"receipt\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyabletoken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint56\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"indexed_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"indexed_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"indexed_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"indexed_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"KPRToken","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ecf452ded4460f303a38e2502c7902d74d842dd0bf8e41aff8224288a79fa184"}]}