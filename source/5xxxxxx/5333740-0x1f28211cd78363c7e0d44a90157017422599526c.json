{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract SplitPayment {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public totalShares = 0;\r\n  uint256 public totalReleased = 0;\r\n\r\n  mapping(address => uint256) public shares;\r\n  mapping(address => uint256) public released;\r\n  address[] public payees;\r\n\r\n  /**\r\n   * @dev Constructor\r\n   */\r\n  function SplitPayment(address[] _payees, uint256[] _shares) public payable {\r\n    require(_payees.length == _shares.length);\r\n\r\n    for (uint256 i = 0; i < _payees.length; i++) {\r\n      addPayee(_payees[i], _shares[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev payable fallback\r\n   */\r\n  function () public payable {}\r\n\r\n  /**\r\n   * @dev Claim your share of the balance.\r\n   */\r\n  function claim() public {\r\n    address payee = msg.sender;\r\n\r\n    require(shares[payee] > 0);\r\n\r\n    uint256 totalReceived = this.balance.add(totalReleased);\r\n    uint256 payment = totalReceived.mul(shares[payee]).div(totalShares).sub(released[payee]);\r\n\r\n    require(payment != 0);\r\n    require(this.balance >= payment);\r\n\r\n    released[payee] = released[payee].add(payment);\r\n    totalReleased = totalReleased.add(payment);\r\n\r\n    payee.transfer(payment);\r\n  }\r\n\r\n  /**\r\n   * @dev Add a new payee to the contract.\r\n   * @param _payee The address of the payee to add.\r\n   * @param _shares The number of shares owned by the payee.\r\n   */\r\n  function addPayee(address _payee, uint256 _shares) internal {\r\n    require(_payee != address(0));\r\n    require(_shares > 0);\r\n    require(shares[_payee] == 0);\r\n\r\n    payees.push(_payee);\r\n    shares[_payee] = _shares;\r\n    totalShares = totalShares.add(_shares);\r\n  }\r\n}\r\n\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n\t\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your assets.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ncontract CorsariumAccessControl is SplitPayment {\r\n//contract CorsariumAccessControl {\r\n   \r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public megoAddress = 0x4ab6C984E72CbaB4162429721839d72B188010E3;\r\n    address public publisherAddress = 0x00C0bCa70EAaADF21A158141EC7eA699a17D63ed;\r\n    // cat, rene, pablo,  cristean, chulini, pablo, david, mego\r\n    address[] public teamAddresses = [0x4978FaF663A3F1A6c74ACCCCBd63294Efec64624, 0x772009E69B051879E1a5255D9af00723df9A6E04, 0xA464b05832a72a1a47Ace2Be18635E3a4c9a240A, 0xd450fCBfbB75CDAeB65693849A6EFF0c2976026F, 0xd129BBF705dC91F50C5d9B44749507f458a733C8, 0xfDC2ad68fd1EF5341a442d0E2fC8b974E273AC16, 0x4ab6C984E72CbaB4162429721839d72B188010E3];\r\n    // todo: add addresses of creators\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    modifier onlyTeam() {\r\n        require(msg.sender == teamAddresses[0] || msg.sender == teamAddresses[1] || msg.sender == teamAddresses[2] || msg.sender == teamAddresses[3] || msg.sender == teamAddresses[4] || msg.sender == teamAddresses[5] || msg.sender == teamAddresses[6] || msg.sender == teamAddresses[7]);\r\n        _; // do the rest\r\n    }\r\n\r\n    modifier onlyPublisher() {\r\n        require(msg.sender == publisherAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMEGO() {\r\n        require(msg.sender == megoAddress);\r\n        _;\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function CorsariumAccessControl() public {\r\n        megoAddress = msg.sender;\r\n    }\r\n\r\n    /// @dev Called by any team member to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyTeam whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by MEGO, since\r\n    ///  one reason we may pause the contract is when team accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyMEGO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n\r\n}\r\n\r\ncontract CardBase is CorsariumAccessControl, ERC721, ERC721Metadata {\r\n\r\n    /*** EVENTS ***/\r\n\r\n    /// @dev The Print event is fired whenever a new card comes into existence.\r\n    event Print(address owner, uint256 cardId);\r\n    \r\n    uint256 lastPrintedCard = 0;\r\n     \r\n    mapping (uint256 => address) public tokenIdToOwner;  // 721 tokenIdToOwner\r\n    mapping (address => uint256) public ownerTokenCount; // 721 ownerTokenCount\r\n    mapping (uint256 => address) public tokenIdToApproved; // 721 tokenIdToApprovedAddress\r\n    mapping (uint256 => uint256) public tokenToCardIndex; // 721 tokenIdToMetadata\r\n    //mapping (uint256 => uint256) public tokenCountIndex;\r\n    //mapping (address => uint256[]) internal ownerToTokensOwned;\r\n    //mapping (uint256 => uint256) internal tokenIdToOwnerArrayIndex;\r\n\r\n    /// @dev Assigns ownership of a specific card to an address.\r\n    /*function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n      \r\n        ownershipTokenCount[_to]++;\r\n        // transfer ownership\r\n        cardIndexToOwner[_tokenId] = _to;\r\n       \r\n        // Emit the transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n        \r\n    }*/\r\n    \r\n    function _createCard(uint256 _prototypeId, address _owner) internal returns (uint) {\r\n\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        require(uint256(1000000) > lastPrintedCard);\r\n        lastPrintedCard++;\r\n        tokenToCardIndex[lastPrintedCard] = _prototypeId;\r\n        _setTokenOwner(lastPrintedCard, _owner);\r\n        //_addTokenToOwnersList(_owner, lastPrintedCard);\r\n        Transfer(0, _owner, lastPrintedCard);\r\n        //tokenCountIndex[_prototypeId]++;\r\n        \r\n        //_transfer(0, _owner, lastPrintedCard); //<-- asd\r\n        \r\n\r\n        return lastPrintedCard;\r\n    }\r\n\r\n    function _clearApprovalAndTransfer(address _from, address _to, uint _tokenId) internal {\r\n        _clearTokenApproval(_tokenId);\r\n        //_removeTokenFromOwnersList(_from, _tokenId);\r\n        ownerTokenCount[_from]--;\r\n        _setTokenOwner(_tokenId, _to);\r\n        //_addTokenToOwnersList(_to, _tokenId);\r\n    }\r\n\r\n    function _ownerOf(uint _tokenId) internal view returns (address _owner) {\r\n        return tokenIdToOwner[_tokenId];\r\n    }\r\n\r\n    function _approve(address _to, uint _tokenId) internal {\r\n        tokenIdToApproved[_tokenId] = _to;\r\n    }\r\n\r\n    function _getApproved(uint _tokenId) internal view returns (address _approved) {\r\n        return tokenIdToApproved[_tokenId];\r\n    }\r\n\r\n    function _clearTokenApproval(uint _tokenId) internal {\r\n        tokenIdToApproved[_tokenId] = address(0);\r\n    }\r\n\r\n    function _setTokenOwner(uint _tokenId, address _owner) internal {\r\n        tokenIdToOwner[_tokenId] = _owner;\r\n        ownerTokenCount[_owner]++;\r\n    }\r\n\r\n}\r\n\r\ncontract CardOwnership is CardBase {\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownerTokenCount[_owner];\r\n    }\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\r\n        _owner = tokenIdToOwner[_tokenId];\r\n        require(_owner != address(0));\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {\r\n        require(_getApproved(_tokenId) == msg.sender);\r\n        require(_ownerOf(_tokenId) == _from);\r\n        require(_to != address(0));\r\n\r\n        _clearApprovalAndTransfer(_from, _to, _tokenId);\r\n\r\n        Approval(_from, 0, _tokenId);\r\n        Transfer(_from, _to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 value = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\r\n\r\n            if (value != bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))) {\r\n                revert();\r\n            }\r\n        }\r\n    }\r\n\t\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n        require(_getApproved(_tokenId) == msg.sender);\r\n        require(_ownerOf(_tokenId) == _from);\r\n        require(_to != address(0));\r\n\r\n        _clearApprovalAndTransfer(_from, _to, _tokenId);\r\n\r\n        Approval(_from, 0, _tokenId);\r\n        Transfer(_from, _to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 value = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, \"\");\r\n\r\n            if (value != bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))) {\r\n                revert();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n        require(_getApproved(_tokenId) == msg.sender);\r\n        require(_ownerOf(_tokenId) == _from);\r\n        require(_to != address(0));\r\n\r\n        _clearApprovalAndTransfer(_from, _to, _tokenId);\r\n\r\n        Approval(_from, 0, _tokenId);\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable {\r\n        require(msg.sender == _ownerOf(_tokenId));\r\n        require(msg.sender != _approved);\r\n        \r\n        if (_getApproved(_tokenId) != address(0) || _approved != address(0)) {\r\n            _approve(_approved, _tokenId);\r\n            Approval(msg.sender, _approved, _tokenId);\r\n        }\r\n    }\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your assets.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        revert();\r\n    }\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        return _getApproved(_tokenId);\r\n    }\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return _owner == _operator;\r\n    }\r\n\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name) {\r\n        return \"Dark Winds First Edition Cards\";\r\n    }\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol) {\r\n        return \"DW1ST\";\r\n    }\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string _tokenURI) {\r\n        _tokenURI = \"https://corsarium.playdarkwinds.com/cards/00000.json\"; //37 36 35 34 33\r\n        bytes memory tokenUriBytes = bytes(_tokenURI);\r\n        tokenUriBytes[33] = byte(48 + (tokenToCardIndex[_tokenId] / 10000) % 10);\r\n        tokenUriBytes[34] = byte(48 + (tokenToCardIndex[_tokenId] / 1000) % 10);\r\n        tokenUriBytes[35] = byte(48 + (tokenToCardIndex[_tokenId] / 100) % 10);\r\n        tokenUriBytes[36] = byte(48 + (tokenToCardIndex[_tokenId] / 10) % 10);\r\n        tokenUriBytes[37] = byte(48 + (tokenToCardIndex[_tokenId] / 1) % 10);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256 _total) {\r\n        _total = lastPrintedCard;\r\n    }\r\n\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { \r\n            size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract CorsariumCore is CardOwnership {\r\n\r\n    uint256 nonce = 1;\r\n    uint256 public cardCost = 1 finney;\r\n\r\n    function CorsariumCore(address[] _payees, uint256[] _shares) SplitPayment(_payees, _shares) public {\r\n\r\n    }\r\n\r\n    // payable fallback\r\n    function () public payable {}\r\n\r\n    function changeCardCost(uint256 _newCost) onlyTeam public {\r\n        cardCost = _newCost;\r\n    }\r\n\r\n    function getCard(uint _token_id) public view returns (uint256) {\r\n        assert(_token_id <= lastPrintedCard);\r\n        return tokenToCardIndex[_token_id];\r\n    }\r\n\r\n    function buyBoosterPack() public payable {\r\n        uint amount = msg.value/cardCost;\r\n        uint blockNumber = block.timestamp;\r\n        for (uint i = 0; i < amount; i++) {\r\n            _createCard(i%5 == 1 ? (uint256(keccak256(i+nonce+blockNumber)) % 50) : (uint256(keccak256(i+nonce+blockNumber)) % 50) + (nonce%50), msg.sender);\r\n        }\r\n        nonce += amount;\r\n\r\n    }\r\n    \r\n    function cardsOfOwner(address _owner) external view returns (uint256[] ownerCards) {\r\n        uint256 tokenCount = ownerTokenCount[_owner];\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 resultIndex = 0;\r\n\r\n            // We count on the fact that all cards have IDs starting at 1 and increasing\r\n            // sequentially up to the totalCards count.\r\n            uint256 cardId;\r\n\r\n            for (cardId = 1; cardId <= lastPrintedCard; cardId++) {\r\n                if (tokenIdToOwner[cardId] == _owner) {\r\n                    result[resultIndex] = cardId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) external view returns (uint256[] ownerCards) {\r\n        uint256 tokenCount = ownerTokenCount[_owner];\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 resultIndex = 0;\r\n\r\n            // We count on the fact that all cards have IDs starting at 1 and increasing\r\n            // sequentially up to the totalCards count.\r\n            uint256 cardId;\r\n\r\n            for (cardId = 1; cardId <= lastPrintedCard; cardId++) {\r\n                if (tokenIdToOwner[cardId] == _owner) {\r\n                    result[resultIndex] = cardId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function cardSupply() external view returns (uint256[] printedCards) {\r\n\r\n        if (totalSupply() == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](100);\r\n            //uint256 totalCards = 1000000;\r\n            //uint256 resultIndex = 0;\r\n\r\n            // We count on the fact that all cards have IDs starting at 1 and increasing\r\n            // sequentially up to 1000000\r\n            uint256 cardId;\r\n\r\n            for (cardId = 1; cardId < 1000000; cardId++) {\r\n                result[tokenToCardIndex[cardId]]++;\r\n                //resultIndex++;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address \r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCost\",\"type\":\"uint256\"}],\"name\":\"changeCardCost\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publisherAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"cardsOfOwner\",\"outputs\":[{\"name\":\"ownerCards\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payees\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cardSupply\",\"outputs\":[{\"name\":\"printedCards\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerCards\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token_id\",\"type\":\"uint256\"}],\"name\":\"getCard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyBoosterPack\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"_tokenURI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"megoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReleased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cardCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToCardIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_payees\",\"type\":\"address[]\"},{\"name\":\"_shares\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"Print\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"CorsariumCore","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000004ab6c984e72cbab4162429721839d72b188010e300000000000000000000000000c0bca70eaaadf21a158141ec7ea699a17d63ed0000000000000000000000004978faf663a3f1a6c74accccbd63294efec64624000000000000000000000000772009e69b051879e1a5255d9af00723df9a6e04000000000000000000000000a464b05832a72a1a47ace2be18635e3a4c9a240a000000000000000000000000d450fcbfbb75cdaeb65693849a6eff0c2976026f000000000000000000000000d129bbf705dc91f50c5d9b44749507f458a733c8000000000000000000000000fdc2ad68fd1ef5341a442d0e2fc8b974e273ac160000000000000000000000003b8957d1f6f416ad11b25e9c4e99fef3542f6802000000000000000000000000afdb9e04b1bd67224b0d993d9ed08054ab99f4b1000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://43bed85377b7babfa1e7893162864ac1d87cb0d020b5a48ea1e5c7abf8df7dab"}]}