{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\ncontract Escrow {\r\n    using SafeMath for uint256;\r\n    using ContentUtils for ContentUtils.ContentMapping;\r\n\r\n    ContentUtils.ContentMapping public content;\r\n    address escrowAddr = address(this);\r\n\r\n    uint256 public claimable = 0; \r\n    uint256 public currentBalance = 0; \r\n    mapping(bytes32 => uint256) public claimableRewards;\r\n\r\n    /// @notice valid reward and user has enough funds\r\n    modifier validReward(uint256 _reward) {\r\n        require(_reward > 0 && _depositEscrow(_reward));\r\n        _;\r\n    }\r\n\r\n    /// @notice complete deliverable by making reward amount claimable\r\n    function completeDeliverable(bytes32 _id, address _creator, address _brand) internal returns(bool) {\r\n        require(content.isFulfilled(_id, _creator, _brand));\r\n        content.completeDeliverable(_id);\r\n        return _approveEscrow(_id, content.rewardOf(_id));       \r\n    }\r\n\r\n    /// @notice update current balance, if proper token amount approved\r\n    function _depositEscrow(uint256 _amount) internal returns(bool) {\r\n        currentBalance = currentBalance.add(_amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice approve reward amount for transfer from escrow contract to creator\r\n    function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) {\r\n        claimable = claimable.add(_amount);\r\n        claimableRewards[_id] = _amount;\r\n        return true;\r\n    }\r\n\r\n    function getClaimableRewards(bytes32 _id) public returns(uint256) {\r\n        return claimableRewards[_id];\r\n    }\r\n\r\n    function getContentByName(string _name) public view returns(\r\n        string name,\r\n        string description,\r\n        uint reward,\r\n        uint addedOn) \r\n    {\r\n        var (_content, exist) = content.getContentByName(_name);\r\n        if (exist) {\r\n            return (_content.name, _content.description, _content.deliverable.reward, _content.addedOn);\r\n        } else {\r\n            return (\"\", \"\", 0, 0);\r\n        }\r\n    }\r\n\r\n    function currentFulfillment(string _name) public view returns(bool fulfillment) {\r\n        var (_content, exist) = content.getContentByName(_name);\r\n        if (exist) {\r\n            return _content.deliverable.fulfillment[msg.sender];\r\n        } else {\r\n            false;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary DeliverableUtils {\r\n\r\n    struct Deliverable {\r\n        uint256 reward;\r\n        mapping(address=>bool) fulfillment;\r\n        bool fulfilled;\r\n    }\r\n\r\n    /// @notice msg.sender can be creator or brand and mark their delivery or approval, returns check if completely Fulfilled\r\n    function fulfill(Deliverable storage self, address _creator, address _brand) internal returns(bool) {\r\n        require(msg.sender == _creator || msg.sender == _brand);\r\n        self.fulfillment[msg.sender] = true;\r\n        return self.fulfillment[_creator] && self.fulfillment[_brand];\r\n    }\r\n\r\n    /// @notice check if deliverable fulfilled completely\r\n    function isFulfilled(Deliverable storage self, address _creator, address _brand) internal view returns(bool) {\r\n        return self.fulfillment[_creator] && self.fulfillment[_brand];\r\n    }\r\n\r\n    /// @notice return new deliverable struct if reward greater than 0\r\n    function newDeliverable(uint256 _reward) internal pure returns(Deliverable _deliverable) {\r\n        require(_reward > 0);\r\n        return Deliverable(_reward, false);\r\n    }\r\n}\r\n\r\nlibrary ContentUtils {\r\n    using SafeMath for uint256;\r\n    using DeliverableUtils for DeliverableUtils.Deliverable;\r\n\r\n    struct Content {\r\n        bytes32 id;\r\n        string name;\r\n        string description;\r\n        uint addedOn;\r\n        DeliverableUtils.Deliverable deliverable;\r\n    }\r\n\r\n    /// @notice utility for mapping bytes32=>Content. Keys must be unique. It can be updated until it is locked.\r\n    struct ContentMapping {\r\n        mapping(bytes32=>Content) data;\r\n        bytes32[] keys;\r\n        bool locked;\r\n    }\r\n\r\n    string constant UNIQUE_KEY_ERR = \"Content with ID already exists \";\r\n    string constant KEY_NOT_FOUND_ERR = \"Key not found\";\r\n\r\n    /// @notice put item into mapping\r\n    function put(ContentMapping storage self, \r\n        string _name, \r\n        string _description, \r\n        uint _reward) public returns (bool) \r\n    {\r\n            require(!self.locked);\r\n\r\n            bytes32 _id = generateContentID(_name);\r\n            require(self.data[_id].id == bytes32(0));\r\n\r\n            self.data[_id] = Content(_id, _name, _description, block.timestamp, DeliverableUtils.newDeliverable(_reward));\r\n            self.keys.push(_id);\r\n            return true;\r\n    }\r\n    \r\n    /// @notice get amount of items in mapping\r\n    function size(ContentMapping storage self) public view returns (uint) {\r\n        return self.keys.length;\r\n    }\r\n\r\n    /// @notice return reward of content delivarable\r\n    function rewardOf(ContentMapping storage self, bytes32 _id) public view returns (uint256) {\r\n        return self.data[_id].deliverable.reward;\r\n    }\r\n\r\n    function getKey(ContentMapping storage self, uint _index) public view returns (bytes32) {\r\n        isValidIndex(_index, self.keys.length);\r\n        return self.keys[_index];\r\n    }\r\n\r\n    /// @notice get content by plain string name\r\n    function getContentByName(ContentMapping storage self, string _name) public view returns (Content storage _content, bool exists) {\r\n        bytes32 _hash = generateContentID(_name);\r\n        return (self.data[_hash], self.data[_hash].addedOn != 0);\r\n    }\r\n\r\n    /// @notice get content by sha3 ID hash\r\n    function getContentByID(ContentMapping storage self, bytes32 _id) public view returns (Content storage _content, bool exists) {\r\n        return (self.data[_id], self.data[_id].id == bytes32(0));\r\n    }\r\n\r\n    /// @notice get content by _index into key array \r\n    function getContentByKeyIndex(ContentMapping storage self, uint _index) public view returns (Content storage _content) {\r\n        isValidIndex(_index, self.keys.length);\r\n        return (self.data[self.keys[_index]]);\r\n    }\r\n\r\n    /// @notice wrapper around internal deliverable method\r\n    function fulfill(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public returns(bool) {\r\n        return self.data[_id].deliverable.fulfill(_creator, _brand);\r\n    }\r\n\r\n    /// @notice wrapper around internal deliverable method\r\n    function isFulfilled(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public view returns(bool) {\r\n        return self.data[_id].deliverable.isFulfilled(_creator, _brand);\r\n    }\r\n\r\n    /// @notice marks deliverable as fulfilled\r\n    function completeDeliverable(ContentMapping storage self, bytes32 _id) internal returns(bool) {\r\n        self.data[_id].deliverable.fulfilled = true;\r\n        return true;\r\n    }\r\n\r\n    /// @notice get sha256 hash of name for content ID\r\n    function generateContentID(string _name) public pure returns (bytes32) {\r\n        return keccak256(_name);\r\n    }\r\n\r\n    /// @notice index not out of bounds\r\n    function isValidIndex(uint _index, uint _size) public pure {\r\n        require(_index < _size, KEY_NOT_FOUND_ERR);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract Agreement is Escrow {\r\n    \r\n    bool public locked;\r\n    uint  public createdOn;\r\n    uint public expiration;\r\n    uint public startTime;\r\n    address public brand;\r\n    address public creator;\r\n    \r\n    constructor(address _creator, uint _expiration, address _token) public {\r\n        brand = msg.sender;\r\n        creator = _creator;\r\n        expiration = _expiration;\r\n    }\r\n\r\n    /// @notice only brand is authorized\r\n    modifier onlyBrand() {\r\n        require(msg.sender == brand);\r\n        _;\r\n    }\r\n\r\n    /// @notice only creator is authorized\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator);\r\n        _;\r\n    }\r\n\r\n    /// @notice deliverable fulfilled\r\n    modifier fulfilled(bytes32 _id) {\r\n        require(content.isFulfilled(_id, creator, brand));\r\n        _;\r\n    }\r\n\r\n    /// @notice agreement expired, refunds remaining balance in escrow\r\n    modifier expired() {\r\n        require(block.timestamp > expiration);\r\n        _;\r\n    }\r\n\r\n    /// @notice agreement not expired, refunds remaining balance in escrow\r\n    modifier notExpired() {\r\n        require(block.timestamp < expiration);\r\n        _;\r\n    }\r\n\r\n    /// @notice agreement not locked\r\n    modifier notLocked() {\r\n        require(!locked);\r\n        _;\r\n    }\r\n\r\n    /// @notice add content to the agreement\r\n    function addContent(string _name, \r\n        string _description, \r\n        uint _reward) notLocked onlyBrand validReward(_reward) \r\n        public returns(bool _success) {\r\n            return content.put(_name, _description, _reward);\r\n    }\r\n\r\n    function _fulfill(bytes32 _id) private returns (bool) {\r\n        bool _fulfilled = content.fulfill(_id, creator, brand);\r\n        if(_fulfilled) {\r\n            return completeDeliverable(_id, creator, brand);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function fulfillDeliverable(bytes32 _id) notExpired onlyCreator public returns (bool) {\r\n        return _fulfill(_id);\r\n    }\r\n\r\n    function approveDeliverable(bytes32 _id) onlyBrand public returns (bool) {\r\n        return _fulfill(_id);\r\n    }\r\n    \r\n    function claim(bytes32 _id) external onlyCreator {\r\n        claimableRewards[_id] = 0;\r\n    }\r\n\r\n\r\n    function lock() onlyBrand public {\r\n        content.locked == true;\r\n        locked = true;\r\n        startTime = block.timestamp;\r\n    }\r\n\r\n    function extendExpiration(uint _expiration) onlyBrand public returns (bool) {\r\n        require(_expiration > expiration && _expiration >= block.timestamp);\r\n        expiration = _expiration;\r\n        return true;\r\n    }\r\n\r\n    function destroy() onlyBrand expired public {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    function deposit() payable {}\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n */\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) constant returns (uint);\r\n\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n\r\n    function approve(address spender, uint value) returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        if (newOwner != address(0))\r\n            owner = newOwner;\r\n    }\r\n\r\n    function kill() {\r\n        if (msg.sender == owner)\r\n            selfdestruct(owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender == owner)\r\n            _;\r\n    }\r\n}\r\n\r\n// Token Contract\r\ncontract CCOIN is ERC20, Ownable {\r\n\r\n    struct Escrow {\r\n        address creator;\r\n        address brand;\r\n        address agreementContract;\r\n        uint256 reward;\r\n    }\r\n\r\n    // Public variables of the token\r\n    string public constant name = \"CCOIN\";\r\n    string public constant symbol = \"CCOIN\";\r\n    uint public constant decimals = 18;\r\n    uint public totalSupply = 1000000000 * 10 ** 18;\r\n    bool public locked;\r\n\r\n    address public multisigETH; // SafeMath.multisig contract that will receive the ETH\r\n    address public crowdSaleaddress; // Crowdsale address\r\n    uint public ethReceived; // Number of ETH received\r\n    uint public totalTokensSent; // Number of tokens sent to ETH contributors\r\n    uint public startBlock; // Crowdsale start block\r\n    uint public endBlock; // Crowdsale end block\r\n    uint public maxCap; // Maximum number of token to sell\r\n    uint public minCap; // Minimum number of ETH to raise\r\n    uint public minContributionETH; // Minimum amount to invest\r\n    uint public tokenPriceWei;\r\n\r\n    uint firstPeriod;\r\n    uint secondPeriod;\r\n    uint thirdPeriod;\r\n    uint fourthPeriod;\r\n    uint fifthPeriod;\r\n    uint firstBonus;\r\n    uint secondBonus;\r\n    uint thirdBonus;\r\n    uint fourthBonus;\r\n    uint fifthBonus;\r\n    uint public multiplier;\r\n\r\n    bool public stopInEmergency = false;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    mapping(address => Escrow) escrowAgreements;\r\n    // Whitelist\r\n    mapping(address => bool) public whitelisted;\r\n\r\n    event Whitelist(address indexed participant);\r\n    event Locked();\r\n    event Unlocked();\r\n    event StoppedCrowdsale();\r\n    event RestartedCrowdsale();\r\n    event Burned(uint256 value);\r\n\r\n    // Lock transfer during the ICO\r\n    modifier onlyUnlocked() {\r\n        if (msg.sender != crowdSaleaddress && locked && msg.sender != owner)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // @notice to protect short address attack\r\n    modifier onlyPayloadSize(uint numWords){\r\n        assert(msg.data.length >= numWords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        if (msg.sender != crowdSaleaddress && msg.sender != owner)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // The Token constructor\r\n    constructor() public {\r\n        locked = true;\r\n        multiplier = 10 ** 18;\r\n\r\n        multisigETH = msg.sender;\r\n        minContributionETH = 1;\r\n        startBlock = 0;\r\n        endBlock = 0;\r\n        maxCap = 1000 * multiplier;\r\n        tokenPriceWei = SafeMath.div(1, 1400);\r\n        minCap = 100 * multiplier;\r\n        totalTokensSent = 0;\r\n        firstPeriod = 100;\r\n        secondPeriod = 200;\r\n        thirdPeriod = 300;\r\n        fourthPeriod = 400;\r\n        fifthPeriod = 500;\r\n\r\n        firstBonus = 120;\r\n        secondBonus = 115;\r\n        thirdBonus = 110;\r\n        fourthBonus = SafeMath.div(1075, 10);\r\n        fifthBonus = 105;\r\n        balances[multisigETH] = totalSupply;\r\n    }\r\n\r\n    function resetCrowdSaleaddress(address _newCrowdSaleaddress) public onlyAuthorized() {\r\n        crowdSaleaddress = _newCrowdSaleaddress;\r\n    }\r\n\r\n    function unlock() public onlyAuthorized {\r\n        locked = false;\r\n        emit Unlocked();\r\n    }\r\n\r\n    function lock() public onlyAuthorized {\r\n        locked = true;\r\n        emit Locked();\r\n    }\r\n\r\n    function burn(address _member, uint256 _value) public onlyAuthorized returns (bool) {\r\n        balances[_member] = SafeMath.sub(balances[_member], _value);\r\n        totalSupply = SafeMath.sub(totalSupply, _value);\r\n        emit Transfer(_member, 0x0, _value);\r\n        emit Burned(_value);\r\n        return true;\r\n    }\r\n\r\n    function Airdrop(address _to, uint256 _tokens) external onlyAuthorized returns(bool) {\r\n        require(transfer(_to, _tokens));\r\n    } \r\n\r\n    function transfer(address _to, uint _value) public onlyUnlocked returns (bool) {\r\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\r\n        balances[_to] = SafeMath.add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns (bool success) {\r\n        if (balances[_from] < _value)\r\n            revert();\r\n        // Check if the sender has enough\r\n        if (_value > allowed[_from][msg.sender])\r\n            revert();\r\n        // Check allowance\r\n        balances[_from] = SafeMath.sub(balances[_from], _value);\r\n        // SafeMath.subtract from the sender\r\n        balances[_to] = SafeMath.add(balances[_to], _value);\r\n        // SafeMath.add the same to the recipient\r\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function withdrawFromEscrow(address _agreementAddr, bytes32 _id) {\r\n        require(balances[_agreementAddr] > 0);\r\n        Agreement agreement = Agreement(_agreementAddr);\r\n        require(agreement.creator() == msg.sender);\r\n        uint256 reward = agreement.getClaimableRewards(_id);\r\n        require(reward > 0);\r\n        balances[_agreementAddr] = SafeMath.sub(balances[_agreementAddr], reward);\r\n        balances[msg.sender] = SafeMath.add(balances[msg.sender], reward);\r\n    }\r\n\r\n    function WhitelistParticipant(address participant) external onlyAuthorized {\r\n        whitelisted[participant] = true;\r\n        emit Whitelist(participant);\r\n    }\r\n\r\n    function BlacklistParticipant(address participant) external onlyAuthorized {\r\n        whitelisted[participant] = false;\r\n        emit Whitelist(participant);\r\n    }\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handles allocation of Ether and calculates tokens.\r\n    function() public payable onlyPayloadSize(2) {\r\n        contribute(msg.sender);\r\n    }\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _backer {address} address of beneficiary\r\n    // @return res {bool} true if transaction was successful\r\n    function contribute(address _backer) internal returns (bool res) {\r\n        // stop when required minimum is not sent\r\n        if (msg.value < minContributionETH)\r\n            revert();\r\n\r\n        // calculate number of tokens\r\n        uint tokensToSend = calculateNoOfTokensToSend();\r\n\r\n        // Ensure that max cap hasn't been reached\r\n        if (SafeMath.add(totalTokensSent, tokensToSend) > maxCap)\r\n            revert();\r\n\r\n        // Transfer tokens to contributor\r\n        if (!transfer(_backer, tokensToSend))\r\n            revert();\r\n\r\n        ethReceived = SafeMath.add(ethReceived, msg.value);\r\n        totalTokensSent = SafeMath.add(totalTokensSent, tokensToSend);\r\n\r\n        return true;\r\n    }\r\n\r\n    // @notice This function will return number of tokens based on time intervals in the campaign\r\n    function calculateNoOfTokensToSend() constant internal returns (uint) {\r\n        uint tokenAmount = SafeMath.div(SafeMath.mul(msg.value, multiplier), tokenPriceWei);\r\n        if (block.number <= startBlock + firstPeriod)\r\n            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, firstBonus), 100);\r\n        else if (block.number <= startBlock + secondPeriod)\r\n            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, secondBonus), 100);\r\n        else if (block.number <= startBlock + thirdPeriod)\r\n            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, thirdBonus), 100);\r\n        else if (block.number <= startBlock + fourthPeriod)\r\n            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fourthBonus), 100);\r\n        else if (block.number <= startBlock + fifthPeriod)\r\n            return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fifthBonus), 100);\r\n        else\r\n            return tokenAmount;\r\n    }\r\n\r\n    function stopCrowdsale() external onlyOwner{\r\n        stopInEmergency = true;\r\n        emit StoppedCrowdsale();\r\n    }\r\n\r\n    function restartCrowdsale() external onlyOwner{\r\n        stopInEmergency = false;\r\n        emit RestartedCrowdsale();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopInEmergency\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agreementAddr\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"withdrawFromEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCrowdSaleaddress\",\"type\":\"address\"}],\"name\":\"resetCrowdSaleaddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"WhitelistParticipant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Airdrop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"BlacklistParticipant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleaddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContributionETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"Whitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StoppedCrowdsale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RestartedCrowdsale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CCOIN","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e3e3f3e1fcbca9a22ed9b81b85e03ca0e4b699b0b02b554a9512d0bb5c310f78"}]}