{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n *\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n *\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * @dev and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      \"\\x19Ethereum Signed Message:\\n32\",\r\n      hash\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Arbitrator is Ownable {\r\n\r\n  mapping(address => bool) private aribitratorWhitelist;\r\n  address private primaryArbitrator;\r\n\r\n  event ArbitratorAdded(address indexed newArbitrator);\r\n  event ArbitratorRemoved(address indexed newArbitrator);\r\n  event ChangePrimaryArbitratorWallet(address indexed newPrimaryWallet);\r\n\r\n  constructor() public {\r\n    primaryArbitrator = msg.sender;\r\n  }\r\n\r\n  modifier onlyArbitrator() {\r\n    require(aribitratorWhitelist[msg.sender] == true || msg.sender == primaryArbitrator);\r\n    _;\r\n  }\r\n\r\n  function changePrimaryArbitrator(address walletAddress) public onlyOwner {\r\n    require(walletAddress != address(0));\r\n    emit ChangePrimaryArbitratorWallet(walletAddress);\r\n    primaryArbitrator = walletAddress;\r\n  }\r\n\r\n  function addArbitrator(address newArbitrator) public onlyOwner {\r\n    require(newArbitrator != address(0));\r\n    emit ArbitratorAdded(newArbitrator);\r\n    aribitratorWhitelist[newArbitrator] = true;\r\n  }\r\n\r\n  function deleteArbitrator(address arbitrator) public onlyOwner {\r\n    require(arbitrator != address(0));\r\n    require(arbitrator != msg.sender); //ensure owner isn't removed\r\n    emit ArbitratorRemoved(arbitrator);\r\n    delete aribitratorWhitelist[arbitrator];\r\n  }\r\n\r\n  //Mainly for front-end administration\r\n  function isArbitrator(address arbitratorCheck) external view returns(bool) {\r\n    return (aribitratorWhitelist[arbitratorCheck] || arbitratorCheck == primaryArbitrator);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ApprovedWithdrawer is Ownable {\r\n\r\n  mapping(address => bool) private withdrawerWhitelist;\r\n  address private primaryWallet;\r\n\r\n  event WalletApproved(address indexed newAddress);\r\n  event WalletRemoved(address indexed removedAddress);\r\n  event ChangePrimaryApprovedWallet(address indexed newPrimaryWallet);\r\n\r\n  constructor() public {\r\n    primaryWallet = msg.sender;\r\n  }\r\n\r\n  modifier onlyApprovedWallet(address _to) {\r\n    require(withdrawerWhitelist[_to] == true || primaryWallet == _to);\r\n    _;\r\n  }\r\n\r\n  function changePrimaryApprovedWallet(address walletAddress) public onlyOwner {\r\n    require(walletAddress != address(0));\r\n    emit ChangePrimaryApprovedWallet(walletAddress);\r\n    primaryWallet = walletAddress;\r\n  }\r\n\r\n  function addApprovedWalletAddress(address walletAddress) public onlyOwner {\r\n    require(walletAddress != address(0));\r\n    emit WalletApproved(walletAddress);\r\n    withdrawerWhitelist[walletAddress] = true;\r\n  }\r\n\r\n  function deleteApprovedWalletAddress(address walletAddress) public onlyOwner {\r\n    require(walletAddress != address(0));\r\n    require(walletAddress != msg.sender); //ensure owner isn't removed\r\n    emit WalletRemoved(walletAddress);\r\n    delete withdrawerWhitelist[walletAddress];\r\n  }\r\n\r\n  //Mainly for front-end administration\r\n  function isApprovedWallet(address walletCheck) external view returns(bool) {\r\n    return (withdrawerWhitelist[walletCheck] || walletCheck == primaryWallet);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title CoinSparrow\r\n */\r\n\r\n\r\ncontract CoinSparrow  is Ownable, Arbitrator, ApprovedWithdrawer, Pausable {\r\n\r\n  //Who wouldn't?\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n   * ------------------------------------\r\n   * SET UP SOME CONSTANTS FOR JOB STATUS\r\n   * ------------------------------------\r\n   */\r\n\r\n  //Some of these are not used in the contract, but are for reference and are used in the front-end's database.\r\n  uint8 constant private STATUS_JOB_NOT_EXIST = 1; //Not used in contract. Here for reference (used externally)\r\n  uint8 constant private STATUS_JOB_CREATED = 2; //Job has been created. Set by createJobEscrow()\r\n  uint8 constant private STATUS_JOB_STARTED = 3; //Contractor flags job as started. Set by jobStarted()\r\n  uint8 constant private STATUS_HIRER_REQUEST_CANCEL = 4; //Hirer requested cancellation on started job.\r\n                                                  //Set by requestMutualJobCancelation()\r\n  uint8 constant private STATUS_JOB_COMPLETED = 5; //Contractor flags job as completed. Set by jobCompleted()\r\n  uint8 constant private STATUS_JOB_IN_DISPUTE = 6; //Either party raised dispute. Set by requestDispute()\r\n  uint8 constant private STATUS_HIRER_CANCELLED = 7; //Not used in contract. Here for reference\r\n  uint8 constant private STATUS_CONTRACTOR_CANCELLED = 8; //Not used in contract. Here for reference\r\n  uint8 constant private STATUS_FINISHED_FUNDS_RELEASED = 9; //Not used in contract. Here for reference\r\n  uint8 constant private STATUS_FINISHED_FUNDS_RELEASED_BY_CONTRACTOR = 10; //Not used in contract. Here for reference\r\n  uint8 constant private STATUS_CONTRACTOR_REQUEST_CANCEL = 11; //Contractor requested cancellation on started job.\r\n                                                        //Set by requestMutualJobCancelation()\r\n  uint8 constant private STATUS_MUTUAL_CANCELLATION_PROCESSED = 12; //Not used in contract. Here for reference\r\n\r\n  //Deployment script will check for existing CoinSparrow contracts, and only\r\n  //deploy if this value is > than existing version.\r\n  //TODO: to be implemented\r\n  uint8 constant private COINSPARROW_CONTRACT_VERSION = 1;\r\n\r\n  /**\r\n   * ------\r\n   * EVENTS\r\n   * ------\r\n   */\r\n\r\n  event JobCreated(bytes32 _jobHash, address _who, uint256 _value);\r\n  event ContractorStartedJob(bytes32 _jobHash, address _who);\r\n  event ContractorCompletedJob(bytes32 _jobHash, address _who);\r\n  event HirerRequestedCancel(bytes32 _jobHash, address _who);\r\n  event ContractorRequestedCancel(bytes32 _jobHash, address _who);\r\n  event CancelledByHirer(bytes32 _jobHash, address _who);\r\n  event CancelledByContractor(bytes32 _jobHash, address _who);\r\n  event MutuallyAgreedCancellation(\r\n    bytes32 _jobHash,\r\n    address _who,\r\n    uint256 _hirerAmount,\r\n    uint256 _contractorAmount\r\n  );\r\n  event DisputeRequested(bytes32 _jobHash, address _who);\r\n  event DisputeResolved(\r\n    bytes32 _jobHash,\r\n    address _who,\r\n    uint256 _hirerAmount,\r\n    uint256 _contractorAmount\r\n  );\r\n  event HirerReleased(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\r\n  event AddFeesToCoinSparrowPool(bytes32 _jobHash, uint256 _value);\r\n  event ContractorReleased(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\r\n  event HirerLastResortRefund(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\r\n  event WithdrawFeesFromCoinSparrowPool(address _whoCalled, address _to, uint256 _amount);\r\n  event LogFallbackFunctionCalled(address _from, uint256 _amount);\r\n\r\n\r\n  /**\r\n   * ----------\r\n   * STRUCTURES\r\n   * ----------\r\n   */\r\n\r\n  /**\r\n   * @dev Structure to hold live Escrow data - current status, times etc.\r\n   */\r\n  struct JobEscrow {\r\n    // Set so we know the job has already been created. Set when job created in createJobEscrow()\r\n    bool exists;\r\n    // The timestamp after which the hirer can cancel the task if the contractor has not yet flagged as job started.\r\n    // Set in createJobEscrow(). If the Contractor has not called jobStarted() within this time, then the hirer\r\n    // can call hirerCancel() to get a full refund (minus gas fees)\r\n    uint32 hirerCanCancelAfter;\r\n    //Job's current status (see STATUS_JOB_* constants above). Updated in multiple functions\r\n    uint8 status;\r\n    //timestamp for job completion. Set when jobCompleted() is called.\r\n    uint32 jobCompleteDate;\r\n    //num agreed seconds it will take to complete the job, once flagged as STATUS_JOB_STARTED. Set in createJobEscrow()\r\n    uint32 secondsToComplete;\r\n    //timestamp calculated for agreed completion date. Set when jobStarted() is called.\r\n    uint32 agreedCompletionDate;\r\n  }\r\n\r\n  /**\r\n   * ------------------\r\n   * CONTRACT VARIABLES\r\n   * ------------------\r\n   */\r\n\r\n\r\n  //Total Wei currently held in Escrow\r\n  uint256 private totalInEscrow;\r\n  //Amount of Wei available to CoinSparrow to withdraw\r\n  uint256 private feesAvailableForWithdraw;\r\n\r\n  /*\r\n   * Set max limit for how much (in wei) contract will accept. Can be modified by owner using setMaxSend()\r\n   * This ensures that arbitrarily large amounts of ETH can't be sent.\r\n   * Front end will check this value before processing new jobs\r\n   */\r\n  uint256 private MAX_SEND;\r\n\r\n  /*\r\n   * Mapping of active jobs. Key is a hash of the job data:\r\n   * JobEscrow = keccak256(_jobId,_hirer,_contractor, _value, _fee)\r\n   * Once job is complete, and refunds released, the\r\n   * mapping for that job is deleted to conserve space.\r\n   */\r\n  mapping(bytes32 => JobEscrow) private jobEscrows;\r\n\r\n  /*\r\n   * mapping of Hirer's funds in Escrow for each job.\r\n   * This is referenced when any ETH transactions occur\r\n   */\r\n  mapping(address => mapping(bytes32 => uint256)) private hirerEscrowMap;\r\n\r\n  /**\r\n   * ---------\r\n   * MODIFIERS\r\n   * ---------\r\n   */\r\n\r\n  /**\r\n   * @dev modifier to ensure only the Hirer can execute\r\n   * @param _hirer Address of the hirer to check against msg.sender\r\n   */\r\n\r\n  modifier onlyHirer(address _hirer) {\r\n    require(msg.sender == _hirer);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to ensure only the Contractor can execute\r\n   * @param _contractor Address of the contractor to check against msg.sender\r\n   */\r\n\r\n  modifier onlyContractor(address _contractor) {\r\n    require(msg.sender == _contractor);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to ensure only the Contractor can execute\r\n   * @param _contractor Address of the contractor to check against msg.sender\r\n   */\r\n\r\n  modifier onlyHirerOrContractor(address _hirer, address _contractor) {\r\n    require(msg.sender == _hirer || msg.sender == _contractor);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * ----------------------\r\n   * CONTRACT FUNCTIONALITY\r\n   * ----------------------\r\n   */\r\n\r\n  /**\r\n   * @dev Constructor function for the contract\r\n   * @param _maxSend Maximum Wei the contract will accept in a transaction\r\n   */\r\n\r\n  constructor(uint256 _maxSend) public {\r\n    require(_maxSend > 0);\r\n    //a bit of protection. Set a limit, so users can't send stupid amounts of ETH\r\n    MAX_SEND = _maxSend;\r\n  }\r\n\r\n  /**\r\n   * @dev fallback function for the contract. Log event so ETH can be tracked and returned\r\n   */\r\n\r\n  function() payable {\r\n    //Log who sent, and how much so it can be returned\r\n    emit LogFallbackFunctionCalled(msg.sender, msg.value);\r\n  }\r\n\r\n  /**\r\n   * @dev Create a new escrow and add it to the `jobEscrows` mapping.\r\n   * Also updates/creates a reference to the job, and amount in Escrow for the job in hirerEscrowMap\r\n   * jobHash is created by hashing _jobId, _seller, _buyer, _value and _fee params.\r\n   * These params must be supplied on future contract calls.\r\n   * A hash of the job parameters (_jobId, _hirer, _contractor, _value, _fee) is created and used\r\n   * to access job data held in the contract. All functions that interact with a job in Escrow\r\n   * require these parameters.\r\n   * Pausable - only runs whenNotPaused. Can pause to prevent taking any more\r\n   *            ETH if there is a problem with the Smart Contract.\r\n   *            Parties can still access/transfer their existing ETH held in Escrow, complete jobs etc.\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @param _jobStartedWindowInSeconds time within which the contractor must flag as job started\r\n   *                                   if job hasn't started AFTER this time, hirer can cancel contract.\r\n   *                                   Hirer cannot cancel contract before this time.\r\n   * @param _secondsToComplete agreed time to complete job once it's flagged as STATUS_JOB_STARTED\r\n   */\r\n  function createJobEscrow(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee,\r\n    uint32 _jobStartedWindowInSeconds,\r\n    uint32 _secondsToComplete\r\n  ) payable external whenNotPaused onlyHirer(_hirer)\r\n  {\r\n\r\n    // Check sent eth against _value and also make sure is not 0\r\n    require(msg.value == _value && msg.value > 0);\r\n\r\n    //CoinSparrow's Fee should be less than the Job Value, because anything else would be daft.\r\n    require(_fee < _value);\r\n\r\n    //Check the amount sent is below the acceptable threshold\r\n    require(msg.value <= MAX_SEND);\r\n\r\n    //needs to be more than 0 seconds\r\n    require(_jobStartedWindowInSeconds > 0);\r\n\r\n    //needs to be more than 0 seconds\r\n    require(_secondsToComplete > 0);\r\n\r\n    //generate the job hash. Used to reference the job in all future function calls/transactions.\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //Check that the job does not already exist.\r\n    require(!jobEscrows[jobHash].exists);\r\n\r\n    //create the job and store it in the mapping\r\n    jobEscrows[jobHash] = JobEscrow(\r\n      true,\r\n      uint32(block.timestamp) + _jobStartedWindowInSeconds,\r\n      STATUS_JOB_CREATED,\r\n      0,\r\n      _secondsToComplete,\r\n      0);\r\n\r\n    //update total held in escrow\r\n    totalInEscrow = totalInEscrow.add(msg.value);\r\n\r\n    //Update hirer's job => value mapping\r\n    hirerEscrowMap[msg.sender][jobHash] = msg.value;\r\n\r\n    //Let the world know.\r\n    emit JobCreated(jobHash, msg.sender, msg.value);\r\n  }\r\n\r\n  /**\r\n   * -----------------------\r\n   * RELEASE FUNDS FUNCTIONS\r\n   * -----------------------\r\n   */\r\n\r\n  /**\r\n   * @dev Release funds to contractor. Can only be called by Hirer. Can be called at any time as long as the\r\n   * job exists in the contract (for example, two parties may have agreed job is complete external to the\r\n   * CoinSparrow website). Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function hirerReleaseFunds(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyHirer(_hirer)\r\n  {\r\n\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n\r\n    //check hirer has funds in the Smart Contract assigned to this job\r\n    require(hirerEscrowMap[msg.sender][jobHash] > 0);\r\n\r\n    //get the value from the stored hirer => job => value mapping\r\n    uint256 jobValue = hirerEscrowMap[msg.sender][jobHash];\r\n\r\n    //Check values in contract and sent are valid\r\n    require(jobValue > 0 && jobValue == _value);\r\n\r\n    //check fee amount is valid\r\n    require(jobValue >= jobValue.sub(_fee));\r\n\r\n    //check there is enough in escrow\r\n    require(totalInEscrow >= jobValue && totalInEscrow > 0);\r\n\r\n     //Log event\r\n    emit HirerReleased(\r\n      jobHash,\r\n      msg.sender,\r\n      _contractor,\r\n      jobValue);\r\n\r\n     //Log event\r\n    emit AddFeesToCoinSparrowPool(jobHash, _fee);\r\n\r\n    //no longer required. Remove to save storage. Also prevents reentrancy\r\n    delete jobEscrows[jobHash];\r\n    //no longer required. Remove to save storage. Also prevents reentrancy\r\n    delete hirerEscrowMap[msg.sender][jobHash];\r\n\r\n    //add to CoinSparrow's fee pool\r\n    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\r\n\r\n    //update total in escrow\r\n    totalInEscrow = totalInEscrow.sub(jobValue);\r\n\r\n    //Finally, transfer the funds, minus CoinSparrow fees\r\n    _contractor.transfer(jobValue.sub(_fee));\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Release funds to contractor in the event that the Hirer is unresponsive after job has been flagged as complete.\r\n   * Can only be called by the contractor, and only 4 weeks after the job has been flagged as complete.\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function contractorReleaseFunds(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyContractor(_contractor)\r\n  {\r\n\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n\r\n    //check job is actually completed\r\n    require(jobEscrows[jobHash].status == STATUS_JOB_COMPLETED);\r\n    //can only self-release 4 weeks after completion\r\n    require(block.timestamp > jobEscrows[jobHash].jobCompleteDate + 4 weeks);\r\n\r\n    //get value for job\r\n    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\r\n\r\n    //Check values in contract and sent are valid\r\n    require(jobValue > 0 && jobValue == _value);\r\n\r\n    //check fee amount is valid\r\n    require(jobValue >= jobValue.sub(_fee));\r\n\r\n    //check there is enough in escrow\r\n    require(totalInEscrow >= jobValue && totalInEscrow > 0);\r\n\r\n    emit ContractorReleased(\r\n      jobHash,\r\n      _hirer,\r\n      _contractor,\r\n      jobValue); //Log event\r\n    emit AddFeesToCoinSparrowPool(jobHash, _fee);\r\n\r\n    delete jobEscrows[jobHash]; //no longer required. Remove to save storage.\r\n    delete  hirerEscrowMap[_hirer][jobHash]; //no longer required. Remove to save storage.\r\n\r\n    //add fees to coinsparrow pool\r\n    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\r\n\r\n    //update total in escrow\r\n    totalInEscrow = totalInEscrow.sub(jobValue);\r\n\r\n    //transfer funds to contractor, minus fees\r\n    _contractor.transfer(jobValue.sub(_fee));\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Can be called by the hirer to claim a full refund, if job has been started but contractor has not\r\n   * completed within 4 weeks after agreed completion date, and becomes unresponsive.\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function hirerLastResortRefund(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyHirer(_hirer)\r\n  {\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n    \r\n    //check job is started\r\n    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);\r\n    //can only self-refund 4 weeks after agreed completion date\r\n    require(block.timestamp > jobEscrows[jobHash].agreedCompletionDate + 4 weeks);\r\n\r\n    //get value for job\r\n    uint256 jobValue = hirerEscrowMap[msg.sender][jobHash];\r\n\r\n    //Check values in contract and sent are valid\r\n    require(jobValue > 0 && jobValue == _value);\r\n\r\n    //check fee amount is valid\r\n    require(jobValue >= jobValue.sub(_fee));\r\n\r\n    //check there is enough in escrow\r\n    require(totalInEscrow >= jobValue && totalInEscrow > 0);\r\n\r\n    emit HirerLastResortRefund(\r\n      jobHash,\r\n      _hirer,\r\n      _contractor,\r\n      jobValue); //Log event\r\n\r\n    delete jobEscrows[jobHash]; //no longer required. Remove to save storage.\r\n    delete  hirerEscrowMap[_hirer][jobHash]; //no longer required. Remove to save storage.\r\n\r\n    //update total in escrow\r\n    totalInEscrow = totalInEscrow.sub(jobValue);\r\n\r\n    //transfer funds to hirer\r\n    _hirer.transfer(jobValue);\r\n  }\r\n\r\n  /**\r\n   * ---------------------------\r\n   * UPDATE JOB STATUS FUNCTIONS\r\n   * ---------------------------\r\n   */\r\n\r\n  /**\r\n   * @dev Flags job started, and Stops the hirer from cancelling the job.\r\n   * Can only be called the contractor when job starts.\r\n   * Used to mark the job as started. After this point, hirer must request cancellation\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function jobStarted(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyContractor(_contractor)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n    //check job status.\r\n    require(jobEscrows[jobHash].status == STATUS_JOB_CREATED);\r\n    jobEscrows[jobHash].status = STATUS_JOB_STARTED; //set status\r\n    jobEscrows[jobHash].hirerCanCancelAfter = 0;\r\n    jobEscrows[jobHash].agreedCompletionDate = uint32(block.timestamp) + jobEscrows[jobHash].secondsToComplete;\r\n    emit ContractorStartedJob(jobHash, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Flags job completed to inform hirer. Also sets flag to allow contractor to get their funds 4 weeks after\r\n   * completion in the event that the hirer is unresponsive and doesn't release the funds.\r\n   * Can only be called the contractor when job complete.\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function jobCompleted(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyContractor(_contractor)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    require(jobEscrows[jobHash].exists); //check the job exists in the contract\r\n    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED); //check job status.\r\n    jobEscrows[jobHash].status = STATUS_JOB_COMPLETED;\r\n    jobEscrows[jobHash].jobCompleteDate = uint32(block.timestamp);\r\n    emit ContractorCompletedJob(jobHash, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * --------------------------\r\n   * JOB CANCELLATION FUNCTIONS\r\n   * --------------------------\r\n   */\r\n\r\n  /**\r\n   * @dev Cancels the job and returns the ether to the hirer.\r\n   * Can only be called the contractor. Can be called at any time during the process\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function contractorCancel(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyContractor(_contractor)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n\r\n    //Check values in contract and sent are valid\r\n    require(jobValue > 0 && jobValue == _value);\r\n\r\n    //check fee amount is valid\r\n    require(jobValue >= jobValue.sub(_fee));\r\n\r\n    //check there is enough in escrow\r\n    require(totalInEscrow >= jobValue && totalInEscrow > 0);\r\n\r\n    delete jobEscrows[jobHash];\r\n    delete  hirerEscrowMap[_hirer][jobHash];\r\n    emit CancelledByContractor(jobHash, msg.sender);\r\n\r\n    totalInEscrow = totalInEscrow.sub(jobValue);\r\n\r\n    _hirer.transfer(jobValue);\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels the job and returns the ether to the hirer.\r\n   * Can only be called the hirer.\r\n   * Can only be called if the job start window was missed by the contractor\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function hirerCancel(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyHirer(_hirer)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n\r\n    require(jobEscrows[jobHash].hirerCanCancelAfter > 0);\r\n    require(jobEscrows[jobHash].status == STATUS_JOB_CREATED);\r\n    require(jobEscrows[jobHash].hirerCanCancelAfter < block.timestamp);\r\n\r\n    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\r\n\r\n    //Check values in contract and sent are valid\r\n    require(jobValue > 0 && jobValue == _value);\r\n\r\n    //check fee amount is valid\r\n    require(jobValue >= jobValue.sub(_fee));\r\n\r\n    //check there is enough in escrow\r\n    require(totalInEscrow >= jobValue && totalInEscrow > 0);\r\n\r\n    delete jobEscrows[jobHash];\r\n    delete  hirerEscrowMap[msg.sender][jobHash];\r\n    emit CancelledByHirer(jobHash, msg.sender);\r\n\r\n    totalInEscrow = totalInEscrow.sub(jobValue);\r\n\r\n    _hirer.transfer(jobValue);\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the hirer or contractor to request mutual cancellation once job has started\r\n   * Can only be called when status = STATUS_JOB_STARTED\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function requestMutualJobCancellation(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyHirerOrContractor(_hirer, _contractor)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);\r\n\r\n    if (msg.sender == _hirer) {\r\n      jobEscrows[jobHash].status = STATUS_HIRER_REQUEST_CANCEL;\r\n      emit HirerRequestedCancel(jobHash, msg.sender);\r\n    }\r\n    if (msg.sender == _contractor) {\r\n      jobEscrows[jobHash].status = STATUS_CONTRACTOR_REQUEST_CANCEL;\r\n      emit ContractorRequestedCancel(jobHash, msg.sender);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Called when both hirer and contractor have agreed on cancellation conditions, and amount each will receive\r\n   * can be called by hirer or contractor once % amount has been signed by both parties.\r\n   * Both parties sign a hash of the % agreed upon. The signatures of both parties must be sent and verified\r\n   * before the transaction is processed, to ensure that the % processed is valid.\r\n   * can be called at any time\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @param _contractorPercent percentage the contractor will be paid\r\n   * @param _hirerMsgSig Signed message from hiring party agreeing on _contractorPercent\r\n   * @param _contractorMsgSig Signed message from contractor agreeing on _contractorPercent\r\n   */\r\n  function processMutuallyAgreedJobCancellation(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee,\r\n    uint8 _contractorPercent,\r\n    bytes _hirerMsgSig,\r\n    bytes _contractorMsgSig\r\n  ) external\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n\r\n    require(msg.sender == _hirer || msg.sender == _contractor);\r\n    require(_contractorPercent <= 100 && _contractorPercent >= 0);\r\n\r\n    //Checks the signature of both parties to ensure % is correct.\r\n    //Attempts to prevent the party calling the function from modifying the pre-agreed %\r\n    require(\r\n      checkRefundSignature(_contractorPercent,_hirerMsgSig,_hirer)&&\r\n      checkRefundSignature(_contractorPercent,_contractorMsgSig,_contractor));\r\n\r\n    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\r\n\r\n    //Check values in contract and sent are valid\r\n    require(jobValue > 0 && jobValue == _value);\r\n\r\n    //check fee amount is valid\r\n    require(jobValue >= jobValue.sub(_fee));\r\n\r\n    //check there is enough in escrow\r\n    require(totalInEscrow >= jobValue && totalInEscrow > 0);\r\n\r\n    totalInEscrow = totalInEscrow.sub(jobValue);\r\n    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\r\n\r\n    delete jobEscrows[jobHash];\r\n    delete  hirerEscrowMap[_hirer][jobHash];\r\n\r\n    uint256 contractorAmount = jobValue.sub(_fee).mul(_contractorPercent).div(100);\r\n    uint256 hirerAmount = jobValue.sub(_fee).mul(100 - _contractorPercent).div(100);\r\n\r\n    emit MutuallyAgreedCancellation(\r\n      jobHash,\r\n      msg.sender,\r\n      hirerAmount,\r\n      contractorAmount);\r\n\r\n    emit AddFeesToCoinSparrowPool(jobHash, _fee);\r\n\r\n    if (contractorAmount > 0) {\r\n      _contractor.transfer(contractorAmount);\r\n    }\r\n    if (hirerAmount > 0) {\r\n      _hirer.transfer(hirerAmount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * -------------------------\r\n   * DISPUTE RELATED FUNCTIONS\r\n   * -------------------------\r\n   */\r\n\r\n  /**\r\n   * @dev Called by hirer or contractor to raise a dispute during started, completed or canellation request statuses\r\n   * Once called, funds are locked until arbitrator can resolve the dispute. Assigned arbitrator\r\n   * will review all information relating to the job, and decide on a fair course of action.\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   */\r\n  function requestDispute(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  ) external onlyHirerOrContractor(_hirer, _contractor)\r\n  {\r\n\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n    require(\r\n      jobEscrows[jobHash].status == STATUS_JOB_STARTED||\r\n      jobEscrows[jobHash].status == STATUS_JOB_COMPLETED||\r\n      jobEscrows[jobHash].status == STATUS_HIRER_REQUEST_CANCEL||\r\n      jobEscrows[jobHash].status == STATUS_CONTRACTOR_REQUEST_CANCEL);\r\n\r\n    jobEscrows[jobHash].status = STATUS_JOB_IN_DISPUTE;\r\n\r\n    emit DisputeRequested(jobHash, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the arbitrator to resolve a dispute\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @param _contractorPercent percentage the contractor will receive\r\n   */\r\n\r\n  function resolveDispute(\r\n\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee,\r\n    uint8 _contractorPercent\r\n  ) external onlyArbitrator\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    //check the job exists in the contract\r\n    require(jobEscrows[jobHash].exists);\r\n\r\n    require(jobEscrows[jobHash].status == STATUS_JOB_IN_DISPUTE);\r\n    require(_contractorPercent <= 100);\r\n\r\n    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\r\n\r\n    //Check values in contract and sent are valid\r\n    require(jobValue > 0 && jobValue == _value);\r\n\r\n    //check fee amount is valid\r\n    require(jobValue >= jobValue.sub(_fee));\r\n\r\n    //check there is enough in escrow\r\n    require(totalInEscrow >= jobValue && totalInEscrow > 0);\r\n\r\n    totalInEscrow = totalInEscrow.sub(jobValue);\r\n    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\r\n    // Add the the pot for localethereum to withdraw\r\n\r\n    delete jobEscrows[jobHash];\r\n    delete  hirerEscrowMap[_hirer][jobHash];\r\n\r\n    uint256 contractorAmount = jobValue.sub(_fee).mul(_contractorPercent).div(100);\r\n    uint256 hirerAmount = jobValue.sub(_fee).mul(100 - _contractorPercent).div(100);\r\n    emit DisputeResolved(\r\n      jobHash,\r\n      msg.sender,\r\n      hirerAmount,\r\n      contractorAmount);\r\n\r\n    emit AddFeesToCoinSparrowPool(jobHash, _fee);\r\n\r\n    _contractor.transfer(contractorAmount);\r\n    _hirer.transfer(hirerAmount);\r\n\r\n  }\r\n\r\n  /**\r\n   * ------------------------\r\n   * ADMINISTRATIVE FUNCTIONS\r\n   * ------------------------\r\n   */\r\n\r\n  /**\r\n   * @dev Allows owner to transfer funds from the collected fees pool to an approved wallet address\r\n   * @param _to receiver wallet address\r\n   * @param _amount amount to withdraw and transfer\r\n   */\r\n  function withdrawFees(address _to, uint256 _amount) onlyOwner onlyApprovedWallet(_to) external {\r\n    /**\r\n     * Withdraw fees collected by the contract. Only the owner can call this.\r\n     * Can only be sent to an approved wallet address\r\n     */\r\n    require(_amount > 0);\r\n    require(_amount <= feesAvailableForWithdraw && feesAvailableForWithdraw > 0);\r\n\r\n    feesAvailableForWithdraw = feesAvailableForWithdraw.sub(_amount);\r\n\r\n    emit WithdrawFeesFromCoinSparrowPool(msg.sender,_to, _amount);\r\n\r\n    _to.transfer(_amount);\r\n  }\r\n\r\n  /**\r\n   * @dev returns how much has been collected in fees, and how much is available to withdraw\r\n   * @return feesAvailableForWithdraw amount available for CoinSparrow to withdraw\r\n   */\r\n\r\n  function howManyFees() external view returns (uint256) {\r\n    return feesAvailableForWithdraw;\r\n  }\r\n\r\n  /**\r\n   * @dev returns how much is currently held in escrow\r\n   * @return totalInEscrow amount currently held in escrow\r\n   */\r\n\r\n  function howMuchInEscrow() external view returns (uint256) {\r\n    return totalInEscrow;\r\n  }\r\n\r\n  /**\r\n   * @dev modify the maximum amount of ETH the contract will allow in a transaction (when creating a new job)\r\n   * @param _maxSend amount in Wei\r\n   */\r\n\r\n  function setMaxSend(uint256 _maxSend) onlyOwner external {\r\n    require(_maxSend > 0);\r\n    MAX_SEND = _maxSend;\r\n  }\r\n\r\n  /**\r\n   * @dev return the current maximum amount the contract will allow in a transaction\r\n   * @return MAX_SEND current maximum value\r\n   */\r\n\r\n  function getMaxSend() external view returns (uint256) {\r\n    return MAX_SEND;\r\n  }\r\n\r\n  /**\r\n   * @dev returns THIS contract instance's version\r\n   * @return COINSPARROW_CONTRACT_VERSION version number of THIS instance of the contract\r\n   */\r\n\r\n  function getContractVersion() external pure returns(uint8) {\r\n    return COINSPARROW_CONTRACT_VERSION;\r\n  }\r\n\r\n  /**\r\n   * -------------------------\r\n   * JOB INFORMATION FUNCTIONS\r\n   * -------------------------\r\n   */\r\n\r\n  /**\r\n   * @dev returns the status of the requested job\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @return status job's current status\r\n   */\r\n\r\n  function getJobStatus(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee) external view returns (uint8)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    uint8 status = STATUS_JOB_NOT_EXIST;\r\n\r\n    if (jobEscrows[jobHash].exists) {\r\n      status = jobEscrows[jobHash].status;\r\n    }\r\n    return status;\r\n  }\r\n\r\n  /**\r\n   * @dev returns the date after which the Hirer can cancel the job\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @return hirerCanCancelAfter timestamp for date after which the hirer can cancel\r\n   */\r\n\r\n  function getJobCanCancelAfter(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee) external view returns (uint32)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    uint32 hirerCanCancelAfter = 0;\r\n\r\n    if (jobEscrows[jobHash].exists) {\r\n      hirerCanCancelAfter = jobEscrows[jobHash].hirerCanCancelAfter;\r\n    }\r\n    return hirerCanCancelAfter;\r\n  }\r\n\r\n  /**\r\n   * @dev returns the number of seconds for job completion\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @return secondsToComplete number of seconds to complete job\r\n   */\r\n\r\n  function getSecondsToComplete(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee) external view returns (uint32)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    uint32 secondsToComplete = 0;\r\n\r\n    if (jobEscrows[jobHash].exists) {\r\n      secondsToComplete = jobEscrows[jobHash].secondsToComplete;\r\n    }\r\n    return secondsToComplete;\r\n  }\r\n\r\n  /**\r\n   * @dev returns the agreed completion date of the requested job\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @return agreedCompletionDate timestamp for agreed completion date\r\n   */\r\n\r\n  function getAgreedCompletionDate(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee) external view returns (uint32)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    uint32 agreedCompletionDate = 0;\r\n\r\n    if (jobEscrows[jobHash].exists) {\r\n      agreedCompletionDate = jobEscrows[jobHash].agreedCompletionDate;\r\n    }\r\n    return agreedCompletionDate;\r\n  }\r\n\r\n  /**\r\n   * @dev returns the actual completion date of the job of the requested job\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @return jobCompleteDate timestamp for actual completion date\r\n   */\r\n\r\n  function getActualCompletionDate(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee) external view returns (uint32)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    uint32 jobCompleteDate = 0;\r\n\r\n    if (jobEscrows[jobHash].exists) {\r\n      jobCompleteDate = jobEscrows[jobHash].jobCompleteDate;\r\n    }\r\n    return jobCompleteDate;\r\n  }\r\n\r\n  /**\r\n   * @dev returns the value for the requested job\r\n   * Following parameters are used to regenerate the jobHash:\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @return amount job's value\r\n   */\r\n\r\n  function getJobValue(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee) external view returns(uint256)\r\n  {\r\n    //get job Hash\r\n    bytes32 jobHash = getJobHash(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee);\r\n\r\n    uint256 amount = 0;\r\n    if (jobEscrows[jobHash].exists) {\r\n      amount = hirerEscrowMap[_hirer][jobHash];\r\n    }\r\n    return amount;\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function to pre-validate mutual cancellation signatures. Used by front-end app\r\n   * to let each party know that the other has signed off the agreed %\r\n   * @param _contractorPercent percentage agreed upon\r\n   * @param _sigMsg signed message to be validated\r\n   * @param _signer wallet address of the message signer to validate against\r\n   * @return bool whether or not the signature is valid\r\n   */\r\n  function validateRefundSignature(\r\n    uint8 _contractorPercent,\r\n    bytes _sigMsg,\r\n    address _signer) external pure returns(bool)\r\n  {\r\n\r\n    return checkRefundSignature(_contractorPercent,_sigMsg,_signer);\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Executes the actual signature verification.\r\n   * @param _contractorPercent percentage agreed upon\r\n   * @param _sigMsg signed message to be validated\r\n   * @param _signer wallet address of the message signer to validate against\r\n   * @return bool whether or not the signature is valid\r\n   */\r\n  function checkRefundSignature(\r\n    uint8 _contractorPercent,\r\n    bytes _sigMsg,\r\n    address _signer) private pure returns(bool)\r\n  {\r\n    bytes32 percHash = keccak256(abi.encodePacked(_contractorPercent));\r\n    bytes32 msgHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\",percHash));\r\n\r\n    address addr = ECRecovery.recover(msgHash,_sigMsg);\r\n    return addr == _signer;\r\n  }\r\n\r\n  /**\r\n   * @dev Generates the sha256 jobHash based on job parameters. Used in several functions\r\n   * @param _jobId The unique ID of the job, from the CoinSparrow database\r\n   * @param _hirer The wallet address of the hiring (buying) party\r\n   * @param _contractor The wallet address of the contractor (selling) party\r\n   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\r\n   * @param _fee CoinSparrow fee for this job. Pre-calculated\r\n   * @return bytes32 the calculated jobHash value\r\n   */\r\n  function getJobHash(\r\n    bytes16 _jobId,\r\n    address _hirer,\r\n    address _contractor,\r\n    uint256 _value,\r\n    uint256 _fee\r\n  )  private pure returns(bytes32)\r\n  {\r\n    return keccak256(abi.encodePacked(\r\n      _jobId,\r\n      _hirer,\r\n      _contractor,\r\n      _value,\r\n      _fee));\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newArbitrator\",\"type\":\"address\"}],\"name\":\"addArbitrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxSend\",\"type\":\"uint256\"}],\"name\":\"setMaxSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"jobCompleted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"getActualCompletionDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"getJobCanCancelAfter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxSend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"deleteApprovedWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"requestDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"jobStarted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"hirerCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"getJobStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"contractorCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"walletCheck\",\"type\":\"address\"}],\"name\":\"isApprovedWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"hirerLastResortRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howMuchInEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"changePrimaryApprovedWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"hirerReleaseFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_contractorPercent\",\"type\":\"uint8\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"arbitratorCheck\",\"type\":\"address\"}],\"name\":\"isArbitrator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"getJobValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"getSecondsToComplete\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractorPercent\",\"type\":\"uint8\"},{\"name\":\"_sigMsg\",\"type\":\"bytes\"},{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"validateRefundSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"changePrimaryArbitrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"requestMutualJobCancellation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"getAgreedCompletionDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howManyFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_jobStartedWindowInSeconds\",\"type\":\"uint32\"},{\"name\":\"_secondsToComplete\",\"type\":\"uint32\"}],\"name\":\"createJobEscrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_contractorPercent\",\"type\":\"uint8\"},{\"name\":\"_hirerMsgSig\",\"type\":\"bytes\"},{\"name\":\"_contractorMsgSig\",\"type\":\"bytes\"}],\"name\":\"processMutuallyAgreedJobCancellation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"addApprovedWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arbitrator\",\"type\":\"address\"}],\"name\":\"deleteArbitrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"name\":\"_hirer\",\"type\":\"address\"},{\"name\":\"_contractor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"contractorReleaseFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_maxSend\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"JobCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"ContractorStartedJob\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"ContractorCompletedJob\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"HirerRequestedCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"ContractorRequestedCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"CancelledByHirer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"CancelledByContractor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_hirerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_contractorAmount\",\"type\":\"uint256\"}],\"name\":\"MutuallyAgreedCancellation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"DisputeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_hirerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_contractorAmount\",\"type\":\"uint256\"}],\"name\":\"DisputeResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_hirer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contractor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"HirerReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"AddFeesToCoinSparrowPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_hirer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contractor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ContractorReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_jobHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_hirer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_contractor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"HirerLastResortRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_whoCalled\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFeesFromCoinSparrowPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LogFallbackFunctionCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"WalletApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"removedAddress\",\"type\":\"address\"}],\"name\":\"WalletRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newPrimaryWallet\",\"type\":\"address\"}],\"name\":\"ChangePrimaryApprovedWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newArbitrator\",\"type\":\"address\"}],\"name\":\"ArbitratorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newArbitrator\",\"type\":\"address\"}],\"name\":\"ArbitratorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newPrimaryWallet\",\"type\":\"address\"}],\"name\":\"ChangePrimaryArbitratorWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CoinSparrow","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000056bc75e2d63100000","Library":"","SwarmSource":"bzzr://0e4536ca02da9ba3378a0ff9ff6f14b60deb9c4db07e6d3f96dec27fcb53ec90"}]}