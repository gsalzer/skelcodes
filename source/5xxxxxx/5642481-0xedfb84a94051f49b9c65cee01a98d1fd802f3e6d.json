{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.20;\r\n\r\n/*\r\n* Team AppX presents - Moon, Inc. | Competitive Ethereum Idle Pyramid\r\n* \r\n* - You can buy workers with ETH to increase your cookies production.\r\n* - You can sell your cookies and claim a proportion of the cookie fund.\r\n* - You cannot sell cookies within the first hour of a new production unit launch.\r\n* - The selling price of a cookie depends on the Cookie Fund and the total cookies supply, the formula is:\r\n*   CookiePrice = CookieFund / TotalCookieSupply * Multiplier\r\n*   * Where Multiplier is a number from 0.5 to 1, which starts with 0.5 after a new production unit started, and reaches maximum value (1) after 5 days.\r\n* - You can sell your workers at any time like normal tokens\r\n*\r\n*/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n}\r\n\r\n\r\ncontract ProductionUnitToken {\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    /// @dev Only people with tokens\r\n    modifier onlyBagholders {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only people with profits\r\n    modifier onlyStronghands {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy,\r\n        uint timestamp,\r\n        uint256 price\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned,\r\n        uint timestamp,\r\n        uint256 price\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n\r\n    // ERC20\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n\r\n\r\n    /*=====================================\r\n    =            DEPENDENCIES             =\r\n    =====================================*/\r\n\r\n    // MoonInc contract\r\n    MoonInc public moonIncContract;\r\n\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n\r\n    string public name = \"Production Unit | Moon, Inc.\";\r\n    string public symbol = \"ProductionUnit\";\r\n    uint8 constant public decimals = 18;\r\n\r\n    /// @dev dividends for token purchase\r\n    uint8 public entryFee_;\r\n\r\n    /// @dev dividends for token transfer\r\n    uint8 public transferFee_;\r\n\r\n    /// @dev dividends for token selling\r\n    uint8 public exitFee_;\r\n\r\n    /// @dev 20% of entryFee_ is given to referrer\r\n    uint8 constant internal refferalFee_ = 20;\r\n\r\n    uint256 public tokenPriceInitial_; // original is 0.0000001 ether\r\n    uint256 public tokenPriceIncremental_; // original is 0.00000001 ether\r\n    uint256 constant internal magnitude = 2 ** 64;\r\n\r\n    /// @dev proof of stake (10 tokens)\r\n    uint256 public stakingRequirement = 10e18;\r\n\r\n    // cookie production multiplier (how many cookies do 1 token make per second)\r\n    uint256 public cookieProductionMultiplier;\r\n\r\n    // auto start timer\r\n    uint256 public startTime;\r\n\r\n    // Maximum amount of dev one time pre-mine\r\n    mapping(address => uint) public ambassadorsMaxPremine;\r\n    mapping(address => bool) public ambassadorsPremined;\r\n    mapping(address => address) public ambassadorsPrerequisite;\r\n\r\n\r\n   /*=================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal referralBalance_;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    uint256 internal tokenSupply_;\r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS           =\r\n    =======================================*/\r\n\r\n    /// @dev Set the MoonInc contract address to notify when token amount changes\r\n    function ProductionUnitToken(\r\n        address _moonIncContractAddress, uint8 _entryFee, uint8 _transferFee, uint8 _exitFee,\r\n        uint _tokenPriceInitial, uint _tokenPriceIncremental, uint _cookieProductionMultiplier, uint _startTime\r\n    ) public {\r\n        moonIncContract = MoonInc(_moonIncContractAddress);\r\n        entryFee_ = _entryFee;\r\n        transferFee_ = _transferFee;\r\n        exitFee_ = _exitFee;\r\n        tokenPriceInitial_ = _tokenPriceInitial;\r\n        tokenPriceIncremental_ = _tokenPriceIncremental;\r\n        cookieProductionMultiplier = _cookieProductionMultiplier;\r\n        startTime = _startTime;\r\n\r\n        // Set ambassadors' maximum one time pre-mine amount (Total 1.29 ETH pre-mine).\r\n        uint BETA_DIVISOR = 1000; // TODO: remove this in main launch contract\r\n\r\n        // MA\r\n        ambassadorsMaxPremine[0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD] = 0.28 ether / BETA_DIVISOR;\r\n        ambassadorsPremined[address(0)] = true; // first ambassador don't need prerequisite\r\n\r\n        // BL\r\n        ambassadorsMaxPremine[0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f] = 0.28 ether / BETA_DIVISOR;\r\n        ambassadorsPrerequisite[0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f] = 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD;\r\n\r\n        // PH\r\n        ambassadorsMaxPremine[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = 0.28 ether / BETA_DIVISOR;\r\n        ambassadorsPrerequisite[0x183feBd8828a9ac6c70C0e27FbF441b93004fC05] = 0xc951D3463EbBa4e9Ec8dDfe1f42bc5895C46eC8f;\r\n\r\n        // RS\r\n        ambassadorsMaxPremine[0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d] = 0.09 ether / BETA_DIVISOR;\r\n        ambassadorsPrerequisite[0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d] = 0x183feBd8828a9ac6c70C0e27FbF441b93004fC05;\r\n\r\n        // LN\r\n        ambassadorsMaxPremine[0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05] = 0.09 ether / BETA_DIVISOR;\r\n        ambassadorsPrerequisite[0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05] = 0x1fbc2Ca750E003A56d706C595b49a0A430EBA92d;\r\n\r\n        // LE\r\n        ambassadorsMaxPremine[0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41] = 0.09 ether / BETA_DIVISOR;\r\n        ambassadorsPrerequisite[0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41] = 0x41F29054E7c0BC59a8AF10f3a6e7C0E53B334e05;\r\n\r\n        // MI\r\n        ambassadorsMaxPremine[0x0a3239799518E7F7F339867A4739282014b97Dcf] = 0.09 ether / BETA_DIVISOR;\r\n        ambassadorsPrerequisite[0x0a3239799518E7F7F339867A4739282014b97Dcf] = 0x15Fda64fCdbcA27a60Aa8c6ca882Aa3e1DE4Ea41;\r\n\r\n        // PO\r\n        ambassadorsMaxPremine[0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87] = 0.09 ether / BETA_DIVISOR;\r\n        ambassadorsPrerequisite[0x31529d5Ab0D299D9b0594B7f2ef3515Be668AA87] = 0x0a3239799518E7F7F339867A4739282014b97Dcf;\r\n    }\r\n\r\n    /// @dev Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\r\n    function buy(address _referredBy) public payable returns (uint256) {\r\n        purchaseTokens(msg.value, _referredBy);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to handle ethereum that was send straight to the contract\r\n     *  Unfortunately we cannot use a referral address this way.\r\n     */\r\n    function() payable public {\r\n        purchaseTokens(msg.value, 0x0);\r\n    }\r\n\r\n    /// @dev Converts all of caller's dividends to tokens.\r\n    function reinvest() onlyStronghands public {\r\n        // fetch dividends\r\n        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\r\n\r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude);\r\n\r\n        // retrieve ref. bonus\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(_dividends, 0x0);\r\n\r\n        // fire event\r\n        onReinvestment(_customerAddress, _dividends, _tokens);\r\n    }\r\n\r\n    /// @dev Alias of sell() and withdraw().\r\n    function exit() public {\r\n        // get token count for caller & sell them all\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n        if (_tokens > 0) sell(_tokens);\r\n\r\n        // lambo delivery service\r\n        withdraw();\r\n    }\r\n\r\n    /// @dev Withdraws all of the callers earnings.\r\n    function withdraw() onlyStronghands public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends(false); // get ref. bonus later in the code\r\n\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n        // add ref. bonus\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n\r\n        // lambo delivery service\r\n        _customerAddress.transfer(_dividends);\r\n\r\n        // fire event\r\n        onWithdraw(_customerAddress, _dividends);\r\n    }\r\n\r\n    /// @dev Liquifies tokens to ethereum.\r\n    function sell(uint256 _amountOfTokens) onlyBagholders public {\r\n        require(now >= startTime);\r\n\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        // russian hackers BTFO\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n\r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (_taxedEthereum * magnitude);\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n        // Tell MoonInc contract for tokens amount change, and transfer dividends.\r\n        moonIncContract.handleProductionDecrease.value(_dividends)(_customerAddress, _tokens * cookieProductionMultiplier);\r\n\r\n        // fire event\r\n        onTokenSell(_customerAddress, _tokens, _taxedEthereum, now, buyPrice());\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from the caller to a new holder.\r\n     *  Remember, there's a fee here as well.\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders public returns (bool) {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested tokens\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        // withdraw all outstanding dividends first\r\n        if (myDividends(true) > 0) {\r\n            withdraw();\r\n        }\r\n\r\n        // liquify 10% of the tokens that are transfered\r\n        // these are dispersed to shareholders\r\n        uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\r\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\r\n        uint256 _dividends = tokensToEthereum_(_tokenFee);\r\n\r\n        // burn the fee tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\r\n\r\n        // Tell MoonInc contract for tokens amount change, and transfer dividends.\r\n        moonIncContract.handleProductionDecrease.value(_dividends)(_customerAddress, _amountOfTokens * cookieProductionMultiplier);\r\n        moonIncContract.handleProductionIncrease(_toAddress, _taxedTokens * cookieProductionMultiplier);\r\n\r\n        // fire event\r\n        Transfer(_customerAddress, _toAddress, _taxedTokens);\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =      HELPERS AND CALCULATORS        =\r\n    =====================================*/\r\n\r\n    function getSettings() public view returns (uint8, uint8, uint8, uint256, uint256, uint256, uint256) {\r\n        return (entryFee_, transferFee_, exitFee_, tokenPriceInitial_,\r\n            tokenPriceIncremental_, cookieProductionMultiplier, startTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Method to view the current Ethereum stored in the contract\r\n     *  Example: totalEthereumBalance()\r\n     */\r\n    function totalEthereumBalance() public view returns (uint256) {\r\n        return this.balance;\r\n    }\r\n\r\n    /// @dev Retrieve the total token supply.\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /// @dev Retrieve the tokens owned by the caller.\r\n    function myTokens() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the dividends owned by the caller.\r\n     *  If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\r\n     *  The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\r\n     *  But in the internal calculations, we want them separate.\r\n     */\r\n    function myDividends(bool _includeReferralBonus) public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /// @dev Retrieve the dividend balance of any single address.\r\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (-payoutsTo_[_customerAddress])) / magnitude;\r\n    }\r\n\r\n    /// @dev Return the sell price of 1 individual token.\r\n    function sellPrice() public view returns (uint256) {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\r\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n\r\n    /// @dev Return the buy price of 1 individual token.\r\n    function buyPrice() public view returns (uint256) {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, entryFee_), 100);\r\n            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\r\n\r\n            return _taxedEthereum;\r\n        }\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns (uint256) {\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereumToSpend, entryFee_), 100);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n    function calculateEthereumReceived(uint256 _tokensToSell) public view returns (uint256) {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethereum, exitFee_), 100);\r\n        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n        return _taxedEthereum;\r\n    }\r\n\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    /// @dev Internal function to actually purchase the tokens.\r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) internal returns (uint256) {\r\n        // Remove this on main launch\r\n        require(_incomingEthereum <= 1 finney);\r\n\r\n        require(\r\n            // auto start\r\n            now >= startTime ||\r\n            // ambassador pre-mine within 1 hour before startTime, sequences enforced\r\n            (now >= startTime - 1 hours && !ambassadorsPremined[msg.sender] && ambassadorsPremined[ambassadorsPrerequisite[msg.sender]] && _incomingEthereum <= ambassadorsMaxPremine[msg.sender]) ||\r\n            // ambassador pre-mine within 10 minutes before startTime, sequences not enforced\r\n            (now >= startTime - 10 minutes && !ambassadorsPremined[msg.sender] && _incomingEthereum <= ambassadorsMaxPremine[msg.sender])\r\n        );\r\n\r\n        if (now < startTime) {\r\n            ambassadorsPremined[msg.sender] = true;\r\n        }\r\n\r\n        // data setup\r\n        address _customerAddress = msg.sender;\r\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, entryFee_), 100);\r\n        uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, refferalFee_), 100);\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\r\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n\r\n        // no point in continuing execution if OP is a poorfag russian hacker\r\n        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\r\n        // (or hackers)\r\n        // and yes we know that the safemath function automatically rules out the \"greater then\" equasion.\r\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\r\n\r\n        // is the user referred by a masternode?\r\n        if (\r\n            // is this a referred purchase?\r\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\r\n\r\n            // no cheating!\r\n            _referredBy != _customerAddress &&\r\n\r\n            // does the referrer have at least X whole tokens?\r\n            // i.e is the referrer a godly chad masternode\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n        ) {\r\n            // wealth redistribution\r\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n        } else {\r\n            // no ref purchase\r\n            // add the referral bonus back to the global dividends cake\r\n            _dividends = SafeMath.add(_dividends, _referralBonus);\r\n        }\r\n\r\n        // add tokens to the pool\r\n        tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // Tell MoonInc contract for tokens amount change, and transfer dividends.\r\n        moonIncContract.handleProductionIncrease.value(_dividends)(_customerAddress, _amountOfTokens * cookieProductionMultiplier);\r\n\r\n        // fire event\r\n        onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy, now, buyPrice());\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate Token price based on an amount of incoming ethereum\r\n     *  It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     *  Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function ethereumToTokens_(uint256 _ethereum) internal view returns (uint256) {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n         (\r\n            (\r\n                // underflow attempts BTFO\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial ** 2)\r\n                            +\r\n                            (2 * (tokenPriceIncremental_ * 1e18) * (_ethereum * 1e18))\r\n                            +\r\n                            ((tokenPriceIncremental_ ** 2) * (tokenSupply_ ** 2))\r\n                            +\r\n                            (2 * tokenPriceIncremental_ * _tokenPriceInitial*tokenSupply_)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            ) / (tokenPriceIncremental_)\r\n        ) - (tokenSupply_);\r\n\r\n        return _tokensReceived;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate token sell value.\r\n     *  It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     *  Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function tokensToEthereum_(uint256 _tokens) internal view returns (uint256) {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n            // underflow attempts BTFO\r\n            SafeMath.sub(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\r\n                        ) - tokenPriceIncremental_\r\n                    ) * (tokens_ - 1e18)\r\n                ), (tokenPriceIncremental_ * ((tokens_ ** 2 - tokens_) / 1e18)) / 2\r\n            )\r\n        / 1e18);\r\n\r\n        return _etherReceived;\r\n    }\r\n\r\n    /// @dev This is where all your gas goes.\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = (x + 1) / 2;\r\n        y = x;\r\n\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\ncontract MoonInc {\r\n\r\n    string public constant name  = \"Cookie | Moon, Inc.\";\r\n    string public constant symbol = \"Cookie\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    // Total balances\r\n    uint256 public totalEtherCookieResearchPool; // Eth dividends to be split between players' cookie production\r\n    uint256 public totalCookieProduction;\r\n    uint256 private roughSupply;\r\n    uint256 private lastTotalCookieSaveTime; // Last time any player claimed their produced cookie\r\n\r\n    // Balances for each player\r\n    mapping(address => uint256) public cookieProduction;\r\n    mapping(address => uint256) public cookieBalance;\r\n    mapping(address => uint256) private lastCookieSaveTime; // Last time player claimed their produced cookie\r\n\r\n    // Mapping of approved ERC20 transfers (by player)\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n\r\n    // Production unit contracts\r\n    ProductionUnitToken[] public productionUnitTokenContracts;\r\n    mapping(address => bool) productionUnitTokenContractAddresses;\r\n\r\n    // Store the production unit start time to calculate sell price.\r\n    uint256[] public tokenContractStartTime;\r\n\r\n    uint256 public constant firstUnitStartTime = 1526763600; // TODO: change this in main launch contract\r\n    \r\n    // ERC20 events\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    // Constructor\r\n    function MoonInc() public payable {\r\n        // Create first production unit (Space Kitty)\r\n        createProductionUnit1Beta();\r\n\r\n        // Create first production unit (Space Rabbit)\r\n        // createProductionUnit2Beta();\r\n\r\n        // Create first production unit (Space Hamster)\r\n        // createProductionUnit3Beta();\r\n    }\r\n\r\n    function() public payable {\r\n        // Fallback will add to research pot\r\n        totalEtherCookieResearchPool += msg.value;\r\n    }\r\n\r\n    // TODO: Create 7 createProductionUnit functions in main launch contract\r\n\r\n    function createProductionUnit1Beta() public {\r\n        require(productionUnitTokenContracts.length == 0);\r\n\r\n        createProductionUnitTokenContract(10, 10, 10, 0.0000001 ether / 1000, 0.00000001 ether / 1000, 1, firstUnitStartTime);\r\n    }\r\n\r\n    function createProductionUnit2Beta() public {\r\n        require(productionUnitTokenContracts.length == 1);\r\n\r\n        createProductionUnitTokenContract(15, 15, 15, 0.0000001 ether / 1000, 0.00000001 ether / 1000, 3, firstUnitStartTime + 1 days);\r\n    }\r\n\r\n    function createProductionUnit3Beta() public {\r\n        require(productionUnitTokenContracts.length == 2);\r\n\r\n        createProductionUnitTokenContract(20, 20, 20, 0.0000001 ether / 1000, 0.00000001 ether / 1000, 9, firstUnitStartTime + 2 days);\r\n    }\r\n\r\n    function createProductionUnitTokenContract(\r\n        uint8 _entryFee, uint8 _transferFee, uint8 _exitFee, uint256 _tokenPriceInitial, \r\n        uint256 _tokenPriceIncremental, uint256 _cookieProductionMultiplier, uint256 _startTime\r\n    ) internal {\r\n        ProductionUnitToken newContract = new ProductionUnitToken(address(this),\r\n            _entryFee, _transferFee, _exitFee, _tokenPriceInitial, _tokenPriceIncremental, _cookieProductionMultiplier, _startTime);\r\n        productionUnitTokenContracts.push(newContract);\r\n        productionUnitTokenContractAddresses[address(newContract)] = true;\r\n\r\n        tokenContractStartTime.push(_startTime);\r\n    }\r\n\r\n    function productionUnitTokenContractCount() public view returns (uint) {\r\n        return productionUnitTokenContracts.length;\r\n    }\r\n\r\n    function handleProductionIncrease(address player, uint256 amount) public payable {\r\n        require(productionUnitTokenContractAddresses[msg.sender]);\r\n\r\n        updatePlayersCookie(player);\r\n\r\n        totalCookieProduction = SafeMath.add(totalCookieProduction, amount);\r\n        cookieProduction[player] = SafeMath.add(cookieProduction[player], amount);\r\n\r\n        if (msg.value > 0) {\r\n            totalEtherCookieResearchPool += msg.value;\r\n        }\r\n    }\r\n\r\n    function handleProductionDecrease(address player, uint256 amount) public payable {\r\n        require(productionUnitTokenContractAddresses[msg.sender]);\r\n\r\n        updatePlayersCookie(player);\r\n\r\n        totalCookieProduction = SafeMath.sub(totalCookieProduction, amount);\r\n        cookieProduction[player] = SafeMath.sub(cookieProduction[player], amount);\r\n\r\n        if (msg.value > 0) {\r\n            totalEtherCookieResearchPool += msg.value;\r\n        }\r\n    }\r\n\r\n    function getState() public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        return (totalCookieProduction, cookieProduction[msg.sender], totalSupply(), balanceOf(msg.sender), \r\n            totalEtherCookieResearchPool, lastTotalCookieSaveTime, computeSellPrice());\r\n    }\r\n\r\n    function totalSupply() public constant returns(uint256) {\r\n        return roughSupply + balanceOfTotalUnclaimedCookie();\r\n    }\r\n\r\n    function balanceOf(address player) public constant returns(uint256) {\r\n        return cookieBalance[player] + balanceOfUnclaimedCookie(player);\r\n    }\r\n\r\n    function balanceOfTotalUnclaimedCookie() public constant returns(uint256) {\r\n        if (lastTotalCookieSaveTime > 0 && lastTotalCookieSaveTime < block.timestamp) {\r\n            return (totalCookieProduction * (block.timestamp - lastTotalCookieSaveTime));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {\r\n        uint256 lastSave = lastCookieSaveTime[player];\r\n\r\n        if (lastSave > 0 && lastSave < block.timestamp) {\r\n            return (cookieProduction[player] * (block.timestamp - lastSave));\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        updatePlayersCookie(msg.sender);\r\n        require(amount <= cookieBalance[msg.sender]);\r\n\r\n        cookieBalance[msg.sender] -= amount;\r\n        cookieBalance[recipient] += amount;\r\n\r\n        Transfer(msg.sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\r\n        updatePlayersCookie(player);\r\n        require(amount <= allowed[player][msg.sender] && amount <= cookieBalance[player]);\r\n\r\n        cookieBalance[player] -= amount;\r\n        cookieBalance[recipient] += amount;\r\n        allowed[player][msg.sender] -= amount;\r\n\r\n        Transfer(player, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address approvee, uint256 amount) public returns (bool){\r\n        allowed[msg.sender][approvee] = amount;\r\n        Approval(msg.sender, approvee, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function allowance(address player, address approvee) public constant returns(uint256){\r\n        return allowed[player][approvee];\r\n    }\r\n\r\n    function updatePlayersCookie(address player) internal {\r\n        roughSupply += balanceOfTotalUnclaimedCookie();\r\n        cookieBalance[player] += balanceOfUnclaimedCookie(player);\r\n        lastTotalCookieSaveTime = block.timestamp;\r\n        lastCookieSaveTime[player] = block.timestamp;\r\n    }\r\n\r\n    // Sell all cookies, the eth earned is calculated by the proportion of cookies owned.\r\n    // Selling of cookie is forbidden within one hour of new production unit launch.\r\n    function sellAllCookies() public {\r\n        updatePlayersCookie(msg.sender);\r\n\r\n        uint256 sellPrice = computeSellPrice();\r\n\r\n        require(sellPrice > 0);\r\n\r\n        uint256 myCookies = cookieBalance[msg.sender];\r\n        uint256 value = myCookies * sellPrice / (1 ether);\r\n\r\n        cookieBalance[msg.sender] = 0;\r\n\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    // Compute sell price for 1 cookie, it is 0.5 when a new token contract is deployed,\r\n    // and then goes up until it reaches the maximum sell price after 5 days.\r\n    function computeSellPrice() public view returns (uint) {\r\n        uint256 supply = totalSupply();\r\n\r\n        if (supply == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint index;\r\n        uint lastTokenContractStartTime = now;\r\n\r\n        while (index < tokenContractStartTime.length && tokenContractStartTime[index] < now) {\r\n            lastTokenContractStartTime = tokenContractStartTime[index];\r\n            index++;\r\n        }\r\n\r\n        if (now < lastTokenContractStartTime + 1 hours) {\r\n            return 0;\r\n        }\r\n\r\n        uint timeToMaxValue = 2 days; // TODO: change to 5 days in main launch contract\r\n\r\n        uint256 secondsPassed = now - lastTokenContractStartTime;\r\n        secondsPassed = secondsPassed <= timeToMaxValue ? secondsPassed : timeToMaxValue;\r\n        uint256 multiplier = 5000 + 5000 * secondsPassed / timeToMaxValue;\r\n\r\n        return 1 ether * totalEtherCookieResearchPool / supply * multiplier / 10000;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCookieProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvee\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createProductionUnit1Beta\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"handleProductionIncrease\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cookieProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenContractStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"productionUnitTokenContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellAllCookies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstUnitStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cookieBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"handleProductionDecrease\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceOfTotalUnclaimedCookie\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"productionUnitTokenContractCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createProductionUnit2Beta\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherCookieResearchPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"computeSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"approvee\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createProductionUnit3Beta\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MoonInc","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e36d74dd513a82bb15488b4fd7d395ecec9d7da855c58c38cb47b27aaf4cbe7d"}]}