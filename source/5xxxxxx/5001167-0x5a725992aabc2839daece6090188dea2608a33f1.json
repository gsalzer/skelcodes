{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/* TODO: Add reporting mechanism to punish revealing votes off-chain either on purpose or by using weak salt for computing vote commit hash */\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\ncontract CryptoTask is Ownable {\r\n   \r\n    uint MAX_UINT32 = 4294967295;\r\n    uint MIN_TASK_VALUE = 200000000000000000000;\r\n    uint CLIENT_TIME_TO_DECIDE = 3 days;\r\n    uint VOTING_PERIOD = 5 days;\r\n    /*uint public MIN_TASK_VALUE = 2000000000000000000;\r\n    uint public CLIENT_TIME_TO_DECIDE = 15 minutes;\r\n    uint public VOTING_PERIOD = 15 minutes;*/\r\n    \r\n    struct Task {\r\n        address client;\r\n        address fl;\r\n        uint taskValue;\r\n        uint workTime;\r\n        uint applyTime;\r\n        uint solutionSubmittedTime;\r\n        uint disputeStartedTime;\r\n        bytes32 blockHash;\r\n        mapping(address => bytes32) voteCommits;\r\n        mapping(uint32 => uint32) votes;\r\n        mapping(uint32 => address) voters;\r\n        uint32 votesTotal;\r\n        uint32 votesClient;\r\n        uint32 votesFl;        \r\n        uint32 stage;\r\n        uint prev;\r\n        uint next;\r\n    }\r\n    //due to stack depth error not everything could be fitted to the struct\r\n    mapping(uint => string) public titles;\r\n    mapping(uint => string) public descriptions;\r\n    mapping(uint => string) public solutions;\r\n    mapping(uint => uint) public disputeBlockNos;\r\n    \r\n    \r\n    ERC20 public tokenContract = ERC20(0x4545750F39aF6Be4F237B6869D4EccA928Fd5A85);\r\n    \r\n    //owner can prevent new task submissions if platform is to be moved to a new contract\r\n    //apart from this and airdrops, owner has no other privileges\r\n    bool public migrating;\r\n    mapping(address => uint32) public ADs;\r\n    \r\n    mapping(uint => Task) public tasks;\r\n    uint public tasksSize;\r\n    uint public lastTaskIndex;\r\n    mapping(address => uint) public stakes;\r\n    mapping(address => uint) public lastStakings;\r\n    uint public totalStake;\r\n    \r\n    \r\n    function setMigrating(bool willMigrate) onlyOwner {\r\n        migrating = willMigrate;\r\n    }\r\n    \r\n    function setMinTaskValue(uint minTaskValue) onlyOwner {\r\n        MIN_TASK_VALUE = minTaskValue;\r\n    }\r\n    \r\n    function postTask(string title, string description, uint taskValue, uint workTime) {\r\n        require(!migrating && taskValue > MIN_TASK_VALUE);\r\n        \r\n        tasksSize++;\r\n        \r\n        tasks[tasksSize].client = msg.sender;\r\n        titles[tasksSize] = title;\r\n        tasks[tasksSize].workTime = workTime;\r\n        tasks[tasksSize].taskValue = taskValue;\r\n        descriptions[tasksSize] = description;\r\n        \r\n        //linked list connecting\r\n        tasks[tasksSize].prev = lastTaskIndex;\r\n        if(lastTaskIndex > 0) {\r\n            tasks[lastTaskIndex].next = tasksSize;\r\n        }\r\n        lastTaskIndex = tasksSize;\r\n        \r\n        tokenContract.transferFrom(msg.sender, this, taskValue + taskValue/10);\r\n    }\r\n    \r\n    function applyForTask(uint taskID) {\r\n        require(tasks[taskID].stage == 0 && tasks[taskID].client != address(0));\r\n        tasks[taskID].fl = msg.sender;\r\n        tasks[taskID].applyTime = now;\r\n        tasks[taskID].stage = 1;\r\n        tokenContract.transferFrom(msg.sender, this, tasks[taskID].taskValue/10);\r\n    }\r\n    \r\n    function submitSolution(uint taskID, string solution) {\r\n        require(tasks[taskID].stage == 1 && msg.sender == tasks[taskID].fl && now < tasks[taskID].applyTime + tasks[taskID].workTime);\r\n        solutions[taskID] = solution;\r\n        tasks[taskID].solutionSubmittedTime = now;\r\n        tasks[taskID].stage = 2;\r\n    }\r\n    \r\n    function startDispute(uint taskID) {\r\n        require(tasks[taskID].stage == 2 && tasks[taskID].client == msg.sender && now < tasks[taskID].solutionSubmittedTime + CLIENT_TIME_TO_DECIDE);\r\n        disputeBlockNos[taskID] = block.number;\r\n        tasks[taskID].stage = 3;\r\n    }\r\n    \r\n    //commitDispute and startDispute need to be separate stages to ensure blockHash randomness\r\n    function commitDispute(uint taskID) {\r\n        require(tasks[taskID].stage == 3 && tasks[taskID].client == msg.sender && now < tasks[taskID].solutionSubmittedTime + CLIENT_TIME_TO_DECIDE && block.number > disputeBlockNos[taskID]+5);\r\n        tasks[taskID].blockHash = block.blockhash(disputeBlockNos[taskID]);\r\n        tasks[taskID].disputeStartedTime = now;\r\n        tasks[taskID].stage = 4;\r\n    }\r\n    \r\n    function commitVote(uint taskID, bytes32 voteHash) {\r\n        require(tasks[taskID].stage == 4 && now < tasks[taskID].disputeStartedTime + VOTING_PERIOD && tasks[taskID].voteCommits[msg.sender] == bytes32(0));\r\n        tasks[taskID].voteCommits[msg.sender] = voteHash;\r\n    }\r\n    \r\n    function revealVote(uint taskID, uint8 v, bytes32 r, bytes32 s, uint32 vote, bytes32 salt) {\r\n        //100 sec buffer between commit and reveal vote stages\r\n        require(tasks[taskID].stage == 4 && now > tasks[taskID].disputeStartedTime + VOTING_PERIOD+100 && now < tasks[taskID].disputeStartedTime + 2*VOTING_PERIOD && tasks[taskID].voteCommits[msg.sender] != bytes32(0));\r\n        //check that revealed signature matches public key, that stake is high enough (selection likelihood proportional to stake), that tokens haven't been moved around since dispute started to prevent biasing the selection likelihood, that revealed vote matches the vote commit\r\n        if(ecrecover(keccak256(taskID, tasks[taskID].blockHash), v, r, s) == msg.sender && (10*MAX_UINT32)/(uint(s) % (MAX_UINT32+1)) > totalStake/stakes[msg.sender] && lastStakings[msg.sender] < tasks[taskID].disputeStartedTime && keccak256(salt, vote) == tasks[taskID].voteCommits[msg.sender]) {\r\n            if(vote==1) {\r\n                tasks[taskID].votesClient++;\r\n            } else if(vote==2) {\r\n                tasks[taskID].votesFl++;\r\n            } else {\r\n                throw;\r\n            }\r\n            tasks[taskID].votes[tasks[taskID].votesTotal] = vote;\r\n            tasks[taskID].voters[tasks[taskID].votesTotal] = msg.sender;\r\n            tasks[taskID].votesTotal++;\r\n            //prevent multiple revealing of same vote\r\n            tasks[taskID].voteCommits[msg.sender] = bytes32(0);\r\n        }\r\n    }\r\n    \r\n    function finalizeTask(uint taskID) {\r\n        uint taskValueTenth = tasks[taskID].taskValue/10;\r\n        uint reviewerReward;\r\n        uint32 i;\r\n        \r\n        //cancel posted task no has applied for yet\r\n        if(tasks[taskID].stage == 0 && msg.sender == tasks[taskID].client) {\r\n            tokenContract.transfer(tasks[taskID].client, tasks[taskID].taskValue + taskValueTenth);\r\n            tasks[taskID].stage = 5;\r\n        }\r\n        //accept freelancer's solution\r\n        else if(tasks[taskID].stage == 2 && msg.sender == tasks[taskID].client) {\r\n            tokenContract.transfer(tasks[taskID].fl, tasks[taskID].taskValue + taskValueTenth);\r\n            tokenContract.transfer(tasks[taskID].client, taskValueTenth);\r\n            tasks[taskID].stage = 6;\r\n        }\r\n        //client didn't review freelancer's solution on time, treated as solution accepted\r\n        else if((tasks[taskID].stage == 2 || tasks[taskID].stage == 3) && now > tasks[taskID].solutionSubmittedTime + CLIENT_TIME_TO_DECIDE) {\r\n            tokenContract.transfer(tasks[taskID].fl, tasks[taskID].taskValue + 2*taskValueTenth);\r\n            tasks[taskID].stage = 7;\r\n        }\r\n        //dispute was started and reviewers voted in freelancer's favour\r\n        else if(tasks[taskID].stage == 4 && tasks[taskID].votesFl > tasks[taskID].votesClient && now > tasks[taskID].disputeStartedTime + 2*VOTING_PERIOD) {\r\n            tokenContract.transfer(tasks[taskID].fl, tasks[taskID].taskValue + taskValueTenth);\r\n            reviewerReward = taskValueTenth / tasks[taskID].votesFl;\r\n            //distribute reviewer rewards\r\n            for(i=0; i < tasks[taskID].votesTotal; i++) {\r\n                if(tasks[taskID].votes[i] == 2) {\r\n                    tokenContract.transfer(tasks[taskID].voters[i], reviewerReward);\r\n                }\r\n            }\r\n            tasks[taskID].stage = 8;\r\n        }\r\n        //freelancer didn't submit solution on time, client gets freelancer's escrow\r\n        else if(tasks[taskID].stage == 1 && now > tasks[taskID].applyTime + tasks[taskID].workTime) {\r\n            tokenContract.transfer(tasks[taskID].client, tasks[taskID].taskValue + 2*taskValueTenth);\r\n            tasks[taskID].stage = 9;\r\n        }\r\n        //dispute was started and reviewers voted in client's favour\r\n        else if(tasks[taskID].stage == 4 && tasks[taskID].votesClient >= tasks[taskID].votesFl && now > tasks[taskID].disputeStartedTime + 2*VOTING_PERIOD) {\r\n            if(tasks[taskID].votesTotal == 0) {\r\n                tokenContract.transfer(tasks[taskID].client, tasks[taskID].taskValue + taskValueTenth);\r\n                tokenContract.transfer(tasks[taskID].fl, taskValueTenth);\r\n            } else {\r\n                tokenContract.transfer(tasks[taskID].client, tasks[taskID].taskValue + taskValueTenth);\r\n                reviewerReward = taskValueTenth / tasks[taskID].votesClient;\r\n                //distribute reviewer rewards\r\n                for(i=0; i < tasks[taskID].votesTotal; i++) {\r\n                    if(tasks[taskID].votes[i] == 1) {\r\n                        tokenContract.transfer(tasks[taskID].voters[i], reviewerReward);\r\n                    }\r\n                }\r\n            }\r\n            tasks[taskID].stage = 10;\r\n        } else {\r\n            throw;\r\n        }\r\n        \r\n        //connect linked list after the task removal\r\n        if(tasks[taskID].prev > 0) {\r\n            tasks[tasks[taskID].prev].next = tasks[taskID].next;\r\n        }\r\n        if(tasks[taskID].next > 0) {\r\n            tasks[tasks[taskID].next].prev = tasks[taskID].prev;\r\n        }\r\n        if(taskID == lastTaskIndex) {\r\n            lastTaskIndex = tasks[taskID].prev;\r\n        }\r\n        \r\n        //if users who received airdrops\r\n        if(ADs[tasks[taskID].client] > 0) {\r\n            ADs[tasks[taskID].client]++;\r\n        }\r\n        if(ADs[tasks[taskID].fl] > 0) {\r\n            ADs[tasks[taskID].fl]++;\r\n        }\r\n    }\r\n    \r\n    \r\n    function addStake(uint value) {\r\n        if(value > 0) {\r\n            stakes[msg.sender] += value;\r\n            lastStakings[msg.sender] = now;\r\n            totalStake += value;\r\n            tokenContract.transferFrom(msg.sender, this, value);\r\n        }\r\n    }\r\n    \r\n    function withdrawStake(uint value) {\r\n        if(value > 0 && stakes[msg.sender] >= value) {\r\n            //received airdrop but completed less than 10 tasks\r\n            if(ADs[msg.sender] > 0 && ADs[msg.sender] < 10) {\r\n                throw;\r\n            }\r\n            stakes[msg.sender] -= value;\r\n            lastStakings[msg.sender] = now;\r\n            totalStake -= value;\r\n            tokenContract.transfer(msg.sender, value);\r\n        }\r\n    }\r\n    \r\n    //airdrop\r\n    function addStakeAD(uint value, address recipient) onlyOwner {\r\n        //prevent owner from adding a small value to set regular user to airdropped user\r\n        if(value > 0 && value > 1000*stakes[recipient]) {\r\n            stakes[recipient] += value;\r\n            lastStakings[recipient] = now;\r\n            totalStake += value;\r\n            ADs[recipient]++;\r\n            tokenContract.transferFrom(msg.sender, this, value);\r\n        }\r\n    }\r\n    \r\n    \r\n    function getVoteCommit(uint taskID, address commiter) constant returns (bytes32 commit) {\r\n        return tasks[taskID].voteCommits[commiter];\r\n    }\r\n    \r\n    function getVote(uint taskID, uint32 index) constant returns (uint32 vote) {\r\n        return tasks[taskID].votes[index];\r\n    }\r\n    \r\n    function getVoter(uint taskID, uint32 index) constant returns (address voter) {\r\n        return tasks[taskID].voters[index];\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"titles\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"commitDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"vote\",\"type\":\"uint32\"},{\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"revealVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrating\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastStakings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"getVote\",\"outputs\":[{\"name\":\"vote\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minTaskValue\",\"type\":\"uint256\"}],\"name\":\"setMinTaskValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ADs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tasksSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"finalizeTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tasks\",\"outputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"fl\",\"type\":\"address\"},{\"name\":\"taskValue\",\"type\":\"uint256\"},{\"name\":\"workTime\",\"type\":\"uint256\"},{\"name\":\"applyTime\",\"type\":\"uint256\"},{\"name\":\"solutionSubmittedTime\",\"type\":\"uint256\"},{\"name\":\"disputeStartedTime\",\"type\":\"uint256\"},{\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"name\":\"votesTotal\",\"type\":\"uint32\"},{\"name\":\"votesClient\",\"type\":\"uint32\"},{\"name\":\"votesFl\",\"type\":\"uint32\"},{\"name\":\"stage\",\"type\":\"uint32\"},{\"name\":\"prev\",\"type\":\"uint256\"},{\"name\":\"next\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"},{\"name\":\"voteHash\",\"type\":\"bytes32\"}],\"name\":\"commitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"},{\"name\":\"commiter\",\"type\":\"address\"}],\"name\":\"getVoteCommit\",\"outputs\":[{\"name\":\"commit\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"solutions\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"disputeBlockNos\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"startDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"taskValue\",\"type\":\"uint256\"},{\"name\":\"workTime\",\"type\":\"uint256\"}],\"name\":\"postTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"},{\"name\":\"solution\",\"type\":\"string\"}],\"name\":\"submitSolution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTaskIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"}],\"name\":\"applyForTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"descriptions\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"addStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"willMigrate\",\"type\":\"bool\"}],\"name\":\"setMigrating\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"addStakeAD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"taskID\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"getVoter\",\"outputs\":[{\"name\":\"voter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CryptoTask","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4bd0b578fd2473f274fc749a8343f1404fae32e095a77af8ee26cb4c79ba23db"}]}