{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 interface\r\n * @dev see https://github.com/ethereum/eips/issues/721\r\n */\r\ncontract ERC721 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function transfer(address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function takeOwnership(uint256 _tokenId) public;\r\n}\r\n\r\n/**\r\n * @title ERC721Token\r\n * Generic implementation for the required functionality of the ERC721 standard\r\n */\r\ncontract ERC721Token is ERC721 {\r\n  using SafeMath for uint256;\r\n\r\n  // Total amount of tokens\r\n  uint256 internal totalTokens;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) internal tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping (address => uint256[]) internal ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n  /**\r\n  * @dev Guarantees msg.sender is owner of the given token\r\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n  */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the total amount of tokens stored by the contract\r\n  * @return uint256 representing the total amount of tokens\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalTokens;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address\r\n  * @param _owner address to query the balance of\r\n  * @return uint256 representing the amount owned by the passed address\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return ownedTokens[_owner].length;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the list of tokens owned by a given address\r\n  * @param _owner address to query the tokens of\r\n  * @return uint256[] representing the list of tokens owned by the passed address\r\n  */\r\n  function tokensOf(address _owner) public view returns (uint256[]) {\r\n    return ownedTokens[_owner];\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the owner of the specified token ID\r\n  * @param _tokenId uint256 ID of the token to query the owner of\r\n  * @return owner address currently marked as the owner of the given token ID\r\n  */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address to take ownership of a given token ID\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved to take ownership of the given token ID\r\n   */\r\n  function approvedFor(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfers the ownership of a given token ID to another address\r\n  * @param _to address to receive the ownership of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\r\n    clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Approves another address to claim for the ownership of the given token ID\r\n  * @param _to address to be approved for the given token ID\r\n  * @param _tokenId uint256 ID of the token to be approved\r\n  */\r\n  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    if (approvedFor(_tokenId) != 0 || _to != 0) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      Approval(owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Claims the ownership of a given token ID\r\n  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\r\n  */\r\n  function takeOwnership(uint256 _tokenId) public {\r\n    require(isApprovedFor(msg.sender, _tokenId));\r\n    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Mint token function\r\n  * @param _to The address that will own the minted token\r\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n  */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addToken(_to, _tokenId);\r\n    Transfer(0x0, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Burns a specific token\r\n  * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n  */\r\n  function _burn(uint256 _tokenId) onlyOwnerOf(_tokenId) internal {\r\n    if (approvedFor(_tokenId) != 0) {\r\n      clearApproval(msg.sender, _tokenId);\r\n    }\r\n    removeToken(msg.sender, _tokenId);\r\n    Transfer(msg.sender, 0x0, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether the msg.sender is approved for the given token ID or not\r\n   * This function is not private so it can be extended in further implementations like the operatable ERC721\r\n   * @param _owner address of the owner to query the approval of\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether the msg.sender is approved for the given token ID or not\r\n   */\r\n  function isApprovedFor(address _owner, uint256 _tokenId) internal view returns (bool) {\r\n    return approvedFor(_tokenId) == _owner;\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function to clear current approval and transfer the ownership of a given token ID\r\n  * @param _from address which you want to send tokens from\r\n  * @param _to address which you want to transfer the token to\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    require(_to != ownerOf(_tokenId));\r\n    require(ownerOf(_tokenId) == _from);\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeToken(_from, _tokenId);\r\n    addToken(_to, _tokenId);\r\n    Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function to clear current approval of a given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function clearApproval(address _owner, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    tokenApprovals[_tokenId] = 0;\r\n    Approval(_owner, 0, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function to add a token ID to the list of a given address\r\n  * @param _to address representing the new owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n  */\r\n  function addToken(address _to, uint256 _tokenId) private {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    uint256 length = balanceOf(_to);\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n    totalTokens = totalTokens.add(1);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function to remove a token ID from the list of a given address\r\n  * @param _from address representing the previous owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n  */\r\n  function removeToken(address _from, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _from);\r\n\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = balanceOf(_from).sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    tokenOwner[_tokenId] = 0;\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n    totalTokens = totalTokens.sub(1);\r\n  }\r\n}\r\n\r\n\r\ncontract AuctionHouse {\r\n    address owner;\r\n\r\n    function AuctionHouse() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) at beginning of auction\r\n        uint128 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint128 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint64 duration;\r\n        // Time when auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut = 375; // Default is 3.75%\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping (address => mapping (uint256 => Auction)) tokenIdToAuction;\r\n\r\n    // Allowed tokens\r\n    mapping (address => bool) supportedTokens;\r\n\r\n    event AuctionCreated(address indexed tokenAddress, uint256 indexed tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration, address seller);\r\n    event AuctionSuccessful(address indexed tokenAddress, uint256 indexed tokenId, uint256 totalPrice, address winner);\r\n    event AuctionCancelled(address indexed tokenAddress, uint256 indexed tokenId, address seller);\r\n\r\n    // Admin\r\n\r\n    // Change owner of the contract\r\n    function changeOwner(address newOwner) external {\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    // Add or remove supported tokens\r\n    function setSupportedToken(address tokenAddress, bool supported) external {\r\n        require(msg.sender == owner);\r\n        supportedTokens[tokenAddress] = supported;\r\n    }\r\n\r\n    // Set the owner cut for auctions\r\n    function setOwnerCut(uint256 cut) external {\r\n        require(msg.sender == owner);\r\n        require(cut <= 10000);\r\n        ownerCut = cut;\r\n    }\r\n\r\n    // Withdraw sales fees\r\n    function withdraw() external {\r\n      require(msg.sender == owner);\r\n      owner.transfer(this.balance);\r\n    }\r\n\r\n    /// @dev Returns true if the claimant owns the token.\r\n    /// @param _claimant - Address claiming to own the token.\r\n    /// @param _tokenId - ID of token whose ownership to verify.\r\n    function _owns(address _tokenAddress, address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (ERC721Token(_tokenAddress).ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /// @dev Escrows the NFT, assigning ownership to this contract.\r\n    /// Throws if the escrow fails.\r\n    /// @param _tokenId - ID of token whose approval to verify.\r\n    function _escrow(address _tokenAddress, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        ERC721Token token = ERC721Token(_tokenAddress);\r\n        if (token.ownerOf(_tokenId) != address(this)) {\r\n          token.takeOwnership(_tokenId);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers an NFT owned by this contract to another address.\r\n    /// Returns true if the transfer succeeds.\r\n    /// @param _receiver - Address to transfer NFT to.\r\n    /// @param _tokenId - ID of token to transfer.\r\n    function _transfer(address _tokenAddress, address _receiver, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        ERC721Token(_tokenAddress).transfer(_receiver, _tokenId);\r\n    }\r\n\r\n    /// @dev Adds an auction to the list of open auctions. Also fires the\r\n    ///  AuctionCreated event.\r\n    /// @param _tokenId The ID of the token to be put on auction.\r\n    /// @param _auction Auction to add.\r\n    function _addAuction(address _tokenAddress, uint256 _tokenId, Auction _auction) internal {\r\n        // Require that all auctions have a duration of\r\n        // at least one minute. (Keeps our math from getting hairy!)\r\n        require(_auction.duration >= 1 minutes);\r\n\r\n        tokenIdToAuction[_tokenAddress][_tokenId] = _auction;\r\n\r\n        AuctionCreated(\r\n            address(_tokenAddress),\r\n            uint256(_tokenId),\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.duration),\r\n            address(_auction.seller)\r\n        );\r\n    }\r\n\r\n    /// @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(address _tokenAddress, uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenAddress, _tokenId);\r\n        _transfer(_tokenAddress, _seller, _tokenId);\r\n        AuctionCancelled(_tokenAddress, _tokenId, _seller);\r\n    }\r\n\r\n    /// @dev Computes the price and transfers winnings.\r\n    /// Does NOT transfer ownership of token.\r\n    function _bid(address _tokenAddress, uint256 _tokenId, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // Get a reference to the auction struct\r\n        Auction storage auction = tokenIdToAuction[_tokenAddress][_tokenId];\r\n\r\n        // Explicitly check that this auction is currently live.\r\n        // (Because of how Ethereum mappings work, we can't just count\r\n        // on the lookup above failing. An invalid _tokenId will just\r\n        // return an auction object that is all zeros.)\r\n        require(_isOnAuction(auction));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(auction);\r\n        require(_bidAmount >= price);\r\n\r\n        // Grab a reference to the seller before the auction struct\r\n        // gets deleted.\r\n        address seller = auction.seller;\r\n\r\n        // The bid is good! Remove the auction before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        _removeAuction(_tokenAddress, _tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the auctioneer's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            // value <= price, so this subtraction can't go negative.)\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - auctioneerCut;\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the auction\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelAuction(). )\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the auction is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        AuctionSuccessful(_tokenAddress, _tokenId, price, msg.sender);\r\n\r\n        return price;\r\n    }\r\n\r\n    /// @dev Removes an auction from the list of open auctions.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function _removeAuction(address _tokenAddress, uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenAddress][_tokenId];\r\n    }\r\n\r\n    /// @dev Returns true if the NFT is on auction.\r\n    /// @param _auction - Auction to check.\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Returns current price of an NFT on auction. Broken into two\r\n    ///  functions (this one, that computes the duration from the auction\r\n    ///  structure, and the other that does the price computation) so we\r\n    ///  can easily test that the price computation works correctly.\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarnatees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    /// @dev Computes the current price of an auction. Factored out\r\n    ///  from _currentPrice so we can run extensive unit tests.\r\n    ///  When testing, make this function public and turn on\r\n    ///  `Current price computation` test suite.\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our public functions carefully cap the maximum values for\r\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\r\n        //  also known to be non-zero (see the require() statement in\r\n        //  _addAuction())\r\n        if (_secondsPassed >= _duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the auction, just return the end price.\r\n            return _endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that _startingPrice. Thus, this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    /// @dev Computes owner's cut of a sale.\r\n    /// @param _price - Sale price of NFT.\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our entry functions carefully cap the maximum values for\r\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\r\n        //  statement in the ClockAuction constructor). The result of this\r\n        //  function is always guaranteed to be <= _price.\r\n        return _price * ownerCut / 10000;\r\n    }\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of time to move between starting\r\n    ///  price and ending price (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        address _tokenAddress,\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        public\r\n    {\r\n        // Check this token is supported\r\n        require(supportedTokens[_tokenAddress]);\r\n\r\n        // Auctions must be made by the token contract or the token owner\r\n        require(msg.sender == _tokenAddress || _owns(_tokenAddress, msg.sender, _tokenId));\r\n\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        _escrow(_tokenAddress, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenAddress, _tokenId, auction);\r\n    }\r\n\r\n    /// @dev Bids on an open auction, completing the auction and transferring\r\n    ///  ownership of the NFT if enough Ether is supplied.\r\n    /// @param _tokenId - ID of token to bid on.\r\n    function bid(address _tokenAddress, uint256 _tokenId)\r\n        external\r\n        payable\r\n    {\r\n        // Check this token is supported\r\n        require(supportedTokens[_tokenAddress]);\r\n        // _bid will throw if the bid or funds transfer fails\r\n        _bid(_tokenAddress, _tokenId, msg.value);\r\n        _transfer(_tokenAddress, msg.sender, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels an auction that hasn't been won yet.\r\n    ///  Returns the NFT to original owner.\r\n    /// @notice This is a state-modifying function that can\r\n    ///  be called while the contract is paused.\r\n    /// @param _tokenId - ID of token on auction\r\n    function cancelAuction(address _tokenAddress, uint256 _tokenId)\r\n        external\r\n    {\r\n        // We don't check if a token is supported here because we may remove supported\r\n        // This allows users to cancel auctions for tokens that have been removed\r\n        Auction storage auction = tokenIdToAuction[_tokenAddress][_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenAddress, _tokenId, seller);\r\n    }\r\n\r\n    /// @dev Returns auction info for an NFT on auction.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function getAuction(address _tokenAddress, uint256 _tokenId)\r\n        external\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        // Check this token is supported\r\n        require(supportedTokens[_tokenAddress]);\r\n        Auction storage auction = tokenIdToAuction[_tokenAddress][_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n            auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the current price of an auction.\r\n    /// @param _tokenId - ID of the token price we are checking.\r\n    function getCurrentPrice(address _tokenAddress, uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Check this token is supported\r\n        require(supportedTokens[_tokenAddress]);\r\n        Auction storage auction = tokenIdToAuction[_tokenAddress][_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n}\r\n\r\ncontract CryptoHandles is ERC721Token {\r\n\r\n    address public owner;\r\n    uint256 public defaultBuyNowPrice = 100 finney;\r\n    uint256 public defaultAuctionPrice = 1 ether;\r\n    uint256 public defaultAuctionDuration = 1 days;\r\n\r\n    AuctionHouse public auctions;\r\n\r\n    mapping (uint => bytes32) handles;\r\n    mapping (bytes32 => uint) reverse;\r\n\r\n    event SetRecord(bytes32 indexed handle, string indexed key, string value);\r\n\r\n    function CryptoHandles(address auctionAddress) {\r\n      owner = msg.sender;\r\n      auctions = AuctionHouse(auctionAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Change owner of the contract\r\n    */\r\n    function changeOwner(address newOwner) external {\r\n      require(msg.sender == owner);\r\n      owner = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw funds\r\n    */\r\n    function withdraw() external {\r\n      require(msg.sender == owner);\r\n      owner.transfer(this.balance);\r\n    }\r\n\r\n    /**\r\n    * @dev Set buy now price\r\n    */\r\n    function setBuyNowPrice(uint price) external {\r\n      require(msg.sender == owner);\r\n      defaultBuyNowPrice = price;\r\n    }\r\n\r\n    /**\r\n    * @dev Set buy now price\r\n    */\r\n    function setAuctionPrice(uint price) external {\r\n      require(msg.sender == owner);\r\n      defaultAuctionPrice = price;\r\n    }\r\n\r\n    /**\r\n    * @dev Set duration\r\n    */\r\n    function setAuctionDuration(uint duration) external {\r\n      require(msg.sender == owner);\r\n      defaultAuctionDuration = duration;\r\n    }\r\n\r\n    /**\r\n    * @dev Accept proceeds from auction sales\r\n    */\r\n    function() public payable {}\r\n\r\n    /**\r\n    * @dev Create a new handle if the handle is valid and not owned\r\n    * @param _handle bytes32 handle to register\r\n    */\r\n    function create(bytes32 _handle) external payable {\r\n        require(isHandleValid(_handle));\r\n        require(isHandleAvailable(_handle));\r\n        uint _tokenId = totalTokens;\r\n        handles[_tokenId] = _handle;\r\n        reverse[_handle] = _tokenId;\r\n\r\n        // handle buy now\r\n        if (msg.value == defaultBuyNowPrice) {\r\n          _mint(msg.sender, _tokenId);\r\n        } else {\r\n          // otherwise start an auction\r\n          require(msg.value == 0);\r\n          // mint the token to the address\r\n          _mint(address(auctions), _tokenId);\r\n          auctions.createAuction(\r\n              address(this),\r\n              _tokenId,\r\n              defaultAuctionPrice,\r\n              0,\r\n              defaultAuctionDuration,\r\n              address(this)\r\n          );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a handle is valid: a-z, 0-9, _\r\n    * @param _handle bytes32 to check validity\r\n    */\r\n    function isHandleValid(bytes32 _handle) public pure returns (bool) {\r\n        if (_handle == 0x0) {\r\n            return false;\r\n        }\r\n        bool padded;\r\n        for (uint i = 0; i < 32; i++) {\r\n            byte char = byte(bytes32(uint(_handle) * 2 ** (8 * i)));\r\n            // null for padding\r\n            if (char == 0x0) {\r\n                padded = true;\r\n                continue;\r\n            }\r\n            // numbers 0-9\r\n            if (char >= 0x30  && char <= 0x39 && !padded) {\r\n                continue;\r\n            }\r\n            // lowercase letters a-z\r\n            if (char >= 0x61  && char <= 0x7A && !padded) {\r\n                continue;\r\n            }\r\n            // underscores _\r\n            if (char == 0x5F && !padded) {\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a handle is available\r\n    * @param _handle bytes32 handle to check availability\r\n    */\r\n    function isHandleAvailable(bytes32 _handle) public view returns (bool) {\r\n        // Get the tokenId for a given handle\r\n        uint tokenId = reverse[_handle];\r\n        if (handles[tokenId] != _handle) {\r\n          return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the AuctionHouse and start an auction\r\n    * @param _tokenId uint256\r\n    * @param _startingPrice uint256\r\n    * @param _endingPrice uint256\r\n    * @param _duration uint256\r\n    */\r\n    function approveAndAuction(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration) external {\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n        tokenApprovals[_tokenId] = address(auctions);\r\n        auctions.createAuction(\r\n            address(this),\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Get tokenId for a given handle\r\n    * @param _handle bytes32 handle\r\n    */\r\n    function tokenIdForHandle(bytes32 _handle) public view returns (uint) {\r\n        // Handle 0 index\r\n        uint tokenId = reverse[_handle];\r\n        require(handles[tokenId] == _handle);\r\n        return tokenId;\r\n    }\r\n\r\n    /**\r\n    * @dev Get handle for a given tokenId\r\n    * @param _tokenId uint\r\n    */\r\n    function handleForTokenId(uint _tokenId) public view returns (bytes32) {\r\n        bytes32 handle = handles[_tokenId];\r\n        require(handle != 0x0);\r\n        return handle;\r\n    }\r\n\r\n    /**\r\n    * @dev Get the handle owner\r\n    * @param _handle bytes32 handle to check availability\r\n    */\r\n    function getHandleOwner(bytes32 _handle) public view returns (address) {\r\n        // Handle 0 index\r\n        uint tokenId = reverse[_handle];\r\n        require(handles[tokenId] == _handle);\r\n        return ownerOf(tokenId);\r\n    }\r\n\r\n    /// Records for a handle\r\n    mapping(bytes32 => mapping(string => string)) internal records;\r\n\r\n    function setRecord(bytes32 _handle, string _key, string _value) external {\r\n        uint tokenId = reverse[_handle];\r\n        require(ownerOf(tokenId) == msg.sender);\r\n        records[_handle][_key] = _value;\r\n        SetRecord(_handle, _key, _value);\r\n    }\r\n\r\n    function getRecord(bytes32 _handle, string _key) external view returns (string) {\r\n        return records[_handle][_key];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_handle\",\"type\":\"bytes32\"}],\"name\":\"isHandleValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approvedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setAuctionPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_handle\",\"type\":\"bytes32\"}],\"name\":\"getHandleOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultAuctionDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_handle\",\"type\":\"bytes32\"},{\"name\":\"_key\",\"type\":\"string\"}],\"name\":\"getRecord\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_handle\",\"type\":\"bytes32\"}],\"name\":\"create\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"handleForTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"approveAndAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctions\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_handle\",\"type\":\"bytes32\"}],\"name\":\"isHandleAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"setAuctionDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_handle\",\"type\":\"bytes32\"},{\"name\":\"_key\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"setRecord\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_handle\",\"type\":\"bytes32\"}],\"name\":\"tokenIdForHandle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultBuyNowPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setBuyNowPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultAuctionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"auctionAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"handle\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"string\"}],\"name\":\"SetRecord\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CryptoHandles","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000024027b8e12383ee6d726b5b6a48562c484593846","Library":"","SwarmSource":"bzzr://aa46507ed0a2b9285be9727ab36236461772ee5d104a88ddb6fc23512e0dd0dd"}]}