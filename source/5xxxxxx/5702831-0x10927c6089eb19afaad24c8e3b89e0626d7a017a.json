{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract TokenTransferProxy is Ownable {\r\n\r\n    /// @dev Only authorized addresses can invoke functions with this modifier.\r\n    modifier onlyAuthorized {\r\n        require(authorized[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier targetAuthorized(address target) {\r\n        require(authorized[target]);\r\n        _;\r\n    }\r\n\r\n    modifier targetNotAuthorized(address target) {\r\n        require(!authorized[target]);\r\n        _;\r\n    }\r\n\r\n    mapping (address => bool) public authorized;\r\n    address[] public authorities;\r\n\r\n    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\r\n    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n\r\n    /// @dev Authorizes an address.\r\n    /// @param target Address to authorize.\r\n    function addAuthorizedAddress(address target)\r\n        public\r\n        onlyOwner\r\n        targetNotAuthorized(target)\r\n    {\r\n        authorized[target] = true;\r\n        authorities.push(target);\r\n        emit LogAuthorizedAddressAdded(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Removes authorizion of an address.\r\n    /// @param target Address to remove authorization from.\r\n    function removeAuthorizedAddress(address target)\r\n        public\r\n        onlyOwner\r\n        targetAuthorized(target)\r\n    {\r\n        delete authorized[target];\r\n        for (uint i = 0; i < authorities.length; i++) {\r\n            if (authorities[i] == target) {\r\n                authorities[i] = authorities[authorities.length - 1];\r\n                authorities.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n        emit LogAuthorizedAddressRemoved(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\r\n    /// @param token Address of token to transfer.\r\n    /// @param from Address to transfer token from.\r\n    /// @param to Address to transfer token to.\r\n    /// @param value Amount of token to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value)\r\n        public\r\n        onlyAuthorized\r\n        returns (bool)\r\n    {\r\n        return Token(token).transferFrom(from, to, value);\r\n    }\r\n\r\n    /*\r\n     * Public constant functions\r\n     */\r\n\r\n    /// @dev Gets all authorized addresses.\r\n    /// @return Array of authorized addresses.\r\n    function getAuthorizedAddresses()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return authorities;\r\n    }\r\n}\r\n\r\n\r\n/// @title Interface for all exchange handler contracts\r\ninterface ExchangeHandler {\r\n\r\n    /// @dev Get the available amount left to fill for an order\r\n    /// @param orderAddresses Array of address values needed for this DEX order\r\n    /// @param orderValues Array of uint values needed for this DEX order\r\n    /// @param exchangeFee Value indicating the fee for this DEX order\r\n    /// @param v ECDSA signature parameter v\r\n    /// @param r ECDSA signature parameter r\r\n    /// @param s ECDSA signature parameter s\r\n    /// @return Available amount left to fill for this order\r\n    function getAvailableAmount(\r\n        address[8] orderAddresses,\r\n        uint256[6] orderValues,\r\n        uint256 exchangeFee,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256);\r\n\r\n    /// @dev Perform a buy order at the exchange\r\n    /// @param orderAddresses Array of address values needed for each DEX order\r\n    /// @param orderValues Array of uint values needed for each DEX order\r\n    /// @param exchangeFee Value indicating the fee for this DEX order\r\n    /// @param amountToFill Amount to fill in this order\r\n    /// @param v ECDSA signature parameter v\r\n    /// @param r ECDSA signature parameter r\r\n    /// @param s ECDSA signature parameter s\r\n    /// @return Amount filled in this order\r\n    function performBuy(\r\n        address[8] orderAddresses,\r\n        uint256[6] orderValues,\r\n        uint256 exchangeFee,\r\n        uint256 amountToFill,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable returns (uint256);\r\n\r\n    /// @dev Perform a sell order at the exchange\r\n    /// @param orderAddresses Array of address values needed for each DEX order\r\n    /// @param orderValues Array of uint values needed for each DEX order\r\n    /// @param exchangeFee Value indicating the fee for this DEX order\r\n    /// @param amountToFill Amount to fill in this order\r\n    /// @param v ECDSA signature parameter v\r\n    /// @param r ECDSA signature parameter r\r\n    /// @param s ECDSA signature parameter s\r\n    /// @return Amount filled in this order\r\n    function performSell(\r\n        address[8] orderAddresses,\r\n        uint256[6] orderValues,\r\n        uint256 exchangeFee,\r\n        uint256 amountToFill,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256);\r\n}\r\n\r\ncontract Token {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n/// @title The primary contract for Totle Inc\r\ncontract TotlePrimary is Ownable {\r\n    // Constants\r\n    string public constant CONTRACT_VERSION = \"0\";\r\n    uint256 public constant MAX_EXCHANGE_FEE_PERCENTAGE = 0.01 * 10**18; // 1%\r\n    bool constant BUY = false;\r\n    bool constant SELL = true;\r\n\r\n    // State variables\r\n    mapping(address => bool) public handlerWhitelist;\r\n    address tokenTransferProxy;\r\n\r\n    // Structs\r\n    struct Tokens {\r\n        address[] tokenAddresses;\r\n        bool[]    buyOrSell;\r\n        uint256[] amountToObtain;\r\n        uint256[] amountToGive;\r\n    }\r\n\r\n    struct DEXOrders {\r\n        address[] tokenForOrder;\r\n        address[] exchanges;\r\n        address[8][] orderAddresses;\r\n        uint256[6][] orderValues;\r\n        uint256[] exchangeFees;\r\n        uint8[] v;\r\n        bytes32[] r;\r\n        bytes32[] s;\r\n    }\r\n\r\n    /// @dev Constructor\r\n    /// @param proxy Address of the TokenTransferProxy\r\n    constructor(address proxy) public {\r\n        tokenTransferProxy = proxy;\r\n    }\r\n\r\n    /*\r\n    *   Public functions\r\n    */\r\n\r\n    /// @dev Set an exchange handler address to true/false\r\n    /// @notice - onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param handler Address of the exchange handler which permission needs changing\r\n    /// @param allowed Boolean value to set whether an exchange handler is allowed/denied\r\n    function setHandler(address handler, bool allowed) public onlyOwner {\r\n        handlerWhitelist[handler] = allowed;\r\n    }\r\n\r\n    /// @dev Synchronously executes an array of orders\r\n    /// @notice The first four parameters relate to Token orders, the last eight relate to DEX orders\r\n    /// @param tokenAddresses Array of addresses of ERC20 Token contracts for each Token order\r\n    /// @param buyOrSell Array indicating whether each Token order is a buy or sell\r\n    /// @param amountToObtain Array indicating the amount (in ether or tokens) to obtain in the order\r\n    /// @param amountToGive Array indicating the amount (in ether or tokens) to give in the order\r\n    /// @param tokenForOrder Array of addresses of ERC20 Token contracts for each DEX order\r\n    /// @param exchanges Array of addresses of exchange handler contracts\r\n    /// @param orderAddresses Array of address values needed for each DEX order\r\n    /// @param orderValues Array of uint values needed for each DEX order\r\n    /// @param exchangeFees Array indicating the fee for each DEX order (percentage of fill amount as decimal * 10**18)\r\n    /// @param v ECDSA signature parameter v\r\n    /// @param r ECDSA signature parameter r\r\n    /// @param s ECDSA signature parameter s\r\n    function executeOrders(\r\n        // Tokens\r\n        address[] tokenAddresses,\r\n        bool[]    buyOrSell,\r\n        uint256[] amountToObtain,\r\n        uint256[] amountToGive,\r\n        // DEX Orders\r\n        address[] tokenForOrder,\r\n        address[] exchanges,\r\n        address[8][] orderAddresses,\r\n        uint256[6][] orderValues,\r\n        uint256[] exchangeFees,\r\n        uint8[] v,\r\n        bytes32[] r,\r\n        bytes32[] s\r\n    ) public payable {\r\n\r\n        require(\r\n            tokenAddresses.length == buyOrSell.length &&\r\n            buyOrSell.length      == amountToObtain.length &&\r\n            amountToObtain.length == amountToGive.length\r\n        );\r\n\r\n        require(\r\n            tokenForOrder.length  == exchanges.length &&\r\n            exchanges.length      == orderAddresses.length &&\r\n            orderAddresses.length == orderValues.length &&\r\n            orderValues.length    == exchangeFees.length &&\r\n            exchangeFees.length   == v.length &&\r\n            v.length              == r.length &&\r\n            r.length              == s.length\r\n        );\r\n\r\n        // Wrapping order in structs to reduce local variable count\r\n        internalOrderExecution(\r\n            Tokens(\r\n                tokenAddresses,\r\n                buyOrSell,\r\n                amountToObtain,\r\n                amountToGive\r\n            ),\r\n            DEXOrders(\r\n                tokenForOrder,\r\n                exchanges,\r\n                orderAddresses,\r\n                orderValues,\r\n                exchangeFees,\r\n                v,\r\n                r,\r\n                s\r\n            )\r\n        );\r\n    }\r\n\r\n    /*\r\n    *   Internal functions\r\n    */\r\n\r\n    /// @dev Synchronously executes an array of orders\r\n    /// @notice The orders in this function have been wrapped in structs to reduce the local variable count\r\n    /// @param tokens Struct containing the arrays of token orders\r\n    /// @param orders Struct containing the arrays of DEX orders\r\n    function internalOrderExecution(Tokens tokens, DEXOrders orders) internal {\r\n        transferTokens(tokens);\r\n\r\n        uint256 tokensLength = tokens.tokenAddresses.length;\r\n        uint256 ordersLength = orders.tokenForOrder.length;\r\n        uint256 etherBalance = msg.value;\r\n        uint256 orderIndex = 0;\r\n\r\n        for(uint256 tokenIndex = 0; tokenIndex < tokensLength; tokenIndex++) {\r\n            // NOTE - check for repetitions in the token list?\r\n\r\n            uint256 amountRemaining = tokens.amountToGive[tokenIndex];\r\n            uint256 amountObtained = 0;\r\n\r\n            while(orderIndex < ordersLength) {\r\n                require(tokens.tokenAddresses[tokenIndex] == orders.tokenForOrder[orderIndex]);\r\n                require(handlerWhitelist[orders.exchanges[orderIndex]]);\r\n\r\n                if(amountRemaining > 0) {\r\n                    if(tokens.buyOrSell[tokenIndex] == BUY) {\r\n                        require(etherBalance >= amountRemaining);\r\n                    }\r\n                    (amountRemaining, amountObtained) = performTrade(\r\n                        tokens.buyOrSell[tokenIndex],\r\n                        amountRemaining,\r\n                        amountObtained,\r\n                        orders, // NOTE - unable to send pointer to order values individually, as run out of stack space!\r\n                        orderIndex\r\n                        );\r\n                }\r\n\r\n                orderIndex = SafeMath.add(orderIndex, 1);\r\n                // If this is the last order for this token\r\n                if(orderIndex == ordersLength || orders.tokenForOrder[SafeMath.sub(orderIndex, 1)] != orders.tokenForOrder[orderIndex]) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            uint256 amountGiven = SafeMath.sub(tokens.amountToGive[tokenIndex], amountRemaining);\r\n\r\n            require(orderWasValid(amountObtained, amountGiven, tokens.amountToObtain[tokenIndex], tokens.amountToGive[tokenIndex]));\r\n\r\n            if(tokens.buyOrSell[tokenIndex] == BUY) {\r\n                // Take away spent ether from refund balance\r\n                etherBalance = SafeMath.sub(etherBalance, amountGiven);\r\n                // Transfer back tokens acquired\r\n                if(amountObtained > 0) {\r\n                    require(Token(tokens.tokenAddresses[tokenIndex]).transfer(msg.sender, amountObtained));\r\n                }\r\n            } else {\r\n                // Add ether to refund balance\r\n                etherBalance = SafeMath.add(etherBalance, amountObtained);\r\n                // Transfer back un-sold tokens\r\n                if(amountRemaining > 0) {\r\n                    require(Token(tokens.tokenAddresses[tokenIndex]).transfer(msg.sender, amountRemaining));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Send back acquired/unspent ether - throw on failure\r\n        if(etherBalance > 0) {\r\n            msg.sender.transfer(etherBalance);\r\n        }\r\n    }\r\n\r\n    /// @dev Iterates through a list of token orders, transfer the SELL orders to this contract & calculates if we have the ether needed\r\n    /// @param tokens Struct containing the arrays of token orders\r\n    function transferTokens(Tokens tokens) internal {\r\n        uint256 expectedEtherAvailable = msg.value;\r\n        uint256 totalEtherNeeded = 0;\r\n\r\n        for(uint256 i = 0; i < tokens.tokenAddresses.length; i++) {\r\n            if(tokens.buyOrSell[i] == BUY) {\r\n                totalEtherNeeded = SafeMath.add(totalEtherNeeded, tokens.amountToGive[i]);\r\n            } else {\r\n                expectedEtherAvailable = SafeMath.add(expectedEtherAvailable, tokens.amountToObtain[i]);\r\n                require(TokenTransferProxy(tokenTransferProxy).transferFrom(\r\n                    tokens.tokenAddresses[i],\r\n                    msg.sender,\r\n                    this,\r\n                    tokens.amountToGive[i]\r\n                ));\r\n            }\r\n        }\r\n\r\n        // Make sure we have will have enough ETH after SELLs to cover our BUYs\r\n        require(expectedEtherAvailable >= totalEtherNeeded);\r\n    }\r\n\r\n    /// @dev Performs a single trade via the requested exchange handler\r\n    /// @param buyOrSell Boolean value stating whether this is a buy or sell order\r\n    /// @param initialRemaining The remaining value we have left to trade\r\n    /// @param totalObtained The total amount we have obtained so far\r\n    /// @param orders Struct containing all DEX orders\r\n    /// @param index Value indicating the index of the specific DEX order we wish to execute\r\n    /// @return Remaining value left after trade\r\n    /// @return Total value obtained after trade\r\n    function performTrade(bool buyOrSell, uint256 initialRemaining, uint256 totalObtained, DEXOrders orders, uint256 index)\r\n        internal returns (uint256, uint256) {\r\n        uint256 obtained = 0;\r\n        uint256 remaining = initialRemaining;\r\n\r\n        require(orders.exchangeFees[index] < MAX_EXCHANGE_FEE_PERCENTAGE);\r\n\r\n        uint256 amountToFill = getAmountToFill(remaining, orders, index);\r\n\r\n        if(amountToFill > 0) {\r\n            remaining = SafeMath.sub(remaining, amountToFill);\r\n\r\n            if(buyOrSell == BUY) {\r\n                obtained = ExchangeHandler(orders.exchanges[index]).performBuy.value(amountToFill)(\r\n                    orders.orderAddresses[index],\r\n                    orders.orderValues[index],\r\n                    orders.exchangeFees[index],\r\n                    amountToFill,\r\n                    orders.v[index],\r\n                    orders.r[index],\r\n                    orders.s[index]\r\n                );\r\n            } else {\r\n                require(Token(orders.tokenForOrder[index]).transfer(\r\n                    orders.exchanges[index],\r\n                    amountToFill\r\n                ));\r\n                obtained = ExchangeHandler(orders.exchanges[index]).performSell(\r\n                    orders.orderAddresses[index],\r\n                    orders.orderValues[index],\r\n                    orders.exchangeFees[index],\r\n                    amountToFill,\r\n                    orders.v[index],\r\n                    orders.r[index],\r\n                    orders.s[index]\r\n                );\r\n            }\r\n        }\r\n\r\n        return (obtained == 0 ? initialRemaining: remaining, SafeMath.add(totalObtained, obtained));\r\n    }\r\n\r\n    /// @dev Get the amount of this order we are able to fill\r\n    /// @param remaining Amount we have left to spend\r\n    /// @param orders Struct containing all DEX orders\r\n    /// @param index Value indicating the index of the specific DEX order we wish to execute\r\n    /// @return Minimum of the amount we have left to spend and the available amount at the exchange\r\n    function getAmountToFill(uint256 remaining, DEXOrders orders, uint256 index) internal returns (uint256) {\r\n\r\n        uint256 availableAmount = ExchangeHandler(orders.exchanges[index]).getAvailableAmount(\r\n            orders.orderAddresses[index],\r\n            orders.orderValues[index],\r\n            orders.exchangeFees[index],\r\n            orders.v[index],\r\n            orders.r[index],\r\n            orders.s[index]\r\n        );\r\n\r\n        return Math.min256(remaining, availableAmount);\r\n    }\r\n\r\n    /// @dev Checks whether a given order was valid\r\n    /// @param amountObtained Amount of the order which was obtained\r\n    /// @param amountGiven Amount given in return for amountObtained\r\n    /// @param amountToObtain Amount we intended to obtain\r\n    /// @param amountToGive Amount we intended to give in return for amountToObtain\r\n    /// @return Boolean value indicating whether this order was valid\r\n    function orderWasValid(uint256 amountObtained, uint256 amountGiven, uint256 amountToObtain, uint256 amountToGive) internal pure returns (bool) {\r\n\r\n        if(amountObtained > 0 && amountGiven > 0) {\r\n            // NOTE - Check the edge cases here\r\n            if(amountObtained > amountGiven) {\r\n                return SafeMath.div(amountToObtain, amountToGive) <= SafeMath.div(amountObtained, amountGiven);\r\n            } else {\r\n                return SafeMath.div(amountToGive, amountToObtain) >= SafeMath.div(amountGiven, amountObtained);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function() public payable {\r\n        // Check in here that the sender is a contract! (to stop accidents)\r\n        uint256 size;\r\n        address sender = msg.sender;\r\n        assembly {\r\n            size := extcodesize(sender)\r\n        }\r\n        require(size > 0);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"handler\",\"type\":\"address\"},{\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setHandler\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"name\":\"buyOrSell\",\"type\":\"bool[]\"},{\"name\":\"amountToObtain\",\"type\":\"uint256[]\"},{\"name\":\"amountToGive\",\"type\":\"uint256[]\"},{\"name\":\"tokenForOrder\",\"type\":\"address[]\"},{\"name\":\"exchanges\",\"type\":\"address[]\"},{\"name\":\"orderAddresses\",\"type\":\"address[8][]\"},{\"name\":\"orderValues\",\"type\":\"uint256[6][]\"},{\"name\":\"exchangeFees\",\"type\":\"uint256[]\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"executeOrders\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"handlerWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_EXCHANGE_FEE_PERCENTAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TotlePrimary","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000ad5aa494bcd729b8ea728f581aade049c4ec4e9d","Library":"","SwarmSource":"bzzr://cd31b331b1b1191c7eeb1ec06558a153d8ad5c65dde27d65225b723f84bf8745"}]}