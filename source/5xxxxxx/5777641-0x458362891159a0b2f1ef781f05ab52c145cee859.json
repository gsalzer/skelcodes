{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n* @title ERC20 interface\r\n* @dev see https://github.com/ethereum/EIPs/issues/20\r\n*/\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract CanReclaimToken is Ownable {\r\n    /**\r\n    * @dev Reclaim all ERC20Basic compatible tokens\r\n    * @param token ERC20Basic The address of the token contract\r\n    */\r\n    function reclaimToken(ERC20Basic token) external onlyOwner {\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n    }\r\n}\r\n\r\n/**\r\n* @title Basic token\r\n* @dev Basic version of StandardToken, with no allowances.\r\n*/\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    uint256 totalSupply_;\r\n\r\n    /**\r\n    * @dev total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\n/**\r\n* @title Standard ERC20 token\r\n*\r\n* @dev Implementation of the basic standard token.\r\n* @dev https://github.com/ethereum/EIPs/issues/20\r\n* @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n*/\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n* @title Mintable token\r\n* @dev Simple ERC20 Token example, with mintable token creation\r\n* @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n* Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n*/\r\ncontract MintableToken is StandardToken, Ownable {\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n    bool public mintingFinished = false;\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to mint tokens\r\n    * @param _to The address that will receive the minted tokens.\r\n    * @param _amount The amount of tokens to mint.\r\n    * @return A boolean that indicates if the operation was successful.\r\n    */\r\n    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Mint(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to stop minting new tokens.\r\n    * @return True if the operation was successful.\r\n    */\r\n    function finishMinting() public onlyOwner canMint returns (bool) {\r\n        mintingFinished = true;\r\n        emit MintFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface BLLNDividendInterface {\r\n    function setTokenAddress(address _tokenAddress) external;\r\n    function buyToken() external payable;\r\n    function withdraw(uint256 _amount) external;\r\n    function withdrawTo(address _to, uint256 _amount) external;\r\n    function updateDividendBalance(uint256 _totalSupply, address _address, uint256 _tokensAmount) external;\r\n    function transferTokens(address _from, address _to, uint256 _amount) external returns (bool);\r\n    function shareDividends() external payable;\r\n    function getDividendBalance(address _address) external view returns (uint256);\r\n}\r\n\r\ncontract BLLNToken is MintableToken, CanReclaimToken {\r\n    string public constant name = \"Billion Token\";\r\n    string public constant symbol = \"BLLN\";\r\n    uint32 public constant decimals = 0;\r\n    uint256 public constant maxTotalSupply = 250*(10**6);\r\n    BLLNDividendInterface public dividend;\r\n\r\n    constructor(address _dividendAddress) public {\r\n        require(_dividendAddress != address(0));\r\n        dividend = BLLNDividendInterface(_dividendAddress);\r\n    }\r\n\r\n    modifier canMint() {\r\n        require(totalSupply_ < maxTotalSupply);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDividend() {\r\n        require(msg.sender == address(dividend));\r\n        _;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(msg.data.length == size + 4);\r\n        _;\r\n    }\r\n\r\n    function () public {}\r\n\r\n    function mint(address _to, uint256 _amount) public onlyDividend canMint returns (bool) {\r\n        require(_to != address(0));\r\n        require(_amount != 0);\r\n        uint256 newTotalSupply = totalSupply_.add(_amount);\r\n        require(newTotalSupply <= maxTotalSupply);\r\n\r\n        totalSupply_ = newTotalSupply;\r\n        balances[_to] = balances[_to].add(_amount);\r\n\r\n        dividend.updateDividendBalance(totalSupply_, _to, _amount);\r\n        emit Mint(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public onlyPayloadSize(2*32) returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        require(dividend.transferTokens(msg.sender, _to, _value));\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Log {\r\n    function ln(uint256 _x)  public pure returns (int256) {\r\n        require(_x < 2**255);\r\n        require(_x >= 10**18);\r\n\r\n        int256 epsilon = 1000;\r\n        int256 x = int256(_x);\r\n        int256 result = 0;\r\n        while (x >= 1.5*(10**18)) {\r\n            result = result + 405465108108164381; // log2(1.5)\r\n            x = x * 2 / 3;\r\n        }\r\n        x = x - 10**18;\r\n        int256 next = x;\r\n        int step = 1;\r\n        while (next > epsilon) {\r\n            result = result + (next / step);\r\n            step = step + 1;\r\n            next = next * x / 10**18;\r\n            result = result - (next / step);\r\n            step = step + 1;\r\n            next = next * x / 10**18;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\ncontract BLLNDividend is Ownable, Log, BLLNDividendInterface, CanReclaimToken {\r\n    using SafeMath for uint256;\r\n\r\n    event PresaleFinished();\r\n\r\n    event DividendsArrived(\r\n        uint256 newD_n\r\n    );\r\n\r\n    struct UserHistory {\r\n        uint256 lastD_n;\r\n        uint256 tokens;\r\n    }\r\n\r\n    uint256 internal constant rounding = 10**18;\r\n\r\n    BLLNToken public m_token;\r\n    bool public m_presaleFinished;\r\n    uint256 public m_sharedDividendBalance;\r\n    uint256 public m_maxTotalSupply;\r\n    uint256 public m_tokenPrice = 300 szabo; // 0.11$\r\n    uint256 public m_tokenDiscountThreshold;\r\n\r\n    uint256 public m_D_n;\r\n    uint256 public m_totalTokens;\r\n    mapping (address => uint256) public m_dividendBalances;\r\n    mapping (address => UserHistory) public m_userHistories;\r\n\r\n    constructor(uint256 _maxTotalSupply) public {\r\n        require(_maxTotalSupply > 0);\r\n\r\n        m_presaleFinished = false;\r\n        owner = msg.sender;\r\n        m_maxTotalSupply = _maxTotalSupply;\r\n        m_tokenDiscountThreshold = 10**4;\r\n    }\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == address(m_token));\r\n        _;\r\n    }\r\n\r\n    modifier onlyPresale() {\r\n        require(!m_presaleFinished);\r\n        _;\r\n    }\r\n\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function setTokenAddress(address _tokenAddress) external onlyOwner {\r\n        require(_tokenAddress != address(0));\r\n        m_token = BLLNToken(_tokenAddress);\r\n    }\r\n\r\n    function setTokenDiscountThreshold(uint256 _discountThreshold) external onlyOwner {\r\n        require(_discountThreshold > 0);\r\n        m_tokenDiscountThreshold = _discountThreshold;\r\n    }\r\n\r\n    function mintPresale(uint256 _presaleAmount, address _receiver) external onlyOwner onlyPresale returns (bool) {\r\n        require(_presaleAmount > 0);\r\n        require(_receiver != address(0));\r\n        require(address(m_token) != address(0));\r\n        require(m_token.mint(_receiver, _presaleAmount));\r\n        return true;\r\n    }\r\n\r\n    function finishPresale() external onlyOwner onlyPresale returns (bool) {\r\n        m_presaleFinished = true;\r\n        emit PresaleFinished();\r\n        return true;\r\n    }\r\n\r\n    function buyToken() external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(_amount != 0);\r\n        uint256 userBalance = m_dividendBalances[msg.sender].add(getDividendAmount(msg.sender));\r\n        require(userBalance >= _amount);\r\n\r\n        takeDividends(msg.sender);\r\n\r\n        m_dividendBalances[msg.sender] = userBalance.sub(_amount);\r\n        msg.sender.transfer(_amount);\r\n    }\r\n\r\n    function withdrawTo(address _to, uint256 _amount) external {\r\n        require(_amount != 0);\r\n        require(_to != address(0));\r\n        uint256 userBalance = m_dividendBalances[msg.sender].add(getDividendAmount(msg.sender));\r\n        require(userBalance >= _amount);\r\n\r\n        takeDividends(msg.sender);\r\n\r\n        m_dividendBalances[msg.sender] = userBalance.sub(_amount);\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    function updateDividendBalance(uint256 _totalSupply, address _address, uint256 _tokensAmount) external onlyToken {\r\n        m_totalTokens = m_totalTokens.add(_tokensAmount);\r\n        require(m_totalTokens == _totalSupply);\r\n\r\n        takeDividends(_address);\r\n        m_userHistories[_address].tokens = m_userHistories[_address].tokens.add(_tokensAmount);\r\n    }\r\n\r\n    function transferTokens(address _from, address _to, uint256 _amount) external onlyToken returns (bool) {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        takeDividends(_from);\r\n        takeDividends(_to);\r\n\r\n        m_userHistories[_from].tokens = m_userHistories[_from].tokens.sub(_amount);\r\n        m_userHistories[_to].tokens = m_userHistories[_to].tokens.add(_amount);\r\n        return true;\r\n    }\r\n\r\n    function shareDividends() external onlyOwner payable {\r\n        require(msg.value > 0);\r\n        m_sharedDividendBalance = m_sharedDividendBalance.add(msg.value);\r\n        m_D_n = m_D_n.add(msg.value.mul(rounding).div(m_totalTokens));\r\n\r\n        emit DividendsArrived(m_D_n);\r\n    }\r\n\r\n    function getDividendBalance(address _address) external view returns (uint256) {\r\n        return m_dividendBalances[_address].add(getDividendAmount(_address));\r\n    }\r\n\r\n    function getDividendAmount(address _address) public view returns (uint256) {\r\n        UserHistory memory history = m_userHistories[_address];\r\n        if (history.tokens == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 dividends = m_D_n.sub(history.lastD_n).mul(history.tokens);\r\n\r\n        dividends = dividends.div(rounding);\r\n\r\n        return dividends;\r\n    }\r\n\r\n    function buyTokens(address _receiver) public payable {\r\n        require(msg.value > 0);\r\n\r\n        uint256 totalSupply = m_token.totalSupply();\r\n        uint256 tokens;\r\n        uint256 change;\r\n        (tokens, change) = calculateTokensFrom(msg.value, totalSupply);\r\n        uint256 tokenPrice = msg.value.sub(change);\r\n\r\n        m_sharedDividendBalance = m_sharedDividendBalance.add(tokenPrice);\r\n\r\n        m_D_n = m_D_n.add(tokenPrice.mul(rounding).div(m_totalTokens));\r\n        m_dividendBalances[_receiver] = m_dividendBalances[_receiver].add(change);\r\n\r\n        require(m_token.mint(_receiver, tokens));\r\n        emit DividendsArrived(m_D_n);\r\n    }\r\n\r\n    function calculateTokensFrom(uint256 _value, uint256 _totalSupply) public view returns (uint256, uint256) {\r\n        require(_value >= m_tokenPrice);\r\n        return calculateTokensAmountToSale(_value, _totalSupply);\r\n    }\r\n\r\n    function priceFor(uint256 _tokenAmount) public view returns (uint256) {\r\n        uint256 price = m_tokenPrice.mul(_tokenAmount);\r\n        return price;\r\n    }\r\n\r\n    function priceWithDiscount(uint256 _tokenAmount, uint256 _totalTokens) public view returns (uint256) {\r\n        uint256 s = _totalTokens.add(_tokenAmount).mul(rounding).div(_totalTokens);\r\n        int256 log = ln(s);\r\n        return m_tokenPrice.mul(_totalTokens).mul(uint256(log)).div(rounding);\r\n    }\r\n\r\n    function tokensAmountFrom(uint256 _value) public view returns (uint256) {\r\n        uint256 tokensAmount = _value.div(m_tokenPrice);\r\n        return tokensAmount;\r\n    }\r\n\r\n    // MARK: Private functions\r\n    function takeDividends(address _user) private {\r\n        uint256 userAmount = getDividendAmount(_user);\r\n        m_userHistories[_user].lastD_n = m_D_n;\r\n        if (userAmount == 0) {\r\n            return;\r\n        }\r\n        m_dividendBalances[_user] = m_dividendBalances[_user].add(userAmount);\r\n        m_sharedDividendBalance = m_sharedDividendBalance.sub(userAmount);\r\n    }\r\n\r\n    function calculateTokensAmountToSale(uint256 _value, uint256 _totalSupply) private view returns (uint256, uint256) {\r\n        uint256 maxTotalSupply = m_maxTotalSupply;\r\n        require(_totalSupply < maxTotalSupply);\r\n\r\n        uint256 remainingTokens = maxTotalSupply.sub(_totalSupply);\r\n        uint256 remainingPrice = priceFor(remainingTokens);\r\n\r\n        if (remainingPrice < _value) {\r\n            return (remainingTokens, _value - remainingPrice);\r\n        }\r\n\r\n        uint256 approxTokens = tokensAmountFrom(_value);\r\n        uint256 approxPrice;\r\n\r\n        if (approxTokens >= m_tokenDiscountThreshold) {\r\n            approxPrice = priceWithDiscount(approxTokens, _totalSupply);\r\n        } else {\r\n            approxPrice = priceFor(approxTokens);\r\n        }\r\n\r\n        uint256 change = _value.sub(approxPrice);\r\n        return (approxTokens, change);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"calculateTokensFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_x\",\"type\":\"uint256\"}],\"name\":\"ln\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_totalTokens\",\"type\":\"uint256\"}],\"name\":\"priceWithDiscount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDividendBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_tokensAmount\",\"type\":\"uint256\"}],\"name\":\"updateDividendBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_discountThreshold\",\"type\":\"uint256\"}],\"name\":\"setTokenDiscountThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_tokenDiscountThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDividendAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_maxTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"m_userHistories\",\"outputs\":[{\"name\":\"lastD_n\",\"type\":\"uint256\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"priceFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_presaleFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"tokensAmountFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_D_n\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presaleAmount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"mintPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shareDividends\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_sharedDividendBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"m_dividendBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_maxTotalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PresaleFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newD_n\",\"type\":\"uint256\"}],\"name\":\"DividendsArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BLLNDividend","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000ee6b280","Library":"","SwarmSource":"bzzr://dee56cd64d975c2debfe372ec5459c51d13da1b08f02bd6890f3ae97799afcd6"}]}