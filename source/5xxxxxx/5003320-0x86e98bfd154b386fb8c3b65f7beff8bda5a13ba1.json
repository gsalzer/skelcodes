{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract ERC20Token {\r\n    using SafeMath for uint;\r\n\r\n    string public constant symbol = \"EBT\";\r\n    string public constant name = \"EtherSweep Token\";\r\n    uint8 public constant decimals = 9;\r\n    uint public totalSupply = 0;\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    function balanceOf(address tokenOwner) public constant returns (uint) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    function transfer(address to, uint tokens) public returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint tokens) public returns (bool) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool) {\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract ICO is ERC20Token, Owned {\r\n    uint private constant icoPart = 40;\r\n    uint private constant priceStart =  300000000000000 wei;\r\n    uint private constant priceEnd   = 1000000000000000 wei;\r\n    uint private icoBegin;\r\n    uint public icoEnd;\r\n\r\n    function ICO(uint duration) public {\r\n        icoBegin = now;\r\n        icoEnd = icoBegin.add(duration);\r\n    }\r\n\r\n    function icoTokenPrice() public constant returns (uint) {\r\n        require(now <= icoEnd);\r\n        return priceStart.add(priceEnd.sub(priceStart).mul(now.sub(icoBegin)).div(icoEnd.sub(icoBegin)));\r\n    }\r\n\r\n    function () public payable {\r\n        require(now <= icoEnd && msg.value > 0);\r\n        uint coins = msg.value.mul(uint(10)**decimals).div(icoTokenPrice());\r\n        totalSupply = totalSupply.add(coins.mul(100).div(icoPart));\r\n        balances[msg.sender] = balances[msg.sender].add(coins);\r\n        Transfer(address(0), msg.sender, coins);\r\n        coins = coins.mul(100 - icoPart).div(icoPart);\r\n        balances[owner] = balances[owner].add(coins);\r\n        Transfer(address(0), owner, coins);\r\n    }\r\n}\r\n\r\ncontract EtherSweepToken is ICO {\r\n    enum Winner {\r\n        First, Draw, Second, Cancelled, None\r\n    }\r\n\r\n    struct BetEvent {\r\n        uint from;\r\n        uint until;\r\n        string category;\r\n        string tournament;\r\n        string player1;\r\n        string player2;\r\n        bool drawAllowed;\r\n        Winner winner;\r\n    }\r\n\r\n    struct Bet {\r\n        address user;\r\n        Winner winner;\r\n        uint amount;\r\n    }\r\n\r\n    uint8 public constant comission = 5;\r\n    uint public reserved = 0;\r\n    BetEvent[] public betEvents;\r\n    mapping(uint => Bet[]) public bets;\r\n\r\n    function EtherSweepToken() public ICO(60*60*24*30) {\r\n    }\r\n\r\n    function availableBalance() public constant returns (uint) {\r\n        return this.balance.sub(reserved);\r\n    }\r\n\r\n    function withdraw(uint amount) public {\r\n        require(amount > 0);\r\n        var toTransfer = amount.mul(availableBalance()).div(totalSupply);\r\n        balances[msg.sender] = balances[msg.sender].sub(amount);\r\n        totalSupply = totalSupply.sub(amount);\r\n        msg.sender.transfer(toTransfer);\r\n    }\r\n\r\n    function betOpen(uint duration, string category, string tournament, string player1, string player2, bool drawAllowed) public onlyOwner {\r\n        betEvents.push(BetEvent(now, now.add(duration), category, tournament, player1, player2, drawAllowed, Winner.None));\r\n    }\r\n\r\n    function getEventBanks(uint eventId) public constant returns (uint[3] banks) {\r\n        require(eventId < betEvents.length);\r\n        for (uint i = 0; i < bets[eventId].length; i++) {\r\n            Bet storage bet = bets[eventId][i];\r\n            banks[uint(bet.winner)] = banks[uint(bet.winner)].add(bet.amount);\r\n        }\r\n    }\r\n\r\n    function betFinalize(uint eventId, Winner winner) public onlyOwner {\r\n        BetEvent storage betEvent = betEvents[eventId];\r\n        require(winner < Winner.None && betEvent.winner == Winner.None && ((winner != Winner.Draw) || betEvent.drawAllowed) && eventId < betEvents.length && now > betEvent.until);\r\n        betEvent.winner = winner;\r\n        uint[3] memory banks = getEventBanks(eventId);\r\n        reserved = reserved.sub(banks[0]).sub(banks[1]).sub(banks[2]);\r\n        if (winner == Winner.Cancelled) {\r\n            for (uint i = 0; i < bets[eventId].length; i++) {\r\n                Bet storage bet = bets[eventId][i];\r\n                bet.user.transfer(bet.amount);\r\n            }\r\n        } else {\r\n            uint loserBank = banks[0].add(banks[1]).add(banks[2]).sub(banks[uint(winner)]).mul(100 - comission).div(100);\r\n            uint winnerBank = banks[uint(winner)];\r\n    \r\n            for (i = 0; i < bets[eventId].length; i++) {\r\n                bet = bets[eventId][i];\r\n                if (bet.winner == winner) {\r\n                    bet.user.transfer(bet.amount.add(bet.amount.mul(loserBank).div(winnerBank)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function betMake(uint eventId, Winner winner) public payable {\r\n        require(winner != Winner.Cancelled && winner < Winner.None && ((winner != Winner.Draw) || betEvents[eventId].drawAllowed) && msg.value > 0 && eventId < betEvents.length && now <= betEvents[eventId].until);\r\n        bets[eventId].push(Bet(msg.sender, winner, msg.value));\r\n        reserved = reserved.add(msg.value);\r\n    }\r\n\r\n    function getEvents(uint from, string category, uint mode) public constant returns (uint cnt, uint[20] res) {\r\n        require(mode < 3 && from <= betEvents.length);\r\n        bytes32 categoryHash = keccak256(category);\r\n        cnt = 0;\r\n        for (int i = int(from == 0 ? betEvents.length : from)-1; i >= 0; i--) {\r\n            uint index = uint(i);\r\n            if ((mode == 0 ? betEvents[index].until >= now : (mode == 1 ? betEvents[index].until < now && betEvents[index].winner == Winner.None : (mode == 2 ? betEvents[index].winner != Winner.None : false))) && (keccak256(betEvents[index].category) == categoryHash)) {\r\n                res[cnt++] = index;\r\n                if (cnt == res.length) break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getEventsCount() public constant returns (uint) {\r\n        return betEvents.length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"icoEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betEvents\",\"outputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"until\",\"type\":\"uint256\"},{\"name\":\"category\",\"type\":\"string\"},{\"name\":\"tournament\",\"type\":\"string\"},{\"name\":\"player1\",\"type\":\"string\"},{\"name\":\"player2\",\"type\":\"string\"},{\"name\":\"drawAllowed\",\"type\":\"bool\"},{\"name\":\"winner\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"getEventBanks\",\"outputs\":[{\"name\":\"banks\",\"type\":\"uint256[3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"uint8\"}],\"name\":\"betFinalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"winner\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"category\",\"type\":\"string\"},{\"name\":\"mode\",\"type\":\"uint256\"}],\"name\":\"getEvents\",\"outputs\":[{\"name\":\"cnt\",\"type\":\"uint256\"},{\"name\":\"res\",\"type\":\"uint256[20]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"uint8\"}],\"name\":\"betMake\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"category\",\"type\":\"string\"},{\"name\":\"tournament\",\"type\":\"string\"},{\"name\":\"player1\",\"type\":\"string\"},{\"name\":\"player2\",\"type\":\"string\"},{\"name\":\"drawAllowed\",\"type\":\"bool\"}],\"name\":\"betOpen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EtherSweepToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a1c885f20ef4236a072b5cfc8e368dd622fb3fc59c702e0a6a08d4a2d1d00523"}]}