{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.2;\r\n\r\n// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n  \t// Required methods\r\n  \tfunction approve(address _to, uint256 _tokenId) public;\r\n  \tfunction balanceOf(address _owner) public view returns (uint256 balance);\r\n  \tfunction implementsERC721() public pure returns (bool);\r\n  \tfunction ownerOf(uint256 _tokenId) public view returns (address addr);\r\n  \tfunction takeOwnership(uint256 _tokenId) public;\r\n  \tfunction totalSupply() public view returns (uint256 total);\r\n  \tfunction transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  \tfunction transfer(address _to, uint256 _tokenId) public;\r\n\t\r\n  \tevent Transfer(address indexed from, address indexed to, uint256 tokenId);\r\n  \tevent Approval(address indexed owner, address indexed approved, uint256 tokenId);\r\n}\r\n\r\ncontract Elements is ERC721 {\r\n\r\n  \t/*** EVENTS ***/\r\n  \t// @dev The Birth event is fired whenever a new element comes into existence.\r\n  \tevent Birth(uint256 tokenId, string name, address owner);\r\n\r\n  \t// @dev The TokenSold event is fired whenever a token is sold.\r\n  \tevent TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);\r\n\r\n  \t// @dev Transfer event as defined in current draft of ERC721. Ownership is assigned, including births.\r\n  \tevent Transfer(address from, address to, uint256 tokenId);\r\n\r\n  \t/*** CONSTANTS, VARIABLES ***/\r\n\r\n\t// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n\tstring public constant NAME = \"CryptoElements\"; // solhint-disable-line\r\n\tstring public constant SYMBOL = \"CREL\"; // solhint-disable-line\r\n\r\n  \tuint256 private periodicStartingPrice = 5 ether;\r\n  \tuint256 private elementStartingPrice = 0.005 ether;\r\n  \tuint256 private scientistStartingPrice = 0.1 ether;\r\n  \tuint256 private specialStartingPrice = 0.05 ether;\r\n\r\n  \tuint256 private firstStepLimit =  0.05 ether;\r\n  \tuint256 private secondStepLimit = 0.75 ether;\r\n  \tuint256 private thirdStepLimit = 3 ether;\r\n\r\n  \tbool private periodicTableExists = false;\r\n\r\n  \tuint256 private elementCTR = 0;\r\n  \tuint256 private scientistCTR = 0;\r\n  \tuint256 private specialCTR = 0;\r\n\r\n  \tuint256 private constant elementSTART = 1;\r\n  \tuint256 private constant scientistSTART = 1000;\r\n  \tuint256 private constant specialSTART = 10000;\r\n\r\n  \tuint256 private constant specialLIMIT = 5000;\r\n\r\n  \t/*** STORAGE ***/\r\n\r\n  \t// @dev A mapping from element IDs to the address that owns them. All elements have\r\n  \t//  some valid owner address.\r\n  \tmapping (uint256 => address) public elementIndexToOwner;\r\n\r\n  \t// @dev A mapping from owner address to count of tokens that address owns.\r\n  \t//  Used internally inside balanceOf() to resolve ownership count.\r\n  \tmapping (address => uint256) private ownershipTokenCount;\r\n\r\n  \t// @dev A mapping from ElementIDs to an address that has been approved to call\r\n  \t//  transferFrom(). Each Element can only have one approved address for transfer\r\n  \t//  at any time. A zero value means no approval is outstanding.\r\n  \tmapping (uint256 => address) public elementIndexToApproved;\r\n\r\n  \t// @dev A mapping from ElementIDs to the price of the token.\r\n  \tmapping (uint256 => uint256) private elementIndexToPrice;\r\n\r\n  \t// The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n  \taddress public ceoAddress;\r\n  \taddress public cooAddress;\r\n\r\n  \t/*** DATATYPES ***/\r\n  \tstruct Element {\r\n  \t\tuint256 tokenId;\r\n    \tstring name;\r\n    \tuint256 scientistId;\r\n  \t}\r\n\r\n  \tmapping(uint256 => Element) elements;\r\n\r\n  \tuint256[] tokens;\r\n\r\n  \t/*** ACCESS MODIFIERS ***/\r\n  \t// @dev Access modifier for CEO-only functionality\r\n  \tmodifier onlyCEO() {\r\n    \trequire(msg.sender == ceoAddress);\r\n    \t_;\r\n  \t}\r\n\r\n  \t// @dev Access modifier for COO-only functionality\r\n  \tmodifier onlyCOO() {\r\n  \t  require(msg.sender == cooAddress);\r\n  \t  _;\r\n  \t}\r\n\r\n  \t// Access modifier for contract owner only functionality\r\n  \tmodifier onlyCLevel() {\r\n  \t  \trequire(\r\n  \t    \tmsg.sender == ceoAddress ||\r\n  \t    \tmsg.sender == cooAddress\r\n  \t  \t);\r\n  \t  \t_;\r\n  \t}\r\n\r\n  \t/*** CONSTRUCTOR ***/\r\n  \tfunction Elements() public {\r\n  \t  \tceoAddress = msg.sender;\r\n  \t  \tcooAddress = msg.sender;\r\n\r\n  \t  \tcreateContractPeriodicTable(\"Periodic\");\r\n  \t}\r\n\r\n  \t/*** PUBLIC FUNCTIONS ***/\r\n  \t// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\r\n  \t// @param _to The address to be granted transfer approval. Pass address(0) to\r\n  \t//  clear all approvals.\r\n  \t// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  \t// @dev Required for ERC-721 compliance.\r\n  \tfunction approve(address _to, uint256 _tokenId) public {\r\n  \t  \t// Caller must own token.\r\n  \t  \trequire(_owns(msg.sender, _tokenId));\r\n\t\r\n\t  \telementIndexToApproved[_tokenId] = _to;\r\n\t\r\n\t  \tApproval(msg.sender, _to, _tokenId);\r\n  \t}\r\n\r\n  \t// For querying balance of a particular account\r\n  \t// @param _owner The address for balance query\r\n  \t// @dev Required for ERC-721 compliance.\r\n  \tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n    \treturn ownershipTokenCount[_owner];\r\n  \t}\r\n\r\n  \t// @notice Returns all the relevant information about a specific element.\r\n  \t// @param _tokenId The tokenId of the element of interest.\r\n  \tfunction getElement(uint256 _tokenId) public view returns (\r\n  \t\tuint256 tokenId,\r\n    \tstring elementName,\r\n    \tuint256 sellingPrice,\r\n    \taddress owner,\r\n    \tuint256 scientistId\r\n  \t) {\r\n    \tElement storage element = elements[_tokenId];\r\n    \ttokenId = element.tokenId;\r\n    \telementName = element.name;\r\n    \tsellingPrice = elementIndexToPrice[_tokenId];\r\n    \towner = elementIndexToOwner[_tokenId];\r\n    \tscientistId = element.scientistId;\r\n  \t}\r\n\r\n  \tfunction implementsERC721() public pure returns (bool) {\r\n    \treturn true;\r\n  \t}\r\n\r\n  \t// For querying owner of token\r\n  \t// @param _tokenId The tokenID for owner inquiry\r\n  \t// @dev Required for ERC-721 compliance.\r\n  \tfunction ownerOf(uint256 _tokenId) public view returns (address owner) {\r\n    \towner = elementIndexToOwner[_tokenId];\r\n    \trequire(owner != address(0));\r\n  \t}\r\n\r\n  \tfunction payout(address _to) public onlyCLevel {\r\n    \t_payout(_to);\r\n  \t}\r\n\r\n  \t// Allows someone to send ether and obtain the token\r\n  \tfunction purchase(uint256 _tokenId) public payable {\r\n    \taddress oldOwner = elementIndexToOwner[_tokenId];\r\n    \taddress newOwner = msg.sender;\r\n\r\n    \tuint256 sellingPrice = elementIndexToPrice[_tokenId];\r\n    \t// Making sure token owner is not sending to self\r\n    \trequire(oldOwner != newOwner);\r\n    \trequire(sellingPrice > 0);\r\n\r\n    \t// Safety check to prevent against an unexpected 0x0 default.\r\n    \trequire(_addressNotNull(newOwner));\r\n\r\n    \t// Making sure sent amount is greater than or equal to the sellingPrice\r\n    \trequire(msg.value >= sellingPrice);\r\n\r\n    \tuint256 ownerPayout = SafeMath.mul(SafeMath.div(sellingPrice, 100), 96);\r\n    \tuint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\r\n    \tuint256\tfeeOnce = SafeMath.div(SafeMath.sub(sellingPrice, ownerPayout), 4);\r\n    \tuint256 fee_for_dev = SafeMath.mul(feeOnce, 2);\r\n\r\n    \t// Pay previous tokenOwner if owner is not contract\r\n    \t// and if previous price is not 0\r\n    \tif (oldOwner != address(this)) {\r\n      \t\t// old owner gets entire initial payment back\r\n      \t\toldOwner.transfer(ownerPayout);\r\n    \t} else {\r\n      \t\tfee_for_dev = SafeMath.add(fee_for_dev, ownerPayout);\r\n    \t}\r\n\r\n    \t// Taxes for Periodic Table owner\r\n\t    if (elementIndexToOwner[0] != address(this)) {\r\n\t    \telementIndexToOwner[0].transfer(feeOnce);\r\n\t    } else {\r\n\t    \tfee_for_dev = SafeMath.add(fee_for_dev, feeOnce);\r\n\t    }\r\n\r\n\t    // Taxes for Scientist Owner for given Element\r\n\t    uint256 scientistId = elements[_tokenId].scientistId;\r\n\r\n\t    if ( scientistId != scientistSTART ) {\r\n\t    \tif (elementIndexToOwner[scientistId] != address(this)) {\r\n\t\t    \telementIndexToOwner[scientistId].transfer(feeOnce);\r\n\t\t    } else {\r\n\t\t    \tfee_for_dev = SafeMath.add(fee_for_dev, feeOnce);\r\n\t\t    }\r\n\t    } else {\r\n\t    \tfee_for_dev = SafeMath.add(fee_for_dev, feeOnce);\r\n\t    }\r\n\t        \r\n    \tif (purchaseExcess > 0) {\r\n    \t\tmsg.sender.transfer(purchaseExcess);\r\n    \t}\r\n\r\n    \tceoAddress.transfer(fee_for_dev);\r\n\r\n    \t_transfer(oldOwner, newOwner, _tokenId);\r\n\r\n    \t//TokenSold(_tokenId, sellingPrice, elementIndexToPrice[_tokenId], oldOwner, newOwner, elements[_tokenId].name);\r\n    \t// Update prices\r\n    \tif (sellingPrice < firstStepLimit) {\r\n      \t\t// first stage\r\n      \t\telementIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 200), 100);\r\n    \t} else if (sellingPrice < secondStepLimit) {\r\n      \t\t// second stage\r\n      \t\telementIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 150), 100);\r\n    \t} else if (sellingPrice < thirdStepLimit) {\r\n    \t  \t// third stage\r\n      \t\telementIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 130), 100);\r\n    \t} else {\r\n      \t\t// fourth stage\r\n      \t\telementIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 115), 100);\r\n    \t}\r\n  \t}\r\n\r\n  \tfunction priceOf(uint256 _tokenId) public view returns (uint256 price) {\r\n\t    return elementIndexToPrice[_tokenId];\r\n  \t}\r\n\r\n  \t// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n  \t// @param _newCEO The address of the new CEO\r\n  \tfunction setCEO(address _newCEO) public onlyCEO {\r\n\t    require(_newCEO != address(0));\r\n\r\n    \tceoAddress = _newCEO;\r\n  \t}\r\n\r\n  \t// @dev Assigns a new address to act as the COO. Only available to the current COO.\r\n  \t// @param _newCOO The address of the new COO\r\n  \tfunction setCOO(address _newCOO) public onlyCEO {\r\n    \trequire(_newCOO != address(0));\r\n    \tcooAddress = _newCOO;\r\n  \t}\r\n\r\n  \t// @notice Allow pre-approved user to take ownership of a token\r\n  \t// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  \t// @dev Required for ERC-721 compliance.\r\n  \tfunction takeOwnership(uint256 _tokenId) public {\r\n    \taddress newOwner = msg.sender;\r\n    \taddress oldOwner = elementIndexToOwner[_tokenId];\r\n\r\n    \t// Safety check to prevent against an unexpected 0x0 default.\r\n    \trequire(_addressNotNull(newOwner));\r\n\r\n    \t// Making sure transfer is approved\r\n    \trequire(_approved(newOwner, _tokenId));\r\n\r\n    \t_transfer(oldOwner, newOwner, _tokenId);\r\n  \t}\r\n\r\n  \t// @param _owner The owner whose element tokens we are interested in.\r\n  \t// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n  \t//  expensive (it walks the entire Elements array looking for elements belonging to owner),\r\n  \t//  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n  \t//  not contract-to-contract calls.\r\n  \tfunction tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\r\n    \tuint256 tokenCount = balanceOf(_owner);\r\n    \tif (tokenCount == 0) {\r\n        \t// Return an empty array\r\n      \t\treturn new uint256[](0);\r\n    \t} else {\r\n      \t\tuint256[] memory result = new uint256[](tokenCount);\r\n      \t\tuint256 totalElements = totalSupply();\r\n      \t\tuint256 resultIndex = 0;\r\n      \t\tuint256 elementId;\r\n      \t\tfor (elementId = 0; elementId < totalElements; elementId++) {\r\n      \t\t\tuint256 tokenId = tokens[elementId];\r\n\r\n\t\t        if (elementIndexToOwner[tokenId] == _owner) {\r\n\t\t          result[resultIndex] = tokenId;\r\n\t\t          resultIndex++;\r\n\t\t        }\r\n      \t\t}\r\n      \t\treturn result;\r\n    \t}\r\n  \t}\r\n\r\n  \t// For querying totalSupply of token\r\n  \t// @dev Required for ERC-721 compliance.\r\n  \tfunction totalSupply() public view returns (uint256 total) {\r\n    \treturn tokens.length;\r\n  \t}\r\n\r\n  \t// Owner initates the transfer of the token to another account\r\n  \t// @param _to The address for the token to be transferred to.\r\n  \t// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  \t// @dev Required for ERC-721 compliance.\r\n  \tfunction transfer( address _to, uint256 _tokenId ) public {\r\n   \t\trequire(_owns(msg.sender, _tokenId));\r\n    \trequire(_addressNotNull(_to));\r\n    \t_transfer(msg.sender, _to, _tokenId);\r\n  \t}\r\n\r\n  \t// Third-party initiates transfer of token from address _from to address _to\r\n  \t// @param _from The address for the token to be transferred from.\r\n  \t// @param _to The address for the token to be transferred to.\r\n  \t// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  \t// @dev Required for ERC-721 compliance.\r\n  \tfunction transferFrom( address _from, address _to, uint256 _tokenId) public {\r\n    \trequire(_owns(_from, _tokenId));\r\n    \trequire(_approved(_to, _tokenId));\r\n    \trequire(_addressNotNull(_to));\r\n    \t_transfer(_from, _to, _tokenId);\r\n  \t}\r\n\r\n  \t/*** PRIVATE FUNCTIONS ***/\r\n  \t// Safety check on _to address to prevent against an unexpected 0x0 default.\r\n  \tfunction _addressNotNull(address _to) private pure returns (bool) {\r\n    \treturn _to != address(0);\r\n  \t}\r\n\r\n  \t// For checking approval of transfer for address _to\r\n\tfunction _approved(address _to, uint256 _tokenId) private view returns (bool) {\r\n\t\treturn elementIndexToApproved[_tokenId] == _to;\r\n\t}\r\n\r\n  \t// Private method for creating Element\r\n  \tfunction _createElement(uint256 _id, string _name, address _owner, uint256 _price, uint256 _scientistId) private returns (string) {\r\n\r\n    \tuint256 newElementId = _id;\r\n    \t// It's probably never going to happen, 4 billion tokens are A LOT, but\r\n    \t// let's just be 100% sure we never let this happen.\r\n    \trequire(newElementId == uint256(uint32(newElementId)));\r\n\r\n    \telements[_id] = Element(_id, _name, _scientistId);\r\n\r\n    \tBirth(newElementId, _name, _owner);\r\n\r\n    \telementIndexToPrice[newElementId] = _price;\r\n\r\n    \t// This will assign ownership, and also emit the Transfer event as\r\n    \t// per ERC721 draft\r\n    \t_transfer(address(0), _owner, newElementId);\r\n\r\n    \ttokens.push(_id);\r\n\r\n    \treturn _name;\r\n  \t}\r\n\r\n\r\n  \t// @dev Creates Periodic Table as first element\r\n  \tfunction createContractPeriodicTable(string _name) public onlyCEO {\r\n  \t\trequire(periodicTableExists == false);\r\n\r\n  \t\t_createElement(0, _name, address(this), periodicStartingPrice, scientistSTART);\r\n  \t\tperiodicTableExists = true;\r\n  \t}\r\n\r\n  \t// @dev Creates a new Element with the given name and Id\r\n  \tfunction createContractElement(string _name, uint256 _scientistId) public onlyCEO {\r\n  \t\trequire(periodicTableExists == true);\r\n\r\n    \tuint256 _id = SafeMath.add(elementCTR, elementSTART);\r\n    \tuint256 _scientistIdProcessed = SafeMath.add(_scientistId, scientistSTART);\r\n\r\n    \t_createElement(_id, _name, address(this), elementStartingPrice, _scientistIdProcessed);\r\n    \telementCTR = SafeMath.add(elementCTR, 1);\r\n  \t}\r\n\r\n  \t// @dev Creates a new Scientist with the given name Id\r\n  \tfunction createContractScientist(string _name) public onlyCEO {\r\n  \t\trequire(periodicTableExists == true);\r\n\r\n  \t\t// to start from 1001\r\n  \t\tscientistCTR = SafeMath.add(scientistCTR, 1);\r\n    \tuint256 _id = SafeMath.add(scientistCTR, scientistSTART);\r\n    \t\r\n    \t_createElement(_id, _name, address(this), scientistStartingPrice, scientistSTART);\t\r\n  \t}\r\n\r\n  \t// @dev Creates a new Special Card with the given name Id\r\n  \tfunction createContractSpecial(string _name) public onlyCEO {\r\n  \t\trequire(periodicTableExists == true);\r\n  \t\trequire(specialCTR <= specialLIMIT);\r\n\r\n  \t\t// to start from 10001\r\n  \t\tspecialCTR = SafeMath.add(specialCTR, 1);\r\n    \tuint256 _id = SafeMath.add(specialCTR, specialSTART);\r\n\r\n    \t_createElement(_id, _name, address(this), specialStartingPrice, scientistSTART);\r\n    \t\r\n  \t}\r\n\r\n  \t// Check for token ownership\r\n  \tfunction _owns(address claimant, uint256 _tokenId) private view returns (bool) {\r\n    \treturn claimant == elementIndexToOwner[_tokenId];\r\n  \t}\r\n\r\n\r\n  \t//**** HELPERS for checking elements, scientists and special cards\r\n  \tfunction checkPeriodic() public view returns (bool) {\r\n  \t\treturn periodicTableExists;\r\n  \t}\r\n\r\n  \tfunction getTotalElements() public view returns (uint256) {\r\n  \t\treturn elementCTR;\r\n  \t}\r\n\r\n  \tfunction getTotalScientists() public view returns (uint256) {\r\n  \t\treturn scientistCTR;\r\n  \t}\r\n\r\n  \tfunction getTotalSpecials() public view returns (uint256) {\r\n  \t\treturn specialCTR;\r\n  \t}\r\n\r\n  \t//**** HELPERS for changing prices limits and steps if it would be bad, community would like different\r\n  \tfunction changeStartingPricesLimits(uint256 _elementStartPrice, uint256 _scientistStartPrice, uint256 _specialStartPrice) public onlyCEO {\r\n  \t\telementStartingPrice = _elementStartPrice;\r\n  \t\tscientistStartingPrice = _scientistStartPrice;\r\n  \t\tspecialStartingPrice = _specialStartPrice;\r\n\t}\r\n\r\n\tfunction changeStepPricesLimits(uint256 _first, uint256 _second, uint256 _third) public onlyCEO {\r\n\t\tfirstStepLimit = _first;\r\n\t\tsecondStepLimit = _second;\r\n\t\tthirdStepLimit = _third;\r\n\t}\r\n\r\n\t// in case of error when assigning scientist to given element\r\n\tfunction changeScientistForElement(uint256 _tokenId, uint256 _scientistId) public onlyCEO {\r\n    \tElement storage element = elements[_tokenId];\r\n    \telement.scientistId = SafeMath.add(_scientistId, scientistSTART);\r\n  \t}\r\n\r\n  \tfunction changeElementName(uint256 _tokenId, string _name) public onlyCEO {\r\n    \tElement storage element = elements[_tokenId];\r\n    \telement.name = _name;\r\n  \t}\r\n\r\n  \t// This function can be used by the owner of a token to modify the current price\r\n\tfunction modifyTokenPrice(uint256 _tokenId, uint256 _newPrice) public payable {\r\n\t    require(_newPrice > elementStartingPrice);\r\n\t    require(elementIndexToOwner[_tokenId] == msg.sender);\r\n\t    require(_newPrice < elementIndexToPrice[_tokenId]);\r\n\r\n\t    if ( _tokenId == 0) {\r\n\t    \trequire(_newPrice > periodicStartingPrice);\r\n\t    } else if ( _tokenId < 1000) {\r\n\t    \trequire(_newPrice > elementStartingPrice);\r\n\t    } else if ( _tokenId < 10000 ) {\r\n\t    \trequire(_newPrice > scientistStartingPrice);\r\n\t    } else {\r\n\t    \trequire(_newPrice > specialStartingPrice);\r\n\t    }\r\n\r\n\t    elementIndexToPrice[_tokenId] = _newPrice;\r\n\t}\r\n\r\n  \t// For paying out balance on contract\r\n  \tfunction _payout(address _to) private {\r\n    \tif (_to == address(0)) {\r\n      \t\tceoAddress.transfer(this.balance);\r\n    \t} else {\r\n      \t\t_to.transfer(this.balance);\r\n    \t}\r\n  \t}\r\n\r\n  \t// @dev Assigns ownership of a specific Element to an address.\r\n  \tfunction _transfer(address _from, address _to, uint256 _tokenId) private {\r\n  \t  \t// Since the number of elements is capped to 2^32 we can't overflow this\r\n  \t  \townershipTokenCount[_to]++;\r\n  \t  \t//transfer ownership\r\n  \t  \telementIndexToOwner[_tokenId] = _to;\r\n  \t  \t// When creating new elements _from is 0x0, but we can't account that address.\r\n  \t  \tif (_from != address(0)) {\r\n  \t    \townershipTokenCount[_from]--;\r\n  \t    \t// clear any previously approved ownership exchange\r\n  \t    \tdelete elementIndexToApproved[_tokenId];\r\n  \t  \t}\r\n  \t  \t// Emit the transfer event.\r\n  \t  \tTransfer(_from, _to, _tokenId);\r\n  \t}\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  \t/**\r\n  \t* @dev Multiplies two numbers, throws on overflow.\r\n  \t*/\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t  return 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n  \t/**\r\n  \t* @dev Integer division of two numbers, truncating the quotient.\r\n  \t*/\r\n  \tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    \tuint256 c = a / b;\r\n    \t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    \treturn c;\r\n  \t}\r\n\r\n  \t/**\r\n  \t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  \t*/\r\n  \tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \tassert(b <= a);\r\n    \treturn a - b;\r\n  \t}\r\n\r\n  \t/**\r\n  \t* @dev Adds two numbers, throws on overflow.\r\n  \t*/\r\n  \tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    \tuint256 c = a + b;\r\n    \tassert(c >= a);\r\n    \treturn c;\r\n  \t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"createContractSpecial\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_scientistId\",\"type\":\"uint256\"}],\"name\":\"changeScientistForElement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSpecials\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"createContractScientist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getElement\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"elementName\",\"type\":\"string\"},{\"name\":\"sellingPrice\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"scientistId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_first\",\"type\":\"uint256\"},{\"name\":\"_second\",\"type\":\"uint256\"},{\"name\":\"_third\",\"type\":\"uint256\"}],\"name\":\"changeStepPricesLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalElements\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_scientistId\",\"type\":\"uint256\"}],\"name\":\"createContractElement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalScientists\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"elementIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"modifyTokenPrice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_elementStartPrice\",\"type\":\"uint256\"},{\"name\":\"_scientistStartPrice\",\"type\":\"uint256\"},{\"name\":\"_specialStartPrice\",\"type\":\"uint256\"}],\"name\":\"changeStartingPricesLimits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"elementIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkPeriodic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"createContractPeriodicTable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"changeElementName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Birth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Elements","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a995bc6040274c97a38bd1325215082a81d653add7ac984d8b4ecdc0996ab121"}]}