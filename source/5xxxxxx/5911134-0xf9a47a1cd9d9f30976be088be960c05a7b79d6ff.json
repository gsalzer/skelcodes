{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n/**\r\n* @title TECH ICO Contract\r\n* @dev TECH is an ERC-20 Standar Compliant Token\r\n* Contact: WorkChainCenters@gmail.com  www.WorkChainCenters.io\r\n*/\r\n\r\n/**\r\n * @title SafeMath by OpenZeppelin\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title admined\r\n * @notice This contract is administered\r\n */\r\ncontract admined {\r\n    //mapping to user levels\r\n    mapping(address => uint8) public level;\r\n    //0 normal user\r\n    //1 basic admin\r\n    //2 master admin\r\n\r\n    /**\r\n    * @dev This contructor takes the msg.sender as the first master admin\r\n    */\r\n    constructor() internal {\r\n        level[msg.sender] = 2; //Set initial admin to contract creator\r\n        emit AdminshipUpdated(msg.sender,2); //Log the admin set\r\n    }\r\n\r\n    /**\r\n    * @dev This modifier limits function execution to the admin\r\n    */\r\n    modifier onlyAdmin(uint8 _level) { //A modifier to define admin-only functions\r\n        require(level[msg.sender] >= _level ); //It require the user level to be more or equal than _level\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice This function transfer the adminship of the contract to _newAdmin\r\n    * @param _newAdmin The new admin of the contract\r\n    */\r\n    function adminshipLevel(address _newAdmin, uint8 _level) onlyAdmin(2) public { //Admin can be set\r\n        require(_newAdmin != address(0)); //The new admin must not be zero address\r\n        level[_newAdmin] = _level; //New level is set\r\n        emit AdminshipUpdated(_newAdmin,_level); //Log the admin set\r\n    }\r\n\r\n    /**\r\n    * @dev Log Events\r\n    */\r\n    event AdminshipUpdated(address _newAdmin, uint8 _level);\r\n\r\n}\r\n\r\ncontract TECHICO is admined {\r\n\r\n    using SafeMath for uint256;\r\n    //This ico have these possible states\r\n    enum State {\r\n        MainSale,\r\n        Paused,\r\n        Successful\r\n    }\r\n    //Public variables\r\n\r\n    //Time-state Related\r\n    State public state = State.MainSale; //Set initial stage\r\n    uint256 constant public SaleStart = 1527879600; //Human time (GMT): Friday, 1 de June de 2018 19:00:00\r\n    uint256 public SaleDeadline = 1535569200; //Human time (GMT): Wednesday, 29 August 2018 19:00:00\r\n    uint256 public completedAt; //Set when ico finish\r\n    //Token-eth related\r\n    uint256 public totalRaised; //eth collected in wei\r\n    uint256 public totalDistributed; //Whole sale tokens distributed\r\n    ERC20Basic public tokenReward; //Token contract address\r\n    uint256 public hardCap = 31200000 * (10 ** 18); // 31.200.000 tokens\r\n    mapping(address => uint256) public pending; //tokens pending to being transfered\r\n    //Contract details\r\n    address public creator; //Creator address\r\n    string public version = '2'; //Contract version\r\n    //Bonus Related - How much tokens per bonus\r\n    uint256 bonus1Remain = 1440000*10**18; //+20%\r\n    uint256 bonus2Remain = 2380000*10**18; //+15%\r\n    uint256 bonus3Remain = 3420000*10**18; //+10%\r\n    uint256 bonus4Remain = 5225000*10**18; //+5%\r\n\r\n    uint256 remainingActualState;\r\n    State laststate;\r\n\r\n    //User rights handlers\r\n    mapping (address => bool) public whiteList; //List of allowed to send eth\r\n\r\n    //Price related\r\n    uint256 rate = 3000; //3000 tokens per ether unit\r\n\r\n    //events for log\r\n    event LogFundrisingInitialized(address _creator);\r\n    event LogFundingReceived(address _addr, uint _amount, uint _currentTotal);\r\n    event LogBeneficiaryPaid(address _beneficiaryAddress);\r\n    event LogContributorsPayout(address _addr, uint _amount);\r\n    event LogFundingSuccessful(uint _totalRaised);\r\n    event LogSalePaused(bool _paused);\r\n\r\n    //Modifier to prevent execution if ico has ended or is holded\r\n    modifier notFinished() {\r\n        require(state != State.Successful && state != State.Paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @notice ICO constructor\r\n    * @param _addressOfTokenUsedAsReward is the token to distribute\r\n    */\r\n    constructor(ERC20Basic _addressOfTokenUsedAsReward ) public {\r\n\r\n        creator = msg.sender; //Creator is set from deployer address\r\n        tokenReward = _addressOfTokenUsedAsReward; //Token address is set during deployment\r\n        emit LogFundrisingInitialized(creator); //Log contract initialization\r\n\r\n        //PreSale tokens already sold = 4.720.047 tokens\r\n        pending[0x8eBBcb4c4177941428E9E9E68C4914fb5A89650E] = 4720047000000000000002000;\r\n        //To no exceed total tokens to sell, update numbers - bonuses not affected\r\n        totalDistributed = 4720047000000000000002000;\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Check remaining and cost function\r\n    * @dev The cost function doesn't include the bonuses calculation\r\n    */\r\n    function remainingTokensAndCost() public view returns (uint256[2]){\r\n        uint256 remaining = hardCap.sub(totalDistributed);\r\n        uint256 cost = remaining.sub((bonus1Remain.mul(2)).div(10));\r\n        cost = cost.sub((bonus2Remain.mul(15)).div(100));\r\n        cost = cost.sub(bonus3Remain.div(10));\r\n        cost = cost.sub((bonus4Remain.mul(5)).div(100));\r\n        cost = cost.div(3000);\r\n        return [remaining,cost];\r\n    }\r\n\r\n    /**\r\n    * @notice Whitelist function\r\n    * @param _user User address to be modified on list\r\n    * @param _flag Whitelist status to set\r\n    */\r\n    function whitelistAddress(address _user, bool _flag) public onlyAdmin(1) {\r\n        whiteList[_user] = _flag; //Assign status to user on whitelist\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Pause function\r\n    * @param _flag Pause status to set\r\n    */\r\n    function pauseSale(bool _flag) onlyAdmin(2) public {\r\n        require(state != State.Successful);\r\n\r\n        if(_flag == true){\r\n            require(state != State.Paused);\r\n            laststate = state;\r\n            remainingActualState = SaleDeadline.sub(now);\r\n            state = State.Paused;\r\n            emit LogSalePaused(true);\r\n        } else {\r\n            require(state == State.Paused);\r\n            state = laststate;\r\n            SaleDeadline = now.add(remainingActualState);\r\n            emit LogSalePaused(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice contribution handler\r\n    */\r\n    function contribute(address _target) public notFinished payable {\r\n        require(now > SaleStart); //This time must be equal or greater than the start time\r\n\r\n        //To handle admin guided contributions\r\n        address user;\r\n        //Let's if user is an admin and is givin a valid target\r\n        if(_target != address(0) && level[msg.sender] >= 1){\r\n          user = _target;\r\n        } else {\r\n          user = msg.sender; //If not the user is the sender\r\n        }\r\n\r\n        require(whiteList[user] == true); //User must be whitelisted\r\n\r\n        totalRaised = totalRaised.add(msg.value); //ether received updated\r\n\r\n        uint256 tokenBought = msg.value.mul(rate); //base tokens amount calculation\r\n\r\n        //Bonus calc helpers\r\n        uint256 bonus = 0; //How much bonus for this sale\r\n        uint256 buyHelper = tokenBought; //Base tokens bought\r\n\r\n        //Bonus Stage 1\r\n        if(bonus1Remain > 0){ //If there still are some tokens with bonus\r\n\r\n          //Lets check if tokens bought are less or more than remaining available\r\n          //tokens whit bonus\r\n          if(buyHelper <= bonus1Remain){ //If purchase is less\r\n              bonus1Remain = bonus1Remain.sub(buyHelper); //Sub from remaining\r\n              //Calculate the bonus for the total bought amount\r\n              bonus = bonus.add((buyHelper.mul(2)).div(10));//+20%\r\n              buyHelper = 0; //Clear buy helper\r\n          }else{ //If purchase is more\r\n              buyHelper = buyHelper.sub(bonus1Remain); //Sub from purchase helper the remaining\r\n              //Calculate bonus for the remaining bonus tokens\r\n              bonus = bonus.add((bonus1Remain.mul(2)).div(10));//+20%\r\n              bonus1Remain = 0; //Clear bonus remaining tokens\r\n          }\r\n\r\n        }\r\n\r\n        //Lets check if tokens bought are less or more than remaining available\r\n        //tokens whit bonus\r\n        if(bonus2Remain > 0 && buyHelper > 0){\r\n\r\n          if(buyHelper <= bonus2Remain){ //If purchase is less\r\n              bonus2Remain = bonus2Remain.sub(buyHelper);//Sub from remaining\r\n              //Calculate the bonus for the total bought amount\r\n              bonus = bonus.add((buyHelper.mul(15)).div(100));//+15%\r\n              buyHelper = 0; //Clear buy helper\r\n          }else{ //If purchase is more\r\n              buyHelper = buyHelper.sub(bonus2Remain);//Sub from purchase helper the remaining\r\n              //Calculate bonus for the remaining bonus tokens\r\n              bonus = bonus.add((bonus2Remain.mul(15)).div(100));//+15%\r\n              bonus2Remain = 0; //Clear bonus remaining tokens\r\n          }\r\n\r\n        }\r\n\r\n        //Lets check if tokens bought are less or more than remaining available\r\n        //tokens whit bonus\r\n        if(bonus3Remain > 0 && buyHelper > 0){\r\n\r\n          if(buyHelper <= bonus3Remain){ //If purchase is less\r\n              bonus3Remain = bonus3Remain.sub(buyHelper);//Sub from remaining\r\n              //Calculate the bonus for the total bought amount\r\n              bonus = bonus.add(buyHelper.div(10));//+10%\r\n              buyHelper = 0; //Clear buy helper\r\n          }else{ //If purchase is more\r\n              buyHelper = buyHelper.sub(bonus3Remain);//Sub from purchase helper the remaining\r\n              //Calculate bonus for the remaining bonus tokens\r\n              bonus = bonus.add(bonus3Remain.div(10));//+10%\r\n              bonus3Remain = 0; //Clear bonus remaining tokens\r\n          }\r\n\r\n        }\r\n\r\n        //Lets check if tokens bought are less or more than remaining available\r\n        //tokens whit bonus\r\n        if(bonus4Remain > 0 && buyHelper > 0){\r\n\r\n          if(buyHelper <= bonus4Remain){ //If purchase is less\r\n              bonus4Remain = bonus4Remain.sub(buyHelper);//Sub from remaining\r\n              //Calculate the bonus for the total bought amount\r\n              bonus = bonus.add((buyHelper.mul(5)).div(100));//+5%\r\n              buyHelper = 0; //Clear buy helper\r\n          }else{ //If purchase is more\r\n              buyHelper = buyHelper.sub(bonus4Remain);//Sub from purchase helper the remaining\r\n              //Calculate bonus for the remaining bonus tokens\r\n              bonus = bonus.add((bonus4Remain.mul(5)).div(100));//+5%\r\n              bonus4Remain = 0; //Clear bonus remaining tokens\r\n          }\r\n\r\n        }\r\n\r\n        tokenBought = tokenBought.add(bonus); //Sum Up Bonus(es) to base purchase\r\n\r\n        require(totalDistributed.add(tokenBought) <= hardCap); //The total amount after sum up must not be more than the hardCap\r\n\r\n        pending[user] = pending[user].add(tokenBought); //Pending balance to distribute is updated\r\n        totalDistributed = totalDistributed.add(tokenBought); //Whole tokens sold updated\r\n\r\n        emit LogFundingReceived(user, msg.value, totalRaised); //Log the purchase\r\n\r\n        checkIfFundingCompleteOrExpired(); //Execute state checks\r\n    }\r\n\r\n    /**\r\n    * @notice Funtion to let users claim their tokens at the end of ico process\r\n    */\r\n    function claimTokensByUser() public{\r\n        require(state == State.Successful); //Once ico is successful\r\n        uint256 temp = pending[msg.sender]; //Get the user pending balance\r\n        pending[msg.sender] = 0; //Clear it\r\n        require(tokenReward.transfer(msg.sender,temp)); //Try to transfer\r\n        emit LogContributorsPayout(msg.sender,temp); //Log the claim\r\n    }\r\n\r\n    /**\r\n    * @notice Funtion to let admins claim users tokens on behalf of them at the end of ico process\r\n    * @param _user Target user of token claim\r\n    */\r\n    function claimTokensByAdmin(address _user) onlyAdmin(1) public{\r\n        require(state == State.Successful); //Once ico is successful\r\n        uint256 temp = pending[_user]; //Get the user pending balance\r\n        pending[_user] = 0; //Clear it\r\n        require(tokenReward.transfer(_user,temp)); //Try to transfer\r\n        emit LogContributorsPayout(_user,temp); //Log the claim\r\n    }\r\n\r\n    /**\r\n    * @notice Process to check contract current status\r\n    */\r\n    function checkIfFundingCompleteOrExpired() public {\r\n         //If hardacap or deadline is reached and not yet successful\r\n        if ( (totalDistributed == hardCap || now > SaleDeadline)\r\n            && state != State.Successful \r\n            && state != State.Paused) {\r\n            //remanent tokens are assigned to creator for later handle\r\n            pending[creator] = tokenReward.balanceOf(address(this)).sub(totalDistributed);\r\n\r\n            state = State.Successful; //ICO becomes Successful\r\n            completedAt = now; //ICO is complete\r\n\r\n            emit LogFundingSuccessful(totalRaised); //we log the finish\r\n            successful(); //and execute closure\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice successful closure handler\r\n    */\r\n    function successful() public {\r\n        require(state == State.Successful); //When successful\r\n        uint256 temp = pending[creator]; //Remanent tokens handle\r\n        pending[creator] = 0; //Clear user balance\r\n        require(tokenReward.transfer(creator,temp)); //Try to transfer\r\n\r\n        emit LogContributorsPayout(creator,temp); //Log transaction\r\n\r\n        creator.transfer(address(this).balance); //After successful, eth is send to creator\r\n\r\n        emit LogBeneficiaryPaid(creator); //Log transaction\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Function to claim any token stuck on contract\r\n    * @param _address Address of target token\r\n    */\r\n    function externalTokensRecovery(ERC20Basic _address) onlyAdmin(2) public{\r\n        require(state == State.Successful); //Only when sale finish\r\n        require(_address != address(tokenReward)); //Target token must be different from token on sale\r\n\r\n        uint256 remainder = _address.balanceOf(this); //Check remainder tokens\r\n        _address.transfer(msg.sender,remainder); //Transfer tokens to admin\r\n\r\n    }\r\n\r\n    /*\r\n    * @dev Direct payments handler\r\n    */\r\n    function () public payable {\r\n\r\n        contribute(address(0)); //Forward to contribute function\r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"pauseSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claimTokensByAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SaleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"completedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"externalTokensRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pending\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkIfFundingCompleteOrExpired\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"successful\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"whitelistAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SaleDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"},{\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"adminshipLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokensByUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"level\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokensAndCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addressOfTokenUsedAsReward\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"LogFundrisingInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_currentTotal\",\"type\":\"uint256\"}],\"name\":\"LogFundingReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiaryAddress\",\"type\":\"address\"}],\"name\":\"LogBeneficiaryPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LogContributorsPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_totalRaised\",\"type\":\"uint256\"}],\"name\":\"LogFundingSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"LogSalePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_level\",\"type\":\"uint8\"}],\"name\":\"AdminshipUpdated\",\"type\":\"event\"}]","ContractName":"TECHICO","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000beb353d7c9d49d51f501fca51f46cbbac4c471db","Library":"","SwarmSource":"bzzr://4af597fc97be3b1baea317affe2a58a2230b00747efe736baef293b41f03f339"}]}