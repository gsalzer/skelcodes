{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract ERC721 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n  function transfer(address _to, uint256 _tokenId) external;\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) external;\r\n  function setApprovalForAll(address _to, bool _approved) external;\r\n  function getApproved(uint256 _tokenId) public view returns (address);\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\nlibrary Strings {\r\n  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\r\n      bytes memory _ba = bytes(_a);\r\n      bytes memory _bb = bytes(_b);\r\n      bytes memory _bc = bytes(_c);\r\n      bytes memory _bd = bytes(_d);\r\n      bytes memory _be = bytes(_e);\r\n      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n      bytes memory babcde = bytes(abcde);\r\n      uint k = 0;\r\n      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n      for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n      for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n      for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n      for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n      return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ncontract ERC721SlimToken is Ownable, ERC721, ERC165, ERC721Metadata {\r\n  using SafeMath for uint256;\r\n\r\n  string public constant NAME = \"EtherLoot\";\r\n  string public constant SYMBOL = \"ETLT\";\r\n  string public tokenMetadataBaseURI = \"http://api.etherloot.moonshadowgames.com/tokenmetadata/\";\r\n\r\n  struct AddressAndTokenIndex {\r\n    address owner;\r\n    uint32 tokenIndex;\r\n  }\r\n\r\n  mapping (uint256 => AddressAndTokenIndex) private tokenOwnerAndTokensIndex;\r\n\r\n  mapping (address => uint256[]) private ownedTokens;\r\n\r\n  mapping (uint256 => address) private tokenApprovals;\r\n\r\n  mapping (address => mapping (address => bool)) private operatorApprovals;\r\n\r\n  mapping (address => bool) private approvedContractAddresses;\r\n\r\n  bool approvedContractsFinalized = false;\r\n\r\n  function implementsERC721() external pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n  function supportsInterface(\r\n    bytes4 interfaceID)\r\n    external view returns (bool)\r\n  {\r\n    return\r\n      interfaceID == this.supportsInterface.selector || // ERC165\r\n      interfaceID == 0x5b5e139f || // ERC721Metadata\r\n      interfaceID == 0x6466353c; // ERC-721\r\n  }\r\n\r\n  function name() external pure returns (string) {\r\n    return NAME;\r\n  }\r\n\r\n  function symbol() external pure returns (string) {\r\n    return SYMBOL;\r\n  }\r\n\r\n  function setTokenMetadataBaseURI(string _tokenMetadataBaseURI) external onlyOwner {\r\n    tokenMetadataBaseURI = _tokenMetadataBaseURI;\r\n  }\r\n\r\n  function tokenURI(uint256 tokenId)\r\n    external\r\n    view\r\n    returns (string infoUrl)\r\n  {\r\n    return Strings.strConcat(\r\n      tokenMetadataBaseURI,\r\n      Strings.uint2str(tokenId));\r\n  }\r\n\r\n  /**\r\n  * @notice Guarantees msg.sender is owner of the given token\r\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n  */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender, \"not owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the balance of the specified address\r\n  * @param _owner address to query the balance of\r\n  * @return uint256 representing the amount owned by the passed address\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0), \"null owner\");\r\n    return ownedTokens[_owner].length;\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the list of tokens owned by a given address\r\n  * @param _owner address to query the tokens of\r\n  * @return uint256[] representing the list of tokens owned by the passed address\r\n  */\r\n  function tokensOf(address _owner) public view returns (uint256[]) {\r\n    return ownedTokens[_owner];\r\n  }\r\n\r\n  /**\r\n  * @notice Enumerate NFTs assigned to an owner\r\n  * @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  *  `_owner` is the zero address, representing invalid NFTs.\r\n  * @param _owner An address where we are interested in NFTs owned by them\r\n  * @param _index A counter less than `balanceOf(_owner)`\r\n  * @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n    external\r\n    view\r\n    returns (uint256 _tokenId)\r\n  {\r\n    require(_index < balanceOf(_owner), \"invalid index\");\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n  * @notice Gets the owner of the specified token ID\r\n  * @param _tokenId uint256 ID of the token to query the owner of\r\n  * @return owner address currently marked as the owner of the given token ID\r\n  */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\r\n    require(_owner != address(0), \"invalid owner\");\r\n    return _owner;\r\n  }\r\n\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address _owner = tokenOwnerAndTokensIndex[_tokenId].owner;\r\n    return (_owner != address(0));\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the approved address to take ownership of a given token ID\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved to take ownership of the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\r\n   * Checks both for specific approval and operator approval\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether transfer by msg.sender is approved for the given token ID or not\r\n   */\r\n  function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {\r\n    return\r\n      ownerOf(_tokenId) == msg.sender ||\r\n      isSpecificallyApprovedFor(msg.sender, _tokenId) ||\r\n      isApprovedForAll(ownerOf(_tokenId), msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether the msg.sender is approved for the given token ID or not\r\n   * @param _asker address of asking for approval\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return bool whether the msg.sender is approved for the given token ID or not\r\n   */\r\n  function isSpecificallyApprovedFor(address _asker, uint256 _tokenId) internal view returns (bool) {\r\n    return getApproved(_tokenId) == _asker;\r\n  }\r\n\r\n  /**\r\n   * @notice Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\r\n  {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n  * @notice Transfers the ownership of a given token ID to another address\r\n  * @param _to address to receive the ownership of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transfer(address _to, uint256 _tokenId)\r\n    external\r\n    onlyOwnerOf(_tokenId)\r\n  {\r\n    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Approves another address to claim for the ownership of the given token ID\r\n  * @param _to address to be approved for the given token ID\r\n  * @param _tokenId uint256 ID of the token to be approved\r\n  */\r\n  function approve(address _to, uint256 _tokenId)\r\n    external\r\n    onlyOwnerOf(_tokenId)\r\n  {\r\n    address _owner = ownerOf(_tokenId);\r\n    require(_to != _owner, \"already owns\");\r\n    if (getApproved(_tokenId) != 0 || _to != 0) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      emit Approval(_owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Enable or disable approval for a third party (\"operator\") to manage all your assets\r\n  * @dev Emits the ApprovalForAll event\r\n  * @param _to Address to add to the set of authorized operators.\r\n  * @param _approved True if the operators is approved, false to revoke approval\r\n  */\r\n  function setApprovalForAll(address _to, bool _approved)\r\n    external\r\n  {\r\n    if(_approved) {\r\n      approveAll(_to);\r\n    } else {\r\n      disapproveAll(_to);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Approves another address to claim for the ownership of any tokens owned by this account\r\n  * @param _to address to be approved for the given token ID\r\n  */\r\n  function approveAll(address _to)\r\n    public\r\n  {\r\n    require(_to != msg.sender, \"cant approve yourself\");\r\n    require(_to != address(0), \"invalid owner\");\r\n    operatorApprovals[msg.sender][_to] = true;\r\n    emit ApprovalForAll(msg.sender, _to, true);\r\n  }\r\n\r\n  /**\r\n  * @notice Removes approval for another address to claim for the ownership of any\r\n  *  tokens owned by this account.\r\n  * @dev Note that this only removes the operator approval and\r\n  *  does not clear any independent, specific approvals of token transfers to this address\r\n  * @param _to address to be disapproved for the given token ID\r\n  */\r\n  function disapproveAll(address _to)\r\n    public\r\n  {\r\n    require(_to != msg.sender, \"cant unapprove yourself\");\r\n    delete operatorApprovals[msg.sender][_to];\r\n    emit ApprovalForAll(msg.sender, _to, false);\r\n  }\r\n\r\n  /**\r\n  * @notice Claims the ownership of a given token ID\r\n  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\r\n  */\r\n  function takeOwnership(uint256 _tokenId)\r\n   external\r\n  {\r\n    require(isSenderApprovedFor(_tokenId), \"not approved\");\r\n    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Transfer a token owned by another address, for which the calling address has\r\n  *  previously been granted transfer approval by the owner.\r\n  * @param _from The address that owns the token\r\n  * @param _to The address that will take ownership of the token. Can be any address, including the caller\r\n  * @param _tokenId The ID of the token to be transferred\r\n  */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n  {\r\n    address tokenOwner = ownerOf(_tokenId);\r\n    require(isSenderApprovedFor(_tokenId) || \r\n      (approvedContractAddresses[msg.sender] && tokenOwner == tx.origin), \"not an approved sender\");\r\n    require(tokenOwner == _from, \"wrong owner\");\r\n    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Transfers the ownership of an NFT from one address to another address\r\n  * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  * operator, or the approved address for this NFT. Throws if `_from` is\r\n  * not the current owner. Throws if `_to` is the zero address. Throws if\r\n  * `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  * `onERC721Received` on `_to` and throws if the return value is not\r\n  * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n  * @param _from The current owner of the NFT\r\n  * @param _to The new owner\r\n  * @param _tokenId The NFT to transfer\r\n  * @param _data Additional data with no specified format, sent in call to `_to`\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n  {\r\n    require(_to != address(0), \"invalid target address\");\r\n    transferFrom(_from, _to, _tokenId);\r\n    if (_isContract(_to)) {\r\n      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\r\n        _from, _tokenId, _data\r\n      );\r\n      require(tokenReceiverResponse == bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")), \"invalid receiver respononse\");\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @notice Transfers the ownership of an NFT from one address to another address\r\n   * @dev This works identically to the other function with an extra data parameter,\r\n   *  except this function just sets data to \"\"\r\n   * @param _from The current owner of the NFT\r\n   * @param _to The new owner\r\n   * @param _tokenId The NFT to transfer\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n  {\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n  * @notice Approve a contract address for minting tokens and transferring tokens, when approved by the owner\r\n  * @param contractAddress The address that will be approved\r\n  */\r\n  function addApprovedContractAddress(address contractAddress) public onlyOwner\r\n  {\r\n    require(!approvedContractsFinalized);\r\n    approvedContractAddresses[contractAddress] = true;\r\n  }\r\n\r\n  /**\r\n  * @notice Unapprove a contract address for minting tokens and transferring tokens\r\n  * @param contractAddress The address that will be unapproved\r\n  */\r\n  function removeApprovedContractAddress(address contractAddress) public onlyOwner\r\n  {\r\n    require(!approvedContractsFinalized);\r\n    approvedContractAddresses[contractAddress] = false;\r\n  }\r\n\r\n  /**\r\n  * @notice Finalize the contract so it will be forever impossible to change the approved contracts list\r\n  */\r\n  function finalizeApprovedContracts() public onlyOwner {\r\n    approvedContractsFinalized = true;\r\n  }\r\n\r\n  /**\r\n  * @notice Mint token function\r\n  * @param _to The address that will own the minted token\r\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n  */\r\n  function mint(address _to, uint256 _tokenId) public {\r\n    require(\r\n      approvedContractAddresses[msg.sender] ||\r\n      msg.sender == owner, \"minter not approved\"\r\n    );\r\n    _mint(_to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Mint token function\r\n  * @param _to The address that will own the minted token\r\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n  */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0), \"invalid target address\");\r\n    require(tokenOwnerAndTokensIndex[_tokenId].owner == address(0), \"token already exists\");\r\n    _addToken(_to, _tokenId);\r\n    emit Transfer(0x0, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\r\n  * @param _from address which you want to send tokens from\r\n  * @param _to address which you want to transfer the token to\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function _clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0), \"invalid target address\");\r\n    require(_to != ownerOf(_tokenId), \"already owns\");\r\n    require(ownerOf(_tokenId) == _from, \"wrong owner\");\r\n\r\n    _clearApproval(_from, _tokenId);\r\n    _removeToken(_from, _tokenId);\r\n    _addToken(_to, _tokenId);\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to clear current approval of a given token ID\r\n  * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function _clearApproval(address _owner, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _owner, \"wrong owner\");\r\n    if (tokenApprovals[_tokenId] != 0) {\r\n      tokenApprovals[_tokenId] = 0;\r\n      emit Approval(_owner, 0, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to add a token ID to the list of a given address\r\n  * @param _to address representing the new owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n  */\r\n  function _addToken(address _to, uint256 _tokenId) private {\r\n    uint256 newTokenIndex = ownedTokens[_to].length;\r\n    ownedTokens[_to].push(_tokenId);\r\n\r\n    // I don't expect anyone to own 4 billion tokens, but just in case...\r\n    require(newTokenIndex == uint256(uint32(newTokenIndex)), \"overflow\");\r\n\r\n    tokenOwnerAndTokensIndex[_tokenId] = AddressAndTokenIndex({owner: _to, tokenIndex: uint32(newTokenIndex)});\r\n  }\r\n\r\n  /**\r\n  * @notice Internal function to remove a token ID from the list of a given address\r\n  * @param _from address representing the previous owner of the given token ID\r\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n  */\r\n  function _removeToken(address _from, uint256 _tokenId) private {\r\n    require(ownerOf(_tokenId) == _from, \"wrong owner\");\r\n\r\n    uint256 tokenIndex = tokenOwnerAndTokensIndex[_tokenId].tokenIndex;\r\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n\r\n    ownedTokens[_from].length--;\r\n    tokenOwnerAndTokensIndex[lastToken] = AddressAndTokenIndex({owner: _from, tokenIndex: uint32(tokenIndex)});\r\n  }\r\n\r\n  function _isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"approveAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenMetadataBaseURI\",\"type\":\"string\"}],\"name\":\"setTokenMetadataBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeApprovedContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"addApprovedContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"disapproveAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMetadataBaseURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"removeApprovedContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ERC721SlimToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cbc095794842abe79bd6db480daced1a35e5325a77326d8961f7ace4b7128df5"}]}