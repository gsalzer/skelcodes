{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Acceptable.sol\r\n\r\n// @title Acceptable\r\n// @author Takayuki Jimba\r\n// @dev Provide basic access control.\r\ncontract Acceptable is Ownable {\r\n    address public sender;\r\n\r\n    // @dev Throws if called by any address other than the sender.\r\n    modifier onlyAcceptable {\r\n        require(msg.sender == sender);\r\n        _;\r\n    }\r\n\r\n    // @dev Change acceptable address\r\n    // @param _sender The address to new sender\r\n    function setAcceptable(address _sender) public onlyOwner {\r\n        sender = _sender;\r\n    }\r\n}\r\n\r\n// File: contracts/zeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);  \r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n  \r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n  \r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;  \r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\r\n}\r\n\r\n// File: contracts/zeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() public view returns (string _name);\r\n  function symbol() public view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n// File: contracts/CrystalBaseIF.sol\r\n\r\n// @title CrystalBaseIF\r\n// @author Takayuki Jimba\r\ncontract CrystalBaseIF is ERC721 {\r\n    function mint(address _owner, uint256 _gene, uint256 _kind, uint256 _weight) public returns(uint256);\r\n    function burn(address _owner, uint256 _tokenId) public;\r\n    function _transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function getCrystalKindWeight(uint256 _tokenId) public view returns(uint256 kind, uint256 weight);\r\n    function getCrystalGeneKindWeight(uint256 _tokenId) public view returns(uint256 gene, uint256 kind, uint256 weight);\r\n}\r\n\r\n// File: contracts/zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/MiningSupplier.sol\r\n\r\n// @title MiningSupplier\r\n// @author Takayuki Jimba\r\ncontract MiningSupplier {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant secondsPerYear = 1 years * 1 seconds;\r\n    uint256 public constant secondsPerDay = 1 days * 1 seconds;\r\n\r\n    // @dev Number of blocks per year\r\n    function _getBlocksPerYear(\r\n        uint256 _secondsPerBlock\r\n    ) public pure returns(uint256) {\r\n        return secondsPerYear.div(_secondsPerBlock);\r\n    }\r\n\r\n    // @dev 0-based block number index\r\n    //      First block number index of every years is 0\r\n    function _getBlockIndexAtYear(\r\n        uint256 _initialBlockNumber,\r\n        uint256 _currentBlockNumber,\r\n        uint256 _secondsPerBlock\r\n    ) public pure returns(uint256) {\r\n        //require(_currentBlockNumber >= _initialBlockNumber, \"current is large than or equal to initial\");\r\n        require(_currentBlockNumber >= _initialBlockNumber);\r\n        uint256 _blockIndex = _currentBlockNumber.sub(_initialBlockNumber);\r\n        uint256 _blocksPerYear = _getBlocksPerYear(_secondsPerBlock);\r\n        return _blockIndex.sub(_blockIndex.div(_blocksPerYear).mul(_blocksPerYear));\r\n    }\r\n\r\n    // @dev Map block number to block index.\r\n    //      First block is number 0.\r\n    function _getBlockIndex(\r\n        uint256 _initialBlockNumber,\r\n        uint256 _currentBlockNumber\r\n    ) public pure returns(uint256) {\r\n        //require(_currentBlockNumber >= _initialBlockNumber, \"current is large than or equal to initial\");\r\n        require(_currentBlockNumber >= _initialBlockNumber);\r\n        return _currentBlockNumber.sub(_initialBlockNumber);\r\n    }\r\n\r\n    // @dev Map block number to year index.\r\n    //      First (blocksPerYear - 1) blocks are number 0.\r\n    function _getYearIndex(\r\n        uint256 _secondsPerBlock,\r\n        uint256 _initialBlockNumber,\r\n        uint256 _currentBlockNumber\r\n    ) public pure returns(uint256) {\r\n        uint256 _blockIndex =  _getBlockIndex(_initialBlockNumber, _currentBlockNumber);\r\n        uint256 _blocksPerYear = _getBlocksPerYear(_secondsPerBlock);\r\n        return _blockIndex.div(_blocksPerYear);\r\n    }\r\n\r\n    // @dev\r\n    function _getWaitingBlocks(\r\n        uint256 _secondsPerBlock\r\n    ) public pure returns(uint256) {\r\n        return secondsPerDay.div(_secondsPerBlock);\r\n    }\r\n\r\n    function _getWeightUntil(\r\n        uint256 _totalWeight,\r\n        uint256 _yearIndex\r\n    ) public pure returns(uint256) {\r\n        uint256 _sum = 0;\r\n        for(uint256 i = 0; i < _yearIndex; i++) {\r\n            _sum = _sum.add(_totalWeight / (2 ** (i + 1)));\r\n        }\r\n        return _sum;\r\n    }\r\n\r\n    function _estimateSupply(\r\n        uint256 _secondsPerBlock,\r\n        uint256 _initialBlockNumber,\r\n        uint256 _currentBlockNumber,\r\n        uint256 _totalWeight\r\n    ) public pure returns(uint256){\r\n        uint256 _yearIndex = _getYearIndex(_secondsPerBlock, _initialBlockNumber, _currentBlockNumber); // 0-based\r\n        uint256 _blockIndex = _getBlockIndexAtYear(_initialBlockNumber, _currentBlockNumber, _secondsPerBlock) + 1;\r\n        uint256 _numerator = _totalWeight.mul(_secondsPerBlock).mul(_blockIndex);\r\n        uint256 _yearFactor = 2 ** (_yearIndex + 1);\r\n        uint256 _denominator =  _yearFactor.mul(secondsPerYear);\r\n        uint256 _supply = _numerator.div(_denominator).add(_getWeightUntil(_totalWeight, _yearIndex));\r\n        return _supply; // mg\r\n    }\r\n\r\n    function _estimateWeight(\r\n        uint256 _secondsPerBlock,\r\n        uint256 _initialBlockNumber,\r\n        uint256 _currentBlockNumber,\r\n        uint256 _totalWeight,\r\n        uint256 _currentWeight\r\n    ) public pure returns(uint256) {\r\n        uint256 _supply = _estimateSupply(\r\n            _secondsPerBlock,\r\n            _initialBlockNumber,\r\n            _currentBlockNumber,\r\n            _totalWeight\r\n        );\r\n        uint256 _yearIndex = _getYearIndex(\r\n            _secondsPerBlock,\r\n            _initialBlockNumber,\r\n            _currentBlockNumber\r\n        ); // 0-based\r\n        uint256 _yearFactor = 2 ** _yearIndex;\r\n        uint256 _defaultWeight = 10000; // mg\r\n\r\n        if(_currentWeight > _supply) {\r\n            // (_supply / _currentWeight) * _defaultWeight / _yearFactor\r\n            return _supply.mul(_defaultWeight).div(_currentWeight).div(_yearFactor);\r\n        } else {\r\n            // _defaultWeight / _yearFactor\r\n            return _defaultWeight.div(_yearFactor);\r\n        }\r\n    }\r\n\r\n    function _updateNeeded(\r\n        uint256 _secondsPerBlock,\r\n        uint256 _currentBlockNumber,\r\n        uint256 _blockNumberUpdated\r\n    ) public pure returns(bool) {\r\n        if (_blockNumberUpdated == 0) {\r\n            return true;\r\n        }\r\n        uint256 _waitingBlocks = _getWaitingBlocks(_secondsPerBlock);\r\n        return _currentBlockNumber >= _blockNumberUpdated + _waitingBlocks;\r\n    }\r\n}\r\n\r\n// File: contracts/CrystalWeightManager.sol\r\n\r\n// @title CrystalWeightManager\r\n// @author Takayuki Jimba\r\ncontract CrystalWeightManager is MiningSupplier {\r\n    // Amounts of deposit of all crystals.\r\n    // Each unit of weight is milligrams\r\n    // e.g. 50000000000 means 50t.\r\n    uint256[100] crystalWeights = [\r\n        50000000000,226800000000,1312500000000,31500000000,235830000000,\r\n        151200000000,655200000000,829500000000,7177734375,762300000000,\r\n        684600000000,676200000000,5037226562,30761718750,102539062500,\r\n        102539062500,102539062500,5126953125,31500000000,5040000000,\r\n        20507812500,20507812500,10253906250,5024414062,6300000000,\r\n        20507812500,102539062500,102539062500,102539062500,102539062500,\r\n        102539062500,7690429687,15380859375,69300000000,10253906250,\r\n        547050000000,15380859375,20507812500,15380859375,15380859375,\r\n        20507812500,15380859375,7690429687,153808593750,92285156250,\r\n        102539062500,71777343750,82031250000,256347656250,1384277343750,\r\n        820312500000,743408203125,461425781250,563964843750,538330078125,\r\n        358886718750,256347656250,358886718750,102539062500,307617187500,\r\n        256347656250,51269531250,41015625000,307617187500,307617187500,\r\n        2050781250,3588867187,2563476562,5126953125,399902343750,\r\n        615234375000,563964843750,461425781250,358886718750,717773437500,\r\n        41015625000,41015625000,2050781250,102539062500,102539062500,\r\n        51269531250,102539062500,30761718750,41015625000,102539062500,\r\n        102539062500,102539062500,205078125000,205078125000,556500000000,\r\n        657300000000,41015625000,102539062500,30761718750,102539062500,\r\n        20507812500,20507812500,20507812500,20507812500,82031250000\r\n    ];\r\n\r\n    uint256 public secondsPerBlock = 12;\r\n    uint256 public initialBlockNumber = block.number;\r\n    uint256 public constant originalTotalWeight = 21 * 10**13; // mg\r\n    uint256 public currentWeight = 0;\r\n    uint256 public estimatedWeight = 0;\r\n    uint256 public blockNumberUpdated = 0;\r\n\r\n    event UpdateEstimatedWeight(uint256 weight, uint256 nextUpdateBlockNumber);\r\n\r\n    function setEstimatedWeight(uint256 _minedWeight) internal {\r\n        currentWeight = currentWeight.add(_minedWeight);\r\n\r\n        uint256 _currentBlockNumber = block.number;\r\n\r\n        bool _isUpdate = _updateNeeded(\r\n            secondsPerBlock,\r\n            _currentBlockNumber,\r\n            blockNumberUpdated\r\n        );\r\n\r\n        if(_isUpdate) {\r\n            estimatedWeight = _estimateWeight(\r\n                secondsPerBlock,\r\n                initialBlockNumber,\r\n                _currentBlockNumber,\r\n                originalTotalWeight,\r\n                currentWeight\r\n            );\r\n            blockNumberUpdated = _currentBlockNumber;\r\n\r\n            emit UpdateEstimatedWeight(estimatedWeight, _currentBlockNumber);\r\n        }\r\n    }\r\n\r\n    function getCrystalWeights() external view returns(uint256[100]) {\r\n        return crystalWeights;\r\n    }\r\n}\r\n\r\n// File: contracts/EOACallable.sol\r\n\r\n// @title EOACallable\r\n// @author Takayuki Jimba\r\ncontract EOACallable {\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    modifier onlyEOA {\r\n        require(!isContract(msg.sender));\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/ExchangeBaseIF.sol\r\n\r\n// @title ExchangeBaseIF\r\n// @author Takayuki Jimba\r\ncontract ExchangeBaseIF {\r\n    function create(\r\n        address _owner,\r\n        uint256 _ownerTokenId,\r\n        uint256 _ownerTokenGene,\r\n        uint256 _ownerTokenKind,\r\n        uint256 _ownerTokenWeight,\r\n        uint256 _kind,\r\n        uint256 _weight,\r\n        uint256 _createdAt\r\n    ) public returns(uint256);\r\n    function remove(uint256 _id) public;\r\n    function getExchange(uint256 _id) public view returns(\r\n        address owner,\r\n        uint256 tokenId,\r\n        uint256 kind,\r\n        uint256 weight,\r\n        uint256 createdAt\r\n    );\r\n    function getTokenId(uint256 _id) public view returns(uint256);\r\n    function ownerOf(uint256 _id) public view returns(address);\r\n    function isOnExchange(uint256 _tokenId) public view returns(bool);\r\n    function isOnExchangeById(uint256 _id) public view returns(bool);\r\n}\r\n\r\n// File: contracts/zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/PickaxeIF.sol\r\n\r\n// @title PickaxeIF\r\n// @author Takayuki Jimba\r\ncontract PickaxeIF is ERC20 {\r\n    function transferFromOwner(address _to, uint256 _amount) public;\r\n    function burn(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/RandomGeneratorIF.sol\r\n\r\n// @title RandomGeneratorIF\r\n// @author Takayuki Jimba\r\ncontract RandomGeneratorIF {\r\n    function generate() public returns(uint64);\r\n}\r\n\r\n// File: contracts/Sellable.sol\r\n\r\n// @title Sellable\r\n// @author Takayuki Jimba\r\n// @dev Sell tokens.\r\n//      Token is supposed to be Pickaxe contract in our contracts.\r\n//      Actual transferring tokens operation is to be implemented in inherited contract.\r\ncontract Sellable is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public wallet;\r\n    uint256 public rate;\r\n\r\n    address public donationWallet;\r\n    uint256 public donationRate;\r\n\r\n    uint256 public constant MIN_WEI_AMOUNT = 5 * 10**15;\r\n\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n    event ForwardFunds(address sender, uint256 value, uint256 deposit);\r\n    event Donation(address sender, uint256 value);\r\n\r\n    constructor(address _wallet, address _donationWallet, uint256 _donationRate) public {\r\n        // 1 token = 0.005 ETH\r\n        rate = 200;\r\n        wallet = _wallet;\r\n        donationWallet = _donationWallet;\r\n        donationRate = _donationRate;\r\n    }\r\n\r\n    function setWallet(address _wallet) external onlyOwner {\r\n        wallet = _wallet;\r\n    }\r\n\r\n    function setEthereumWallet(address _donationWallet) external onlyOwner {\r\n        donationWallet = _donationWallet;\r\n    }\r\n\r\n    function () external payable {\r\n        require(msg.value >= MIN_WEI_AMOUNT);\r\n        buyPickaxes(msg.sender);\r\n    }\r\n\r\n    function buyPickaxes(address _beneficiary) public payable {\r\n        require(msg.value >= MIN_WEI_AMOUNT);\r\n\r\n        uint256 _weiAmount = msg.value;\r\n        uint256 _tokens = _weiAmount.mul(rate).div(1 ether);\r\n\r\n        require(_tokens.mul(1 ether).div(rate) == _weiAmount);\r\n\r\n        _transferFromOwner(msg.sender, _tokens);\r\n        emit TokenPurchase(msg.sender, _beneficiary, _weiAmount, _tokens);\r\n        _forwardFunds();\r\n    }\r\n\r\n    function _transferFromOwner(address _to, uint256 _value) internal {\r\n        /* MUST override */\r\n    }\r\n\r\n    function _forwardFunds() internal {\r\n        uint256 donation = msg.value.div(donationRate); // 2%\r\n        uint256 value = msg.value - donation;\r\n\r\n        wallet.transfer(value);\r\n\r\n        emit ForwardFunds(msg.sender, value, donation);\r\n\r\n        uint256 donationEth = 2014000000000000000; // 2.014 ether\r\n        if(address(this).balance >= donationEth) {\r\n            donationWallet.transfer(donationEth);\r\n            emit Donation(msg.sender, donationEth);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/CryptoCrystal.sol\r\n\r\n// @title CryptoCrystal\r\n// @author Takayuki Jimba\r\n// @dev Almost all application specific logic is in this contract.\r\n//      CryptoCrystal acts as a facade to Pixaxe(ERC20), CrystalBase(ERC721), ExchangeBase as to transactions.\r\ncontract CryptoCrystal is Sellable, EOACallable, CrystalWeightManager {\r\n    PickaxeIF public pickaxe;\r\n    CrystalBaseIF public crystal;\r\n    ExchangeBaseIF public exchange;\r\n    RandomGeneratorIF public generator;\r\n\r\n    //event RandomGenerated(uint256 number);\r\n\r\n    event MineCrystals(\r\n        // miner of the crystal\r\n        address indexed owner,\r\n        // time of mining\r\n        uint256 indexed minedAt,\r\n        // tokenIds of mined crystals\r\n        uint256[] tokenIds,\r\n        // kinds of mined crystals\r\n        uint256[] kinds,\r\n        // weights of mined crystals\r\n        uint256[] weights,\r\n        // genes of mined crystals\r\n        uint256[] genes\r\n    );\r\n\r\n    event MeltCrystals(\r\n        // melter of the crystals\r\n        address indexed owner,\r\n        // time of melting\r\n        uint256 indexed meltedAt,\r\n        // tokenIds of melted crystals\r\n        uint256[] meltedTokenIds,\r\n        // tokenId of newly generated crystal\r\n        uint256 tokenId,\r\n        // kind of newly generated crystal\r\n        uint256 kind,\r\n        // weight of newly generated crystal\r\n        uint256 weight,\r\n        // gene of newly generated crystal\r\n        uint256 gene\r\n    );\r\n\r\n    event CreateExchange(\r\n        // id of exchange\r\n        uint256 indexed id,\r\n        // creator of the exchange\r\n        address owner,\r\n        // tokenId of exhibited crystal\r\n        uint256 ownerTokenId,\r\n        // gene of exhibited crystal\r\n        uint256 ownerTokenGene,\r\n        // kind of exhibited crystal\r\n        uint256 ownerTokenKind,\r\n        // weight of exhibited crystal\r\n        uint256 ownerTokenWeight,\r\n        // kind of condition for exchange\r\n        uint256 kind,\r\n        // weight of condition for exchange\r\n        uint256 weight,\r\n        // time of exchange creation\r\n        uint256 createdAt\r\n    );\r\n\r\n    event CancelExchange(\r\n        // id of excahnge\r\n        uint256 indexed id,\r\n        // creator of the exchange\r\n        address owner,\r\n        // tokenId of exhibited crystal\r\n        uint256 ownerTokenId,\r\n        // kind of exhibited crystal\r\n        uint256 ownerTokenKind,\r\n        // weight of exhibited crystal\r\n        uint256 ownerTokenWeight,\r\n        // time of exchange cancelling\r\n        uint256 cancelledAt\r\n    );\r\n\r\n    event BidExchange(\r\n        // id of exchange\r\n        uint256 indexed id,\r\n        // creator of the exchange\r\n        address owner,\r\n        // tokenId of exhibited crystal\r\n        uint256 ownerTokenId,\r\n        // gene of exhibited crystal\r\n        uint256 ownerTokenGene,\r\n        // kind of exhibited crystal\r\n        uint256 ownerTokenKind,\r\n        // weight of exhibited crystal\r\n        uint256 ownerTokenWeight,\r\n        // exchanger who bid to exchange\r\n        address exchanger,\r\n        // tokenId of crystal to exchange\r\n        uint256 exchangerTokenId,\r\n        // kind of crystal to exchange\r\n        uint256 exchangerTokenKind,\r\n        // weight of crystal to exchange (may not be the same to weight condition)\r\n        uint256 exchangerTokenWeight,\r\n        // time of bidding\r\n        uint256 bidAt\r\n    );\r\n\r\n    struct ExchangeWrapper {\r\n        uint256 id;\r\n        address owner;\r\n        uint256 tokenId;\r\n        uint256 kind;\r\n        uint256 weight;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    struct CrystalWrapper {\r\n        address owner;\r\n        uint256 tokenId;\r\n        uint256 gene;\r\n        uint256 kind;\r\n        uint256 weight;\r\n    }\r\n\r\n    constructor(\r\n        PickaxeIF _pickaxe,\r\n        CrystalBaseIF _crystal,\r\n        ExchangeBaseIF _exchange,\r\n        RandomGeneratorIF _generator,\r\n        address _wallet,\r\n        address _donationWallet,\r\n        uint256 _donationRate\r\n    ) Sellable(_wallet, _donationWallet, _donationRate) public {\r\n        pickaxe = _pickaxe;\r\n        crystal = _crystal;\r\n        exchange = _exchange;\r\n        generator = _generator;\r\n        setEstimatedWeight(0);\r\n    }\r\n\r\n    // @dev mineCrystals consists of two basic operations that burn pickaxes and mint crystals.\r\n    // @param _pkxAmount uint256 the amount of tokens to be burned\r\n    function mineCrystals(uint256 _pkxAmount) external onlyEOA {\r\n        address _owner = msg.sender;\r\n        require(pickaxe.balanceOf(msg.sender) >= _pkxAmount);\r\n        require(0 < _pkxAmount && _pkxAmount <= 100);\r\n\r\n        uint256 _crystalAmount = _getRandom(5);\r\n\r\n        uint256[] memory _tokenIds = new uint256[](_crystalAmount);\r\n        uint256[] memory _kinds = new uint256[](_crystalAmount);\r\n        uint256[] memory _weights = new uint256[](_crystalAmount);\r\n        uint256[] memory _genes = new uint256[](_crystalAmount);\r\n\r\n        uint256[] memory _crystalWeightsCumsum = new uint256[](100);\r\n        _crystalWeightsCumsum[0] = crystalWeights[0];\r\n        for(uint256 i = 1; i < 100; i++) {\r\n            _crystalWeightsCumsum[i] = _crystalWeightsCumsum[i - 1].add(crystalWeights[i]);\r\n        }\r\n        uint256 _totalWeight = _crystalWeightsCumsum[_crystalWeightsCumsum.length - 1];\r\n        uint256 _weightRandomSum = 0;\r\n        uint256 _weightSum = 0;\r\n\r\n        for(i = 0; i < _crystalAmount; i++) {\r\n            _weights[i] = _getRandom(100);\r\n            _weightRandomSum = _weightRandomSum.add(_weights[i]);\r\n        }\r\n\r\n        for(i = 0; i < _crystalAmount; i++) {\r\n            // Kind is decided randomly according to remaining crystal weights.\r\n            // That means crystals of large quantity are chosen with high probability.\r\n            _kinds[i] = _getFirstIndex(_getRandom(_totalWeight), _crystalWeightsCumsum);\r\n\r\n            // Weight is decided randomly according to estimatedWeight.\r\n            // EstimatedWeight is fixed (calculated in advance) in one mining.\r\n            // EstimatedWeight is randomly divided into each of weight.\r\n            // That means sum of weights is equal to EstimatedWeight.\r\n            uint256 actualWeight = estimatedWeight.mul(_pkxAmount);\r\n            _weights[i] = _weights[i].mul(actualWeight).div(_weightRandomSum);\r\n\r\n            // Gene is decided randomly.\r\n            _genes[i] = _generateGene();\r\n\r\n            require(_weights[i] > 0);\r\n\r\n            _tokenIds[i] = crystal.mint(_owner, _genes[i], _kinds[i], _weights[i]);\r\n\r\n            crystalWeights[_kinds[i]] = crystalWeights[_kinds[i]].sub(_weights[i]);\r\n\r\n            _weightSum = _weightSum.add(_weights[i]);\r\n        }\r\n\r\n        setEstimatedWeight(_weightSum);\r\n        pickaxe.burn(msg.sender, _pkxAmount);\r\n\r\n        emit MineCrystals(\r\n        _owner,\r\n        now,\r\n        _tokenIds,\r\n        _kinds,\r\n        _weights,\r\n        _genes\r\n        );\r\n    }\r\n\r\n    // @dev meltCrystals consists of two basic operations.\r\n    //      It burns old crystals and mint new crystal.\r\n    //      The weight of new crystal is the same to total weight of bunred crystals.\r\n    // @notice meltCrystals may have bugs. We will fix later.\r\n    // @param uint256[] _tokenIds the token ids of crystals to be melt\r\n    function meltCrystals(uint256[] _tokenIds) external onlyEOA {\r\n        uint256 _length = _tokenIds.length;\r\n        address _owner = msg.sender;\r\n\r\n        require(2 <= _length && _length <= 10);\r\n\r\n        uint256[] memory _kinds = new uint256[](_length);\r\n        uint256 _weight;\r\n        uint256 _totalWeight = 0;\r\n\r\n        for(uint256 i = 0; i < _length; i++) {\r\n            require(crystal.ownerOf(_tokenIds[i]) == _owner);\r\n            (_kinds[i], _weight) = crystal.getCrystalKindWeight(_tokenIds[i]);\r\n            if (i != 0) {\r\n                require(_kinds[i] == _kinds[i - 1]);\r\n            }\r\n\r\n            _totalWeight = _totalWeight.add(_weight);\r\n            crystal.burn(_owner, _tokenIds[i]);\r\n        }\r\n\r\n        uint256 _gene = _generateGene();\r\n        uint256 _tokenId = crystal.mint(_owner, _gene, _kinds[0], _totalWeight);\r\n\r\n        emit MeltCrystals(_owner, now, _tokenIds, _tokenId, _kinds[0], _totalWeight, _gene);\r\n    }\r\n\r\n    // @dev create exchange\r\n    // @param uint256 _tokenId tokenId you want to exchange\r\n    // @param uint256 _kind crystal kind you want to get\r\n    // @param uint256 _weight minimum crystal weight you want to get\r\n    function createExchange(uint256 _tokenId, uint256 _kind, uint256 _weight) external onlyEOA {\r\n        ExchangeWrapper memory _ew = ExchangeWrapper({\r\n            id: 0, // specify after\r\n            owner: msg.sender,\r\n            tokenId: _tokenId,\r\n            kind: _kind,\r\n            weight: _weight,\r\n            createdAt: 0\r\n            });\r\n\r\n        CrystalWrapper memory _cw = getCrystalWrapper(msg.sender, _tokenId);\r\n\r\n        require(crystal.ownerOf(_tokenId) == _cw.owner);\r\n        require(_kind < 100);\r\n\r\n        // escrow crystal to exchange contract\r\n        crystal._transferFrom(_cw.owner, exchange, _tokenId);\r\n\r\n        _ew.id = exchange.create(_ew.owner, _tokenId, _cw.gene, _cw.kind, _cw.weight, _ew.kind, _ew.weight, now);\r\n\r\n        emit CreateExchange(_ew.id, _ew.owner, _ew.tokenId, _cw.gene, _cw.kind, _cw.weight, _ew.kind, _ew.weight, now);\r\n    }\r\n\r\n    function getCrystalWrapper(address _owner, uint256 _tokenId) internal returns(CrystalWrapper) {\r\n        CrystalWrapper memory _cw;\r\n        _cw.owner = _owner;\r\n        _cw.tokenId = _tokenId;\r\n        (_cw.gene, _cw.kind, _cw.weight) = crystal.getCrystalGeneKindWeight(_tokenId);\r\n        return _cw;\r\n    }\r\n\r\n    // @dev cancel exchange\r\n    // @param uint256 _id exchangeId you want to cancel\r\n    function cancelExchange(uint256 _id) external onlyEOA {\r\n        require(exchange.ownerOf(_id) == msg.sender);\r\n\r\n        uint256 _tokenId = exchange.getTokenId(_id);\r\n\r\n        CrystalWrapper memory _cw = getCrystalWrapper(msg.sender, _tokenId);\r\n\r\n        // withdraw crystal from exchange contract\r\n        crystal._transferFrom(exchange, _cw.owner, _cw.tokenId);\r\n\r\n        exchange.remove(_id);\r\n\r\n        emit CancelExchange(_id, _cw.owner, _cw.tokenId, _cw.kind, _cw.weight, now);\r\n    }\r\n\r\n    // @dev bid exchange\r\n    // @param uint256 _exchangeId exchange id you want to bid\r\n    // @param uint256 _tokenId token id of your crystal to be exchanged\r\n    function bidExchange(uint256 _exchangeId, uint256 _tokenId) external onlyEOA {\r\n        // exchange\r\n        ExchangeWrapper memory _ew;\r\n        _ew.id = _exchangeId;\r\n        (_ew.owner, _ew.tokenId, _ew.kind, _ew.weight, _ew.createdAt) = exchange.getExchange(_ew.id); // check existence\r\n\r\n        // crystal of exchanger\r\n        CrystalWrapper memory _cwe = getCrystalWrapper(msg.sender, _tokenId);\r\n\r\n        // crystal of creator of exchange\r\n        CrystalWrapper memory _cwo = getCrystalWrapper(_ew.owner, _ew.tokenId);\r\n\r\n        require(_cwe.owner != _ew.owner);\r\n        require(_cwe.kind == _ew.kind);\r\n        require(_cwe.weight >= _ew.weight);\r\n\r\n        // transfer my crystal to owner of exchange\r\n        crystal._transferFrom(_cwe.owner, _ew.owner, _cwe.tokenId);\r\n\r\n        // transfer escrowed crystal to me.\r\n        crystal._transferFrom(exchange, _cwe.owner, _ew.tokenId);\r\n\r\n        exchange.remove(_ew.id);\r\n\r\n        emit BidExchange(_ew.id, _ew.owner, _ew.tokenId, _cwo.gene, _cwo.kind, _cwo.weight, _cwe.owner, _cwe.tokenId, _cwe.kind, _cwe.weight, now);\r\n    }\r\n\r\n    // @dev get index when cumsum[i] exceeds _in first.\r\n    // @param uint256 _min\r\n    // @param uint256[] _sorted array is required to be sorted by ascending order\r\n    function _getFirstIndex(uint256 _min, uint256[] _sorted) public pure returns(uint256) {\r\n        for(uint256 i = 0; i < _sorted.length; i++) {\r\n            if(_min < _sorted[i]) {\r\n                return i;\r\n            }\r\n        }\r\n        return _sorted.length - 1;\r\n    }\r\n\r\n    function _transferFromOwner(address _to, uint256 _value) internal {\r\n        pickaxe.transferFromOwner(_to, _value);\r\n    }\r\n\r\n    function _generateGene() internal returns(uint256) {\r\n        return _getRandom(~uint256(0));\r\n    }\r\n\r\n    function _getRandom(uint256 _max) public returns(uint256){\r\n        bytes32 hash = keccak256(generator.generate());\r\n        uint256 number = (uint256(hash) % _max) + 1;\r\n        //emit RandomGenerated(number);\r\n        return number;\r\n    }\r\n\r\n    // @dev change random generator\r\n    // @param RandomGeneratorIF randomGenerator contract address\r\n    function setRandomGenerator(RandomGeneratorIF _generator) external onlyOwner {\r\n        generator = _generator;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyPickaxes\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_initialBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_currentBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_secondsPerBlock\",\"type\":\"uint256\"}],\"name\":\"_getBlockIndexAtYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalWeight\",\"type\":\"uint256\"},{\"name\":\"_yearIndex\",\"type\":\"uint256\"}],\"name\":\"_getWeightUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_min\",\"type\":\"uint256\"},{\"name\":\"_sorted\",\"type\":\"uint256[]\"}],\"name\":\"_getFirstIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockNumberUpdated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"estimatedWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_secondsPerBlock\",\"type\":\"uint256\"},{\"name\":\"_initialBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_currentBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_totalWeight\",\"type\":\"uint256\"}],\"name\":\"_estimateSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"originalTotalWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_generator\",\"type\":\"address\"}],\"name\":\"setRandomGenerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_secondsPerBlock\",\"type\":\"uint256\"},{\"name\":\"_initialBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_currentBlockNumber\",\"type\":\"uint256\"}],\"name\":\"_getYearIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"cancelExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_kind\",\"type\":\"uint256\"},{\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"createExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"generator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_donationWallet\",\"type\":\"address\"}],\"name\":\"setEthereumWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_secondsPerBlock\",\"type\":\"uint256\"}],\"name\":\"_getBlocksPerYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"meltCrystals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crystal\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_initialBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_currentBlockNumber\",\"type\":\"uint256\"}],\"name\":\"_getBlockIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_secondsPerBlock\",\"type\":\"uint256\"},{\"name\":\"_currentBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_blockNumberUpdated\",\"type\":\"uint256\"}],\"name\":\"_updateNeeded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_secondsPerBlock\",\"type\":\"uint256\"},{\"name\":\"_initialBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_currentBlockNumber\",\"type\":\"uint256\"},{\"name\":\"_totalWeight\",\"type\":\"uint256\"},{\"name\":\"_currentWeight\",\"type\":\"uint256\"}],\"name\":\"_estimateWeight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_secondsPerBlock\",\"type\":\"uint256\"}],\"name\":\"_getWaitingBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pkxAmount\",\"type\":\"uint256\"}],\"name\":\"mineCrystals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bidExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"_getRandom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCrystalWeights\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[100]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_WEI_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pickaxe\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pickaxe\",\"type\":\"address\"},{\"name\":\"_crystal\",\"type\":\"address\"},{\"name\":\"_exchange\",\"type\":\"address\"},{\"name\":\"_generator\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_donationWallet\",\"type\":\"address\"},{\"name\":\"_donationRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"minedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"kinds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"weights\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"genes\",\"type\":\"uint256[]\"}],\"name\":\"MineCrystals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"meltedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"meltedTokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"kind\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gene\",\"type\":\"uint256\"}],\"name\":\"MeltCrystals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ownerTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownerTokenGene\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownerTokenKind\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownerTokenWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"kind\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"createdAt\",\"type\":\"uint256\"}],\"name\":\"CreateExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ownerTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownerTokenKind\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownerTokenWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cancelledAt\",\"type\":\"uint256\"}],\"name\":\"CancelExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ownerTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownerTokenGene\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownerTokenKind\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownerTokenWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchanger\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"exchangerTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchangerTokenKind\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchangerTokenWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bidAt\",\"type\":\"uint256\"}],\"name\":\"BidExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextUpdateBlockNumber\",\"type\":\"uint256\"}],\"name\":\"UpdateEstimatedWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"ForwardFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Donation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CryptoCrystal","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005116c1d70e3a2cf55a2502d05f1bc17a0518782e000000000000000000000000cfbc9103362aec4ce3089f155c2da2eea1cb7602000000000000000000000000b6e928db347dbaad2c06868b716a2cf488904574000000000000000000000000045f11fc6fbed29b73119f4d51570c7e64af75f30000000000000000000000007b37faf831044d08da0c0e7419e2e31615f43032000000000000000000000000fb6916095ca1df60bb79ce92ce3ea74c37c5d3590000000000000000000000000000000000000000000000000000000000000032","Library":"","SwarmSource":"bzzr://459e86dc3ddcfbb169995058294fa47fed86bd909aaa082d9f46f3c6b7e881da"}]}