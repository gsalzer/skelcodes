{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic authorization control functions,\r\n/// this simplifies the implementation of \"user permissions\".\r\n/// @dev Based on OpenZeppelin's Ownable.\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed _by, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    /// @dev Constructor sets the original `owner` of the contract to the sender account.\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerCandidate() {\r\n        require(msg.sender == newOwnerCandidate);\r\n        _;\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        require(_newOwnerCandidate != address(0));\r\n\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accept ownership transfer. This method needs to be called by the perviously proposed owner.\r\n    function acceptOwnership() external onlyOwnerCandidate {\r\n        address previousOwner = owner;\r\n\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = address(0);\r\n\r\n        OwnershipTransferred(previousOwner, owner);\r\n    }\r\n}\r\n\r\n/// @title Math operations with safety checks\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // require(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function toPower2(uint256 a) internal pure returns (uint256) {\r\n        return mul(a, a);\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        uint256 c = (a + 1) / 2;\r\n        uint256 b = a;\r\n        while (c < b) {\r\n            b = c;\r\n            c = (a / c + c) / 2;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n\r\n/// @title ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/issues/20)\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n    function balanceOf(address _owner) constant public returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n/// @title ERC Token Standard #677 Interface (https://github.com/ethereum/EIPs/issues/677)\r\ncontract ERC677 is ERC20 {\r\n    function transferAndCall(address to, uint value, bytes data) public returns (bool ok);\r\n\r\n    event TransferAndCall(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\n/// @title ERC223Receiver Interface\r\n/// @dev Based on the specs form: https://github.com/ethereum/EIPs/issues/223\r\ncontract ERC223Receiver {\r\n    function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\r\n}\r\n\r\n\r\n\r\n\r\n/// @title Basic ERC20 token contract implementation.\r\n/// @dev Based on OpenZeppelin's StandardToken.\r\ncontract BasicToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public totalSupply;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => uint256) balances;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve (see NOTE)\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\r\n            revert();\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    /// @param _owner address The address which owns the funds.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @return uint256 specifying the amount of tokens still available for the spender.\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner address The address to query the the balance of.\r\n    /// @return uint256 representing the amount owned by the passed address.\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @dev Transfer token to a specified address.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another.\r\n    /// @param _from address The address which you want to send tokens from.\r\n    /// @param _to address The address which you want to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Standard677Token implentation, base on https://github.com/ethereum/EIPs/issues/677\r\n\r\ncontract Standard677Token is ERC677, BasicToken {\r\n\r\n  /// @dev ERC223 safe token transfer from one address to another\r\n  /// @param _to address the address which you want to transfer to.\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function transferAndCall(address _to, uint _value, bytes _data) public returns (bool) {\r\n    require(super.transfer(_to, _value)); // do a normal token transfer\r\n    TransferAndCall(msg.sender, _to, _value, _data);\r\n    //filtering if the target is a contract with bytecode inside it\r\n    if (isContract(_to)) return contractFallback(_to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  /// @dev called when transaction target is a contract\r\n  /// @param _to address the address which you want to transfer to.\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function contractFallback(address _to, uint _value, bytes _data) private returns (bool) {\r\n    ERC223Receiver receiver = ERC223Receiver(_to);\r\n    require(receiver.tokenFallback(msg.sender, _value, _data));\r\n    return true;\r\n  }\r\n\r\n  /// @dev check if the address is contract\r\n  /// assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  /// @param _addr address the address to check\r\n  function isContract(address _addr) private constant returns (bool is_contract) {\r\n    // retrieve the size of the code on target address, this needs assembly\r\n    uint length;\r\n    assembly { length := extcodesize(_addr) }\r\n    return length > 0;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Token holder contract.\r\ncontract TokenHolder is Ownable {\r\n    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n    /// @param _tokenAddress address The address of the ERC20 contract.\r\n    /// @param _amount uint256 The amount of tokens to be transferred.\r\n    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\r\n        return ERC20(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Colu Local Network contract.\r\n/// @author Tal Beja.\r\ncontract ColuLocalNetwork is Ownable, Standard677Token, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Colu Local Network\";\r\n    string public constant symbol = \"CLN\";\r\n\r\n    // Using same decimals value as ETH (makes ETH-CLN conversion much easier).\r\n    uint8 public constant decimals = 18;\r\n\r\n    // States whether token transfers is allowed or not.\r\n    // Used during token sale.\r\n    bool public isTransferable = false;\r\n\r\n    event TokensTransferable();\r\n\r\n    modifier transferable() {\r\n        require(msg.sender == owner || isTransferable);\r\n        _;\r\n    }\r\n\r\n    /// @dev Creates all tokens and gives them to the owner.\r\n    function ColuLocalNetwork(uint256 _totalSupply) public {\r\n        totalSupply = _totalSupply;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n\r\n    /// @dev start transferable mode.\r\n    function makeTokensTransferable() external onlyOwner {\r\n        if (isTransferable) {\r\n            return;\r\n        }\r\n\r\n        isTransferable = true;\r\n\r\n        TokensTransferable();\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if not transferable.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public transferable returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if not transferable.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public transferable returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if not transferable.\r\n    /// @param _from address The address to send tokens from.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public transferable returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /// @dev Same ERC677 behavior, but reverts if not transferable.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    /// @param _data bytes data to send to receiver if it is a contract.\r\n    function transferAndCall(address _to, uint _value, bytes _data) public transferable returns (bool success) {\r\n      return super.transferAndCall(_to, _value, _data);\r\n    }\r\n}\r\n\r\n\r\n\r\n /// @title Standard ERC223 Token Receiver implementing tokenFallback function and tokenPayable modifier\r\n\r\ncontract Standard223Receiver is ERC223Receiver {\r\n  Tkn tkn;\r\n\r\n  struct Tkn {\r\n    address addr;\r\n    address sender; // the transaction caller\r\n    uint256 value;\r\n  }\r\n\r\n  bool __isTokenFallback;\r\n\r\n  modifier tokenPayable {\r\n    require(__isTokenFallback);\r\n    _;\r\n  }\r\n\r\n  /// @dev Called when the receiver of transfer is contract\r\n  /// @param _sender address the address of tokens sender\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\r\n    if (!supportsToken(msg.sender)) {\r\n      return false;\r\n    }\r\n\r\n    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\r\n    // Solution: Remove the the data\r\n    tkn = Tkn(msg.sender, _sender, _value);\r\n    __isTokenFallback = true;\r\n    if (!address(this).delegatecall(_data)) {\r\n      __isTokenFallback = false;\r\n      return false;\r\n    }\r\n    // avoid doing an overwrite to .token, which would be more expensive\r\n    // makes accessing .tkn values outside tokenPayable functions unsafe\r\n    __isTokenFallback = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function supportsToken(address token) public constant returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title TokenOwnable\r\n/// @dev The TokenOwnable contract adds a onlyTokenOwner modifier as a tokenReceiver with ownable addaptation\r\n\r\ncontract TokenOwnable is Standard223Receiver, Ownable {\r\n    /// @dev Reverts if called by any account other than the owner for token sending.\r\n    modifier onlyTokenOwner() {\r\n        require(tkn.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Vesting trustee contract for Colu Local Network.\r\n/// @dev This Contract can't be TokenHolder, since it will allow its owner to drain its vested tokens.\r\n/// @dev This means that any token sent to it different than ColuLocalNetwork is basicly stucked here forever.\r\n/// @dev ColuLocalNetwork that sent here (by mistake) can withdrawn using the grant method.\r\ncontract VestingTrustee is TokenOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    // Colu Local Network contract.\r\n    ColuLocalNetwork public cln;\r\n\r\n    // Vesting grant for a speicifc holder.\r\n    struct Grant {\r\n        uint256 value;\r\n        uint256 start;\r\n        uint256 cliff;\r\n        uint256 end;\r\n        uint256 installmentLength; // In seconds.\r\n        uint256 transferred;\r\n        bool revokable;\r\n    }\r\n\r\n    // Holder to grant information mapping.\r\n    mapping (address => Grant) public grants;\r\n\r\n    // Total tokens vested.\r\n    uint256 public totalVesting;\r\n\r\n    event NewGrant(address indexed _from, address indexed _to, uint256 _value);\r\n    event TokensUnlocked(address indexed _to, uint256 _value);\r\n    event GrantRevoked(address indexed _holder, uint256 _refund);\r\n\r\n    uint constant OK = 1;\r\n    uint constant ERR_INVALID_VALUE = 10001;\r\n    uint constant ERR_INVALID_VESTED = 10002;\r\n    uint constant ERR_INVALID_TRANSFERABLE = 10003;\r\n\r\n    event Error(address indexed sender, uint error);\r\n\r\n    /// @dev Constructor that initializes the address of the Colu Local Network contract.\r\n    /// @param _cln ColuLocalNetwork The address of the previously deployed Colu Local Network contract.\r\n    function VestingTrustee(ColuLocalNetwork _cln) public {\r\n        require(_cln != address(0));\r\n\r\n        cln = _cln;\r\n    }\r\n\r\n    /// @dev Allow only cln token to be tokenPayable\r\n    /// @param token the token to check\r\n    function supportsToken(address token) public constant returns (bool) {\r\n        return (cln == token);\r\n    }\r\n\r\n    /// @dev Grant tokens to a specified address.\r\n    /// @param _to address The holder address.\r\n    /// @param _start uint256 The beginning of the vesting period (timestamp).\r\n    /// @param _cliff uint256 When the first installment is made (timestamp).\r\n    /// @param _end uint256 The end of the vesting period (timestamp).\r\n    /// @param _installmentLength uint256 The length of each vesting installment (in seconds).\r\n    /// @param _revokable bool Whether the grant is revokable or not.\r\n    function grant(address _to, uint256 _start, uint256 _cliff, uint256 _end,\r\n        uint256 _installmentLength, bool _revokable)\r\n        external onlyTokenOwner tokenPayable {\r\n\r\n        require(_to != address(0));\r\n        require(_to != address(this)); // Protect this contract from receiving a grant.\r\n\r\n        uint256 value = tkn.value;\r\n\r\n        require(value > 0);\r\n\r\n        // Require that every holder can be granted tokens only once.\r\n        require(grants[_to].value == 0);\r\n\r\n        // Require for time ranges to be consistent and valid.\r\n        require(_start <= _cliff && _cliff <= _end);\r\n\r\n        // Require installment length to be valid and no longer than (end - start).\r\n        require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\r\n\r\n        // Grant must not exceed the total amount of tokens currently available for vesting.\r\n        require(totalVesting.add(value) <= cln.balanceOf(address(this)));\r\n\r\n        // Assign a new grant.\r\n        grants[_to] = Grant({\r\n            value: value,\r\n            start: _start,\r\n            cliff: _cliff,\r\n            end: _end,\r\n            installmentLength: _installmentLength,\r\n            transferred: 0,\r\n            revokable: _revokable\r\n        });\r\n\r\n        // Since tokens have been granted, increase the total amount vested.\r\n        totalVesting = totalVesting.add(value);\r\n\r\n        NewGrant(msg.sender, _to, value);\r\n    }\r\n\r\n    /// @dev Grant tokens to a specified address.\r\n    /// @param _to address The holder address.\r\n    /// @param _value uint256 The amount of tokens to be granted.\r\n    /// @param _start uint256 The beginning of the vesting period (timestamp).\r\n    /// @param _cliff uint256 When the first installment is made (timestamp).\r\n    /// @param _end uint256 The end of the vesting period (timestamp).\r\n    /// @param _installmentLength uint256 The length of each vesting installment (in seconds).\r\n    /// @param _revokable bool Whether the grant is revokable or not.\r\n    function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\r\n        uint256 _installmentLength, bool _revokable)\r\n        external onlyOwner {\r\n\r\n        require(_to != address(0));\r\n        require(_to != address(this)); // Protect this contract from receiving a grant.\r\n        require(_value > 0);\r\n\r\n        // Require that every holder can be granted tokens only once.\r\n        require(grants[_to].value == 0);\r\n\r\n        // Require for time ranges to be consistent and valid.\r\n        require(_start <= _cliff && _cliff <= _end);\r\n\r\n        // Require installment length to be valid and no longer than (end - start).\r\n        require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\r\n\r\n        // Grant must not exceed the total amount of tokens currently available for vesting.\r\n        require(totalVesting.add(_value) <= cln.balanceOf(address(this)));\r\n\r\n        // Assign a new grant.\r\n        grants[_to] = Grant({\r\n            value: _value,\r\n            start: _start,\r\n            cliff: _cliff,\r\n            end: _end,\r\n            installmentLength: _installmentLength,\r\n            transferred: 0,\r\n            revokable: _revokable\r\n        });\r\n\r\n        // Since tokens have been granted, increase the total amount vested.\r\n        totalVesting = totalVesting.add(_value);\r\n\r\n        NewGrant(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @dev Revoke the grant of tokens of a specifed address.\r\n    /// @dev Unlocked tokens will be sent to the grantee, the rest is transferred to the trustee's owner.\r\n    /// @param _holder The address which will have its tokens revoked.\r\n    function revoke(address _holder) public onlyOwner {\r\n        Grant memory grant = grants[_holder];\r\n\r\n        // Grant must be revokable.\r\n        require(grant.revokable);\r\n\r\n        // Get the total amount of vested tokens, acccording to grant.\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n\r\n        // Calculate the untransferred vested tokens.\r\n        uint256 transferable = vested.sub(grant.transferred);\r\n\r\n        if (transferable > 0) {\r\n            // Update transferred and total vesting amount, then transfer remaining vested funds to holder.\r\n            grant.transferred = grant.transferred.add(transferable);\r\n            totalVesting = totalVesting.sub(transferable);\r\n            require(cln.transfer(_holder, transferable));\r\n\r\n            TokensUnlocked(_holder, transferable);\r\n        }\r\n\r\n        // Calculate amount of remaining tokens that can still be returned.\r\n        uint256 refund = grant.value.sub(grant.transferred);\r\n\r\n        // Remove the grant.\r\n        delete grants[_holder];\r\n\r\n        // Update total vesting amount and transfer previously calculated tokens to owner.\r\n        totalVesting = totalVesting.sub(refund);\r\n        require(cln.transfer(msg.sender, refund));\r\n\r\n        GrantRevoked(_holder, refund);\r\n    }\r\n\r\n    /// @dev Calculate the amount of ready tokens of a holder.\r\n    /// @param _holder address The address of the holder.\r\n    /// @return a uint256 Representing a holder's total amount of vested tokens.\r\n    function readyTokens(address _holder) public constant returns (uint256) {\r\n        Grant memory grant = grants[_holder];\r\n\r\n        if (grant.value == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n\r\n        if (vested == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return vested.sub(grant.transferred);\r\n    }\r\n\r\n    /// @dev Calculate the total amount of vested tokens of a holder at a given time.\r\n    /// @param _holder address The address of the holder.\r\n    /// @param _time uint256 The specific time to calculate against.\r\n    /// @return a uint256 Representing a holder's total amount of vested tokens.\r\n    function vestedTokens(address _holder, uint256 _time) public constant returns (uint256) {\r\n        Grant memory grant = grants[_holder];\r\n        if (grant.value == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return calculateVestedTokens(grant, _time);\r\n    }\r\n\r\n    /// @dev Calculate amount of vested tokens at a specifc time.\r\n    /// @param _grant Grant The vesting grant.\r\n    /// @param _time uint256 The time to be checked\r\n    /// @return An uint256 Representing the amount of vested tokens of a specific grant.\r\n    function calculateVestedTokens(Grant _grant, uint256 _time) private pure returns (uint256) {\r\n        // If we're before the cliff, then nothing is vested.\r\n        if (_time < _grant.cliff) {\r\n            return 0;\r\n        }\r\n\r\n        // If we're after the end of the vesting period - everything is vested.\r\n        if (_time >= _grant.end) {\r\n            return _grant.value;\r\n        }\r\n\r\n        // Calculate amount of installments past until now.\r\n        //\r\n        // NOTE: result gets floored because of integer division.\r\n        uint256 installmentsPast = _time.sub(_grant.start).div(_grant.installmentLength);\r\n\r\n        // Calculate amount of days in entire vesting period.\r\n        uint256 vestingDays = _grant.end.sub(_grant.start);\r\n\r\n        // Calculate and return the number of tokens according to vesting days that have passed.\r\n        return _grant.value.mul(installmentsPast.mul(_grant.installmentLength)).div(vestingDays);\r\n    }\r\n\r\n    /// @dev Unlock vested tokens and transfer them to the grantee.\r\n    /// @return a uint The success or error code.\r\n    function unlockVestedTokens() external returns (uint) {\r\n        return unlockVestedTokens(msg.sender);\r\n    }\r\n\r\n    /// @dev Unlock vested tokens and transfer them to the grantee (helper function).\r\n    /// @param _grantee address The address of the grantee.\r\n    /// @return a uint The success or error code.\r\n    function unlockVestedTokens(address _grantee) private returns (uint) {\r\n        Grant storage grant = grants[_grantee];\r\n\r\n        // Make sure the grant has tokens available.\r\n        if (grant.value == 0) {\r\n            Error(_grantee, ERR_INVALID_VALUE);\r\n            return ERR_INVALID_VALUE;\r\n        }\r\n\r\n        // Get the total amount of vested tokens, acccording to grant.\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n        if (vested == 0) {\r\n            Error(_grantee, ERR_INVALID_VESTED);\r\n            return ERR_INVALID_VESTED;\r\n        }\r\n\r\n        // Make sure the holder doesn't transfer more than what he already has.\r\n        uint256 transferable = vested.sub(grant.transferred);\r\n        if (transferable == 0) {\r\n            Error(_grantee, ERR_INVALID_TRANSFERABLE);\r\n            return ERR_INVALID_TRANSFERABLE;\r\n        }\r\n\r\n        // Update transferred and total vesting amount, then transfer remaining vested funds to holder.\r\n        grant.transferred = grant.transferred.add(transferable);\r\n        totalVesting = totalVesting.sub(transferable);\r\n        require(cln.transfer(_grantee, transferable));\r\n\r\n        TokensUnlocked(_grantee, transferable);\r\n        return OK;\r\n    }\r\n\r\n    /// @dev batchUnlockVestedTokens vested tokens and transfer them to the grantees.\r\n    /// @param _grantees address[] The addresses of the grantees.\r\n    /// @return a boo if success.\r\n    function batchUnlockVestedTokens(address[] _grantees) external onlyOwner returns (bool success) {\r\n        for (uint i = 0; i<_grantees.length; i++) {\r\n            unlockVestedTokens(_grantees[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n    /// @param _tokenAddress address The address of the ERC20 contract.\r\n    /// @param _amount uint256 The amount of tokens to be transferred.\r\n    function withdrawERC20(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\r\n        if (_tokenAddress == address(cln)) {\r\n            // If the token is cln, allow to withdraw only non vested tokens.\r\n            uint256 availableCLN = cln.balanceOf(this).sub(totalVesting);\r\n            require(_amount <= availableCLN);\r\n        }\r\n        return ERC20(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Colu Local Network sale contract.\r\n/// @author Tal Beja.\r\ncontract ColuLocalNetworkSale is Ownable, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    // External parties:\r\n\r\n    // Colu Local Network contract.\r\n    ColuLocalNetwork public cln;\r\n\r\n    // Vesting contract for presale participants.\r\n    VestingTrustee public trustee;\r\n\r\n    // Received funds are forwarded to this address.\r\n    address public fundingRecipient;\r\n\r\n    // Post-TDE multisig addresses.\r\n    address public communityPoolAddress;\r\n    address public futureDevelopmentPoolAddress;\r\n    address public stakeholdersPoolAddress;\r\n\r\n    // Colu Local Network decimals.\r\n    // Using same decimals value as ETH (makes ETH-CLN conversion much easier).\r\n    // This is the same as in Colu Local Network contract.\r\n    uint256 public constant TOKEN_DECIMALS = 10 ** 18;\r\n\r\n    // Additional Lockup Allocation Pool\r\n    uint256 public constant ALAP = 40701333592592592592614116;\r\n\r\n    // Maximum number of tokens in circulation: 1.5 trillion.\r\n    uint256 public constant MAX_TOKENS = 15 * 10 ** 8 * TOKEN_DECIMALS + ALAP;\r\n\r\n    // Maximum tokens offered in the sale (35%) + ALAP.\r\n    uint256 public constant MAX_TOKENS_SOLD = 525 * 10 ** 6 * TOKEN_DECIMALS + ALAP;\r\n\r\n    // Maximum tokens offered in the presale (from the initial 35% offered tokens) + ALAP.\r\n    uint256 public constant MAX_PRESALE_TOKENS_SOLD = 2625 * 10 ** 5 * TOKEN_DECIMALS + ALAP;\r\n\r\n    // Tokens allocated for Community pool (30%).\r\n    uint256 public constant COMMUNITY_POOL = 45 * 10 ** 7 * TOKEN_DECIMALS;\r\n\r\n    // Tokens allocated for Future development pool (29%).\r\n    uint256 public constant FUTURE_DEVELOPMENT_POOL = 435 * 10 ** 6 * TOKEN_DECIMALS;\r\n\r\n    // Tokens allocated for Stakeholdes pool (6%).\r\n    uint256 public constant STAKEHOLDERS_POOL = 9 * 10 ** 7 * TOKEN_DECIMALS;\r\n\r\n    // CLN to ETH ratio.\r\n    uint256 public constant CLN_PER_ETH = 8600;\r\n\r\n    // Sale start, end blocks (time ranges)\r\n    uint256 public constant SALE_DURATION = 4 days;\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    // Amount of tokens sold until now in the sale.\r\n    uint256 public tokensSold = 0;\r\n\r\n    // Amount of tokens sold until now in the presale.\r\n    uint256 public presaleTokensSold = 0;\r\n\r\n    // Accumulated amount each participant has contributed so far in the sale (in WEI).\r\n    mapping (address => uint256) public participationHistory;\r\n\r\n    // Accumulated amount each participant have contributed so far in the presale.\r\n    mapping (address => uint256) public participationPresaleHistory;\r\n\r\n    // Maximum amount that each particular is allowed to contribute (in ETH-WEI).\r\n    // Defaults to zero. Serving as a functional whitelist. \r\n    mapping (address => uint256) public participationCaps;\r\n\r\n    // Maximum amount ANYONE is currently allowed to contribute. Set to max uint256 so no limitation other than personal participationCaps.\r\n    uint256 public hardParticipationCap = uint256(-1);\r\n\r\n    // initialization of the contract, splitted from the constructor to avoid gas block limit.\r\n    bool public initialized = false;\r\n\r\n    // Vesting plan structure for presale\r\n    struct VestingPlan {\r\n        uint256 startOffset;\r\n        uint256 cliffOffset;\r\n        uint256 endOffset;\r\n        uint256 installmentLength;\r\n        uint8 alapPercent;\r\n    }\r\n\r\n    // Vesting plans for presale\r\n    VestingPlan[] public vestingPlans;\r\n\r\n    // Each token that is sent from the ColuLocalNetworkSale is considered as issued.\r\n    event TokensIssued(address indexed to, uint256 tokens);\r\n\r\n    /// @dev Reverts if called not before the sale.\r\n    modifier onlyBeforeSale() {\r\n        if (now >= startTime) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Reverts if called not during the sale.\r\n    modifier onlyDuringSale() {\r\n        if (tokensSold >= MAX_TOKENS_SOLD || now < startTime || now >= endTime) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Reverts if called before the sale ends.\r\n    modifier onlyAfterSale() {\r\n        if (!(tokensSold >= MAX_TOKENS_SOLD || now >= endTime)) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Reverts if called before the sale is initialized.\r\n    modifier notInitialized() {\r\n        if (initialized) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n\r\n    /// @dev Reverts if called after the sale is initialized.\r\n    modifier isInitialized() {\r\n        if (!initialized) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor sets the sale addresses and start time.\r\n    /// @param _owner address The address of this contract owner.\r\n    /// @param _fundingRecipient address The address of the funding recipient.\r\n    /// @param _communityPoolAddress address The address of the community pool.\r\n    /// @param _futureDevelopmentPoolAddress address The address of the future development pool.\r\n    /// @param _stakeholdersPoolAddress address The address of the team pool.\r\n    /// @param _startTime uint256 The start time of the token sale.\r\n    function ColuLocalNetworkSale(address _owner,\r\n        address _fundingRecipient,\r\n        address _communityPoolAddress,\r\n        address _futureDevelopmentPoolAddress,\r\n        address _stakeholdersPoolAddress,\r\n        uint256 _startTime) public {\r\n        require(_owner != address(0));\r\n        require(_fundingRecipient != address(0));\r\n        require(_communityPoolAddress != address(0));\r\n        require(_futureDevelopmentPoolAddress != address(0));\r\n        require(_stakeholdersPoolAddress != address(0));\r\n        require(_startTime > now);\r\n\r\n        owner = _owner;\r\n        fundingRecipient = _fundingRecipient;\r\n        communityPoolAddress = _communityPoolAddress;\r\n        futureDevelopmentPoolAddress = _futureDevelopmentPoolAddress;\r\n        stakeholdersPoolAddress = _stakeholdersPoolAddress;\r\n        startTime = _startTime;\r\n        endTime = startTime + SALE_DURATION;\r\n    }\r\n\r\n    /// @dev Initialize the sale conditions.\r\n    function initialize() public onlyOwner notInitialized {\r\n        initialized = true;\r\n\r\n        uint256 months = 1 years / 12;\r\n\r\n        vestingPlans.push(VestingPlan(0, 0, 1, 1, 0));\r\n        vestingPlans.push(VestingPlan(0, 0, 6 * months, 1 * months, 4));\r\n        vestingPlans.push(VestingPlan(0, 0, 1 years, 1 * months, 12));\r\n        vestingPlans.push(VestingPlan(0, 0, 2 years, 1 * months, 26));\r\n        vestingPlans.push(VestingPlan(0, 0, 3 years, 1 * months, 35));\r\n\r\n        // Deploy new ColuLocalNetwork contract.\r\n        cln = new ColuLocalNetwork(MAX_TOKENS);\r\n\r\n        // Deploy new VestingTrustee contract.\r\n        trustee = new VestingTrustee(cln);\r\n\r\n        // allocate pool tokens:\r\n        // Issue the remaining tokens to designated pools.\r\n        require(transferTokens(communityPoolAddress, COMMUNITY_POOL));\r\n\r\n        // stakeholdersPoolAddress will create its own vesting trusts.\r\n        require(transferTokens(stakeholdersPoolAddress, STAKEHOLDERS_POOL));\r\n    }\r\n\r\n    /// @dev Allocate tokens to presale participant according to its vesting plan and invesment value.\r\n    /// @param _recipient address The presale participant address to recieve the tokens.\r\n    /// @param _etherValue uint256 The invesment value (in ETH).\r\n    /// @param _vestingPlanIndex uint8 The vesting plan index.\r\n    function presaleAllocation(address _recipient, uint256 _etherValue, uint8 _vestingPlanIndex) external onlyOwner onlyBeforeSale isInitialized {\r\n        require(_recipient != address(0));\r\n        require(_vestingPlanIndex < vestingPlans.length);\r\n\r\n        // Calculate plan and token amount.\r\n        VestingPlan memory plan = vestingPlans[_vestingPlanIndex];\r\n        uint256 tokensAndALAPPerEth = CLN_PER_ETH.mul(SafeMath.add(100, plan.alapPercent)).div(100);\r\n\r\n        uint256 tokensLeftInPreSale = MAX_PRESALE_TOKENS_SOLD.sub(presaleTokensSold);\r\n        uint256 weiLeftInSale = tokensLeftInPreSale.div(tokensAndALAPPerEth);\r\n        uint256 weiToParticipate = SafeMath.min256(_etherValue, weiLeftInSale);\r\n        require(weiToParticipate > 0);\r\n        participationPresaleHistory[msg.sender] = participationPresaleHistory[msg.sender].add(weiToParticipate);\r\n        uint256 tokensToTransfer = weiToParticipate.mul(tokensAndALAPPerEth);\r\n        presaleTokensSold = presaleTokensSold.add(tokensToTransfer);\r\n        tokensSold = tokensSold.add(tokensToTransfer);\r\n\r\n        // Transfer tokens to trustee and create grant.\r\n        grant(_recipient, tokensToTransfer, startTime.add(plan.startOffset), startTime.add(plan.cliffOffset),\r\n            startTime.add(plan.endOffset), plan.installmentLength, false);\r\n    }\r\n\r\n    /// @dev Add a list of participants to a capped participation tier.\r\n    /// @param _participants address[] The list of participant addresses.\r\n    /// @param _cap uint256 The cap amount (in ETH-WEI).\r\n    function setParticipationCap(address[] _participants, uint256 _cap) external onlyOwner isInitialized {\r\n        for (uint i = 0; i < _participants.length; i++) {\r\n            participationCaps[_participants[i]] = _cap;\r\n        }\r\n    }\r\n\r\n    /// @dev Set hard participation cap for all participants.\r\n    /// @param _cap uint256 The hard cap amount.\r\n    function setHardParticipationCap(uint256 _cap) external onlyOwner isInitialized {\r\n        require(_cap > 0);\r\n\r\n        hardParticipationCap = _cap;\r\n    }\r\n\r\n    /// @dev Fallback function that will delegate the request to participate().\r\n    function () external payable onlyDuringSale isInitialized {\r\n        participate(msg.sender);\r\n    }\r\n\r\n    /// @dev Create and sell tokens to the caller.\r\n    /// @param _recipient address The address of the recipient receiving the tokens.\r\n    function participate(address _recipient) public payable onlyDuringSale isInitialized {\r\n        require(_recipient != address(0));\r\n\r\n        // Enforce participation cap (in WEI received).\r\n        uint256 weiAlreadyParticipated = participationHistory[_recipient];\r\n        uint256 participationCap = SafeMath.min256(participationCaps[_recipient], hardParticipationCap);\r\n        uint256 cappedWeiReceived = SafeMath.min256(msg.value, participationCap.sub(weiAlreadyParticipated));\r\n        require(cappedWeiReceived > 0);\r\n\r\n        // Accept funds and transfer to funding recipient.\r\n        uint256 tokensLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold);\r\n        uint256 weiLeftInSale = tokensLeftInSale.div(CLN_PER_ETH);\r\n        uint256 weiToParticipate = SafeMath.min256(cappedWeiReceived, weiLeftInSale);\r\n        participationHistory[_recipient] = weiAlreadyParticipated.add(weiToParticipate);\r\n        fundingRecipient.transfer(weiToParticipate);\r\n\r\n        // Transfer tokens to recipient.\r\n        uint256 tokensToTransfer = weiToParticipate.mul(CLN_PER_ETH);\r\n        if (tokensLeftInSale.sub(tokensToTransfer) < CLN_PER_ETH) {\r\n            // If purchase would cause less than CLN_PER_ETH tokens to be left then nobody could ever buy them.\r\n            // So, gift them to the last buyer.\r\n            tokensToTransfer = tokensLeftInSale;\r\n        }\r\n        tokensSold = tokensSold.add(tokensToTransfer);\r\n        require(transferTokens(_recipient, tokensToTransfer));\r\n\r\n        // Partial refund if full participation not possible\r\n        // e.g. due to cap being reached.\r\n        uint256 refund = msg.value.sub(weiToParticipate);\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n    }\r\n\r\n    /// @dev Finalizes the token sale event: make future development pool grant (lockup) and make token transfarable.\r\n    function finalize() external onlyAfterSale onlyOwner isInitialized {\r\n        if (cln.isTransferable()) {\r\n            revert();\r\n        }\r\n\r\n        // Add unsold token to the future development pool grant (lockup).\r\n        uint256 tokensLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold);\r\n        uint256 futureDevelopmentPool = FUTURE_DEVELOPMENT_POOL.add(tokensLeftInSale);\r\n        // Future Development Pool is locked for 3 years.\r\n        grant(futureDevelopmentPoolAddress, futureDevelopmentPool, startTime, startTime.add(3 years),\r\n            startTime.add(3 years), 1 days, false);\r\n\r\n        // Make tokens Transferable, end the sale!.\r\n        cln.makeTokensTransferable();\r\n    }\r\n\r\n    function grant(address _grantee, uint256 _amount, uint256 _start, uint256 _cliff, uint256 _end,\r\n        uint256 _installmentLength, bool _revokable) private {\r\n        // bytes4 grantSig = bytes4(keccak256(\"grant(address,uint256,uint256,uint256,uint256,bool)\"));\r\n        bytes4 grantSig = 0x5ee7e96d;\r\n        // 6 arguments of size 32\r\n        uint256 argsSize = 6 * 32;\r\n        // sig + arguments size\r\n        uint256 dataSize = 4 + argsSize;\r\n\r\n        bytes memory m_data = new bytes(dataSize);\r\n\r\n        assembly {\r\n            // Add the signature first to memory\r\n            mstore(add(m_data, 0x20), grantSig)\r\n            // Add the parameters\r\n            mstore(add(m_data, 0x24), _grantee)\r\n            mstore(add(m_data, 0x44), _start)\r\n            mstore(add(m_data, 0x64), _cliff)\r\n            mstore(add(m_data, 0x84), _end)\r\n            mstore(add(m_data, 0xa4), _installmentLength)\r\n            mstore(add(m_data, 0xc4), _revokable)\r\n        }\r\n\r\n        require(transferTokens(trustee, _amount, m_data));\r\n    }\r\n\r\n    /// @dev Transfer tokens from the sale contract to a recipient.\r\n    /// @param _recipient address The address of the recipient.\r\n    /// @param _tokens uint256 The amount of tokens to transfer.\r\n    function transferTokens(address _recipient, uint256 _tokens) private returns (bool ans) {\r\n        ans = cln.transfer(_recipient, _tokens);\r\n        if (ans) {\r\n            TokensIssued(_recipient, _tokens);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfer tokens from the sale contract to a recipient.\r\n    /// @param _recipient address The address of the recipient.\r\n    /// @param _tokens uint256 The amount of tokens to transfer.\r\n    /// @param _data bytes data to send to receiver if it is a contract.\r\n    function transferTokens(address _recipient, uint256 _tokens, bytes _data) private returns (bool ans) {\r\n        // Request Colu Local Network contract to transfer the requested tokens for the buyer.\r\n        ans = cln.transferAndCall(_recipient, _tokens, _data);\r\n        if (ans) {\r\n            TokensIssued(_recipient, _tokens);\r\n        }\r\n    }\r\n\r\n    /// @dev Requests to transfer control of the Colu Local Network contract to a new owner.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    ///\r\n    /// NOTE:\r\n    ///   1. The new owner will need to call Colu Local Network contract's acceptOwnership directly in order to accept the ownership.\r\n    ///   2. Calling this method during the token sale will prevent the token sale to continue, since only the owner of\r\n    ///      the Colu Local Network contract can transfer tokens during the sale.\r\n    function requestColuLocalNetworkOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        cln.requestOwnershipTransfer(_newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accepts new ownership on behalf of the Colu Local Network contract.\r\n    // This can be used by the sale contract itself to claim back ownership of the Colu Local Network contract.\r\n    function acceptColuLocalNetworkOwnership() external onlyOwner {\r\n        cln.acceptOwnership();\r\n    }\r\n\r\n    /// @dev Requests to transfer control of the VestingTrustee contract to a new owner.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    ///\r\n    /// NOTE:\r\n    ///   1. The new owner will need to call trustee contract's acceptOwnership directly in order to accept the ownership.\r\n    ///   2. Calling this method during the token sale will prevent the token sale from alocation presale grunts add finalize, since only the owner of\r\n    ///      the trustee contract can create grunts needed in the presaleAlocation add finalize methods.\r\n    function requestVestingTrusteeOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        trustee.requestOwnershipTransfer(_newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accepts new ownership on behalf of the VestingTrustee contract.\r\n    /// This can be used by the token sale contract itself to claim back ownership of the VestingTrustee contract.\r\n    function acceptVestingTrusteeOwnership() external onlyOwner {\r\n        trustee.acceptOwnership();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_etherValue\",\"type\":\"uint256\"},{\"name\":\"_vestingPlanIndex\",\"type\":\"uint8\"}],\"name\":\"presaleAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS_SOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participationHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeholdersPoolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingPlans\",\"outputs\":[{\"name\":\"startOffset\",\"type\":\"uint256\"},{\"name\":\"cliffOffset\",\"type\":\"uint256\"},{\"name\":\"endOffset\",\"type\":\"uint256\"},{\"name\":\"installmentLength\",\"type\":\"uint256\"},{\"name\":\"alapPercent\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLN_PER_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setHardParticipationCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardParticipationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FUTURE_DEVELOPMENT_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participationCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAKEHOLDERS_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ALAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participants\",\"type\":\"address[]\"},{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setParticipationCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cln\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMUNITY_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptColuLocalNetworkOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"participate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestColuLocalNetworkOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestVestingTrusteeOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptVestingTrusteeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PRESALE_TOKENS_SOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityPoolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"futureDevelopmentPoolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participationPresaleHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trustee\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_fundingRecipient\",\"type\":\"address\"},{\"name\":\"_communityPoolAddress\",\"type\":\"address\"},{\"name\":\"_futureDevelopmentPoolAddress\",\"type\":\"address\"},{\"name\":\"_stakeholdersPoolAddress\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"TokensIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ColuLocalNetworkSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a76e676c9cdc7aa2ab12b3ec4dd4c2be9a6774aa00000000000000000000000034df02e145f0a6b5df675e9dfab54ae745e6c4ff000000000000000000000000254158138007803eebc95d082c02d0db4381ebac0000000000000000000000006b83c6a03d99ffadf2416767d64cc959f1b2e2f5000000000000000000000000b0f37b1878fd6a3006467d9cacc8cdef082e11f8000000000000000000000000000000000000000000000000000000005a846b10","Library":"","SwarmSource":"bzzr://f0b0180cdeeba8e04242bf01de41a0a5ec21d89f2549775ddf4e6ca8672e806e"}]}