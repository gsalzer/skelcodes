{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.21;\r\n\r\npragma solidity ^0.4.10;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\npragma solidity ^0.4.10;\r\n\r\ninterface ERC20 {\r\n  function balanceOf(address who) view returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  function allowance(address owner, address spender) view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\npragma solidity ^0.4.10;\r\n\r\ninterface ERC223 {\r\n    function transfer(address to, uint value, bytes data) returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n}\r\npragma solidity ^0.4.10;\r\n\r\ncontract ERC223ReceivingContract { \r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}\r\n\r\npragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\taddress public owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction Ownable()public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner)public onlyOwner {\r\n\t\trequire(newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n\r\n}\r\n\r\npragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title RefundVault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\n * and forwarding it if crowdsale is successful.\r\n */\r\ncontract RefundVault is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tenum State {\r\n\t\tActive,\r\n\t\tRefunding,\r\n\t\tClosed\r\n\t}\r\n\r\n\tmapping(address => uint256)public deposited;\r\n\taddress public wallet;\r\n\tState public state;\r\n\r\n\tevent Closed();\r\n\tevent RefundsEnabled();\r\n\tevent Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n\t/**\r\n\t * @param _wallet Vault address\r\n\t */\r\n\tfunction RefundVault(address _wallet)public {\r\n\t\trequire(_wallet != address(0));\r\n\t\twallet = _wallet;\r\n\t\tstate = State.Active;\r\n\t}\r\n\r\n\t/**\r\n\t * @param investor Investor address\r\n\t */\r\n\tfunction deposit(address investor)onlyOwner public payable {\r\n\t\trequire(state == State.Active);\r\n\t\tdeposited[investor] = deposited[investor].add(msg.value);\r\n\t}\r\n\r\n\tfunction close()onlyOwner public {\r\n\t\trequire(state == State.Active);\r\n\t\tstate = State.Closed;\r\n\t\temit Closed();\r\n\t\twallet.transfer(address(this).balance);\r\n\t}\r\n\r\n\tfunction enableRefunds()onlyOwner public {\r\n\t\trequire(state == State.Active);\r\n\t\tstate = State.Refunding;\r\n\t\temit RefundsEnabled();\r\n\t}\r\n\r\n\t/**\r\n\t * @param investor Investor address\r\n\t */\r\n\tfunction refund(address investor)public {\r\n\t\trequire(state == State.Refunding);\r\n\t\tuint256 depositedValue = deposited[investor];\r\n\t\tdeposited[investor] = 0;\r\n\t\tinvestor.transfer(depositedValue);\r\n\t\temit Refunded(investor, depositedValue);\r\n\t}\r\n}\r\npragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title BonusScheme\r\n * @dev This contract is used for storing and granting tokens calculated \r\n * according to bonus scheme while a crowdsale is in progress.\r\n * When crowdsale ends the rest of tokens is transferred to developers.\r\n */\r\ncontract BonusScheme is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n\t* Defining timestamps for bonuscheme from White Paper. \r\n\t* The start of bonuses is 15 May 2018 and the end is 23 June 2018. \r\n\t* There are 2 seconds in between changing the phases.  */\r\n\tuint256 startOfFirstBonus = 1526021400;\r\n\tuint256 endOfFirstBonus = (startOfFirstBonus - 1) + 5 minutes;\t\r\n\tuint256 startOfSecondBonus = (startOfFirstBonus + 1) + 5 minutes;\r\n\tuint256 endOfSecondBonus = (startOfSecondBonus - 1) + 5 minutes;\r\n\tuint256 startOfThirdBonus = (startOfSecondBonus + 1) + 5 minutes;\r\n\tuint256 endOfThirdBonus = (startOfThirdBonus - 1) + 5 minutes;\r\n\tuint256 startOfFourthBonus = (startOfThirdBonus + 1) + 5 minutes;\r\n\tuint256 endOfFourthBonus = (startOfFourthBonus - 1) + 5 minutes;\r\n\tuint256 startOfFifthBonus = (startOfFourthBonus + 1) + 5 minutes;\r\n\tuint256 endOfFifthBonus = (startOfFifthBonus - 1) + 5 minutes;\r\n\t\r\n\t/**\r\n\t* Defining bonuses according to White Paper.\r\n\t* First week there is bonus 35%.\r\n\t* Second week there is bonus 30%.\r\n\t* Third week there is bonus 20%.\r\n\t* Fourth week there is bonus 10%.\r\n\t* Fifth week there is bonus 5%.\r\n\t*/\r\n\tuint256 firstBonus = 35;\r\n\tuint256 secondBonus = 30;\r\n\tuint256 thirdBonus = 20;\r\n\tuint256 fourthBonus = 10;\r\n\tuint256 fifthBonus = 5;\r\n\r\n\tevent BonusCalculated(uint256 tokenAmount);\r\n\r\n    function BonusScheme() public {\r\n        \r\n    }\r\n\r\n\t/**\r\n\t * @dev Calculates from Bonus Scheme how many tokens can be added to purchased _tokenAmount.\r\n\t * @param _tokenAmount The amount of calculated tokens to sent Ether.\r\n\t * @return Number of bonus tokens that can be granted with the specified _tokenAmount.\r\n\t */\r\n\tfunction getBonusTokens(uint256 _tokenAmount)onlyOwner public returns(uint256) {\r\n\t\tif (block.timestamp >= startOfFirstBonus && block.timestamp <= endOfFirstBonus) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(firstBonus).div(100);\r\n\t\t} else if (block.timestamp >= startOfSecondBonus && block.timestamp <= endOfSecondBonus) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(secondBonus).div(100);\r\n\t\t} else if (block.timestamp >= startOfThirdBonus && block.timestamp <= endOfThirdBonus) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(thirdBonus).div(100);\r\n\t\t} else if (block.timestamp >= startOfFourthBonus && block.timestamp <= endOfFourthBonus) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(fourthBonus).div(100);\r\n\t\t} else if (block.timestamp >= startOfFifthBonus && block.timestamp <= endOfFifthBonus) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(fifthBonus).div(100);\r\n\t\t} else _tokenAmount=0;\r\n\t\temit BonusCalculated(_tokenAmount);\r\n\t\treturn _tokenAmount;\r\n\t}\r\n}\r\n\r\ncontract StandardToken is ERC20, ERC223, Ownable {\r\n\tusing SafeMath for uint;\r\n\r\n\tstring internal _name;\r\n\tstring internal _symbol;\r\n\tuint8 internal _decimals;\r\n\tuint256 internal _totalSupply;\r\n\tuint256 internal _bonusSupply;\r\n\r\n\tuint256 public ethRate; // How many token units a buyer gets per eth\r\n\tuint256 public min_contribution; // Minimal contribution in ICO\r\n\tuint256 public totalWeiRaised; // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here.\r\n\tuint public tokensSold; // the number of tokens already sold\r\n\r\n\tuint public softCap; //softcap in tokens\r\n\tuint public start; // the start date of the crowdsale\r\n\tuint public end; // the end date of the crowdsale\r\n\tbool public crowdsaleClosed; // indicates if the crowdsale has been closed already\r\n\tRefundVault public vault; // refund vault used to hold funds while crowdsale is running\r\n\tBonusScheme public bonusScheme; // contract used to hold and give tokens according to bonus scheme from white paper\r\n\r\n\taddress public fundsWallet; // Where should the raised ETH go?\r\n\r\n\tmapping(address => bool)public frozenAccount;\r\n\tmapping(address => uint256)internal balances;\r\n\tmapping(address => mapping(address => uint256))internal allowed;\r\n\r\n\t/* This generates a public event on the blockchain that will notify clients */\r\n\tevent Burn(address indexed burner, uint256 value);\r\n\tevent FrozenFunds(address target, bool frozen);\r\n\tevent Finalized();\r\n\tevent BonusSent(address indexed from, address indexed to, uint256 boughtTokens, uint256 bonusTokens);\r\n\r\n\t/**\r\n\t * Event for token purchase logging\r\n\t * @param purchaser who paid for the tokens\r\n\t * @param beneficiary who got the tokens\r\n\t * @param value weis paid for purchase\r\n\t * @param amount of tokens purchased\r\n\t */\r\n\tevent TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\t//TODO: correction of smart contract balance of tokens //done\r\n\t//TODO: change symbol and name of token\r\n\t//TODO: change start and end timestamps\r\n\tfunction StandardToken()public {\r\n\t\t_symbol = \"AmTC1\";\r\n\t\t_name = \"AmTokenTestCase1\";\r\n\t\t_decimals = 5;\r\n\t\t_totalSupply = 1100000 * (10 ** uint256(_decimals));\r\n\t\t//_creatorSupply = _totalSupply * 25 / 100; \t\t\t// The creator has 25% of tokens\r\n\t\t//_icoSupply = _totalSupply * 58 / 100; \t\t\t\t// Smart contract balance is 58% of tokens (638 000 tokens)\r\n\t\t_bonusSupply = _totalSupply * 17 / 100; // The Bonus scheme supply is 17% (187 000 tokens)\r\n\t\t\r\n\t\tfundsWallet = msg.sender; // The owner of the contract gets ETH\r\n\t\tvault = new RefundVault(fundsWallet);\r\n\t\tbonusScheme = new BonusScheme();\r\n\r\n\t\t//balances[this] = _icoSupply;          \t\t\t\t// Token balance to smart contract will be added manually from owners wallet\r\n\t\tbalances[msg.sender] = _totalSupply.sub(_bonusSupply);\r\n\t\tbalances[bonusScheme] = _bonusSupply;\r\n\t\tethRate = 40000000; // Set the rate of token to ether exchange for the ICO\r\n\t\tmin_contribution = 1 ether / (10**11); // 0.1 ETH is minimum deposit\r\n\t\ttotalWeiRaised = 0;\r\n\t\ttokensSold = 0;\r\n\t\tsoftCap = 20000 * 10 ** uint(_decimals);\r\n\t\tstart = 1526021100;\r\n\t\tend = 1526023500;\r\n\t\tcrowdsaleClosed = false;\r\n\t}\r\n\r\n\tmodifier beforeICO() {\r\n\t\trequire(block.timestamp <= start);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier afterDeadline() {\r\n\t\trequire(block.timestamp > end);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction name()\r\n\tpublic\r\n\tview\r\n\treturns(string) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction symbol()\r\n\tpublic\r\n\tview\r\n\treturns(string) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction decimals()\r\n\tpublic\r\n\tview\r\n\treturns(uint8) {\r\n\t\treturn _decimals;\r\n\t}\r\n\r\n\tfunction totalSupply()\r\n\tpublic\r\n\tview\r\n\treturns(uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\t// -----------------------------------------\r\n\t// Crowdsale external interface\r\n\t// -----------------------------------------\r\n\r\n\t/**\r\n\t * @dev fallback function ***DO NOT OVERRIDE***\r\n\t */\r\n\tfunction ()external payable {\r\n\t\tbuyTokens(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev low level token purchase ***DO NOT OVERRIDE***\r\n\t * @param _beneficiary Address performing the token purchase\r\n\t */\r\n\t//bad calculations, change  //should be ok\r\n\t//TODO: pre-ico phase to be defined and checked with other tokens, ICO-when closed check softcap, softcap-add pre-ico tokens, if isnt achieved revert all transactions, hardcap, timestamps&bonus scheme(will be discussed next week), minimum amount is 0,1ETH ...\r\n\tfunction buyTokens(address _beneficiary)public payable {\r\n\t\tuint256 weiAmount = msg.value;\r\n\t\t_preValidatePurchase(_beneficiary, weiAmount);\r\n\t\tuint256 tokens = _getTokenAmount(weiAmount); // calculate token amount to be sold\r\n\t\trequire(balances[this] > tokens); //check if the contract has enough tokens\r\n\r\n\t\ttotalWeiRaised = totalWeiRaised.add(weiAmount); //update state\r\n\t\ttokensSold = tokensSold.add(tokens); //update state\r\n\r\n\t\t_processPurchase(_beneficiary, tokens);\r\n\t\temit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n\t\t_processBonus(_beneficiary, tokens);\r\n\r\n\t\t_updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n\t\t_forwardFunds();\r\n\t\t_postValidatePurchase(_beneficiary, weiAmount);\r\n\r\n\t\t/*\r\n\t\tbalances[this] = balances[this].sub(weiAmount);\r\n\t\tbalances[_beneficiary] = balances[_beneficiary].add(weiAmount);\r\n\r\n\t\temit Transfer(this, _beneficiary, weiAmount); \t\t\t\t\t// Broadcast a message to the blockchain\r\n\t\t */\r\n\r\n\t}\r\n\r\n\t// -----------------------------------------\r\n\t// Crowdsale internal interface (extensible)\r\n\t// -----------------------------------------\r\n\r\n\t/**\r\n\t * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\r\n\t * @param _beneficiary Address performing the token purchase\r\n\t * @param _weiAmount Value in wei involved in the purchase\r\n\t */\r\n\tfunction _preValidatePurchase(address _beneficiary, uint256 _weiAmount)internal view {\r\n\t\trequire(_beneficiary != address(0));\r\n\t\trequire(_weiAmount >= min_contribution);\r\n\t\trequire(!crowdsaleClosed && block.timestamp >= start && block.timestamp <= end);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n\t * @param _beneficiary Address performing the token purchase\r\n\t * @param _weiAmount Value in wei involved in the purchase\r\n\t */\r\n\tfunction _postValidatePurchase(address _beneficiary, uint256 _weiAmount)internal pure {\r\n\t\t// optional override\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n\t * @param _beneficiary Address performing the token purchase\r\n\t * @param _tokenAmount Number of tokens to be emitted\r\n\t */\r\n\tfunction _deliverTokens(address _beneficiary, uint256 _tokenAmount)internal {\r\n\t\tthis.transfer(_beneficiary, _tokenAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n\t * @param _beneficiary Address receiving the tokens\r\n\t * @param _tokenAmount Number of tokens to be purchased\r\n\t */\r\n\tfunction _processPurchase(address _beneficiary, uint256 _tokenAmount)internal {\r\n\t\t_deliverTokens(_beneficiary, _tokenAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Executed when a purchase has been validated and bonus tokens need to be calculated. Not necessarily emits/sends bonus tokens.\r\n\t * @param _beneficiary Address receiving the tokens\r\n\t * @param _tokenAmount Number of tokens from which is calculated bonus amount\r\n\t */\r\n\tfunction _processBonus(address _beneficiary, uint256 _tokenAmount)internal {\r\n\t\tuint256 bonusTokens = bonusScheme.getBonusTokens(_tokenAmount); // Calculate bonus token amount\r\n\t\tif (balances[bonusScheme] < bonusTokens) { // If the bonus scheme does not have enough tokens, send all remaining\r\n\t\t\tbonusTokens = balances[bonusScheme];\r\n\t\t}\r\n\t\tif (bonusTokens > 0) { // If there are no tokens left in bonus scheme, we do not need transaction.\r\n\t\t\tbalances[bonusScheme] = balances[bonusScheme].sub(bonusTokens);\r\n\t\t\tbalances[_beneficiary] = balances[_beneficiary].add(bonusTokens);\r\n\t\t\temit Transfer(address(bonusScheme), _beneficiary, bonusTokens);\r\n\t\t\temit BonusSent(address(bonusScheme), _beneficiary, _tokenAmount, bonusTokens);\r\n\t\t\ttokensSold = tokensSold.add(bonusTokens); // update state\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n\t * @param _beneficiary Address receiving the tokens\r\n\t * @param _weiAmount Value in wei involved in the purchase\r\n\t */\r\n\tfunction _updatePurchasingState(address _beneficiary, uint256 _weiAmount)internal {\r\n\t\t// optional override\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Override to extend the way in which ether is converted to tokens.\r\n\t * @param _weiAmount Value in wei to be converted into tokens\r\n\t * @return Number of tokens that can be purchased with the specified _weiAmount\r\n\t */\r\n\tfunction _getTokenAmount(uint256 _weiAmount)internal view returns(uint256) {\r\n\t\t_weiAmount = _weiAmount.mul(ethRate);\r\n\t\treturn _weiAmount.div(10 ** uint(18 - _decimals)); //as we have other decimals number than standard 18, we need to calculate\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Determines how ETH is stored/forwarded on purchases, sending funds to vault.\r\n\t */\r\n\tfunction _forwardFunds()internal {\r\n\t\tvault.deposit.value(msg.value)(msg.sender); //Transfer ether to vault\r\n\t}\r\n\r\n\t///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! bad function, refactor   //should be solved now\r\n\t//standard function transfer similar to ERC20 transfer with no _data\r\n\t//added due to backwards compatibility reasons\r\n\tfunction transfer(address _to, uint256 _value)public returns(bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value <= balances[msg.sender]);\r\n\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\r\n\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\r\n\t\t//require(!isContract(_to));\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner)public view returns(uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\t//standard function transferFrom similar to ERC20 transferFrom with no _data\r\n\t//added due to backwards compatibility reasons\r\n\tfunction transferFrom(address _from, address _to, uint256 _value)public returns(bool) {\r\n\t\trequire(_to != address(0));\r\n\t\trequire(!frozenAccount[_from]); // Check if sender is frozen\r\n\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\r\n\t\trequire(_value <= balances[_from]);\r\n\t\trequire(_value <= allowed[_from][msg.sender]);\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _value)public returns(bool) {\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address _owner, address _spender)public view returns(uint256) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\tfunction increaseApproval(address _spender, uint _addedValue)public returns(bool) {\r\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue)public returns(bool) {\r\n\t\tuint oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);\r\n\t\t}\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Function that is called when a user or another contract wants to transfer funds .    ///add trasnfertocontractwithcustomfallback  //done\r\n\tfunction transfer(address _to, uint _value, bytes _data, string _custom_fallback)public returns(bool success) {\r\n\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\r\n\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\r\n\t\tif (isContract(_to)) {\r\n\t\t\treturn transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);\r\n\t\t} else {\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n\r\n\t// Function that is called when a user or another contract wants to transfer funds .\r\n\tfunction transfer(address _to, uint _value, bytes _data)public returns(bool) {\r\n\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\r\n\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\r\n\t\tif (isContract(_to)) {\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t} else {\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t\t/*\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_value > 0 && _value <= balances[msg.sender]);\r\n\t\tif(isContract(_to)) {\r\n\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\treturn true;\r\n\t\t}\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\t */\r\n\t}\r\n\r\n\tfunction isContract(address _addr)private view returns(bool is_contract) {\r\n\t\tuint length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (length > 0);\r\n\t}\r\n\r\n\t//function that is called when transaction target is an address\r\n\tfunction transferToAddress(address _to, uint _value, bytes _data)private returns(bool success) {\r\n\t\trequire(balanceOf(msg.sender) > _value);\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//function that is called when transaction target is a contract\r\n\tfunction transferToContract(address _to, uint _value, bytes _data)private returns(bool success) {\r\n\t\trequire(balanceOf(msg.sender) > _value);\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//function that is called when transaction target is a contract with custom fallback\r\n\tfunction transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback)private returns(bool success) {\r\n\t\trequire(balanceOf(msg.sender) > _value);\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tassert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setPreICOSoldAmount(uint256 _soldTokens, uint256 _raisedWei)onlyOwner beforeICO public {\r\n\t\ttokensSold = tokensSold.add(_soldTokens);\r\n\t\ttotalWeiRaised = totalWeiRaised.add(_raisedWei);\r\n\t}\r\n\t\r\n\t/// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n\t/// @param target Address to be frozen\r\n\t/// @param freeze either to freeze it or not\r\n\tfunction freezeAccount(address target, bool freeze)onlyOwner public {\r\n\t\tfrozenAccount[target] = freeze;\r\n\t\temit FrozenFunds(target, freeze);\r\n\t}\r\n\r\n\t/**\r\n\t * Destroy tokens\r\n\t *\r\n\t * Remove `_value` tokens from the system irreversibly\r\n\t *\r\n\t * @param _value the amount of money to burn\r\n\t */\r\n\tfunction burn(uint256 _value)onlyOwner public returns(bool success) {\r\n\t\trequire(balances[msg.sender] >= _value); // Check if the sender has enough\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value); // Subtract from the sender\r\n\t\t_totalSupply = _totalSupply.sub(_value); // Updates totalSupply\r\n\t\temit Burn(msg.sender, _value);\r\n\t\temit Transfer(msg.sender, address(0), _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* NOT NEEDED as ethers are in vault\r\n\t//check the functionality\r\n\t// @notice Failsafe drain\r\n\tfunction withdrawEther()onlyOwner public returns(bool) {\r\n\towner.transfer(address(this).balance);\r\n\treturn true;\r\n\t}\r\n\t */\r\n\r\n\t// @notice Failsafe transfer tokens for the team to given account\r\n\tfunction withdrawTokens()onlyOwner public returns(bool) {\r\n\t\trequire(this.transfer(owner, balances[this]));\r\n\t\tuint256 bonusTokens = balances[address(bonusScheme)];\r\n\t\tbalances[address(bonusScheme)] = 0;\r\n\t\tif (bonusTokens > 0) { // If there are no tokens left in bonus scheme, we do not need transaction.\r\n\t\t\tbalances[owner] = balances[owner].add(bonusTokens);\r\n\t\t\temit Transfer(address(bonusScheme), owner, bonusTokens);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n\t * @param _tokenAddress The address of the ERC20 contract.\r\n\t * @param _amount The amount of tokens to be transferred.\r\n\t */\r\n\tfunction transferAnyERC20Token(address _tokenAddress, uint256 _amount)onlyOwner public returns(bool success) {\r\n\t\treturn ERC20(_tokenAddress).transfer(owner, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Investors can claim refunds here if crowdsale is unsuccessful\r\n\t */\r\n\tfunction claimRefund()public {\r\n\t\trequire(crowdsaleClosed);\r\n\t\trequire(!goalReached());\r\n\r\n\t\tvault.refund(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks whether funding goal was reached.\r\n\t * @return Whether funding goal was reached\r\n\t */\r\n\tfunction goalReached()public view returns(bool) {\r\n\t\treturn tokensSold >= softCap;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev vault finalization task, called when owner calls finalize()\r\n\t */\r\n\tfunction finalization()internal {\r\n\t\tif (goalReached()) {\r\n\t\t\tvault.close();\r\n\t\t} else {\r\n\t\t\tvault.enableRefunds();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Must be called after crowdsale ends, to do some extra finalization\r\n\t * work. Calls the contract's finalization function.\r\n\t */\r\n\tfunction finalize()onlyOwner afterDeadline public {\r\n\t\trequire(!crowdsaleClosed);\r\n\r\n\t\tfinalization();\r\n\t\temit Finalized();\r\n\t\twithdrawTokens();\r\n\r\n\t\tcrowdsaleClosed = true;\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusScheme\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"min_contribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_soldTokens\",\"type\":\"uint256\"},{\"name\":\"_raisedWei\",\"type\":\"uint256\"}],\"name\":\"setPreICOSoldAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_custom_fallback\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"boughtTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusTokens\",\"type\":\"uint256\"}],\"name\":\"BonusSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"StandardToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d8edba94a766581f50a6d3f0c384638a8a265fe53a2a9d8192b0350f7f63d82a"}]}