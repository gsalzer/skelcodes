{"status":"1","message":"OK","result":[{"SourceCode":"// Welcome to Reserve Token.\r\n//\r\n\r\n\r\npragma solidity ^0.4.0;\r\n\r\n\r\ncontract ReserveToken {\r\n\r\n    address public tank; //SBC - The tank of the contract\r\n    uint256 public tankAllowance = 0;\r\n    uint256 public tankOut = 0;\r\n    uint256 public valueOfContract = 0;\r\n    string public name;         //Name of the contract\r\n    string public symbol;       //Symbol of the contract\r\n    uint8 public decimals = 18;      //The amount of decimals\r\n\r\n    uint256 public totalSupply; //The current total supply.\r\n    uint256 public maxSupply = uint256(0) - 10; //We let the max amount be the most the variable can handle. well... basically.\r\n    uint256 public tankImposedMax = 100000000000000000000000; //SBC - 10 million maximum tokens at first\r\n    uint256 public priceOfToken;    //The current price of a token\r\n    uint256 public divForSellBack = 2; //SBC - The split for when a sell back occurs\r\n    uint256 public divForTank = 200; //SBC - 20=5%. 100=1% 1000=.1% The amount given to the Abby.\r\n    uint256 public divForPrice = 200; //SBC - The rate in which we grow. 2x this is our possible spread.\r\n    uint256 public divForTransfer = 2; //SBC - The rate in which we grow. 2x this is our possible spread.\r\n    uint256 public firstTTax = 10000; //SBC - The amount added to cost of transfer if firstTTaxAmount\r\n    uint256 public firstTTaxAmount = 10000; //SBC - The sender amount must be greater than this amount.\r\n    uint256 public secondTTax = 20000; //SBC -\r\n    uint256 public secondTTaxAmount = 20000; //SBC\r\n    uint256 public minTokens = 100;     //SBC  - minimum amount of tickets a person may mixssxnt at once\r\n    uint256 public maxTokens = 1000;    //SBC -max amount of tickets a person may mint at once\r\n    uint256 public coinprice; //This is calculated on the fly in the sellprice. This is the last buy price. not the current.\r\n\r\n    //Standard Token\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n\r\n\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\r\n    function ReserveToken() payable public {\r\n        name = \"Reserve Token\";\r\n        //Setting the name of the contract\r\n        symbol = \"RSRV\";\r\n        //Setting the symbol\r\n        tank = msg.sender;\r\n        //setting the tank\r\n        priceOfToken = 1 szabo;\r\n    }\r\n\r\n    function MintTokens() public payable {\r\n        //Just some requirements for BuyTokens -- The Tank needs no requirements. (Tank is still subjected to fees)\r\n        address inAddress = msg.sender;\r\n        uint256 inMsgValue = msg.value;\r\n\r\n        if (inAddress != tank) {\r\n            require(inMsgValue > 1000); //The minimum money supplied\r\n            require(inMsgValue > priceOfToken * minTokens); //The minimum amount of tokens you can buy\r\n            require(inMsgValue < priceOfToken * maxTokens); //The maximum amount of tokens.\r\n        }\r\n\r\n\r\n        //Add the incoming tank allowance to tankAllowance\r\n        tankAllowance += (inMsgValue / divForTank);\r\n        //add to the value of contact the incoming value - what the tank got.\r\n        valueOfContract += (inMsgValue - (inMsgValue / divForTank));\r\n        //new coins are equalal to teh new value of contract divided by the current price of token\r\n        uint256 newcoins = ((inMsgValue - (inMsgValue / divForTank)) * 1 ether) / (priceOfToken);\r\n\r\n\r\n\r\n         //Ensure that we dont go over the max the tank has set.\r\n        require(totalSupply + newcoins < maxSupply);\r\n        //Ensure that we don't go oever the maximum amount of coins.\r\n        require(totalSupply + newcoins < tankImposedMax);\r\n\r\n        \r\n\r\n        //Update use balance, total supply, price of token.\r\n        totalSupply += newcoins;\r\n        priceOfToken += valueOfContract / (totalSupply / 1 ether) / divForPrice;\r\n        balances[inAddress] += newcoins;\r\n    }\r\n\r\n    function BurnAllTokens() public {\r\n        address inAddress = msg.sender;\r\n        uint256 theirBalance = balances[inAddress];\r\n        //Get their balance without any crap code\r\n        require(theirBalance > 0);\r\n        //Make sure that they have enough money to cover this.\r\n        balances[inAddress] = 0;\r\n        //Remove the amount now, for re entry prevention\r\n        coinprice = valueOfContract / (totalSupply / 1 ether);\r\n        //Updating the coin price (buy back price)\r\n        uint256 amountGoingOut = coinprice * (theirBalance / 1 ether); //amount going out in etheruem\r\n        //We convert amount going out to amount without divforTank\r\n        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\r\n        amountGoingOut = amountGoingOut - tankAmount; //the new amount for our going out without the tank\r\n        //Amount going out minus theW\r\n        tankAllowance += (tankAmount - (tankAmount / divForSellBack)); //Give\r\n        //Add the the tank allowance, here we are functionally making the coin worth more.\r\n        valueOfContract -= amountGoingOut + (tankAmount / divForSellBack); //VOC = ago - (tankAmount left after tankAllowance)\r\n        //Updating the new value of our contract. what we will have after the transfer\r\n        msg.sender.transfer(amountGoingOut);\r\n        //Transfer the money\r\n        totalSupply -= theirBalance;\r\n\r\n    }\r\n\r\n    function BurnTokens(uint256 _amount) public {\r\n        address inAddress = msg.sender;\r\n        uint256 theirBalance = balances[inAddress];\r\n        //Get their balance without any crap code\r\n        require(_amount <= theirBalance);\r\n        //Make sure that they have enough money to cover this.\r\n        balances[inAddress] -= _amount;\r\n        //Remove the amount now, for re entry prevention\r\n        coinprice = valueOfContract / (totalSupply / 1 ether);\r\n        //Updating the coin price (buy back price)\r\n        uint256 amountGoingOut = coinprice * (_amount / 1 ether); //amount going out in etheruem\r\n        //We convert amount going out to amount without divforTank\r\n        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\r\n        amountGoingOut = amountGoingOut - tankAmount; //the new amount for our going out without the tank\r\n        //Amount going out minus theW\r\n        tankAllowance += (tankAmount - (tankAmount / divForSellBack)); //Give\r\n        //Add the the tank allowance, here we are functionally making the coin worth more.\r\n        valueOfContract -= amountGoingOut + (tankAmount / divForSellBack); //VOC = ago - (tankAmount left after tankAllowance)\r\n        //Updating the new value of our contract. what we will have after the transfer\r\n        msg.sender.transfer(amountGoingOut);\r\n        //Transfer the money\r\n        totalSupply -= _amount;\r\n\r\n    }\r\n\r\n    function CurrentCoinPrice() view public returns (uint256) {\r\n        uint256 amountGoingOut = valueOfContract / (totalSupply / 1 ether);\r\n        //We convert amount going out to amount without divforTank\r\n        uint256 tankAmount = (amountGoingOut / divForTank); //The amount going to the tank\r\n        return amountGoingOut - tankAmount; //the new amount for our going out without the tank\r\n    }\r\n\r\n\r\n    function TankWithdrawSome(uint256 _amount) public {\r\n        address inAddress = msg.sender;\r\n        require(inAddress == tank);\r\n        //Require person to be the tank\r\n\r\n        //if our allowance is greater than the value of the contract then the contract must be empty.\r\n        if (tankAllowance < valueOfContract) {\r\n            require(_amount <= tankAllowance - tankOut);\r\n        }\r\n\r\n        //Require the amount to be less than the amount for tank0.\r\n\r\n        tankOut += _amount;\r\n        //Adding in new tank withdraw.\r\n        tank.transfer(_amount);\r\n        //transfering amount to tank's balance.\r\n    }\r\n\r\n    //This is an ethereum withdraw for the tank.\r\n    function TankWithdrawAll() public {\r\n        address inAddress = msg.sender;\r\n        require(inAddress == tank);\r\n        //Require person to be the tank\r\n\r\n        //if our allowance is greater than the value of the contract then the contract must be empty.\r\n        if (tankAllowance < valueOfContract) {\r\n            require(tankAllowance - tankOut > 0); //Tank allowance - tankout = whats left for tank. and it must be over zero\r\n        }\r\n\r\n        //Require the amount to be less than the amount for tank0.\r\n\r\n        tankOut += tankAllowance - tankOut; //We give whats left to our tankout makeing whats left zero. so tank cant double withdraw.\r\n        //Adding in new tank withdraw.\r\n        tank.transfer(tankAllowance - tankOut);\r\n        //transfering amount to tank's balance.\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function TankDeposit() payable public {\r\n        address inAddress = msg.sender;\r\n        uint256 inValue = msg.value;\r\n\r\n        require(inAddress == tank);\r\n        //require the person to be a the tank\r\n\r\n        if (inValue < tankOut) {\r\n            tankOut -= inValue;\r\n            // We cant underflow here because it has to be less.\r\n        }\r\n        else\r\n        {\r\n            //Add the excess to the contract value\r\n            valueOfContract += (inValue - tankOut) * 1 ether;\r\n            //We DO NOT INCREASE ALLOWANCE, we only allow the tank to go to zero.\r\n            tankOut = 0;\r\n\r\n        }\r\n    }\r\n\r\n\r\n    // What is the balance of a particular account?\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transferFee(uint256 _amount) view internal returns (uint256){\r\n        //If Amount is above the tax amount return the tax\r\n        if (_amount > secondTTaxAmount)\r\n            return secondTTax;\r\n\r\n        if (_amount > firstTTaxAmount)\r\n            return firstTTax;\r\n    }\r\n\r\n    // Transfer the balance from tank's account to another account\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        //variables we are working with.\r\n        uint256 fromBalance = balances[msg.sender];\r\n        uint256 toBalance = balances[_to];\r\n        uint256 tFee = transferFee(_amount);\r\n\r\n\r\n        //Require the balance be greater than the amount + fee\r\n        require(fromBalance >= _amount + tFee);\r\n        //Require the amount ot be greater than 0.\r\n        require(_amount > 0);\r\n        //Require the toBalance to be greater than the current amount. w\r\n        require(toBalance + _amount > toBalance);\r\n\r\n        balances[msg.sender] -= _amount + tFee;\r\n        balances[_to] += _amount;\r\n        balances[tank] += tFee / divForTransfer;\r\n        totalSupply -= tFee - (tFee / divForTransfer);\r\n\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        //Create Event\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    // fees in sub-currencies; the command should fail unless the _from account has\r\n    // deliberately authorized the sender of the message via some mechanism; we propose\r\n    // these standardized APIs for approval:\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        uint256 fromBalance = balances[_from];  //The current balance of from\r\n        uint256 toBalance = balances[_to];      //The current blance for to\r\n        uint256 tFee = transferFee(_amount);    //The transaction fee that will be accociated with this transaction\r\n\r\n        //Require the from balance to have more than the amount they want to send + the current fee\r\n        require(fromBalance >= _amount + tFee);\r\n        //Require the allowed balance to be greater than that amount as well.\r\n        require(allowed[_from][msg.sender] >= _amount + tFee);\r\n        //Require the current amount to be greater than 0.\r\n        require(_amount > 0);\r\n        //Require the to balance to gain an amount. protect against under and over flows\r\n        require(toBalance + _amount > toBalance);\r\n\r\n        //Update from balance, allowed balance, to balance, tank balance, total supply. create Transfer event.\r\n        balances[_from] -= _amount + tFee;\r\n        allowed[_from][msg.sender] -= _amount + tFee;\r\n        balances[_to] += _amount;\r\n        balances[tank] += tFee / divForTransfer;\r\n        totalSupply -= tFee - (tFee / divForTransfer);\r\n        emit Transfer(_from, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n     function GrabUnallocatedValue() public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         //Sometimes someone sends money straight to the contract but that isn't recorded in the value of teh contract.\r\n         //So here we allow tank to withdraw those extra funds\r\n         address walletaddress = this;\r\n         if (walletaddress.balance * 1 ether > valueOfContract) {\r\n            tank.transfer(walletaddress.balance - (valueOfContract / 1 ether));\r\n         }\r\n    }\r\n\r\n\r\n    function TankTransfer(address _NewTank) public {\r\n        address inAddress = msg.sender;\r\n        require(inAddress == tank);\r\n        tank = _NewTank;\r\n    }\r\n\r\n    function SettankImposedMax(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         tankImposedMax = _input;\r\n    }\r\n\r\n    function SetdivForSellBack(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         divForSellBack = _input;\r\n    }\r\n\r\n    function SetdivForTank(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         divForTank = _input;\r\n    }\r\n\r\n    function SetdivForPrice(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         divForPrice = _input;\r\n    }\r\n\r\n    function SetfirstTTax(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         firstTTax = _input;\r\n    }\r\n\r\n    function SetfirstTTaxAmount(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         firstTTaxAmount = _input;\r\n    }\r\n\r\n    function SetsecondTTax(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         secondTTax = _input;\r\n    }\r\n\r\n    function SetsecondTTaxAmount(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         secondTTaxAmount = _input;\r\n    }\r\n\r\n    function SetminTokens(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         minTokens = _input;\r\n    }\r\n\r\n    function SetmaxTokens(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         maxTokens = _input;\r\n    }\r\n\r\n    function SetdivForTransfer(uint256 _input) public {\r\n         address inAddress = msg.sender;\r\n         require(inAddress == tank);\r\n         divForTransfer = _input;\r\n    }\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"BurnAllTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetsecondTTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divForTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOfToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"MintTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondTTaxAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetfirstTTax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstTTaxAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tankOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tankAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetdivForTank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divForTank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetmaxTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coinprice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"TankDeposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divForSellBack\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstTTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetsecondTTaxAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divForPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetdivForSellBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"valueOfContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetminTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TankWithdrawSome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetdivForTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tank\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"GrabUnallocatedValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetdivForPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SetfirstTTaxAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_NewTank\",\"type\":\"address\"}],\"name\":\"TankTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondTTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"SettankImposedMax\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CurrentCoinPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tankImposedMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"TankWithdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ReserveToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e38c164edc85ae62928dbd3be21418c8a2247777f19b3b6ad882252f856456f6"}]}