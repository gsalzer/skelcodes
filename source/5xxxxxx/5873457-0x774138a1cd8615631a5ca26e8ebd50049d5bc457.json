{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/ERC20Interface.sol\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/PermissionGroups.sol\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    constructor(address _admin) public {\r\n        admin = _admin;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        emit AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                emit AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Withdrawable.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers can inherit this contract.\r\n * @author Ilan Doron\r\n * @dev Allows to recover any tokens or Ethers received in a contract.\r\n * Should prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    constructor(address _admin) PermissionGroups (_admin) public {}\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/zeppelin/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/IEORate.sol\r\n\r\ncontract IEORate is Withdrawable {\r\n\r\n    uint public ethToTokenNumerator;\r\n    uint public ethToTokenDenominator;\r\n\r\n    constructor(address admin) Withdrawable(admin) public\r\n    {}\r\n\r\n    event RateSet (uint rateNumerator, uint rateDenominator, address sender);\r\n\r\n    function setRateEthToToken(uint rateNumerator, uint rateDenominator) public onlyOperator {\r\n        require(rateNumerator > 0);\r\n        require(rateDenominator > 0);\r\n\r\n        ethToTokenNumerator = rateNumerator;\r\n        ethToTokenDenominator = rateDenominator;\r\n        emit RateSet(rateNumerator, rateDenominator, msg.sender);\r\n    }\r\n\r\n    function getRate () public view returns(uint rateNumerator, uint rateDenominator) {\r\n        rateNumerator = ethToTokenNumerator;\r\n        rateDenominator = ethToTokenDenominator;\r\n    }\r\n}\r\n\r\n// File: contracts/CapManager.sol\r\n\r\n//@Title Cap manager handles contribution cap per contributor.\r\n//@dev   IEO will have 2 phases:\r\n//          First phase is capped IEO where each contributor can contribute up to capped amount.\r\n//          Second phase will be open for unlimited contributions that are blocked only by amount of tokens.\r\ncontract CapManager is Withdrawable {\r\n    mapping(uint=>uint) public participatedWei;\r\n    uint public contributorCapWei;\r\n    uint internal IEOId; //uinque ID will be part of hash\r\n    uint constant public MAX_PURCHASE_WEI = uint(-1);\r\n    uint public cappedIEOStartTime;\r\n    uint public openIEOStartTime; //open IEO means no cap on purchase amount of KYC addresses.\r\n    uint public endIEOTime;\r\n\r\n    using SafeMath for uint;\r\n\r\n    constructor(uint _cappedIEOTime,\r\n        uint _openIEOTime,\r\n        uint _endIEOTime,\r\n        uint _contributorCapWei,\r\n        uint _IEOId,\r\n        address _admin)\r\n        Withdrawable(_admin)\r\n        public\r\n    {\r\n        require(_cappedIEOTime >= now); // solium-disable-line security/no-block-members\r\n        require(_cappedIEOTime <= _openIEOTime);\r\n        require(_openIEOTime <= _endIEOTime);\r\n        require(_IEOId != 0);\r\n\r\n        contributorCapWei = _contributorCapWei;\r\n        IEOId = _IEOId;\r\n        cappedIEOStartTime = _cappedIEOTime;\r\n        openIEOStartTime = _openIEOTime;\r\n        endIEOTime = _endIEOTime;\r\n    }\r\n\r\n    //@dev  getContributorRemainingCap returns remaining cap for a contributor\r\n    //      Assuming that contributor has passed KYC process = is allowed to participate.\r\n    //      If contributor hasn\"t participated - it will return full cap according to IEO stage (capped / open / close).\r\n    //      If contributor already participated. when IEO in capped stage, will return contributor cap less previous\r\n    //        participation. if open contribute stage will return max cap.\r\n    //        notice the participation amount will still be blocked by token balance of this contract.\r\n    function getContributorRemainingCap(uint userId) public view returns(uint capWei) {\r\n        if (!IEOStarted()) return 0;\r\n        if (IEOEnded()) return 0;\r\n\r\n        if (openIEOStarted()) {\r\n            capWei = MAX_PURCHASE_WEI;\r\n        } else {\r\n            if (participatedWei[userId] >= contributorCapWei) capWei = 0;\r\n            else capWei = contributorCapWei.sub(participatedWei[userId]);\r\n        }\r\n    }\r\n\r\n    function eligible(uint userID, uint amountWei) public view returns(uint) {\r\n        uint remainingCap = getContributorRemainingCap(userID);\r\n        if (amountWei > remainingCap) return remainingCap;\r\n        return amountWei;\r\n    }\r\n\r\n    event ContributorCapSet(uint capWei, address sender);\r\n    function setContributorCap(uint capWei) public onlyAdmin {\r\n        contributorCapWei = capWei;\r\n        emit ContributorCapSet(capWei, msg.sender);\r\n    }\r\n\r\n    function IEOStarted() public view returns(bool) {\r\n        return (now >= cappedIEOStartTime); // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    function openIEOStarted() public view returns(bool) {\r\n        return (now >= openIEOStartTime); // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    function IEOEnded() public view returns(bool) {\r\n        return (now >= endIEOTime); // solium-disable-line security/no-block-members\r\n    }\r\n\r\n    function validateContributor(address contributor, uint userId, uint8 v, bytes32 r, bytes32 s) public view returns(bool) {\r\n        require(verifySignature(keccak256(contributor, userId, IEOId), v, r, s));\r\n        return true;\r\n    }\r\n\r\n    function getIEOId() external view returns(uint) {\r\n        return IEOId;\r\n    }\r\n\r\n    function eligibleCheckAndIncrement(uint userId, uint amountInWei) internal returns(uint)\r\n    {\r\n        uint result = eligible(userId, amountInWei);\r\n        participatedWei[userId] = participatedWei[userId].add(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    function verifySignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal view returns(bool) {\r\n        address signer = ecrecover(hash, v, r, s);\r\n        return operators[signer];\r\n    }\r\n}\r\n\r\n// File: contracts/KyberIEOInterface.sol\r\n\r\ninterface KyberIEOInterface {\r\n    function contribute(address contributor, uint userId, uint8 v, bytes32 r, bytes32 s) external payable returns(bool);\r\n    function getContributorRemainingCap(uint userId) external view returns(uint capWei);\r\n    function getIEOId() external view returns(uint);\r\n}\r\n\r\n// File: contracts/KyberIEO.sol\r\n\r\ncontract KyberIEO is KyberIEOInterface, CapManager {\r\n    mapping(address=>bool) public whiteListedAddresses;\r\n    ERC20 public token;\r\n    uint  public raisedWei;\r\n    uint  public distributedTokensTwei;\r\n    bool  public haltedIEO = false;\r\n    IEORate public IEORateContract;\r\n    address public contributionWallet;\r\n\r\n    constructor (\r\n        address _admin,\r\n        address _contributionWallet,\r\n        ERC20 _token,\r\n        uint _contributorCapWei,\r\n        uint _IEOId,\r\n        uint _cappedIEOStart,\r\n        uint _openIEOStart,\r\n        uint _publicIEOEnd)\r\n        CapManager(_cappedIEOStart, _openIEOStart, _publicIEOEnd, _contributorCapWei, _IEOId, _admin)\r\n        public\r\n    {\r\n        require(_token != address(0));\r\n        require(_contributionWallet != address(0));\r\n\r\n        IEORateContract = new IEORate(_admin);\r\n        contributionWallet = _contributionWallet;\r\n        token = _token;\r\n    }\r\n\r\n    event IEOHalted(address sender);\r\n    function haltIEO() public onlyAlerter {\r\n        haltedIEO = true;\r\n        emit IEOHalted(msg.sender);\r\n    }\r\n\r\n    event IEOResumed(address sender);\r\n    function resumeIEO() public onlyAdmin {\r\n        haltedIEO = false;\r\n        emit IEOResumed(msg.sender);\r\n    }\r\n\r\n    event Contribution(address msgSender, address contributor, uint userId, uint distributedTokensTwei, uint payedWei);\r\n    function contribute(address contributor, uint userId, uint8 v, bytes32 r, bytes32 s) external payable returns(bool) {\r\n        require(!haltedIEO);\r\n        require(IEOStarted());\r\n        require(!IEOEnded());\r\n        require((contributor == msg.sender) || whiteListedAddresses[msg.sender]);\r\n\r\n        uint rateNumerator;\r\n        uint rateDenominator;\r\n        (rateNumerator, rateDenominator) = IEORateContract.getRate();\r\n        require(rateNumerator > 0);\r\n        require(rateDenominator > 0);\r\n        require(validateContributor(contributor, userId, v, r, s));\r\n\r\n        uint weiPayment = eligibleCheckAndIncrement(userId, msg.value);\r\n        require(weiPayment > 0);\r\n\r\n        uint tokenQty = weiPayment.mul(rateNumerator).div(rateDenominator);\r\n        require(tokenQty > 0);\r\n\r\n        // send remaining wei to msg.sender, not to contributor\r\n        if(msg.value > weiPayment) {\r\n            msg.sender.transfer(msg.value.sub(weiPayment));\r\n        }\r\n\r\n        // send payment to wallet\r\n        sendETHToContributionWallet(weiPayment);\r\n        raisedWei = raisedWei.add(weiPayment);\r\n\r\n        //send exchanged tokens to contributor\r\n        require(token.transfer(contributor, tokenQty));\r\n        distributedTokensTwei = distributedTokensTwei.add(tokenQty);\r\n\r\n        emit Contribution(msg.sender, contributor, userId, tokenQty, weiPayment);\r\n\r\n        return true;\r\n    }\r\n\r\n    event addressWhiteListed(address _address, bool whiteListed);\r\n    function whiteListAddress(address addr, bool whiteListed) public onlyAdmin {\r\n        whiteListedAddresses[addr] = whiteListed;\r\n        emit addressWhiteListed(addr, whiteListed);\r\n    }\r\n\r\n    function getRate () public view returns(uint rateNumerator, uint rateDenominator) {\r\n        (rateNumerator, rateDenominator) = IEORateContract.getRate();\r\n    }\r\n\r\n    // just to check that funds goes to the right place\r\n    // tokens are not given in return\r\n    function debugBuy() public payable {\r\n        require(msg.value == 123);\r\n        sendETHToContributionWallet(msg.value);\r\n    }\r\n\r\n    function sendETHToContributionWallet(uint valueWei) internal {\r\n        contributionWallet.transfer(valueWei);\r\n    }\r\n}\r\n\r\n// File: contracts/KyberIEOGetter.sol\r\n\r\ncontract ERC20Plus is ERC20 {\r\n    function symbol() external view returns(string);\r\n    function totalSupply() external view returns(uint);\r\n}\r\n\r\n\r\ncontract KyberIEOGetter {\r\n\r\n    function getIEOInfo(KyberIEO IEO) public view returns (\r\n        uint[3] IEOTimes,\r\n        bool[4] IEOStates,\r\n        uint[2] rate,\r\n        uint[5] amounts,\r\n        uint tokenDecimals,\r\n        address tokenAddress,\r\n        string symbol\r\n        )\r\n    {\r\n        IEOTimes = [IEO.cappedIEOStartTime(), IEO.openIEOStartTime(), IEO.endIEOTime()];\r\n        IEOStates = [IEO.IEOStarted(), IEO.openIEOStarted(), IEO.IEOEnded(), IEO.haltedIEO()];\r\n        rate = [IEORate(IEO.IEORateContract()).ethToTokenNumerator(), IEORate(IEO.IEORateContract()).ethToTokenDenominator()];\r\n        amounts = [IEO.distributedTokensTwei(), IEO.raisedWei(), IEO.contributorCapWei(), 0, IEO.token().totalSupply()];\r\n        amounts[3] = IEO.token().balanceOf(address(IEO));\r\n\r\n        return(IEOTimes, IEOStates, rate, amounts, IEO.token().decimals(), IEO.token(), ERC20Plus(IEO.token()).symbol());\r\n    }\r\n\r\n    function getIEOsInfo(KyberIEO[] IEOs) public view returns(\r\n        uint[] distributedTweiPerIEO,\r\n        uint[] tokenBalancePerIEO,\r\n        address[] tokenAddressPerIEO,\r\n        bytes32[] tokenSymbolPerIEO,\r\n        uint[] tokenDecimalsPerIEO,\r\n        uint[] totalSupplyPerIEO\r\n        )\r\n    {\r\n\r\n        distributedTweiPerIEO = new uint[](IEOs.length);\r\n        tokenBalancePerIEO = new uint[](IEOs.length);\r\n        tokenAddressPerIEO = new address[](IEOs.length);\r\n        tokenSymbolPerIEO = new bytes32[](IEOs.length);\r\n        tokenDecimalsPerIEO = new uint[](IEOs.length);\r\n        totalSupplyPerIEO = new uint[](IEOs.length);\r\n\r\n        for(uint i = 0; i < IEOs.length; i++) {\r\n            distributedTweiPerIEO[i] = IEOs[i].distributedTokensTwei();\r\n            tokenBalancePerIEO[i] = IEOs[i].token().balanceOf(address(IEOs[i]));\r\n            tokenAddressPerIEO[i] = IEOs[i].token();\r\n            tokenSymbolPerIEO[i] = stringToBytes32(ERC20Plus(IEOs[i].token()).symbol());\r\n            tokenDecimalsPerIEO[i] = IEOs[i].token().decimals();\r\n            totalSupplyPerIEO[i] = IEOs[i].token().totalSupply();\r\n        }\r\n    }\r\n\r\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"IEOs\",\"type\":\"address[]\"}],\"name\":\"getIEOsInfo\",\"outputs\":[{\"name\":\"distributedTweiPerIEO\",\"type\":\"uint256[]\"},{\"name\":\"tokenBalancePerIEO\",\"type\":\"uint256[]\"},{\"name\":\"tokenAddressPerIEO\",\"type\":\"address[]\"},{\"name\":\"tokenSymbolPerIEO\",\"type\":\"bytes32[]\"},{\"name\":\"tokenDecimalsPerIEO\",\"type\":\"uint256[]\"},{\"name\":\"totalSupplyPerIEO\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"IEO\",\"type\":\"address\"}],\"name\":\"getIEOInfo\",\"outputs\":[{\"name\":\"IEOTimes\",\"type\":\"uint256[3]\"},{\"name\":\"IEOStates\",\"type\":\"bool[4]\"},{\"name\":\"rate\",\"type\":\"uint256[2]\"},{\"name\":\"amounts\",\"type\":\"uint256[5]\"},{\"name\":\"tokenDecimals\",\"type\":\"uint256\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"KyberIEOGetter","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bdb97342b3f0cdd7d0918172eb5af58fc13e86259f10a59da1b461149361a7a4"}]}