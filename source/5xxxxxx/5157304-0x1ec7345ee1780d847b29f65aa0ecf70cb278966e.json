{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC721Token\r\n * Generic implementation for the required functionality of the ERC721 standard\r\n */\r\ncontract EtherTv is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  Show[] private shows;\r\n  uint256 public devOwed;\r\n\r\n  // dividends\r\n  mapping (address => uint256) public userDividends;\r\n\r\n  // Events\r\n  event ShowPurchased(\r\n    uint256 _tokenId,\r\n    address oldOwner,\r\n    address newOwner,\r\n    uint256 price,\r\n    uint256 nextPrice\r\n  );\r\n\r\n  // Purchasing Caps for Determining Next Pool Cut\r\n  uint256 constant private FIRST_CAP  = 0.5 ether;\r\n  uint256 constant private SECOND_CAP = 1.0 ether;\r\n  uint256 constant private THIRD_CAP  = 3.0 ether;\r\n  uint256 constant private FINAL_CAP  = 5.0 ether;\r\n\r\n  // Struct to store Show Data\r\n  struct Show {\r\n    uint256 price;  // Current price of the item.\r\n    uint256 payout; // The percent of the pool rewarded.\r\n    address owner;  // Current owner of the item.\r\n  }\r\n\r\n  function createShow(uint256 _payoutPercentage) onlyOwner() public {\r\n    // payout must be greater than 0\r\n    require(_payoutPercentage > 0);\r\n    \r\n    // create new token\r\n    var show = Show({\r\n      price: 0.005 ether,\r\n      payout: _payoutPercentage,\r\n      owner: this\r\n    });\r\n\r\n    shows.push(show);\r\n  }\r\n\r\n  function createMultipleShows(uint256[] _payoutPercentages) onlyOwner() public {\r\n    for (uint256 i = 0; i < _payoutPercentages.length; i++) {\r\n      createShow(_payoutPercentages[i]);\r\n    }\r\n  }\r\n\r\n  function getShow(uint256 _showId) public view returns (\r\n    uint256 price,\r\n    uint256 nextPrice,\r\n    uint256 payout,\r\n    uint256 effectivePayout,\r\n    address owner\r\n  ) {\r\n    var show = shows[_showId];\r\n    price = show.price;\r\n    nextPrice = getNextPrice(show.price);\r\n    payout = show.payout;\r\n    effectivePayout = show.payout.mul(10000).div(getTotalPayout());\r\n    owner = show.owner;\r\n  }\r\n\r\n  /**\r\n  * @dev Determines next price of token\r\n  * @param _price uint256 ID of current price\r\n  */\r\n  function getNextPrice (uint256 _price) private pure returns (uint256 _nextPrice) {\r\n    if (_price < FIRST_CAP) {\r\n      return _price.mul(200).div(100);\r\n    } else if (_price < SECOND_CAP) {\r\n      return _price.mul(135).div(100);\r\n    } else if (_price < THIRD_CAP) {\r\n      return _price.mul(125).div(100);\r\n    } else if (_price < FINAL_CAP) {\r\n      return _price.mul(117).div(100);\r\n    } else {\r\n      return _price.mul(115).div(100);\r\n    }\r\n  }\r\n\r\n  function calculatePoolCut (uint256 _price) private pure returns (uint256 _poolCut) {\r\n    if (_price < FIRST_CAP) {\r\n      return _price.mul(7).div(100); // 7%\r\n    } else if (_price < SECOND_CAP) {\r\n      return _price.mul(6).div(100); // 6%\r\n    } else if (_price < THIRD_CAP) {\r\n      return _price.mul(5).div(100); // 5%\r\n    } else if (_price < FINAL_CAP) {\r\n      return _price.mul(4).div(100); // 4%\r\n    } else {\r\n      return _price.mul(3).div(100); // 3%\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @dev Purchase show from previous owner\r\n  * @param _tokenId uint256 of token\r\n  */\r\n  function purchaseShow(uint256 _tokenId) public payable {\r\n    var show = shows[_tokenId];\r\n    uint256 price = show.price;\r\n    address oldOwner = show.owner;\r\n    address newOwner = msg.sender;\r\n\r\n    // revert checks\r\n    require(price > 0);\r\n    require(msg.value >= price);\r\n    require(oldOwner != msg.sender);\r\n\r\n    uint256 purchaseExcess = msg.value.sub(price);\r\n\r\n    // Calculate pool cut for taxes.\r\n    \r\n    // 4% goes to developers\r\n    uint256 devCut = price.mul(4).div(100);\r\n    devOwed = devOwed.add(devCut);\r\n\r\n    // 3 - 7% goes to shareholders\r\n    uint256 shareholderCut = calculatePoolCut(price);\r\n    distributeDividends(shareholderCut);\r\n\r\n    // Transfer payment to old owner minus the developer's and pool's cut.\r\n    uint256 excess = price.sub(devCut).sub(shareholderCut);\r\n\r\n    if (oldOwner != address(this)) {\r\n      oldOwner.transfer(excess);\r\n    }\r\n\r\n    // set new price\r\n    uint256 nextPrice = getNextPrice(price);\r\n    show.price = nextPrice;\r\n\r\n    // set new owner\r\n    show.owner = newOwner;\r\n\r\n    // Send refund to owner if needed\r\n    if (purchaseExcess > 0) {\r\n      newOwner.transfer(purchaseExcess);\r\n    }\r\n\r\n    // raise event\r\n    ShowPurchased(_tokenId, oldOwner, newOwner, price, nextPrice);\r\n  }\r\n\r\n  function distributeDividends(uint256 _shareholderCut) private {\r\n    uint256 totalPayout = getTotalPayout();\r\n\r\n    for (uint256 i = 0; i < shows.length; i++) {\r\n      var show = shows[i];\r\n      var payout = _shareholderCut.mul(show.payout).div(totalPayout);\r\n      userDividends[show.owner] = userDividends[show.owner].add(payout);\r\n    }\r\n  }\r\n\r\n  function getTotalPayout() private view returns(uint256) {\r\n    uint256 totalPayout = 0;\r\n\r\n    for (uint256 i = 0; i < shows.length; i++) {\r\n      var show = shows[i];\r\n      totalPayout = totalPayout.add(show.payout);\r\n    }\r\n\r\n    return totalPayout;\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw dev's cut\r\n  */\r\n  function withdraw() onlyOwner public {\r\n    owner.transfer(devOwed);\r\n    devOwed = 0;\r\n  }\r\n\r\n  /**\r\n  * @dev Owner can withdraw their accumulated dividends\r\n  */\r\n  function withdrawDividends() public {\r\n    uint256 dividends = userDividends[msg.sender];\r\n    userDividends[msg.sender] = 0;\r\n    msg.sender.transfer(dividends);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payoutPercentage\",\"type\":\"uint256\"}],\"name\":\"createShow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"purchaseShow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_showId\",\"type\":\"uint256\"}],\"name\":\"getShow\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"nextPrice\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint256\"},{\"name\":\"effectivePayout\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payoutPercentages\",\"type\":\"uint256[]\"}],\"name\":\"createMultipleShows\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextPrice\",\"type\":\"uint256\"}],\"name\":\"ShowPurchased\",\"type\":\"event\"}]","ContractName":"EtherTv","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c27b9a46f8e16ae522b85d3e5a201c909b9e16d07527282c1e3aed7e93f8b871"}]}