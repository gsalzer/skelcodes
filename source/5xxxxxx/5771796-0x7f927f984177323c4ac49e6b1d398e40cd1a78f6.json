{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;        // v0.4.18 was the latest possible version. 0.4.19 and above were not allowed\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\nlibrary SafeMath \r\n{\r\n    //--------------------------------------------------------------------------\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0)     return 0;\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\nlibrary StringLib \r\n{\r\n    function concat(string strA, string strB) internal pure returns (string)\r\n    {\r\n        uint            i;\r\n        uint            g;\r\n        uint            finalLen;\r\n        bytes memory    dataStrA;\r\n        bytes memory    dataStrB;\r\n        bytes memory    buffer;\r\n\r\n        dataStrA  = bytes(strA);\r\n        dataStrB  = bytes(strB);\r\n\r\n        finalLen  = dataStrA.length + dataStrB.length;\r\n        buffer    = new bytes(finalLen);\r\n\r\n        for (g=i=0; i<dataStrA.length; i++)   buffer[g++] = dataStrA[i];\r\n        for (i=0;   i<dataStrB.length; i++)   buffer[g++] = dataStrB[i];\r\n\r\n        return string(buffer);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function same(string strA, string strB) internal pure returns(bool)\r\n    {\r\n        return keccak256(strA)==keccak256(strB);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function uintToAscii(uint number) internal pure returns(byte) \r\n    {\r\n             if (number < 10)         return byte(48 + number);\r\n        else if (number < 16)         return byte(87 + number);\r\n\r\n        revert();\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function asciiToUint(byte char) internal pure returns (uint) \r\n    {\r\n        uint asciiNum = uint(char);\r\n\r\n             if (asciiNum > 47 && asciiNum < 58)    return asciiNum - 48;\r\n        else if (asciiNum > 96 && asciiNum < 103)   return asciiNum - 87;\r\n\r\n        revert();\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function bytes32ToString (bytes32 data) internal pure returns (string) \r\n    {\r\n        bytes memory bytesString = new bytes(64);\r\n\r\n        for (uint j=0; j < 32; j++) \r\n        {\r\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\r\n\r\n            bytesString[j*2+0] = uintToAscii(uint(char) / 16);\r\n            bytesString[j*2+1] = uintToAscii(uint(char) % 16);\r\n        }\r\n        return string(bytesString);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function stringToBytes32(string str) internal pure returns (bytes32) \r\n    {\r\n        bytes memory bString = bytes(str);\r\n        uint uintString;\r\n\r\n        if (bString.length != 64) { revert(); }\r\n\r\n        for (uint i = 0; i < 64; i++) \r\n        {\r\n            uintString = uintString*16 + uint(asciiToUint(bString[i]));\r\n        }\r\n        return bytes32(uintString);\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract ERC20 \r\n{\r\n    function balanceOf(   address _owner)                               public constant returns (uint256 balance);\r\n    function transfer(    address toAddr,  uint256 amount)              public returns (bool success);\r\n    function allowance(   address owner,   address spender)             public constant returns (uint256);\r\n    function transferFrom(address fromAddr,address toAddr, uint256 value)   public returns (bool);\r\n    function approve(     address spender, uint256 value)               public returns (bool);\r\n\r\n    event Transfer(address indexed fromAddr, address indexed toAddr,   uint256 amount);\r\n    event Approval(address indexed _owner,   address indexed _spender, uint256 amount);\r\n\r\n    uint256 public totalSupply;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract Ownable \r\n{\r\n    address public owner;\r\n\r\n    //-------------------------------------------------------------------------- @dev The Ownable constructor sets the original `owner` of the contract to the sender account\r\n    function Ownable() public \r\n    {\r\n        owner = msg.sender;\r\n    }\r\n    //-------------------------------------------------------------------------- @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract Lockable is Ownable \r\n{\r\n    uint256 internal constant lockedUntil = 1527811200;     // 2018-06-01 00:00 (GMT+0)\r\n\r\n    address internal allowedSender;     // the address that can make transactions when the transaction is locked \r\n\r\n    //-------------------------------------------------------------------------- @dev Allow access only when is unlocked. This function is good when you make crowdsale to avoid token expose in exchanges\r\n    modifier unlocked() \r\n    {\r\n        require((now > lockedUntil) || (allowedSender == msg.sender));\r\n        _;\r\n    }\r\n    //-------------------------------------------------------------------------- @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    function transferOwnership(address newOwner) public onlyOwner               // @param newOwner The address to transfer ownership to.\r\n    {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n\r\n        allowedSender = newOwner;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract Token is ERC20, Lockable \r\n{\r\n    using SafeMath for uint256;\r\n\r\n    address public                                      owner;          // Owner of this contract\r\n    mapping(address => uint256)                         balances;       // Maintain balance in a mapping\r\n    mapping(address => mapping (address => uint256))    allowances;     // Allowances index-1 = Owner account   index-2 = spender account\r\n\r\n    //------ TOKEN SPECIFICATION\r\n\r\n    string public constant      name     = \"Yield Coin\";\r\n    string public constant      symbol   = \"YLD\";\r\n\r\n    uint256 public constant     decimals = 2;      // Handle the coin as FIAT (2 decimals). ETH Handles 18 decimal places\r\n\r\n    uint256 public constant     initSupply = 1100000000 * 10**decimals;        // 10**18 max\r\n\r\n    //-------------------------------------------------------------------------- Functions with this modifier can only be executed by the owner\r\n    modifier onlyOwner() \r\n    {\r\n        if (msg.sender != owner) \r\n        {\r\n            //----> (Jean) deprecated       throw;\r\n            assert(true==false);\r\n        }\r\n        _;\r\n    }\r\n    //-------------------------------------------------------------------------- Constructor\r\n    function Token() public \r\n    {\r\n        owner           = msg.sender;\r\n        totalSupply     = initSupply;\r\n        balances[owner] = initSupply;   // send the tokens to the owner\r\n\r\n        //-----\r\n\r\n        allowedSender = owner;          // In this contract, only the contract owner can send token while ICO is active.\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function transfer(address toAddr, uint256 amount)  public   unlocked returns (bool success) \r\n    {\r\n        require(toAddr!=0x0 && toAddr!=msg.sender && amount>0);         // Prevent transfer to 0x0 address and to self, amount must be >0\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(amount);\r\n        balances[toAddr]     = balances[toAddr].add(amount);\r\n\r\n        //emit Transfer(msg.sender, toAddr, amount);\r\n        Transfer(msg.sender, toAddr, amount);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function transferFrom(address fromAddr, address toAddr, uint256 amount)  public   unlocked returns (bool) \r\n    {\r\n        if (amount <= 0)                                return false;\r\n        if (fromAddr==toAddr)                           return false;\r\n        if(allowances[fromAddr][msg.sender] < amount)   return false;\r\n        if(balances[fromAddr] < amount)                 return false;\r\n\r\n        balances[fromAddr] = balances[fromAddr].sub(amount);\r\n        balances[toAddr]   = balances[toAddr].add(  amount);\r\n\r\n        allowances[fromAddr][msg.sender] = allowances[fromAddr][msg.sender].sub(amount);\r\n\r\n        //emit Transfer(fromAddr, toAddr, amount);\r\n        Transfer(fromAddr, toAddr, amount);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function balanceOf(address _owner)  public   constant returns (uint256 balance) \r\n    {\r\n        return balances[_owner];\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function approve(address _spender, uint256 amount)  public   returns (bool) \r\n    {\r\n        require((amount == 0) || (allowances[msg.sender][_spender] == 0));\r\n\r\n        allowances[msg.sender][_spender] = amount;\r\n\r\n        //emit Approval(msg.sender, _spender, amount);\r\n        Approval(msg.sender, _spender, amount);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function allowance(address _owner, address _spender)  public   constant returns (uint remaining)\r\n    {\r\n        return allowances[_owner][_spender];    // Return the allowance for _spender approved by _owner\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function() public                       \r\n    {\r\n        assert(true == false);      // If Ether is sent to this address, don't handle it -> send it back.\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n\r\n\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromAddr\",\"type\":\"address\"},{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://25f0c7778a8e41b5c600effe746a00f3e46ddf3b1ad95b9e6105ae2a91d4db42"}]}