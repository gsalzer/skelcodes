{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract QuarterMachine {\r\n\r\n  // Address of the contract creator\r\n  address public contractOwner;\r\n\r\n  // FIFO queue\r\n  BuyIn[] public buyIns;\r\n\r\n  // The current BuyIn queue index\r\n  uint256 public index;\r\n\r\n  // Total invested for entire contract\r\n  uint256 public contractTotalInvested;\r\n\r\n  // Total invested for a given address\r\n  mapping (address => uint256) public totalInvested;\r\n\r\n  // Total value for a given address\r\n  mapping (address => uint256) public totalValue;\r\n\r\n  // Total paid out for a given address\r\n  mapping (address => uint256) public totalPaidOut;\r\n\r\n  struct BuyIn {\r\n    uint256 value;\r\n    address owner;\r\n  }\r\n\r\n  modifier onlyContractOwner() {\r\n    require(msg.sender == contractOwner);\r\n    _;\r\n  }\r\n\r\n  function QuarterMachine() public {\r\n    contractOwner = msg.sender;\r\n  }\r\n\r\n  function purchase() public payable {\r\n    // I don't want no scrub\r\n    require(msg.value >= 0.01 ether);\r\n\r\n    // Take a 5% fee\r\n    uint256 value = SafeMath.div(SafeMath.mul(msg.value, 95), 100);\r\n\r\n    // 1.25x multiplier\r\n    uint256 valueMultiplied = SafeMath.div(SafeMath.mul(msg.value, 125), 100);\r\n\r\n    contractTotalInvested += msg.value;\r\n    totalInvested[msg.sender] += msg.value;\r\n\r\n    while (index < buyIns.length && value > 0) {\r\n      BuyIn storage buyIn = buyIns[index];\r\n\r\n      if (value < buyIn.value) {\r\n        buyIn.owner.transfer(value);\r\n        totalPaidOut[buyIn.owner] += value;\r\n        totalValue[buyIn.owner] -= value;\r\n        buyIn.value -= value;\r\n        value = 0;\r\n      } else {\r\n        buyIn.owner.transfer(buyIn.value);\r\n        totalPaidOut[buyIn.owner] += buyIn.value;\r\n        totalValue[buyIn.owner] -= buyIn.value;\r\n        value -= buyIn.value;\r\n        buyIn.value = 0;\r\n        index++;\r\n      }\r\n    }\r\n\r\n    // if buyins have been exhausted, return the remaining\r\n    // funds back to the investor\r\n    if (value > 0) {\r\n      msg.sender.transfer(value);\r\n      valueMultiplied -= value;\r\n      totalPaidOut[msg.sender] += value;\r\n    }\r\n\r\n    totalValue[msg.sender] += valueMultiplied;\r\n\r\n    buyIns.push(BuyIn({\r\n      value: valueMultiplied,\r\n      owner: msg.sender\r\n    }));\r\n  }\r\n\r\n  function payout() public onlyContractOwner {\r\n    contractOwner.transfer(this.balance);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalPaidOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buyIns\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractTotalInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"QuarterMachine","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://456be9573b43a98eef9e919d33611f871f456ec48cefc93651e1bbe81eea7768"}]}