{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// EtherVegas V3 \r\n// Updates: time is now a hard reset and is based on the price you buy with minimum \r\n// Name feature introduced plus quotes [added to UI soon]\r\n// Poker feature added, pays about ~4/25 of entire collected pot currently \r\n// can be claimed multiple times (by other users). Last poker winner gets \r\n// remaining pot when complete jackpot is paid out \r\n\r\n// HOST: ethlasvegas.surge.sh \r\n// Made by EtherGuy \r\n// Questions or suggestions? etherguy@mail.com \r\n\r\ncontract RNG{\r\n     uint256 secret = 0;\r\n     \r\n    // Thanks to TechnicalRise\r\n    // Ban contracts\r\n    modifier NoContract(){\r\n        uint size;\r\n        address addr = msg.sender;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size == 0);\r\n        _;\r\n    }\r\n    \r\n    function RNG() public NoContract{\r\n        secret = uint256(keccak256(block.coinbase));\r\n    }\r\n    \r\n    function _giveRNG(uint256 modulo, uint256 secr) private view returns (uint256, uint256){\r\n        uint256 seed1 = uint256(block.coinbase);\r\n        uint256 seed3 = secr; \r\n        uint256 newsecr = (uint256(keccak256(seed1,seed3)));\r\n        return (newsecr % modulo, newsecr);\r\n    }\r\n    \r\n\r\n    function GiveRNG(uint256 max) internal NoContract returns (uint256){\r\n        uint256 num;\r\n        uint256 newsecret = secret;\r\n\r\n        (num,newsecret) = _giveRNG(max, newsecret);\r\n        secret=newsecret;\r\n        return num; \r\n    }\r\n    \r\n\r\n}\r\n\r\ncontract Poker is RNG{\r\n    // warning; number 0 is a non-existing card; means empty;\r\n    \r\n\r\n\r\n    uint8[5] public HouseCards;\r\n    \r\n    mapping(address => uint8[2]) public PlayerCards;\r\n    mapping(address => uint256) public PlayerRound;\r\n    \r\n    uint256 public RoundNumber;\r\n    \r\n    uint8[6] public WinningHand; // tracks winning hand. ID 1 defines winning level (9=straight flush, 8=4 of a kind, etc) and other numbers \r\n    address  public PokerWinner;\r\n    \r\n    uint8[2] public WinningCards;\r\n    // define the other cards which might play in defining the winner. \r\n\r\n    function GetCardNumber(uint8 rank, uint8 suit) public pure returns (uint8){\r\n        if (rank==0){\r\n            return 0;\r\n        }\r\n        \r\n        return ((rank-1)*4+1)+suit;\r\n    }\r\n    \r\n    function GetPlayerRound(address who) public view returns (uint256){\r\n        return PlayerRound[who];\r\n    }\r\n    \r\n    \r\n    \r\n    function GetCardInfo(uint8 n) public pure returns (uint8 rank, uint8 suit){\r\n        if (n==0){\r\n            return (0,0);\r\n        }\r\n        suit = (n-1)%4;\r\n        rank = (n-1)/4+1;\r\n    }\r\n    \r\n   // event pushifo(uint8, uint8, uint8,uint8,uint8);\r\n    // resets game \r\n    function DrawHouse() internal {\r\n        // Draw table cards \r\n        uint8 i;\r\n        uint8 rank;\r\n        uint8 suit;\r\n        uint8 n;\r\n        for (i=0; i<5; i++){\r\n            rank = uint8(GiveRNG(13)+1);\r\n            suit = uint8(GiveRNG(4));\r\n            n = GetCardNumber(rank,suit);\r\n            HouseCards[i]=n;\r\n        }\r\n\r\n        uint8[2] storage target = PlayerCards[address(this)];\r\n        for (i=0; i<2; i++){\r\n            rank = uint8(GiveRNG(13)+1);\r\n            suit = uint8(GiveRNG(4));\r\n            n = GetCardNumber(rank,suit);\r\n\r\n            target[i]=n;\r\n\r\n        }\r\n        \r\n        WinningHand = RankScore(address(this));\r\n        WinningCards=[target[0],target[1]];\r\n        PokerWinner= address(this);\r\n    }\r\n    \r\n    event DrawnCards(address player, uint8 card1, uint8 card2);\r\n    function DrawAddr() internal {\r\n        uint8 tcard1;\r\n        uint8 tcard2;\r\n        for (uint8 i=0; i<2; i++){\r\n            uint8 rank = uint8(GiveRNG(13)+1);\r\n            uint8 suit = uint8(GiveRNG(4));\r\n            uint8 n = GetCardNumber(rank,suit);\r\n            \r\n            if (i==0){\r\n                tcard1=n;\r\n            }\r\n            else{\r\n                tcard2=n;\r\n            }\r\n\r\n            PlayerCards[msg.sender][i]=n;\r\n\r\n        }\r\n        \r\n        if (PlayerRound[msg.sender] != RoundNumber){\r\n            PlayerRound[msg.sender] = RoundNumber;\r\n        }\r\n        emit DrawnCards(msg.sender,tcard1, tcard2);\r\n    }\r\n    \r\n    function GetPlayerCards(address who) public view NoContract returns (uint8, uint8){\r\n        uint8[2] memory target = PlayerCards[who];\r\n        \r\n        return (target[0], target[1]);\r\n    }\r\n\r\n    function GetWinCards() public view returns (uint8, uint8){\r\n        return (WinningCards[0], WinningCards[1]);\r\n    }\r\n    \r\n    \r\n    \r\n    // welp this is handy \r\n    struct Card{\r\n        uint8 rank;\r\n        uint8 suit;\r\n    }\r\n    \r\n    // web \r\n  //  function HandWinsView(address checkhand) view returns (uint8){\r\n    //    return HandWins(checkhand);\r\n    //}\r\n    \r\n    \r\n    function HandWins(address checkhand) internal returns (uint8){\r\n        uint8 result = HandWinsView(checkhand);\r\n        \r\n        uint8[6] memory CurrScore = RankScore(checkhand);\r\n            \r\n        uint8[2] memory target = PlayerCards[checkhand];\r\n        \r\n        if (result == 1){\r\n            WinningHand = CurrScore;\r\n            WinningCards= [target[0],target[1]];\r\n            PokerWinner=msg.sender;\r\n            // clear cards \r\n            //PlayerCards[checkhand][0]=0;\r\n            //PlayerCards[checkhand][1]=0;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    // returns 0 if lose, 1 if win, 2 if equal \r\n    // if winner found immediately sets winner values \r\n    function HandWinsView(address checkhand) public view returns (uint8){ \r\n        if (PlayerRound[checkhand] != RoundNumber){\r\n            return 0; // empty cards in new round. \r\n        }\r\n        uint8[6] memory CurrentWinHand = WinningHand;\r\n        \r\n        uint8[6] memory CurrScore = RankScore(checkhand);\r\n        \r\n        \r\n        uint8 ret = 2;\r\n        if (CurrScore[0] > CurrentWinHand[0]){\r\n \r\n            return 1;\r\n        }\r\n        else if (CurrScore[0] == CurrentWinHand[0]){\r\n            for (uint i=1; i<=5; i++){\r\n                if (CurrScore[i] >= CurrentWinHand[i]){\r\n                    if (CurrScore[i] > CurrentWinHand[i]){\r\n\r\n                        return 1;\r\n                    }\r\n                }\r\n                else{\r\n                    ret=0;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            ret=0;\r\n        }\r\n        // 2 is same hand. commented out in pay mode \r\n        // only winner gets pot. \r\n        return ret;\r\n    }\r\n    \r\n    \r\n\r\n    function RankScore(address checkhand) internal view returns (uint8[6] output){\r\n      \r\n        uint8[4] memory FlushTracker;\r\n        uint8[14] memory CardTracker;\r\n        \r\n        uint8 rank;\r\n        uint8 suit;\r\n        \r\n        Card[7] memory Cards;\r\n        \r\n        for (uint8 i=0; i<7; i++){\r\n            if (i>=5){\r\n                (rank,suit) = GetCardInfo(PlayerCards[checkhand][i-5]);\r\n                FlushTracker[suit]++;\r\n                CardTracker[rank]++;\r\n                Cards[i] = Card(rank,suit);\r\n            }\r\n            else{\r\n                (rank,suit) = GetCardInfo(HouseCards[i]);\r\n                FlushTracker[suit]++;\r\n                CardTracker[rank]++;\r\n                Cards[i] = Card(rank,suit);\r\n            }\r\n        }\r\n        \r\n        uint8 straight = 0;\r\n        // skip all zero's\r\n        uint8[3] memory straight_startcard;\r\n        for (uint8 startcard=13; i>=5; i--){\r\n            if (CardTracker[startcard] >= 1){\r\n                for (uint8 currcard=startcard-1; currcard>=(startcard-4); currcard--){\r\n                    if (CardTracker[currcard] >= 1){\r\n                        if (currcard == (startcard-4)){\r\n                            // at end, straight \r\n                            straight_startcard[straight] = startcard;\r\n                            straight++;\r\n                        }\r\n                    }\r\n                    else{\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        uint8 flush=0;\r\n\r\n        for (i=0;i<=3;i++){\r\n            if (FlushTracker[i]>=5){\r\n                flush=i;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // done init. \r\n        \r\n        // straight flush? \r\n        \r\n        \r\n        \r\n        if (flush>0 && straight>0){\r\n            // someone has straight flush? \r\n            // level score 9 \r\n            output[0] = 9;\r\n            currcard=0;\r\n            for (i=0; i<3; i++){\r\n                startcard=straight_startcard[i];\r\n                currcard=5; // track flush, num 5 is standard.    \r\n                for (rank=0; i<7; i++){\r\n                    if (Cards[i].suit == flush && Cards[i].rank <= startcard && Cards[i].rank>=(startcard-4)){\r\n                        currcard--;\r\n                        if (currcard==0){\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (currcard==0){\r\n                    // found straight flush high. \r\n                    output[1] = straight_startcard[i]; // save the high card \r\n                    break;\r\n                }\r\n            }\r\n            \r\n            return output; \r\n        }\r\n        \r\n        // high card \r\n        \r\n        //reuse the rank variable to sum cards; \r\n        rank=0;\r\n        for (i=13;i>=1;i--){\r\n            rank = rank + CardTracker[i];\r\n            if (CardTracker[i] >= 4){\r\n                output[0] = 8; // high card \r\n                output[1] = i; // the type of card \r\n                return output;\r\n            }\r\n            if (rank >=4){\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // full house \r\n        \r\n        rank=0; // track 3-kind \r\n        suit=0; // track 2-kind \r\n        startcard=0;\r\n        currcard=0;\r\n        \r\n        for (i=13;i>=1;i--){\r\n            if (rank == 0 && CardTracker[i] >= 3){\r\n                rank = i;\r\n            }\r\n            else if(CardTracker[i] >= 2){\r\n                if (suit == 0){\r\n                    suit = i;\r\n                }\r\n                else{\r\n                    // double nice \r\n                    if (startcard==0){\r\n                        startcard=i;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (rank != 0 && suit != 0){\r\n            output[0] = 7;\r\n            output[1] = rank; // full house tripple high \r\n            output[2] = suit; // full house tripple low \r\n            return output;\r\n        }\r\n        \r\n        if (flush>0){\r\n            // flush \r\n            output[0] = 6;\r\n            output[1] = flush;\r\n            return output;\r\n            \r\n        }\r\n        \r\n        if (straight>0){\r\n            //straight \r\n            output[0] = 5;\r\n            output[1] = straight_startcard[0];\r\n            return output;\r\n        }\r\n        \r\n        if (rank>0){\r\n            // tripple \r\n            output[0]=4;\r\n            output[1]=rank;\r\n            currcard=2; // track index; \r\n            // get 2 highest cards \r\n            for (i=13;i>=1;i--){\r\n                if (i != rank){\r\n                    if (CardTracker[i] > 0){\r\n                        // note at three of a kind we have no other doubles; all other ranks are different so no check > 1 \r\n                        output[currcard] = i;\r\n                        currcard++;\r\n                        if(currcard==4){\r\n                            return output;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (suit > 0 && startcard > 0){\r\n            // double pair \r\n            output[0] = 3;\r\n            output[1] = suit;\r\n            output[2] = startcard;\r\n            // get highest card \r\n            for (i=13;i>=1;i--){\r\n                if (i!=suit && i!=startcard && CardTracker[i]>0){\r\n                    output[3]=i;\r\n                    return output;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (suit > 0){\r\n            // pair \r\n            output[0]=2;\r\n            output[1]=suit;\r\n            currcard=2;\r\n            // fill 3 other positions with high cards. \r\n            for (i=13;i>=1;i--){\r\n                if (i!=suit && CardTracker[i]>0){\r\n                    output[currcard]=i;\r\n                    currcard++;\r\n                    if(currcard==5){\r\n                        return output;\r\n                    }\r\n                }   \r\n            }\r\n        }\r\n        \r\n        // welp you are here now, only have high card?\r\n        // boring \r\n        output[0]=1;\r\n        currcard=1;\r\n        for (i=13;i>=1;i--){\r\n            if (CardTracker[i]>0){\r\n                output[currcard]=i;\r\n                currcard++;\r\n                if (currcard==6){\r\n                    return output;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n}\r\n\r\ncontract Vegas is Poker{\r\n    address owner;\r\n    address public feesend;\r\n    \r\n    \r\n    uint256 public Timer;\r\n    \r\n    uint8 constant MAXPRICEPOWER = 40; // < 255\r\n    \r\n    address public JackpotWinner;\r\n    \r\n    uint16 public JackpotPayout = 8000; \r\n    uint16 public PokerPayout = 2000;\r\n    uint16 public PreviousPayout = 6500;\r\n    uint16 public Increase = 9700;\r\n    uint16 public Tax = 500;\r\n    uint16 public PotPayout = 8000;\r\n    \r\n    uint256 public BasePrice = (0.005 ether);\r\n    \r\n    uint256 public TotalPot;\r\n    uint256 public PokerPayoutValue;\r\n    \r\n    // mainnet \r\n    uint256[9] TimeArray = [uint256(6 hours), uint256(3 hours), uint256(2 hours), uint256(1 hours), uint256(50 minutes), uint256(40 minutes), uint256(30 minutes), uint256(20 minutes), uint256(15 minutes)];\r\n    // testnet \r\n    //uint256[3] TimeArray = [uint256(3 minutes), uint256(3 minutes), uint256(2 minutes)];\r\n    \r\n    struct Item{\r\n        address Holder;\r\n        uint8 PriceID;\r\n    }\r\n    \r\n    Item[16] public Market;\r\n    \r\n    uint8 public MaxItems = 12; // max ID, is NOT index but actual max items to buy. 0 means really nothing, not 1 item \r\n    \r\n    event ItemBought(uint256 Round, uint8 ID,  uint256 Price, address BoughtFrom, address NewOwner, uint256 NewTimer, uint256 NewJP, string Quote, string Name);\r\n    // quotes here ? \r\n    event PokerPaid(uint256 Round, uint256 AmountWon, address Who, string Quote, string Name, uint8[6] WinHand);\r\n    event JackpotPaid(uint256 Round, uint256 Amount,  address Who, string Quote, string Name);\r\n    event NewRound();\r\n    \r\n    bool public EditMode;\r\n    bool public SetEditMode;\r\n    // dev functions \r\n    \r\n    modifier OnlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier GameClosed(){\r\n        require (block.timestamp > Timer);\r\n        _;\r\n    }\r\n    \r\n\r\n    \r\n    function Vegas() public{\r\n        owner=msg.sender;\r\n        feesend=0x09470436BD5b44c7EbDb75eEe2478eC172eAaBF6;\r\n        // withdraw also setups new game. \r\n        // pays out 0 eth of course to owner, no eth in contract. \r\n        Timer = 1; // makes sure withdrawal runs\r\n        Withdraw(\"Game init\", \"Admin\");\r\n    }\r\n    \r\n    // all contract calls are banned from buying \r\n    function Buy(uint8 ID, string Quote, string Name) public payable NoContract {\r\n        require(ID < MaxItems);\r\n        require(!EditMode);\r\n        // get price \r\n        //uint8 pid = Market[ID].PriceID;\r\n        uint256 price = GetPrice(Market[ID].PriceID);\r\n        require(msg.value >= price);\r\n        \r\n        if (block.timestamp > Timer){\r\n            if (Timer != 0){ // timer 0 means withdraw is gone; withdraw will throw on 0\r\n                Withdraw(\"GameInit\", \"Admin\");\r\n                return;\r\n            }\r\n        }\r\n        \r\n        // return excess \r\n        if (msg.value > price){\r\n            msg.sender.transfer(msg.value-price);\r\n        }\r\n        \r\n        uint256 PayTax = (price * Tax)/10000;\r\n        feesend.transfer(PayTax);\r\n        uint256 Left = (price-PayTax);\r\n        \r\n        \r\n        if (Market[ID].PriceID!=0){\r\n            // unzero, move to previous owner\r\n            uint256 pay = (Left*PreviousPayout)/10000;\r\n            TotalPot = TotalPot + (Left-pay);\r\n           // Left=Left-pay;\r\n            Market[ID].Holder.transfer(pay);\r\n        }\r\n        else{\r\n            TotalPot = TotalPot + Left;\r\n        }\r\n        \r\n        // reset timer; \r\n        Timer = block.timestamp + GetTime(Market[ID].PriceID);\r\n        //set jackpot winner \r\n        JackpotWinner = msg.sender;\r\n\r\n\r\n        // give user new card; \r\n        \r\n        emit ItemBought(RoundNumber,ID,  price,  Market[ID].Holder, msg.sender, Timer,  TotalPot,  Quote, Name);\r\n        \r\n        DrawAddr(); // give player cards\r\n        \r\n        // update price \r\n        Market[ID].PriceID++;\r\n        //set holder \r\n        Market[ID].Holder=msg.sender;\r\n    }\r\n    \r\n    function GetPrice(uint8 id) public view returns (uint256){\r\n        uint256 p = BasePrice;\r\n        if (id > 0){\r\n            // max price baseprice * increase^20 is reasonable\r\n            for (uint i=1; i<=id; i++){\r\n                if (i==MAXPRICEPOWER){\r\n                    break; // prevent overflow (not sure why someone would buy at increase^255)\r\n                }\r\n                p = (p * (10000 + Increase))/10000;\r\n            }\r\n        }\r\n        \r\n        return p;\r\n    }\r\n    \r\n    function PayPoker(string Quote, string Name) public NoContract{\r\n        uint8 wins = HandWins(msg.sender);\r\n        if (wins>0){\r\n            uint256 available_balance = (TotalPot*PotPayout)/10000;\r\n            uint256 payment = sub ((available_balance * PokerPayout)/10000 , PokerPayoutValue);\r\n            \r\n            \r\n            \r\n            PokerPayoutValue = PokerPayoutValue + payment;\r\n            if (wins==1){\r\n                msg.sender.transfer(payment);\r\n                emit PokerPaid(RoundNumber, payment, msg.sender,  Quote,  Name, WinningHand);\r\n            }\r\n            /*\r\n            else if (wins==2){\r\n                uint256 pval = payment/2;\r\n                msg.sender.transfer(pval);\r\n                PokerWinner.transfer(payment-pval);// saves 1 wei error \r\n                emit PokerPaid(RoundNumber, pval, msg.sender,  Quote,  Name, WinningHand);\r\n                emit PokerPaid(RoundNumber, pval, msg.sender, \"\", \"\", WinningHand);\r\n            }*/\r\n        }\r\n        else{\r\n            // nice bluff mate \r\n            revert();\r\n        }\r\n    }\r\n    \r\n    function GetTime(uint8 id) public view returns (uint256){\r\n        if (id >= TimeArray.length){\r\n            return TimeArray[TimeArray.length-1];\r\n        }\r\n        else{\r\n            return TimeArray[id];\r\n        }\r\n    }\r\n    \r\n    //function Call() public {\r\n   //     DrawHouse();\r\n   // }\r\n    \r\n    \r\n    // pays winner. \r\n    // also sets up new game \r\n    // winner receives lots of eth compared to gas so a small payment to gas is reasonable.\r\n    \r\n    function Withdraw(string Quote, string Name) public NoContract {\r\n        _withdraw(Quote,Name,false);\r\n    }\r\n    \r\n    // in case there is a revert bug in the poker contract \r\n    // allows winner to get paid without calling poker. should never be called \r\n    // follows all normal rules of game .\r\n    function WithdrawEmergency() public OnlyOwner{\r\n        _withdraw(\"Emergency withdraw call\",\"Admin\",true);\r\n    }\r\n    function _withdraw(string Quote, string Name, bool Emergency) NoContract internal {\r\n        // Setup cards for new game. \r\n        \r\n        require(block.timestamp > Timer && Timer != 0);\r\n        Timer=0; // prevent re-entrancy immediately. \r\n        \r\n        // send from this.balance \r\n        uint256 available_balance = (TotalPot*PotPayout)/10000;\r\n        uint256 bal = (available_balance * JackpotPayout)/10000;\r\n        \r\n                    \r\n        JackpotWinner.transfer(bal);\r\n        emit JackpotPaid(RoundNumber, bal,  JackpotWinner, Quote, Name);\r\n        \r\n        // pay the last poker winner remaining poker pot.\r\n        bal = sub(sub(available_balance, bal),PokerPayoutValue);\r\n        if (bal > 0 && PokerWinner != address(this)){\r\n            // this only happens at start game,  some wei error \r\n            if (bal > address(this).balance){\r\n                PokerWinner.transfer(address(this).balance);\r\n            }\r\n            else{\r\n                PokerWinner.transfer(bal);     \r\n            }\r\n           \r\n            emit PokerPaid(RoundNumber, bal, PokerWinner,  \"Paid out left poker pot\", \"Dealer\", WinningHand);\r\n        }\r\n        TotalPot = address(this).balance;\r\n    \r\n        // next poker pot starts at zero. \r\n        PokerPayoutValue= (TotalPot * PotPayout * PokerPayout)/(10000*10000);\r\n\r\n        // reset price \r\n\r\n        for (uint i=0; i<MaxItems; i++){\r\n            Market[i].PriceID=0;\r\n        }\r\n        \r\n        if (!Emergency){\r\n            DrawHouse();\r\n        }\r\n        RoundNumber++;\r\n        // enable edit mode if set by dev.\r\n        EditMode=SetEditMode;\r\n        \r\n        emit NewRound();\r\n    }\r\n    \r\n    // dev edit functions below \r\n    \r\n    \r\n    function setEditModeBool(bool editmode) public OnlyOwner {\r\n        // start edit mode closes the whole game. \r\n        SetEditMode=editmode;\r\n        if (!editmode){\r\n            // enable game round.\r\n            EditMode=false;\r\n        }\r\n    }\r\n    \r\n    function emergencyDropEth() public payable{\r\n        // any weird error might be solved by dropping eth (and no this is not even a scam, if contract needs a wei more, we send a wei, get funds out and fix contract)\r\n    }\r\n        \r\n    function editTimer(uint8 ID, uint256 Time) public OnlyOwner GameClosed{\r\n        TimeArray[ID] = Time;\r\n    }\r\n    \r\n    function editBasePrice(uint256 NewBasePrice) public OnlyOwner GameClosed{\r\n        BasePrice = NewBasePrice;  \r\n    }\r\n    \r\n    function editMaxItems(uint8 NewMax) public OnlyOwner GameClosed{\r\n        MaxItems = NewMax;\r\n    }\r\n    \r\n    function editPayoutSetting(uint8 setting, uint16 newv) public OnlyOwner GameClosed{\r\n        require(setting > 0);\r\n        if (setting == 1){\r\n            require(newv <= 10000);\r\n            JackpotPayout = newv;\r\n            PokerPayout = 10000-newv;\r\n        }\r\n        else if (setting == 2){\r\n            require(newv <= 10000);\r\n            PokerPayout = newv;\r\n            JackpotPayout = 10000-newv;\r\n        }\r\n        else if (setting == 3){\r\n            require (newv <= 10000);\r\n            PreviousPayout = newv;\r\n        }\r\n        else if (setting == 4){\r\n            require(newv <= 30000);\r\n            Increase = newv;\r\n        }\r\n        else if (setting == 5){\r\n            require(newv <=10000);\r\n            PotPayout = newv;\r\n        }\r\n        else if (setting == 6){\r\n            require(newv < 700);\r\n            Tax = newv;\r\n        }\r\n        else{\r\n            revert();\r\n        }\r\n    }\r\n    \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"emergencyDropEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Timer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"HouseCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TotalPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PotPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feesend\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"setting\",\"type\":\"uint8\"},{\"name\":\"newv\",\"type\":\"uint16\"}],\"name\":\"editPayoutSetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"GetPlayerCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PlayerCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SetEditMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint8\"},{\"name\":\"Quote\",\"type\":\"string\"},{\"name\":\"Name\",\"type\":\"string\"}],\"name\":\"Buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rank\",\"type\":\"uint8\"},{\"name\":\"suit\",\"type\":\"uint8\"}],\"name\":\"GetCardNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"PlayerRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetWinCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EditMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"GetTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Tax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"NewBasePrice\",\"type\":\"uint256\"}],\"name\":\"editBasePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RoundNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"GetPlayerRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Quote\",\"type\":\"string\"},{\"name\":\"Name\",\"type\":\"string\"}],\"name\":\"Withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Quote\",\"type\":\"string\"},{\"name\":\"Name\",\"type\":\"string\"}],\"name\":\"PayPoker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BasePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PokerWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"GetPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"WinningCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"editmode\",\"type\":\"bool\"}],\"name\":\"setEditModeBool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"checkhand\",\"type\":\"address\"}],\"name\":\"HandWinsView\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint8\"}],\"name\":\"GetCardInfo\",\"outputs\":[{\"name\":\"rank\",\"type\":\"uint8\"},{\"name\":\"suit\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JackpotPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"WinningHand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MaxItems\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"NewMax\",\"type\":\"uint8\"}],\"name\":\"editMaxItems\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JackpotWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PokerPayoutValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint8\"},{\"name\":\"Time\",\"type\":\"uint256\"}],\"name\":\"editTimer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawEmergency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PokerPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PreviousPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Market\",\"outputs\":[{\"name\":\"Holder\",\"type\":\"address\"},{\"name\":\"PriceID\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Increase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ID\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"Price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"BoughtFrom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"NewTimer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"NewJP\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Quote\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"Name\",\"type\":\"string\"}],\"name\":\"ItemBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"AmountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Quote\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"Name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"WinHand\",\"type\":\"uint8[6]\"}],\"name\":\"PokerPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"Round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"Who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"Quote\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"Name\",\"type\":\"string\"}],\"name\":\"JackpotPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"card1\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"card2\",\"type\":\"uint8\"}],\"name\":\"DrawnCards\",\"type\":\"event\"}]","ContractName":"Vegas","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0df6764af20462a14cc70ab6d045fe0dc629fb64a6867f80cacc5c2db4fdd2cf"}]}