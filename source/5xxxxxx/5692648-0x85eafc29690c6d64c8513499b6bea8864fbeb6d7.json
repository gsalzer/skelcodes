{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/OpenZeppelin/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/OpenZeppelin/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n*/\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether.\r\n */\r\n\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // Address of the contract owner\r\n  address public owner;\r\n\r\n  // The rate of tokens per ether. Only applied for the first tier, the first\r\n  // 150 million tokens sold\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  // Amount of sold tokens\r\n  uint256 public soldTokens;\r\n\r\n  // Amount of tokens processed\r\n  uint256 public processedTokens;\r\n\r\n  // Amount of unsold tokens to burn\r\n  uint256 public unSoldTokens;\r\n\r\n  // Amount of locked tokens\r\n  uint256 public lockedTokens;\r\n\r\n  // Amount of alocated tokens\r\n  uint256 public allocatedTokens;\r\n\r\n  // Amount of distributed tokens\r\n  uint256 public distributedTokens;\r\n\r\n  // ICO state paused or not\r\n  bool public paused = false;\r\n\r\n  // Minimal amount to exchange in ETH\r\n  uint256 public minPurchase = 53 finney;\r\n\r\n  // Keeping track of current round\r\n  uint256 public currentRound;\r\n\r\n  // We can only sell maximum total amount- 1,000,000,000 tokens during the ICO\r\n  uint256 public constant maxTokensRaised = 1000000000E4;\r\n\r\n  // Timestamp when the crowdsale starts 01/01/2018 @ 00:00am (UTC);\r\n  uint256 public startTime = 1527703200;\r\n\r\n  // Timestamp when the initial round ends (UTC);\r\n  uint256 public currentRoundStart = startTime;\r\n\r\n  // Timestamp when the crowdsale ends 07/07/2018 @ 00:00am (UTC);\r\n  uint256 public endTime = 1532386740;\r\n\r\n  // Timestamp when locked tokens become unlocked 21/09/2018 @ 00:00am (UTC);\r\n  uint256 public lockedTill = 1542931200;\r\n\r\n  // Timestamp when approved tokens become available 21/09/2018 @ 00:00am (UTC);\r\n  uint256 public approvedTill = 1535328000;\r\n\r\n  // How much each user paid for the crowdsale\r\n  mapping(address => uint256) public crowdsaleBalances;\r\n\r\n  // How many tokens each user got for the crowdsale\r\n  mapping(address => uint256) public tokensBought;\r\n\r\n  // How many tokens each user got for the crowdsale as bonus\r\n  mapping(address => uint256) public bonusBalances;\r\n\r\n  // How many tokens each user got locked\r\n  mapping(address => uint256) public lockedBalances;\r\n\r\n  // How many tokens each user got pre-delivered\r\n  mapping(address => uint256) public allocatedBalances;\r\n\r\n  // If user is approved to withdraw tokens\r\n  mapping(address => bool) public approved;\r\n\r\n  // How many tokens each user got distributed\r\n  mapping(address => uint256) public distributedBalances;\r\n\r\n  // Bonus levels per each round\r\n  mapping (uint256 => uint256) public bonusLevels;\r\n\r\n  // Rate levels per each round\r\n  mapping (uint256 => uint256) public rateLevels;\r\n\r\n  // Cap levels per each round\r\n  mapping (uint256 => uint256) public capLevels;\r\n\r\n  // To track list of contributors\r\n  address[] public allocatedAddresses;              \r\n\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n\r\n  function setNewBonusLevel (uint256 _bonusIndex, uint256 _bonusValue) onlyOwner external {\r\n    bonusLevels[_bonusIndex] = _bonusValue;\r\n  }\r\n\r\n  function setNewRateLevel (uint256 _rateIndex, uint256 _rateValue) onlyOwner external {\r\n    rateLevels[_rateIndex] = _rateValue;\r\n  }\r\n\r\n  function setMinPurchase (uint256 _minPurchase) onlyOwner external {\r\n    minPurchase = _minPurchase;\r\n  }\r\n\r\n   // @notice Set's the rate of tokens per ether for each round\r\n  function setNewRatesCustom (uint256 _r1, uint256 _r2, uint256 _r3, uint256 _r4, uint256 _r5, uint256 _r6) onlyOwner external {\r\n    require(_r1 > 0 && _r2 > 0 && _r3 > 0 && _r4 > 0 && _r5 > 0 && _r6 > 0);\r\n    rateLevels[1] = _r1;\r\n    rateLevels[2] = _r2;\r\n    rateLevels[3] = _r3;\r\n    rateLevels[4] = _r4;\r\n    rateLevels[5] = _r5;\r\n    rateLevels[6] = _r6;\r\n  }\r\n\r\n   // @notice Set's the rate of tokens per ether for each round\r\n  function setNewRatesBase (uint256 _r1) onlyOwner external {\r\n    require(_r1 > 0);\r\n    rateLevels[1] = _r1;\r\n    rateLevels[2] = _r1.div(2);\r\n    rateLevels[3] = _r1.div(3);\r\n    rateLevels[4] = _r1.div(4);\r\n    rateLevels[5] = _r1.div(5);\r\n    rateLevels[6] = _r1.div(5);\r\n  }\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per ETH\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n\r\n  constructor(uint256 _rate, address _wallet, address _owner, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    wallet = _wallet;\r\n    token = _token;\r\n    owner = _owner;\r\n\r\n    soldTokens = 0;\r\n    unSoldTokens = 0;\r\n    processedTokens = 0;\r\n\r\n    lockedTokens = 0;\r\n    distributedTokens = 0;\r\n\r\n    currentRound = 1;\r\n\r\n    //bonus values per each round;\r\n    bonusLevels[1] =  5;\r\n    bonusLevels[2] = 10;\r\n    bonusLevels[3] = 15;\r\n    bonusLevels[4] = 20;\r\n    bonusLevels[5] = 50;\r\n    bonusLevels[6] = 0;\r\n\r\n    //rate values per each round;\r\n    rateLevels[1] = _rate;\r\n    rateLevels[2] = _rate.div(2);\r\n    rateLevels[3] = _rate.div(3);\r\n    rateLevels[4] = _rate.div(4);\r\n    rateLevels[5] = _rate.div(5);\r\n    rateLevels[6] = _rate.div(5);\r\n\r\n    //cap values per each round\r\n    capLevels[1] = 150000000E4;\r\n    capLevels[2] = 210000000E4;\r\n    capLevels[3] = 255000000E4;\r\n    capLevels[4] = 285000000E4;\r\n    capLevels[5] = 300000000E4;\r\n    capLevels[6] = maxTokensRaised;\r\n\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale interface\r\n  // -----------------------------------------\r\n\r\n  function () external payable whenNotPaused {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable whenNotPaused {\r\n\r\n    uint256 amountPaid = msg.value;\r\n    _preValidatePurchase(_beneficiary, amountPaid);\r\n\r\n    uint256 tokens = 0;\r\n    uint256 bonusTokens = 0;\r\n    uint256 fullTokens = 0;\r\n\r\n    // Round 1\r\n    if(processedTokens < capLevels[1]) {\r\n\r\n        tokens = _getTokensAmount(amountPaid, 1);\r\n        bonusTokens = _getBonusAmount(tokens, 1);\r\n        fullTokens = tokens.add(bonusTokens);\r\n\r\n        // If the amount of tokens that you want to buy gets out of round 1\r\n        if(processedTokens.add(fullTokens) > capLevels[1]) {\r\n            tokens = _calculateExcessTokens(amountPaid, 1);\r\n            bonusTokens = _calculateExcessBonus(tokens, 1);\r\n            setCurrentRound(2);\r\n        }\r\n\r\n    // Round 2\r\n    } else if(processedTokens >= capLevels[1] && processedTokens < capLevels[2]) {\r\n        tokens = _getTokensAmount(amountPaid, 2);\r\n        bonusTokens = _getBonusAmount(tokens, 2);\r\n        fullTokens = tokens.add(bonusTokens);\r\n\r\n        // If the amount of tokens that you want to buy gets out of round 2\r\n        if(processedTokens.add(fullTokens) > capLevels[2]) {\r\n            tokens = _calculateExcessTokens(amountPaid, 2);\r\n            bonusTokens = _calculateExcessBonus(tokens, 2);\r\n            setCurrentRound(3);\r\n        }\r\n\r\n    // Round 3\r\n    } else if(processedTokens >= capLevels[2] && processedTokens < capLevels[3]) {\r\n         tokens = _getTokensAmount(amountPaid, 3);\r\n         bonusTokens = _getBonusAmount(tokens, 3);\r\n         fullTokens = tokens.add(bonusTokens);\r\n\r\n         // If the amount of tokens that you want to buy gets out of round 3\r\n         if(processedTokens.add(fullTokens) > capLevels[3]) {\r\n            tokens = _calculateExcessTokens(amountPaid, 3);\r\n            bonusTokens = _calculateExcessBonus(tokens, 3);\r\n            setCurrentRound(4);\r\n         }\r\n\r\n    // Round 4\r\n    } else if(processedTokens >= capLevels[3] && processedTokens < capLevels[4]) {\r\n         tokens = _getTokensAmount(amountPaid, 4);\r\n         bonusTokens = _getBonusAmount(tokens, 4);\r\n         fullTokens = tokens.add(bonusTokens);\r\n\r\n         // If the amount of tokens that you want to buy gets out of round 4\r\n         if(processedTokens.add(fullTokens) > capLevels[4]) {\r\n            tokens = _calculateExcessTokens(amountPaid, 4);\r\n            bonusTokens = _calculateExcessBonus(tokens, 4);\r\n            setCurrentRound(5);\r\n         }\r\n\r\n    // Round 5\r\n    } else if(processedTokens >= capLevels[4] && processedTokens < capLevels[5]) {\r\n         tokens = _getTokensAmount(amountPaid, 5);\r\n         bonusTokens = _getBonusAmount(tokens, 5);\r\n         fullTokens = tokens.add(bonusTokens);\r\n\r\n         // If the amount of tokens that you want to buy gets out of round 5\r\n         if(processedTokens.add(fullTokens) > capLevels[5]) {\r\n            tokens = _calculateExcessTokens(amountPaid, 5);\r\n            bonusTokens = 0;\r\n            setCurrentRound(6);\r\n         }\r\n\r\n    // Round 6\r\n    } else if(processedTokens >= capLevels[5]) {\r\n        tokens = _getTokensAmount(amountPaid, 6);\r\n    }\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(amountPaid);\r\n    fullTokens = tokens.add(bonusTokens);\r\n    soldTokens = soldTokens.add(fullTokens);\r\n    processedTokens = processedTokens.add(fullTokens);\r\n\r\n    // Keep a record of how many tokens everybody gets in case we need to do refunds\r\n    tokensBought[msg.sender] = tokensBought[msg.sender].add(tokens);\r\n\r\n    // Kepp a record of how many wei everybody contributed in case we need to do refunds\r\n    crowdsaleBalances[msg.sender] = crowdsaleBalances[msg.sender].add(amountPaid);\r\n\r\n    // Kepp a record of how many token everybody got as bonus to display in\r\n    bonusBalances[msg.sender] = bonusBalances[msg.sender].add(bonusTokens);\r\n\r\n   // Combine bought tokens with bonus tokens before sending to investor\r\n    uint256 totalTokens = tokens.add(bonusTokens);\r\n\r\n    // Distribute the token\r\n    _processPurchase(_beneficiary, totalTokens);\r\n    emit TokenPurchase(\r\n      msg.sender,\r\n      _beneficiary,\r\n      amountPaid,\r\n      totalTokens\r\n    );\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) view internal {\r\n\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n\r\n    bool withinPeriod = hasStarted() && hasNotEnded();\r\n    bool nonZeroPurchase = msg.value > 0;\r\n    bool withinTokenLimit = processedTokens < maxTokensRaised;\r\n    bool minimumPurchase = msg.value >= minPurchase;\r\n\r\n    require(withinPeriod);\r\n    require(nonZeroPurchase);\r\n    require(withinTokenLimit);\r\n    require(minimumPurchase);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n    uint256 _tokensToPreAllocate = _tokenAmount.div(2);\r\n    uint256 _tokensToLock = _tokenAmount.sub(_tokensToPreAllocate);\r\n    \r\n    //record address for future distribution\r\n    allocatedAddresses.push(_beneficiary);    \r\n\r\n    //pre allocate 50% of purchase for delivery in 30 days\r\n    _preAllocateTokens(_beneficiary, _tokensToPreAllocate);\r\n    \r\n    //lock 50% of purchase for delivery after 4 months\r\n    _lockTokens(_beneficiary, _tokensToLock);\r\n    \r\n    //approve by default (dissaprove manually)\r\n    approved[_beneficiary] = true;\r\n  }\r\n\r\n  function _lockTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n    lockedBalances[_beneficiary] = lockedBalances[_beneficiary].add(_tokenAmount);\r\n    lockedTokens = lockedTokens.add(_tokenAmount);\r\n  }\r\n\r\n  function _preAllocateTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n    allocatedBalances[_beneficiary] = allocatedBalances[_beneficiary].add(_tokenAmount);\r\n    allocatedTokens = allocatedTokens.add(_tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to bonus tokens.\r\n   * @param _tokenAmount Value in wei to be converted into tokens\r\n   * @return Number of bonus tokens that can be distributed with the specified bonus percent\r\n   */\r\n  function _getBonusAmount(uint256 _tokenAmount, uint256 _bonusIndex) internal view returns (uint256) {\r\n    uint256 bonusValue = _tokenAmount.mul(bonusLevels[_bonusIndex]);\r\n    return bonusValue.div(100);\r\n  }\r\n\r\n    function _calculateExcessBonus(uint256 _tokens, uint256 _level) internal view returns (uint256) {\r\n        uint256 thisLevelTokens = processedTokens.add(_tokens);\r\n        uint256 nextLevelTokens = thisLevelTokens.sub(capLevels[_level]);\r\n        uint256 totalBonus = _getBonusAmount(nextLevelTokens, _level.add(1));\r\n        return totalBonus;\r\n    }\r\n\r\n   function _calculateExcessTokens(\r\n      uint256 amount,\r\n      uint256 roundSelected\r\n   ) internal returns(uint256) {\r\n      require(amount > 0);\r\n      require(roundSelected >= 1 && roundSelected <= 6);\r\n\r\n      uint256 _rate = rateLevels[roundSelected];\r\n      uint256 _leftTokens = capLevels[roundSelected].sub(processedTokens);\r\n      uint256 weiThisRound = _leftTokens.div(_rate).mul(1E14);\r\n      uint256 weiNextRound = amount.sub(weiThisRound);\r\n      uint256 tokensNextRound = 0;\r\n\r\n      // If there's excessive wei for the last tier, refund those\r\n      uint256 nextRound = roundSelected.add(1);\r\n      if(roundSelected != 6) {\r\n        tokensNextRound = _getTokensAmount(weiNextRound, nextRound);\r\n      }\r\n      else {\r\n         msg.sender.transfer(weiNextRound);\r\n      }\r\n\r\n      uint256 totalTokens = _leftTokens.add(tokensNextRound);\r\n      return totalTokens;\r\n   }\r\n\r\n\r\n   function _getTokensAmount(uint256 weiPaid, uint256 roundSelected)\r\n        internal constant returns(uint256 calculatedTokens)\r\n   {\r\n      require(weiPaid > 0);\r\n      require(roundSelected >= 1 && roundSelected <= 6);\r\n      uint256 typeTokenWei = weiPaid.div(1E14);\r\n      calculatedTokens = typeTokenWei.mul(rateLevels[roundSelected]);\r\n\r\n   }\r\n\r\n  // -----------------------------------------\r\n  // External interface (withdraw)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Determines how ETH is being transfered to owners wallet.\r\n   */\r\n  function _withdrawAllFunds() onlyOwner external {\r\n    wallet.transfer(address(this).balance);\r\n  }\r\n\r\n  function _withdrawWei(uint256 _amount) onlyOwner external {\r\n    wallet.transfer(_amount);\r\n  }\r\n\r\n   function _changeLockDate(uint256 _newDate) onlyOwner external {\r\n    require(_newDate <= endTime.add(36 weeks));\r\n    lockedTill = _newDate;\r\n  }\r\n\r\n   function _changeApproveDate(uint256 _newDate) onlyOwner external {\r\n    require(_newDate <= endTime.add(12 weeks));\r\n    approvedTill = _newDate;\r\n  }\r\n\r\n  function changeWallet(address _newWallet) onlyOwner external {\r\n    wallet = _newWallet;\r\n  }\r\n\r\n   /// @notice Public function to check if the crowdsale has ended or not\r\n   function hasNotEnded() public constant returns(bool) {\r\n      return now < endTime && processedTokens < maxTokensRaised;\r\n   }\r\n\r\n   /// @notice Public function to check if the crowdsale has started or not\r\n   function hasStarted() public constant returns(bool) {\r\n      return now > startTime;\r\n   }\r\n\r\n    function setCurrentRound(uint256 _roundIndex) internal {\r\n        currentRound = _roundIndex;\r\n        currentRoundStart = now;\r\n    }\r\n\r\n    //move to next round by overwriting soldTokens value, unsold tokens will be burned;\r\n   function goNextRound() onlyOwner external {\r\n       require(currentRound < 6);\r\n       uint256 notSold = getUnsold();\r\n       unSoldTokens = unSoldTokens.add(notSold);\r\n       processedTokens = capLevels[currentRound];\r\n       currentRound = currentRound.add(1);\r\n       currentRoundStart = now;\r\n   }\r\n\r\n    function getUnsold() internal view returns (uint256) {\r\n        uint256 unSold = capLevels[currentRound].sub(processedTokens);\r\n        return unSold;\r\n    }\r\n\r\n    function checkUnsold() onlyOwner external view returns (uint256) {\r\n        uint256 unSold = capLevels[currentRound].sub(processedTokens);\r\n        return unSold;\r\n    }\r\n\r\n    function round() public view returns(uint256) {\r\n        return currentRound;\r\n    }\r\n\r\n    function currentBonusLevel() public view returns(uint256) {\r\n        return bonusLevels[currentRound];\r\n    }\r\n\r\n    function currentRateLevel() public view returns(uint256) {\r\n        return rateLevels[currentRound];\r\n    }\r\n\r\n    function currentCapLevel() public view returns(uint256) {\r\n        return capLevels[currentRound];\r\n    }\r\n\r\n    function changeApproval(address _beneficiary, bool _newStatus) onlyOwner public {\r\n        approved[_beneficiary] = _newStatus;\r\n    }\r\n\r\n    function massApproval(bool _newStatus, uint256 _start, uint256 _end) onlyOwner public {\r\n        require(_start >= 0);\r\n        require(_end > 0);\r\n        require(_end > _start);\r\n        for (uint256 i = _start; i < _end; i++) {\r\n            approved[allocatedAddresses[i]] = _newStatus;\r\n        }\r\n    }\r\n\r\n    function autoTransferApproved(uint256 _start, uint256 _end) onlyOwner public {\r\n        require(_start >= 0);\r\n        require(_end > 0);\r\n        require(_end > _start);\r\n        for (uint256 i = _start; i < _end; i++) {\r\n            transferApprovedBalance(allocatedAddresses[i]);\r\n        }\r\n    }\r\n\r\n    function autoTransferLocked(uint256 _start, uint256 _end) onlyOwner public {\r\n        require(_start >= 0);\r\n        require(_end > 0);\r\n        require(_end > _start);\r\n        for (uint256 i = _start; i < _end; i++) {\r\n            transferLockedBalance(allocatedAddresses[i]);\r\n        }\r\n    }\r\n\r\n    function transferApprovedBalance(address _beneficiary) public {\r\n        require(_beneficiary != address(0));\r\n        require(now >= approvedTill);\r\n        require(allocatedTokens > 0);\r\n        require(approved[_beneficiary]);\r\n        require(allocatedBalances[_beneficiary] > 0);\r\n        \r\n        uint256 _approvedTokensToTransfer = allocatedBalances[_beneficiary];\r\n        token.transfer(_beneficiary, _approvedTokensToTransfer);\r\n        distributedBalances[_beneficiary] = distributedBalances[_beneficiary].add(_approvedTokensToTransfer);\r\n        allocatedTokens = allocatedTokens.sub(_approvedTokensToTransfer);\r\n        allocatedBalances[_beneficiary] = 0;\r\n        distributedTokens = distributedTokens.add(_approvedTokensToTransfer);\r\n    }\r\n\r\n    function transferLockedBalance(address _beneficiary) public {\r\n        require(_beneficiary != address(0));\r\n        require(now >= lockedTill);\r\n        require(lockedTokens > 0);\r\n        require(approved[_beneficiary]);\r\n        require(lockedBalances[_beneficiary] > 0);\r\n\r\n        uint256 _lockedTokensToTransfer = lockedBalances[_beneficiary];\r\n        token.transfer(_beneficiary, _lockedTokensToTransfer);\r\n        distributedBalances[_beneficiary] = distributedBalances[_beneficiary].add(_lockedTokensToTransfer);\r\n        lockedTokens = lockedTokens.sub(_lockedTokensToTransfer);\r\n        lockedBalances[_beneficiary] = 0;\r\n        distributedTokens = distributedTokens.add(_lockedTokensToTransfer);\r\n    }\r\n\r\n    function transferToken(uint256 _tokens) external onlyOwner returns (bool success) {\r\n        //bool withinPeriod = hasStarted() && hasNotEnded();\r\n        //require(!withinPeriod);\r\n        return token.transfer(owner, _tokens);\r\n    }\r\n\r\n    function tokenBalance() public view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    //destory contract with unsold tokens\r\n    function burnUnsold() public onlyOwner {\r\n        require(now > lockedTill);\r\n        require(address(this).balance == 0);\r\n        require(lockedTokens == 0);\r\n        require(allocatedTokens == 0);\r\n        require(unSoldTokens > 0);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"allocatedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rateLevels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokensRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"transferApprovedBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"crowdsaleBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"distributedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStatus\",\"type\":\"bool\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"massApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_r1\",\"type\":\"uint256\"},{\"name\":\"_r2\",\"type\":\"uint256\"},{\"name\":\"_r3\",\"type\":\"uint256\"},{\"name\":\"_r4\",\"type\":\"uint256\"},{\"name\":\"_r5\",\"type\":\"uint256\"},{\"name\":\"_r6\",\"type\":\"uint256\"}],\"name\":\"setNewRatesCustom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRoundStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allocatedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkUnsold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvedTill\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocatedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDate\",\"type\":\"uint256\"}],\"name\":\"_changeApproveDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"transferLockedBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCapLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRateLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDate\",\"type\":\"uint256\"}],\"name\":\"_changeLockDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rateIndex\",\"type\":\"uint256\"},{\"name\":\"_rateValue\",\"type\":\"uint256\"}],\"name\":\"setNewRateLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"processedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"autoTransferLocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_withdrawWei\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unSoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_withdrawAllFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_newStatus\",\"type\":\"bool\"}],\"name\":\"changeApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnUnsold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"capLevels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"goNextRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"autoTransferApproved\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTill\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusLevels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBonusLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonusIndex\",\"type\":\"uint256\"},{\"name\":\"_bonusValue\",\"type\":\"uint256\"}],\"name\":\"setNewBonusLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minPurchase\",\"type\":\"uint256\"}],\"name\":\"setMinPurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_r1\",\"type\":\"uint256\"}],\"name\":\"setNewRatesBase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasNotEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000d055000000000000000000000000641ad78baca220c5bd28b51ce8e0f495e85fe689000000000000000000000000641ad78baca220c5bd28b51ce8e0f495e85fe689000000000000000000000000eaf61fc150cd5c3bea75744e830d916e60ea5a9f","Library":"","SwarmSource":"bzzr://718195f9c192db5ad6e7d37685a3cc0725598a69fb3dc25c7533b36074008924"}]}