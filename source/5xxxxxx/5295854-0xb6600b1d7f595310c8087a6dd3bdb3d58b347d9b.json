{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control \r\n * functions, this simplifies the implementation of \"user permissions\". \r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /** \r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev revert()s if called by any account other than the owner. \r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to. \r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  \r\n  \r\n  function mul256(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div256(uint256 a, uint256 b) internal returns (uint256) {\r\n    require(b > 0); // Solidity automatically revert()s when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub256(uint256 a, uint256 b) internal returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add256(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }  \r\n  \r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant public returns (uint256);\r\n  function transfer(address to, uint256 value) public;\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev ERC20 interface with allowances. \r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant public returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public;\r\n  function approve(address spender, uint256 value) public;\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n     require(msg.data.length >= size + 4);\r\n     _;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public {\r\n    balances[msg.sender] = balances[msg.sender].sub256(_value);\r\n    balances[_to] = balances[_to].add256(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n * @dev Implemantation of the basic standart token.\r\n */\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already revert() if this condition is not met\r\n    // if (_value > _allowance) revert();\r\n\r\n    balances[_to] = balances[_to].add256(_value);\r\n    balances[_from] = balances[_from].sub256(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub256(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public {\r\n\r\n    //  To change the approve amount you first have to reduce the addresses\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint specifing the amount of tokens still avaible for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title TeuToken\r\n * @dev The main TEU token contract\r\n * \r\n */\r\n \r\ncontract TeuToken is StandardToken, Ownable{\r\n  string public name = \"20-footEqvUnit\";\r\n  string public symbol = \"TEU\";\r\n  uint public decimals = 18;\r\n\r\n  event TokenBurned(uint256 value);\r\n  \r\n  function TeuToken() public {\r\n    totalSupply = (10 ** 8) * (10 ** decimals);\r\n    balances[msg.sender] = totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the owner to burn the token\r\n   * @param _value number of tokens to be burned.\r\n   */\r\n  function burn(uint _value) onlyOwner public {\r\n    require(balances[msg.sender] >= _value);\r\n    balances[msg.sender] = balances[msg.sender].sub256(_value);\r\n    totalSupply = totalSupply.sub256(_value);\r\n    TokenBurned(_value);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title teuInitialTokenSale \r\n * @dev The TEU token ICO contract\r\n * \r\n */\r\ncontract teuInitialTokenSale is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n    event LogContribution(address indexed _contributor, uint256 _etherAmount, uint256 _basicTokenAmount, uint256 _timeBonusTokenAmount, uint256 _volumeBonusTokenAmount);\r\n    event LogContributionBitcoin(address indexed _contributor, uint256 _bitcoinAmount, uint256 _etherAmount, uint256 _basicTokenAmount, uint256 _timeBonusTokenAmount, uint256 _volumeBonusTokenAmount, uint _contributionDatetime);\r\n    event LogOffChainContribution(address indexed _contributor, uint256 _etherAmount, uint256 _tokenAmount);\r\n    event LogReferralAward(address indexed _refereeWallet, address indexed _referrerWallet, uint256 _referralBonusAmount);\r\n    event LogTokenCollected(address indexed _contributor, uint256 _collectedTokenAmount);\r\n    event LogClientIdentRejectListChange(address indexed _contributor, uint8 _newValue);\r\n\r\n\r\n    TeuToken\t\t\t                constant private\t\ttoken = TeuToken(0xeEAc3F8da16bb0485a4A11c5128b0518DaC81448); // hard coded due to token already deployed\r\n    address\t\t                        constant private\t\tetherHolderWallet = 0x00222EaD2D0F83A71F645d3d9634599EC8222830; // hard coded due to deployment for once only\r\n    uint256\t\t                        constant private \t    minContribution = 100 finney;\r\n    uint                                         public         saleStart = 1523498400;\r\n    uint                                         public         saleEnd = 1526090400;\r\n    uint                                constant private        etherToTokenConversionRate = 400;\r\n    uint                                constant private        referralAwardPercent = 20;\r\n    uint256                             constant private        maxCollectableToken = 20 * 10 ** 6 * 10 ** 18;\r\n\r\n    mapping (address => uint256)                private     referralContribution;  // record the referral contribution amount in ether for claiming of referral bonus\r\n    mapping (address => uint)                   private     lastContribitionDate;  // record the last contribution date/time for valid the referral bonus claiming period\r\n\r\n    mapping (address => uint256)                private     collectableToken;  // record the token amount to be collected of each contributor\r\n    mapping (address => uint8)                  private     clientIdentRejectList;  // record a list of contributors who do not pass the client identification process\r\n    bool                                        public      isCollectTokenStart = false;  // flag to indicate if token collection is started\r\n    bool                                        public      isAllowContribution = true; // flag to enable/disable contribution.\r\n    uint256                                     public      totalCollectableToken;  // the total amount of token will be colleceted after considering all the contribution and bonus\r\n\r\n    //  ***** private helper functions ***************\r\n\r\n    \r\n\r\n    /**\r\n    * @dev get the current datetime\r\n    */   \r\n    function getCurrentDatetime() private constant returns (uint) {\r\n        return now; \r\n    }\r\n\r\n    /**\r\n    * @dev get the current sale day\r\n    */   \r\n    function getCurrentSaleDay() private saleIsOn returns (uint) {\r\n        return getCurrentDatetime().sub256(saleStart).div256(86400).add256(1);\r\n    }\r\n\r\n    /**\r\n    * @dev to get the time bonus Percentage based on the no. of sale day(s)\r\n    * @param _days no of sale day to calculate the time bonus\r\n    */      \r\n    function getTimeBonusPercent(uint _days) private pure returns (uint) {\r\n        if (_days <= 10)\r\n            return 50;\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n    * @dev to get the volumne bonus percentage based on the ether amount contributed\r\n    * @param _etherAmount ether amount contributed.\r\n    */          \r\n    function getVolumeBonusPercent(uint256 _etherAmount) private pure returns (uint) {\r\n\r\n        if (_etherAmount < 1 ether)\r\n            return 0;\r\n        if (_etherAmount < 2 ether)\r\n            return 35;\r\n        if (_etherAmount < 3 ether)\r\n            return 40;\r\n        if (_etherAmount < 4 ether)\r\n            return 45;\r\n        if (_etherAmount < 5 ether)\r\n            return 50;\r\n        if (_etherAmount < 10 ether)\r\n            return 55;\r\n        if (_etherAmount < 20 ether)\r\n            return 60;\r\n        if (_etherAmount < 30 ether)\r\n            return 65;\r\n        if (_etherAmount < 40 ether)\r\n            return 70;\r\n        if (_etherAmount < 50 ether)\r\n            return 75;\r\n        if (_etherAmount < 100 ether)\r\n            return 80;\r\n        if (_etherAmount < 200 ether)\r\n            return 90;\r\n        if (_etherAmount >= 200 ether)\r\n            return 100;\r\n        return 0;\r\n    }\r\n    \r\n    /**\r\n    * @dev to get the time bonus amount given the token amount to be collected from contribution\r\n    * @param _tokenAmount token amount to be collected from contribution\r\n    */ \r\n    function getTimeBonusAmount(uint256 _tokenAmount) private returns (uint256) {\r\n        return _tokenAmount.mul256(getTimeBonusPercent(getCurrentSaleDay())).div256(100);\r\n    }\r\n    \r\n    /**\r\n    * @dev to get the volume bonus amount given the token amount to be collected from contribution and the ether amount contributed\r\n    * @param _tokenAmount token amount to be collected from contribution\r\n    * @param _etherAmount ether amount contributed\r\n    */\r\n    function getVolumeBonusAmount(uint256 _tokenAmount, uint256 _etherAmount) private returns (uint256) {\r\n        return _tokenAmount.mul256(getVolumeBonusPercent(_etherAmount)).div256(100);\r\n    }\r\n    \r\n    /**\r\n    * @dev to get the referral bonus amount given the ether amount contributed\r\n    * @param _etherAmount ether amount contributed\r\n    */\r\n    function getReferralBonusAmount(uint256 _etherAmount) private returns (uint256) {\r\n        return _etherAmount.mul256(etherToTokenConversionRate).mul256(referralAwardPercent).div256(100);\r\n    }\r\n    \r\n    /**\r\n    * @dev to get the basic amount of token to be collected given the ether amount contributed\r\n    * @param _etherAmount ether amount contributed\r\n    */\r\n    function getBasicTokenAmount(uint256 _etherAmount) private returns (uint256) {\r\n        return _etherAmount.mul256(etherToTokenConversionRate);\r\n    }\r\n  \r\n  \r\n    // ****** modifiers  ************\r\n\r\n    /**\r\n    * @dev modifier to allow contribution only when the sale is ON\r\n    */\r\n    modifier saleIsOn() {\r\n        require(getCurrentDatetime() >= saleStart && getCurrentDatetime() < saleEnd);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to check if the sale is ended\r\n    */    \r\n    modifier saleIsEnd() {\r\n        require(getCurrentDatetime() >= saleEnd);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to check if token is collectable\r\n    */    \r\n    modifier tokenIsCollectable() {\r\n        require(isCollectTokenStart);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev modifier to check if contribution is over the min. contribution amount\r\n    */    \r\n    modifier overMinContribution(uint256 _etherAmount) {\r\n        require(_etherAmount >= minContribution);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev modifier to check if max. token pool is not reached\r\n    */\r\n    modifier underMaxTokenPool() {\r\n        require(maxCollectableToken > totalCollectableToken);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to check if contribution is allowed\r\n    */\r\n    modifier contributionAllowed() {\r\n        require(isAllowContribution);\r\n        _;\r\n    }\r\n\r\n\r\n    //  ***** public transactional functions ***************\r\n    /**\r\n    * @dev called by owner to set the new sale start date/time \r\n    * @param _newStart new start date/time\r\n    */\r\n    function setNewStart(uint _newStart) public onlyOwner {\r\n\trequire(saleStart > getCurrentDatetime());\r\n        require(_newStart > getCurrentDatetime());\r\n\trequire(saleEnd > _newStart);\r\n        saleStart = _newStart;\r\n    }\r\n\r\n    /**\r\n    * @dev called by owner to set the new sale end date/time \r\n    * @param _newEnd new end date/time\r\n    */\r\n    function setNewEnd(uint _newEnd) public onlyOwner {\r\n\trequire(saleEnd < getCurrentDatetime());\r\n        require(_newEnd < getCurrentDatetime());\r\n\trequire(_newEnd > saleStart);\r\n        saleEnd = _newEnd;\r\n    }\r\n\r\n    /**\r\n    * @dev called by owner to enable / disable contribution \r\n    * @param _isAllow true - allow contribution; false - disallow contribution\r\n    */\r\n    function enableContribution(bool _isAllow) public onlyOwner {\r\n        isAllowContribution = _isAllow;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev called by contributors to record a contribution \r\n    */\r\n    function contribute() public payable saleIsOn overMinContribution(msg.value) underMaxTokenPool contributionAllowed {\r\n        uint256 _basicToken = getBasicTokenAmount(msg.value);\r\n        uint256 _timeBonus = getTimeBonusAmount(_basicToken);\r\n        uint256 _volumeBonus = getVolumeBonusAmount(_basicToken, msg.value);\r\n        uint256 _totalToken = _basicToken.add256(_timeBonus).add256(_volumeBonus);\r\n        \r\n        lastContribitionDate[msg.sender] = getCurrentDatetime();\r\n        referralContribution[msg.sender] = referralContribution[msg.sender].add256(msg.value);\r\n        \r\n        collectableToken[msg.sender] = collectableToken[msg.sender].add256(_totalToken);\r\n        totalCollectableToken = totalCollectableToken.add256(_totalToken);\r\n        assert(etherHolderWallet.send(msg.value));\r\n\r\n        LogContribution(msg.sender, msg.value, _basicToken, _timeBonus, _volumeBonus);\r\n    }\r\n\r\n    /**\r\n    * @dev called by contract owner to record a off chain contribution by Bitcoin. The token collection process is the same as those ether contributors\r\n    * @param _bitcoinAmount bitcoin amount contributed\r\n    * @param _etherAmount ether equivalent amount contributed\r\n    * @param _contributorWallet wallet address of contributor which will be used for token collection\r\n    * @param _contributionDatetime date/time of contribution. For calculating time bonus and claiming referral bonus.\r\n    */\r\n    function contributeByBitcoin(uint256 _bitcoinAmount, uint256 _etherAmount, address _contributorWallet, uint _contributionDatetime) public overMinContribution(_etherAmount) onlyOwner contributionAllowed {\r\n        require(_contributionDatetime <= getCurrentDatetime());\r\n\r\n        uint256 _basicToken = getBasicTokenAmount(_etherAmount);\r\n        uint256 _timeBonus = getTimeBonusAmount(_basicToken);\r\n        uint256 _volumeBonus = getVolumeBonusAmount(_basicToken, _etherAmount);\r\n        uint256 _totalToken = _basicToken.add256(_timeBonus).add256(_volumeBonus);\r\n        \r\n\t    if (_contributionDatetime > lastContribitionDate[_contributorWallet])\r\n            lastContribitionDate[_contributorWallet] = _contributionDatetime;\r\n        referralContribution[_contributorWallet] = referralContribution[_contributorWallet].add256(_etherAmount);\r\n    \r\n        collectableToken[_contributorWallet] = collectableToken[_contributorWallet].add256(_totalToken);\r\n        totalCollectableToken = totalCollectableToken.add256(_totalToken);\r\n        LogContributionBitcoin(_contributorWallet, _bitcoinAmount, _etherAmount, _basicToken, _timeBonus, _volumeBonus, _contributionDatetime);\r\n    }\r\n    \r\n    /**\r\n    * @dev called by contract owner to record a off chain contribution by Ether. The token are distributed off chain already.  The contributor can only entitle referral bonus through this smart contract\r\n    * @param _etherAmount ether equivalent amount contributed\r\n    * @param _contributorWallet wallet address of contributor which will be used for referral bonus collection\r\n    * @param _tokenAmount amunt of token distributed to the contributor. For reference only in the event log\r\n    */\r\n    function recordOffChainContribute(uint256 _etherAmount, address _contributorWallet, uint256 _tokenAmount) public overMinContribution(_etherAmount) onlyOwner {\r\n\r\n        lastContribitionDate[_contributorWallet] = getCurrentDatetime();\r\n        LogOffChainContribution(_contributorWallet, _etherAmount, _tokenAmount);\r\n    }    \r\n\r\n    /**\r\n    * @dev called by contributor to claim the referral bonus\r\n    * @param _referrerWallet wallet address of referrer.  Referrer must also be a contributor\r\n    */\r\n    function referral(address _referrerWallet) public {\r\n\trequire (msg.sender != _referrerWallet);\r\n        require (referralContribution[msg.sender] > 0);\r\n        require (lastContribitionDate[_referrerWallet] > 0);\r\n        require (getCurrentDatetime() - lastContribitionDate[msg.sender] <= (4 * 24 * 60 * 60));\r\n        \r\n        uint256 _referralBonus = getReferralBonusAmount(referralContribution[msg.sender]);\r\n        referralContribution[msg.sender] = 0;\r\n        \r\n        collectableToken[msg.sender] = collectableToken[msg.sender].add256(_referralBonus);\r\n        collectableToken[_referrerWallet] = collectableToken[_referrerWallet].add256(_referralBonus);\r\n        totalCollectableToken = totalCollectableToken.add256(_referralBonus).add256(_referralBonus);\r\n        LogReferralAward(msg.sender, _referrerWallet, _referralBonus);\r\n    }\r\n    \r\n    /**\r\n    * @dev called by contract owener to register a list of rejected clients who cannot pass the client identification process.\r\n    * @param _clients an array of wallet address clients to be set\r\n    * @param _valueToSet  1 - add to reject list, 0 - remove from reject list\r\n    */\r\n    function setClientIdentRejectList(address[] _clients, uint8 _valueToSet) public onlyOwner {\r\n        for (uint i = 0; i < _clients.length; i++) {\r\n            if (_clients[i] != address(0) && clientIdentRejectList[_clients[i]] != _valueToSet) {\r\n                clientIdentRejectList[_clients[i]] = _valueToSet;\r\n                LogClientIdentRejectListChange(_clients[i], _valueToSet);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev called by contract owner to enable / disable token collection process\r\n    * @param _enable true - enable collection; false - disable collection\r\n    */\r\n    function setTokenCollectable(bool _enable) public onlyOwner saleIsEnd {\r\n        isCollectTokenStart = _enable;\r\n    }\r\n    \r\n    /**\r\n    * @dev called by contributor to collect tokens.  If they are rejected by the client identification process, error will be thrown\r\n    */\r\n    function collectToken() public tokenIsCollectable {\r\n\tuint256 _collToken = collectableToken[msg.sender];\r\n\r\n\trequire(clientIdentRejectList[msg.sender] <= 0);\r\n        require(_collToken > 0);\r\n\r\n        collectableToken[msg.sender] = 0;\r\n\r\n        token.transfer(msg.sender, _collToken);\r\n        LogTokenCollected(msg.sender, _collToken);\r\n    }\r\n\r\n    /**\r\n    * @dev Allow owner to transfer out the token left in the contract\r\n    * @param _to address to transfer to\r\n    * @param _amount amount to transfer\r\n    */  \r\n    function transferTokenOut(address _to, uint256 _amount) public onlyOwner {\r\n        token.transfer(_to, _amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Allow owner to transfer out the ether left in the contract\r\n    * @param _to address to transfer to\r\n    * @param _amount amount to transfer\r\n    */  \r\n    function transferEtherOut(address _to, uint256 _amount) public onlyOwner {\r\n        assert(_to.send(_amount));\r\n    }  \r\n    \r\n\r\n    //  ***** public constant functions ***************\r\n\r\n    /**\r\n    * @dev to get the amount of token collectable by any contributor\r\n    * @param _contributor contributor to get amont\r\n    */  \r\n    function collectableTokenOf(address _contributor) public constant returns (uint256) {\r\n        return collectableToken[_contributor] ;\r\n    }\r\n    \r\n    /**\r\n    * @dev to get the amount of token collectable by any contributor\r\n    * @param _contributor contributor to get amont\r\n    */  \r\n    function isClientIdentRejectedOf(address _contributor) public constant returns (uint8) {\r\n        return clientIdentRejectList[_contributor];\r\n    }    \r\n    \r\n    /**\r\n    * @dev Fallback function which receives ether and create the appropriate number of tokens for the \r\n    * msg.sender.\r\n    */\r\n    function() external payable {\r\n        contribute();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokenOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bitcoinAmount\",\"type\":\"uint256\"},{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_contributorWallet\",\"type\":\"address\"},{\"name\":\"_contributionDatetime\",\"type\":\"uint256\"}],\"name\":\"contributeByBitcoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"collectableTokenOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferEtherOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollectableToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_clients\",\"type\":\"address[]\"},{\"name\":\"_valueToSet\",\"type\":\"uint8\"}],\"name\":\"setClientIdentRejectList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStart\",\"type\":\"uint256\"}],\"name\":\"setNewStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrerWallet\",\"type\":\"address\"}],\"name\":\"referral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"setTokenCollectable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isAllow\",\"type\":\"bool\"}],\"name\":\"enableContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCollectTokenStart\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAllowContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEnd\",\"type\":\"uint256\"}],\"name\":\"setNewEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"isClientIdentRejectedOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_contributorWallet\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recordOffChainContribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_basicTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timeBonusTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_volumeBonusTokenAmount\",\"type\":\"uint256\"}],\"name\":\"LogContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_bitcoinAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_basicTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timeBonusTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_volumeBonusTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_contributionDatetime\",\"type\":\"uint256\"}],\"name\":\"LogContributionBitcoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LogOffChainContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_refereeWallet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrerWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_referralBonusAmount\",\"type\":\"uint256\"}],\"name\":\"LogReferralAward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_collectedTokenAmount\",\"type\":\"uint256\"}],\"name\":\"LogTokenCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newValue\",\"type\":\"uint8\"}],\"name\":\"LogClientIdentRejectListChange\",\"type\":\"event\"}]","ContractName":"teuInitialTokenSale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://73540a5fdf2ce3721c686aea6c5216a4b741506deb29d594c844757d8a0b636f"}]}