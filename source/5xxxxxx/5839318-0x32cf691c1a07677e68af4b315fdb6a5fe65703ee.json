{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n *\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    // A hashmap to help keep track of list of all owners\r\n    mapping(address => uint) public allOwnersMap;\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n        allOwnersMap[msg.sender] = 1;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"You're not the owner!\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the all owners in the history of\r\n     * the smart contract.\r\n     */\r\n    modifier onlyAnyOwners() {\r\n        require(allOwnersMap[msg.sender] == 1, \"You're not the owner or never were the owner!\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n\r\n        // Keep track of list of owners\r\n        allOwnersMap[newOwner] = 1;\r\n    }\r\n\r\n\r\n    // transfer ownership event\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Suicidable\r\n *\r\n * @dev Suicidable is special contract with functions to suicide. This is a security measure added in\r\n * incase Bitwords gets hacked.\r\n */\r\ncontract Suicidable is Ownable {\r\n    bool public hasSuicided = false;\r\n\r\n\r\n    /**\r\n     * @dev Throws if called the contract has not yet suicided\r\n     */\r\n    modifier hasNotSuicided() {\r\n        require(hasSuicided == false, \"Contract has suicided!\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Suicides the entire smart contract\r\n     */\r\n    function suicideContract() public onlyAnyOwners {\r\n        hasSuicided = true;\r\n        emit SuicideContract(msg.sender);\r\n    }\r\n\r\n\r\n    // suicide contract event\r\n    event SuicideContract(address indexed owner);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Migratable\r\n *\r\n * @dev Migratable is special contract which allows the funds of a smart-contact to be migrated\r\n * to a new smart contract.\r\n */\r\ncontract Migratable is Suicidable {\r\n    bool public hasRequestedForMigration = false;\r\n    uint public requestedForMigrationAt = 0;\r\n    address public migrationDestination;\r\n\r\n    function() public payable {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for a migration request to be created, all migrations requests\r\n     * are timelocked by 7 days.\r\n     *\r\n     * @param destination   The destination to send the ether to.\r\n     */\r\n    function requestForMigration(address destination) public onlyOwner {\r\n        hasRequestedForMigration = true;\r\n        requestedForMigrationAt = now;\r\n        migrationDestination = destination;\r\n\r\n        emit MigrateFundsRequested(msg.sender, destination);\r\n    }\r\n\r\n    /**\r\n     * @dev Cancels a migration\r\n     */\r\n    function cancelMigration() public onlyOwner hasNotSuicided {\r\n        hasRequestedForMigration = false;\r\n        requestedForMigrationAt = 0;\r\n\r\n        emit MigrateFundsCancelled(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves a migration and suicides the entire smart contract\r\n     */\r\n    function approveMigration(uint gasCostInGwei) public onlyOwner hasNotSuicided {\r\n        require(hasRequestedForMigration, \"please make a migration request\");\r\n        require(requestedForMigrationAt + 604800 < now, \"migration is timelocked for 7 days\");\r\n        require(gasCostInGwei > 0, \"gas cost must be more than 0\");\r\n        require(gasCostInGwei < 20, \"gas cost can't be more than 20\");\r\n\r\n        // Figure out how much ether to send\r\n        uint gasLimit = 21000;\r\n        uint gasPrice = gasCostInGwei * 1000000000;\r\n        uint gasCost = gasLimit * gasPrice;\r\n        uint etherToSend = address(this).balance - gasCost;\r\n\r\n        require(etherToSend > 0, \"not enough balance in smart contract\");\r\n\r\n        // Send the funds to the new smart contract\r\n        emit MigrateFundsApproved(msg.sender, etherToSend);\r\n        migrationDestination.transfer(etherToSend);\r\n\r\n        // suicide the contract so that no more funds/actions can take place\r\n        suicideContract();\r\n    }\r\n\r\n    // events\r\n    event MigrateFundsCancelled(address indexed by);\r\n    event MigrateFundsRequested(address indexed by, address indexed newSmartContract);\r\n    event MigrateFundsApproved(address indexed by, uint amount);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Bitwords\r\n *\r\n * @dev The Bitwords smart contract that allows advertisers and publishers to\r\n * safetly deposit/receive ether and interact with the Bitwords platform.\r\n *\r\n * TODO:\r\n *  - timelock all chargeAdvertiser requests\r\n *  - if suicide is called, then all timelocked requests need to be stopped and then later reversed\r\n */\r\ncontract Bitwords is Migratable {\r\n    mapping(address => uint) public advertiserBalances;\r\n\r\n    // This mapping overrides the default bitwords cut for a specific publisher.\r\n    mapping(address => uint) public bitwordsCutOverride;\r\n\r\n    // The bitwords address, where all the 30% cut is received ETH\r\n    address public bitwordsWithdrawlAddress;\r\n\r\n    // How much cut out of 100 Bitwords takes. By default 10%\r\n    uint public bitwordsCutOutof100 = 10;\r\n\r\n    // To store the advertiserChargeRequests\r\n    // TODO: this needs to be used for the timelock\r\n    struct advertiserChargeRequest {\r\n        address advertiser;\r\n        address publisher;\r\n        uint amount;\r\n        uint requestedAt;\r\n        uint processAfter;\r\n    }\r\n\r\n    // How much days should each refund request be timelocked for\r\n    uint public refundRequestTimelock = 7 days;\r\n\r\n    // To store refund request\r\n    struct refundRequest {\r\n        address advertiser;\r\n        uint amount;\r\n        uint requestedAt;\r\n        uint processAfter;\r\n    }\r\n\r\n    // An array of all the refund requests submitted by advertisers.\r\n    refundRequest[] public refundQueue;\r\n\r\n    // variables that help track where in the refund loop we are in.\r\n    mapping(address => uint) private advertiserRefundRequestsIndex;\r\n    uint private lastProccessedIndex = 0;\r\n\r\n\r\n    /**\r\n     * @dev The Bitwords constructor sets the address where all the withdrawals will\r\n     * happen.\r\n     */\r\n    constructor () public {\r\n        bitwordsWithdrawlAddress = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Anybody who deposits ether to the smart contract will be considered as an\r\n     * advertiser and will get that much ether debitted into his account.\r\n     */\r\n    function() public payable {\r\n        advertiserBalances[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value, advertiserBalances[msg.sender]);\r\n    }\r\n\r\n    /**\r\n     * Used by the owner to set the withdrawal address for Bitwords. This address\r\n     * is where Bitwords will receive all the cut from the advertisements.\r\n     *\r\n     * @param newAddress    the new withdrawal address\r\n     */\r\n    function setBitwordsWithdrawlAddress (address newAddress) hasNotSuicided onlyOwner public {\r\n        bitwordsWithdrawlAddress = newAddress;\r\n\r\n        emit BitwordsWithdrawlAddressChanged(msg.sender, newAddress);\r\n    }\r\n\r\n    /**\r\n     * Change the cut that Bitwords takes.\r\n     *\r\n     * @param cut   the amount of cut that Bitwords takes.\r\n     */\r\n    function setBitwordsCut (uint cut) hasNotSuicided onlyOwner public {\r\n        require(cut <= 30, \"cut cannot be more than 30%\");\r\n        require(cut >= 0, \"cut should be greater than 0%\");\r\n        bitwordsCutOutof100 = cut;\r\n\r\n        emit BitwordsCutChanged(msg.sender, cut);\r\n    }\r\n\r\n    /**\r\n     * Set the new timelock for refund reuqests\r\n     *\r\n     * @param newTimelock   the new timelock\r\n     */\r\n    function setRefundTimelock (uint newTimelock) hasNotSuicided onlyOwner public {\r\n        require(newTimelock >= 0, \"timelock has to be greater than 0\");\r\n        refundRequestTimelock = newTimelock;\r\n\r\n        emit TimelockChanged(msg.sender, newTimelock);\r\n    }\r\n\r\n    /**\r\n     * Process all the refund requests in the queue. This is called by the Bitwords\r\n     * server ideally right after chargeAdvertisers has been called.\r\n     *\r\n     * This function will only process refunds that have passed it's timelock and\r\n     * it will only refund maximum to how much the advertiser currently has in\r\n     * his balance.\r\n     */\r\n    bool private inProcessRefunds = false;\r\n    function processRefunds () onlyAnyOwners public {\r\n        // prevent reentry bug\r\n        require(!inProcessRefunds, \"prevent reentry bug\");\r\n        inProcessRefunds = true;\r\n\r\n        for (uint j = lastProccessedIndex; j < refundQueue.length; j++) {\r\n            // If we haven't passed the timelock for this refund request, then\r\n            // we stop the loop. Reaching here means that all the requests\r\n            // in next iterations have also not reached their timelocks.\r\n            if (refundQueue[j].processAfter > now) break;\r\n\r\n            // Find the minimum that needs to be withdrawn. This is important\r\n            // because since every call to chargeAdvertisers might update the\r\n            // advertiser's balance, it is possible that the amount that the\r\n            // advertiser requests for is small.\r\n            uint cappedAmount = refundQueue[j].amount;\r\n            if (advertiserBalances[refundQueue[j].advertiser] < cappedAmount)\r\n                cappedAmount = advertiserBalances[refundQueue[j].advertiser];\r\n\r\n            // This refund is now invalid, skip it\r\n            if (cappedAmount <= 0) {\r\n                lastProccessedIndex++;\r\n                continue;\r\n            }\r\n\r\n            // deduct advertiser's balance and send the ether\r\n            advertiserBalances[refundQueue[j].advertiser] -= cappedAmount;\r\n            refundQueue[j].advertiser.transfer(cappedAmount);\r\n            refundQueue[j].amount = 0;\r\n\r\n            // Emit events\r\n            emit RefundAdvertiserProcessed(refundQueue[j].advertiser, cappedAmount, advertiserBalances[refundQueue[j].advertiser]);\r\n\r\n            // Increment the last proccessed index, effectively marking this\r\n            // refund request as completed.\r\n            lastProccessedIndex++;\r\n        }\r\n\r\n        inProcessRefunds = false;\r\n    }\r\n\r\n    /**\r\n     * Anybody can credit ether on behalf of an advertiser\r\n     *\r\n     * @param advertiser    The advertiser to credit ether to\r\n     */\r\n    function creditAdvertiser (address advertiser) hasNotSuicided public payable {\r\n        advertiserBalances[advertiser] += msg.value;\r\n        emit Deposit(advertiser, msg.value, advertiserBalances[msg.sender]);\r\n    }\r\n\r\n    /**\r\n     * Anybody can credit ether on behalf of an advertiser\r\n     *\r\n     * @param publisher    The address of the publisher\r\n     * @param cut          How much cut should be taken from this publisher\r\n     */\r\n    function setPublisherCut (address publisher, uint cut) hasNotSuicided onlyOwner public {\r\n        require(cut <= 30, \"cut cannot be more than 30%\");\r\n        require(cut >= 0, \"cut should be greater than 0%\");\r\n\r\n        bitwordsCutOverride[publisher] = cut;\r\n        emit SetPublisherCut(publisher, cut);\r\n    }\r\n\r\n    /**\r\n     * Charge the advertiser with whatever clicks have been served by the ad engine.\r\n     *\r\n     * @param advertisers           Array of address of the advertiser from whom we should debit ether\r\n     * @param costs                 Array of the cost to be paid to publisher by advertisers\r\n     * @param publishers            Array of address of the publisher from whom we should credit ether\r\n     * @param publishersToCredit    Array of indices of publishers that need to be credited than debited.\r\n     */\r\n    bool private inChargeAdvertisers = false;\r\n    function chargeAdvertisers (address[] advertisers, uint[] costs, address[] publishers, uint[] publishersToCredit) hasNotSuicided onlyOwner public {\r\n        // Prevent re-entry bug\r\n        require(!inChargeAdvertisers, \"avoid rentry bug\");\r\n        inChargeAdvertisers = true;\r\n\r\n        uint creditArrayIndex = 0;\r\n\r\n        for (uint i = 0; i < advertisers.length; i++) {\r\n            uint toWithdraw = costs[i];\r\n\r\n            // First check if all advertisers have enough balance and cap it if needed\r\n            if (advertiserBalances[advertisers[i]] <= 0) {\r\n                emit InsufficientBalance(advertisers[i], advertiserBalances[advertisers[i]], costs[i]);\r\n                continue;\r\n            }\r\n            if (advertiserBalances[advertisers[i]] < toWithdraw) toWithdraw = advertiserBalances[advertisers[i]];\r\n\r\n            // Update the advertiser's balance\r\n            advertiserBalances[advertisers[i]] -= toWithdraw;\r\n            emit DeductFromAdvertiser(advertisers[i], toWithdraw, advertiserBalances[advertisers[i]]);\r\n\r\n            // Calculate how much cut Bitwords should take\r\n            uint bitwordsCut = bitwordsCutOutof100;\r\n            if (bitwordsCutOverride[publishers[i]] > 0 && bitwordsCutOverride[publishers[i]] <= 30) {\r\n                bitwordsCut = bitwordsCutOverride[publishers[i]];\r\n            }\r\n\r\n            // Figure out how much should go to Bitwords and to the publishers.\r\n            uint publisherNetCut = toWithdraw * (100 - bitwordsCut) / 100;\r\n            uint bitwordsNetCut = toWithdraw - publisherNetCut;\r\n\r\n            // Send the ether to the publisher and to Bitwords\r\n            // Either decide to credit the ether as an advertiser\r\n            if (publishersToCredit.length > creditArrayIndex && publishersToCredit[creditArrayIndex] == i) {\r\n                creditArrayIndex++;\r\n                advertiserBalances[publishers[i]] += publisherNetCut;\r\n                emit CreditPublisher(publishers[i], publisherNetCut, advertisers[i], advertiserBalances[publishers[i]]);\r\n            } else { // or send it to the publisher.\r\n                publishers[i].transfer(publisherNetCut);\r\n                emit PayoutToPublisher(publishers[i], publisherNetCut, advertisers[i]);\r\n            }\r\n\r\n            // send bitwords it's cut\r\n            bitwordsWithdrawlAddress.transfer(bitwordsNetCut);\r\n            emit PayoutToBitwords(bitwordsWithdrawlAddress, bitwordsNetCut, advertisers[i]);\r\n        }\r\n\r\n        inChargeAdvertisers = false;\r\n    }\r\n\r\n    /**\r\n     * Called by Bitwords to manually refund an advertiser.\r\n     *\r\n     * @param advertiser    The advertiser address to be refunded\r\n     * @param amount        The amount the advertiser would like to withdraw\r\n     */\r\n    bool private inRefundAdvertiser = false;\r\n    function refundAdvertiser (address advertiser, uint amount) onlyAnyOwners public {\r\n        // Ensure that the advertiser has enough balance to refund the smart\r\n        // contract\r\n        require(amount > 0, \"Amount should be greater than 0\");\r\n        require(advertiserBalances[advertiser] > 0, \"Advertiser has no balance\");\r\n        require(advertiserBalances[advertiser] >= amount, \"Insufficient balance to refund\");\r\n\r\n        // Prevent re-entry bug\r\n        require(!inRefundAdvertiser, \"avoid rentry bug\");\r\n        inRefundAdvertiser = true;\r\n\r\n        // deduct balance and send the ether\r\n        advertiserBalances[advertiser] -= amount;\r\n        advertiser.transfer(amount);\r\n\r\n        // Emit events\r\n        emit RefundAdvertiserProcessed(advertiser, amount, advertiserBalances[advertiser]);\r\n\r\n        inRefundAdvertiser = false;\r\n    }\r\n\r\n    /**\r\n     * Called by Bitwords to invalidate a refund sent by an advertiser.\r\n     */\r\n    function invalidateAdvertiserRefund (uint refundIndex) hasNotSuicided onlyOwner public {\r\n        require(refundIndex >= 0, \"index should be greater than 0\");\r\n        require(refundQueue.length >=  refundIndex, \"index is out of bounds\");\r\n        refundQueue[refundIndex].amount = 0;\r\n\r\n        emit RefundAdvertiserCancelled(refundQueue[refundIndex].advertiser);\r\n    }\r\n\r\n    /**\r\n     * Called by an advertiser when he/she would like to make a refund request.\r\n     *\r\n     * @param amount    The amount the advertiser would like to withdraw\r\n     */\r\n    function requestForRefund (uint amount) public {\r\n        // Make sure that advertisers are requesting a refund for how much ever\r\n        // ether they have.\r\n        require(amount > 0, \"Amount should be greater than 0\");\r\n        require(advertiserBalances[msg.sender] > 0, \"You have no balance\");\r\n        require(advertiserBalances[msg.sender] >= amount, \"Insufficient balance to refund\");\r\n\r\n        // push the refund request in a refundQueue so that it can be processed\r\n        // later.\r\n        refundQueue.push(refundRequest(msg.sender, amount, now, now + refundRequestTimelock));\r\n\r\n        // Add the index into a hashmap for later use\r\n        advertiserRefundRequestsIndex[msg.sender] = refundQueue.length - 1;\r\n\r\n        // Emit events\r\n        emit RefundAdvertiserRequested(msg.sender, amount, refundQueue.length - 1);\r\n    }\r\n\r\n    /**\r\n     * Called by an advertiser when he/she wants to manually process a refund\r\n     * that he/she has requested for earlier.\r\n     *\r\n     * This function will first find a refund request, check if it's valid (as\r\n     * in, has it passed it's timelock?, is there enough balance? etc.) and\r\n     * then process it, updating the advertiser's balance along the way.\r\n     */\r\n    mapping(address => bool) private inProcessMyRefund;\r\n    function processMyRefund () public {\r\n        // Check if a refund request even exists for this advertiser?\r\n        require(advertiserRefundRequestsIndex[msg.sender] >= 0, \"no refund request found\");\r\n\r\n        // Get the refund request details\r\n        uint refundRequestIndex = advertiserRefundRequestsIndex[msg.sender];\r\n\r\n        // Check if the refund has been proccessed\r\n        require(refundQueue[refundRequestIndex].amount > 0, \"refund already proccessed\");\r\n\r\n        // Check if the advertiser has enough balance to request for this refund?\r\n        require(\r\n            advertiserBalances[msg.sender] >= refundQueue[refundRequestIndex].amount,\r\n            \"advertiser balance is low; refund amount is invalid.\"\r\n        );\r\n\r\n        // Check the timelock\r\n        require(\r\n            now > refundQueue[refundRequestIndex].processAfter,\r\n            \"timelock for this request has not passed\"\r\n        );\r\n\r\n        // Prevent reentry bug\r\n        require(!inProcessMyRefund[msg.sender], \"prevent re-entry bug\");\r\n        inProcessMyRefund[msg.sender] = true;\r\n\r\n        // Send the amount\r\n        uint amount = refundQueue[refundRequestIndex].amount;\r\n        msg.sender.transfer(amount);\r\n\r\n        // update the new balance and void this request.\r\n        refundQueue[refundRequestIndex].amount = 0;\r\n        advertiserBalances[msg.sender] -= amount;\r\n\r\n        // reset the reentry flag\r\n        inProcessMyRefund[msg.sender] = false;\r\n\r\n        // Emit events\r\n        emit SelfRefundAdvertiser(msg.sender, amount, advertiserBalances[msg.sender]);\r\n        emit RefundAdvertiserProcessed(msg.sender, amount, advertiserBalances[msg.sender]);\r\n    }\r\n\r\n    /** Events */\r\n    event BitwordsCutChanged(address indexed _to, uint _value);\r\n    event BitwordsWithdrawlAddressChanged(address indexed _to, address indexed _from);\r\n    event CreditPublisher(address indexed _to, uint _value, address indexed _from, uint _newBalance);\r\n    event DeductFromAdvertiser(address indexed _to, uint _value, uint _newBalance);\r\n    event Deposit(address indexed _to, uint _value, uint _newBalance);\r\n    event InsufficientBalance(address indexed _to, uint _balance, uint _valueToDeduct);\r\n    event PayoutToBitwords(address indexed _to, uint _value, address indexed _from);\r\n    event PayoutToPublisher(address indexed _to, uint _value, address indexed _from);\r\n    event RefundAdvertiserCancelled(address indexed _to);\r\n    event RefundAdvertiserProcessed(address indexed _to, uint _value, uint _newBalance);\r\n    event RefundAdvertiserRequested(address indexed _to, uint _value, uint requestIndex);\r\n    event SelfRefundAdvertiser(address indexed _to, uint _value, uint _newBalance);\r\n    event SetPublisherCut(address indexed _to, uint _value);\r\n    event TimelockChanged(address indexed _to, uint _value);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"refundRequestTimelock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allOwnersMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"advertiser\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"refundAdvertiser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bitwordsCutOverride\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"suicideContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"refundIndex\",\"type\":\"uint256\"}],\"name\":\"invalidateAdvertiserRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"processMyRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setBitwordsWithdrawlAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasRequestedForMigration\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasSuicided\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"publisher\",\"type\":\"address\"},{\"name\":\"cut\",\"type\":\"uint256\"}],\"name\":\"setPublisherCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasCostInGwei\",\"type\":\"uint256\"}],\"name\":\"approveMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"advertisers\",\"type\":\"address[]\"},{\"name\":\"costs\",\"type\":\"uint256[]\"},{\"name\":\"publishers\",\"type\":\"address[]\"},{\"name\":\"publishersToCredit\",\"type\":\"uint256[]\"}],\"name\":\"chargeAdvertisers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"advertiser\",\"type\":\"address\"}],\"name\":\"creditAdvertiser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"processRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestForRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"requestForMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bitwordsWithdrawlAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bitwordsCutOutof100\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cut\",\"type\":\"uint256\"}],\"name\":\"setBitwordsCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"advertiserBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTimelock\",\"type\":\"uint256\"}],\"name\":\"setRefundTimelock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestedForMigrationAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refundQueue\",\"outputs\":[{\"name\":\"advertiser\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"requestedAt\",\"type\":\"uint256\"},{\"name\":\"processAfter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"BitwordsCutChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"BitwordsWithdrawlAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"CreditPublisher\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"DeductFromAdvertiser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_valueToDeduct\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"PayoutToBitwords\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"PayoutToPublisher\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"RefundAdvertiserCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"RefundAdvertiserProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"RefundAdvertiserRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"SelfRefundAdvertiser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"SetPublisherCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TimelockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"MigrateFundsCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newSmartContract\",\"type\":\"address\"}],\"name\":\"MigrateFundsRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MigrateFundsApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SuicideContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Bitwords","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5467620e605803c796726564d16ca4b153a348aac6204e86940051f8ac638ebd"}]}