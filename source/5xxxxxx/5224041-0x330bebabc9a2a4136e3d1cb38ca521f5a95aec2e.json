{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallReceiver {\r\n    function receiveApproval(\r\n        address _from, \r\n        uint256 _amount, \r\n        address _token, \r\n        bytes _data\r\n    ) public;\r\n}\r\n\r\n//normal contract. already compiled as bin\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { \r\n        require(msg.sender == controller); \r\n        _; \r\n    }\r\n\r\n    //block for check//bool private initialed = false;\r\n    address public controller;\r\n\r\n    function Controlled() public {\r\n      //block for check//require(!initialed);\r\n      controller = msg.sender;\r\n      //block for check//initialed = true;\r\n    }\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController public {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n//abstract contract. used for interface\r\ncontract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable public returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\r\n}\r\n\r\ncontract ERC20Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n      function totalSupply() constant returns (uint256 supply);\r\n      is replaced with:\r\n      uint256 public totalSupply;\r\n      This automatically creates a getter function for the totalSupply.\r\n      This is moved to the base contract since public getter functions are not\r\n      currently recognised as an implementation of the matching abstract\r\n      function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n    //function totalSupply() public constant returns (uint256 balance);\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    mapping (address => uint256) public balanceOf;\r\n    //function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    //function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract TokenI is ERC20Token, Controlled {\r\n\r\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             //Number of decimals of the smallest unit\r\n    string public symbol;              //An identifier: e.g. REP\r\n\r\n\r\n    // ERC20 Methods\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(\r\n        address _spender,\r\n        uint256 _amount,\r\n        bytes _extraData\r\n    ) public returns (bool success);\r\n\r\n\r\n    // Generate and destroy tokens\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount) public returns (bool);\r\n\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount) public returns (bool);\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) public;\r\n\r\n\r\n    // Safety Methods\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public;\r\n\r\n\r\n    // Events\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n}\r\n\r\ncontract Token is TokenI {\r\n    using SafeMath for uint256;\r\n\r\n    string public techProvider = \"WeYii Tech\";\r\n    string public officialSite = \"http://www.beautybloc.io\";\r\n\r\n    address public owner;\r\n\r\n    struct FreezeInfo {\r\n        address user;\r\n        uint256 amount;\r\n    }\r\n    //Key1: step(募资阶段); Key2: user sequence(用户序列)\r\n    mapping (uint8 => mapping (uint8 => FreezeInfo)) public freezeOf; //所有锁仓，key 使用序号向上增加，方便程序查询。\r\n    mapping (uint8 => uint8) public lastFreezeSeq; //最后的 freezeOf 键值。key: step; value: sequence\r\n    mapping (uint8 => uint8) internal unlockTime;\r\n\r\n    bool public transfersEnabled;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    //event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /* This notifies clients about the amount burnt */\r\n    event Burn(address indexed from, uint256 value);\r\n    \r\n    /* This notifies clients about the amount frozen */\r\n    event Freeze(address indexed from, uint256 value);\r\n    \r\n    /* This notifies clients about the amount unfrozen */\r\n    event Unfreeze(address indexed from, uint256 value);\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function Token(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transfersEnable\r\n        ) public {\r\n        balanceOf[msg.sender] = initialSupply;\r\n        totalSupply = initialSupply;\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = decimalUnits;\r\n        transfersEnabled = transfersEnable;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier ownerOrController() {\r\n        require(msg.sender == owner || msg.sender == controller);\r\n        _;\r\n    }\r\n\r\n    modifier ownerOrUser(address user){\r\n        require(msg.sender == owner || msg.sender == user);\r\n        _;\r\n    }\r\n\r\n    modifier realUser(address user){\r\n        if(user == 0x0){\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier moreThanZero(uint256 _value){\r\n        if (_value <= 0){\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier moreOrEqualZero(uint256 _value){\r\n        if(_value < 0){\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) {\r\n            return false;\r\n        }\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) realUser(_to) moreThanZero(_value) public returns (bool) {\r\n        //infoAddr('msg.sender', msg.sender);\r\n        //infoBool('typeOf msg.sender', isContract(msg.sender));\r\n        require(balanceOf[msg.sender] >= _value);           // Check if the sender has enough\r\n        require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;                     // Subtract from the sender\r\n        balanceOf[_to] = balanceOf[_to] + _value;                            // Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\r\n        return true;\r\n    }\r\n\r\n    /* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value) moreThanZero(_value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n     *  its behalf, and then a function is triggered in the contract that is\r\n     *  being approved, `_spender`. This allows users to use their tokens to\r\n     *  interact with contracts in one function call instead of two\r\n     * @param _spender The address of the contract able to transfer the tokens\r\n     * @param _amount The amount of tokens to be approved for transfer\r\n     * @return True if the function call was successful\r\n     */\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\r\n        require(approve(_spender, _amount));\r\n\r\n        ApproveAndCallReceiver(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) realUser(_from) realUser(_to) moreThanZero(_value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                 // Check if the sender has enough\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);  // Check for overflows\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        balanceOf[_from] = balanceOf[_from] - _value;                           // Subtract from the sender\r\n        balanceOf[_to] = balanceOf[_to] + _value;                             // Add the same to the recipient\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender] + _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function transferMulti(address[] _to, uint256[] _value) public returns (uint256 amount){\r\n        require(_to.length == _value.length);\r\n        uint8 len = uint8(_to.length);\r\n        for(uint8 j; j<len; j++){\r\n            amount += _value[j];\r\n        }\r\n        require(balanceOf[msg.sender] >= amount);\r\n        for(uint8 i; i<len; i++){\r\n            address _toI = _to[i];\r\n            uint256 _valueI = _value[i];\r\n            balanceOf[_toI] += _valueI;\r\n            balanceOf[msg.sender] -= _valueI;\r\n            Transfer(msg.sender, _toI, _valueI);\r\n        }\r\n    }\r\n    \r\n    //只能自己或者 owner 才能冻结账户\r\n    function freeze(address _user, uint256 _value, uint8 _step) moreThanZero(_value) onlyController public returns (bool success) {\r\n        //info256(\"balanceOf[_user]\", balanceOf[_user]);\r\n        require(balanceOf[_user] >= _value);\r\n        balanceOf[_user] = balanceOf[_user] - _value;\r\n        freezeOf[_step][lastFreezeSeq[_step]] = FreezeInfo({user:_user, amount:_value});\r\n        lastFreezeSeq[_step]++;\r\n        Freeze(_user, _value);\r\n        return true;\r\n    }\r\n\r\n    event infoBool(string name, bool value);\r\n    event infoAddr(string name, address addr);\r\n    event info(string name, uint8 value);\r\n    event info256(string name, uint256 value);\r\n    \r\n    //为用户解锁账户资金\r\n    function unFreeze(uint8 _step) onlyOwner public returns (bool unlockOver) {\r\n        //_end = length of freezeOf[_step]\r\n        uint8 _end = lastFreezeSeq[_step];\r\n        require(_end > 0);\r\n        //info(\"_end\", _end);\r\n        unlockOver = (_end <= 99);\r\n        uint8 _start = (_end > 99) ? _end-100 : 0;\r\n        //info(\"_start\", _start);\r\n        for(; _end>_start; _end--){\r\n            FreezeInfo storage fInfo = freezeOf[_step][_end-1];\r\n            uint256 _amount = fInfo.amount;\r\n            balanceOf[fInfo.user] += _amount;\r\n            delete freezeOf[_step][_end-1];\r\n            lastFreezeSeq[_step]--;\r\n            Unfreeze(fInfo.user, _amount);\r\n        }\r\n    }\r\n    \r\n    //accept ether\r\n    function() payable public {\r\n        //屏蔽控制方的合约类型检查，以兼容发行方无控制合约的情况。\r\n        require(isContract(controller));\r\n        bool proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender);\r\n        require(proxyPayment);\r\n    }\r\n\r\n    ////////////////\r\n    // Generate and destroy tokens\r\n    ////////////////\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _user The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _user, uint _amount) onlyController public returns (bool) {\r\n        require(balanceOf[owner] >= _amount);\r\n        balanceOf[_user] += _amount;\r\n        balanceOf[owner] -= _amount;\r\n        Transfer(0, _user, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _user The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _user, uint _amount) onlyOwner public returns (bool) {\r\n        require(balanceOf[_user] >= _amount);\r\n        balanceOf[owner] += _amount;\r\n        balanceOf[_user] -= _amount;\r\n        Transfer(_user, 0, _amount);\r\n        Burn(_user, _amount);\r\n        return true;\r\n    }\r\n\r\n    ////////////////\r\n    // Enable tokens transfers\r\n    ////////////////\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) onlyOwner public {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n    //////////\r\n    // Safety Methods\r\n    //////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyController public {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        Token token = Token(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n    function changeOwner(address newOwner) onlyOwner public returns (bool) {\r\n        balanceOf[newOwner] += balanceOf[owner];\r\n        balanceOf[owner] = 0;\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n}\r\ncontract KoreaShow is TokenController, Controlled {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public startFundingTime;\r\n    uint256 public endFundingTime;\r\n    \r\n    uint256 constant public maximumFunding = 100 ether;\r\n    uint256 public tokensPerEther = 31000;\r\n    uint256 constant oneDay = 86400;\r\n    uint256 public totalCollected = 0;\r\n    bool    public paused;\r\n    string  public techProvider = \"WeYii Tech\";\r\n    Token   public tokenContract;\r\n    bool    public finalized = false;\r\n    bool    public allowChange = true;\r\n    bool    private transfersEnabled = true;\r\n    address private vaultAddress;\r\n\r\n    bool private initialed = false;\r\n\r\n    event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount);\r\n\r\n    /**\r\n     * @param _startFundingTime The UNIX time that the PreTokenSale will be able to start receiving funds\r\n     * @param _endFundingTime   The UNIX time that the PreTokenSale will stop being able to receive funds\r\n     * @param _vaultAddress     The address that will store the donated funds\r\n     * @param _tokenAddress     Address of the token contract this contract controls\r\n     */\r\n    function KoreaShow(\r\n        uint _startFundingTime, \r\n        uint _endFundingTime, \r\n        address _vaultAddress,\r\n        address _tokenAddress\r\n    ) public {\r\n        require(_endFundingTime > now);\r\n        require(_endFundingTime >= _startFundingTime);\r\n        require(_vaultAddress != 0);\r\n        require(_tokenAddress != 0);\r\n        require(!initialed);\r\n\r\n        startFundingTime = _startFundingTime;\r\n        endFundingTime = _endFundingTime;\r\n        vaultAddress = _vaultAddress;\r\n        tokenContract = Token(_tokenAddress);\r\n        paused = false;\r\n        initialed = true;\r\n    }\r\n\r\n\r\n    function setTime(uint time1, uint time2) onlyController public {\r\n        require(endFundingTime > now && startFundingTime < endFundingTime);\r\n        startFundingTime = time1;\r\n        endFundingTime = time2;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev The fallback function is called when ether is sent to the contract, it simply calls `doPayment()` with the address that sent the ether as the `_owner`. Payable is a required solidity modifier for functions to receive ether, without this modifier functions will throw if ether is sent to them\r\n     */\r\n    function () payable notPaused public {\r\n        doPayment(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice `proxyPayment()` allows the caller to send ether to the PreTokenSale and have the tokens created in an address of their choosing\r\n     * @param _owner The address that will hold the newly created tokens\r\n     */\r\n    function proxyPayment(address _owner) payable notPaused public returns(bool success) {\r\n        return doPayment(_owner);\r\n    }\r\n\r\n    /**\r\n    * @notice Notifies the controller about a transfer, for this PreTokenSale all transfers are allowed by default and no extra notifications are needed\r\n    * @param _from The origin of the transfer\r\n    * @param _to The destination of the transfer\r\n    * @param _amount The amount of the transfer\r\n    * @return False if the controller does not authorize the transfer\r\n    */\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool success) {\r\n        if ( _from == vaultAddress || transfersEnabled) {\r\n            return true;\r\n        }\r\n        _to;\r\n        _amount;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Notifies the controller about an approval, for this PreTokenSale all\r\n     * approvals are allowed by default and no extra notifications are needed\r\n     * @param _owner The address that calls `approve()`\r\n     * @param _spender The spender in the `approve()` call\r\n     * @param _amount The amount in the `approve()` call\r\n     * @return False if the controller does not authorize the approval\r\n     */\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool success) {\r\n        if ( _owner == vaultAddress ) {\r\n            return true;\r\n        }\r\n        _spender;\r\n        _amount;\r\n        return false;\r\n    }\r\n\r\n    event info(string name, string msg);\r\n    event info256(string name, uint256 value);\r\n\r\n    /// @dev `doPayment()` is an internal function that sends the ether that this\r\n    ///  contract receives to the `vault` and creates tokens in the address of the\r\n    ///  `_owner` assuming the PreTokenSale is still accepting funds\r\n    /// @param _owner The address that will hold the newly created tokens\r\n    function doPayment(address _owner) internal returns(bool success) {\r\n        //info(\"step\", \"enter doPayment\");\r\n        require(msg.value >= 1 ether && msg.value <=3 ether);\r\n        require(endFundingTime > now);\r\n\r\n        // Track how much the PreTokenSale has collected\r\n        require(totalCollected < maximumFunding);\r\n        totalCollected = totalCollected.add(msg.value);\r\n\r\n        //Send the ether to the vault\r\n        require(vaultAddress.send(msg.value));\r\n        \r\n        uint256 tokenValue = tokensPerEther.mul(msg.value);\r\n        // Creates an equal amount of tokens as ether sent. The new tokens are created in the `_owner` address\r\n        require(tokenContract.generateTokens(_owner, tokenValue));\r\n        Payment(_owner, msg.value, tokenValue);\r\n        return true;\r\n    }\r\n\r\n    function changeTokenController(address _newController) onlyController public {\r\n        tokenContract.changeController(_newController);\r\n    }\r\n\r\n    /**\r\n     * 修改所控 Token 合约\r\n     */\r\n    function changeToken(address _newToken) onlyController public {\r\n        tokenContract = Token(_newToken);\r\n    }\r\n\r\n    /**\r\n     * 修改TNB兑换比率\r\n     */\r\n    function changeTokensPerEther(uint256 _newRate) onlyController public {\r\n        require(allowChange);\r\n        tokensPerEther = _newRate;\r\n    }\r\n\r\n    /**\r\n     * 允许普通用户转账\r\n     */\r\n    function allowTransfersEnabled(bool _allow) onlyController public {\r\n        transfersEnabled = _allow;\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns (bool) {\r\n        if (_addr == 0) {\r\n            return false;\r\n        }\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    /// @notice `finalizeSale()` ends the PreTokenSale. It will generate the platform and team tokens\r\n    ///  and set the controller to the referral fee contract.\r\n    /// @dev `finalizeSale()` can only be called after the end of the funding period or if the maximum amount is raised.\r\n    function finalizeSale() onlyController public {\r\n        require(now > endFundingTime || totalCollected >= maximumFunding);\r\n        require(!finalized);\r\n\r\n        //20000 TNB/ETH and 90 percent discount\r\n        uint256 totalTokens = totalCollected * tokensPerEther * 10**18;\r\n        if (!tokenContract.generateTokens(vaultAddress, totalTokens)) {\r\n            revert();\r\n        }\r\n\r\n        finalized = true;\r\n        allowChange = false;\r\n    }\r\n\r\n    //////////\r\n    // Safety Methods\r\n    //////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyController public {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n\r\n    /// @notice Pauses the contribution if there is any issue\r\n    function pauseContribution() onlyController public {\r\n        paused = true;\r\n    }\r\n\r\n    /// @notice Resumes the contribution\r\n    function resumeContribution() onlyController public {\r\n        paused = false;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"techProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"changeTokensPerEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newToken\",\"type\":\"address\"}],\"name\":\"changeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time1\",\"type\":\"uint256\"},{\"name\":\"time2\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startFundingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowChange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeTokenController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onApprove\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endFundingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"allowTransfersEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"proxyPayment\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startFundingTime\",\"type\":\"uint256\"},{\"name\":\"_endFundingTime\",\"type\":\"uint256\"},{\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"info\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"info256\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"}]","ContractName":"KoreaShow","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000016221ce70000000000000000000000000000000000000000000000000000000016228ac4000000000000000000000000000e9e8296e7cfb3881fa5e5d1d38d03ec11087ff63000000000000000000000000b5a1df09ccaa8197d54839c2c9175ec32b560151","Library":"","SwarmSource":"bzzr://41a6f8063b05b013cc4c4515d80449c4e5db847fe8b143e396eae37cc080de07"}]}