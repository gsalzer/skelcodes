{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract CardsAccess {\r\n  address autoAddress;\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  function CardsAccess() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function setAutoAddress(address _address) external onlyOwner {\r\n    require(_address != address(0));\r\n    autoAddress = _address;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAuto() {\r\n    require(msg.sender == autoAddress);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ninterface CardsInterface {\r\n    function getJadeProduction(address player) external constant returns (uint256);\r\n    function getUpgradeValue(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external view returns (uint256);\r\n    function getGameStarted() external constant returns (bool);\r\n    function balanceOf(address player) external constant returns(uint256);\r\n    function balanceOfUnclaimed(address player) external constant returns (uint256);\r\n    function coinBalanceOf(address player,uint8 itype) external constant returns(uint256);\r\n\r\n    function setCoinBalance(address player, uint256 eth, uint8 itype, bool iflag) external;\r\n    function setJadeCoin(address player, uint256 coin, bool iflag) external;\r\n    function setJadeCoinZero(address player) external;\r\n\r\n    function setLastJadeSaveTime(address player) external;\r\n    function setRoughSupply(uint256 iroughSupply) external;\r\n\r\n    function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) external;\r\n    function updatePlayersCoinByOut(address player) external;\r\n\r\n    function increasePlayersJadeProduction(address player, uint256 increase) external;\r\n    function reducePlayersJadeProduction(address player, uint256 decrease) external;\r\n\r\n    function getUintsOwnerCount(address _address) external view returns (uint256);\r\n    function setUintsOwnerCount(address _address, uint256 amount, bool iflag) external;\r\n\r\n    function getOwnedCount(address player, uint256 cardId) external view returns (uint256);\r\n    function setOwnedCount(address player, uint256 cardId, uint256 amount, bool iflag) external;\r\n\r\n    function getUpgradesOwned(address player, uint256 upgradeId) external view returns (uint256);\r\n    function setUpgradesOwned(address player, uint256 upgradeId) external;\r\n    \r\n    function getTotalEtherPool(uint8 itype) external view returns (uint256);\r\n    function setTotalEtherPool(uint256 inEth, uint8 itype, bool iflag) external;\r\n\r\n    function setNextSnapshotTime(uint256 iTime) external;\r\n    function getNextSnapshotTime() external view;\r\n\r\n    function AddPlayers(address _address) external;\r\n    function getTotalUsers()  external view returns (uint256);\r\n    function getRanking() external view returns (address[] addr, uint256[] _arr);\r\n    function getAttackRanking() external view returns (address[] addr, uint256[] _arr);\r\n\r\n    function getUnitsProduction(address player, uint256 cardId, uint256 amount) external constant returns (uint256);\r\n\r\n    function getUnitCoinProductionIncreases(address _address, uint256 cardId) external view returns (uint256);\r\n    function setUnitCoinProductionIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n    function getUnitCoinProductionMultiplier(address _address, uint256 cardId) external view returns (uint256);\r\n    function setUnitCoinProductionMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n    function setUnitAttackIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n    function setUnitAttackMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n    function setUnitDefenseIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n    function setunitDefenseMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n    \r\n    function setUnitJadeStealingIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n    function setUnitJadeStealingMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n\r\n    function setUintCoinProduction(address _address, uint256 cardId, uint256 iValue,bool iflag) external;\r\n    function getUintCoinProduction(address _address, uint256 cardId) external returns (uint256);\r\n\r\n    function getUnitsInProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256);\r\n    function getPlayersBattleStats(address player) public constant returns (\r\n    uint256 attackingPower, \r\n    uint256 defendingPower, \r\n    uint256 stealingPower,\r\n    uint256 battlePower); \r\n}\r\n\r\n\r\ninterface GameConfigInterface {\r\n  function getMaxCAP() external returns (uint256);\r\n  function unitCoinProduction(uint256 cardId) external constant returns (uint256);\r\n  function getCostForCards(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256);\r\n  function getUpgradeCardsInfo(uint256 upgradecardId,uint256 existing) external constant returns (\r\n    uint256 coinCost, \r\n    uint256 ethCost, \r\n    uint256 upgradeClass, \r\n    uint256 cardId, \r\n    uint256 upgradeValue,\r\n    uint256 platCost\r\n  );\r\n function getCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256, bool);\r\n function getBattleCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, bool);\r\n  \r\n}\r\n\r\ninterface RareInterface {\r\n  function getRareItemsOwner(uint256 rareId) external view returns (address);\r\n  function getRareItemsPrice(uint256 rareId) external view returns (uint256);\r\n    function getRareInfo(uint256 _tokenId) external view returns (\r\n    uint256 sellingPrice,\r\n    address owner,\r\n    uint256 nextPrice,\r\n    uint256 rareClass,\r\n    uint256 cardId,\r\n    uint256 rareValue\r\n  ); \r\n  function transferToken(address _from, address _to, uint256 _tokenId) external;\r\n  function transferTokenByContract(uint256 _tokenId,address _to) external;\r\n  function setRarePrice(uint256 _rareId, uint256 _price) external;\r\n  function rareStartPrice() external view returns (uint256);\r\n}\r\n\r\ncontract CardsHelper is CardsAccess {\r\n  //data contract\r\n  CardsInterface public cards ;\r\n  GameConfigInterface public schema;\r\n  RareInterface public rare;\r\n\r\n  function setCardsAddress(address _address) external onlyOwner {\r\n    cards = CardsInterface(_address);\r\n  }\r\n\r\n   //normal cards\r\n  function setConfigAddress(address _address) external onlyOwner {\r\n    schema = GameConfigInterface(_address);\r\n  }\r\n\r\n  //rare cards\r\n  function setRareAddress(address _address) external onlyOwner {\r\n    rare = RareInterface(_address);\r\n  }\r\n\r\n  function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\r\n    uint256 productionGain;\r\n    if (upgradeClass == 0) {\r\n      cards.setUnitCoinProductionIncreases(player, unitId, upgradeValue,true);\r\n      productionGain = (cards.getOwnedCount(player,unitId) * upgradeValue * (10 + cards.getUnitCoinProductionMultiplier(player,unitId)));\r\n      cards.setUintCoinProduction(player,unitId,productionGain,true); \r\n      cards.increasePlayersJadeProduction(player,productionGain);\r\n    } else if (upgradeClass == 1) {\r\n      cards.setUnitCoinProductionMultiplier(player,unitId,upgradeValue,true);\r\n      productionGain = (cards.getOwnedCount(player,unitId) * upgradeValue * (schema.unitCoinProduction(unitId) + cards.getUnitCoinProductionIncreases(player,unitId)));\r\n      cards.setUintCoinProduction(player,unitId,productionGain,true);\r\n      cards.increasePlayersJadeProduction(player,productionGain);\r\n    } else if (upgradeClass == 2) {\r\n      cards.setUnitAttackIncreases(player,unitId,upgradeValue,true);\r\n    } else if (upgradeClass == 3) {\r\n      cards.setUnitAttackMultiplier(player,unitId,upgradeValue,true);\r\n    } else if (upgradeClass == 4) {\r\n      cards.setUnitDefenseIncreases(player,unitId,upgradeValue,true);\r\n    } else if (upgradeClass == 5) {\r\n      cards.setunitDefenseMultiplier(player,unitId,upgradeValue,true);\r\n    } else if (upgradeClass == 6) {\r\n      cards.setUnitJadeStealingIncreases(player,unitId,upgradeValue,true);\r\n    } else if (upgradeClass == 7) {\r\n      cards.setUnitJadeStealingMultiplier(player,unitId,upgradeValue,true);\r\n    }\r\n  }\r\n\r\n  function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\r\n    uint256 productionLoss;\r\n    if (upgradeClass == 0) {\r\n      cards.setUnitCoinProductionIncreases(player, unitId, upgradeValue,false);\r\n      productionLoss = (cards.getOwnedCount(player,unitId) * upgradeValue * (10 + cards.getUnitCoinProductionMultiplier(player,unitId)));\r\n      cards.setUintCoinProduction(player,unitId,productionLoss,false); \r\n      cards.reducePlayersJadeProduction(player, productionLoss);\r\n    } else if (upgradeClass == 1) {\r\n      cards.setUnitCoinProductionMultiplier(player,unitId,upgradeValue,false);\r\n      productionLoss = (cards.getOwnedCount(player,unitId) * upgradeValue * (schema.unitCoinProduction(unitId) + cards.getUnitCoinProductionIncreases(player,unitId)));\r\n      cards.setUintCoinProduction(player,unitId,productionLoss,false); \r\n      cards.reducePlayersJadeProduction(player, productionLoss);\r\n    } else if (upgradeClass == 2) {\r\n      cards.setUnitAttackIncreases(player,unitId,upgradeValue,false);\r\n    } else if (upgradeClass == 3) {\r\n      cards.setUnitAttackMultiplier(player,unitId,upgradeValue,false);\r\n    } else if (upgradeClass == 4) {\r\n      cards.setUnitDefenseIncreases(player,unitId,upgradeValue,false);\r\n    } else if (upgradeClass == 5) {\r\n      cards.setunitDefenseMultiplier(player,unitId,upgradeValue,false);\r\n    } else if (upgradeClass == 6) { \r\n      cards.setUnitJadeStealingIncreases(player,unitId,upgradeValue,false);\r\n    } else if (upgradeClass == 7) {\r\n      cards.setUnitJadeStealingMultiplier(player,unitId,upgradeValue,false);\r\n    }\r\n  }\r\n}\r\n\r\ncontract CardsTrade is CardsHelper {\r\n   // Minor game events\r\n  event UnitBought(address player, uint256 unitId, uint256 amount);\r\n  event UpgradeCardBought(address player, uint256 upgradeId);\r\n  event BuyRareCard(address player, address previous, uint256 rareId,uint256 iPrice);\r\n  event UnitSold(address player, uint256 unitId, uint256 amount);\r\n\r\n  mapping(address => mapping(uint256 => uint256)) unitsOwnedOfEth; //cards bought through ether\r\n\r\n  function() external payable {\r\n    cards.setTotalEtherPool(msg.value,0,true);\r\n  }\r\n  \r\n  /// @notice invite \r\n  function sendGiftCard(address _address) external onlyAuto {\r\n    uint256 existing = cards.getOwnedCount(_address,1);\r\n    require(existing < schema.getMaxCAP());\r\n    require(SafeMath.add(existing,1) <= schema.getMaxCAP());\r\n\r\n    // Update players jade\r\n    cards.updatePlayersCoinByPurchase(_address, 0);\r\n        \r\n    if (schema.unitCoinProduction(1) > 0) {\r\n      cards.increasePlayersJadeProduction(_address,cards.getUnitsProduction(_address, 1, 1)); \r\n      cards.setUintCoinProduction(_address,1,cards.getUnitsProduction(_address, 1, 1),true); \r\n    }\r\n    //players\r\n    if (cards.getUintsOwnerCount(_address) <= 0) {\r\n      cards.AddPlayers(_address);\r\n    }\r\n    cards.setUintsOwnerCount(_address,1,true);\r\n  \r\n    cards.setOwnedCount(_address,1,1,true);\r\n    UnitBought(_address, 1, 1);\r\n  } \r\n  \r\n  /// buy normal cards with jade\r\n  function buyBasicCards(uint256 unitId, uint256 amount) external {\r\n    require(cards.getGameStarted());\r\n    require(amount>=1);\r\n    uint256 existing = cards.getOwnedCount(msg.sender,unitId);\r\n    uint256 iAmount;\r\n    require(existing < schema.getMaxCAP());\r\n    if (SafeMath.add(existing, amount) > schema.getMaxCAP()) {\r\n      iAmount = SafeMath.sub(schema.getMaxCAP(),existing);\r\n    } else {\r\n      iAmount = amount;\r\n    }\r\n    uint256 coinProduction;\r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    if (unitId>=1 && unitId<=39) {    \r\n      (, coinProduction, coinCost, ethCost,) = schema.getCardInfo(unitId, existing, iAmount);\r\n    } else if (unitId>=40) {\r\n      (, coinCost, ethCost,) = schema.getBattleCardInfo(unitId, existing, iAmount);\r\n    }\r\n    require(cards.balanceOf(msg.sender) >= coinCost);\r\n    require(ethCost == 0); // Free ether unit\r\n        \r\n    // Update players jade \r\n    cards.updatePlayersCoinByPurchase(msg.sender, coinCost);\r\n    ///****increase production***/\r\n    if (coinProduction > 0) {\r\n      cards.increasePlayersJadeProduction(msg.sender,cards.getUnitsProduction(msg.sender, unitId, iAmount)); \r\n      cards.setUintCoinProduction(msg.sender,unitId,cards.getUnitsProduction(msg.sender, unitId, iAmount),true); \r\n    }\r\n    //players\r\n    if (cards.getUintsOwnerCount(msg.sender)<=0) {\r\n      cards.AddPlayers(msg.sender);\r\n    }\r\n    cards.setUintsOwnerCount(msg.sender,iAmount,true);\r\n    cards.setOwnedCount(msg.sender,unitId,iAmount,true);\r\n    \r\n    UnitBought(msg.sender, unitId, iAmount);\r\n  }\r\n\r\n  /// buy cards with ether\r\n  function buyEthCards(uint256 unitId, uint256 amount) external payable {\r\n    require(cards.getGameStarted());\r\n    require(amount>=1);\r\n    uint256 existing = cards.getOwnedCount(msg.sender,unitId);\r\n    require(existing < schema.getMaxCAP());    \r\n    \r\n    uint256 iAmount;\r\n    if (SafeMath.add(existing, amount) > schema.getMaxCAP()) {\r\n      iAmount = SafeMath.sub(schema.getMaxCAP(),existing);\r\n    } else {\r\n      iAmount = amount;\r\n    }\r\n    uint256 coinProduction;\r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    if (unitId>=1 && unitId<=39) {\r\n      (,coinProduction, coinCost, ethCost,) = schema.getCardInfo(unitId, existing, iAmount);\r\n    } else if (unitId>=40){\r\n      (,coinCost, ethCost,) = schema.getBattleCardInfo(unitId, existing, iAmount);\r\n    }\r\n    \r\n    require(ethCost>0);\r\n    require(SafeMath.add(cards.coinBalanceOf(msg.sender,0),msg.value) >= ethCost);\r\n    require(cards.balanceOf(msg.sender) >= coinCost);  \r\n\r\n    // Update players jade  \r\n    cards.updatePlayersCoinByPurchase(msg.sender, coinCost);\r\n\r\n    if (ethCost > msg.value) {\r\n      cards.setCoinBalance(msg.sender,SafeMath.sub(ethCost,msg.value),0,false);\r\n    } else if (msg.value > ethCost) {\r\n      // Store overbid in their balance\r\n      cards.setCoinBalance(msg.sender,SafeMath.sub(msg.value,ethCost),0,true);\r\n    } \r\n\r\n    uint256 devFund = uint256(SafeMath.div(ethCost,20)); // 5% defund\r\n    cards.setTotalEtherPool(uint256(SafeMath.div(ethCost,4)),0,true);  // 25% go to pool\r\n    cards.setCoinBalance(owner,devFund,0,true);  \r\n  \r\n    //check procution   \r\n    if (coinProduction > 0) {\r\n      cards.increasePlayersJadeProduction(msg.sender, cards.getUnitsProduction(msg.sender, unitId, iAmount)); // increase procuction\r\n      cards.setUintCoinProduction(msg.sender,unitId,cards.getUnitsProduction(msg.sender, unitId, iAmount),true); \r\n    }\r\n    //players\r\n    if (cards.getUintsOwnerCount(msg.sender)<=0) {\r\n      cards.AddPlayers(msg.sender);\r\n    }\r\n    cards.setUintsOwnerCount(msg.sender,iAmount,true);\r\n    cards.setOwnedCount(msg.sender,unitId,iAmount,true);\r\n    unitsOwnedOfEth[msg.sender][unitId] = SafeMath.add(unitsOwnedOfEth[msg.sender][unitId],iAmount);\r\n    UnitBought(msg.sender, unitId, iAmount);\r\n  }\r\n\r\n   /// buy upgrade cards with ether/Jade\r\n  function buyUpgradeCard(uint256 upgradeId) external payable {\r\n    require(cards.getGameStarted());\r\n    require(upgradeId>=1);\r\n    uint256 existing = cards.getUpgradesOwned(msg.sender,upgradeId);\r\n    require(existing<=5); \r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    uint256 upgradeClass;\r\n    uint256 unitId;\r\n    uint256 upgradeValue;\r\n    (coinCost, ethCost, upgradeClass, unitId, upgradeValue,) = schema.getUpgradeCardsInfo(upgradeId,existing);\r\n\r\n    if (ethCost > 0) {\r\n      require(SafeMath.add(cards.coinBalanceOf(msg.sender,0),msg.value) >= ethCost); \r\n      \r\n      if (ethCost > msg.value) { // They can use their balance instead\r\n        cards.setCoinBalance(msg.sender, SafeMath.sub(ethCost,msg.value),0,false);\r\n      } else if (ethCost < msg.value) {  \r\n        cards.setCoinBalance(msg.sender,SafeMath.sub(msg.value,ethCost),0,true);\r\n      } \r\n\r\n      // defund 5%\r\n      uint256 devFund = uint256(SafeMath.div(ethCost, 20)); // 5% fee on purchases (marketing, gameplay & maintenance)\r\n      cards.setTotalEtherPool(SafeMath.sub(ethCost,devFund),0,true); // go to pool 95%\r\n      cards.setCoinBalance(owner,devFund,0,true);  \r\n    }\r\n    require(cards.balanceOf(msg.sender) >= coinCost);  \r\n    cards.updatePlayersCoinByPurchase(msg.sender, coinCost);\r\n\r\n    upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue);  \r\n    cards.setUpgradesOwned(msg.sender,upgradeId); //upgrade cards level\r\n\r\n    UpgradeCardBought(msg.sender, upgradeId);\r\n  }\r\n\r\n  // Allows someone to send ether and obtain the token\r\n  function buyRareItem(uint256 rareId) external payable {\r\n    require(cards.getGameStarted());        \r\n    address previousOwner = rare.getRareItemsOwner(rareId); \r\n    require(previousOwner != 0);\r\n    require(msg.sender!=previousOwner);  // can not buy from itself\r\n    \r\n    uint256 ethCost = rare.getRareItemsPrice(rareId);\r\n    uint256 totalCost = SafeMath.add(cards.coinBalanceOf(msg.sender,0),msg.value);\r\n    require(totalCost >= ethCost); \r\n        \r\n    // We have to claim buyer/sellder's goo before updating their production values \r\n    cards.updatePlayersCoinByOut(msg.sender);\r\n    cards.updatePlayersCoinByOut(previousOwner);\r\n\r\n    uint256 upgradeClass;\r\n    uint256 unitId;\r\n    uint256 upgradeValue;\r\n    (,,,,upgradeClass, unitId, upgradeValue) = rare.getRareInfo(rareId);\r\n    \r\n    upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue); \r\n    removeUnitMultipliers(previousOwner, upgradeClass, unitId, upgradeValue); \r\n\r\n    // Splitbid/Overbid\r\n    if (ethCost > msg.value) {\r\n      cards.setCoinBalance(msg.sender,SafeMath.sub(ethCost,msg.value),0,false);\r\n    } else if (msg.value > ethCost) {\r\n      // Store overbid in their balance\r\n      cards.setCoinBalance(msg.sender,SafeMath.sub(msg.value,ethCost),0,true);\r\n    }  \r\n    // Distribute ethCost\r\n    uint256 devFund = uint256(SafeMath.div(ethCost, 20)); // 5% fee on purchases (marketing, gameplay & maintenance) \r\n    uint256 dividends = uint256(SafeMath.div(ethCost,20)); // 5% goes to pool \r\n\r\n    cards.setTotalEtherPool(dividends,0,true);\r\n    cards.setCoinBalance(owner,devFund,0,true); \r\n        \r\n    // Transfer / update rare item\r\n    rare.transferToken(previousOwner,msg.sender,rareId); \r\n    rare.setRarePrice(rareId,SafeMath.div(SafeMath.mul(ethCost,5),4));\r\n\r\n    cards.setCoinBalance(previousOwner,SafeMath.sub(ethCost,SafeMath.add(dividends,devFund)),0,true);\r\n\r\n    //players\r\n    if (cards.getUintsOwnerCount(msg.sender)<=0) {\r\n      cards.AddPlayers(msg.sender);\r\n    }\r\n   \r\n    cards.setUintsOwnerCount(msg.sender,1,true);\r\n    cards.setUintsOwnerCount(previousOwner,1,false);\r\n\r\n    //tell the world\r\n    BuyRareCard(msg.sender, previousOwner, rareId, ethCost);\r\n  }\r\n  \r\n  /// sell out cards ,upgrade cards can not be sold\r\n  function sellCards(uint256 unitId, uint256 amount) external {\r\n    require(cards.getGameStarted());\r\n    uint256 existing = cards.getOwnedCount(msg.sender,unitId);\r\n    require(existing >= amount && amount>0); \r\n    existing = SafeMath.sub(existing,amount);\r\n\r\n    uint256 coinChange;\r\n    uint256 decreaseCoin;\r\n    uint256 schemaUnitId;\r\n    uint256 coinProduction;\r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    bool sellable;\r\n    if (unitId>=40) {\r\n      (schemaUnitId,coinCost,ethCost, sellable) = schema.getBattleCardInfo(unitId, existing, amount);\r\n    } else {\r\n      (schemaUnitId, coinProduction, coinCost, ethCost, sellable) = schema.getCardInfo(unitId, existing, amount);\r\n    }\r\n    if (ethCost>0) {\r\n      require(unitsOwnedOfEth[msg.sender][unitId]>=amount);\r\n    }\r\n    //cards can be sold\r\n    require(sellable);\r\n    if (coinCost>0) {\r\n      coinChange = SafeMath.add(cards.balanceOfUnclaimed(msg.sender), SafeMath.div(SafeMath.mul(coinCost,70),100)); // Claim unsaved goo whilst here\r\n    } else {\r\n      coinChange = cards.balanceOfUnclaimed(msg.sender); //if 0\r\n    }\r\n\r\n    cards.setLastJadeSaveTime(msg.sender); \r\n    cards.setRoughSupply(coinChange);  \r\n    cards.setJadeCoin(msg.sender, coinChange, true); //  70% to users\r\n\r\n    decreaseCoin = cards.getUnitsInProduction(msg.sender, unitId, amount); \r\n    \r\n    if (coinProduction > 0) { \r\n      cards.reducePlayersJadeProduction(msg.sender, decreaseCoin);\r\n      //reduct production\r\n      cards.setUintCoinProduction(msg.sender,unitId,decreaseCoin,false); \r\n    }\r\n\r\n    if (ethCost > 0) { // Premium units sell for 70% of buy cost\r\n      cards.setCoinBalance(msg.sender,SafeMath.div(SafeMath.mul(ethCost,70),100),0,true);\r\n    }\r\n\r\n    cards.setOwnedCount(msg.sender,unitId,amount,false); //subscriber\r\n    cards.setUintsOwnerCount(msg.sender,amount,false);\r\n    if (ethCost>0) {\r\n      unitsOwnedOfEth[msg.sender][unitId] = SafeMath.sub(unitsOwnedOfEth[msg.sender][unitId],amount);\r\n    }\r\n    //tell the world\r\n    UnitSold(msg.sender, unitId, amount);\r\n  }\r\n\r\n  // withraw ether\r\n  function withdrawAmount (uint256 _amount) public onlyOwner {\r\n    require(_amount<= this.balance);\r\n    owner.transfer(_amount);\r\n  }\r\n   /// withdraw ether to wallet\r\n  function withdrawEtherFromTrade(uint256 amount) external {\r\n    require(amount <= cards.coinBalanceOf(msg.sender,0));\r\n    cards.setCoinBalance(msg.sender,amount,0,false);\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n  function getCanSellUnit(address _address,uint256 unitId) external view returns (uint256) {\r\n    return unitsOwnedOfEth[_address][unitId];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyEthCards\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyBasicCards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEtherFromTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rare\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAutoAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCardsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setRareAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setConfigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellCards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rareId\",\"type\":\"uint256\"}],\"name\":\"buyRareItem\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"unitId\",\"type\":\"uint256\"}],\"name\":\"getCanSellUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"sendGiftCard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"upgradeId\",\"type\":\"uint256\"}],\"name\":\"buyUpgradeCard\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"schema\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnitBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"upgradeId\",\"type\":\"uint256\"}],\"name\":\"UpgradeCardBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rareId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iPrice\",\"type\":\"uint256\"}],\"name\":\"BuyRareCard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnitSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CardsTrade","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://69e828f918961f8023afb023d15c4e0b0ea6bce38aab4a50ab3d97d6f953b45f"}]}