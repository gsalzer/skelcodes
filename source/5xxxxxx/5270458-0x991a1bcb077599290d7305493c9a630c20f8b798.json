{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.20;\r\n\r\ninterface ERC820ImplementerInterface {\r\n    /// @notice Contracts that implement an interferce in behalf of another contract must return true\r\n    /// @param addr Address that the contract woll implement the interface in behalf of\r\n    /// @param interfaceHash keccak256 of the name of the interface\r\n    /// @return ERC820_ACCEPT_MAGIC if the contract can implement the interface represented by\r\n    ///  `Ã¬nterfaceHash` in behalf of `addr`\r\n    function canImplementInterfaceForAddress(address addr, bytes32 interfaceHash) view public returns(bytes32);\r\n}\r\n\r\ncontract ERC820Registry {\r\n    bytes4 constant InvalidID = 0xffffffff;\r\n    bytes4 constant ERC165ID = 0x01ffc9a7;\r\n    bytes32 constant ERC820_ACCEPT_MAGIC = keccak256(\"ERC820_ACCEPT_MAGIC\");\r\n\r\n\r\n    mapping (address => mapping(bytes32 => address)) interfaces;\r\n    mapping (address => address) managers;\r\n    mapping (address => mapping(bytes4 => bool)) erc165Cache;\r\n\r\n    modifier canManage(address addr) {\r\n        require(getManager(addr) == msg.sender);\r\n        _;\r\n    }\r\n\r\n\r\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\r\n    event ManagerChanged(address indexed addr, address indexed newManager);\r\n\r\n    /// @notice Query the hash of an interface given a name\r\n    /// @param interfaceName Name of the interfce\r\n    function interfaceHash(string interfaceName) public pure returns(bytes32) {\r\n        return keccak256(interfaceName);\r\n    }\r\n\r\n    /// @notice GetManager\r\n    function getManager(address addr) public view returns(address) {\r\n        // By default the manager of an address is the same address\r\n        if (managers[addr] == 0) {\r\n            return addr;\r\n        } else {\r\n            return managers[addr];\r\n        }\r\n    }\r\n\r\n    /// @notice Sets an external `manager` that will be able to call `setInterfaceImplementer()`\r\n    ///  on behalf of the address.\r\n    /// @param addr Address that you are defining the manager for.\r\n    /// @param newManager The address of the manager for the `addr` that will replace\r\n    ///  the old one.  Set to 0x0 if you want to remove the manager.\r\n    function setManager(address addr, address newManager) public canManage(addr) {\r\n        managers[addr] = newManager == addr ? 0 : newManager;\r\n        ManagerChanged(addr, newManager);\r\n    }\r\n\r\n    /// @notice Query if an address implements an interface and thru which contract\r\n    /// @param addr Address that is being queried for the implementation of an interface\r\n    /// @param iHash SHA3 of the name of the interface as a string\r\n    ///  Example `web3.utils.sha3('ERC777Token`')`\r\n    /// @return The address of the contract that implements a specific interface\r\n    ///  or 0x0 if `addr` does not implement this interface\r\n    function getInterfaceImplementer(address addr, bytes32 iHash) constant public returns (address) {\r\n        if (isERC165Interface(iHash)) {\r\n            bytes4 i165Hash = bytes4(iHash);\r\n            return erc165InterfaceSupported(addr, i165Hash) ? addr : 0;\r\n        }\r\n        return interfaces[addr][iHash];\r\n    }\r\n\r\n    /// @notice Sets the contract that will handle a specific interface; only\r\n    ///  the address itself or a `manager` defined for that address can set it\r\n    /// @param addr Address that you want to define the interface for\r\n    /// @param iHash SHA3 of the name of the interface as a string\r\n    ///  For example `web3.utils.sha3('Ierc777')` for the Ierc777\r\n    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public canManage(addr)  {\r\n        require(!isERC165Interface(iHash));\r\n        if ((implementer != 0) && (implementer!=msg.sender)) {\r\n            require(ERC820ImplementerInterface(implementer).canImplementInterfaceForAddress(addr, iHash)\r\n                        == ERC820_ACCEPT_MAGIC);\r\n        }\r\n        interfaces[addr][iHash] = implementer;\r\n        InterfaceImplementerSet(addr, iHash, implementer);\r\n    }\r\n\r\n\r\n/// ERC165 Specific\r\n\r\n    function isERC165Interface(bytes32 iHash) internal pure returns (bool) {\r\n        return iHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;\r\n    }\r\n\r\n    function erc165InterfaceSupported(address _contract, bytes4 _interfaceId) constant public returns (bool) {\r\n        if (!erc165Cache[_contract][_interfaceId]) {\r\n            erc165UpdateCache(_contract, _interfaceId);\r\n        }\r\n        return interfaces[_contract][_interfaceId] != 0;\r\n    }\r\n\r\n    function erc165UpdateCache(address _contract, bytes4 _interfaceId) public {\r\n        interfaces[_contract][_interfaceId] =\r\n            erc165InterfaceSupported_NoCache(_contract, _interfaceId) ? _contract : 0;\r\n        erc165Cache[_contract][_interfaceId] = true;\r\n    }\r\n\r\n    function erc165InterfaceSupported_NoCache(address _contract, bytes4 _interfaceId) public constant returns (bool) {\r\n        uint256 success;\r\n        uint256 result;\r\n\r\n        (success, result) = noThrowCall(_contract, ERC165ID);\r\n        if ((success==0)||(result==0)) {\r\n            return false;\r\n        }\r\n\r\n        (success, result) = noThrowCall(_contract, InvalidID);\r\n        if ((success==0)||(result!=0)) {\r\n            return false;\r\n        }\r\n\r\n        (success, result) = noThrowCall(_contract, _interfaceId);\r\n        if ((success==1)&&(result==1)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function noThrowCall(address _contract, bytes4 _interfaceId) constant internal returns (uint256 success, uint256 result) {\r\n        bytes4 erc165ID = ERC165ID;\r\n\r\n        assembly {\r\n                let x := mload(0x40)               // Find empty storage location using \"free memory pointer\"\r\n                mstore(x, erc165ID)                // Place signature at begining of empty storage\r\n                mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\r\n\r\n                success := staticcall(\r\n                                    30000,         // 30k gas\r\n                                    _contract,     // To addr\r\n                                    x,             // Inputs are stored at location x\r\n                                    0x08,          // Inputs are 8 bytes long\r\n                                    x,             // Store output over input (saves space)\r\n                                    0x20)          // Outputs are 32 bytes long\r\n\r\n                result := mload(x)                 // Load the result\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"iHash\",\"type\":\"bytes32\"},{\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"setInterfaceImplementer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"erc165UpdateCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"interfaceName\",\"type\":\"string\"}],\"name\":\"interfaceHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"erc165InterfaceSupported\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"iHash\",\"type\":\"bytes32\"}],\"name\":\"getInterfaceImplementer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"erc165InterfaceSupported_NoCache\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"InterfaceImplementerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"}]","ContractName":"ERC820Registry","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b424185958879a1eef1cb7235bfd8ed607a7402b46853860e5343340925f028e"}]}