{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\nlibrary AddressUtils {\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract BasicAccessControl {\r\n    address public owner;\r\n    // address[] public moderators;\r\n    uint16 public totalModerators = 0;\r\n    mapping (address => bool) public moderators;\r\n    bool public isMaintaining = false;\r\n\r\n    function BasicAccessControl() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address _newOwner) onlyOwner public {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n\r\n    function AddModerator(address _newModerator) onlyOwner public {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }\r\n    \r\n    function RemoveModerator(address _oldModerator) onlyOwner public {\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }\r\n\r\n    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\r\n        isMaintaining = _isMaintaining;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n}\r\n\r\n\r\ncontract EtheremonAdventurePresale is BasicAccessControl {\r\n    uint8 constant NO_ETH_SITE = 52;\r\n    uint8 constant MAX_BID_PER_SITE = 2;\r\n    using AddressUtils for address;\r\n    \r\n    struct BiddingInfo {\r\n        address bidder;\r\n        uint32 bidId;\r\n        uint amount;\r\n        uint time;\r\n        uint8 siteId;\r\n    }\r\n    \r\n    // address\r\n    address public tokenContract;\r\n    \r\n    uint32 public totalBid = 0;\r\n    uint public startTime;\r\n    uint public endTime;\r\n    uint public bidETHMin;\r\n    uint public bidETHIncrement;\r\n    uint public bidEMONTMin;\r\n    uint public bidEMONTIncrement;\r\n    \r\n    mapping(uint32 => BiddingInfo) bids;\r\n    mapping(uint8 => uint32[]) sites;\r\n\r\n    // event\r\n    event EventPlaceBid(address indexed bidder, uint8 siteId, uint32 bidId, uint amount);\r\n    \r\n    // modifier\r\n    modifier requireTokenContract {\r\n        require(tokenContract != address(0));\r\n        _;\r\n    }\r\n    \r\n    modifier validETHSiteId(uint8 _siteId) {\r\n        require(_siteId > 0 && _siteId <= NO_ETH_SITE);\r\n        _;\r\n    }\r\n    modifier validEMONTSiteId(uint8 _siteId) {\r\n        require(_siteId == 53 || _siteId == 54);\r\n        _;\r\n    }\r\n    modifier onlyRunning {\r\n        require(!isMaintaining);\r\n        require(block.timestamp >= startTime && block.timestamp < endTime);\r\n        _;\r\n    }\r\n    \r\n    function withdrawEther(address _sendTo, uint _amount) onlyModerators public {\r\n        // only allow withdraw after the presale \r\n        if (block.timestamp < endTime)\r\n            revert();\r\n        if (_amount > this.balance) {\r\n            revert();\r\n        }\r\n        _sendTo.transfer(_amount);\r\n    }\r\n    \r\n    function withdrawToken(address _sendTo, uint _amount) onlyModerators requireTokenContract external {\r\n        // only allow withdraw after the presale \r\n        if (block.timestamp < endTime)\r\n            revert();\r\n        ERC20Interface token = ERC20Interface(tokenContract);\r\n        if (_amount > token.balanceOf(address(this))) {\r\n            revert();\r\n        }\r\n        token.transfer(_sendTo, _amount);\r\n    }\r\n\r\n    \r\n    // public functions\r\n    \r\n    function EtheremonAdventurePresale(uint _bidETHMin, uint _bidETHIncrement, uint _bidEMONTMin, uint _bidEMONTIncrement, uint _startTime, uint _endTime, address _tokenContract) public {\r\n        if (_startTime >= _endTime) revert();\r\n        \r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        bidETHMin = _bidETHMin;\r\n        bidETHIncrement = _bidETHIncrement;\r\n        bidEMONTMin = _bidEMONTMin;\r\n        bidEMONTIncrement = _bidEMONTIncrement;\r\n        \r\n        tokenContract = _tokenContract;\r\n    }\r\n    \r\n    function placeETHBid(uint8 _siteId) onlyRunning payable external validETHSiteId(_siteId) {\r\n        // check valid bid \r\n        if (msg.sender.isContract()) revert();\r\n        if (msg.value < bidETHMin) revert();\r\n        \r\n        uint index = 0;\r\n        totalBid += 1;\r\n        BiddingInfo storage bid = bids[totalBid];\r\n        bid.bidder = msg.sender;\r\n        bid.bidId = totalBid;\r\n        bid.amount = msg.value;\r\n        bid.time = block.timestamp;\r\n        bid.siteId = _siteId;\r\n        \r\n        uint32[] storage siteBids = sites[_siteId];\r\n        if (siteBids.length >= MAX_BID_PER_SITE) {\r\n            // find lowest bid\r\n            uint lowestIndex = 0;\r\n            BiddingInfo storage currentBid = bids[siteBids[0]];\r\n            BiddingInfo storage lowestBid = currentBid;\r\n            for (index = 0; index < siteBids.length; index++) {\r\n                currentBid = bids[siteBids[index]];\r\n                // check no same ether address \r\n                if (currentBid.bidder == msg.sender) {\r\n                    revert();\r\n                }\r\n                if (lowestBid.amount == 0 || currentBid.amount < lowestBid.amount || (currentBid.amount == lowestBid.amount && currentBid.bidId > lowestBid.bidId)) {\r\n                    lowestIndex = index;\r\n                    lowestBid = currentBid;\r\n                }\r\n            }\r\n            \r\n            // verify bidIncrement\r\n            if (msg.value < lowestBid.amount + bidETHIncrement)\r\n                revert();\r\n            \r\n            // update latest bidder\r\n            siteBids[lowestIndex] = totalBid;\r\n            \r\n            // refund for the lowest \r\n            lowestBid.bidder.transfer(lowestBid.amount);\r\n        } else {\r\n            for (index = 0; index < siteBids.length; index++) {\r\n                if (bids[siteBids[index]].bidder == msg.sender)\r\n                    revert();\r\n            }\r\n            siteBids.push(totalBid);\r\n        }\r\n        \r\n        EventPlaceBid(msg.sender, _siteId, totalBid, msg.value);\r\n    }\r\n    \r\n    // call from our payment contract\r\n    function placeEMONTBid(address _bidder, uint8 _siteId, uint _bidAmount) requireTokenContract onlyRunning onlyModerators external validEMONTSiteId(_siteId) {\r\n        // check valid bid \r\n        if (_bidder.isContract()) revert();\r\n        if (_bidAmount < bidEMONTMin) revert();\r\n        \r\n        \r\n        uint index = 0;\r\n        totalBid += 1;\r\n        BiddingInfo storage bid = bids[totalBid];\r\n        uint32[] storage siteBids = sites[_siteId];\r\n        if (siteBids.length >= MAX_BID_PER_SITE) {\r\n            // find lowest bid\r\n            uint lowestIndex = 0;\r\n            BiddingInfo storage currentBid = bids[siteBids[0]];\r\n            BiddingInfo storage lowestBid = currentBid;\r\n            for (index = 0; index < siteBids.length; index++) {\r\n                currentBid = bids[siteBids[index]];\r\n                // check no same ether address \r\n                if (currentBid.bidder == _bidder) {\r\n                    revert();\r\n                }\r\n                if (lowestBid.amount == 0 || currentBid.amount < lowestBid.amount || (currentBid.amount == lowestBid.amount && currentBid.bidId > lowestBid.bidId)) {\r\n                    lowestIndex = index;\r\n                    lowestBid = currentBid;\r\n                }\r\n            }\r\n            \r\n            // verify bidIncrement\r\n            if (_bidAmount < lowestBid.amount + bidEMONTIncrement)\r\n                revert();\r\n            \r\n            // update latest bidder\r\n            bid.bidder = _bidder;\r\n            bid.bidId = totalBid;\r\n            bid.amount = _bidAmount;\r\n            bid.time = block.timestamp;\r\n            siteBids[lowestIndex] = totalBid;\r\n            \r\n            // refund for the lowest \r\n            ERC20Interface token = ERC20Interface(tokenContract);\r\n            token.transfer(lowestBid.bidder, lowestBid.amount);\r\n        } else {\r\n            for (index = 0; index < siteBids.length; index++) {\r\n                if (bids[siteBids[index]].bidder == _bidder)\r\n                    revert();\r\n            }\r\n            bid.bidder = _bidder;\r\n            bid.bidId = totalBid;\r\n            bid.amount = _bidAmount;\r\n            bid.time = block.timestamp;\r\n            siteBids.push(totalBid);\r\n        }\r\n        \r\n        EventPlaceBid(_bidder, _siteId, totalBid, _bidAmount);\r\n    }\r\n    \r\n    // get data\r\n    \r\n    function getBidInfo(uint32 _bidId) constant external returns(address bidder, uint8 siteId, uint amount, uint time) {\r\n        BiddingInfo memory bid = bids[_bidId];\r\n        bidder = bid.bidder;\r\n        siteId = bid.siteId;\r\n        amount = bid.amount;\r\n        time = bid.time;\r\n    }\r\n    \r\n    function getBidBySiteIndex(uint8 _siteId, uint _index) constant external returns(address bidder, uint32 bidId, uint8 siteId, uint amount, uint time) {\r\n        bidId = sites[_siteId][_index];\r\n        if (bidId > 0) {\r\n            BiddingInfo memory bid = bids[bidId];\r\n            bidder = bid.bidder;\r\n            siteId = bid.siteId;\r\n            amount = bid.amount;\r\n            time = bid.time;\r\n        }\r\n    }\r\n\r\n    function countBid(uint8 _siteId) constant external returns(uint) {\r\n        return sites[_siteId].length;\r\n    }\r\n    \r\n    function getLowestBid(uint8 _siteId) constant external returns(uint lowestAmount) {\r\n        uint32[] storage siteBids = sites[_siteId];\r\n        lowestAmount = 0;\r\n        for (uint index = 0; index < siteBids.length; index++) {\r\n            if (lowestAmount == 0 || bids[siteBids[index]].amount < lowestAmount) {\r\n                lowestAmount = bids[siteBids[index]].amount;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"moderators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidder\",\"type\":\"address\"},{\"name\":\"_siteId\",\"type\":\"uint8\"},{\"name\":\"_bidAmount\",\"type\":\"uint256\"}],\"name\":\"placeEMONTBid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidETHMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isMaintaining\",\"type\":\"bool\"}],\"name\":\"UpdateMaintaining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalModerators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidEMONTIncrement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sendTo\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_siteId\",\"type\":\"uint8\"}],\"name\":\"getLowestBid\",\"outputs\":[{\"name\":\"lowestAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_siteId\",\"type\":\"uint8\"}],\"name\":\"placeETHBid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newModerator\",\"type\":\"address\"}],\"name\":\"AddModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bidId\",\"type\":\"uint32\"}],\"name\":\"getBidInfo\",\"outputs\":[{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"siteId\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_siteId\",\"type\":\"uint8\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getBidBySiteIndex\",\"outputs\":[{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"bidId\",\"type\":\"uint32\"},{\"name\":\"siteId\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sendTo\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidEMONTMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldModerator\",\"type\":\"address\"}],\"name\":\"RemoveModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_siteId\",\"type\":\"uint8\"}],\"name\":\"countBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidETHIncrement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMaintaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bidETHMin\",\"type\":\"uint256\"},{\"name\":\"_bidETHIncrement\",\"type\":\"uint256\"},{\"name\":\"_bidEMONTMin\",\"type\":\"uint256\"},{\"name\":\"_bidEMONTIncrement\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"siteId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"bidId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EventPlaceBid\",\"type\":\"event\"}]","ContractName":"EtheremonAdventurePresale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000006f05b59d3b2000000000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000000000000000000000000000000000005d21dba00000000000000000000000000000000000000000000000000000000012a05f200000000000000000000000000000000000000000000000000000000005b08a380000000000000000000000000000000000000000000000000000000005b24530000000000000000000000000095daaab98046846bf4b2853e23cba236fa394a31","Library":"","SwarmSource":"bzzr://60fe5ccb65f558576ffa5998d1e8f59aa2729e9f90903c6c374ab8f6e95e683d"}]}