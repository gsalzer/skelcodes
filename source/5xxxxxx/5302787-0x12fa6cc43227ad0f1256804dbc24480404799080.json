{"status":"1","message":"OK","result":[{"SourceCode":"// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ODIN token contract \r\n// ----------------------------------------------------------------------------\r\npragma solidity ^0.4.21;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Interface {\r\n//    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Burn(uint tokens);\r\n\r\n    // mitigates the ERC20 short address attack\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n    \r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract OdinToken is ERC20Interface, Owned {\r\n\r\n  using SafeMath for uint256;\r\n\r\n    string public symbol;\r\n    string public name;\r\n    uint8 public decimals;\r\n//    uint private totalSupply;\r\n    bool private _whitelistAll;\r\n\r\n    struct balanceData {  \r\n       bool locked;\r\n       uint balance;\r\n       uint airDropQty;\r\n    }\r\n\r\n    mapping(address => balanceData) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n  /**\r\n  * @dev Constructor for Odin creation\r\n  * @dev Initially assigns the totalSupply to the contract creator\r\n  */\r\n    function OdinToken() public {\r\n        \r\n        // owner of this contract\r\n        owner = msg.sender;\r\n        symbol = \"ODIN\";\r\n        name = \"ODIN Token\";\r\n        decimals = 18;\r\n        _whitelistAll=false;\r\n        totalSupply = 100000000000000000000000;\r\n        balances[owner].balance = totalSupply;\r\n\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    // function totalSupply() constant public returns (uint256 totalSupply) {\r\n    //     return totalSupply;\r\n    // }\r\n    uint256 public totalSupply;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // whitelist an address\r\n    // ------------------------------------------------------------------------\r\n    function whitelistAddress(address tokenOwner) onlyOwner public returns (bool)    {\r\n\t\tbalances[tokenOwner].airDropQty = 0;\r\n\t\treturn true;\r\n    }\r\n\r\n\r\n    /**\r\n  * @dev Whitelist all addresses early\r\n  * @return An bool showing if the function succeeded.\r\n  */\r\n    function whitelistAllAddresses() onlyOwner public returns (bool) {\r\n        _whitelistAll = true;\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param tokenOwner The address to query the the balance of.\r\n  * @return An uint representing the amount owned by the passed address.\r\n  */\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner].balance;\r\n    }\r\n\r\n    function airdrop(address[] recipients, uint[] values) onlyOwner public {\r\n\r\n    require(recipients.length <= 255);\r\n    require (msg.sender==owner);\r\n    require(recipients.length == values.length);\r\n    for (uint i = 0; i < recipients.length; i++) {\r\n        if (balances[recipients[i]].balance==0) {\r\n          OdinToken.transfer(recipients[i], values[i]);\r\n    }\r\n    }\r\n  }\r\n  \r\n    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {\r\n\r\n        if (_value > balances[tokenOwner].balance) {return false;}     // do they have enough to spend?\r\n        if (tokenOwner==address(0)) {return false;}                               // cannot send to address[0]\r\n\r\n        if (tokenOwner==owner) {return true;}                                       // owner can always spend\r\n        if (_whitelistAll) {return true;}                                   // we pulled the rip cord\r\n        if (balances[tokenOwner].airDropQty==0) {return true;}                      // these are not airdrop tokens\r\n        if (block.timestamp>1569974400) {return true;}                      // no restrictions after june 30, 2019\r\n\r\n        // do not allow transfering air dropped tokens prior to Sep 1 2018\r\n         if (block.timestamp < 1535760000) {return false;}\r\n\r\n        // after Sep 1 2018 and before Dec 31, 2018, do not allow transfering more than 10% of air dropped tokens\r\n        if (block.timestamp < 1546214400 && (balances[tokenOwner].balance - _value) < (balances[tokenOwner].airDropQty / 10 * 9)) {\r\n            return false;\r\n        }\r\n\r\n        // after Dec 31 2018 and before March 31, 2019, do not allow transfering more than 25% of air dropped tokens\r\n        if (block.timestamp < 1553990400 && (balances[tokenOwner].balance - _value) < balances[tokenOwner].airDropQty / 4 * 3) {\r\n            return false;\r\n        }\r\n\r\n        // after March 31, 2019 and before Jun 30, 2019, do not allow transfering more than 50% of air dropped tokens\r\n        if (block.timestamp < 1561852800 && (balances[tokenOwner].balance - _value) < balances[tokenOwner].airDropQty / 2) {\r\n            return false;\r\n        }\r\n\r\n        // after Jun 30, 2019 and before Oct 2, 2019, do not allow transfering more than 75% of air dropped tokens\r\n        if (block.timestamp < 1569974400 && (balances[tokenOwner].balance - _value) < balances[tokenOwner].airDropQty / 4) {\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n\r\n    }\r\n\r\n    function transfer(address to, uint _value) onlyPayloadSize(2 * 32) public returns (bool success) {\r\n\r\n        require (canSpend(msg.sender, _value));\r\n        balances[msg.sender].balance = balances[msg.sender].balance.sub( _value);\r\n        balances[to].balance = balances[to].balance.add( _value);\r\n        if (msg.sender == owner) {\r\n            balances[to].airDropQty = balances[to].airDropQty.add( _value);\r\n        }\r\n        emit Transfer(msg.sender, to,  _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint  _value) public returns (bool success) {\r\n\r\n        require (canSpend(msg.sender, _value));\r\n\r\n        // // mitigates the ERC20 spend/approval race condition\r\n        // if ( _value != 0 && allowed[msg.sender][spender] != 0) { return false; }\r\n\r\n        allowed[msg.sender][spender] =  _value;\r\n        emit Approval(msg.sender, spender,  _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint  _value) onlyPayloadSize(3 * 32) public returns (bool success) {\r\n\r\n        if (balances[from].balance >=  _value && allowed[from][msg.sender] >=  _value &&  _value > 0) {\r\n\r\n            allowed[from][msg.sender].sub( _value);\r\n            balances[from].balance = balances[from].balance.sub( _value);\r\n            balances[to].balance = balances[to].balance.add( _value);\r\n            emit Transfer(from, to,  _value);\r\n          return true;\r\n        } else {\r\n          require(false);\r\n        }\r\n      }\r\n    \r\n\r\n    // ------------------------------------------------------------------------\r\n    // not implemented\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Used to burn unspent tokens in the contract\r\n    // ------------------------------------------------------------------------\r\n    function burn(uint  _value) onlyOwner public returns (bool) {\r\n        require((balances[owner].balance -  _value) >= 0);\r\n        balances[owner].balance = balances[owner].balance.sub( _value);\r\n        totalSupply = totalSupply.sub( _value);\r\n        emit Burn( _value);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"whitelistAllAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"canSpend\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"whitelistAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipients\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"OdinToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b9db5ceafdd3f4355116e59010403a366811f3ce83803139bc5eb7166dd062d3"}]}