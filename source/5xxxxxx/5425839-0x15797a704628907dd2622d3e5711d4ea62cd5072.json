{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\nlibrary itMaps {\r\n    /* itMapAddressUint\r\n         address =>  Uint\r\n    */\r\n    struct entryAddressUint {\r\n    // Equal to the index of the key of this item in keys, plus 1.\r\n    uint keyIndex;\r\n    uint value;\r\n    }\r\n\r\n    struct itMapAddressUint {\r\n    mapping(address => entryAddressUint) data;\r\n    address[] keys;\r\n    }\r\n\r\n    function insert(itMapAddressUint storage self, address key, uint value) internal returns (bool replaced) {\r\n        entryAddressUint storage e = self.data[key];\r\n        e.value = value;\r\n        if (e.keyIndex > 0) {\r\n            return true;\r\n        } else {\r\n            e.keyIndex = ++self.keys.length;\r\n            self.keys[e.keyIndex - 1] = key;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function remove(itMapAddressUint storage self, address key) internal returns (bool success) {\r\n        entryAddressUint storage e = self.data[key];\r\n        if (e.keyIndex == 0)\r\n        return false;\r\n\r\n        if (e.keyIndex <= self.keys.length) {\r\n            // Move an existing element into the vacated key slot.\r\n            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\r\n            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\r\n            self.keys.length -= 1;\r\n            delete self.data[key];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function destroy(itMapAddressUint storage self) internal  {\r\n        for (uint i; i<self.keys.length; i++) {\r\n            delete self.data[ self.keys[i]];\r\n        }\r\n        delete self.keys;\r\n        return ;\r\n    }\r\n\r\n    function contains(itMapAddressUint storage self, address key) internal constant returns (bool exists) {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n\r\n    function size(itMapAddressUint storage self) internal constant returns (uint) {\r\n        return self.keys.length;\r\n    }\r\n\r\n    function get(itMapAddressUint storage self, address key) internal constant returns (uint) {\r\n        return self.data[key].value;\r\n    }\r\n\r\n    function getKeyByIndex(itMapAddressUint storage self, uint idx) internal constant returns (address) {\r\n        return self.keys[idx];\r\n    }\r\n\r\n    function getValueByIndex(itMapAddressUint storage self, uint idx) internal constant returns (uint) {\r\n        return self.data[self.keys[idx]].value;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint256 supply);\r\n    function balanceOf(address who) public constant returns (uint value);\r\n    function allowance(address owner, address spender) public constant returns (uint _allowance);\r\n\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract TakeMyEther is ERC20{\r\n    using itMaps for itMaps.itMapAddressUint;\r\n\r\n    uint private initialSupply = 2800000;\r\n    uint public soldTokens = 0; //reduces when somebody returns money\r\n    string public constant name = \"TakeMyEther\";\r\n    string public constant symbol = \"TMEther\";\r\n    address public TakeMyEtherTeamAddress;\r\n\r\n    itMaps.itMapAddressUint tokenBalances; //amount of tokens each address holds\r\n    mapping (address => uint256) weiBalances; //amount of Wei, paid for tokens that smb holds. Used only before project completed.\r\n    mapping (address => uint256) weiBalancesReturned;\r\n\r\n    uint public percentsOfProjectComplete = 0;\r\n    uint public lastStageSubmitted;\r\n    uint public lastTimeWithdrawal;\r\n\r\n    uint public constant softCapTokensAmount = 500000;\r\n    uint public constant hardCapTokensAmount = 2250000;\r\n\r\n    uint public constant lockDownPeriod = 1 weeks;\r\n    uint public constant minimumStageDuration = 2 weeks;\r\n\r\n    bool public isICOfinalized = false;\r\n    bool public projectCompleted = false;\r\n\r\n    modifier onlyTeam {\r\n        if (msg.sender == TakeMyEtherTeamAddress) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    event StageSubmitted(uint last);\r\n    event etherPassedToTheTeam(uint weiAmount, uint when);\r\n    event etherWithdrawFromTheContract(address tokenHolder, uint numberOfTokensSoldBack, uint weiValue);\r\n    event Burned(address indexed from, uint amount);\r\n    event DividendsTransfered(address to, uint tokensAmount, uint weiAmount);\r\n\r\n    // ERC20 interface implementation\r\n\r\n    function totalSupply() public constant returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n\r\n    function balanceOf(address tokenHolder) public view returns (uint256 balance) {\r\n        return tokenBalances.get(tokenHolder);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public constant returns (uint256) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint value) public returns (bool success) {\r\n        if (tokenBalances.get(msg.sender) >= value && value > 0) {\r\n            if (to == address(this)) { // if you send even 1 token back to the contract, it will return all available funds to you\r\n                returnAllAvailableFunds();\r\n                return true;\r\n            }\r\n            else {\r\n                return transferTokensAndEtherValue(msg.sender, to, value, getAverageTokenPrice(msg.sender) * value);\r\n            }\r\n        } else return false;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (tokenBalances.get(from)>=value && allowed[from][to] >= value && value > 0) {\r\n            if (transferTokensAndEtherValue(from, to, value, getAverageTokenPrice(from) * value)) {\r\n                allowed[from][to] -= value;\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function approve(address spender, uint value) public returns (bool success) {\r\n        if ((value != 0) && (tokenBalances.get(msg.sender) >= value)){\r\n            allowed[msg.sender][spender] = value;\r\n            emit Approval(msg.sender, spender, value);\r\n            return true;\r\n        } else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Constructor, fallback, return funds\r\n\r\n    function TakeMyEther() public {\r\n        TakeMyEtherTeamAddress = msg.sender;\r\n        tokenBalances.insert(address(this), initialSupply);\r\n        lastStageSubmitted = now;\r\n    } //tested\r\n\r\n    function () public payable {\r\n        require (!projectCompleted);\r\n        uint weiToSpend = msg.value; //recieved value\r\n        uint currentPrice = getCurrentSellPrice(); //0.5 ETH or 1 ETH for 1000 tokens\r\n        uint valueInWei = 0;\r\n        uint valueToPass = 0;\r\n\r\n        if (weiToSpend < currentPrice) {// return ETH back if nothing to buy\r\n            return;\r\n        }\r\n\r\n        if (!tokenBalances.contains(msg.sender))\r\n        tokenBalances.insert(msg.sender, 0);\r\n\r\n        if (soldTokens < softCapTokensAmount) {\r\n            uint valueLeftForSoftCap = softCapTokensAmount - soldTokens;\r\n            valueToPass = weiToSpend / currentPrice;\r\n\r\n            if (valueToPass > valueLeftForSoftCap)\r\n            valueToPass = valueLeftForSoftCap;\r\n\r\n            valueInWei = valueToPass * currentPrice;\r\n            weiToSpend -= valueInWei;\r\n            soldTokens += valueToPass;\r\n            weiBalances[address(this)] += valueInWei;\r\n            transferTokensAndEtherValue(address(this), msg.sender, valueToPass, valueInWei);\r\n        }\r\n\r\n        currentPrice = getCurrentSellPrice(); //renew current price\r\n\r\n        if (weiToSpend < currentPrice) {\r\n            return;\r\n        }\r\n\r\n        if (soldTokens < hardCapTokensAmount && soldTokens >= softCapTokensAmount) {\r\n            uint valueLeftForHardCap = hardCapTokensAmount - soldTokens;\r\n            valueToPass = weiToSpend / currentPrice;\r\n\r\n            if (valueToPass > valueLeftForHardCap)\r\n            valueToPass = valueLeftForHardCap;\r\n\r\n            valueInWei = valueToPass * currentPrice;\r\n            weiToSpend -= valueInWei;\r\n            soldTokens += valueToPass;\r\n            weiBalances[address(this)] += valueInWei;\r\n            transferTokensAndEtherValue(address(this), msg.sender, valueToPass, valueInWei);\r\n        }\r\n\r\n        if (weiToSpend / 10**17 > 1) { //return unspent funds if they are greater than 0.1 ETH\r\n            msg.sender.transfer(weiToSpend);\r\n        }\r\n    }\r\n\r\n    function returnAllAvailableFunds() public {\r\n        require (tokenBalances.contains(msg.sender)); //you need to be a tokenHolder\r\n        require (!projectCompleted); //you can not return tokens after project is completed\r\n\r\n        uint avPrice = getAverageTokenPrice(msg.sender);\r\n        weiBalances[msg.sender] = getWeiAvailableToReturn(msg.sender); //depends on project completeness level\r\n\r\n        uint amountOfTokensToReturn = weiBalances[msg.sender] / avPrice;\r\n\r\n        require (amountOfTokensToReturn>0);\r\n\r\n        uint valueInWei = weiBalances[msg.sender];\r\n\r\n        transferTokensAndEtherValue(msg.sender, address(this), amountOfTokensToReturn, valueInWei);\r\n        emit etherWithdrawFromTheContract(msg.sender, amountOfTokensToReturn, valueInWei);\r\n        weiBalances[address(this)] -= valueInWei;\r\n        soldTokens -= amountOfTokensToReturn;\r\n        msg.sender.transfer(valueInWei);\r\n    }\r\n\r\n    // View functions\r\n\r\n    function getWeiBalance(address a) public view returns (uint) {\r\n        return weiBalances[a];\r\n    }\r\n\r\n    function getWeiAvailableToReturn(address holder) public view returns (uint amount) {\r\n        if (!isICOfinalized) return weiBalances[holder];\r\n        uint percentsBlocked = 0;\r\n        if (percentsOfProjectComplete > 10 && lastStageSubmitted + lockDownPeriod > now)\r\n        percentsBlocked = percentsOfProjectComplete - 10;\r\n        else\r\n        percentsBlocked = percentsOfProjectComplete;\r\n        return ((weiBalances[holder]  / 100) * (100 - percentsOfProjectComplete));\r\n    }\r\n\r\n    function getAverageTokenPrice(address holder) public view returns (uint avPriceInWei) {\r\n        return weiBalances[holder] / tokenBalances.get(holder);\r\n    }\r\n\r\n    function getNumberOfTokensForTheTeam() public view returns (uint amount) {\r\n        if (soldTokens == softCapTokensAmount) return soldTokens * 4; // 80%\r\n        if (soldTokens == hardCapTokensAmount) return soldTokens/4; // 20%\r\n        uint teamPercents = (80 - ((soldTokens - softCapTokensAmount) / ((hardCapTokensAmount - softCapTokensAmount)/60)));\r\n        return ((soldTokens / (100 - teamPercents)) * teamPercents); // tokens for the team\r\n    }\r\n\r\n    function getCurrentSellPrice() public view returns (uint priceInWei) {\r\n        if (!isICOfinalized) {\r\n            if (soldTokens < softCapTokensAmount) return 10**14 * 5 ; //this is equal to 0.0005 ETH\r\n            else return 10**15; //this is equal to 0.001 ETH\r\n        }\r\n        else { //if someone returns tokens after ICO finished, he can buy them until project is finished. But the price will depend on the project completeness level.\r\n            if (!projectCompleted) //if project is finished, no one can buy tokens\r\n            return (1 * 10**15 + 5 * (percentsOfProjectComplete * 10**13)) ; //each percent of completeness adds 5% to the tokenPrice.\r\n            else return 0; // there is no problem, because project is completed and fallback function won't work;\r\n        }\r\n    }\r\n\r\n    function getAvailableFundsForTheTeam() public view returns (uint amount) {\r\n        if (percentsOfProjectComplete == 100) return address(this).balance; // take all the rest\r\n        return (address(this).balance /(100 - (percentsOfProjectComplete - 10))) * 10; // take next 10% of funds, left on the contract.\r\n        /*So if, for example, percentsOfProjectComplete is 30 (increased by 10 from previous stage)\r\n        there are 80% of funds, left on the contract. So we devide balance by 80 to get 1%, and then multiply by 10*/\r\n    }\r\n\r\n    // Team functions\r\n\r\n    function finalizeICO() public onlyTeam {\r\n        require(!isICOfinalized); // this function can be called only once\r\n        if (soldTokens < hardCapTokensAmount)\r\n        require (lastStageSubmitted + minimumStageDuration < now); // ICO duration is at least 2 weeks\r\n        require(soldTokens >= softCapTokensAmount); //means, that the softCap Reached\r\n        uint tokensToPass = passTokensToTheTeam(); //but without weiValue, so the team can not withdraw ether by returning tokens to the contract\r\n        burnUndistributedTokens(tokensToPass);//tokensToPass); // undistributed tokens are destroyed\r\n        lastStageSubmitted = now;\r\n        emit StageSubmitted(lastStageSubmitted);\r\n        increaseProjectCompleteLevel(); // Now, team can withdraw 10% of funds raised to begin the project\r\n        passFundsToTheTeam();\r\n        isICOfinalized = true;\r\n    }\r\n\r\n    function submitNextStage() public onlyTeam returns (bool success) {\r\n        if (lastStageSubmitted + minimumStageDuration > now) return false; //Team submitted the completeness of previous stage more then 2 weeks before.\r\n        lastStageSubmitted = now;\r\n        emit StageSubmitted(lastStageSubmitted);\r\n        increaseProjectCompleteLevel();\r\n        return true;\r\n    }\r\n\r\n    function unlockFundsAndPassEther() public onlyTeam returns (bool success) {\r\n        require (lastTimeWithdrawal<=lastStageSubmitted);\r\n        if (lastStageSubmitted + lockDownPeriod > now) return false; //funds can not be passed until lockDownPeriod ends\r\n        if (percentsOfProjectComplete == 100 && !projectCompleted) {\r\n            projectCompleted = true;\r\n            if (tokenBalances.get(address(this))>0) {\r\n                uint toTransferAmount = tokenBalances.get(address(this));\r\n                tokenBalances.insert(TakeMyEtherTeamAddress, tokenBalances.get(address(this)) + tokenBalances.get(TakeMyEtherTeamAddress));\r\n                tokenBalances.insert(address(this), 0);\r\n                emit Transfer(address(this), TakeMyEtherTeamAddress, toTransferAmount);\r\n            }\r\n        }\r\n        passFundsToTheTeam();\r\n        return true;\r\n    }\r\n\r\n    // Receive dividends\r\n\r\n    function topUpWithEtherAndTokensForHolders(address tokensContractAddress, uint tokensAmount) public payable {\r\n        uint weiPerToken = msg.value / initialSupply;\r\n        uint tokensPerToken = 100 * tokensAmount / initialSupply; //Multiplication for more precise amount\r\n        uint weiAmountForHolder = 0;\r\n        uint tokensForHolder = 0;\r\n\r\n        for (uint i = 0; i< tokenBalances.size(); i += 1) {\r\n            address tokenHolder = tokenBalances.getKeyByIndex(i);\r\n            if (tokenBalances.get(tokenHolder)>0) {\r\n                weiAmountForHolder = tokenBalances.get(tokenHolder)*weiPerToken;\r\n                tokensForHolder = tokenBalances.get(tokenHolder) * tokensPerToken / 100; // Dividing because of the previous multiplication\r\n                tokenHolder.transfer(weiAmountForHolder); //This will pass a certain amount of ether to TakeMyEther platform tokenHolders\r\n                if (tokensContractAddress.call(bytes4(keccak256(\"authorizedTransfer(address,address,uint256)\")), msg.sender, tokenHolder, tokensForHolder)) //This will pass a certain amount of tokens to TakeMyEther platform tokenHolders\r\n                emit DividendsTransfered(tokenHolder, tokensForHolder, weiAmountForHolder);\r\n            }\r\n        }\r\n    }\r\n\r\n    function passUndistributedEther() public {\r\n        require (projectCompleted);\r\n        uint weiPerToken = (address(this).balance * 100) / initialSupply;\r\n\r\n        for (uint i = 0; i< tokenBalances.size(); i += 1) {\r\n            address tokenHolder = tokenBalances.getKeyByIndex(i);\r\n            if (tokenBalances.get(tokenHolder)>0) {\r\n                uint weiAmountForHolder = (tokenBalances.get(tokenHolder)*weiPerToken)/100;\r\n                tokenHolder.transfer(weiAmountForHolder); //This will pass a certain amount of ether to TakeMyEther platform tokenHolders\r\n                emit DividendsTransfered(tokenHolder, 0, weiAmountForHolder);\r\n            }\r\n        }\r\n    } // When project is finished and Dividends are passed to the tokenHolders, there is some wei, left on the contract. Gradually, there can be a large amount of wei left, so it should be also distributed among tokenHolders.\r\n\r\n    // Internal functions\r\n\r\n    function transferTokensAndEtherValue(address from, address to, uint value, uint weiValue) internal returns (bool success){\r\n        if (tokenBalances.contains(from) && tokenBalances.get(from) >= value) {\r\n            tokenBalances.insert(to, tokenBalances.get(to) + value);\r\n            tokenBalances.insert(from, tokenBalances.get(from) - value);\r\n\r\n            weiBalances[from] -= weiValue;\r\n            weiBalances[to] += weiValue;\r\n\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function passFundsToTheTeam() internal {\r\n        uint weiAmount = getAvailableFundsForTheTeam();\r\n        TakeMyEtherTeamAddress.transfer(weiAmount);\r\n        emit etherPassedToTheTeam(weiAmount, now);\r\n        lastTimeWithdrawal = now;\r\n    }\r\n\r\n    function passTokensToTheTeam() internal returns (uint tokenAmount) { //This function passes tokens to the team without weiValue, so the team can not withdraw ether by returning tokens to the contract\r\n        uint tokensToPass = getNumberOfTokensForTheTeam();\r\n        tokenBalances.insert(TakeMyEtherTeamAddress, tokensToPass);\r\n        weiBalances[TakeMyEtherTeamAddress] = 0; // those tokens don't cost any ether\r\n        emit Transfer(address(this), TakeMyEtherTeamAddress, tokensToPass);\r\n        return tokensToPass;\r\n    }\r\n\r\n    function increaseProjectCompleteLevel() internal {\r\n        if (percentsOfProjectComplete<60)\r\n        percentsOfProjectComplete += 10;\r\n        else\r\n        percentsOfProjectComplete = 100;\r\n    }\r\n\r\n    function burnUndistributedTokens(uint tokensToPassToTheTeam) internal {\r\n        uint toBurn = initialSupply - (tokensToPassToTheTeam + soldTokens);\r\n        initialSupply -=  toBurn;\r\n        tokenBalances.insert(address(this), 0);\r\n        emit Burned(address(this), toBurn);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumStageDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastStageSubmitted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"returnAllAvailableFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockDownPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getAverageTokenPrice\",\"outputs\":[{\"name\":\"avPriceInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TakeMyEtherTeamAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getWeiAvailableToReturn\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockFundsAndPassEther\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapTokensAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"submitNextStage\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"passUndistributedEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getWeiBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentsOfProjectComplete\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableFundsForTheTeam\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentSellPrice\",\"outputs\":[{\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCapTokensAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isICOfinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimeWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfTokensForTheTeam\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokensContractAddress\",\"type\":\"address\"},{\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"topUpWithEtherAndTokensForHolders\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"last\",\"type\":\"uint256\"}],\"name\":\"StageSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"etherPassedToTheTeam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberOfTokensSoldBack\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiValue\",\"type\":\"uint256\"}],\"name\":\"etherWithdrawFromTheContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"DividendsTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"TakeMyEther","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://71f2845cb31899a10f8a4894f692fffe5dffa29bb64a889d4cdec27c174bd5b9"}]}