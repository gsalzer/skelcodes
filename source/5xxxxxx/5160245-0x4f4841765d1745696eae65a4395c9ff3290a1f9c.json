{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n    function getBeneficiary() external view returns(address);\r\n}\r\n\r\ncontract GeneratorInterface {\r\n\r\n    function isGenerator() public pure returns (bool);\r\n\r\n    /// @dev generate new warrior genes\r\n    /// @param _heroGenes Genes of warrior that have completed dungeon\r\n    /// @param _heroLevel Level of the warrior\r\n    /// @return the genes that are supposed to be passed down to newly arisen warrior\r\n    function generateWarrior(uint256 _heroGenes, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) public returns (uint256);\r\n}\r\n\r\ncontract PVPInterface {\r\n\r\n    function isPVPProvider() external pure returns (bool);\r\n    \r\n    function addTournamentContender(address _owner, uint256[] _tournamentData) external payable;\r\n    function getTournamentThresholdFee() public view returns(uint256);\r\n    \r\n    function addPVPContender(address _owner, uint256 _packedWarrior) external payable;\r\n    function getPVPEntranceFee(uint256 _levelPoints) external view returns(uint256);\r\n}\r\n\r\ncontract PVPListenerInterface {\r\n\r\n    function isPVPListener() public pure returns (bool);\r\n    function getBeneficiary() external view returns(address);\r\n    \r\n    function pvpFinished(uint256[] warriorData, uint256 matchingCount) public;\r\n    function pvpContenderRemoved(uint32 _warriorId) public;\r\n    function tournamentFinished(uint256[] packedContenders) public;\r\n}\r\n\r\n// - The Admin: The Admin performs administrative functions, such as pause, unpause, change dependent contracts\r\n// contracts.\r\n//\r\n// - The Bank: the beneficiary of all contracts\r\n//\r\n// - The Issuer: The Issuer can release miner warriors to auction.\r\ncontract PermissionControll {\r\n\r\n    event ContractUpgrade(address newContract);\r\n    \r\n    address public newContractAddress;\r\n\r\n    address public adminAddress;\r\n    address public bankAddress;\r\n    address public issuerAddress; \r\n\r\n    bool public paused = false;\r\n    \r\n\r\n    modifier onlyAdmin(){\r\n        require(msg.sender == adminAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBank(){\r\n        require(msg.sender == bankAddress);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIssuer(){\r\n    \t\trequire(msg.sender == issuerAddress);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyAuthorized(){\r\n        require(msg.sender == issuerAddress ||\r\n            msg.sender == adminAddress ||\r\n            msg.sender == bankAddress);\r\n        _;\r\n    }\r\n\r\n\r\n    function setBank(address _newBank) external onlyBank {\r\n        require(_newBank != address(0));\r\n        bankAddress = _newBank;\r\n    }\r\n\r\n    function setAdmin(address _newAdmin) external {\r\n        require(msg.sender == adminAddress || msg.sender == bankAddress);\r\n        require(_newAdmin != address(0));\r\n        adminAddress = _newAdmin;\r\n    }\r\n    \r\n    function setIssuer(address _newIssuer) external onlyAdmin{\r\n        require(_newIssuer != address(0));\r\n        issuerAddress = _newIssuer;\r\n    }\r\n\r\n    modifier whenNotPaused(){\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier whenPaused{\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyAuthorized whenNotPaused{\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyAdmin whenPaused{\r\n        paused = false;\r\n    }\r\n    \r\n\r\n    function setNewAddress(address _v2Address) external onlyAdmin whenPaused {\r\n        newContractAddress = _v2Address;\r\n        ContractUpgrade(_v2Address);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner{\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS paused\r\n     */\r\n    modifier whenNotPaused(){\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS NOT paused\r\n     */\r\n    modifier whenPaused{\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n\r\nlibrary DataTypes {\r\n\r\n    struct Warrior{\r\n        // The Warrior's identity code is packed into these 256-bits\r\n        uint256 identity;\r\n        \r\n        uint64 cooldownEndBlock;\r\n        /** every warriors starts from 1 lv (10 level points per level) */\r\n        uint64 level;\r\n        /** PVP rating, every warrior starts with 100 rating */\r\n        int64 rating;\r\n        // 0 - idle\r\n        uint32 action;\r\n        /** Set to the index in the levelRequirements array (see CryptoWarriorBase.levelRequirements) that represents\r\n         *  the current dungeon level requirement for warrior. This starts at zero. */\r\n        uint32 dungeonIndex;\r\n    }\r\n}\r\n\r\ncontract CryptoWarriorBase is PermissionControll, PVPListenerInterface {\r\n\r\n\r\n    /// @dev The Arise event is fired when a new warrior created.\r\n    event Arise(address owner, uint256 warriorId, uint256 identity);\r\n\r\n    /// @dev ERC721 Transfer event\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    /*** CONSTANTS ***/\r\n    \r\n\tuint256 public constant IDLE = 0;\r\n    uint256 public constant PVE_BATTLE = 1;\r\n    uint256 public constant PVP_BATTLE = 2;\r\n    uint256 public constant TOURNAMENT_BATTLE = 3;\r\n    \r\n    //max pve dungeon level\r\n    uint256 public constant MAX_LEVEL = 25;\r\n    //how many points is needed to get 1 level\r\n    uint256 public constant POINTS_TO_LEVEL = 10;\r\n    \r\n    /// @dev Array contains PVE dungeon level requirements, each time warrior\r\n    /// completes dungeon, next level requirement is set, until 25lv (250points) is reached.\r\n    uint32[6] public dungeonRequirements = [\r\n        uint32(10),\r\n        uint32(30),\r\n        uint32(60),\r\n        uint32(100),\r\n        uint32(150),\r\n        uint32(250)\r\n    ];\r\n\r\n    uint256 public secondsPerBlock = 15;\r\n\r\n    /*** STORAGE ***/\r\n\r\n    /// @dev An array of warrior tokens\r\n    DataTypes.Warrior[] warriors;\r\n\r\n    /// @dev A mapping of warrior id to owner address\r\n    mapping (uint256 => address) public warriorToOwner;\r\n\r\n    // @dev A mapping from owner address to warriors count\r\n    mapping (address => uint256) ownersTokenCount;\r\n\r\n    /// @dev A mapping from warror id to approved address, that have permission to transfer specified warrior\r\n    mapping (uint256 => address) public warriorToApproved;\r\n\r\n    SaleClockAuction public saleAuction;\r\n    \r\n    \r\n    /// @dev Assigns ownership of a specific warrior to an address.\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        // Since the number of warriors is capped to '1 000 000' we can't overflow this\r\n        ownersTokenCount[_to]++;\r\n        // transfer ownership\r\n        warriorToOwner[_tokenId] = _to;\r\n        // When creating new warriors _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownersTokenCount[_from]--;\r\n            // clear any previously approved ownership exchange\r\n            delete warriorToApproved[_tokenId];\r\n        }\r\n        // Emit the transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @param _identity The warrior's genetic code.\r\n    /// @param _owner The initial owner of this warrior, must be non-zero\r\n    /// @param _cooldown pve cooldown block number\r\n    function _createWarrior(uint256 _identity, address _owner, uint256 _cooldown)\r\n        internal\r\n        returns (uint256) {\r\n        \t    \r\n        DataTypes.Warrior memory _warrior = DataTypes.Warrior({\r\n            identity : _identity,\r\n            cooldownEndBlock : uint64(_cooldown),\r\n            level : uint64(10),\r\n            rating : int64(100),\r\n            action : uint32(IDLE),\r\n            dungeonIndex : uint32(0)\r\n        });\r\n        uint256 newWarriorId = warriors.push(_warrior) - 1;\r\n        \r\n        require(newWarriorId == uint256(uint32(newWarriorId)));\r\n        \r\n        // emit the arise event\r\n        Arise(_owner, newWarriorId, _identity);\r\n        \r\n        // emit the Transfer event\r\n        _transfer(0, _owner, newWarriorId);\r\n\r\n        return newWarriorId;\r\n    }\r\n    \r\n\r\n    function setSecondsPerBlock(uint256 secs) external onlyAuthorized {\r\n        secondsPerBlock = secs;\r\n    }\r\n}\r\n\r\ncontract WarriorTokenImpl is CryptoWarriorBase, ERC721 {\r\n\r\n    string public constant name = \"CryptoWarriors\";\r\n    string public constant symbol = \"CW\";\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('transfer(address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('tokensOfOwner(address)'));\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return warriorToOwner[_tokenId] == _claimant;    \r\n    }\r\n\r\n    function _ownerApproved(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return warriorToOwner[_tokenId] == _claimant && warriorToApproved[_tokenId] == address(0);    \r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return warriorToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        warriorToApproved[_tokenId] = _approved;\r\n    }\r\n\t\r\n\t/// @notice ERC-721 method.\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownersTokenCount[_owner];\r\n    }\r\n\r\n\t/// @notice ERC-721 method.\r\n    function transfer(address _to, uint256 _tokenId) external whenNotPaused {\r\n        //sanity check\r\n        require(_to != address(0));\r\n        //can't transfer to core contract\r\n        require(_to != address(this));\r\n        //can't transfer to auction contract\r\n        require(_to != address(saleAuction));\r\n\r\n        // You can only send your own warrior.\r\n        require(_owns(msg.sender, _tokenId));\r\n        // Only idle warriors are allowed \r\n        require(warriors[_tokenId].action == IDLE);\r\n\r\n        // actually transfer warrior\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n\t/// @notice ERC-721 method.\r\n    function approve(address _to, uint256 _tokenId) external whenNotPaused {\r\n        // Only owner can approve\r\n        require(_owns(msg.sender, _tokenId));\r\n        // Only idle warriors are allowed \r\n        require(warriors[_tokenId].action == IDLE);\r\n\r\n        // actually approve\r\n        _approve(_tokenId, _to);\r\n\r\n        // Emit event.\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n\t/// @notice ERC-721 method.\r\n    function transferFrom(address _from, address _to, uint256 _tokenId)\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Sanity check\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any warriors (except very briefly\r\n        // after a miner warrior is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n        // Only idle warriors are allowed \r\n        require(warriors[_tokenId].action == IDLE);\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice ERC-721 method.\r\n    function totalSupply() public view returns (uint256) {\r\n        return warriors.length;\r\n    }\r\n\r\n    /// @notice ERC-721 method.\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address owner)\r\n    {\r\n        owner = warriorToOwner[_tokenId];\r\n\r\n        require(owner != address(0));\r\n    }\r\n\r\n    /// @notice ERC-721 method.\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalWarriors = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            uint256 warriorId;\r\n\r\n            for (warriorId = 0; warriorId < totalWarriors; warriorId++) {\r\n                if (warriorToOwner[warriorId] == _owner) {\r\n                    result[resultIndex] = warriorId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract CryptoWarriorPVE is WarriorTokenImpl {\r\n    \r\n    uint256 internal constant SUMMONING_SICKENESS = 12;\r\n    \r\n    uint256 internal constant PVE_COOLDOWN = 1 hours;\r\n    uint256 internal constant PVE_DURATION = 15 minutes;\r\n    \r\n    \r\n    /// @notice The payment required to use startPVEBattle().\r\n    uint256 public pveBattleFee = 10 finney;\r\n    uint256 public constant PVE_COMPENSATION = 2 finney;\r\n    \r\n\t/// @dev The address of contract that is used to implement warrior generation algorithm.\r\n    GeneratorInterface public generator;\r\n\r\n    /** @dev PVEStarted event. Emitted every time a warrior enters pve battle\r\n     *  @param owner Warrior owner\r\n     *  @param dungeonIndex Started dungeon index \r\n     *  @param warriorId Warrior ID that started PVE dungeon\r\n     *  @param battleEndBlock Block number, when started PVE dungeon will be completed\r\n     */\r\n    event PVEStarted(address owner, uint256 dungeonIndex, uint256 warriorId, uint256 battleEndBlock);\r\n\r\n    /** @dev PVEFinished event. Emitted every time a warrior finishes pve battle\r\n     *  @param owner Warrior owner\r\n     *  @param dungeonIndex Finished dungeon index\r\n     *  @param warriorId Warrior ID that completed dungeon\r\n     *  @param cooldownEndBlock Block number, when cooldown on PVE battle entrance will be over\r\n     *  @param rewardId Warrior ID which was granted to the owner as battle reward\r\n     */\r\n    event PVEFinished(address owner, uint256 dungeonIndex, uint256 warriorId, uint256 cooldownEndBlock, uint256 rewardId);\r\n\r\n\t/// @dev Update the address of the generator contract, can only be called by the Admin.\r\n    /// @param _address An address of a Generator contract instance to be used from this point forward.\r\n    function setGeneratorAddress(address _address) external onlyAdmin {\r\n        GeneratorInterface candidateContract = GeneratorInterface(_address);\r\n\r\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n        require(candidateContract.isGenerator());\r\n\r\n        // Set the new contract address\r\n        generator = candidateContract;\r\n    }\r\n    \r\n    function areUnique(uint32[] memory _warriorIds) internal pure returns(bool) {\r\n   \t    uint256 length = _warriorIds.length;\r\n   \t    uint256 j;\r\n        for(uint256 i = 0; i < length; i++) {\r\n\t        for(j = i + 1; j < length; j++) {\r\n\t            if (_warriorIds[i] == _warriorIds[j]) return false;\r\n\t        }\r\n        }\r\n        return true; \r\n   \t}\r\n\r\n    /// @dev Updates the minimum payment required for calling startPVE(). Can only\r\n    ///  be called by the admin address.\r\n    function setPVEBattleFee(uint256 _pveBattleFee) external onlyAdmin {\r\n        require(_pveBattleFee > PVE_COMPENSATION);\r\n        pveBattleFee = _pveBattleFee;\r\n    }\r\n    \r\n    /** @dev Returns PVE cooldown, after each battle, the warrior receives a \r\n     *  cooldown on the next entrance to the battle, cooldown depends on current warrior level,\r\n     *  which is multiplied by 1h. Special case: after receiving 25 lv, the cooldwon will be 14 days.\r\n     *  @param _levelPoints warrior level */\r\n    function getPVECooldown(uint256 _levelPoints) public pure returns (uint256) {\r\n        uint256 level = CryptoUtils._getLevel(_levelPoints);\r\n        if (level >= MAX_LEVEL) return (14 * 24 * PVE_COOLDOWN);//14 days\r\n        return (PVE_COOLDOWN * level);\r\n    }\r\n\r\n    /** @dev Returns PVE duration, each battle have a duration, which depends on current warrior level,\r\n     *  which is multiplied by 15 min. At the end of the duration, warrior is becoming eligible to receive\r\n     *  battle reward (new warrior in shiny armor)\r\n     *  @param _levelPoints warrior level points \r\n     */\r\n    function getPVEDuration(uint256 _levelPoints) public pure returns (uint256) {\r\n        return CryptoUtils._getLevel(_levelPoints) * PVE_DURATION;\r\n    }\r\n    \r\n    /// @dev Checks that a given warrior can participate in PVE battle. Requires that the\r\n    ///  current cooldown is finished and also checks that warrior is idle (does not participate in any action)\r\n    ///  and dungeon level requirement is satisfied\r\n    function _isReadyToPVE(DataTypes.Warrior _warrior) internal view returns (bool) {\r\n        return (_warrior.action == IDLE) && //is idle\r\n        (_warrior.cooldownEndBlock <= uint64(block.number)) && //no cooldown\r\n        (_warrior.level >= dungeonRequirements[_warrior.dungeonIndex]);//dungeon level requirement is satisfied\r\n    }\r\n    \r\n    /// @dev Internal utility function to initiate pve battle, assumes that all battle\r\n    ///  requirements have been checked.\r\n    function _triggerPVEStart(uint256 _warriorId) internal {\r\n        // Grab a reference to the warrior from storage.\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n        // Set warrior current action to pve battle\r\n        warrior.action = uint16(PVE_BATTLE);\r\n        // Set battle duration\r\n        warrior.cooldownEndBlock = uint64((getPVEDuration(warrior.level) / secondsPerBlock) + block.number);\r\n        // Emit the pve battle start event.\r\n        PVEStarted(msg.sender, warrior.dungeonIndex, _warriorId, warrior.cooldownEndBlock);\r\n    }\r\n    \r\n    /// @dev Starts PVE battle for specified warrior, \r\n    /// after battle, warrior owner will receive reward (Warrior) \r\n    /// @param _warriorId A Warrior ready to PVE battle.\r\n    function startPVE(uint256 _warriorId) external payable whenNotPaused {\r\n\t\t// Checks for payment.\r\n        require(msg.value >= pveBattleFee);\r\n\t\t\r\n\t\t// Caller must own the warrior.\r\n        require(_ownerApproved(msg.sender, _warriorId));\r\n\r\n        // Grab a reference to the warrior in storage.\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n\r\n        // Check that the warrior exists.\r\n        require(warrior.identity != 0);\r\n\r\n        // Check that the warrior is ready to battle\r\n        require(_isReadyToPVE(warrior));\r\n        \r\n        // All checks passed, let the battle begin!\r\n        _triggerPVEStart(_warriorId);\r\n        \r\n        // Calculate any excess funds included in msg.value. If the excess\r\n        // is anything worth worrying about, transfer it back to message owner.\r\n        // NOTE: We checked above that the msg.value is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 feeExcess = msg.value - pveBattleFee;\r\n\r\n        // Return the funds. This is not susceptible \r\n        // to a re-entry attack because of _isReadyToPVE check\r\n        // will fail\r\n        msg.sender.transfer(feeExcess);\r\n        //send battle fee to beneficiary\r\n        bankAddress.transfer(pveBattleFee - PVE_COMPENSATION);\r\n    }\r\n    \r\n    function _ariseWarrior(address _owner, DataTypes.Warrior storage _warrior) internal returns(uint256) {\r\n        uint256 identity = generator.generateWarrior(_warrior.identity, CryptoUtils._getLevel(_warrior.level), _warrior.cooldownEndBlock - 1, 0);\r\n        return _createWarrior(identity, _owner, block.number + (PVE_COOLDOWN * SUMMONING_SICKENESS / secondsPerBlock));\r\n    }\r\n\r\n\t/// @dev Internal utility function to finish pve battle, assumes that all battle\r\n    ///  finish requirements have been checked.\r\n    function _triggerPVEFinish(uint256 _warriorId) internal {\r\n        // Grab a reference to the warrior in storage.\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n        \r\n        // Set warrior current action to idle\r\n        warrior.action = uint16(IDLE);\r\n        \r\n        // Compute an estimation of the cooldown time in blocks (based on current level).\r\n        // and miner perc also reduces cooldown time by 4 times\r\n        warrior.cooldownEndBlock = uint64((getPVECooldown(warrior.level) / \r\n            CryptoUtils._getBonus(warrior.identity) / secondsPerBlock) + block.number);\r\n        \r\n        // cash completed dungeon index before increment\r\n        uint32 dungeonIndex = warrior.dungeonIndex;\r\n        // Increment the dungeon index, clamping it at 6, which is the length of the\r\n        // dungeonRequirements array. We could check the array size dynamically, but hard-coding\r\n        // this as a constant saves gas.\r\n        if (dungeonIndex < 6) {\r\n            warrior.dungeonIndex += 1;\r\n        }\r\n        \r\n        address owner = warriorToOwner[_warriorId];\r\n        // generate reward\r\n        uint256 arisenWarriorId = _ariseWarrior(owner, warrior);\r\n        //Emit event\r\n        PVEFinished(owner, dungeonIndex, _warriorId, warrior.cooldownEndBlock, arisenWarriorId);\r\n    }\r\n    \r\n    /**\r\n     * @dev finishPVE can be called after battle time is over,\r\n     * if checks are passed then battle result is computed,\r\n     * and new warrior is awarded to owner of specified _warriord ID.\r\n     * NB anyone can call this method, if they willing to pay the gas price\r\n     */\r\n    function finishPVE(uint32 _warriorId) external whenNotPaused {\r\n        // Grab a reference to the warrior in storage.\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n        \r\n        // Check that the warrior exists.\r\n        require(warrior.identity != 0);\r\n        \r\n        // Check that warrior participated in PVE battle action\r\n        require(warrior.action == PVE_BATTLE);\r\n        \r\n        // And the battle time is over\r\n        require(warrior.cooldownEndBlock <= uint64(block.number));\r\n        \r\n        // When the all checks done, calculate actual battle result\r\n        _triggerPVEFinish(_warriorId);\r\n        \r\n        //not susceptible to reetrance attack because of require(warrior.action == PVE_BATTLE)\r\n        //and require(warrior.cooldownEndBlock <= uint64(block.number));\r\n        msg.sender.transfer(PVE_COMPENSATION);\r\n    }\r\n    \r\n    /**\r\n     * @dev finishPVEBatch same as finishPVE but for multiple warrior ids.\r\n     * NB anyone can call this method, if they willing to pay the gas price\r\n     */\r\n    function finishPVEBatch(uint32[] _warriorIds) external whenNotPaused {\r\n        uint256 length = _warriorIds.length;\r\n        //check max number of bach finish pve\r\n        require(length <= 20);\r\n        uint256 blockNumber = block.number;\r\n        uint256 index;\r\n        //all warrior ids must be unique\r\n        require(areUnique(_warriorIds));\r\n        //check prerequisites\r\n        for(index = 0; index < length; index ++) {\r\n            DataTypes.Warrior storage warrior = warriors[_warriorIds[index]];\r\n\t\t\trequire(\r\n\t\t        // Check that the warrior exists.\r\n\t\t\t    warrior.identity != 0 &&\r\n\t\t        // Check that warrior participated in PVE battle action\r\n\t\t\t    warrior.action == PVE_BATTLE &&\r\n\t\t        // And the battle time is over\r\n\t\t\t    warrior.cooldownEndBlock <= blockNumber\r\n\t\t\t);\r\n        }\r\n        // When the all checks done, calculate actual battle result\r\n        for(index = 0; index < length; index ++) {\r\n            _triggerPVEFinish(_warriorIds[index]);\r\n        }\r\n        \r\n        //not susceptible to reetrance attack because of require(warrior.action == PVE_BATTLE)\r\n        //and require(warrior.cooldownEndBlock <= uint64(block.number));\r\n        msg.sender.transfer(PVE_COMPENSATION * length);\r\n    }\r\n}\r\n\r\ncontract CryptoWarriorPVP is CryptoWarriorPVE {\r\n\t\r\n\tPVPInterface public battleProvider;\r\n\t\r\n\t/// @dev Sets the reference to the sale auction.\r\n    /// @param _address - Address of sale contract.\r\n    function setBattleProviderAddress(address _address) external onlyAdmin {\r\n        PVPInterface candidateContract = PVPInterface(_address);\r\n\r\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n        require(candidateContract.isPVPProvider());\r\n\r\n        // Set the new contract address\r\n        battleProvider = candidateContract;\r\n    }\r\n    \r\n    function _packPVPData(uint256 _warriorId, DataTypes.Warrior storage warrior) internal view returns(uint256){\r\n        return CryptoUtils._packWarriorPvpData(warrior.identity, uint256(warrior.rating), 0, _warriorId, warrior.level);\r\n    }\r\n    \r\n    function _triggerPVPSignUp(uint32 _warriorId, uint256 fee) internal {\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n    \t\t\r\n\t\tuint256 packedWarrior = _packPVPData(_warriorId, warrior);\r\n        \r\n        // addPVPContender will throw if fee fails.\r\n        battleProvider.addPVPContender.value(fee)(msg.sender, packedWarrior);\r\n        \r\n        warrior.action = uint16(PVP_BATTLE);\r\n    }\r\n    \r\n    /*\r\n     * @title signUpForPVP enqueues specified warrior to PVP\r\n     * \r\n     * @dev When the owner enqueues his warrior for PvP, the warrior enters the waiting room.\r\n     * Once every 15 minutes, we check the warriors in the room and select pairs. \r\n     * For those warriors to whom we found couples, fighting is conducted and the results \r\n     * are recorded in the profile of the warrior. \r\n     */\r\n    function signUpForPVP(uint32 _warriorId) public payable whenNotPaused {//done\r\n\t\t// Caller must own the warrior.\r\n        require(_ownerApproved(msg.sender, _warriorId));\r\n        // Grab a reference to the warrior in storage.\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n        // sanity check\r\n        require(warrior.identity != 0);\r\n\r\n        // Check that the warrior is ready to battle\r\n        require(warrior.action == IDLE);\r\n        \r\n        // Define the current price of the auction.\r\n        uint256 fee = battleProvider.getPVPEntranceFee(warrior.level);\r\n        \r\n        // Checks for payment.\r\n        require(msg.value >= fee);\r\n        \r\n        // All checks passed, put the warrior to the queue!\r\n        _triggerPVPSignUp(_warriorId, fee);\r\n        \r\n        // Calculate any excess funds included in msg.value. If the excess\r\n        // is anything worth worrying about, transfer it back to message owner.\r\n        // NOTE: We checked above that the msg.value is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 feeExcess = msg.value - fee;\r\n\r\n        // Return the funds. This is not susceptible \r\n        // to a re-entry attack because of warrior.action == IDLE check\r\n        // will fail\r\n        msg.sender.transfer(feeExcess);\r\n    }\r\n\r\n    function _grandPVPWinnerReward(uint256 _warriorId) internal {\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n        // reward 1 level, add 10 level points\r\n        uint256 level = warrior.level;\r\n        if (level < (MAX_LEVEL * POINTS_TO_LEVEL)) {\r\n            level = level + POINTS_TO_LEVEL;\r\n\t\t\twarrior.level = uint64(level > (MAX_LEVEL * POINTS_TO_LEVEL) ? (MAX_LEVEL * POINTS_TO_LEVEL) : level);\r\n        }\r\n\t\t// give 100 rating for levelUp and 30 for win\r\n\t\twarrior.rating += 130;\r\n\t\t// mark warrior idle, so it can participate\r\n\t\t// in another actions\r\n\t\twarrior.action = uint16(IDLE);\r\n    }\r\n\r\n    function _grandPVPLoserReward(uint256 _warriorId) internal {\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n\t\t// reward 0.5 level\r\n\t\tuint256 oldLevel = warrior.level;\r\n\t\tuint256 level = oldLevel;\r\n\t\tif (level < (MAX_LEVEL * POINTS_TO_LEVEL)) {\r\n            level += (POINTS_TO_LEVEL / 2);\r\n\t\t\twarrior.level = uint64(level);\r\n        }\r\n\t\t// give 100 rating for levelUp if happens and -30 for lose\r\n\t\tint256 newRating = warrior.rating + (CryptoUtils._getLevel(level) > CryptoUtils._getLevel(oldLevel) ? int256(100 - 30) : int256(-30));\r\n\t\t// rating can't be less than 0 and more than 1000000000\r\n\t    warrior.rating = int64((newRating >= 0) ? (newRating > 1000000000 ? 1000000000 : newRating) : 0);\r\n        // mark warrior idle, so it can participate\r\n\t\t// in another actions\r\n\t    warrior.action = uint16(IDLE);\r\n    }\r\n    \r\n    function _grandPVPRewards(uint256[] memory warriorsData, uint256 matchingCount) internal {\r\n        for(uint256 id = 0; id < matchingCount; id += 2){\r\n            //\r\n            // winner, even ids are winners!\r\n            _grandPVPWinnerReward(CryptoUtils._unpackIdValue(warriorsData[id]));\r\n            //\r\n            // loser, they are odd...\r\n            _grandPVPLoserReward(CryptoUtils._unpackIdValue(warriorsData[id + 1]));\r\n        }\r\n\t}\r\n\r\n    // @dev Internal utility function to initiate pvp battle, assumes that all battle\r\n    ///  requirements have been checked.\r\n    function pvpFinished(uint256[] warriorsData, uint256 matchingCount) public {\r\n        //this method can be invoked only by battleProvider contract\r\n        require(msg.sender == address(battleProvider));\r\n        \r\n        _grandPVPRewards(warriorsData, matchingCount);\r\n    }\r\n    \r\n    function pvpContenderRemoved(uint32 _warriorId) public {\r\n        //this method can be invoked only by battleProvider contract\r\n        require(msg.sender == address(battleProvider));\r\n        //grab warrior storage reference\r\n        DataTypes.Warrior storage warrior = warriors[_warriorId];\r\n        //specified warrior must be in pvp state\r\n        require(warrior.action == PVP_BATTLE);\r\n        //all checks done\r\n        //set warrior state to IDLE\r\n        warrior.action = uint16(IDLE);\r\n    }\r\n}\r\n\r\ncontract CryptoWarriorTournament is CryptoWarriorPVP {\r\n    \r\n    uint256 internal constant GROUP_SIZE = 5;\r\n    \r\n    function _ownsAll(address _claimant, uint32[] memory _warriorIds) internal view returns (bool) {\r\n        uint256 length = _warriorIds.length;\r\n        for(uint256 i = 0; i < length; i++) {\r\n            if (!_ownerApproved(_claimant, _warriorIds[i])) return false;\r\n        }\r\n        return true;    \r\n    }\r\n    \r\n    function _isReadyToTournament(DataTypes.Warrior storage _warrior) internal view returns(bool){\r\n        return _warrior.level >= 50 && _warrior.action == IDLE;//must not participate in any action\r\n    }\r\n    \r\n    function _packTournamentData(uint32[] memory _warriorIds) internal view returns(uint256[] memory tournamentData) {\r\n        tournamentData = new uint256[](GROUP_SIZE);\r\n        uint256 warriorId;\r\n        for(uint256 i = 0; i < GROUP_SIZE; i++) {\r\n            warriorId = _warriorIds[i];\r\n            tournamentData[i] = _packPVPData(warriorId, warriors[warriorId]);   \r\n        }\r\n        return tournamentData;\r\n    }\r\n    \r\n    \r\n    // @dev Internal utility function to sign up to tournament, \r\n    // assumes that all battle requirements have been checked.\r\n    function _triggerTournamentSignUp(uint32[] memory _warriorIds, uint256 fee) internal {\r\n        //pack warrior ids into into uint256\r\n        uint256[] memory tournamentData = _packTournamentData(_warriorIds);\r\n        \r\n        for(uint256 i = 0; i < GROUP_SIZE; i++) {\r\n            // Set warrior current action to tournament battle\r\n            warriors[_warriorIds[i]].action = uint16(TOURNAMENT_BATTLE);\r\n        }\r\n\r\n        battleProvider.addTournamentContender.value(fee)(msg.sender, tournamentData);\r\n    }\r\n    \r\n    function signUpForTournament(uint32[] _warriorIds) public payable {\r\n        //\r\n        //check that there is enough funds to pay entrance fee\r\n        uint256 fee = battleProvider.getTournamentThresholdFee();\r\n        require(msg.value >= fee);\r\n        //\r\n        //check that warriors group is exactly of allowed size\r\n        require(_warriorIds.length == GROUP_SIZE);\r\n        //\r\n        //message sender must own all the specified warrior IDs\r\n        require(_ownsAll(msg.sender, _warriorIds));\r\n        //\r\n        //check all warriors are unique\r\n        require(areUnique(_warriorIds));\r\n        //\r\n        //check that all warriors are 25 lv and IDLE\r\n        for(uint256 i = 0; i < GROUP_SIZE; i ++) {\r\n            // Grab a reference to the warrior in storage.\r\n            require(_isReadyToTournament(warriors[_warriorIds[i]]));\r\n        }\r\n        \r\n        \r\n        //all checks passed, trigger sign up\r\n        _triggerTournamentSignUp(_warriorIds, fee);\r\n        \r\n        // Calculate any excess funds included in msg.value. If the excess\r\n        // is anything worth worrying about, transfer it back to message owner.\r\n        // NOTE: We checked above that the msg.value is greater than or\r\n        // equal to the fee so this cannot underflow.\r\n        uint256 feeExcess = msg.value - fee;\r\n\r\n        // Return the funds. This is not susceptible \r\n        // to a re-entry attack because of _isReadyToTournament check\r\n        // will fail\r\n        msg.sender.transfer(feeExcess);\r\n    }\r\n    \r\n    function _setIDLE(uint256 warriorIds) internal {\r\n        for(uint256 i = 0; i < GROUP_SIZE; i ++) {\r\n            warriors[CryptoUtils._unpackWarriorId(warriorIds, i)].action = uint16(IDLE);\r\n        }\r\n    }\r\n    \r\n    function _freeWarriors(uint256[] memory packedContenders) internal {\r\n        uint256 length = packedContenders.length;\r\n        for(uint256 i = 0; i < length; i ++) {\r\n            //set participants action to IDLE\r\n            _setIDLE(packedContenders[i]);\r\n        }\r\n    }\r\n    \r\n    function tournamentFinished(uint256[] packedContenders) public {\r\n        //this method can be invoked only by battleProvider contract\r\n        require(msg.sender == address(battleProvider));\r\n        \r\n        //grad rewards and set IDLE action\r\n        _freeWarriors(packedContenders);\r\n    }\r\n    \r\n}\r\n\r\ncontract CryptoWarriorAuction is CryptoWarriorTournament {\r\n\r\n    function setSaleAuctionAddress(address _address) external onlyAdmin {\r\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\r\n\r\n        require(candidateContract.isSaleClockAuction());\r\n\r\n        saleAuction = candidateContract;\r\n    }\r\n\r\n    function createSaleAuction(\r\n        uint256 _warriorId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // only owned and not approved to transfer warriors allowed \r\n        require(_ownerApproved(msg.sender, _warriorId));\r\n        // Ensure the warrior is not busy to prevent the auction\r\n        // contract creation while warrior is in any kind of battle (PVE, PVP, TOURNAMENT).\r\n        require(warriors[_warriorId].action == IDLE);\r\n        _approve(_warriorId, address(saleAuction));\r\n        // Actually create auction\r\n        saleAuction.createAuction(\r\n            _warriorId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n}\r\n\r\ncontract CryptoWarriorIssuer is CryptoWarriorAuction {\r\n    \r\n    // Limits the number of warriors the contract owner can ever create\r\n    uint256 public constant MINER_CREATION_LIMIT = 2880;//issue every 15min for one month\r\n\tuint256 internal constant MINER_PERK = 1;\r\n    // Constants for miner auctions.\r\n    uint256 public constant MINER_STARTING_PRICE = 100 finney;\r\n    uint256 public constant MINER_END_PRICE = 50 finney;\r\n    uint256 public constant MINER_AUCTION_DURATION = 1 days;\r\n\r\n    uint256 public minerCreatedCount;\r\n\r\n    /// @dev Generates a new miner warrior with MINER perk of COMMON rarity\r\n    ///  creates an auction for it.\r\n    function createMinerAuction() external onlyIssuer {\r\n        require(minerCreatedCount < MINER_CREATION_LIMIT);\r\n\t\t\r\n        minerCreatedCount++;\r\n\r\n        uint256 identity = generator.generateWarrior(minerCreatedCount, 0, block.number - 1, MINER_PERK);\r\n        uint256 warriorId = _createWarrior(identity, bankAddress, 0);\r\n        _approve(warriorId, address(saleAuction));\r\n\r\n        saleAuction.createAuction(\r\n            warriorId,\r\n            _computeNextMinerPrice(),\r\n            MINER_END_PRICE,\r\n            MINER_AUCTION_DURATION,\r\n            bankAddress\r\n        );\r\n    }\r\n\r\n    function _computeNextMinerPrice() internal view returns (uint256) {\r\n        uint256 avePrice = saleAuction.averageMinerSalePrice();\r\n\r\n        require(avePrice == uint256(uint128(avePrice)));\r\n\r\n        uint256 nextPrice = avePrice * 3 / 2;//confirmed\r\n\r\n        if (nextPrice < MINER_STARTING_PRICE) {\r\n            nextPrice = MINER_STARTING_PRICE;\r\n        }\r\n\r\n        return nextPrice;\r\n    }\r\n\r\n}\r\n\r\ncontract CryptoWarriorCore is CryptoWarriorIssuer {\r\n\r\n    function CryptoWarriorCore() public {\r\n        // Starts paused.\r\n        paused = true;\r\n\r\n        // the creator of the contract is the initial Admin\r\n        adminAddress = msg.sender;\r\n\r\n        // the creator of the contract is also the initial Issuer\r\n        issuerAddress = msg.sender;\r\n        \r\n        // the creator of the contract is also the initial Bank\r\n        bankAddress = msg.sender;\r\n    }\r\n    \r\n    function() external payable {\r\n        require(false);\r\n    }\r\n    \r\n    function unpause() public onlyAdmin whenPaused {\r\n        require(address(saleAuction) != address(0));\r\n        require(address(generator) != address(0));\r\n        require(address(battleProvider) != address(0));\r\n        require(newContractAddress == address(0));\r\n\r\n        // Actually unpause the contract.\r\n        super.unpause();\r\n    }\r\n    \r\n    function getBeneficiary() external view returns(address) {\r\n        return bankAddress;\r\n    }\r\n    \r\n    function isPVPListener() public pure returns (bool) {\r\n        return true;\r\n    }\r\n       \r\n    /**\r\n     *@param _warriorIds array of warriorIds, \r\n     * for those IDs warrior data will be packed into warriorsData array\r\n     *@return warriorsData packed warrior data\r\n     *@return stepSize number of fields in single warrior data */\r\n    function getWarriors(uint32[] _warriorIds) external view returns (uint256[] memory warriorsData, uint32 stepSize) {\r\n        stepSize = 6;\r\n        warriorsData = new uint256[](_warriorIds.length * stepSize);\r\n        for(uint32 i = 0; i < _warriorIds.length; i++) {\r\n            _setWarriorData(warriorsData, warriors[_warriorIds[i]], i * stepSize);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     *@param indexFrom index in global warrior storage (aka warriorId), \r\n     * from this index(including), warriors data will be gathered\r\n     *@param count Number of warriors to include in packed data\r\n     *@return warriorsData packed warrior data\r\n     *@return stepSize number of fields in single warrior data */\r\n    function getWarriorsFromIndex(uint32 indexFrom, uint32 count) external view returns (uint256[] memory warriorsData, uint32 stepSize) {\r\n        stepSize = 6;\r\n        //check length\r\n        uint256 lenght = (warriors.length - indexFrom >= count ? count : warriors.length - indexFrom);\r\n        \r\n        warriorsData = new uint256[](lenght * stepSize);\r\n        for(uint32 i = 0; i < lenght; i ++) {\r\n            _setWarriorData(warriorsData, warriors[indexFrom + i], i * stepSize);\r\n        }\r\n    }\r\n    \r\n    function getWarriorOwners(uint32[] _warriorIds) external view returns (address[] memory owners) {\r\n        uint256 lenght = _warriorIds.length;\r\n        owners = new address[](lenght);\r\n        \r\n        for(uint256 i = 0; i < lenght; i ++) {\r\n            owners[i] = warriorToOwner[_warriorIds[i]];\r\n        }\r\n    }\r\n    \r\n    \r\n    function _setWarriorData(uint256[] memory warriorsData, DataTypes.Warrior storage warrior, uint32 id) internal view {\r\n        warriorsData[id] = uint256(warrior.identity);//0\r\n        warriorsData[id + 1] = uint256(warrior.cooldownEndBlock);//1\r\n        warriorsData[id + 2] = uint256(warrior.level);//2\r\n        warriorsData[id + 3] = uint256(warrior.rating);//3\r\n        warriorsData[id + 4] = uint256(warrior.action);//4\r\n        warriorsData[id + 5] = uint256(warrior.dungeonIndex);//5\r\n    }\r\n    \r\n\tfunction getWarrior(uint256 _id) external view returns \r\n    (\r\n        uint256 identity, \r\n        uint256 cooldownEndBlock, \r\n        uint256 level,\r\n        uint256 rating, \r\n        uint256 action,\r\n        uint256 dungeonIndex\r\n    ) {\r\n        DataTypes.Warrior storage warrior = warriors[_id];\r\n\r\n        identity = uint256(warrior.identity);\r\n        cooldownEndBlock = uint256(warrior.cooldownEndBlock);\r\n        level = uint256(warrior.level);\r\n\t\trating = uint256(warrior.rating);\r\n\t\taction = uint256(warrior.action);\r\n\t\tdungeonIndex = uint256(warrior.dungeonIndex);\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract PVP is Pausable, PVPInterface {\r\n\t/* PVP BATLE */\r\n\t\r\n    /** list of packed warrior data that will participate in next PVP session. \r\n     *  Fixed size arry, to evade constant remove and push operations,\r\n     *  this approach reduces transaction costs involving queue modification. */\r\n    uint256[100] public pvpQueue;\r\n    //\r\n    //queue size\r\n    uint256 public pvpQueueSize = 0;\r\n    \r\n    // @dev A mapping from owner address to booty in WEI\r\n    //  booty is acquired in PVP and Tournament battles and can be\r\n    // withdrawn with grabBooty method by the owner of the loot\r\n    mapping (address => uint256) public ownerToBooty;\r\n    \r\n    // @dev A mapping from warrior id to owners address\r\n    mapping (uint256 => address) internal warriorToOwner;\r\n    \r\n    // An approximation of currently how many seconds are in between blocks.\r\n    uint256 internal secondsPerBlock = 15;\r\n    \r\n    // Cut owner takes from, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public pvpOwnerCut;\r\n    \r\n    // Values 0-10,000 map to 0%-100%\r\n    //this % of the total bets will be sent as \r\n    //a reward to address, that triggered finishPVP method\r\n    uint256 public pvpMaxIncentiveCut;\r\n    \r\n    /// @notice The payment base required to use startPVP().\r\n    // pvpBattleFee * (warrior.level / POINTS_TO_LEVEL)\r\n    uint256 internal pvpBattleFee = 20 finney;\r\n    \r\n    uint256 public constant PVP_INTERVAL = 15 minutes;\r\n    \r\n    uint256 public nextPVPBatleBlock = 0;\r\n    //number of WEI in hands of warrior owners\r\n    uint256 public totalBooty = 0;\r\n    \r\n    /* TOURNAMENT */\r\n    uint256 public constant FUND_GATHERING_TIME = 24 hours;\r\n    uint256 public constant ADMISSION_TIME = 12 hours;\r\n    uint256 public constant RATING_EXPAND_INTERVAL = 1 hours;\r\n    uint256 internal constant SAFETY_GAP = 5;\r\n    \r\n    uint256 internal constant MAX_INCENTIVE_REWARD = 200 finney;\r\n    \r\n    //tournamentContenders size\r\n    uint256 public tournamentQueueSize = 0;\r\n    \r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public tournamentBankCut;\r\n    \r\n   /** tournamentEndBlock, tournament is eligible to be finished only\r\n    *  after block.number >= tournamentEndBlock \r\n    *  it depends on FUND_GATHERING_TIME and ADMISSION_TIME */\r\n    uint256 public tournamentEndBlock;\r\n    \r\n    //number of WEI in tournament bank\r\n    uint256 public currentTournamentBank = 0;\r\n    uint256 public nextTournamentBank = 0;\r\n    \r\n    PVPListenerInterface internal pvpListener;\r\n    \r\n    /* EVENTS */\r\n    /** @dev TournamentScheduled event. Emitted every time a tournament is scheduled \r\n     *  @param tournamentEndBlock when block.number > tournamentEndBlock, then tournament \r\n     *         is eligible to be finished or rescheduled */\r\n    event TournamentScheduled(uint256 tournamentEndBlock);\r\n    \r\n    /** @dev PVPScheduled event. Emitted every time a tournament is scheduled \r\n     *  @param nextPVPBatleBlock when block.number > nextPVPBatleBlock, then pvp battle \r\n     *         is eligible to be finished or rescheduled */\r\n    event PVPScheduled(uint256 nextPVPBatleBlock);\r\n    \r\n    /** @dev PVPNewContender event. Emitted every time a warrior enqueues pvp battle\r\n     *  @param owner Warrior owner\r\n     *  @param warriorId Warrior ID that entered PVP queue\r\n     *  @param entranceFee fee in WEI warrior owner payed to enter PVP\r\n     */\r\n    event PVPNewContender(address owner, uint256 warriorId, uint256 entranceFee);\r\n\r\n    /** @dev PVPFinished event. Emitted every time a pvp battle is finished\r\n     *  @param warriorsData array of pairs of pvp warriors packed to uint256, even => winners, odd => losers \r\n     *  @param owners array of warrior owners, 1 to 1 with warriorsData, even => winners, odd => losers \r\n     *  @param matchingCount total number of warriors that fought in current pvp session and got rewards,\r\n     *  if matchingCount < participants.length then all IDs that are >= matchingCount will \r\n     *  remain in waiting room, until they are matched.\r\n     */\r\n    event PVPFinished(uint256[] warriorsData, address[] owners, uint256 matchingCount);\r\n    \r\n    /** @dev BootySendFailed event. Emitted every time address.send() function failed to transfer Ether to recipient\r\n     *  in this case recipient Ether is recorded to ownerToBooty mapping, so recipient can withdraw their booty manually\r\n     *  @param recipient address for whom send failed\r\n     *  @param amount number of WEI we failed to send\r\n     */\r\n    event BootySendFailed(address recipient, uint256 amount);\r\n    \r\n    /** @dev BootyGrabbed event\r\n     *  @param receiver address who grabbed his booty\r\n     *  @param amount number of WEI\r\n     */\r\n    event BootyGrabbed(address receiver, uint256 amount);\r\n    \r\n    /** @dev PVPContenderRemoved event. Emitted every time warrior is removed from pvp queue by its owner.\r\n     *  @param warriorId id of the removed warrior\r\n     */\r\n    event PVPContenderRemoved(uint256 warriorId, address owner);\r\n    \r\n    function PVP(uint256 _pvpCut, uint256 _tournamentBankCut, uint256 _pvpMaxIncentiveCut) public {\r\n        require((_tournamentBankCut + _pvpCut + _pvpMaxIncentiveCut) <= 10000);\r\n\t\tpvpOwnerCut = _pvpCut;\r\n\t\ttournamentBankCut = _tournamentBankCut;\r\n\t\tpvpMaxIncentiveCut = _pvpMaxIncentiveCut;\r\n    }\r\n    \r\n    /** @dev grabBooty sends to message sender his booty in WEI\r\n     */\r\n    function grabBooty() external {\r\n        uint256 booty = ownerToBooty[msg.sender];\r\n        require(booty > 0);\r\n        require(totalBooty >= booty);\r\n        \r\n        ownerToBooty[msg.sender] = 0;\r\n        totalBooty -= booty;\r\n        \r\n        msg.sender.transfer(booty);\r\n        //emit event\r\n        BootyGrabbed(msg.sender, booty);\r\n    }\r\n    \r\n    function safeSend(address _recipient, uint256 _amaunt) internal {\r\n\t\tuint256 failedBooty = sendBooty(_recipient, _amaunt);\r\n        if (failedBooty > 0) {\r\n\t\t\ttotalBooty += failedBooty;\r\n        }\r\n    }\r\n    \r\n    function sendBooty(address _recipient, uint256 _amaunt) internal returns(uint256) {\r\n        bool success = _recipient.send(_amaunt);\r\n        if (!success && _amaunt > 0) {\r\n            ownerToBooty[_recipient] += _amaunt;\r\n            BootySendFailed(_recipient, _amaunt);\r\n            return _amaunt;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    //@returns block number, after this block tournament is opened for admission\r\n    function getTournamentAdmissionBlock() public view returns(uint256) {\r\n        uint256 admissionInterval = (ADMISSION_TIME / secondsPerBlock);\r\n        return tournamentEndBlock < admissionInterval ? 0 : tournamentEndBlock - admissionInterval;\r\n    }\r\n    \r\n    \r\n    //schedules next turnament time(block)\r\n    function _scheduleTournament() internal {\r\n        //we can chedule only if there is nobody in tournament queue and\r\n        //time of tournament battle have passed\r\n\t\tif (tournamentQueueSize == 0 && tournamentEndBlock <= block.number) {\r\n\t\t    tournamentEndBlock = ((FUND_GATHERING_TIME / 2 + ADMISSION_TIME) / secondsPerBlock) + block.number;\r\n\t\t    TournamentScheduled(tournamentEndBlock);\r\n\t\t}\r\n    }\r\n    \r\n    /// @dev Updates the minimum payment required for calling startPVP(). Can only\r\n    ///  be called by the Owner address, and only if pvp queue is empty.\r\n    function setPVPEntranceFee(uint256 value) external onlyOwner {\r\n        require(pvpQueueSize == 0);\r\n        pvpBattleFee = value;\r\n    }\r\n    \r\n    //@returns PVP entrance fee for specified warrior level \r\n    //@param _levelPoints NB!\r\n    function getPVPEntranceFee(uint256 _levelPoints) external view returns(uint256) {\r\n        return pvpBattleFee * CryptoUtils._getLevel(_levelPoints);\r\n    }\r\n    \r\n    //level can only be > 0 and <= 25\r\n    function _getPVPFeeByLevel(uint256 _level) internal view returns(uint256) {\r\n        return pvpBattleFee * _level;\r\n    }\r\n    \r\n\t// @dev Computes warrior pvp reward\r\n    // @param _totalBet - total bet from both competitors.\r\n    function _computePVPReward(uint256 _totalBet, uint256 _contendersCut) internal pure returns (uint256){\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        // _totalBet max value is 1000 finney, and _contendersCut aka\r\n        // (10000 - pvpOwnerCut - tournamentBankCut - incentiveRewardCut) <= 10000 (see the require()\r\n        // statement in the BattleProvider constructor). The result of this\r\n        // function is always guaranteed to be <= _totalBet.\r\n        return _totalBet * _contendersCut / 10000;\r\n    }\r\n    \r\n    function _getPVPContendersCut(uint256 _incentiveCut) internal view returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        // (pvpOwnerCut + tournamentBankCut + pvpMaxIncentiveCut) <= 10000 (see the require()\r\n        // statement in the BattleProvider constructor). \r\n        // _incentiveCut is guaranteed to be >= 1 and <=  pvpMaxIncentiveCut\r\n        return (10000 - pvpOwnerCut - tournamentBankCut - _incentiveCut);\r\n    }\r\n\t\r\n\t// @dev Computes warrior pvp reward\r\n    // @param _totalSessionLoot - total bets from all competitors.\r\n    function _computeIncentiveReward(uint256 _totalSessionLoot, uint256 _incentiveCut) internal pure returns (uint256){\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        // _totalSessionLoot max value is 37500 finney, and \r\n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\r\n        // statement in the BattleProvider constructor). The result of this\r\n        // function is always guaranteed to be <= _totalSessionLoot.\r\n        return _totalSessionLoot * _incentiveCut / 10000;\r\n    }\r\n    \r\n\t///@dev computes incentive cut for specified loot, \r\n\t/// Values 0-10,000 map to 0%-100%\r\n\t/// max incentive reward cut is 5%, if it exceeds MAX_INCENTIVE_REWARD,\r\n\t/// then cut is lowered to be equal to MAX_INCENTIVE_REWARD.\r\n\t/// minimum cut is 0.01%\r\n    /// this % of the total bets will be sent as \r\n    /// a reward to address, that triggered finishPVP method\r\n    function _computeIncentiveCut(uint256 _totalSessionLoot, uint256 maxIncentiveCut) internal pure returns(uint256) {\r\n        uint256 result = _totalSessionLoot * maxIncentiveCut / 10000;\r\n        result = result <= MAX_INCENTIVE_REWARD ? maxIncentiveCut : MAX_INCENTIVE_REWARD * 10000 / _totalSessionLoot;\r\n        //min cut is 0.01%\r\n        return result > 0 ? result : 1;\r\n    }\r\n    \r\n    // @dev Computes warrior pvp reward\r\n    // @param _totalSessionLoot - total bets from all competitors.\r\n    function _computePVPBeneficiaryFee(uint256 _totalSessionLoot) internal view returns (uint256){\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        // _totalSessionLoot max value is 37500 finney, and \r\n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\r\n        // statement in the BattleProvider constructor). The result of this\r\n        // function is always guaranteed to be <= _totalSessionLoot.\r\n        return _totalSessionLoot * pvpOwnerCut / 10000;\r\n    }\r\n    \r\n    // @dev Computes tournament bank cut\r\n    // @param _totalSessionLoot - total session loot.\r\n    function _computeTournamentCut(uint256 _totalSessionLoot) internal view returns (uint256){\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        // _totalSessionLoot max value is 37500 finney, and \r\n        // (pvpOwnerCut + tournamentBankCut + incentiveRewardCut) <= 10000 (see the require()\r\n        // statement in the BattleProvider constructor). The result of this\r\n        // function is always guaranteed to be <= _totalSessionLoot.\r\n        return _totalSessionLoot * tournamentBankCut / 10000;\r\n    }\r\n\r\n    function indexOf(uint256 _warriorId) internal view returns(int256) {\r\n\t    uint256 length = uint256(pvpQueueSize);\r\n\t    for(uint256 i = 0; i < length; i ++) {\r\n\t        if(CryptoUtils._unpackIdValue(pvpQueue[i]) == _warriorId) return int256(i);\r\n\t    }\r\n\t    return -1;\r\n\t}\r\n    \r\n    function getPVPIncentiveReward(uint256[] memory matchingIds, uint256 matchingCount) internal view returns(uint256) {\r\n        uint256 sessionLoot = _computeTotalBooty(matchingIds, matchingCount);\r\n        \r\n        return _computeIncentiveReward(sessionLoot, _computeIncentiveCut(sessionLoot, pvpMaxIncentiveCut));\r\n    }\r\n    \r\n    function maxPVPContenders() external view returns(uint256){\r\n        return pvpQueue.length;\r\n    }\r\n    \r\n    function getPVPState() external view returns\r\n    (uint256 contendersCount, uint256 matchingCount, uint256 endBlock, uint256 incentiveReward)\r\n    {\r\n        uint256[] memory pvpData = _packPVPData();\r\n        \r\n    \tcontendersCount = pvpQueueSize;\r\n    \tmatchingCount = CryptoUtils._getMatchingIds(pvpData, PVP_INTERVAL, _computeCycleSkip(), RATING_EXPAND_INTERVAL);\r\n    \tendBlock = nextPVPBatleBlock;   \r\n    \tincentiveReward = getPVPIncentiveReward(pvpData, matchingCount);\r\n    }\r\n    \r\n    function canFinishPVP() external view returns(bool) {\r\n        return nextPVPBatleBlock <= block.number &&\r\n         CryptoUtils._getMatchingIds(_packPVPData(), PVP_INTERVAL, _computeCycleSkip(), RATING_EXPAND_INTERVAL) > 1;\r\n    }\r\n    \r\n    function _clarifyPVPSchedule() internal {\r\n        uint256 length = pvpQueueSize;\r\n\t\tuint256 currentBlock = block.number;\r\n\t\tuint256 nextBattleBlock = nextPVPBatleBlock;\r\n\t\t//if battle not scheduled, schedule battle\r\n\t\tif (nextBattleBlock <= currentBlock) {\r\n\t\t    //if queue not empty update cycles\r\n\t\t    if (length > 0) {\r\n\t\t\t\tuint256 packedWarrior;\r\n\t\t\t\tuint256 cycleSkip = _computeCycleSkip();\r\n\t\t        for(uint256 i = 0; i < length; i++) {\r\n\t\t            packedWarrior = pvpQueue[i];\r\n\t\t            //increase warrior iteration cycle\r\n\t\t            pvpQueue[i] = CryptoUtils._changeCycleValue(packedWarrior, CryptoUtils._unpackCycleValue(packedWarrior) + cycleSkip);\r\n\t\t        }\r\n\t\t    }\r\n\t\t    nextBattleBlock = (PVP_INTERVAL / secondsPerBlock) + currentBlock;\r\n\t\t    nextPVPBatleBlock = nextBattleBlock;\r\n\t\t    PVPScheduled(nextBattleBlock);\r\n\t\t//if pvp queue will be full and there is still too much time left, then let the battle begin! \r\n\t\t} else if (length + 1 == pvpQueue.length && (currentBlock + SAFETY_GAP * 2) < nextBattleBlock) {\r\n\t\t    nextBattleBlock = currentBlock + SAFETY_GAP;\r\n\t\t    nextPVPBatleBlock = nextBattleBlock;\r\n\t\t    PVPScheduled(nextBattleBlock);\r\n\t\t}\r\n    }\r\n    \r\n    /// @dev Internal utility function to initiate pvp battle, assumes that all battle\r\n    ///  requirements have been checked.\r\n    function _triggerNewPVPContender(address _owner, uint256 _packedWarrior, uint256 fee) internal {\r\n\r\n\t\t_clarifyPVPSchedule();\r\n        //number of pvp cycles the warrior is waiting for suitable enemy match\r\n        //increment every time when finishPVP is called and no suitable enemy match was found\r\n        _packedWarrior = CryptoUtils._changeCycleValue(_packedWarrior, 0);\r\n\t\t\r\n\t\t//record contender data\r\n\t\tpvpQueue[pvpQueueSize++] = _packedWarrior;\r\n\t\twarriorToOwner[CryptoUtils._unpackIdValue(_packedWarrior)] = _owner;\r\n\t\t\r\n\t\t//Emit event\r\n\t\tPVPNewContender(_owner, CryptoUtils._unpackIdValue(_packedWarrior), fee);\r\n    }\r\n    \r\n    function _noMatchingPairs() internal view returns(bool) {\r\n        uint256 matchingCount = CryptoUtils._getMatchingIds(_packPVPData(), uint64(PVP_INTERVAL), _computeCycleSkip(), uint64(RATING_EXPAND_INTERVAL));\r\n        return matchingCount == 0;\r\n    }\r\n    \r\n    /*\r\n     * @title startPVP enqueues specified warrior to PVP\r\n     * \r\n     * @dev When the owner enqueues his warrior for PvP, the warrior enters the waiting room.\r\n     * Once every 15 minutes, we check the warriors in the room and select pairs. \r\n     * For those warriors to whom we found couples, fighting is conducted and the results \r\n     * are recorded in the profile of the warrior. \r\n     */\r\n    function addPVPContender(address _owner, uint256 _packedWarrior) external payable whenNotPaused {\r\n\t\t// Caller must be pvpListener contract\r\n        require(msg.sender == address(pvpListener));\r\n\r\n        require(_owner != address(0));\r\n        //contender can be added only while PVP is scheduled in future\r\n        //or no matching warrior pairs found\r\n        require(nextPVPBatleBlock > block.number || _noMatchingPairs());\r\n        // Check that the warrior exists.\r\n        require(_packedWarrior != 0);\r\n        //owner must withdraw all loot before contending pvp\r\n        require(ownerToBooty[_owner] == 0);\r\n        //check that there is enough room for new participants\r\n        require(pvpQueueSize < pvpQueue.length);\r\n        // Checks for payment.\r\n        uint256 fee = _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarrior));\r\n        require(msg.value >= fee);\r\n        //\r\n        // All checks passed, put the warrior to the queue!\r\n        _triggerNewPVPContender(_owner, _packedWarrior, fee);\r\n    }\r\n    \r\n    function _packPVPData() internal view returns(uint256[] memory matchingIds) {\r\n        uint256 length = pvpQueueSize;\r\n        matchingIds = new uint256[](length);\r\n        for(uint256 i = 0; i < length; i++) {\r\n            matchingIds[i] = pvpQueue[i];\r\n        }\r\n        return matchingIds;\r\n    }\r\n    \r\n    function _computeTotalBooty(uint256[] memory _packedWarriors, uint256 matchingCount) internal view returns(uint256) {\r\n        //compute session booty\r\n        uint256 sessionLoot = 0;\r\n        for(uint256 i = 0; i < matchingCount; i++) {\r\n            sessionLoot += _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarriors[i]));\r\n        }\r\n        return sessionLoot;\r\n    }\r\n    \r\n    function _grandPVPRewards(uint256[] memory _packedWarriors, uint256 matchingCount) \r\n    internal returns(uint256)\r\n    {\r\n        uint256 booty = 0;\r\n        uint256 packedWarrior;\r\n        uint256 failedBooty = 0;\r\n        \r\n        uint256 sessionBooty = _computeTotalBooty(_packedWarriors, matchingCount);\r\n        uint256 incentiveCut = _computeIncentiveCut(sessionBooty, pvpMaxIncentiveCut);\r\n        uint256 contendersCut = _getPVPContendersCut(incentiveCut);\r\n        \r\n        for(uint256 id = 0; id < matchingCount; id++) {\r\n            //give reward to warriors that fought hard\r\n\t\t\t//winner, even ids are winners!\r\n\t\t\tpackedWarrior = _packedWarriors[id];\r\n\t\t\t//\r\n\t\t\t//give winner deserved booty 80% from both bets\r\n\t\t\t//must be computed before level reward!\r\n\t\t\tbooty = _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(packedWarrior)) + \r\n\t\t\t\t_getPVPFeeByLevel(CryptoUtils._unpackLevelValue(_packedWarriors[id + 1]));\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t//send reward to warrior owner\r\n\t\t\tfailedBooty += sendBooty(warriorToOwner[CryptoUtils._unpackIdValue(packedWarrior)], _computePVPReward(booty, contendersCut));\r\n\t\t\t//loser, they are odd...\r\n\t\t\t//skip them, as they deserve none!\r\n\t\t\tid ++;\r\n        }\r\n        failedBooty += sendBooty(pvpListener.getBeneficiary(), _computePVPBeneficiaryFee(sessionBooty));\r\n        \r\n        if (failedBooty > 0) {\r\n            totalBooty += failedBooty;\r\n        }\r\n        //if tournament admission start time not passed\r\n        //add tournament cut to current tournament bank,\r\n        //otherwise to next tournament bank\r\n        if (getTournamentAdmissionBlock() > block.number) {\r\n            currentTournamentBank += _computeTournamentCut(sessionBooty);\r\n        } else {\r\n            nextTournamentBank += _computeTournamentCut(sessionBooty);\r\n        }\r\n        \r\n        //compute incentive reward\r\n        return _computeIncentiveReward(sessionBooty, incentiveCut);\r\n    }\r\n    \r\n    function _increaseCycleAndTrimQueue(uint256[] memory matchingIds, uint256 matchingCount) internal {\r\n        uint32 length = uint32(matchingIds.length - matchingCount);  \r\n\t\tuint256 packedWarrior;\r\n\t\tuint256 skipCycles = _computeCycleSkip();\r\n        for(uint256 i = 0; i < length; i++) {\r\n            packedWarrior = matchingIds[matchingCount + i];\r\n            //increase warrior iteration cycle\r\n            pvpQueue[i] = CryptoUtils._changeCycleValue(packedWarrior, CryptoUtils._unpackCycleValue(packedWarrior) + skipCycles);\r\n        }\r\n        //trim queue\t\r\n        pvpQueueSize = length;\r\n    }\r\n    \r\n    function _computeCycleSkip() internal view returns(uint256) {\r\n        uint256 number = block.number;\r\n        return nextPVPBatleBlock > number ? 0 : (number - nextPVPBatleBlock) * secondsPerBlock / PVP_INTERVAL + 1;\r\n    }\r\n    \r\n    function _getWarriorOwners(uint256[] memory pvpData) internal view returns (address[] memory owners){\r\n        uint256 length = pvpData.length;\r\n        owners = new address[](length);\r\n        for(uint256 i = 0; i < length; i ++) {\r\n            owners[i] = warriorToOwner[CryptoUtils._unpackIdValue(pvpData[i])];\r\n        }\r\n    }\r\n    \r\n    // @dev Internal utility function to initiate pvp battle, assumes that all battle\r\n    ///  requirements have been checked.\r\n    function _triggerPVPFinish(uint256[] memory pvpData, uint256 matchingCount) internal returns(uint256){\r\n        //\r\n\t\t//compute battle results        \r\n        CryptoUtils._getPVPBattleResults(pvpData, matchingCount, nextPVPBatleBlock);\r\n        //\r\n        //mark not fought warriors and trim queue \r\n        _increaseCycleAndTrimQueue(pvpData, matchingCount);\r\n        //\r\n        //schedule next battle time\r\n        nextPVPBatleBlock = (PVP_INTERVAL / secondsPerBlock) + block.number;\r\n        \r\n        //\r\n        //schedule tournament\r\n        //if contendersCount is 0 and tournament not scheduled, schedule tournament\r\n        //NB MUST be before _grandPVPRewards()\r\n        _scheduleTournament();\r\n        // compute and grand rewards to warriors,\r\n        // put tournament cut to bank, not susceptible to reentry attack because of require(nextPVPBatleBlock <= block.number);\r\n        // and require(number of pairs > 1);\r\n        uint256 incentiveReward = _grandPVPRewards(pvpData, matchingCount);\r\n        //\r\n        //notify pvp listener contract\r\n        pvpListener.pvpFinished(pvpData, matchingCount);\r\n        \r\n        //\r\n        //fire event\r\n\t\tPVPFinished(pvpData, _getWarriorOwners(pvpData), matchingCount);\r\n        PVPScheduled(nextPVPBatleBlock);\r\n\t\t\r\n\t\treturn incentiveReward;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev finishPVP this method finds matches of warrior pairs\r\n     * in waiting room and computes result of their fights.\r\n     * \r\n     * The winner gets +1 level, the loser gets +0.5 level\r\n     * The winning player gets +130 rating\r\n\t * The losing player gets -30 or 70 rating (if warrior levelUps after battle) .\r\n     * can be called once in 15min.\r\n     * NB If the warrior is not picked up in an hour, then we expand the range \r\n     * of selection by 25 rating each hour.\r\n     */\r\n    function finishPVP() public whenNotPaused {\r\n        // battle interval is over\r\n        require(nextPVPBatleBlock <= block.number);\r\n        //\r\n\t    //match warriors\r\n        uint256[] memory pvpData = _packPVPData();\r\n        //match ids and sort them according to matching\r\n        uint256 matchingCount = CryptoUtils._getMatchingIds(pvpData, uint64(PVP_INTERVAL), _computeCycleSkip(), uint64(RATING_EXPAND_INTERVAL));\r\n\t\t// we have at least 1 matching battle pair\r\n        require(matchingCount > 1);\r\n        \r\n        // When the all checks done, calculate actual battle result\r\n        uint256 incentiveReward = _triggerPVPFinish(pvpData, matchingCount);\r\n        \r\n        //give reward for incentive\r\n        safeSend(msg.sender, incentiveReward);\r\n    }\r\n\r\n    // @dev Removes specified warrior from PVP queue\r\n    //  sets warrior free (IDLE) and returns pvp entrance fee to owner\r\n    // @notice This is a state-modifying function that can\r\n    //  be called while the contract is paused.\r\n    // @param _warriorId - ID of warrior in PVP queue\r\n    function removePVPContender(uint32 _warriorId) external{\r\n        uint256 queueSize = pvpQueueSize;\r\n        require(queueSize > 0);\r\n        // Caller must be owner of the specified warrior\r\n        require(warriorToOwner[_warriorId] == msg.sender);\r\n        //warrior must be in pvp queue\r\n        int256 warriorIndex = indexOf(_warriorId);\r\n        require(warriorIndex >= 0);\r\n        //grab warrior data\r\n        uint256 warriorData = pvpQueue[uint32(warriorIndex)];\r\n        //warrior cycle must be >= 4 (> than 1 hour)\r\n        require((CryptoUtils._unpackCycleValue(warriorData) + _computeCycleSkip()) >= 4);\r\n        \r\n        //remove from queue\r\n        if (uint256(warriorIndex) < queueSize - 1) {\r\n\t        pvpQueue[uint32(warriorIndex)] = pvpQueue[pvpQueueSize - 1];\r\n        }\r\n        pvpQueueSize --;\r\n        //notify battle listener\r\n        pvpListener.pvpContenderRemoved(_warriorId);\r\n        //return pvp bet\r\n        msg.sender.transfer(_getPVPFeeByLevel(CryptoUtils._unpackLevelValue(warriorData)));\r\n        //Emit event\r\n        PVPContenderRemoved(_warriorId, msg.sender);\r\n    }\r\n    \r\n    function getPVPCycles(uint32[] warriorIds) external view returns(uint32[]){\r\n        uint256 length = warriorIds.length;\r\n        uint32[] memory cycles = new uint32[](length);\r\n        int256 index;\r\n        uint256 skipCycles = _computeCycleSkip();\r\n\t    for(uint256 i = 0; i < length; i ++) {\r\n\t        index = indexOf(warriorIds[i]);\r\n\t        cycles[i] = index >= 0 ? uint32(CryptoUtils._unpackCycleValue(pvpQueue[uint32(index)]) + skipCycles) : 0;\r\n\t    }\r\n\t    return cycles;\r\n    }\r\n    \r\n    // @dev Remove all PVP contenders from PVP queue \r\n    //  and return all bets to warrior owners.\r\n    //  NB: this is emergency method, used only in f%#^@up situation\r\n    function removeAllPVPContenders() external onlyOwner whenPaused {\r\n        //remove all pvp contenders\r\n        uint256 length = pvpQueueSize;\r\n        \r\n        uint256 warriorData;\r\n        uint256 warriorId;\r\n        uint256 failedBooty;\r\n        address owner;\r\n        \r\n        pvpQueueSize = 0;\r\n        \r\n        for(uint256 i = 0; i < length; i++) {\r\n\t        //grab warrior data\r\n\t        warriorData = pvpQueue[i];\r\n\t        warriorId = CryptoUtils._unpackIdValue(warriorData);\r\n\t        //notify battle listener\r\n\t        pvpListener.pvpContenderRemoved(uint32(warriorId));\r\n\t        \r\n\t        owner = warriorToOwner[warriorId];\r\n\t        //return pvp bet\r\n\t        failedBooty += sendBooty(owner, _getPVPFeeByLevel(CryptoUtils._unpackLevelValue(warriorData)));\r\n        }\r\n        totalBooty += failedBooty;\r\n    }\r\n}\r\n\r\ncontract Tournament is PVP {\r\n\r\n    uint256 internal constant GROUP_SIZE = 5;\r\n    uint256 internal constant DATA_SIZE = 2;\r\n    uint256 internal constant THRESHOLD = 300;\r\n    \r\n  /** list of warrior IDs that will participate in next tournament. \r\n    *  Fixed size arry, to evade constant remove and push operations,\r\n    *  this approach reduces transaction costs involving array modification. */\r\n    uint256[160] public tournamentQueue;\r\n    \r\n    /**The cost of participation in the tournament is 1% of its current prize fund, \r\n     * money is added to the prize fund. measured in basis points (1/100 of a percent).\r\n     * Values 0-10,000 map to 0%-100% */\r\n    uint256 internal tournamentEntranceFeeCut = 100;\r\n    \r\n    // Values 0-10,000 map to 0%-100% => 20%\r\n    uint256 public tournamentOwnersCut;\r\n    uint256 public tournamentIncentiveCut;\r\n    \r\n     /** @dev TournamentNewContender event. Emitted every time a warrior enters tournament\r\n     *  @param owner Warrior owner\r\n     *  @param warriorIds 5 Warrior IDs that entered tournament, packed into one uint256\r\n     *  see CryptoUtils._packWarriorIds\r\n     */\r\n    event TournamentNewContender(address owner, uint256 warriorIds, uint256 entranceFee);\r\n    \r\n    /** @dev TournamentFinished event. Emitted every time a tournament is finished\r\n     *  @param owners array of warrior group owners packed to uint256\r\n     *  @param results number of wins for each group\r\n     *  @param tournamentBank current tournament bank\r\n     *  see CryptoUtils._packWarriorIds\r\n     */\r\n    event TournamentFinished(uint256[] owners, uint32[] results, uint256 tournamentBank);\r\n    \r\n    function Tournament(uint256 _pvpCut, uint256 _tournamentBankCut, \r\n    uint256 _pvpMaxIncentiveCut, uint256 _tournamentOwnersCut, uint256 _tournamentIncentiveCut) public\r\n    PVP(_pvpCut, _tournamentBankCut, _pvpMaxIncentiveCut) \r\n    {\r\n        require((_tournamentOwnersCut + _tournamentIncentiveCut) <= 10000);\r\n\t\t\r\n\t\ttournamentOwnersCut = _tournamentOwnersCut;\r\n\t\ttournamentIncentiveCut = _tournamentIncentiveCut;\r\n    }\r\n    \r\n    \r\n    \r\n    // @dev Computes incentive reward for launching tournament finishTournament()\r\n    // @param _tournamentBank\r\n    function _computeTournamentIncentiveReward(uint256 _currentBank, uint256 _incentiveCut) internal pure returns (uint256){\r\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\r\n        // and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\r\n        // statement in the Tournament constructor). The result of this\r\n        // function is always guaranteed to be <= _currentBank.\r\n        return _currentBank * _incentiveCut / 10000;\r\n    }\r\n    \r\n    function _computeTournamentContenderCut(uint256 _incentiveCut) internal view returns (uint256) {\r\n        // NOTE: (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\r\n        // statement in the Tournament constructor). The result of this\r\n        // function is always guaranteed to be <= _reward.\r\n        return 10000 - tournamentOwnersCut - _incentiveCut;\r\n    }\r\n    \r\n    function _computeTournamentBeneficiaryFee(uint256 _currentBank) internal view returns (uint256){\r\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\r\n        // and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\r\n        // statement in the Tournament constructor). The result of this\r\n        // function is always guaranteed to be <= _currentBank.\r\n        return _currentBank * tournamentOwnersCut / 10000;\r\n    }\r\n    \r\n    // @dev set tournament entrance fee cut, can be set only if\r\n    // tournament queue is empty\r\n    // @param _cut range from 0 - 10000, mapped to 0-100%\r\n    function setTournamentEntranceFeeCut(uint256 _cut) external onlyOwner {\r\n        //cut must be less or equal 100&\r\n        require(_cut <= 10000);\r\n        //tournament queue must be empty\r\n        require(tournamentQueueSize == 0);\r\n        //checks passed, set cut\r\n\t\ttournamentEntranceFeeCut = _cut;\r\n    }\r\n    \r\n    function getTournamentEntranceFee() external view returns(uint256) {\r\n        return currentTournamentBank * tournamentEntranceFeeCut / 10000;\r\n    }\r\n    \r\n    //@dev returns tournament entrance fee - 3% threshold\r\n    function getTournamentThresholdFee() public view returns(uint256) {\r\n        return currentTournamentBank * tournamentEntranceFeeCut * (10000 - THRESHOLD) / 10000 / 10000;\r\n    }\r\n    \r\n    //@dev returns max allowed tournament contenders, public because of internal use\r\n    function maxTournamentContenders() public view returns(uint256){\r\n        return tournamentQueue.length / DATA_SIZE;\r\n    }\r\n    \r\n    function canFinishTournament() external view returns(bool) {\r\n        return tournamentEndBlock <= block.number && tournamentQueueSize > 0;\r\n    }\r\n    \r\n    // @dev Internal utility function to sigin up to tournament, \r\n    // assumes that all battle requirements have been checked.\r\n    function _triggerNewTournamentContender(address _owner, uint256[] memory _tournamentData, uint256 _fee) internal {\r\n        //pack warrior ids into uint256\r\n        \r\n        currentTournamentBank += _fee;\r\n        \r\n        uint256 packedWarriorIds = CryptoUtils._packWarriorIds(_tournamentData);\r\n        //make composite warrior out of 5 warriors \r\n        uint256 combinedWarrior = CryptoUtils._combineWarriors(_tournamentData);\r\n        \r\n        //add to queue\r\n        //icrement tournament queue\r\n        uint256 size = tournamentQueueSize++ * DATA_SIZE;\r\n        //record tournament data\r\n\t\ttournamentQueue[size++] = packedWarriorIds;\r\n\t\ttournamentQueue[size++] = combinedWarrior;\r\n\t\twarriorToOwner[CryptoUtils._unpackWarriorId(packedWarriorIds, 0)] = _owner;\r\n\t\t//\r\n\t\t//Emit event\r\n\t\tTournamentNewContender(_owner, packedWarriorIds, _fee);\r\n    }\r\n    \r\n    function addTournamentContender(address _owner, uint256[] _tournamentData) external payable whenNotPaused{\r\n        // Caller must be pvpListener contract\r\n        require(msg.sender == address(pvpListener));\r\n        \r\n        require(_owner != address(0));\r\n        //\r\n        //check current tournament bank > 0\r\n        require(pvpBattleFee == 0 || currentTournamentBank > 0);\r\n        //\r\n        //check that there is enough funds to pay entrance fee\r\n        uint256 fee = getTournamentThresholdFee();\r\n        require(msg.value >= fee);\r\n        //owner must withdraw all booty before contending pvp\r\n        require(ownerToBooty[_owner] == 0);\r\n        //\r\n        //check that warriors group is exactly of allowed size\r\n        require(_tournamentData.length == GROUP_SIZE);\r\n        //\r\n        //check that there is enough room for new participants\r\n        require(tournamentQueueSize < maxTournamentContenders());\r\n        //\r\n        //check that admission started\r\n        require(block.number >= getTournamentAdmissionBlock());\r\n        //check that admission not ended\r\n        require(block.number <= tournamentEndBlock);\r\n        \r\n        //all checks passed, trigger sign up\r\n        _triggerNewTournamentContender(_owner, _tournamentData, fee);\r\n    }\r\n    \r\n    //@dev collect all combined warriors data\r\n    function getCombinedWarriors() internal view returns(uint256[] memory warriorsData) {\r\n        uint256 length = tournamentQueueSize;\r\n        warriorsData = new uint256[](length);\r\n        \r\n        for(uint256 i = 0; i < length; i ++) {\r\n            // Grab the combined warrior data in storage.\r\n            warriorsData[i] = tournamentQueue[i * DATA_SIZE + 1];\r\n        }\r\n        return warriorsData;\r\n    }\r\n    \r\n    function getTournamentState() external view returns\r\n    (uint256 contendersCount, uint256 bank, uint256 admissionStartBlock, uint256 endBlock, uint256 incentiveReward)\r\n    {\r\n    \tcontendersCount = tournamentQueueSize;\r\n    \tbank = currentTournamentBank;\r\n    \tadmissionStartBlock = getTournamentAdmissionBlock();   \r\n    \tendBlock = tournamentEndBlock;\r\n    \tincentiveReward = _computeTournamentIncentiveReward(bank, _computeIncentiveCut(bank, tournamentIncentiveCut));\r\n    }\r\n    \r\n    function _repackToCombinedIds(uint256[] memory _warriorsData) internal view {\r\n        uint256 length = _warriorsData.length;\r\n        for(uint256 i = 0; i < length; i ++) {\r\n            _warriorsData[i] = tournamentQueue[i * DATA_SIZE];\r\n        }\r\n    }\r\n    \r\n    // @dev Computes warrior pvp reward\r\n    // @param _totalBet - total bet from both competitors.\r\n    function _computeTournamentBooty(uint256 _currentBank, uint256 _contenderResult, uint256 _totalBattles) internal pure returns (uint256){\r\n        // NOTE: We don't use SafeMath (or similar) in this function because _currentBank max is equal ~ 20000000 finney,\r\n        // _totalBattles is guaranteed to be > 0 and <= 400, and (tournamentOwnersCut + tournamentIncentiveCut) <= 10000 (see the require()\r\n        // statement in the Tournament constructor). The result of this\r\n        // function is always guaranteed to be <= _reward.\r\n        // return _currentBank * (10000 - tournamentOwnersCut - _incentiveCut) * _result / 10000 / _totalBattles;\r\n        return _currentBank * _contenderResult / _totalBattles;\r\n        \r\n    }\r\n    \r\n    function _grandTournamentBooty(uint256 _warriorIds, uint256 _currentBank, uint256 _contenderResult, uint256 _totalBattles)\r\n    internal returns (uint256)\r\n    {\r\n        uint256 warriorId = CryptoUtils._unpackWarriorId(_warriorIds, 0);\r\n        address owner = warriorToOwner[warriorId];\r\n        uint256 booty = _computeTournamentBooty(_currentBank, _contenderResult, _totalBattles);\r\n        return sendBooty(owner, booty);\r\n    }\r\n    \r\n    function _grandTournamentRewards(uint256 _currentBank, uint256[] memory _warriorsData, uint32[] memory _results) internal returns (uint256){\r\n        uint256 length = _warriorsData.length;\r\n        uint256 totalBattles = CryptoUtils._getTournamentBattles(length) * 10000;//*10000 required for booty computation\r\n        uint256 incentiveCut = _computeIncentiveCut(_currentBank, tournamentIncentiveCut);\r\n        uint256 contenderCut = _computeTournamentContenderCut(incentiveCut);\r\n        \r\n        uint256 failedBooty = 0;\r\n        for(uint256 i = 0; i < length; i ++) {\r\n            //grand rewards\r\n            failedBooty += _grandTournamentBooty(_warriorsData[i], _currentBank, _results[i] * contenderCut, totalBattles);\r\n        }\r\n        //send beneficiary fee\r\n        failedBooty += sendBooty(pvpListener.getBeneficiary(), _computeTournamentBeneficiaryFee(_currentBank));\r\n        if (failedBooty > 0) {\r\n            totalBooty += failedBooty;\r\n        }\r\n        return _computeTournamentIncentiveReward(_currentBank, incentiveCut);\r\n    }\r\n    \r\n    function _repackToWarriorOwners(uint256[] memory warriorsData) internal view {\r\n        uint256 length = warriorsData.length;\r\n        for (uint256 i = 0; i < length; i ++) {\r\n            warriorsData[i] = uint256(warriorToOwner[CryptoUtils._unpackWarriorId(warriorsData[i], 0)]);\r\n        }\r\n    }\r\n    \r\n    function _triggerFinishTournament() internal returns(uint256){\r\n        //hold 10 random battles for each composite warrior\r\n        uint256[] memory warriorsData = getCombinedWarriors();\r\n        uint32[] memory results = CryptoUtils.getTournamentBattleResults(warriorsData, tournamentEndBlock - 1);\r\n        //repack combined warriors id\r\n        _repackToCombinedIds(warriorsData);\r\n        //notify pvp listener\r\n        pvpListener.tournamentFinished(warriorsData);\r\n        //reschedule\r\n        //clear tournament\r\n        tournamentQueueSize = 0;\r\n        //schedule new tournament\r\n        _scheduleTournament();\r\n        \r\n        uint256 currentBank = currentTournamentBank;\r\n        currentTournamentBank = 0;//nullify before sending to users\r\n        //grand rewards, not susceptible to reentry attack\r\n        //because of require(tournamentEndBlock <= block.number)\r\n        //and require(tournamentQueueSize > 0) and currentTournamentBank == 0\r\n        uint256 incentiveReward = _grandTournamentRewards(currentBank, warriorsData, results);\r\n        \r\n        currentTournamentBank = nextTournamentBank;\r\n        nextTournamentBank = 0;\r\n        \r\n        _repackToWarriorOwners(warriorsData);\r\n        \r\n        //emit event\r\n        TournamentFinished(warriorsData, results, currentBank);\r\n\r\n        return incentiveReward;\r\n    }\r\n    \r\n    function finishTournament() external whenNotPaused {\r\n        //make all the checks\r\n        // tournament is ready to be executed\r\n        require(tournamentEndBlock <= block.number);\r\n        // we have participants\r\n        require(tournamentQueueSize > 0);\r\n        \r\n        uint256 incentiveReward = _triggerFinishTournament();\r\n        \r\n        //give reward for incentive\r\n        safeSend(msg.sender, incentiveReward);\r\n    }\r\n    \r\n    \r\n    // @dev Remove all PVP contenders from PVP queue \r\n    //  and return all entrance fees to warrior owners.\r\n    //  NB: this is emergency method, used only in f%#^@up situation\r\n    function removeAllTournamentContenders() external onlyOwner whenPaused {\r\n        //remove all pvp contenders\r\n        uint256 length = tournamentQueueSize;\r\n        \r\n        uint256 warriorId;\r\n        uint256 failedBooty;\r\n        uint256 i;\r\n\r\n        uint256 fee;\r\n        uint256 bank = currentTournamentBank;\r\n        \r\n        uint256[] memory warriorsData = new uint256[](length);\r\n        //get tournament warriors\r\n        for(i = 0; i < length; i ++) {\r\n            warriorsData[i] = tournamentQueue[i * DATA_SIZE];\r\n        }\r\n        //notify pvp listener\r\n        pvpListener.tournamentFinished(warriorsData);\r\n        //return entrance fee to warrior owners\r\n     \tcurrentTournamentBank = 0;\r\n        tournamentQueueSize = 0;\r\n\r\n        for(i = length - 1; i >= 0; i --) {\r\n            //return entrance fee\r\n            warriorId = CryptoUtils._unpackWarriorId(warriorsData[i], 0);\r\n            //compute contender entrance fee\r\n\t\t\tfee = bank - (bank * 10000 / (tournamentEntranceFeeCut * (10000 - THRESHOLD) / 10000 + 10000));\r\n\t\t\t//return entrance fee to owner\r\n\t        failedBooty += sendBooty(warriorToOwner[warriorId], fee);\r\n\t        //subtract fee from bank, for next use\r\n\t        bank -= fee;\r\n        }\r\n        currentTournamentBank = bank;\r\n        totalBooty += failedBooty;\r\n    }\r\n}\r\n\r\ncontract BattleProvider is Tournament {\r\n    \r\n    function BattleProvider(address _pvpListener, uint256 _pvpCut, uint256 _tournamentCut, uint256 _incentiveCut, \r\n    uint256 _tournamentOwnersCut, uint256 _tournamentIncentiveCut) public \r\n    Tournament(_pvpCut, _tournamentCut, _incentiveCut, _tournamentOwnersCut, _tournamentIncentiveCut) \r\n    {\r\n        PVPListenerInterface candidateContract = PVPListenerInterface(_pvpListener);\r\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n        require(candidateContract.isPVPListener());\r\n        // Set the new contract address\r\n        pvpListener = candidateContract;\r\n        \r\n        paused = true;\r\n\r\n        // the creator of the contract is the initial owner\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    \r\n    // @dev Sanity check that allows us to ensure that we are pointing to the\r\n    // right BattleProvider in our setBattleProviderAddress() call.\r\n    function isPVPProvider() external pure returns (bool) {\r\n        return true;\r\n    }\r\n    \r\n    /// @dev Override unpause so it requires all external contract addresses\r\n    ///  to be set before contract can be unpaused.\r\n    /// @notice This is public rather than external so we can call super.unpause\r\n    ///  without using an expensive CALL.\r\n    function unpause() public onlyOwner whenPaused {\r\n        require(address(pvpListener) != address(0));\r\n\r\n        // Actually unpause the contract.\r\n        super.unpause();\r\n    }\r\n    \r\n    function setSecondsPerBlock(uint256 secs) external onlyOwner {\r\n        secondsPerBlock = secs;\r\n    }\r\n}\r\n\r\nlibrary CryptoUtils {\r\n   \r\n    /* CLASSES */\r\n    uint256 internal constant WARRIOR = 0;\r\n    uint256 internal constant ARCHER = 1;\r\n    uint256 internal constant MAGE = 2;\r\n    /* RARITIES */\r\n    uint256 internal constant COMMON = 1;\r\n    uint256 internal constant UNCOMMON = 2;\r\n    uint256 internal constant RARE = 3;\r\n    uint256 internal constant MYTHIC = 4;\r\n    uint256 internal constant LEGENDARY = 5;\r\n    uint256 internal constant UNIQUE = 6;\r\n    /* LIMITS */\r\n    uint256 internal constant CLASS_MECHANICS_MAX = 3;\r\n    uint256 internal constant RARITY_MAX = 6;\r\n    /*@dev range used for rarity chance computation */\r\n    uint256 internal constant RARITY_CHANCE_RANGE = 10000000;\r\n    uint256 internal constant POINTS_TO_LEVEL = 10;\r\n    /* ATTRIBUTE MASKS */\r\n    /*@dev range 0-9999 */\r\n    uint256 internal constant UNIQUE_MASK_0 = 1;\r\n    /*@dev range 0-9 */\r\n    uint256 internal constant RARITY_MASK_1 = UNIQUE_MASK_0 * 10000;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant CLASS_VIEW_MASK_2 = RARITY_MASK_1 * 10;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant BODY_COLOR_MASK_3 = CLASS_VIEW_MASK_2 * 1000;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant EYES_MASK_4 = BODY_COLOR_MASK_3 * 1000;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant MOUTH_MASK_5 = EYES_MASK_4 * 1000;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant HEIR_MASK_6 = MOUTH_MASK_5 * 1000;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant HEIR_COLOR_MASK_7 = HEIR_MASK_6 * 1000;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant ARMOR_MASK_8 = HEIR_COLOR_MASK_7 * 1000;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant WEAPON_MASK_9 = ARMOR_MASK_8 * 1000;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant HAT_MASK_10 = WEAPON_MASK_9 * 1000;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant RUNES_MASK_11 = HAT_MASK_10 * 1000;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant WINGS_MASK_12 = RUNES_MASK_11 * 100;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant PET_MASK_13 = WINGS_MASK_12 * 100;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant BORDER_MASK_14 = PET_MASK_13 * 100;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant BACKGROUND_MASK_15 = BORDER_MASK_14 * 100;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant INTELLIGENCE_MASK_16 = BACKGROUND_MASK_15 * 100;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant AGILITY_MASK_17 = INTELLIGENCE_MASK_16 * 100;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant STRENGTH_MASK_18 = AGILITY_MASK_17 * 100;\r\n    /*@dev range 0-9 */\r\n    uint256 internal constant CLASS_MECH_MASK_19 = STRENGTH_MASK_18 * 100;\r\n    /*@dev range 0-999 */\r\n    uint256 internal constant RARITY_BONUS_MASK_20 = CLASS_MECH_MASK_19 * 10;\r\n    /*@dev range 0-9 */\r\n    uint256 internal constant SPECIALITY_MASK_21 = RARITY_BONUS_MASK_20 * 1000;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant DAMAGE_MASK_22 = SPECIALITY_MASK_21 * 10;\r\n    /*@dev range 0-99 */\r\n    uint256 internal constant AURA_MASK_23 = DAMAGE_MASK_22 * 100;\r\n    /*@dev 20 decimals left */\r\n    uint256 internal constant BASE_MASK_24 = AURA_MASK_23 * 100;\r\n    \r\n    \r\n    /* SPECIAL PERKS */\r\n    uint256 internal constant MINER_PERK = 1;\r\n    \r\n    \r\n    /* PARAM INDEXES */\r\n    uint256 internal constant BODY_COLOR_MAX_INDEX_0 = 0;\r\n    uint256 internal constant EYES_MAX_INDEX_1 = 1;\r\n    uint256 internal constant MOUTH_MAX_2 = 2;\r\n    uint256 internal constant HAIR_MAX_3 = 3;\r\n    uint256 internal constant HEIR_COLOR_MAX_4 = 4;\r\n    uint256 internal constant ARMOR_MAX_5 = 5;\r\n    uint256 internal constant WEAPON_MAX_6 = 6;\r\n    uint256 internal constant HAT_MAX_7 = 7;\r\n    uint256 internal constant RUNES_MAX_8 = 8;\r\n    uint256 internal constant WINGS_MAX_9 = 9;\r\n    uint256 internal constant PET_MAX_10 = 10;\r\n    uint256 internal constant BORDER_MAX_11 = 11;\r\n    uint256 internal constant BACKGROUND_MAX_12 = 12;\r\n    uint256 internal constant UNIQUE_INDEX_13 = 13;\r\n    uint256 internal constant LEGENDARY_INDEX_14 = 14;\r\n    uint256 internal constant MYTHIC_INDEX_15 = 15;\r\n    uint256 internal constant RARE_INDEX_16 = 16;\r\n    uint256 internal constant UNCOMMON_INDEX_17 = 17;\r\n    uint256 internal constant UNIQUE_TOTAL_INDEX_18 = 18;\r\n    \r\n     /* PACK PVP DATA LOGIC */\r\n    //pvp data\r\n    uint256 internal constant CLASS_PACK_0 = 1;\r\n    uint256 internal constant RARITY_BONUS_PACK_1 = CLASS_PACK_0 * 10;\r\n    uint256 internal constant RARITY_PACK_2 = RARITY_BONUS_PACK_1 * 1000;\r\n    uint256 internal constant EXPERIENCE_PACK_3 = RARITY_PACK_2 * 10;\r\n    uint256 internal constant INTELLIGENCE_PACK_4 = EXPERIENCE_PACK_3 * 1000;\r\n    uint256 internal constant AGILITY_PACK_5 = INTELLIGENCE_PACK_4 * 100;\r\n    uint256 internal constant STRENGTH_PACK_6 = AGILITY_PACK_5 * 100;\r\n    uint256 internal constant BASE_DAMAGE_PACK_7 = STRENGTH_PACK_6 * 100;\r\n    uint256 internal constant PET_PACK_8 = BASE_DAMAGE_PACK_7 * 100;\r\n    uint256 internal constant AURA_PACK_9 = PET_PACK_8 * 100;\r\n    uint256 internal constant WARRIOR_ID_PACK_10 = AURA_PACK_9 * 100;\r\n    uint256 internal constant PVP_CYCLE_PACK_11 = WARRIOR_ID_PACK_10 * 10**10;\r\n    uint256 internal constant RATING_PACK_12 = PVP_CYCLE_PACK_11 * 10**10;\r\n    uint256 internal constant PVP_BASE_PACK_13 = RATING_PACK_12 * 10**10;//NB rating must be at the END!\r\n    \r\n    //tournament data\r\n    uint256 internal constant HP_PACK_0 = 1;\r\n    uint256 internal constant DAMAGE_PACK_1 = HP_PACK_0 * 10**12;\r\n    uint256 internal constant ARMOR_PACK_2 = DAMAGE_PACK_1 * 10**12;\r\n    uint256 internal constant DODGE_PACK_3 = ARMOR_PACK_2 * 10**12;\r\n    uint256 internal constant PENETRATION_PACK_4 = DODGE_PACK_3 * 10**12;\r\n    uint256 internal constant COMBINE_BASE_PACK_5 = PENETRATION_PACK_4 * 10**12;\r\n    \r\n    /* MISC CONSTANTS */\r\n    uint256 internal constant MAX_ID_SIZE = 10000000000;\r\n    int256 internal constant PRECISION = 1000000;\r\n    \r\n    uint256 internal constant BATTLES_PER_CONTENDER = 10;//10x100\r\n    uint256 internal constant BATTLES_PER_CONTENDER_SUM = BATTLES_PER_CONTENDER * 100;//10x100\r\n    \r\n    uint256 internal constant LEVEL_BONUSES = 98898174676155504541373431282523211917151413121110;\r\n    \r\n    //ucommon bonuses\r\n    uint256 internal constant BONUS_NONE = 0;\r\n    uint256 internal constant BONUS_HP = 1;\r\n    uint256 internal constant BONUS_ARMOR = 2;\r\n    uint256 internal constant BONUS_CRIT_CHANCE = 3;\r\n    uint256 internal constant BONUS_CRIT_MULT = 4;\r\n    uint256 internal constant BONUS_PENETRATION = 5;\r\n    //rare bonuses\r\n    uint256 internal constant BONUS_STR = 6;\r\n    uint256 internal constant BONUS_AGI = 7;\r\n    uint256 internal constant BONUS_INT = 8;\r\n    uint256 internal constant BONUS_DAMAGE = 9;\r\n    \r\n    //bonus value database, \r\n    uint256 internal constant BONUS_DATA = 16060606140107152000;\r\n    //pets database\r\n    uint256 internal constant PETS_DATA = 287164235573728325842459981692000;\r\n    \r\n    uint256 internal constant PET_AURA = 2;\r\n    uint256 internal constant PET_PARAM_1 = 1;\r\n    uint256 internal constant PET_PARAM_2 = 0;\r\n\r\n    /* GETTERS */\r\n\tfunction getUniqueValue(uint256 identity) internal pure returns(uint256){\r\n\t\treturn identity % RARITY_MASK_1;\r\n\t}\r\n\r\n    function getRarityValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % CLASS_VIEW_MASK_2) / RARITY_MASK_1;\r\n    }\r\n\r\n\tfunction getClassViewValue(uint256 identity) internal pure returns(uint256){\r\n\t\treturn (identity % BODY_COLOR_MASK_3) / CLASS_VIEW_MASK_2;\r\n\t}\r\n\r\n\tfunction getBodyColorValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % EYES_MASK_4) / BODY_COLOR_MASK_3;\r\n    }\r\n\r\n    function getEyesValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % MOUTH_MASK_5) / EYES_MASK_4;\r\n    }\r\n\r\n    function getMouthValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % HEIR_MASK_6) / MOUTH_MASK_5;\r\n    }\r\n\r\n    function getHairValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % HEIR_COLOR_MASK_7) / HEIR_MASK_6;\r\n    }\r\n\r\n    function getHairColorValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % ARMOR_MASK_8) / HEIR_COLOR_MASK_7;\r\n    }\r\n\r\n    function getArmorValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % WEAPON_MASK_9) / ARMOR_MASK_8;\r\n    }\r\n\r\n    function getWeaponValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % HAT_MASK_10) / WEAPON_MASK_9;\r\n    }\r\n\r\n    function getHatValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % RUNES_MASK_11) / HAT_MASK_10;\r\n    }\r\n\r\n    function getRunesValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % WINGS_MASK_12) / RUNES_MASK_11;\r\n    }\r\n\r\n    function getWingsValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % PET_MASK_13) / WINGS_MASK_12;\r\n    }\r\n\r\n    function getPetValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % BORDER_MASK_14) / PET_MASK_13;\r\n    }\r\n\r\n\tfunction getBorderValue(uint256 identity) internal pure returns(uint256){\r\n\t\treturn (identity % BACKGROUND_MASK_15) / BORDER_MASK_14;\r\n\t}\r\n\r\n\tfunction getBackgroundValue(uint256 identity) internal pure returns(uint256){\r\n\t\treturn (identity % INTELLIGENCE_MASK_16) / BACKGROUND_MASK_15;\r\n\t}\r\n\r\n    function getIntelligenceValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % AGILITY_MASK_17) / INTELLIGENCE_MASK_16;\r\n    }\r\n\r\n    function getAgilityValue(uint256 identity) internal pure returns(uint256){\r\n        return ((identity % STRENGTH_MASK_18) / AGILITY_MASK_17);\r\n    }\r\n\r\n    function getStrengthValue(uint256 identity) internal pure returns(uint256){\r\n        return ((identity % CLASS_MECH_MASK_19) / STRENGTH_MASK_18);\r\n    }\r\n\r\n    function getClassMechValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % RARITY_BONUS_MASK_20) / CLASS_MECH_MASK_19;\r\n    }\r\n\r\n    function getRarityBonusValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % SPECIALITY_MASK_21) / RARITY_BONUS_MASK_20;\r\n    }\r\n\r\n    function getSpecialityValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % DAMAGE_MASK_22) / SPECIALITY_MASK_21;\r\n    }\r\n    \r\n    function getDamageValue(uint256 identity) internal pure returns(uint256){\r\n        return (identity % AURA_MASK_23) / DAMAGE_MASK_22;\r\n    }\r\n\r\n    function getAuraValue(uint256 identity) internal pure returns(uint256){\r\n        return ((identity % BASE_MASK_24) / AURA_MASK_23);\r\n    }\r\n\r\n    /* SETTERS */\r\n    function _setUniqueValue0(uint256 value) internal pure returns(uint256){\r\n        require(value < RARITY_MASK_1);\r\n        return value * UNIQUE_MASK_0;\r\n    }\r\n\r\n    function _setRarityValue1(uint256 value) internal pure returns(uint256){\r\n        require(value < (CLASS_VIEW_MASK_2 / RARITY_MASK_1));\r\n        return value * RARITY_MASK_1;\r\n    }\r\n\r\n    function _setClassViewValue2(uint256 value) internal pure returns(uint256){\r\n        require(value < (BODY_COLOR_MASK_3 / CLASS_VIEW_MASK_2));\r\n        return value * CLASS_VIEW_MASK_2;\r\n    }\r\n\r\n    function _setBodyColorValue3(uint256 value) internal pure returns(uint256){\r\n        require(value < (EYES_MASK_4 / BODY_COLOR_MASK_3));\r\n        return value * BODY_COLOR_MASK_3;\r\n    }\r\n\r\n    function _setEyesValue4(uint256 value) internal pure returns(uint256){\r\n        require(value < (MOUTH_MASK_5 / EYES_MASK_4));\r\n        return value * EYES_MASK_4;\r\n    }\r\n\r\n    function _setMouthValue5(uint256 value) internal pure returns(uint256){\r\n        require(value < (HEIR_MASK_6 / MOUTH_MASK_5));\r\n        return value * MOUTH_MASK_5;\r\n    }\r\n\r\n    function _setHairValue6(uint256 value) internal pure returns(uint256){\r\n        require(value < (HEIR_COLOR_MASK_7 / HEIR_MASK_6));\r\n        return value * HEIR_MASK_6;\r\n    }\r\n\r\n    function _setHairColorValue7(uint256 value) internal pure returns(uint256){\r\n        require(value < (ARMOR_MASK_8 / HEIR_COLOR_MASK_7));\r\n        return value * HEIR_COLOR_MASK_7;\r\n    }\r\n\r\n    function _setArmorValue8(uint256 value) internal pure returns(uint256){\r\n        require(value < (WEAPON_MASK_9 / ARMOR_MASK_8));\r\n        return value * ARMOR_MASK_8;\r\n    }\r\n\r\n    function _setWeaponValue9(uint256 value) internal pure returns(uint256){\r\n        require(value < (HAT_MASK_10 / WEAPON_MASK_9));\r\n        return value * WEAPON_MASK_9;\r\n    }\r\n\r\n    function _setHatValue10(uint256 value) internal pure returns(uint256){\r\n        require(value < (RUNES_MASK_11 / HAT_MASK_10));\r\n        return value * HAT_MASK_10;\r\n    }\r\n\r\n    function _setRunesValue11(uint256 value) internal pure returns(uint256){\r\n        require(value < (WINGS_MASK_12 / RUNES_MASK_11));\r\n        return value * RUNES_MASK_11;\r\n    }\r\n\r\n    function _setWingsValue12(uint256 value) internal pure returns(uint256){\r\n        require(value < (PET_MASK_13 / WINGS_MASK_12));\r\n        return value * WINGS_MASK_12;\r\n    }\r\n\r\n    function _setPetValue13(uint256 value) internal pure returns(uint256){\r\n        require(value < (BORDER_MASK_14 / PET_MASK_13));\r\n        return value * PET_MASK_13;\r\n    }\r\n\r\n    function _setBorderValue14(uint256 value) internal pure returns(uint256){\r\n        require(value < (BACKGROUND_MASK_15 / BORDER_MASK_14));\r\n        return value * BORDER_MASK_14;\r\n    }\r\n\r\n    function _setBackgroundValue15(uint256 value) internal pure returns(uint256){\r\n        require(value < (INTELLIGENCE_MASK_16 / BACKGROUND_MASK_15));\r\n        return value * BACKGROUND_MASK_15;\r\n    }\r\n\r\n    function _setIntelligenceValue16(uint256 value) internal pure returns(uint256){\r\n        require(value < (AGILITY_MASK_17 / INTELLIGENCE_MASK_16));\r\n        return value * INTELLIGENCE_MASK_16;\r\n    }\r\n\r\n    function _setAgilityValue17(uint256 value) internal pure returns(uint256){\r\n        require(value < (STRENGTH_MASK_18 / AGILITY_MASK_17));\r\n        return value * AGILITY_MASK_17;\r\n    }\r\n\r\n    function _setStrengthValue18(uint256 value) internal pure returns(uint256){\r\n        require(value < (CLASS_MECH_MASK_19 / STRENGTH_MASK_18));\r\n        return value * STRENGTH_MASK_18;\r\n    }\r\n\r\n    function _setClassMechValue19(uint256 value) internal pure returns(uint256){\r\n        require(value < (RARITY_BONUS_MASK_20 / CLASS_MECH_MASK_19));\r\n        return value * CLASS_MECH_MASK_19;\r\n    }\r\n\r\n    function _setRarityBonusValue20(uint256 value) internal pure returns(uint256){\r\n        require(value < (SPECIALITY_MASK_21 / RARITY_BONUS_MASK_20));\r\n        return value * RARITY_BONUS_MASK_20;\r\n    }\r\n\r\n    function _setSpecialityValue21(uint256 value) internal pure returns(uint256){\r\n        require(value < (DAMAGE_MASK_22 / SPECIALITY_MASK_21));\r\n        return value * SPECIALITY_MASK_21;\r\n    }\r\n    \r\n    function _setDamgeValue22(uint256 value) internal pure returns(uint256){\r\n        require(value < (AURA_MASK_23 / DAMAGE_MASK_22));\r\n        return value * DAMAGE_MASK_22;\r\n    }\r\n\r\n    function _setAuraValue23(uint256 value) internal pure returns(uint256){\r\n        require(value < (BASE_MASK_24 / AURA_MASK_23));\r\n        return value * AURA_MASK_23;\r\n    }\r\n    \r\n    /* WARRIOR IDENTITY GENERATION */\r\n    function _computeRunes(uint256 _rarity) internal pure returns (uint256){\r\n        return _rarity > UNCOMMON ? _rarity - UNCOMMON : 0;// 1 + _random(0, max, hash, WINGS_MASK_12, RUNES_MASK_11) : 0;\r\n    }\r\n\r\n    function _computeWings(uint256 _rarity, uint256 max, uint256 hash) internal pure returns (uint256){\r\n        return _rarity > RARE ?  1 + _random(0, max, hash, PET_MASK_13, WINGS_MASK_12) : 0;\r\n    }\r\n\r\n    function _computePet(uint256 _rarity, uint256 max, uint256 hash) internal pure returns (uint256){\r\n        return _rarity > MYTHIC ? 1 + _random(0, max, hash, BORDER_MASK_14, PET_MASK_13) : 0;\r\n    }\r\n\r\n    function _computeBorder(uint256 _rarity) internal pure returns (uint256){\r\n        return _rarity >= COMMON ? _rarity - 1 : 0;\r\n    }\r\n\r\n    function _computeBackground(uint256 _rarity) internal pure returns (uint256){\r\n        return _rarity;\r\n    }\r\n    \r\n    function _unpackPetData(uint256 index) internal pure returns(uint256){\r\n        return (PETS_DATA % (1000 ** (index + 1)) / (1000 ** index));\r\n    }\r\n    \r\n    function _getPetBonus1(uint256 _pet) internal pure returns(uint256) {\r\n        return (_pet % (10 ** (PET_PARAM_1 + 1)) / (10 ** PET_PARAM_1));\r\n    }\r\n    \r\n    function _getPetBonus2(uint256 _pet) internal pure returns(uint256) {\r\n        return (_pet % (10 ** (PET_PARAM_2 + 1)) / (10 ** PET_PARAM_2));\r\n    }\r\n    \r\n    function _getPetAura(uint256 _pet) internal pure returns(uint256) {\r\n        return (_pet % (10 ** (PET_AURA + 1)) / (10 ** PET_AURA));\r\n    }\r\n    \r\n    function _getBattleBonus(uint256 _setBonusIndex, uint256 _currentBonusIndex, uint256 _petData, uint256 _warriorAuras, uint256 _petAuras) internal pure returns(int256) {\r\n        int256 bonus = 0;\r\n        if (_setBonusIndex == _currentBonusIndex) {\r\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION;\r\n        }\r\n        //add pet bonuses\r\n        if (_setBonusIndex == _getPetBonus1(_petData)) {\r\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\r\n        }\r\n        if (_setBonusIndex == _getPetBonus2(_petData)) {\r\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\r\n        }\r\n        //add warrior aura bonuses\r\n        if (isAuraSet(_warriorAuras, uint8(_setBonusIndex))) {//warriors receive half bonuses from auras\r\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION / 2;\r\n        }\r\n        //add pet aura bonuses\r\n        if (isAuraSet(_petAuras, uint8(_setBonusIndex))) {//pets receive full bonues from auras\r\n            bonus += int256(BONUS_DATA % (100 ** (_setBonusIndex + 1)) / (100 ** _setBonusIndex)) * PRECISION;\r\n        }\r\n        return bonus;\r\n    }\r\n    \r\n    function _computeRarityBonus(uint256 _rarity, uint256 hash) internal pure returns (uint256){\r\n        if (_rarity == UNCOMMON) {\r\n            return 1 + _random(0, BONUS_PENETRATION, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\r\n        }\r\n        if (_rarity == RARE) {\r\n            return 1 + _random(BONUS_PENETRATION, BONUS_DAMAGE, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\r\n        }\r\n        if (_rarity >= MYTHIC) {\r\n            return 1 + _random(0, BONUS_DAMAGE, hash, SPECIALITY_MASK_21, RARITY_BONUS_MASK_20);\r\n        }\r\n        return BONUS_NONE;\r\n    }\r\n\r\n    function _computeAura(uint256 _rarity, uint256 hash) internal pure returns (uint256){\r\n        if (_rarity >= MYTHIC) {\r\n            return 1 + _random(0, BONUS_DAMAGE, hash, BASE_MASK_24, AURA_MASK_23);\r\n        }\r\n        return BONUS_NONE;\r\n    }\r\n    \r\n\tfunction _computeRarity(uint256 _reward, uint256 _unique, uint256 _legendary, \r\n\t    uint256 _mythic, uint256 _rare, uint256 _uncommon) internal pure returns(uint256){\r\n\t        \r\n        uint256 range = _unique + _legendary + _mythic + _rare + _uncommon;\r\n        if (_reward >= range) return COMMON; // common\r\n        if (_reward >= (range = (range - _uncommon))) return UNCOMMON;\r\n        if (_reward >= (range = (range - _rare))) return RARE;\r\n        if (_reward >= (range = (range - _mythic))) return MYTHIC;\r\n        if (_reward >= (range = (range - _legendary))) return LEGENDARY;\r\n        if (_reward < range) return UNIQUE;\r\n        return COMMON;\r\n    }\r\n    \r\n    function _computeUniqueness(uint256 _rarity, uint256 nextUnique) internal pure returns (uint256){\r\n        return _rarity == UNIQUE ? nextUnique : 0;\r\n    }\r\n    \r\n    /* identity packing */\r\n    /* @returns bonus value which depends on speciality value,\r\n     * if speciality == 1 (miner), then bonus value will be equal 4,\r\n     * otherwise 1\r\n     */\r\n    function _getBonus(uint256 identity) internal pure returns(uint256){\r\n        return getSpecialityValue(identity) == MINER_PERK ? 4 : 1;\r\n    }\r\n    \r\n\r\n    function _computeAndSetBaseParameters16_18_22(uint256 _hash) internal pure returns (uint256, uint256){\r\n        uint256 identity = 0;\r\n\r\n        uint256 damage = 35 + _random(0, 21, _hash, AURA_MASK_23, DAMAGE_MASK_22);\r\n        \r\n        uint256 strength = 45 + _random(0, 26, _hash, CLASS_MECH_MASK_19, STRENGTH_MASK_18);\r\n        uint256 agility = 15 + (125 - damage - strength);\r\n        uint256 intelligence = 155 - strength - agility - damage;\r\n        (strength, agility, intelligence) = _shuffleParams(strength, agility, intelligence, _hash);\r\n        \r\n        identity += _setStrengthValue18(strength);\r\n        identity += _setAgilityValue17(agility);\r\n\t\tidentity += _setIntelligenceValue16(intelligence);\r\n\t\tidentity += _setDamgeValue22(damage);\r\n        \r\n        uint256 classMech = strength > agility ? (strength > intelligence ? WARRIOR : MAGE) : (agility > intelligence ? ARCHER : MAGE);\r\n        return (identity, classMech);\r\n    }\r\n    \r\n    function _shuffleParams(uint256 param1, uint256 param2, uint256 param3, uint256 _hash) internal pure returns(uint256, uint256, uint256) {\r\n        uint256 temp = param1;\r\n        if (_hash % 2 == 0) {\r\n            temp = param1;\r\n            param1 = param2;\r\n            param2 = temp;\r\n        }\r\n        if ((_hash / 10 % 2) == 0) {\r\n            temp = param2;\r\n            param2 = param3;\r\n            param3 = temp;\r\n        }\r\n        if ((_hash / 100 % 2) == 0) {\r\n            temp = param1;\r\n            param1 = param2;\r\n            param2 = temp;\r\n        }\r\n        return (param1, param2, param3);\r\n    }\r\n    \r\n    \r\n    /* RANDOM */\r\n    function _random(uint256 _min, uint256 _max, uint256 _hash, uint256 _reminder, uint256 _devider) internal pure returns (uint256){\r\n        return ((_hash % _reminder) / _devider) % (_max - _min) + _min;\r\n    }\r\n\r\n    function _random(uint256 _min, uint256 _max, uint256 _hash) internal pure returns (uint256){\r\n        return _hash % (_max - _min) + _min;\r\n    }\r\n\r\n    function _getTargetBlock(uint256 _targetBlock) internal view returns(uint256){\r\n        uint256 currentBlock = block.number;\r\n        uint256 target = currentBlock - (currentBlock % 256) + (_targetBlock % 256);\r\n        if (target >= currentBlock) {\r\n            return (target - 256);\r\n        }\r\n        return target;\r\n    }\r\n    \r\n    function _getMaxRarityChance() internal pure returns(uint256){\r\n        return RARITY_CHANCE_RANGE;\r\n    }\r\n    \r\n    function generateWarrior(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 specialPerc, uint32[19] memory params) internal view returns (uint256) {\r\n        _targetBlock = _getTargetBlock(_targetBlock);\r\n        \r\n        uint256 identity;\r\n        uint256 hash = uint256(keccak256(block.blockhash(_targetBlock), _heroIdentity, block.coinbase, block.difficulty));\r\n        //0 _heroLevel produces warriors of COMMON rarity\r\n        uint256 rarityChance = _heroLevel == 0 ? RARITY_CHANCE_RANGE : \r\n        \t_random(0, RARITY_CHANCE_RANGE, hash) / (_heroLevel * _getBonus(_heroIdentity)); // 0 - 10 000 000\r\n        uint256 rarity = _computeRarity(rarityChance, \r\n            params[UNIQUE_INDEX_13],params[LEGENDARY_INDEX_14], params[MYTHIC_INDEX_15], params[RARE_INDEX_16], params[UNCOMMON_INDEX_17]);\r\n            \r\n        uint256 classMech;\r\n        \r\n        // start\r\n        (identity, classMech) = _computeAndSetBaseParameters16_18_22(hash);\r\n        \r\n        identity += _setUniqueValue0(_computeUniqueness(rarity, params[UNIQUE_TOTAL_INDEX_18] + 1));\r\n        identity += _setRarityValue1(rarity);\r\n        identity += _setClassViewValue2(classMech); // 1 to 1 with classMech\r\n        \r\n        identity += _setBodyColorValue3(1 + _random(0, params[BODY_COLOR_MAX_INDEX_0], hash, EYES_MASK_4, BODY_COLOR_MASK_3));\r\n        identity += _setEyesValue4(1 + _random(0, params[EYES_MAX_INDEX_1], hash, MOUTH_MASK_5, EYES_MASK_4));\r\n        identity += _setMouthValue5(1 + _random(0, params[MOUTH_MAX_2], hash, HEIR_MASK_6, MOUTH_MASK_5));\r\n        identity += _setHairValue6(1 + _random(0, params[HAIR_MAX_3], hash, HEIR_COLOR_MASK_7, HEIR_MASK_6));\r\n        identity += _setHairColorValue7(1 + _random(0, params[HEIR_COLOR_MAX_4], hash, ARMOR_MASK_8, HEIR_COLOR_MASK_7));\r\n        identity += _setArmorValue8(1 + _random(0, params[ARMOR_MAX_5], hash, WEAPON_MASK_9, ARMOR_MASK_8));\r\n        identity += _setWeaponValue9(1 + _random(0, params[WEAPON_MAX_6], hash, HAT_MASK_10, WEAPON_MASK_9));\r\n        identity += _setHatValue10(_random(0, params[HAT_MAX_7], hash, RUNES_MASK_11, HAT_MASK_10));//removed +1\r\n        \r\n        identity += _setRunesValue11(_computeRunes(rarity));\r\n        identity += _setWingsValue12(_computeWings(rarity, params[WINGS_MAX_9], hash));\r\n        identity += _setPetValue13(_computePet(rarity, params[PET_MAX_10], hash));\r\n        identity += _setBorderValue14(_computeBorder(rarity)); // 1 to 1 with rarity\r\n        identity += _setBackgroundValue15(_computeBackground(rarity)); // 1 to 1 with rarity\r\n        \r\n        identity += _setClassMechValue19(classMech);\r\n\r\n        identity += _setRarityBonusValue20(_computeRarityBonus(rarity, hash));\r\n        identity += _setSpecialityValue21(specialPerc); // currently only miner (1)\r\n        \r\n        identity += _setAuraValue23(_computeAura(rarity, hash));\r\n        // end\r\n        return identity;\r\n    }\r\n    \r\n\tfunction _changeParameter(uint256 _paramIndex, uint32 _value, uint32[19] storage parameters) internal {\r\n\t\t//we can change only view parameters, and unique count in max range <= 100\r\n\t\trequire(_paramIndex >= BODY_COLOR_MAX_INDEX_0 && _paramIndex <= UNIQUE_INDEX_13);\r\n\t\t//we can NOT set pet, border and background values,\r\n\t\t//those values have special logic behind them\r\n\t\trequire(\r\n\t\t    _paramIndex != RUNES_MAX_8 && \r\n\t\t    _paramIndex != PET_MAX_10 && \r\n\t\t    _paramIndex != BORDER_MAX_11 && \r\n\t\t    _paramIndex != BACKGROUND_MAX_12\r\n\t\t);\r\n\t\t//value of bodyColor, eyes, mouth, hair, hairColor, armor, weapon, hat must be < 1000\r\n\t\trequire(_paramIndex > HAT_MAX_7 || _value < 1000);\r\n\t\t//value of wings,  must be < 100\r\n\t\trequire(_paramIndex > BACKGROUND_MAX_12 || _value < 100);\r\n\t\t//check that max total number of UNIQUE warriors that we can emit is not > 100\r\n\t\trequire(_paramIndex != UNIQUE_INDEX_13 || (_value + parameters[UNIQUE_TOTAL_INDEX_18]) <= 100);\r\n\t\t\r\n\t\tparameters[_paramIndex] = _value;\r\n    }\r\n    \r\n\tfunction _recordWarriorData(uint256 identity, uint32[19] storage parameters) internal {\r\n        uint256 rarity = getRarityValue(identity);\r\n        if (rarity == UNCOMMON) { // uncommon\r\n            parameters[UNCOMMON_INDEX_17]--;\r\n            return;\r\n        }\r\n        if (rarity == RARE) { // rare\r\n            parameters[RARE_INDEX_16]--;\r\n            return;\r\n        }\r\n        if (rarity == MYTHIC) { // mythic\r\n            parameters[MYTHIC_INDEX_15]--;\r\n            return;\r\n        }\r\n        if (rarity == LEGENDARY) { // legendary\r\n            parameters[LEGENDARY_INDEX_14]--;\r\n            return;\r\n        }\r\n        if (rarity == UNIQUE) { // unique\r\n            parameters[UNIQUE_INDEX_13]--;\r\n            parameters[UNIQUE_TOTAL_INDEX_18] ++;\r\n            return;\r\n        }\r\n    }\r\n    \r\n    function _validateIdentity(uint256 _identity, uint32[19] memory params) internal pure returns(bool){\r\n        uint256 rarity = getRarityValue(_identity);\r\n        require(rarity <= UNIQUE);\r\n        \r\n        require(\r\n            rarity <= COMMON ||//common \r\n            (rarity == UNCOMMON && params[UNCOMMON_INDEX_17] > 0) ||//uncommon\r\n            (rarity == RARE && params[RARE_INDEX_16] > 0) ||//rare\r\n            (rarity == MYTHIC && params[MYTHIC_INDEX_15] > 0) ||//mythic\r\n            (rarity == LEGENDARY && params[LEGENDARY_INDEX_14] > 0) ||//legendary\r\n            (rarity == UNIQUE && params[UNIQUE_INDEX_13] > 0)//unique\r\n        );\r\n        require(rarity != UNIQUE || getUniqueValue(_identity) > params[UNIQUE_TOTAL_INDEX_18]);\r\n        \r\n        //check battle parameters\r\n        require(\r\n            getStrengthValue(_identity) < 100 &&\r\n            getAgilityValue(_identity) < 100 &&\r\n            getIntelligenceValue(_identity) < 100 &&\r\n            getDamageValue(_identity) <= 55\r\n        );\r\n        require(getClassMechValue(_identity) <= MAGE);\r\n        require(getClassMechValue(_identity) == getClassViewValue(_identity));\r\n        require(getSpecialityValue(_identity) <= MINER_PERK);\r\n        require(getRarityBonusValue(_identity) <= BONUS_DAMAGE);\r\n        require(getAuraValue(_identity) <= BONUS_DAMAGE);\r\n        \r\n        //check view\r\n        require(getBodyColorValue(_identity) <= params[BODY_COLOR_MAX_INDEX_0]);\r\n        require(getEyesValue(_identity) <= params[EYES_MAX_INDEX_1]);\r\n        require(getMouthValue(_identity) <= params[MOUTH_MAX_2]);\r\n        require(getHairValue(_identity) <= params[HAIR_MAX_3]);\r\n        require(getHairColorValue(_identity) <= params[HEIR_COLOR_MAX_4]);\r\n        require(getArmorValue(_identity) <= params[ARMOR_MAX_5]);\r\n        require(getWeaponValue(_identity) <= params[WEAPON_MAX_6]);\r\n        require(getHatValue(_identity) <= params[HAT_MAX_7]);\r\n        require(getRunesValue(_identity) <= params[RUNES_MAX_8]);\r\n        require(getWingsValue(_identity) <= params[WINGS_MAX_9]);\r\n        require(getPetValue(_identity) <= params[PET_MAX_10]);\r\n        require(getBorderValue(_identity) <= params[BORDER_MAX_11]);\r\n        require(getBackgroundValue(_identity) <= params[BACKGROUND_MAX_12]);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /* UNPACK METHODS */\r\n    //common\r\n    function _unpackClassValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % RARITY_PACK_2 / CLASS_PACK_0);\r\n    }\r\n    \r\n    function _unpackRarityBonusValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % RARITY_PACK_2 / RARITY_BONUS_PACK_1);\r\n    }\r\n    \r\n    function _unpackRarityValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % EXPERIENCE_PACK_3 / RARITY_PACK_2);\r\n    }\r\n    \r\n    function _unpackExpValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % INTELLIGENCE_PACK_4 / EXPERIENCE_PACK_3);\r\n    }\r\n\r\n    function _unpackLevelValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % INTELLIGENCE_PACK_4) / (EXPERIENCE_PACK_3 * POINTS_TO_LEVEL);\r\n    }\r\n    \r\n    function _unpackIntelligenceValue(uint256 packedValue) internal pure returns(int256){\r\n        return int256(packedValue % AGILITY_PACK_5 / INTELLIGENCE_PACK_4);\r\n    }\r\n    \r\n    function _unpackAgilityValue(uint256 packedValue) internal pure returns(int256){\r\n        return int256(packedValue % STRENGTH_PACK_6 / AGILITY_PACK_5);\r\n    }\r\n    \r\n    function _unpackStrengthValue(uint256 packedValue) internal pure returns(int256){\r\n        return int256(packedValue % BASE_DAMAGE_PACK_7 / STRENGTH_PACK_6);\r\n    }\r\n\r\n    function _unpackBaseDamageValue(uint256 packedValue) internal pure returns(int256){\r\n        return int256(packedValue % PET_PACK_8 / BASE_DAMAGE_PACK_7);\r\n    }\r\n    \r\n    function _unpackPetValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % AURA_PACK_9 / PET_PACK_8);\r\n    }\r\n    \r\n    function _unpackAuraValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % WARRIOR_ID_PACK_10 / AURA_PACK_9);\r\n    }\r\n    //\r\n    //pvp unpack\r\n    function _unpackIdValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % PVP_CYCLE_PACK_11 / WARRIOR_ID_PACK_10);\r\n    }\r\n    \r\n    function _unpackCycleValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % RATING_PACK_12 / PVP_CYCLE_PACK_11);\r\n    }\r\n    \r\n    function _unpackRatingValue(uint256 packedValue) internal pure returns(uint256){\r\n        return (packedValue % PVP_BASE_PACK_13 / RATING_PACK_12);\r\n    }\r\n    \r\n    //max cycle skip value cant be more than 1000000000\r\n    function _changeCycleValue(uint256 packedValue, uint256 newValue) internal pure returns(uint256){\r\n        newValue = newValue > 1000000000 ? 1000000000 : newValue;\r\n        return packedValue - (_unpackCycleValue(packedValue) * PVP_CYCLE_PACK_11) + newValue * PVP_CYCLE_PACK_11;\r\n    }\r\n    \r\n    function _packWarriorCommonData(uint256 _identity, uint256 _experience) internal pure returns(uint256){\r\n        uint256 packedData = 0;\r\n        packedData += getClassMechValue(_identity) * CLASS_PACK_0;\r\n        packedData += getRarityBonusValue(_identity) * RARITY_BONUS_PACK_1;\r\n        packedData += getRarityValue(_identity) * RARITY_PACK_2;\r\n        packedData += _experience * EXPERIENCE_PACK_3;\r\n        packedData += getIntelligenceValue(_identity) * INTELLIGENCE_PACK_4;\r\n        packedData += getAgilityValue(_identity) * AGILITY_PACK_5;\r\n        packedData += getStrengthValue(_identity) * STRENGTH_PACK_6;\r\n        packedData += getDamageValue(_identity) * BASE_DAMAGE_PACK_7;\r\n        packedData += getPetValue(_identity) * PET_PACK_8;\r\n        \r\n        return packedData;\r\n    }\r\n    \r\n    function _packWarriorPvpData(uint256 _identity, uint256 _rating, uint256 _pvpCycle, uint256 _warriorId, uint256 _experience) internal pure returns(uint256){\r\n        uint256 packedData = _packWarriorCommonData(_identity, _experience);\r\n        packedData += _warriorId * WARRIOR_ID_PACK_10;\r\n        packedData += _pvpCycle * PVP_CYCLE_PACK_11;\r\n        //rating MUST have most significant value!\r\n        packedData += _rating * RATING_PACK_12;\r\n        return packedData;\r\n    }\r\n    \r\n    /* TOURNAMENT BATTLES */\r\n    \r\n    \r\n    function _packWarriorIds(uint256[] memory packedWarriors) internal pure returns(uint256){\r\n        uint256 packedIds = 0;\r\n        uint256 length = packedWarriors.length;\r\n        for(uint256 i = 0; i < length; i ++) {\r\n            packedIds += (MAX_ID_SIZE ** i) * _unpackIdValue(packedWarriors[i]);\r\n        }\r\n        return packedIds;\r\n    }\r\n\r\n    function _unpackWarriorId(uint256 packedIds, uint256 index) internal pure returns(uint256){\r\n        return (packedIds % (MAX_ID_SIZE ** (index + 1)) / (MAX_ID_SIZE ** index));\r\n    }\r\n    \r\n    function _packCombinedParams(int256 hp, int256 damage, int256 armor, int256 dodge, int256 penetration) internal pure returns(uint256) {\r\n        uint256 combinedWarrior = 0;\r\n        combinedWarrior += uint256(hp) * HP_PACK_0;\r\n        combinedWarrior += uint256(damage) * DAMAGE_PACK_1;\r\n        combinedWarrior += uint256(armor) * ARMOR_PACK_2;\r\n        combinedWarrior += uint256(dodge) * DODGE_PACK_3;\r\n        combinedWarrior += uint256(penetration) * PENETRATION_PACK_4;\r\n        return combinedWarrior;\r\n    }\r\n    \r\n    function _unpackProtectionParams(uint256 combinedWarrior) internal pure returns \r\n    (int256 hp, int256 armor, int256 dodge){\r\n        hp = int256(combinedWarrior % DAMAGE_PACK_1 / HP_PACK_0);\r\n        armor = int256(combinedWarrior % DODGE_PACK_3 / ARMOR_PACK_2);\r\n        dodge = int256(combinedWarrior % PENETRATION_PACK_4 / DODGE_PACK_3);\r\n    }\r\n    \r\n    function _unpackAttackParams(uint256 combinedWarrior) internal pure returns(int256 damage, int256 penetration) {\r\n        damage = int256(combinedWarrior % ARMOR_PACK_2 / DAMAGE_PACK_1);\r\n        penetration = int256(combinedWarrior % COMBINE_BASE_PACK_5 / PENETRATION_PACK_4);\r\n    }\r\n    \r\n    function _combineWarriors(uint256[] memory packedWarriors) internal pure returns (uint256) {\r\n        int256 hp;\r\n        int256 damage;\r\n\t\tint256 armor;\r\n\t\tint256 dodge;\r\n\t\tint256 penetration;\r\n\t\t\r\n\t\t(hp, damage, armor, dodge, penetration) = _computeCombinedParams(packedWarriors);\r\n        return _packCombinedParams(hp, damage, armor, dodge, penetration);\r\n    }\r\n    \r\n    function _computeCombinedParams(uint256[] memory packedWarriors) internal pure returns \r\n    (int256 totalHp, int256 totalDamage, int256 maxArmor, int256 maxDodge, int256 maxPenetration){\r\n        uint256 length = packedWarriors.length;\r\n        \r\n        int256 hp;\r\n\t\tint256 armor;\r\n\t\tint256 dodge;\r\n\t\tint256 penetration;\r\n\t\t\r\n\t\tuint256 warriorAuras;\r\n\t\tuint256 petAuras;\r\n\t\t(warriorAuras, petAuras) = _getAurasData(packedWarriors);\r\n\t\t\r\n\t\tuint256 packedWarrior;\r\n        for(uint256 i = 0; i < length; i ++) {\r\n            packedWarrior = packedWarriors[i];\r\n            \r\n            totalDamage += getDamage(packedWarrior, warriorAuras, petAuras);\r\n            \r\n            penetration = getPenetration(packedWarrior, warriorAuras, petAuras);\r\n            maxPenetration = maxPenetration > penetration ? maxPenetration : penetration;\r\n\t\t\t(hp, armor, dodge) = _getProtectionParams(packedWarrior, warriorAuras, petAuras);\r\n            totalHp += hp;\r\n            maxArmor = maxArmor > armor ? maxArmor : armor;\r\n            maxDodge = maxDodge > dodge ? maxDodge : dodge;\r\n        }\r\n    }\r\n    \r\n    function _getAurasData(uint256[] memory packedWarriors) internal pure returns(uint256 warriorAuras, uint256 petAuras) {\r\n        uint256 length = packedWarriors.length;\r\n        \r\n        warriorAuras = 0;\r\n        petAuras = 0;\r\n        \r\n        uint256 packedWarrior;\r\n        for(uint256 i = 0; i < length; i ++) {\r\n            packedWarrior = packedWarriors[i];\r\n            warriorAuras = enableAura(warriorAuras, (_unpackAuraValue(packedWarrior)));\r\n            petAuras = enableAura(petAuras, (_getPetAura(_unpackPetData(_unpackPetValue(packedWarrior)))));\r\n        }\r\n        warriorAuras = filterWarriorAuras(warriorAuras, petAuras);\r\n        return (warriorAuras, petAuras);\r\n    }\r\n    \r\n    // Get bit value at position\r\n    function isAuraSet(uint256 aura, uint256 auraIndex) internal pure returns (bool) {\r\n        return aura & (uint256(0x01) << auraIndex) != 0;\r\n    }\r\n    \r\n    // Set bit value at position\r\n    function enableAura(uint256 a, uint256 n) internal pure returns (uint256) {\r\n        return a | (uint256(0x01) << n);\r\n    }\r\n    \r\n    //switch off warrior auras that are enabled in pets auras, pet aura have priority\r\n    function filterWarriorAuras(uint256 _warriorAuras, uint256 _petAuras) internal pure returns(uint256) {\r\n        return (_warriorAuras & _petAuras) ^ _warriorAuras;\r\n    }\r\n  \r\n    function _getTournamentBattles(uint256 _numberOfContenders) internal pure returns(uint256) {\r\n        return (_numberOfContenders * BATTLES_PER_CONTENDER / 2);\r\n    }\r\n    \r\n    function getTournamentBattleResults(uint256[] memory combinedWarriors, uint256 _targetBlock) internal view returns (uint32[] memory results){\r\n        uint256 length = combinedWarriors.length;\r\n        results = new uint32[](length);\r\n\t\t\r\n\t\tint256 damage1;\r\n\t\tint256 penetration1;\r\n\t\t\r\n\t\tuint256 hash;\r\n\t\t\r\n\t\tuint256 randomIndex;\r\n\t\tuint256 exp = 0;\r\n\t\tuint256 i;\r\n\t\tuint256 result;\r\n        for(i = 0; i < length; i ++) {\r\n            (damage1, penetration1) = _unpackAttackParams(combinedWarriors[i]);\r\n            while(results[i] < BATTLES_PER_CONTENDER_SUM) {\r\n                //if we just started generate new random source\r\n                //or regenerate if we used all data from it\r\n                if (exp == 0 || exp > 73) {\r\n                    hash = uint256(keccak256(block.blockhash(_getTargetBlock(_targetBlock - i)), uint256(damage1) + now));\r\n                    exp = 0;\r\n                }\r\n                //we do not fight with self if there are other warriors\r\n                randomIndex = (_random(i + 1 < length ? i + 1 : i, length, hash, 1000 * 10**exp, 10**exp));\r\n                result = getTournamentBattleResult(damage1, penetration1, combinedWarriors[i],\r\n                    combinedWarriors[randomIndex], hash % (1000 * 10**exp) / 10**exp);\r\n                results[result == 1 ? i : randomIndex] += 101;//icrement battle count 100 and +1 win\r\n                results[result == 1 ? randomIndex : i] += 100;//increment only battle count 100 for loser\r\n                if (results[randomIndex] >= BATTLES_PER_CONTENDER_SUM) {\r\n                    if (randomIndex < length - 1) {\r\n                        _swapValues(combinedWarriors, results, randomIndex, length - 1);\r\n                    }\r\n                    length --;\r\n                }\r\n                exp++;\r\n            }\r\n        }\r\n        //filter battle count from results\r\n        length = combinedWarriors.length;\r\n        for(i = 0; i < length; i ++) {\r\n            results[i] = results[i] % 100;\r\n        }\r\n        \r\n        return results;\r\n    }\r\n    \r\n    function _swapValues(uint256[] memory combinedWarriors, uint32[] memory results, uint256 id1, uint256 id2) internal pure {\r\n        uint256 temp = combinedWarriors[id1];\r\n        combinedWarriors[id1] = combinedWarriors[id2];\r\n        combinedWarriors[id2] = temp;\r\n        temp = results[id1];\r\n        results[id1] = results[id2];\r\n        results[id2] = uint32(temp);\r\n    }\r\n\r\n    function getTournamentBattleResult(int256 damage1, int256 penetration1, uint256 combinedWarrior1, \r\n        uint256 combinedWarrior2, uint256 randomSource) internal pure returns (uint256)\r\n    {\r\n        int256 damage2;\r\n\t\tint256 penetration2;\r\n        \r\n\t\t(damage2, penetration2) = _unpackAttackParams(combinedWarrior1);\r\n\r\n\t\tint256 totalHp1 = getCombinedTotalHP(combinedWarrior1, penetration2);\r\n\t\tint256 totalHp2 = getCombinedTotalHP(combinedWarrior2, penetration1);\r\n        \r\n        return _getBattleResult(damage1 * getBattleRandom(randomSource, 1) / 100, damage2 * getBattleRandom(randomSource, 10) / 100, totalHp1, totalHp2, randomSource);\r\n    }\r\n    /* COMMON BATTLE */\r\n    \r\n    function _getBattleResult(int256 damage1, int256 damage2, int256 totalHp1, int256 totalHp2, uint256 randomSource)  internal pure returns (uint256){\r\n\t\ttotalHp1 = (totalHp1 * (PRECISION * PRECISION) / damage2);\r\n\t\ttotalHp2 = (totalHp2 * (PRECISION * PRECISION) / damage1);\r\n\t\t//if draw, let the coin decide who wins\r\n\t\tif (totalHp1 == totalHp2) return randomSource % 2 + 1;\r\n\t\treturn totalHp1 > totalHp2 ? 1 : 2;       \r\n    }\r\n    \r\n    function getCombinedTotalHP(uint256 combinedData, int256 enemyPenetration) internal pure returns(int256) {\r\n        int256 hp;\r\n\t\tint256 armor;\r\n\t\tint256 dodge;\r\n\t\t(hp, armor, dodge) = _unpackProtectionParams(combinedData);\r\n        \r\n        return _getTotalHp(hp, armor, dodge, enemyPenetration);\r\n    }\r\n    \r\n    function getTotalHP(uint256 packedData, uint256 warriorAuras, uint256 petAuras, int256 enemyPenetration) internal pure returns(int256) {\r\n        int256 hp;\r\n\t\tint256 armor;\r\n\t\tint256 dodge;\r\n\t\t(hp, armor, dodge) = _getProtectionParams(packedData, warriorAuras, petAuras);\r\n        \r\n        return _getTotalHp(hp, armor, dodge, enemyPenetration);\r\n    }\r\n    \r\n    function _getTotalHp(int256 hp, int256 armor, int256 dodge, int256 enemyPenetration) internal pure returns(int256) {\r\n        int256 piercingResult = (armor - enemyPenetration) < -(75 * PRECISION) ? -(75 * PRECISION) : (armor - enemyPenetration);\r\n        int256 mitigation = (PRECISION - piercingResult * PRECISION / (PRECISION + piercingResult / 100) / 100);\r\n        \r\n        return (hp * PRECISION / mitigation + (hp * dodge / (100 * PRECISION)));\r\n    }\r\n    \r\n    function _applyLevelBonus(int256 _value, uint256 _level) internal pure returns(int256) {\r\n        _level -= 1;\r\n        return int256(uint256(_value) * (LEVEL_BONUSES % (100 ** (_level + 1)) / (100 ** _level)) / 10);\r\n    }\r\n    \r\n    function _getProtectionParams(uint256 packedData, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256 hp, int256 armor, int256 dodge) {\r\n        uint256 rarityBonus = _unpackRarityBonusValue(packedData);\r\n        uint256 petData = _unpackPetData(_unpackPetValue(packedData));\r\n        int256 strength = _unpackStrengthValue(packedData) * PRECISION + _getBattleBonus(BONUS_STR, rarityBonus, petData, warriorAuras, petAuras);\r\n        int256 agility = _unpackAgilityValue(packedData) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\r\n        \r\n        hp = 100 * PRECISION + strength + 7 * strength / 10 + _getBattleBonus(BONUS_HP, rarityBonus, petData, warriorAuras, petAuras);//add bonus hp\r\n        hp = _applyLevelBonus(hp, _unpackLevelValue(packedData));\r\n\t\tarmor = (strength + 8 * strength / 10 + agility + _getBattleBonus(BONUS_ARMOR, rarityBonus, petData, warriorAuras, petAuras));//add bonus armor\r\n\t\tdodge = (2 * agility / 3);\r\n    }\r\n    \r\n    function getDamage(uint256 packedWarrior, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256) {\r\n        uint256 rarityBonus = _unpackRarityBonusValue(packedWarrior);\r\n        uint256 petData = _unpackPetData(_unpackPetValue(packedWarrior));\r\n        int256 agility = _unpackAgilityValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\r\n        int256 intelligence = _unpackIntelligenceValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_INT, rarityBonus, petData, warriorAuras, petAuras);\r\n\t\t\r\n\t\tint256 crit = (agility / 5 + intelligence / 4) + _getBattleBonus(BONUS_CRIT_CHANCE, rarityBonus, petData, warriorAuras, petAuras);\r\n\t\tint256 critMultiplier = (PRECISION + intelligence / 25) + _getBattleBonus(BONUS_CRIT_MULT, rarityBonus, petData, warriorAuras, petAuras);\r\n        \r\n        int256 damage = int256(_unpackBaseDamageValue(packedWarrior) * 3 * PRECISION / 2) + _getBattleBonus(BONUS_DAMAGE, rarityBonus, petData, warriorAuras, petAuras);\r\n        \r\n\t\treturn (_applyLevelBonus(damage, _unpackLevelValue(packedWarrior)) * (PRECISION + crit * critMultiplier / (100 * PRECISION))) / PRECISION;\r\n    }\r\n\r\n    function getPenetration(uint256 packedWarrior, uint256 warriorAuras, uint256 petAuras) internal pure returns(int256) {\r\n        uint256 rarityBonus = _unpackRarityBonusValue(packedWarrior);\r\n        uint256 petData = _unpackPetData(_unpackPetValue(packedWarrior));\r\n        int256 agility = _unpackAgilityValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_AGI, rarityBonus, petData, warriorAuras, petAuras);\r\n        int256 intelligence = _unpackIntelligenceValue(packedWarrior) * PRECISION + _getBattleBonus(BONUS_INT, rarityBonus, petData, warriorAuras, petAuras);\r\n\t\t\r\n\t\treturn (intelligence * 2 + agility + _getBattleBonus(BONUS_PENETRATION, rarityBonus, petData, warriorAuras, petAuras));\r\n    }\r\n    \r\n    /* BATTLE PVP */\r\n    \r\n    //@param randomSource must be >= 1000\r\n    function getBattleRandom(uint256 randmSource, uint256 _step) internal pure returns(int256){\r\n        return int256(100 + _random(0, 11, randmSource, 100 * _step, _step));\r\n    }\r\n    \r\n    uint256 internal constant NO_AURA = 0;\r\n    \r\n    function getPVPBattleResult(uint256 packedData1, uint256 packedData2, uint256 randmSource) internal pure returns (uint256){\r\n        uint256 petAura1 = _computePVPPetAura(packedData1);\r\n        uint256 petAura2 = _computePVPPetAura(packedData2);\r\n        \r\n        uint256 warriorAura1 = _computePVPWarriorAura(packedData1, petAura1);\r\n        uint256 warriorAura2 = _computePVPWarriorAura(packedData2, petAura2);\r\n        \r\n\t\tint256 damage1 = getDamage(packedData1, warriorAura1, petAura1) * getBattleRandom(randmSource, 1) / 100;\r\n        int256 damage2 = getDamage(packedData2, warriorAura2, petAura2) * getBattleRandom(randmSource, 10) / 100;\r\n\r\n\t\tint256 totalHp1;\r\n\t\tint256 totalHp2;\r\n\t\t(totalHp1, totalHp2) = _computeContendersTotalHp(packedData1, warriorAura1, petAura1, packedData2, warriorAura1, petAura1);\r\n        \r\n        return _getBattleResult(damage1, damage2, totalHp1, totalHp2, randmSource);\r\n    }\r\n    \r\n    function _computePVPPetAura(uint256 packedData) internal pure returns(uint256) {\r\n        return enableAura(NO_AURA, _getPetAura(_unpackPetData(_unpackPetValue(packedData))));\r\n    }\r\n    \r\n    function _computePVPWarriorAura(uint256 packedData, uint256 petAuras) internal pure returns(uint256) {\r\n        return filterWarriorAuras(enableAura(NO_AURA, _unpackAuraValue(packedData)), petAuras);\r\n    }\r\n    \r\n    function _computeContendersTotalHp(uint256 packedData1, uint256 warriorAura1, uint256 petAura1, uint256 packedData2, uint256 warriorAura2, uint256 petAura2) \r\n    internal pure returns(int256 totalHp1, int256 totalHp2) {\r\n\t\tint256 enemyPenetration = getPenetration(packedData2, warriorAura2, petAura2);\r\n\t\ttotalHp1 = getTotalHP(packedData1, warriorAura1, petAura1, enemyPenetration);\r\n\t\tenemyPenetration = getPenetration(packedData1, warriorAura1, petAura1);\r\n\t\ttotalHp2 = getTotalHP(packedData2, warriorAura1, petAura1, enemyPenetration);\r\n    }\r\n    \r\n    function getRatingRange(uint256 _pvpCycle, uint256 _pvpInterval, uint256 _expandInterval) internal pure returns (uint256){\r\n        return 50 + (_pvpCycle * _pvpInterval / _expandInterval * 25);\r\n    }\r\n    \r\n    function isMatching(int256 evenRating, int256 oddRating, int256 ratingGap) internal pure returns(bool) {\r\n        return evenRating <= (oddRating + ratingGap) && evenRating >= (oddRating - ratingGap);\r\n    }\r\n    \r\n    function sort(uint256[] memory data) internal pure {\r\n       quickSort(data, int(0), int(data.length - 1));\r\n    }\r\n    \r\n    function quickSort(uint256[] memory arr, int256 left, int256 right) internal pure {\r\n        int256 i = left;\r\n        int256 j = right;\r\n        if(i==j) return;\r\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\r\n        while (i <= j) {\r\n            while (arr[uint256(i)] < pivot) i++;\r\n            while (pivot < arr[uint256(j)]) j--;\r\n            if (i <= j) {\r\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left < j)\r\n            quickSort(arr, left, j);\r\n        if (i < right)\r\n            quickSort(arr, i, right);\r\n    }\r\n    \r\n    function _swapPair(uint256[] memory matchingIds, uint256 id1, uint256 id2, uint256 id3, uint256 id4) internal pure {\r\n        uint256 temp = matchingIds[id1];\r\n        matchingIds[id1] = matchingIds[id2];\r\n        matchingIds[id2] = temp;\r\n        \r\n        temp = matchingIds[id3];\r\n        matchingIds[id3] = matchingIds[id4];\r\n        matchingIds[id4] = temp;\r\n    }\r\n    \r\n    function _swapValues(uint256[] memory matchingIds, uint256 id1, uint256 id2) internal pure {\r\n        uint256 temp = matchingIds[id1];\r\n        matchingIds[id1] = matchingIds[id2];\r\n        matchingIds[id2] = temp;\r\n    }\r\n    \r\n    function _getMatchingIds(uint256[] memory matchingIds, uint256 _pvpInterval, uint256 _skipCycles, uint256 _expandInterval) \r\n    internal pure returns(uint256 matchingCount) \r\n    {\r\n        matchingCount = matchingIds.length;\r\n        if (matchingCount == 0) return 0;\r\n        \r\n        uint256 warriorId;\r\n        uint256 index;\r\n        //sort matching ids\r\n        quickSort(matchingIds, int256(0), int256(matchingCount - 1));\r\n        //find pairs\r\n        int256 rating1;\r\n        uint256 pairIndex = 0;\r\n        int256 ratingRange;\r\n        for(index = 0; index < matchingCount; index++) {\r\n            //get packed value\r\n            warriorId = matchingIds[index];\r\n            //unpack rating 1\r\n            rating1 = int256(_unpackRatingValue(warriorId));\r\n            ratingRange = int256(getRatingRange(_unpackCycleValue(warriorId) + _skipCycles, _pvpInterval, _expandInterval));\r\n            \r\n            if (index > pairIndex && //check left neighbor\r\n            isMatching(rating1, int256(_unpackRatingValue(matchingIds[index - 1])), ratingRange)) {\r\n                //move matched pairs to the left\r\n                //swap pairs\r\n                _swapPair(matchingIds, pairIndex, index - 1, pairIndex + 1, index);\r\n                //mark last pair position\r\n                pairIndex += 2;\r\n            } else if (index + 1 < matchingCount && //check right neighbor\r\n            isMatching(rating1, int256(_unpackRatingValue(matchingIds[index + 1])), ratingRange)) {\r\n                //move matched pairs to the left\r\n                //swap pairs\r\n                _swapPair(matchingIds, pairIndex, index, pairIndex + 1, index + 1);\r\n                //mark last pair position\r\n                pairIndex += 2;\r\n                //skip next iteration\r\n                index++;\r\n            }\r\n        }\r\n        \r\n        matchingCount = pairIndex;\r\n    }\r\n\r\n    function _getPVPBattleResults(uint256[] memory matchingIds, uint256 matchingCount, uint256 _targetBlock) internal view {\r\n        uint256 exp = 0;\r\n        uint256 hash = 0;\r\n        uint256 result = 0;\r\n        for (uint256 even = 0; even < matchingCount; even += 2) {\r\n            if (exp == 0 || exp > 73) {\r\n                hash = uint256(keccak256(block.blockhash(_getTargetBlock(_targetBlock)), hash));\r\n                exp = 0;\r\n            }\r\n                \r\n            //compute battle result 1 = even(left) id won, 2 - odd(right) id won\r\n            result = getPVPBattleResult(matchingIds[even], matchingIds[even + 1], hash % (1000 * 10**exp) / 10**exp);\r\n            require(result > 0 && result < 3);\r\n            exp++;\r\n            //if odd warrior won, swap his id with even warrior,\r\n            //otherwise do nothing,\r\n            //even ids are winning ids! odds suck!\r\n            if (result == 2) {\r\n                _swapValues(matchingIds, even, even + 1);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function _getLevel(uint256 _levelPoints) internal pure returns(uint256) {\r\n        return _levelPoints / POINTS_TO_LEVEL;\r\n    }\r\n    \r\n}\r\n\r\ncontract WarriorGenerator is Ownable, GeneratorInterface {\r\n    \r\n    address coreContract;\r\n    \r\n    /* LIMITS */\r\n    uint32[19] public parameters;/*  = [\r\n        uint32(10),//0_bodyColorMax3\r\n        uint32(10),//1_eyeshMax4\r\n        uint32(10),//2_mouthMax5\r\n        uint32(20),//3_heirMax6\r\n        uint32(10),//4_heirColorMax7\r\n        uint32(3),//5_armorMax8\r\n        uint32(3),//6_weaponMax9\r\n        uint32(3),//7_hatMax10\r\n        uint32(4),//8_runesMax11\r\n        uint32(1),//9_wingsMax12\r\n        uint32(10),//10_petMax13\r\n        uint32(6),//11_borderMax14\r\n        uint32(6),//12_backgroundMax15\r\n        uint32(10),//13_unique\r\n        uint32(900),//14_legendary\r\n        uint32(9000),//15_mythic\r\n        uint32(90000),//16_rare\r\n        uint32(900000),//17_uncommon\r\n        uint32(0)//18_uniqueTotal\r\n    ];*/\r\n    \r\n    function WarriorGenerator(address _coreContract, uint32[] _settings) public {\r\n        uint256 length = _settings.length;\r\n        require(length == 18);\r\n        require(_settings[8] == 4);//check runes max\r\n        require(_settings[10] == 10);//check pets max\r\n        require(_settings[11] == 5);//check border max\r\n        require(_settings[12] == 6);//check background max\r\n        //setup parameters\r\n        for(uint256 i = 0; i < length; i ++) {\r\n            parameters[i] = _settings[i];\r\n        }\t\r\n        \r\n        coreContract = _coreContract;\r\n    }\r\n    \r\n    function changeParameter(uint32 _paramIndex, uint32 _value) external onlyOwner {\r\n        CryptoUtils._changeParameter(_paramIndex, _value, parameters);\r\n    }\r\n\r\n    // / @dev simply a boolean to indicate this is the contract we expect to be\r\n    function isGenerator() public pure returns (bool){\r\n        return true;\r\n    }\r\n\r\n    // / @dev generate new warrior identity\r\n    // / @param _heroIdentity Genes of warrior that invoked resurrection, if 0 => Demigod gene that signals to generate unique warrior\r\n    // / @param _heroLevel Level of the warrior\r\n    // / @_targetBlock block number from which hash will be taken\r\n    // / @_perkId special perk id, like MINER(1)\r\n    // / @return the identity that are supposed to be passed down to newly arisen warrior\r\n    function generateWarrior(uint256 _heroIdentity, uint256 _heroLevel, uint256 _targetBlock, uint256 _perkId) \r\n    public returns (uint256) \r\n    {\r\n        //only core contract can call this method\r\n        require(msg.sender == coreContract);\r\n        //get memory copy, to reduce storage read requests\r\n        uint32[19] memory memoryParams = parameters;\r\n        //generate warrior identity\r\n        uint256 identity = CryptoUtils.generateWarrior(_heroIdentity, _heroLevel, _targetBlock, _perkId, memoryParams);\r\n        \r\n        //validate before pushing changes to storage\r\n        CryptoUtils._validateIdentity(identity, memoryParams);\r\n        //push changes to storage\r\n        CryptoUtils._recordWarriorData(identity, parameters);\r\n        \r\n        return identity;\r\n    }\r\n}\r\n\r\ncontract AuctionBase {\r\n\tuint256 public constant PRICE_CHANGE_TIME_STEP = 15 minutes;\r\n\t\r\n    struct Auction{\r\n        address seller;\r\n        uint128 startingPrice;\r\n        uint128 endingPrice;\r\n        uint64 duration;\r\n        uint64 startedAt;\r\n    }\r\n    mapping (uint256 => Auction) internal tokenIdToAuction;\r\n    \r\n    uint256 public ownerCut;\r\n    \r\n    ERC721 public nonFungibleContract;\r\n\r\n    event AuctionCreated(uint256 tokenId, address seller, uint256 startingPrice);\r\n\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner, address seller);\r\n\r\n    event AuctionCancelled(uint256 tokenId, address seller);\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool){\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    function _escrow(address _owner, uint256 _tokenId) internal{\r\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\r\n    }\r\n    \r\n    function _transfer(address _receiver, uint256 _tokenId) internal{\r\n        nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n    \r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal{\r\n        require(_auction.duration >= 1 minutes);\r\n        \r\n        tokenIdToAuction[_tokenId] = _auction;\r\n        \r\n        AuctionCreated(uint256(_tokenId), _auction.seller, _auction.startingPrice);\r\n    }\r\n\r\n    // @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal{\r\n        _removeAuction(_tokenId);\r\n        \r\n        _transfer(_seller, _tokenId);\r\n        \r\n        AuctionCancelled(_tokenId, _seller);\r\n    }\r\n\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount) internal returns (uint256){\r\n        \r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        \r\n        require(_isOnAuction(auction));\r\n        \r\n        uint256 price = _currentPrice(auction);\r\n        \r\n        require(_bidAmount >= price);\r\n        \r\n        address seller = auction.seller;\r\n        \r\n        _removeAuction(_tokenId);\r\n        \r\n        if (price > 0) {\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - auctioneerCut;\r\n            \r\n            seller.transfer(sellerProceeds);\r\n            nonFungibleContract.getBeneficiary().transfer(auctioneerCut);\r\n        }\r\n        \r\n        uint256 bidExcess = _bidAmount - price;\r\n        \r\n        msg.sender.transfer(bidExcess);\r\n        \r\n        AuctionSuccessful(_tokenId, price, msg.sender, seller);\r\n        \r\n        return price;\r\n    }\r\n\r\n    function _removeAuction(uint256 _tokenId) internal{\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool){\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256){\r\n        uint256 secondsPassed = 0;\r\n        \r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n        \r\n        return _computeCurrentPrice(_auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed);\r\n    }\r\n    \r\n    function _computeCurrentPrice(uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed)\r\n        internal\r\n        pure\r\n        returns (uint256){\r\n        \r\n        if (_secondsPassed >= _duration) {\r\n            return _endingPrice;\r\n        } else {\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n            \r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed / PRICE_CHANGE_TIME_STEP * PRICE_CHANGE_TIME_STEP) / int256(_duration);\r\n            \r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n            \r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    function _computeCut(uint256 _price) internal view returns (uint256){\r\n        \r\n        return _price * ownerCut / 10000;\r\n    }\r\n}\r\n\r\n\r\ncontract SaleClockAuction is Pausable, AuctionBase {\r\n    \r\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9f40b779);\r\n    \r\n    bool public isSaleClockAuction = true;\r\n    uint256 public minerSaleCount;\r\n    uint256[5] public lastMinerSalePrices;\r\n\r\n    function SaleClockAuction(address _nftAddress, uint256 _cut) public{\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\r\n        require(candidateContract.getBeneficiary() != address(0));\r\n        \r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    function cancelAuction(uint256 _tokenId)\r\n        external{\r\n        \r\n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\r\n        \r\n        require(_isOnAuction(auction));\r\n        \r\n        address seller = auction.seller;\r\n        \r\n        require(msg.sender == seller);\r\n        \r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n        whenPaused\r\n        onlyOwner\r\n        external{\r\n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256){\r\n        \r\n        AuctionBase.Auction storage auction = tokenIdToAuction[_tokenId];\r\n        \r\n        require(_isOnAuction(auction));\r\n        \r\n        return _currentPrice(auction);\r\n    }\r\n    \r\n    function createAuction(uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller)\r\n        external{\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        \r\n        AuctionBase.Auction memory auction = Auction(_seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now));\r\n        \r\n        _addAuction(_tokenId, auction);\r\n    }\r\n    \r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable{\r\n        \r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        \r\n        uint256 price = _bid(_tokenId, msg.value);\r\n        \r\n        _transfer(msg.sender, _tokenId);\r\n        \r\n        if (seller == nonFungibleContract.getBeneficiary()) {\r\n            lastMinerSalePrices[minerSaleCount % 5] = price;\r\n            minerSaleCount++;\r\n        }\r\n    }\r\n\r\n    function averageMinerSalePrice() external view returns (uint256){\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < 5; i++){\r\n            sum += lastMinerSalePrices[i];\r\n        }\r\n        return sum / 5;\r\n    }\r\n    \r\n    /**getAuctionsById returns packed actions data\r\n     * @param tokenIds ids of tokens, whose auction's must be active \r\n     * @return auctionData as uint256 array\r\n     * @return stepSize number of fields describing auction \r\n     */\r\n    function getAuctionsById(uint32[] tokenIds) external view returns(uint256[] memory auctionData, uint32 stepSize) {\r\n        stepSize = 6;\r\n        auctionData = new uint256[](tokenIds.length * stepSize);\r\n        \r\n        uint32 tokenId;\r\n        for(uint32 i = 0; i < tokenIds.length; i ++) {\r\n            tokenId = tokenIds[i];\r\n            AuctionBase.Auction storage auction = tokenIdToAuction[tokenId];\r\n            require(_isOnAuction(auction));\r\n            _setTokenData(auctionData, auction, tokenId, i * stepSize);\r\n        }\r\n    }\r\n    \r\n    /**getAuctions returns packed actions data\r\n     * @param fromIndex warrior index from global warrior storage (aka warriorId)\r\n     * @param count Number of auction's to find, if count == 0, then exact warriorId(fromIndex) will be searched\r\n     * @return auctionData as uint256 array\r\n     * @return stepSize number of fields describing auction \r\n     */\r\n    function getAuctions(uint32 fromIndex, uint32 count) external view returns(uint256[] memory auctionData, uint32 stepSize) {\r\n        stepSize = 6;\r\n        if (count == 0) {\r\n            AuctionBase.Auction storage auction = tokenIdToAuction[fromIndex];\r\n\t        \trequire(_isOnAuction(auction));\r\n\t        \tauctionData = new uint256[](1 * stepSize);\r\n\t        \t_setTokenData(auctionData, auction, fromIndex, count);\r\n\t        \treturn (auctionData, stepSize);\r\n        } else {\r\n            uint256 totalWarriors = nonFungibleContract.totalSupply();\r\n\t        if (totalWarriors == 0) {\r\n\t            // Return an empty array\r\n\t            return (new uint256[](0), stepSize);\r\n\t        } else {\r\n\t\r\n\t            uint32 totalSize = 0;\r\n\t            uint32 tokenId;\r\n\t            uint32 size = 0;\r\n\t\t\t\tauctionData = new uint256[](count * stepSize);\r\n\t            for (tokenId = 0; tokenId < totalWarriors && size < count; tokenId++) {\r\n\t                AuctionBase.Auction storage auction1 = tokenIdToAuction[tokenId];\r\n\t        \r\n\t\t        \t\tif (_isOnAuction(auction1)) {\r\n\t\t        \t\t    totalSize ++;\r\n\t\t        \t\t    if (totalSize > fromIndex) {\r\n\t\t        \t\t        _setTokenData(auctionData, auction1, tokenId, size++ * stepSize);//warriorId;\r\n\t\t        \t\t    }\r\n\t\t        \t\t}\r\n\t            }\r\n\t            \r\n\t            if (size < count) {\r\n\t                size *= stepSize;\r\n\t                uint256[] memory repack = new uint256[](size);\r\n\t                for(tokenId = 0; tokenId < size; tokenId++) {\r\n\t                    repack[tokenId] = auctionData[tokenId];\r\n\t                }\r\n\t                return (repack, stepSize);\r\n\t            }\r\n\t\r\n\t            return (auctionData, stepSize);\r\n\t        }\r\n        }\r\n    }\r\n    \r\n    // @dev Returns auction info for an NFT on auction.\r\n    // @param _tokenId - ID of NFT on auction.\r\n    function getAuction(uint256 _tokenId) external view returns(\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n        ){\r\n        \r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        \r\n        require(_isOnAuction(auction));\r\n        \r\n        return (auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt);\r\n    }\r\n    \r\n    //pack NFT data into specified array\r\n    function _setTokenData(uint256[] memory auctionData, \r\n        AuctionBase.Auction storage auction, uint32 tokenId, uint32 index\r\n    ) internal view {\r\n        auctionData[index] = uint256(tokenId);//0\r\n        auctionData[index + 1] = uint256(auction.seller);//1\r\n        auctionData[index + 2] = uint256(auction.startingPrice);//2\r\n        auctionData[index + 3] = uint256(auction.endingPrice);//3\r\n        auctionData[index + 4] = uint256(auction.duration);//4\r\n        auctionData[index + 5] = uint256(auction.startedAt);//5\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastMinerSalePrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSaleClockAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"averageMinerSalePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fromIndex\",\"type\":\"uint32\"},{\"name\":\"count\",\"type\":\"uint32\"}],\"name\":\"getAuctions\",\"outputs\":[{\"name\":\"auctionData\",\"type\":\"uint256[]\"},{\"name\":\"stepSize\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenIds\",\"type\":\"uint32[]\"}],\"name\":\"getAuctionsById\",\"outputs\":[{\"name\":\"auctionData\",\"type\":\"uint256[]\"},{\"name\":\"stepSize\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_CHANGE_TIME_STEP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minerSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_cut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"SaleClockAuction","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c4a21f9a38b813b2c8e3f2e01c8d7547a99ed2b7000000000000000000000000000000000000000000000000000000000000015e","Library":"","SwarmSource":"bzzr://a2cf24d3a5db75488b70ea4ffdb876d79134ecef00dcbcbd6f864db8ff16e4d2"}]}