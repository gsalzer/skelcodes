{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.17;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure  returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal  pure returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns(uint);\r\n\r\n    function allowance(address owner, address spender) public view returns(uint);\r\n\r\n    function transfer(address to, uint value) public returns(bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) public returns(bool ok);\r\n\r\n    function approve(address spender, uint value) public returns(bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n\r\n// Whitelist smart contract\r\n// This smart contract keeps list of addresses to whitelist\r\ncontract WhiteList is Ownable {\r\n    \r\n    mapping(address => bool) public whiteList;\r\n    uint public totalWhiteListed; //white listed users number\r\n\r\n    event LogWhiteListed(address indexed user, uint whiteListedNum);\r\n    event LogWhiteListedMultiple(uint whiteListedNum);\r\n    event LogRemoveWhiteListed(address indexed user);\r\n\r\n    // @notice it will return status of white listing\r\n    // @return true if user is white listed and false if is not\r\n    function isWhiteListed(address _user) external view returns (bool) {\r\n\r\n        return whiteList[_user]; \r\n    }\r\n\r\n    // @notice it will remove whitelisted user\r\n    // @param _contributor {address} of user to unwhitelist\r\n    function removeFromWhiteList(address _user) external onlyOwner() returns (bool) {\r\n       \r\n        require(whiteList[_user] == true);\r\n        whiteList[_user] = false;\r\n        totalWhiteListed--;\r\n        LogRemoveWhiteListed(_user);\r\n        return true;\r\n    }\r\n\r\n    // @notice it will white list one member\r\n    // @param _user {address} of user to whitelist\r\n    // @return true if successful\r\n    function addToWhiteList(address _user) external onlyOwner()  returns (bool) {\r\n\r\n        if (whiteList[_user] != true) {\r\n            whiteList[_user] = true;\r\n            totalWhiteListed++;\r\n            LogWhiteListed(_user, totalWhiteListed);            \r\n        }\r\n        return true;\r\n    }\r\n\r\n    // @notice it will white list multiple members\r\n    // @param _user {address[]} of users to whitelist\r\n    // @return true if successful\r\n    function addToWhiteListMultiple(address[] _users) external onlyOwner()  returns (bool) {\r\n\r\n        for (uint i = 0; i < _users.length; ++i) {\r\n\r\n            if (whiteList[_users[i]] != true) {\r\n                whiteList[_users[i]] = true;\r\n                totalWhiteListed++;                          \r\n            }           \r\n        }\r\n        LogWhiteListedMultiple(totalWhiteListed); \r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// @note this contract can be inherited by Crowdsale and TeamAllocation contracts and\r\n// control release of tokens through even time release based on the inputted duration time interval\r\ncontract TokenVesting is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    struct TokenHolder {\r\n        uint weiReceived; // amount of ETH contributed\r\n        uint tokensToSend; // amount of tokens  sent  \r\n        bool refunded; // true if user has been refunded       \r\n        uint releasedAmount; // amount released through vesting schedule\r\n        bool revoked; // true if right to continue vesting is revoked\r\n    }\r\n\r\n    event Released(uint256 amount, uint256 tokenDecimals);\r\n    event ContractUpdated(bool done);\r\n\r\n    uint256 public cliff;  // time in  when vesting should begin\r\n    uint256 public startCountDown;  // time when countdown starts\r\n    uint256 public duration; // duration of period in which vesting takes place   \r\n    Token public token;  // token contract containing tokens\r\n    mapping(address => TokenHolder) public tokenHolders; //tokenHolder list\r\n    WhiteList public whiteList; // whitelist contract\r\n    uint256 public presaleBonus;\r\n    \r\n    // @note constructor \r\n    /**\r\n    function TokenVesting(uint256 _start, uint256 _cliff, uint256 _duration) public {   \r\n         require(_cliff <= _duration);   \r\n        duration = _duration;\r\n        cliff = _start.add(_cliff);\r\n        startCountDown = _start;         \r\n        ContractUpdated(true);                    \r\n    }\r\n    */\r\n    // @notice Specify address of token contract\r\n    // @param _tokenAddress {address} address of token contract\r\n    // @return res {bool}\r\n    function initilizeVestingAndTokenAndWhiteList(Token _tokenAddress, \r\n                                        uint256 _start, \r\n                                        uint256 _cliff, \r\n                                        uint256 _duration,\r\n                                        uint256 _presaleBonus, \r\n                                        WhiteList _whiteList) external onlyOwner() returns(bool res) {\r\n        require(_cliff <= _duration);   \r\n        require(_tokenAddress != address(0));\r\n        duration = _duration;\r\n        cliff = _start.add(_cliff);\r\n        startCountDown = _start;  \r\n        token = _tokenAddress; \r\n        whiteList = _whiteList;\r\n        presaleBonus = _presaleBonus;\r\n        ContractUpdated(true);\r\n        return true;    \r\n    }\r\n\r\n    // @notice Specify address of token contract\r\n    // @param _tokenAddress {address} address of token contract\r\n    // @return res {bool}\r\n    function initilizeVestingAndToken(Token _tokenAddress, \r\n                                        uint256 _start, \r\n                                        uint256 _cliff, \r\n                                        uint256 _duration,\r\n                                        uint256 _presaleBonus\r\n                                        ) external onlyOwner() returns(bool res) {\r\n        require(_cliff <= _duration);   \r\n        require(_tokenAddress != address(0));\r\n        duration = _duration;\r\n        cliff = _start.add(_cliff);\r\n        startCountDown = _start;  \r\n        token = _tokenAddress;        \r\n        presaleBonus = _presaleBonus;\r\n        ContractUpdated(true);\r\n        return true;    \r\n    }\r\n\r\n    function returnVestingSchedule() external view returns (uint, uint, uint) {\r\n\r\n        return (duration, cliff, startCountDown);\r\n    }\r\n\r\n    // @note owner can revoke access to continue vesting of tokens\r\n    // @param _user {address} of user to revoke their right to vesting\r\n    function revoke(address _user) public onlyOwner() {\r\n\r\n        TokenHolder storage tokenHolder = tokenHolders[_user];\r\n        tokenHolder.revoked = true; \r\n    }\r\n\r\n    function vestedAmountAvailable() public view returns (uint amount, uint decimals) {\r\n\r\n        TokenHolder storage tokenHolder = tokenHolders[msg.sender];\r\n        uint tokensToRelease = vestedAmount(tokenHolder.tokensToSend);\r\n\r\n     //   if (tokenHolder.releasedAmount + tokensToRelease > tokenHolder.tokensToSend)\r\n      //      return (tokenHolder.tokensToSend - tokenHolder.releasedAmount, token.decimals());\r\n     //   else \r\n        return (tokensToRelease - tokenHolder.releasedAmount, token.decimals());\r\n    }\r\n    \r\n    // @notice Transfers vested available tokens to beneficiary   \r\n    function release() public {\r\n\r\n        TokenHolder storage tokenHolder = tokenHolders[msg.sender];        \r\n        // check if right to vesting is not revoked\r\n        require(!tokenHolder.revoked);                                   \r\n        uint tokensToRelease = vestedAmount(tokenHolder.tokensToSend);      \r\n        uint currentTokenToRelease = tokensToRelease - tokenHolder.releasedAmount;\r\n        tokenHolder.releasedAmount += currentTokenToRelease;            \r\n        token.transfer(msg.sender, currentTokenToRelease);\r\n\r\n        Released(currentTokenToRelease, token.decimals());\r\n    }\r\n  \r\n    // @notice this function will determine vested amount\r\n    // @param _totalBalance {uint} total balance of tokens assigned to this user\r\n    // @return {uint} amount of tokens available to transfer\r\n    function vestedAmount(uint _totalBalance) public view returns (uint) {\r\n\r\n        if (now < cliff) {\r\n            return 0;\r\n        } else if (now >= startCountDown.add(duration)) {\r\n            return _totalBalance;\r\n        } else {\r\n            return _totalBalance.mul(now.sub(startCountDown)) / duration;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Crowdsale Smart Contract\r\n// This smart contract collects ETH and in return sends  tokens to the Backers\r\ncontract Crowdsale is Pausable, TokenVesting {\r\n\r\n    using SafeMath for uint;\r\n\r\n    address public multisigETH; // Multisig contract that will receive the ETH\r\n    address public commissionAddress;  // address to deposit commissions\r\n    uint public tokensForTeam; // tokens for the team\r\n    uint public ethReceivedPresale; // Number of ETH received in presale\r\n    uint public ethReceivedMain; // Number of ETH received in main sale\r\n    uint public totalTokensSent; // Number of tokens sent to ETH contributors\r\n    uint public tokensSentMain;\r\n    uint public tokensSentPresale;       \r\n    uint public tokensSentDev;         \r\n    uint public startBlock; // Crowdsale start block\r\n    uint public endBlock; // Crowdsale end block\r\n    uint public maxCap; // Maximum number of token to sell\r\n    uint public minCap; // Minimum number of ETH to raise\r\n    uint public minContributionMainSale; // Minimum amount to contribute in main sale\r\n    uint public minContributionPresale; // Minimum amount to contribut in presale\r\n    uint public maxContribution;\r\n    bool public crowdsaleClosed; // Is crowdsale still on going\r\n    uint public tokenPriceWei;\r\n    uint public refundCount;\r\n    uint public totalRefunded;\r\n    uint public campaignDurationDays; // campaign duration in days \r\n    uint public firstPeriod; \r\n    uint public secondPeriod; \r\n    uint public thirdPeriod; \r\n    uint public firstBonus; \r\n    uint public secondBonus;\r\n    uint public thirdBonus;\r\n    uint public multiplier;\r\n    uint public status;    \r\n    Step public currentStep;  // To allow for controlled steps of the campaign \r\n   \r\n    // Looping through Backer\r\n    //mapping(address => Backer) public backers; //backer list\r\n    address[] public holdersIndex;   // to be able to itarate through backers when distributing the tokens\r\n    address[] public devIndex;   // to be able to itarate through backers when distributing the tokens\r\n\r\n    // @notice to set and determine steps of crowdsale\r\n    enum Step {      \r\n        FundingPreSale,     // presale mode\r\n        FundingMainSale,  // public mode\r\n        Refunding  // in case campaign failed during this step contributors will be able to receive refunds\r\n    }\r\n\r\n    // @notice to verify if action is not performed out of the campaing range\r\n    modifier respectTimeFrame() {\r\n        if ((block.number < startBlock) || (block.number > endBlock)) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier minCapNotReached() {\r\n        if (totalTokensSent >= minCap) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // Events\r\n    event LogReceivedETH(address indexed backer, uint amount, uint tokenAmount);\r\n    event LogStarted(uint startBlockLog, uint endBlockLog);\r\n    event LogFinalized(bool success);  \r\n    event LogRefundETH(address indexed backer, uint amount);\r\n    event LogStepAdvanced();\r\n    event LogDevTokensAllocated(address indexed dev, uint amount);\r\n    event LogNonVestedTokensSent(address indexed user, uint amount);\r\n\r\n    // Crowdsale  {constructor}\r\n    // @notice fired when contract is crated. Initilizes all constnat variables.\r\n    function Crowdsale(uint _decimalPoints,\r\n                        address _multisigETH,\r\n                        uint _toekensForTeam, \r\n                        uint _minContributionPresale,\r\n                        uint _minContributionMainSale,\r\n                        uint _maxContribution,                        \r\n                        uint _maxCap, \r\n                        uint _minCap, \r\n                        uint _tokenPriceWei, \r\n                        uint _campaignDurationDays,\r\n                        uint _firstPeriod, \r\n                        uint _secondPeriod, \r\n                        uint _thirdPeriod, \r\n                        uint _firstBonus, \r\n                        uint _secondBonus,\r\n                        uint _thirdBonus) public {\r\n        multiplier = 10**_decimalPoints;\r\n        multisigETH = _multisigETH; \r\n        tokensForTeam = _toekensForTeam * multiplier; \r\n        minContributionPresale = _minContributionPresale; \r\n        minContributionMainSale = _minContributionMainSale;\r\n        maxContribution = _maxContribution;       \r\n        maxCap = _maxCap * multiplier;       \r\n        minCap = _minCap * multiplier;\r\n        tokenPriceWei = _tokenPriceWei;\r\n        campaignDurationDays = _campaignDurationDays;\r\n        firstPeriod = _firstPeriod; \r\n        secondPeriod = _secondPeriod; \r\n        thirdPeriod = _thirdPeriod;\r\n        firstBonus = _firstBonus;\r\n        secondBonus = _secondBonus;\r\n        thirdBonus = _thirdBonus;       \r\n        //TODO replace this address below with correct address.\r\n        commissionAddress = 0x326B5E9b8B2ebf415F9e91b42c7911279d296ea1;\r\n        //commissionAddress = 0x853A3F142430658A32f75A0dc891b98BF4bDF5c1;\r\n        currentStep = Step.FundingPreSale; \r\n    }\r\n\r\n    // @notice to populate website with status of the sale \r\n    function returnWebsiteData() external view returns(uint, \r\n        uint, uint, uint, uint, uint, uint, uint, uint, uint, bool, bool, uint, Step) {\r\n    \r\n        return (startBlock, endBlock, numberOfBackers(), ethReceivedPresale + ethReceivedMain, maxCap, minCap, \r\n                totalTokensSent, tokenPriceWei, minContributionPresale, minContributionMainSale, \r\n                paused, crowdsaleClosed, token.decimals(), currentStep);\r\n    }\r\n    \r\n    // @notice this function will determine status of crowdsale\r\n    function determineStatus() external view returns (uint) {\r\n       \r\n        if (crowdsaleClosed)            // ICO finihsed\r\n            return 1;   \r\n\r\n        if (block.number < endBlock && totalTokensSent < maxCap - 100)   // ICO in progress\r\n            return 2;            \r\n    \r\n        if (totalTokensSent < minCap && block.number > endBlock)      // ICO failed    \r\n            return 3;            \r\n    \r\n        if (endBlock == 0)           // ICO hasn't been started yet \r\n            return 4;            \r\n    \r\n        return 0;         \r\n    } \r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handels allocation of Ether and calculates tokens.\r\n    function () public payable {    \r\n             \r\n        contribute(msg.sender);\r\n    }\r\n\r\n    // @notice to allow for contribution from interface\r\n    function contributePublic() external payable {\r\n        contribute(msg.sender);\r\n    }\r\n\r\n    // @notice set the step of the campaign from presale to public sale\r\n    // contract is deployed in presale mode\r\n    // WARNING: there is no way to go back\r\n    function advanceStep() external onlyOwner() {\r\n        currentStep = Step.FundingMainSale;\r\n        LogStepAdvanced();\r\n    }\r\n\r\n    // @notice It will be called by owner to start the sale    \r\n    function start() external onlyOwner() {\r\n        startBlock = block.number;\r\n        endBlock = startBlock + (4*60*24*campaignDurationDays); // assumption is that one block takes 15 sec. \r\n        crowdsaleClosed = false;\r\n        LogStarted(startBlock, endBlock);\r\n    }\r\n\r\n    // @notice This function will finalize the sale.\r\n    // It will only execute if predetermined sale time passed or all tokens are sold.\r\n    function finalize() external onlyOwner() {\r\n\r\n        require(!crowdsaleClosed);                       \r\n        require(block.number >= endBlock || totalTokensSent > maxCap - 1000);\r\n                    // - 1000 is used to allow closing of the campaing when contribution is near \r\n                    // finished as exact amount of maxCap might be not feasible e.g. you can't easily buy few tokens. \r\n                    // when min contribution is 0.1 Eth.  \r\n\r\n        require(totalTokensSent >= minCap);\r\n        crowdsaleClosed = true;\r\n        \r\n        // transfer commission portion to the platform\r\n        commissionAddress.transfer(determineCommissions());         \r\n        \r\n        // transfer remaning funds to the campaign wallet\r\n        multisigETH.transfer(this.balance);\r\n        \r\n        /*if (!token.transfer(owner, token.balanceOf(this))) \r\n            revert(); // transfer tokens to admin account  \r\n            \r\n        if (!token.burn(this, token.balanceOf(this))) \r\n            revert();  // burn all the tokens remaining in the contract   */\r\n        token.unlock();    // release lock from transfering tokens. \r\n\r\n        LogFinalized(true);        \r\n    }\r\n\r\n    // @notice it will allow contributors to get refund in case campaign failed\r\n    // @return {bool} true if successful\r\n    function refund() external whenNotPaused returns (bool) {      \r\n        \r\n        uint totalEtherReceived = ethReceivedPresale + ethReceivedMain;\r\n\r\n        require(totalEtherReceived < minCap);  // ensure that campaign failed\r\n        require(this.balance > 0);  // contract will hold 0 ether at the end of campaign.\r\n                                    // contract needs to be funded through fundContract() \r\n        TokenHolder storage backer = tokenHolders[msg.sender];\r\n\r\n        require(backer.weiReceived > 0);  // ensure that user has sent contribution\r\n        require(!backer.refunded);        // ensure that user hasn't been refunded yet\r\n\r\n        backer.refunded = true;  // save refund status to true\r\n        refundCount++;\r\n        totalRefunded += backer.weiReceived;\r\n\r\n        if (!token.burn(msg.sender, backer.tokensToSend)) // burn tokens\r\n            revert();        \r\n        msg.sender.transfer(backer.weiReceived);  // send back the contribution \r\n        LogRefundETH(msg.sender, backer.weiReceived);\r\n        return true;\r\n    }\r\n\r\n    // @notice allocate tokens to dev/team/advisors\r\n    // @param _dev {address} \r\n    // @param _amount {uint} amount of tokens\r\n    function devAllocation(address _dev, uint _amount) external onlyOwner() returns (bool) {\r\n\r\n        require(_dev != address(0));\r\n        require(crowdsaleClosed); \r\n        require(totalTokensSent.add(_amount) <= token.totalSupply());\r\n        devIndex.push(_dev);\r\n        TokenHolder storage tokenHolder = tokenHolders[_dev];\r\n        tokenHolder.tokensToSend = _amount;\r\n        tokensSentDev += _amount;\r\n        totalTokensSent += _amount;        \r\n        LogDevTokensAllocated(_dev, _amount); // Register event\r\n        return true;\r\n\r\n    }\r\n\r\n    // @notice Failsafe drain\r\n    function drain(uint _amount) external onlyOwner() {\r\n        owner.transfer(_amount);           \r\n    }\r\n\r\n    // @notice transfer tokens which are not subject to vesting\r\n    // @param _recipient {addres}\r\n    // @param _amont {uint} amount to transfer\r\n    function transferTokens(address _recipient, uint _amount) external onlyOwner() returns (bool) {\r\n\r\n        require(_recipient != address(0));\r\n        if (!token.transfer(_recipient, _amount))\r\n            revert();\r\n        LogNonVestedTokensSent(_recipient, _amount);\r\n    }\r\n\r\n    // @notice determine amount of commissions for the platform    \r\n    function determineCommissions() public view returns (uint) {\r\n     \r\n        if (this.balance <= 500 ether) {\r\n            return (this.balance * 10)/100;\r\n        }else if (this.balance <= 1000 ether) {\r\n            return (this.balance * 8)/100;\r\n        }else if (this.balance < 10000 ether) {\r\n            return (this.balance * 6)/100;\r\n        }else {\r\n            return (this.balance * 6)/100;\r\n        }\r\n    }\r\n\r\n    // @notice return number of contributors\r\n    // @return  {uint} number of contributors\r\n    function numberOfBackers() public view returns (uint) {\r\n        return holdersIndex.length;\r\n    }\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _backer {address} address of beneficiary\r\n    // @return res {bool} true if transaction was successful\r\n    function contribute(address _backer) internal whenNotPaused respectTimeFrame returns(bool res) {\r\n\r\n        //require(msg.value <= maxContribution);\r\n\r\n        if (whiteList != address(0))  // if whitelist initialized verify member whitelist status\r\n            require(whiteList.isWhiteListed(_backer));  // ensure that user is whitelisted\r\n          \r\n        uint tokensToSend = calculateNoOfTokensToSend(); // calculate number of tokens\r\n\r\n        // Ensure that max cap hasn't been reached\r\n        require(totalTokensSent + tokensToSend <= maxCap);\r\n        \r\n        TokenHolder storage backer = tokenHolders[_backer];\r\n\r\n        if (backer.weiReceived == 0)\r\n            holdersIndex.push(_backer);\r\n\r\n        if (Step.FundingMainSale == currentStep) { // Update the total Ether received and tokens sent during public sale\r\n            require(msg.value >= minContributionMainSale); // stop when required minimum is not met    \r\n            ethReceivedMain = ethReceivedMain.add(msg.value);\r\n            tokensSentMain += tokensToSend;\r\n        }else {  \r\n            require(msg.value >= minContributionPresale); // stop when required minimum is not met\r\n            ethReceivedPresale = ethReceivedPresale.add(msg.value); \r\n            tokensSentPresale += tokensToSend;\r\n        }  \r\n       \r\n        backer.tokensToSend += tokensToSend;\r\n        backer.weiReceived = backer.weiReceived.add(msg.value);       \r\n        totalTokensSent += tokensToSend;      \r\n        \r\n        // tokens are not transferrd to contributors during this phase\r\n        // tokens will be transferred based on the vesting schedule, when contributor\r\n        // calls release() function of this contract\r\n        LogReceivedETH(_backer, msg.value, tokensToSend); // Register event\r\n        return true;\r\n    }\r\n\r\n    // @notice This function will return number of tokens based on time intervals in the campaign\r\n    function calculateNoOfTokensToSend() internal view returns (uint) {\r\n\r\n        uint tokenAmount = msg.value.mul(multiplier) / tokenPriceWei;\r\n\r\n        if (Step.FundingMainSale == currentStep) {\r\n        \r\n            if (block.number <= startBlock + firstPeriod) {  \r\n                return  tokenAmount + tokenAmount.mul(firstBonus) / 100;\r\n            }else if (block.number <= startBlock + secondPeriod) {\r\n                return  tokenAmount + tokenAmount.mul(secondBonus) / 100; \r\n            }else if (block.number <= startBlock + thirdPeriod) { \r\n                return  tokenAmount + tokenAmount.mul(thirdBonus) / 100;        \r\n            }else {              \r\n                return  tokenAmount; \r\n            }\r\n        }else \r\n            return  tokenAmount + tokenAmount.mul(presaleBonus) / 100;\r\n    }  \r\n}\r\n\r\n\r\n// The  token\r\ncontract Token is ERC20, Ownable {\r\n\r\n    using SafeMath for uint;\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals; // How many decimals to show.\r\n    string public version = \"v0.1\";\r\n    uint public totalSupply;\r\n    bool public locked;\r\n    address public crowdSaleAddress;\r\n\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n    \r\n    // Lock transfer during the ICO\r\n    modifier onlyUnlocked() {\r\n        if (msg.sender != crowdSaleAddress && locked && msg.sender != owner) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        if (msg.sender != crowdSaleAddress && msg.sender != owner) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // The Token constructor     \r\n    function Token(uint _initialSupply,\r\n            string _tokenName,\r\n            uint _decimalUnits,\r\n            string _tokenSymbol,\r\n            string _version,\r\n            address _crowdSaleAddress) public {      \r\n        locked = true;  // Lock the transfer of tokens during the crowdsale\r\n        totalSupply = _initialSupply * (10**_decimalUnits);     \r\n                                        \r\n        name = _tokenName; // Set the name for display purposes\r\n        symbol = _tokenSymbol; // Set the symbol for display purposes\r\n        decimals = _decimalUnits; // Amount of decimals for display purposes\r\n        version = _version;\r\n        crowdSaleAddress = _crowdSaleAddress;              \r\n        balances[crowdSaleAddress] = totalSupply;   \r\n    }\r\n\r\n    function unlock() public onlyAuthorized {\r\n        locked = false;\r\n    }\r\n\r\n    function lock() public onlyAuthorized {\r\n        locked = true;\r\n    }\r\n\r\n    function burn(address _member, uint256 _value) public onlyAuthorized returns(bool) {\r\n        require(balances[_member] >= _value);\r\n        balances[_member] -= _value;\r\n        totalSupply -= _value;\r\n        Transfer(_member, 0x0, _value);\r\n        return true;\r\n    }\r\n\r\n   \r\n    // @notice transfer tokens to given address\r\n    // @param _to {address} address or recipient\r\n    // @param _value {uint} amount to transfer\r\n    // @return  {bool} true if successful\r\n    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {\r\n\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice transfer tokens from given address to another address\r\n    // @param _from {address} from whom tokens are transferred\r\n    // @param _to {address} to whom tokens are transferred\r\n    // @param _value {uint} amount of tokens to transfer\r\n    // @return  {bool} true if successful\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns(bool success) {\r\n\r\n        require(_to != address(0));\r\n        require(balances[_from] >= _value); // Check if the sender has enough\r\n        require(_value <= allowed[_from][msg.sender]); // Check if allowed is greater or equal\r\n        balances[_from] -= _value; // Subtract from the sender\r\n        balances[_to] += _value; // Add the same to the recipient\r\n        allowed[_from][msg.sender] -= _value;  // adjust allowed\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n      // @notice to query balance of account\r\n    // @return _owner {address} address of user to query balance\r\n    function balanceOf(address _owner) public view returns(uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) public returns(bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // @notice to query of allowance of one user to the other\r\n    // @param _owner {address} of the owner of the account\r\n    // @param _spender {address} of the spender of the account\r\n    // @return remaining {uint} amount of remaining allowance\r\n    function allowance(address _owner, address _spender) public view returns(uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    */\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBackers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnWebsiteData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cliff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"campaignDurationDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalBalance\",\"type\":\"uint256\"}],\"name\":\"vestedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startCountDown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"returnVestingSchedule\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"determineStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holdersIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"determineCommissions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestedAmountAvailable\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contributePublic\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"advanceStep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContributionMainSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenHolders\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"tokensToSend\",\"type\":\"uint256\"},{\"name\":\"refunded\",\"type\":\"bool\"},{\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"name\":\"revoked\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSentDev\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_presaleBonus\",\"type\":\"uint256\"},{\"name\":\"_whiteList\",\"type\":\"address\"}],\"name\":\"initilizeVestingAndTokenAndWhiteList\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thirdPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_presaleBonus\",\"type\":\"uint256\"}],\"name\":\"initilizeVestingAndToken\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethReceivedPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSentPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dev\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"devAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContributionPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSentMain\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"devIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_decimalPoints\",\"type\":\"uint256\"},{\"name\":\"_multisigETH\",\"type\":\"address\"},{\"name\":\"_toekensForTeam\",\"type\":\"uint256\"},{\"name\":\"_minContributionPresale\",\"type\":\"uint256\"},{\"name\":\"_minContributionMainSale\",\"type\":\"uint256\"},{\"name\":\"_maxContribution\",\"type\":\"uint256\"},{\"name\":\"_maxCap\",\"type\":\"uint256\"},{\"name\":\"_minCap\",\"type\":\"uint256\"},{\"name\":\"_tokenPriceWei\",\"type\":\"uint256\"},{\"name\":\"_campaignDurationDays\",\"type\":\"uint256\"},{\"name\":\"_firstPeriod\",\"type\":\"uint256\"},{\"name\":\"_secondPeriod\",\"type\":\"uint256\"},{\"name\":\"_thirdPeriod\",\"type\":\"uint256\"},{\"name\":\"_firstBonus\",\"type\":\"uint256\"},{\"name\":\"_secondBonus\",\"type\":\"uint256\"},{\"name\":\"_thirdBonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LogReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startBlockLog\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endBlockLog\",\"type\":\"uint256\"}],\"name\":\"LogStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"LogFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRefundETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStepAdvanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dev\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDevTokensAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogNonVestedTokensSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenDecimals\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"ContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000818598b0305dc16c694294e2d863f4e668a0aad5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004b7ec32d7a2000000000000000000000000000000000000000000000000000004b7ec32d7a2000000000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000000000000000000016c6000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000044364c5bb0000000000000000000000000000000000000000000000000000000000000000005a00000000000000000000000000000000000000000000000000000000000871eb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://69cf72ba79943bcfb648637d08cf076b6c3c1939f4ef4ea8a462b6f755958e92"}]}