{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\nlibrary Bonus {\r\n    uint256 constant pointMultiplier = 1e18; //100% = 1*10^18 points\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function getBonusFactor(uint256 basisTokens, uint timestamp)\r\n    internal pure returns (uint256 factor)\r\n    {\r\n        uint256[4][5] memory factors = [[uint256(300), 400, 500, 750],\r\n        [uint256(200), 300, 400, 600],\r\n        [uint256(150), 250, 300, 500],\r\n        [uint256(100), 150, 250, 400],\r\n        [uint256(0),   100, 150, 300]];\r\n\r\n        uint[4] memory cutofftimes = [toTimestamp(2018, 3, 24),\r\n        toTimestamp(2018, 4, 5),\r\n        toTimestamp(2018, 5, 5),\r\n        toTimestamp(2018, 6, 5)];\r\n\r\n        //compare whole tokens\r\n        uint256 tokenAmount = basisTokens / pointMultiplier;\r\n\r\n        //set default to the 0% bonus\r\n        uint256 timeIndex = 4;\r\n        uint256 amountIndex = 0;\r\n\r\n        // 0.02 NZD per token = 50 tokens per NZD\r\n        if (tokenAmount >= 500000000) {\r\n            // >10M NZD\r\n            amountIndex = 3;\r\n        } else if (tokenAmount >= 100000000) {\r\n            // >2M NZD\r\n            amountIndex = 2;\r\n        } else if (tokenAmount >= 25000000) {\r\n            // >500K NZD\r\n            amountIndex = 1;\r\n        } else {\r\n            // <500K NZD\r\n            //amountIndex = 0;\r\n        }\r\n\r\n        uint256 maxcutoffindex = cutofftimes.length;\r\n        for (uint256 i = 0; i < maxcutoffindex; i++) {\r\n            if (timestamp < cutofftimes[i]) {\r\n                timeIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return factors[timeIndex][amountIndex];\r\n    }\r\n\r\n    // Timestamp functions based on\r\n    // https://github.com/pipermerriam/ethereum-datetime/blob/master/contracts/DateTime.sol\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day)\r\n    internal pure returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        timestamp += (year - ORIGIN_YEAR) * 1 years;\r\n        timestamp += (leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR)) * 1 days;\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n            monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < month; i++) {\r\n            timestamp += monthDayCounts[i - 1] * 1 days;\r\n        }\r\n\r\n        // Day\r\n        timestamp += (day - 1) * 1 days;\r\n\r\n        // Hour, Minute, and Second are assumed as 0 (we calculate in GMT)\r\n\r\n        return timestamp;\r\n    }\r\n\r\n    function leapYearsBefore(uint year)\r\n    internal pure returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function isLeapYear(uint16 year)\r\n    internal pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ClearToken is StandardToken {\r\n\r\n    // data structures\r\n    enum States {\r\n        Initial, // deployment time\r\n        ValuationSet,\r\n        Ico, // whitelist addresses, accept funds, update balances\r\n        Underfunded, // ICO time finished and minimal amount not raised\r\n        Operational, // production phase\r\n        Paused         // for contract upgrades\r\n    }\r\n\r\n    mapping(address => uint256) public ethPossibleRefunds;\r\n\r\n    uint256 public soldTokens;\r\n\r\n    string public constant name = \"CLEAR Token\";\r\n\r\n    string public constant symbol = \"CLEAR\";\r\n\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping(address => bool) public whitelist;\r\n\r\n    address public reserves;\r\n\r\n    address public stateControl;\r\n\r\n    address public whitelistControl;\r\n\r\n    address public withdrawControl;\r\n\r\n    address public tokenAssignmentControl;\r\n\r\n    States public state;\r\n\r\n    uint256 public startAcceptingFundsBlock;\r\n\r\n    uint256 public endTimestamp;\r\n\r\n    uint256 public ETH_CLEAR; //number of tokens per ETH\r\n\r\n    uint256 public constant NZD_CLEAR = 50; //fixed rate of 50 CLEAR to 1 NZD\r\n\r\n    uint256 constant pointMultiplier = 1e18; //100% = 1*10^18 points\r\n\r\n    uint256 public constant maxTotalSupply = 102400000000 * pointMultiplier; //102.4B tokens\r\n\r\n    uint256 public constant percentForSale = 50;\r\n\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n\r\n    bool public mintingFinished = false;\r\n\r\n\r\n    //this creates the contract and stores the owner. it also passes in 3 addresses to be used later during the lifetime of the contract.\r\n    function ClearToken(\r\n        address _stateControl\r\n    , address _whitelistControl\r\n    , address _withdrawControl\r\n    , address _tokenAssignmentControl\r\n    , address _reserves\r\n    ) public\r\n    {\r\n        stateControl = _stateControl;\r\n        whitelistControl = _whitelistControl;\r\n        withdrawControl = _withdrawControl;\r\n        tokenAssignmentControl = _tokenAssignmentControl;\r\n        moveToState(States.Initial);\r\n        endTimestamp = 0;\r\n        ETH_CLEAR = 0;\r\n        totalSupply = maxTotalSupply;\r\n        soldTokens = 0;\r\n        reserves = _reserves;\r\n        balances[reserves] = totalSupply;\r\n        Mint(reserves, totalSupply);\r\n        Transfer(0x0, reserves, totalSupply);\r\n    }\r\n\r\n    event Whitelisted(address addr);\r\n\r\n    event StateTransition(States oldState, States newState);\r\n\r\n    modifier onlyWhitelist() {\r\n        require(msg.sender == whitelistControl);\r\n        _;\r\n    }\r\n\r\n    modifier onlyStateControl() {\r\n        require(msg.sender == stateControl);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenAssignmentControl() {\r\n        require(msg.sender == tokenAssignmentControl);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWithdraw() {\r\n        require(msg.sender == withdrawControl);\r\n        _;\r\n    }\r\n\r\n    modifier requireState(States _requiredState) {\r\n        require(state == _requiredState);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    BEGIN ICO functions\r\n    */\r\n\r\n    //this is the main funding function, it updates the balances of tokens during the ICO.\r\n    //no particular incentive schemes have been implemented here\r\n    //it is only accessible during the \"ICO\" phase.\r\n    function() payable\r\n    public\r\n    requireState(States.Ico)\r\n    {\r\n        require(whitelist[msg.sender] == true);\r\n\r\n        require(block.timestamp < endTimestamp);\r\n        require(block.number >= startAcceptingFundsBlock);\r\n\r\n        uint256 soldToTuserWithBonus = calcBonus(msg.value);\r\n\r\n        issueTokensToUser(msg.sender, soldToTuserWithBonus);\r\n        ethPossibleRefunds[msg.sender] = ethPossibleRefunds[msg.sender].add(msg.value);\r\n    }\r\n\r\n    function issueTokensToUser(address beneficiary, uint256 amount)\r\n    internal\r\n    {\r\n        uint256 soldTokensAfterInvestment = soldTokens.add(amount);\r\n        require(soldTokensAfterInvestment <= maxTotalSupply.mul(percentForSale).div(100));\r\n\r\n        balances[beneficiary] = balances[beneficiary].add(amount);\r\n        balances[reserves] = balances[reserves].sub(amount);\r\n        soldTokens = soldTokensAfterInvestment;\r\n        Transfer(reserves, beneficiary, amount);\r\n    }\r\n\r\n    function calcBonus(uint256 weiAmount)\r\n    constant\r\n    public\r\n    returns (uint256 resultingTokens)\r\n    {\r\n        uint256 basisTokens = weiAmount.mul(ETH_CLEAR);\r\n        //percentages are integer numbers as per mill (promille) so we can accurately calculate 0.5% = 5. 100% = 1000\r\n        uint256 perMillBonus = Bonus.getBonusFactor(basisTokens, now);\r\n        //100% + bonus % times original amount divided by 100%.\r\n        return basisTokens.mul(per_mill + perMillBonus).div(per_mill);\r\n    }\r\n\r\n    uint256 constant per_mill = 1000;\r\n\r\n\r\n    function moveToState(States _newState)\r\n    internal\r\n    {\r\n        StateTransition(state, _newState);\r\n        state = _newState;\r\n    }\r\n    // ICO contract configuration function\r\n    // new_ETH_NZD is the new rate of ETH in NZD (from which to derive tokens per ETH)\r\n    // newTimestamp is the number of seconds since 1970-01-01 00:00:00 GMT at which the ICO must stop. It must be set in the future.\r\n    function updateEthICOVariables(uint256 _new_ETH_NZD, uint256 _newEndTimestamp)\r\n    public\r\n    onlyStateControl\r\n    {\r\n        require(state == States.Initial || state == States.ValuationSet);\r\n        require(_new_ETH_NZD > 0);\r\n        require(block.timestamp < _newEndTimestamp);\r\n        endTimestamp = _newEndTimestamp;\r\n        // initial conversion rate of ETH_CLEAR set now, this is used during the Ico phase.\r\n        ETH_CLEAR = _new_ETH_NZD.mul(NZD_CLEAR);\r\n        // check pointMultiplier\r\n        moveToState(States.ValuationSet);\r\n    }\r\n\r\n    function updateETHNZD(uint256 _new_ETH_NZD)\r\n    public\r\n    onlyTokenAssignmentControl\r\n    requireState(States.Ico)\r\n    {\r\n        require(_new_ETH_NZD > 0);\r\n        ETH_CLEAR = _new_ETH_NZD.mul(NZD_CLEAR);\r\n    }\r\n\r\n    function startICO()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.ValuationSet)\r\n    {\r\n        require(block.timestamp < endTimestamp);\r\n        startAcceptingFundsBlock = block.number;\r\n        moveToState(States.Ico);\r\n    }\r\n\r\n    function addPresaleAmount(address beneficiary, uint256 amount)\r\n    public\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(state == States.ValuationSet || state == States.Ico);\r\n        issueTokensToUser(beneficiary, amount);\r\n    }\r\n\r\n\r\n    function endICO()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.Ico)\r\n    {\r\n        finishMinting();\r\n        moveToState(States.Operational);\r\n    }\r\n\r\n    function anyoneEndICO()\r\n    public\r\n    requireState(States.Ico)\r\n    {\r\n        require(block.timestamp > endTimestamp);\r\n        finishMinting();\r\n        moveToState(States.Operational);\r\n    }\r\n\r\n    function finishMinting()\r\n    internal\r\n    {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n    }\r\n\r\n    function addToWhitelist(address _whitelisted)\r\n    public\r\n    onlyWhitelist\r\n        //    requireState(States.Ico)\r\n    {\r\n        whitelist[_whitelisted] = true;\r\n        Whitelisted(_whitelisted);\r\n    }\r\n\r\n\r\n    //emergency pause for the ICO\r\n    function pause()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.Ico)\r\n    {\r\n        moveToState(States.Paused);\r\n    }\r\n\r\n    //in case we want to completely abort\r\n    function abort()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.Paused)\r\n    {\r\n        moveToState(States.Underfunded);\r\n    }\r\n\r\n    //un-pause\r\n    function resumeICO()\r\n    public\r\n    onlyStateControl\r\n    requireState(States.Paused)\r\n    {\r\n        moveToState(States.Ico);\r\n    }\r\n\r\n    //in case of a failed/aborted ICO every investor can get back their money\r\n    function requestRefund()\r\n    public\r\n    requireState(States.Underfunded)\r\n    {\r\n        require(ethPossibleRefunds[msg.sender] > 0);\r\n        //there is no need for updateAccount(msg.sender) since the token never became active.\r\n        uint256 payout = ethPossibleRefunds[msg.sender];\r\n        //reverse calculate the amount to pay out\r\n        ethPossibleRefunds[msg.sender] = 0;\r\n        msg.sender.transfer(payout);\r\n    }\r\n\r\n    //after the ico has run its course, the withdraw account can drain funds bit-by-bit as needed.\r\n    function requestPayout(uint _amount)\r\n    public\r\n    onlyWithdraw //very important!\r\n    requireState(States.Operational)\r\n    {\r\n        msg.sender.transfer(_amount);\r\n    }\r\n\r\n    //if this contract gets a balance in some other ERC20 contract - or even iself - then we can rescue it.\r\n    function rescueToken(ERC20Basic _foreignToken, address _to)\r\n    public\r\n    onlyTokenAssignmentControl\r\n    requireState(States.Operational)\r\n    {\r\n        _foreignToken.transfer(_to, _foreignToken.balanceOf(this));\r\n    }\r\n    /**\r\n    END ICO functions\r\n    */\r\n\r\n    /**\r\n    BEGIN ERC20 functions\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n    public\r\n    requireState(States.Operational)\r\n    returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    requireState(States.Operational)\r\n    returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function balanceOf(address _account)\r\n    public\r\n    constant\r\n    returns (uint256 balance) {\r\n        return balances[_account];\r\n    }\r\n\r\n    /**\r\n    END ERC20 functions\r\n    */\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"stateControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"calcBonus\",\"outputs\":[{\"name\":\"resultingTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"anyoneEndICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new_ETH_NZD\",\"type\":\"uint256\"},{\"name\":\"_newEndTimestamp\",\"type\":\"uint256\"}],\"name\":\"updateEthICOVariables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"abort\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignToken\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserves\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startAcceptingFundsBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_CLEAR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NZD_CLEAR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAssignmentControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addPresaleAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelisted\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new_ETH_NZD\",\"type\":\"uint256\"}],\"name\":\"updateETHNZD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethPossibleRefunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_stateControl\",\"type\":\"address\"},{\"name\":\"_whitelistControl\",\"type\":\"address\"},{\"name\":\"_withdrawControl\",\"type\":\"address\"},{\"name\":\"_tokenAssignmentControl\",\"type\":\"address\"},{\"name\":\"_reserves\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"ClearToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000009848f88307e6e2adf95ebeced073d63802ece69000000000000000000000000be0ace1e742a5cc246d719bf20be908b2ed905e80000000000000000000000008b5ab35b50deb29d84dff4053bb013d1fa82fcfb00000000000000000000000071ab6571680f7745008b3adfb4081f7e20429e1600000000000000000000000002c4e5d881e22c094731ad3073ee8afe5dfb4163","Library":"","SwarmSource":"bzzr://843e51ff42d875b7a418603310fefd64d3ae268e1bbff7ccea3e52579e58d130"}]}