{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary ECRecovery {\r\n\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes sig)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            // solium-disable-next-line arg-overflow\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * @dev and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(\r\n            \"\\x19Ethereum Signed Message:\\n32\",\r\n            hash\r\n        );\r\n    }\r\n}\r\n\r\ncontract Htlc {\r\n    using ECRecovery for bytes32;\r\n\r\n    // TYPES\r\n\r\n    struct Multisig { // Locked by time and/or authority approval for HTLC conversion or earlyResolve\r\n        address owner; // Owns funds deposited in multisig,\r\n        address authority; // Can approve earlyResolve of funds out of multisig\r\n        uint deposit; // Amount deposited by owner in this multisig\r\n        uint unlockTime; // Multisig expiration timestamp in seconds\r\n    }\r\n\r\n    struct AtomicSwap { // HTLC swap used for regular transfers\r\n        address initiator; // Initiated this swap\r\n        address beneficiary; // Beneficiary of this swap\r\n        uint amount; // If zero then swap not active anymore\r\n        uint fee; // Fee amount to be paid to multisig authority\r\n        uint expirationTime; // Swap expiration timestamp in seconds\r\n        bytes32 hashedSecret; // sha256(secret), hashed secret of swap initiator\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    address constant FEE_RECIPIENT = 0x0E5cB767Cce09A7F3CA594Df118aa519BE5e2b5A;\r\n    mapping (bytes32 => Multisig) public hashIdToMultisig;\r\n    mapping (bytes32 => AtomicSwap) public hashIdToSwap;\r\n\r\n    // EVENTS\r\n\r\n    // TODO add events for all public functions\r\n\r\n    // MODIFIERS\r\n\r\n    // METHODS\r\n\r\n    /**\r\n    @notice Send ether out of this contract to multisig owner and update or delete entry in multisig mapping\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @param amount Spend this amount of ether\r\n    */\r\n    function spendFromMultisig(bytes32 msigId, uint amount, address recipient)\r\n        internal\r\n    {\r\n        // Require sufficient deposit amount; Prevents buffer underflow\r\n        require(amount <= hashIdToMultisig[msigId].deposit);\r\n        hashIdToMultisig[msigId].deposit -= amount;\r\n        if (hashIdToMultisig[msigId].deposit == 0) {\r\n            // Delete multisig\r\n            delete hashIdToMultisig[msigId];\r\n            assert(hashIdToMultisig[msigId].deposit == 0);\r\n        }\r\n        // Transfer recipient\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    /**\r\n    @notice Send ether out of this contract to swap beneficiary and update or delete entry in swap mapping\r\n    @param swapId Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifier\r\n    @param amount Spend this amount of ether\r\n    */\r\n    function spendFromSwap(bytes32 swapId, uint amount, address recipient)\r\n        internal\r\n    {\r\n        // Require sufficient swap amount; Prevents buffer underflow\r\n        require(amount <= hashIdToSwap[swapId].amount);\r\n        hashIdToSwap[swapId].amount -= amount;\r\n        if (hashIdToSwap[swapId].amount == 0) {\r\n            // Delete swap\r\n            delete hashIdToSwap[swapId];\r\n            assert(hashIdToSwap[swapId].amount == 0);\r\n        }\r\n        // Transfer to recipient\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n    @notice Initialise and reparametrize Multisig\r\n    @dev Uses msg.value to fund Multisig\r\n    @param authority Second multisig Authority. Usually this is the Exchange.\r\n    @param unlockTime Lock Ether until unlockTime in seconds.\r\n    @return msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    */\r\n    function initialiseMultisig(address authority, uint unlockTime)\r\n        public\r\n        payable\r\n        returns (bytes32 msigId)\r\n    {\r\n        // Require not own authority and ether are sent\r\n        require(msg.sender != authority);\r\n        require(msg.value > 0);\r\n        msigId = keccak256(\r\n            msg.sender,\r\n            authority,\r\n            msg.value,\r\n            unlockTime\r\n        );\r\n\r\n        Multisig storage multisig = hashIdToMultisig[msigId];\r\n        if (multisig.deposit == 0) { // New or empty multisig\r\n            // Create new multisig\r\n            multisig.owner = msg.sender;\r\n            multisig.authority = authority;\r\n        }\r\n        // Adjust balance and locktime\r\n        reparametrizeMultisig(msigId, unlockTime);\r\n    }\r\n\r\n    /**\r\n    @notice Deposit msg.value ether into a multisig and set unlockTime\r\n    @dev Can increase deposit and/or unlockTime but not owner or authority\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @param unlockTime Lock Ether until unlockTime in seconds.\r\n    */\r\n    function reparametrizeMultisig(bytes32 msigId, uint unlockTime)\r\n        public\r\n        payable\r\n    {\r\n        Multisig storage multisig = hashIdToMultisig[msigId];\r\n        assert(\r\n            multisig.deposit + msg.value >=\r\n            multisig.deposit\r\n        ); // Throws on overflow.\r\n        multisig.deposit += msg.value;\r\n        assert(multisig.unlockTime <= unlockTime); // Can only increase unlockTime\r\n        multisig.unlockTime = unlockTime;\r\n    }\r\n\r\n    // TODO allow for batch convertIntoHtlc\r\n    /**\r\n    @notice Convert swap from multisig to htlc mode\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @param beneficiary Beneficiary of this swap\r\n    @param amount Convert this amount from multisig into swap\r\n    @param fee Fee amount to be paid to multisig authority\r\n    @param expirationTime Swap expiration timestamp in seconds; not more than 1 day from now\r\n    @param hashedSecret sha3(secret), hashed secret of swap initiator\r\n    @return swapId Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifier\r\n    */\r\n    function convertIntoHtlc(bytes32 msigId, address beneficiary, uint amount, uint fee, uint expirationTime, bytes32 hashedSecret)\r\n        public\r\n        returns (bytes32 swapId)\r\n    {\r\n        // Require owner with sufficient deposit\r\n        require(hashIdToMultisig[msigId].owner == msg.sender);\r\n        require(hashIdToMultisig[msigId].deposit >= amount + fee); // Checks for underflow\r\n        require(now <= expirationTime && expirationTime <= now + 86400); // Not more than 1 day\r\n        require(amount > 0); // Non-empty amount as definition for active swap\r\n        // Account in multisig balance\r\n        hashIdToMultisig[msigId].deposit -= amount + fee;\r\n        swapId = keccak256(\r\n            msg.sender,\r\n            beneficiary,\r\n            amount,\r\n            fee,\r\n            expirationTime,\r\n            hashedSecret\r\n        );\r\n        // Create swap\r\n        AtomicSwap storage swap = hashIdToSwap[swapId];\r\n        swap.initiator = msg.sender;\r\n        swap.beneficiary = beneficiary;\r\n        swap.amount = amount;\r\n        swap.fee = fee;\r\n        swap.expirationTime = expirationTime;\r\n        swap.hashedSecret = hashedSecret;\r\n        // Transfer fee to multisig.authority\r\n        hashIdToMultisig[msigId].authority.transfer(fee);\r\n    }\r\n\r\n    // TODO calc gas limit\r\n    /**\r\n    @notice Withdraw ether and delete the htlc swap. Equivalent to REGULAR_TRANSFER in Nimiq\r\n    @dev Transfer swap amount to beneficiary of swap and fee to authority\r\n    @param swapIds Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifiers\r\n    @param secrets Hashed secrets of htlc swaps\r\n    */\r\n    function batchRegularTransfer(bytes32[] swapIds, bytes32[] secrets)\r\n        public\r\n    {\r\n        for (uint i = 0; i < swapIds.length; ++i)\r\n            regularTransfer(swapIds[i], secrets[i]);\r\n    }\r\n\r\n    /**\r\n    @notice Withdraw ether and delete the htlc swap. Equivalent to REGULAR_TRANSFER in Nimiq\r\n    @dev Transfer swap amount to beneficiary of swap and fee to authority\r\n    @param swapId Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifier\r\n    @param secret Hashed secret of htlc swap\r\n    */\r\n    function regularTransfer(bytes32 swapId, bytes32 secret)\r\n        public\r\n    {\r\n        // Require valid secret provided\r\n        require(sha256(secret) == hashIdToSwap[swapId].hashedSecret);\r\n        // Execute swap\r\n        spendFromSwap(swapId, hashIdToSwap[swapId].amount, hashIdToSwap[swapId].beneficiary);\r\n        spendFromSwap(swapId, hashIdToSwap[swapId].fee, FEE_RECIPIENT);\r\n    }\r\n\r\n    /**\r\n    @notice Reclaim all the expired, non-empty swaps into a multisig\r\n    @dev Transfer swap amount to beneficiary of swap and fee to authority\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier to which deposit expired swaps\r\n    @param swapIds Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifiers\r\n    */\r\n    function batchReclaimExpiredSwaps(bytes32 msigId, bytes32[] swapIds)\r\n        public\r\n    {\r\n        for (uint i = 0; i < swapIds.length; ++i)\r\n            reclaimExpiredSwaps(msigId, swapIds[i]);\r\n    }\r\n\r\n    /**\r\n    @notice Reclaim an expired, non-empty swap into a multisig\r\n    @dev Transfer swap amount to beneficiary of swap and fee to authority\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier to which deposit expired swaps\r\n    @param swapId Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifier\r\n    */\r\n    function reclaimExpiredSwaps(bytes32 msigId, bytes32 swapId)\r\n        public\r\n    {\r\n        // Require: msg.sender == ower or authority\r\n        require(\r\n            hashIdToMultisig[msigId].owner == msg.sender ||\r\n            hashIdToMultisig[msigId].authority == msg.sender\r\n        );\r\n        // TODO! link msigId to swapId\r\n        // Require: is expired\r\n        require(now >= hashIdToSwap[swapId].expirationTime);\r\n        uint amount = hashIdToSwap[swapId].amount;\r\n        assert(hashIdToMultisig[msigId].deposit + amount >= amount); // Throws on overflow.\r\n        delete hashIdToSwap[swapId];\r\n        hashIdToMultisig[msigId].deposit += amount;\r\n    }\r\n\r\n    /**\r\n    @notice Withdraw ether and delete the htlc swap. Equivalent to EARLY_RESOLVE in Nimiq\r\n    @param hashedMessage bytes32 hash of unique swap hash, the hash is the signed message. What is recovered is the signer address.\r\n    @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n    */\r\n    function earlyResolve(bytes32 msigId, uint amount, bytes32 hashedMessage, bytes sig)\r\n        public\r\n    {\r\n        // Require: msg.sender == ower or authority\r\n        require(\r\n            hashIdToMultisig[msigId].owner == msg.sender ||\r\n            hashIdToMultisig[msigId].authority == msg.sender\r\n        );\r\n        // Require: valid signature from not tx.sending authority\r\n        address otherAuthority = hashIdToMultisig[msigId].owner == msg.sender ?\r\n            hashIdToMultisig[msigId].authority :\r\n            hashIdToMultisig[msigId].owner;\r\n        require(otherAuthority == hashedMessage.recover(sig));\r\n\r\n        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);\r\n    }\r\n\r\n    /**\r\n    @notice Withdraw ether and delete the htlc swap. Equivalent to TIMEOUT_RESOLVE in Nimiq\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @dev Only refunds owned multisig deposits\r\n    */\r\n    function timeoutResolve(bytes32 msigId, uint amount)\r\n        public\r\n    {\r\n        // Require sufficient amount and time passed\r\n        require(hashIdToMultisig[msigId].deposit >= amount);\r\n        require(now >= hashIdToMultisig[msigId].unlockTime);\r\n\r\n        spendFromMultisig(msigId, amount, hashIdToMultisig[msigId].owner);\r\n    }\r\n\r\n    // TODO add timelocked selfdestruct function for initial version\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"swapId\",\"type\":\"bytes32\"},{\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"regularTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"hashedMessage\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"earlyResolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"reparametrizeMultisig\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"name\":\"hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"convertIntoHtlc\",\"outputs\":[{\"name\":\"swapId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"swapIds\",\"type\":\"bytes32[]\"},{\"name\":\"secrets\",\"type\":\"bytes32[]\"}],\"name\":\"batchRegularTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"swapId\",\"type\":\"bytes32\"}],\"name\":\"reclaimExpiredSwaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"timeoutResolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"swapIds\",\"type\":\"bytes32[]\"}],\"name\":\"batchReclaimExpiredSwaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashIdToMultisig\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"authority\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"},{\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"initialiseMultisig\",\"outputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashIdToSwap\",\"outputs\":[{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"name\":\"hashedSecret\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Htlc","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://210250d5c41ab80f1a161f24783b066d96fd29a002da425c8d97685ff31f76a3"}]}