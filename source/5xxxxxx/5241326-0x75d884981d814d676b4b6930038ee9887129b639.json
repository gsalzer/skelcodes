{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n\r\ncontract IConnections {\r\n    // Forward = the connection is from the Connection creator to the specified recipient\r\n    // Backwards = the connection is from the specified recipient to the Connection creator\r\n    enum Direction {NotApplicable, Forwards, Backwards, Invalid}\r\n    function createUser() external returns (address entityAddress);\r\n    function createUserAndConnection(address _connectionTo, bytes32 _connectionType, Direction _direction) external returns (address entityAddress);\r\n    function createVirtualEntity() external returns (address entityAddress);\r\n    function createVirtualEntityAndConnection(address _connectionTo, bytes32 _connectionType, Direction _direction) external returns (address entityAddress);\r\n    function editEntity(address _entity, bool _active, bytes32 _data) external;\r\n    function transferEntityOwnerPush(address _entity, address _newOwner) external;\r\n    function transferEntityOwnerPull(address _entity) external;\r\n    function addConnection(address _entity, address _connectionTo, bytes32 _connectionType, Direction _direction) public;\r\n    function editConnection(address _entity, address _connectionTo, bytes32 _connectionType, Direction _direction, bool _active, bytes32 _data, uint _expiration) external;\r\n    function removeConnection(address _entity, address _connectionTo, bytes32 _connectionType) external;\r\n    function isUser(address _entity) view public returns (bool isUserEntity);\r\n    function getEntity(address _entity) view external returns (bool active, address transferOwnerTo, bytes32 data, address owner);\r\n    function getConnection(address _entity, address _connectionTo, bytes32 _connectionType) view external returns (bool entityActive, bool connectionEntityActive, bool connectionActive, bytes32 data, Direction direction, uint expiration);\r\n\r\n    // ################## Events ################## //\r\n    event entityAdded(address indexed entity, address indexed owner);\r\n    event entityModified(address indexed entity, address indexed owner, bool indexed active, bytes32 data);\r\n    event entityOwnerChangeRequested(address indexed entity, address indexed oldOwner, address newOwner);\r\n    event entityOwnerChanged(address indexed entity, address indexed oldOwner, address newOwner);\r\n    event connectionAdded(address indexed entity, address indexed connectionTo, bytes32 connectionType, Direction direction);\r\n    event connectionModified(address indexed entity, address indexed connectionTo, bytes32 indexed connectionType, Direction direction, bool active, uint expiration);\r\n    event connectionRemoved(address indexed entity, address indexed connectionTo, bytes32 indexed connectionType);\r\n    event entityResolved(address indexed entityRequested, address indexed entityResolved);    \r\n}\r\n\r\n\r\n/**\r\n * @title Connections v0.2\r\n * @dev The Connections contract records different connections between different types of entities.\r\n *\r\n * The contract has been designed for flexibility and scalability for use by anyone wishing to record different types of connections.\r\n *\r\n * Entities can be Users representing People, or Virtual Entities representing abstract types such as companies, objects, devices, robots etc...\r\n * User entities are special: each Ethereum address that creates or controls a User entity can only ever create one User Entity.\r\n * Each entity has an address to refer to it.\r\n *\r\n * Each entity has a number of connections to other entities, which are refered to using the entities address that the connection is to.\r\n * Modifying or removing entities, or adding, modifying or removing connections can only be done by the entity owner.\r\n *\r\n * Each connection also has a type, a direction and an expiration. The use of these fields is up to the Dapp to define and interprete.\r\n * Hashing a string of the connection name to create the connection type is suggested to obscure and diffuse types. Example bytes32 connection types:\r\n *     0x30ed9383ab64b27cb4b70035e743294fe1a1c83eaf57eca05033b523d1fa4261 = keccak256(\"isAdvisorOf\")\r\n *     0xffe72ffb7d5cc4224f27ea8ad324f4b53b37835a76fc2b627b3d669180b75ecc = keccak256(\"isPartneredWith\")\r\n *     0xa64b51178a7ee9735fb96d8e7ffdebb455b02beb3b1e17a709b5c1beef797405 = keccak256(\"isEmployeeOf\")\r\n *     0x0079ca0c877589ba53b2e415a660827390d2c2a62123cef473009d003577b7f6 = keccak256(\"isColleagueOf\")\r\n *\r\n */\r\ncontract Connections is IConnections {\r\n\r\n    struct Entity {\r\n        bool active;\r\n        address transferOwnerTo;\r\n        address owner;\r\n        bytes32 data; // optional, this can link to IPFS or another off-chain storage location\r\n        mapping (address => mapping (bytes32 => Connection)) connections;\r\n    }\r\n\r\n    // Connection has a type and direction\r\n    struct Connection {\r\n        bool active;\r\n        bytes32 data; // optional, this can link to IPFS or another off-chain storage location\r\n        Direction direction;\r\n        uint expiration; // optional, unix timestamp or latest date to assume this connection is valid, 0 as no expiration\r\n    }\r\n\r\n    mapping (address => Entity) public entities;\r\n    mapping (address => address) public entityOfUser;\r\n    uint256 public virtualEntitiesCreated = 0;\r\n\r\n    // ################## Constructor and Fallback function ################## //\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Connections() public {}\r\n\r\n    /**\r\n     * Fallback function that cannot be called and will not accept Ether\r\n     * Note that Ether can still be forced to this contract with a contract suicide()\r\n     */\r\n    function () external {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ################## External function ################## //\r\n    /**\r\n     * Creates a new user entity with an address of the msg.sender\r\n     */\r\n    function createUser() external returns (address entityAddress) {\r\n        entityAddress = msg.sender;\r\n        assert(entityOfUser[msg.sender] == address(0));\r\n        createEntity(entityAddress, msg.sender);\r\n        entityOfUser[msg.sender] = entityAddress;\r\n    }\r\n\r\n    /**\r\n     * Creates a new user entity and a connection in one transaction\r\n     * @param _connectionTo - the address of the entity to connect to\r\n     * @param _connectionType - hash of the connection type\r\n     * @param _direction - indicates the direction of the connection type\r\n     */\r\n    function createUserAndConnection(\r\n        address _connectionTo,\r\n        bytes32 _connectionType,\r\n        Direction _direction\r\n    )\r\n        external returns (address entityAddress)\r\n    {\r\n        entityAddress = msg.sender;\r\n        assert(entityOfUser[msg.sender] == address(0));\r\n        createEntity(entityAddress, msg.sender);\r\n        entityOfUser[msg.sender] = entityAddress;\r\n        addConnection(entityAddress, _connectionTo, _connectionType, _direction);\r\n    }\r\n\r\n    /**\r\n     * Creates a new virtual entity that is assigned to a unique address\r\n     */\r\n    function createVirtualEntity() external returns (address entityAddress) {\r\n        entityAddress = createVirtualAddress();\r\n        createEntity(entityAddress, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Creates a new virtual entity and a connection in one transaction\r\n     * @param _connectionTo - the address of the entity to connect to\r\n     * @param _connectionType - hash of the connection type\r\n     * @param _direction - indicates the direction of the connection type\r\n     */\r\n    function createVirtualEntityAndConnection(\r\n        address _connectionTo,\r\n        bytes32 _connectionType,\r\n        Direction _direction\r\n    )\r\n        external returns (address entityAddress)\r\n    {\r\n        entityAddress = createVirtualAddress();\r\n        createEntity(entityAddress, msg.sender);\r\n        addConnection(entityAddress, _connectionTo, _connectionType, _direction);\r\n    }\r\n\r\n    /**\r\n     * Edits data or active boolean of an entity that the msg sender is an owner of\r\n     * This can be used to activate or deactivate an entity\r\n     * @param _entity - the address of the entity to edit\r\n     * @param _active - boolean to indicate if the entity is active or not\r\n     * @param _data - data to be used to locate off-chain information about the user\r\n     */\r\n    function editEntity(address _entity, bool _active, bytes32 _data) external {\r\n        address resolvedEntity = resolveEntityAddressAndOwner(_entity);\r\n        Entity storage entity = entities[resolvedEntity];\r\n        entity.active = _active;\r\n        entity.data = _data;\r\n        entityModified(_entity, msg.sender, _active, _data);\r\n    }\r\n\r\n    /**\r\n     * Creates a request to transfer the ownership of an entity which must be accepted.\r\n     * To cancel a request execute this function with _newOwner = address(0)\r\n     * @param _entity - the address of the entity to transfer\r\n     * @param _newOwner - the address of the new owner that will then have the exclusive permissions to control the entity\r\n     */\r\n    function transferEntityOwnerPush(address _entity, address _newOwner) external {\r\n        address resolvedEntity = resolveEntityAddressAndOwner(_entity);\r\n        entities[resolvedEntity].transferOwnerTo = _newOwner;\r\n        entityOwnerChangeRequested(_entity, msg.sender, _newOwner);\r\n    }\r\n\r\n    /**\r\n     * Accepts a request to transfer the ownership of an entity\r\n     * @param _entity - the address of the entity to get ownership of\r\n     */\r\n    function transferEntityOwnerPull(address _entity) external {\r\n        address resolvedEntity = resolveEntityAddress(_entity);\r\n        emitEntityResolution(_entity, resolvedEntity);\r\n        Entity storage entity = entities[resolvedEntity];\r\n        require(entity.transferOwnerTo == msg.sender);\r\n        if (isUser(resolvedEntity)) { // This is a user entity\r\n            assert(entityOfUser[msg.sender] == address(0) ||\r\n                   entityOfUser[msg.sender] == resolvedEntity);\r\n            entityOfUser[msg.sender] = resolvedEntity;\r\n        }\r\n        address oldOwner = entity.owner;\r\n        entity.owner = entity.transferOwnerTo;\r\n        entity.transferOwnerTo = address(0);\r\n        entityOwnerChanged(_entity, oldOwner, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Edits a connection to another entity\r\n     * @param _entity - the address of the entity to edit the connection of\r\n     * @param _connectionTo - the address of the entity to connect to\r\n     * @param _connectionType - hash of the connection type\r\n     * @param _active - boolean to indicate if the connection is active or not\r\n     * @param _direction - indicates the direction of the connection type\r\n     * @param _expiration - number to indicate the expiration of the connection\r\n     */\r\n    function editConnection(\r\n        address _entity,\r\n        address _connectionTo,\r\n        bytes32 _connectionType,\r\n        Direction _direction,\r\n        bool _active,\r\n        bytes32 _data,\r\n        uint _expiration\r\n    )\r\n        external\r\n    {\r\n        address resolvedEntity = resolveEntityAddressAndOwner(_entity);\r\n        address resolvedConnectionEntity = resolveEntityAddress(_connectionTo);\r\n        emitEntityResolution(_connectionTo, resolvedConnectionEntity);\r\n        Entity storage entity = entities[resolvedEntity];\r\n        Connection storage connection = entity.connections[resolvedConnectionEntity][_connectionType];\r\n        connection.active = _active;\r\n        connection.direction = _direction;\r\n        connection.data = _data;\r\n        connection.expiration = _expiration;\r\n        connectionModified(_entity, _connectionTo, _connectionType, _direction, _active, _expiration);\r\n    }\r\n\r\n    /**\r\n     * Removes a connection from the entities connections mapping.\r\n     * If this is the last connection of any type to the _connectionTo address, then the removeConnection function should also be called to clean up the Entity\r\n     * @param _entity - the address of the entity to edit the connection of\r\n     * @param _connectionTo - the address of the entity to connect to\r\n     * @param _connectionType - hash of the connection type\r\n     */\r\n    function removeConnection(address _entity, address _connectionTo, bytes32 _connectionType) external {\r\n        address resolvedEntity = resolveEntityAddressAndOwner(_entity);\r\n        address resolvedConnectionEntity = resolveEntityAddress(_connectionTo);\r\n        emitEntityResolution(_connectionTo,resolvedConnectionEntity);\r\n        Entity storage entity = entities[resolvedEntity];\r\n        delete entity.connections[resolvedConnectionEntity][_connectionType];\r\n        connectionRemoved(_entity, _connectionTo, _connectionType); // TBD: @haresh should we use resolvedEntity and resolvedConnectionEntity here?\r\n    }\r\n\r\n    /**\r\n     * Returns the sha256 hash of a string. Useful for looking up the bytes32 values are for connection types.\r\n     * Note this function is designed to be called off-chain for convenience, it is not used by any functions internally and does not change contract state\r\n     * @param _string - string to hash\r\n     * @return result - the hash of the string\r\n     */\r\n    function sha256ofString(string _string) external pure returns (bytes32 result) {\r\n        result = keccak256(_string);\r\n    }\r\n\r\n    /**\r\n     * Returns all the fields of an entity\r\n     * @param _entity - the address of the entity to retrieve\r\n     * @return (active, transferOwnerTo, data, owner) - a tuple containing the active flag, transfer status, data field and owner of an entity\r\n     */\r\n    function getEntity(address _entity) view external returns (bool active, address transferOwnerTo, bytes32 data, address owner) {\r\n        address resolvedEntity = resolveEntityAddress(_entity);\r\n        Entity storage entity = entities[resolvedEntity];\r\n        return (entity.active, entity.transferOwnerTo, entity.data, entity.owner);\r\n    }\r\n\r\n    /**\r\n     * Returns details of a connection\r\n     * @param _entity - the address of the entity which created the\r\n     * @return (entityActive, connectionEntityActive, connectionActive, data, direction, expiration)\r\n     *                - tupple containing the entity active and the connection fields\r\n     */\r\n    function getConnection(\r\n        address _entity,\r\n        address _connectionTo,\r\n        bytes32 _connectionType\r\n    )\r\n        view external returns (\r\n            bool entityActive,\r\n            bool connectionEntityActive,\r\n            bool connectionActive,\r\n            bytes32 data,\r\n            Direction direction,\r\n            uint expiration\r\n    ){\r\n        address resolvedEntity = resolveEntityAddress(_entity);\r\n        address resolvedConnectionEntity = resolveEntityAddress(_connectionTo);\r\n        Entity storage entity = entities[resolvedEntity];\r\n        Connection storage connection = entity.connections[resolvedConnectionEntity][_connectionType];\r\n        return (entity.active, entities[resolvedConnectionEntity].active, connection.active, connection.data, connection.direction, connection.expiration);\r\n    }\r\n\r\n\r\n    // ################## Public function ################## //\r\n    /**\r\n     * Creates a new connection to another entity\r\n     * @param _entity - the address of the entity to add a connection to\r\n     * @param _connectionTo - the address of the entity to connect to\r\n     * @param _connectionType - hash of the connection type\r\n     * @param _direction - indicates the direction of the connection type\r\n     */\r\n    function addConnection(\r\n        address _entity,\r\n        address _connectionTo,\r\n        bytes32 _connectionType,\r\n        Direction _direction\r\n    )\r\n        public\r\n    {\r\n        address resolvedEntity = resolveEntityAddressAndOwner(_entity);\r\n        address resolvedEntityConnection = resolveEntityAddress(_connectionTo);\r\n        emitEntityResolution(_connectionTo, resolvedEntityConnection);\r\n        Entity storage entity = entities[resolvedEntity];\r\n        assert(!entity.connections[resolvedEntityConnection][_connectionType].active);\r\n        Connection storage connection = entity.connections[resolvedEntityConnection][_connectionType];\r\n        connection.active = true;\r\n        connection.direction = _direction;\r\n        connectionAdded(_entity, _connectionTo, _connectionType, _direction);\r\n    }\r\n\r\n    /**\r\n     * Returns true if an entity is a user, false if a virtual entity or fails if is not an entity\r\n     * @param _entity - the address of the entity\r\n     * @return isUserEntity - true if the entity was created with createUser(), false if the entity is created using createVirtualEntity()\r\n     */\r\n    function isUser(address _entity) view public returns (bool isUserEntity) {\r\n        address resolvedEntity = resolveEntityAddress(_entity);\r\n        assert(entities[resolvedEntity].active); // Make sure the user is active, otherwise this function call is invalid\r\n        address owner = entities[resolvedEntity].owner;\r\n        isUserEntity = (resolvedEntity == entityOfUser[owner]);\r\n    }\r\n\r\n\r\n    // ################## Internal functions ################## //\r\n    /**\r\n     * Creates a new entity at a specified address\r\n     */\r\n    function createEntity(address _entityAddress, address _owner) internal {\r\n        require(!entities[_entityAddress].active); // Ensure the new entity address is not in use, prevents forceful takeover off addresses\r\n        Entity storage entity = entities[_entityAddress];\r\n        entity.active = true;\r\n        entity.owner = _owner;\r\n        entityAdded(_entityAddress, _owner);\r\n    }\r\n\r\n    /**\r\n     * Returns a new unique deterministic address that has not been used before\r\n     */\r\n    function createVirtualAddress() internal returns (address virtualAddress) {\r\n        virtualAddress = address(keccak256(safeAdd(virtualEntitiesCreated,block.number)));\r\n        virtualEntitiesCreated = safeAdd(virtualEntitiesCreated,1);\r\n    }\r\n\r\n    /**\r\n     * Emits an event if an entity resolution took place. Separated out as it would impact\r\n     * view only functions which need entity resolution as well.\r\n     */\r\n    function emitEntityResolution(address _entity, address _resolvedEntity) internal {\r\n        if (_entity != _resolvedEntity)\r\n            entityResolved(_entity,_resolvedEntity);\r\n    }\r\n\r\n    /**\r\n     * Returns the correct entity address resolved based on entityOfUser mapping\r\n     */\r\n    function resolveEntityAddress(address _entityAddress) internal view returns (address resolvedAddress) {\r\n        if (entityOfUser[_entityAddress] != address(0) && entityOfUser[_entityAddress] != _entityAddress) {\r\n            resolvedAddress = entityOfUser[_entityAddress];\r\n        } else {\r\n            resolvedAddress = _entityAddress;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the correct entity address resolved based on entityOfUser mapping and also reverts if the\r\n     * resolved if it is owned by the message sender\r\n     * sender.\r\n     */\r\n    function resolveEntityAddressAndOwner(address _entityAddress) internal returns (address entityAddress) {\r\n        entityAddress = resolveEntityAddress(_entityAddress);\r\n        emitEntityResolution(_entityAddress, entityAddress);\r\n        require(entities[entityAddress].owner == msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Adds two numbers and returns result throws in case an overflow occurs.\r\n     */\r\n    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert(z >= x);\r\n      return z;\r\n    }    \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"entityOfUser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_connectionTo\",\"type\":\"address\"},{\"name\":\"_connectionType\",\"type\":\"bytes32\"},{\"name\":\"_direction\",\"type\":\"uint8\"},{\"name\":\"_active\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes32\"},{\"name\":\"_expiration\",\"type\":\"uint256\"}],\"name\":\"editConnection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_active\",\"type\":\"bool\"},{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"editEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"entities\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"transferOwnerTo\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createUser\",\"outputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferEntityOwnerPush\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"}],\"name\":\"isUser\",\"outputs\":[{\"name\":\"isUserEntity\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_string\",\"type\":\"string\"}],\"name\":\"sha256ofString\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createVirtualEntity\",\"outputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"}],\"name\":\"transferEntityOwnerPull\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"}],\"name\":\"getEntity\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"transferOwnerTo\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_connectionTo\",\"type\":\"address\"},{\"name\":\"_connectionType\",\"type\":\"bytes32\"}],\"name\":\"getConnection\",\"outputs\":[{\"name\":\"entityActive\",\"type\":\"bool\"},{\"name\":\"connectionEntityActive\",\"type\":\"bool\"},{\"name\":\"connectionActive\",\"type\":\"bool\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"direction\",\"type\":\"uint8\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"virtualEntitiesCreated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_connectionTo\",\"type\":\"address\"},{\"name\":\"_connectionType\",\"type\":\"bytes32\"}],\"name\":\"removeConnection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entity\",\"type\":\"address\"},{\"name\":\"_connectionTo\",\"type\":\"address\"},{\"name\":\"_connectionType\",\"type\":\"bytes32\"},{\"name\":\"_direction\",\"type\":\"uint8\"}],\"name\":\"addConnection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_connectionTo\",\"type\":\"address\"},{\"name\":\"_connectionType\",\"type\":\"bytes32\"},{\"name\":\"_direction\",\"type\":\"uint8\"}],\"name\":\"createUserAndConnection\",\"outputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_connectionTo\",\"type\":\"address\"},{\"name\":\"_connectionType\",\"type\":\"bytes32\"},{\"name\":\"_direction\",\"type\":\"uint8\"}],\"name\":\"createVirtualEntityAndConnection\",\"outputs\":[{\"name\":\"entityAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"entityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"active\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"entityModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"entityOwnerChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"entityOwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"connectionTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"connectionType\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"direction\",\"type\":\"uint8\"}],\"name\":\"connectionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"connectionTo\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"connectionType\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"direction\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"connectionModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"connectionTo\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"connectionType\",\"type\":\"bytes32\"}],\"name\":\"connectionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityRequested\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"entityResolved\",\"type\":\"address\"}],\"name\":\"entityResolved\",\"type\":\"event\"}]","ContractName":"Connections","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://95b5964310a4a8cc53a2672d8f9c39508a6d2b9c274991668b14557fd57e1293"}]}