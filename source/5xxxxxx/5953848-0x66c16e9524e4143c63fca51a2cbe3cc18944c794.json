{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract Transfer {\r\n\r\n    address constant public ETH = 0x0;\r\n\r\n    /**\r\n    * @dev Transfer tokens from this contract to an account.\r\n    * @param token Address of token to transfer. 0x0 for ETH\r\n    * @param to Address to send tokens to.\r\n    * @param amount Amount of token to send.\r\n    */\r\n    function transfer(address token, address to, uint256 amount) internal returns (bool) {\r\n        if (token == ETH) {\r\n            to.transfer(amount);\r\n        } else {\r\n            require(ERC20(token).transfer(to, amount));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from an account to this contract.\r\n    * @param token Address of token to transfer. 0x0 for ETH\r\n    * @param from Address to send tokens from.\r\n    * @param to Address to send tokens to.\r\n    * @param amount Amount of token to send.\r\n    */\r\n    function transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) \r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(token == ETH && msg.value == amount || msg.value == 0);\r\n\r\n        if (token != ETH) {\r\n            // Remember to approve first\r\n            require(ERC20(token).transferFrom(from, to, amount));\r\n        }\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n}\r\n\r\n\r\ncontract Withdrawable is Ownable {\r\n    function () public payable {}\r\n\r\n    // Allow the owner to withdraw Ether\r\n    function withdraw() public onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n    \r\n    // Allow the owner to withdraw tokens\r\n    function withdrawToken(address token) public onlyOwner returns (bool) {\r\n        IERC20 foreignToken = IERC20(token);\r\n        uint256 amount = foreignToken.balanceOf(address(this));\r\n        return foreignToken.transfer(owner, amount);\r\n    }\r\n}\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract ExternalCall {\r\n    // Source: https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol\r\n    // call has been separated into its own function in order to take advantage\r\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\r\n        bool result;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\r\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2018 Contra Labs Inc.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n// @title TradeExecutor: Atomically execute two trades using decentralized exchange wrapper contracts.\r\n// @author Rich McAteer <rich@marble.org>, Max Wolff <max@marble.org>\r\ncontract TradeExecutor is Transfer, Withdrawable, ExternalCall {\r\n\r\n    // Allow exchange wrappers to send Ether\r\n    function () public payable {}\r\n\r\n    /**\r\n     * @dev Execute multiple trades in a single transaction.\r\n     * @param wrappers Addresses of exchange wrappers.\r\n     * @param token Address of ERC20 token to receive in first trade.\r\n     * @param trade1 Calldata of Ether => ERC20 trade.\r\n     * @param trade2 Calldata of ERC20 => Ether trade.\r\n    */\r\n    function trade(\r\n        address[2] wrappers,\r\n        address token,\r\n        bytes trade1,\r\n        bytes trade2\r\n    )\r\n        external\r\n        payable\r\n    {\r\n        // Execute the first trade to get tokens\r\n        require(execute(wrappers[0], msg.value, trade1));\r\n\r\n        uint256 tokenBalance = IERC20(token).balanceOf(this);\r\n\r\n        // Transfer tokens to the next exchange wrapper\r\n        transfer(token, wrappers[1], tokenBalance);\r\n\r\n        // Execute the second trade to get Ether\r\n        require(execute(wrappers[1], 0, trade2));\r\n        \r\n        // Send the arbitrageur Ether\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    function tradeForTokens(\r\n        address[2] wrappers,\r\n        address token,\r\n        bytes trade1,\r\n        bytes trade2\r\n    )\r\n        external\r\n    {\r\n        // Transfer tokens to the first exchange wrapper\r\n        uint256 tokenBalance = IERC20(token).balanceOf(this);\r\n        transfer(token, wrappers[0], tokenBalance);\r\n\r\n        // Execute the first trade to get Ether\r\n        require(execute(wrappers[0], 0, trade1));\r\n\r\n        uint256 balance = address(this).balance;\r\n\r\n        // Execute the second trade to get tokens\r\n        require(execute(wrappers[1], balance, trade2));\r\n\r\n        tokenBalance = IERC20(token).balanceOf(this);\r\n        require(IERC20(token).transfer(msg.sender, tokenBalance));\r\n    }\r\n\r\n    function execute(address wrapper, uint256 value, bytes data) private returns (bool) {\r\n        return external_call(wrapper, value, data.length, data);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wrappers\",\"type\":\"address[2]\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"trade1\",\"type\":\"bytes\"},{\"name\":\"trade2\",\"type\":\"bytes\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wrappers\",\"type\":\"address[2]\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"trade1\",\"type\":\"bytes\"},{\"name\":\"trade2\",\"type\":\"bytes\"}],\"name\":\"tradeForTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TradeExecutor","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"5000000","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c76ea740b2cf51c2557aa79355aa78dd038ce82261ea48565b3cd46fae5531d9"}]}