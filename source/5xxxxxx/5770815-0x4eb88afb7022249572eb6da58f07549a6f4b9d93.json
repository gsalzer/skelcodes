{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract SimpleMultiSig {\r\n\r\n  uint public nonce;                 // (only) mutable state\r\n  uint public threshold;             // immutable state\r\n  mapping (address => bool) isOwner; // immutable state\r\n  address[] public ownersArr;        // immutable state\r\n\r\n  function SimpleMultiSig(uint threshold_, address[] owners_) public {\r\n    require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ != 0);\r\n\r\n    address lastAdd = address(0); \r\n    for (uint i = 0; i < owners_.length; i++) {\r\n      require(owners_[i] > lastAdd);\r\n      isOwner[owners_[i]] = true;\r\n      lastAdd = owners_[i];\r\n    }\r\n    ownersArr = owners_;\r\n    threshold = threshold_;\r\n  }\r\n\r\n  // Note that address recovered from signatures must be strictly increasing\r\n  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {\r\n    require(sigR.length == threshold);\r\n    require(sigR.length == sigS.length && sigR.length == sigV.length);\r\n\r\n    // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191\r\n    bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce);\r\n\r\n    address lastAdd = address(0); // cannot have address(0) as an owner\r\n    for (uint i = 0; i < threshold; i++) {\r\n      address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);\r\n      require(recovered > lastAdd && isOwner[recovered]);\r\n      lastAdd = recovered;\r\n    }\r\n\r\n    // If we make it here all signatures are accounted for\r\n    nonce = nonce + 1;\r\n    require(executeCall(destination, value, data));\r\n  }\r\n\r\n  // The address.call() syntax is no longer recommended, see:\r\n  // https://github.com/ethereum/solidity/issues/2884\r\n  function executeCall(address to, uint256 value, bytes data) internal returns (bool success) {\r\n    assembly {\r\n      success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n    }\r\n  }\r\n\r\n  function () payable public {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownersArr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sigV\",\"type\":\"uint8[]\"},{\"name\":\"sigR\",\"type\":\"bytes32[]\"},{\"name\":\"sigS\",\"type\":\"bytes32[]\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"threshold_\",\"type\":\"uint256\"},{\"name\":\"owners_\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"SimpleMultiSig","CompilerVersion":"v0.4.25-nightly.2018.6.8+commit.81c5a6e4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000100000000000000000000000092affcfa3051d66176fa09e7c1f11fa0946e6bbe","Library":"","SwarmSource":"bzzr://e0d364bdc473c55722d70c512b75273a5484247c482554e6cc364a45c46a7195"}]}