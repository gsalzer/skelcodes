{"status":"1","message":"OK","result":[{"SourceCode":"//In dedication to my wife and family\r\npragma solidity ^0.4.23;\r\ncontract _0xBabylon{\r\n\t// scaleFactor is used to convert Ether into tokens and vice-versa: they're of different\r\n\t// orders of magnitude, hence the need to bridge between the two.\r\n\tuint256 constant scaleFactor = 0x10000000000000000;// 2^64\r\n\r\n\tint constant crr_n = 3;//CRR numerator\r\n\tint constant crr_d = 5;//CRR denominator\r\n\r\n\tint constant price_coeff = 0x42ea9ce452cde449f;\r\n\r\n\t// Array between each address and their number of tokens.\r\n\tmapping(address => uint256) public holdings;\r\n\t//cut down by a percentage when you sell out.\r\n\tmapping(address => uint256) public avgFactor_ethSpent;\r\n\r\n\tmapping(address => uint256) public color_R;\r\n\tmapping(address => uint256) public color_G;\r\n\tmapping(address => uint256) public color_B;\r\n\r\n\t// Array between each address and how much Ether has been paid out to it.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tmapping(address => address) public reff;\r\n\tmapping(address => uint256) public tricklingPass;\r\n\tmapping(address => uint256) public pocket;\r\n\tmapping(address => int256) public payouts;\r\n\r\n\t// Variable tracking how many tokens are in existence overall.\r\n\tuint256 public totalBondSupply;\r\n\r\n\t// Aggregate sum of all payouts.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tint256 totalPayouts;\r\n\tuint256 public trickleSum;\r\n\tuint256 public stakingRequirement = 1e18;\r\n\t\r\n\taddress public lastGateway;\r\n\tuint256 constant trickTax = 3; //divides flux'd fee and for every pass up\r\n\r\n\t//flux fee ratio and contract score keepers\r\n\tuint256 public withdrawSum;\r\n\tuint256 public investSum;\r\n\r\n\t// Variable tracking how much Ether each token is currently worth.\r\n\t// Note that this is scaled by the scaleFactor variable.\r\n\tuint256 earningsPerBond;\r\n\r\n\tevent onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed gateway\r\n    );\r\n\tevent onBoughtFor(\r\n        address indexed buyerAddress,\r\n        address indexed forWho,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed gateway\r\n    );\r\n\tevent onReinvestFor(\r\n        address indexed buyerAddress,\r\n        address indexed forWho,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed gateway\r\n    );\r\n    \r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 totalTokensAtTheTime,//maybe it'd be cool to see what % people are selling from their total bank\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned,\r\n        uint256 resolved,\r\n        address indexed gateway\r\n    );\r\n    \r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted,\r\n        address indexed gateway\r\n    );\r\n    \r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    event onCashDividends(\r\n        address indexed ownerAddress,\r\n        address indexed receiverAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    event onColor(\r\n        address indexed customerAddress,\r\n        uint256 oldR,\r\n        uint256 oldG,\r\n        uint256 oldB,\r\n        uint256 newR,\r\n        uint256 newG,\r\n        uint256 newB\r\n    );\r\n\r\n    event onTrickle(\r\n        address indexed fromWho,\r\n        address indexed finalReff,\r\n        uint256 reward,\r\n        uint256 passUp\r\n    );\r\n\r\n\t// The following functions are used by the front-end for display purposes.\r\n\r\n\r\n\t// Returns the number of tokens currently held by _owner.\r\n\tfunction holdingsOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn holdings[_owner];\r\n\t}\r\n\r\n\t// Withdraws all dividends held by the caller sending the transaction, updates\r\n\t// the requisite global variables, and transfers Ether back to the caller.\r\n\tfunction withdraw(address to) public {\r\n\t\ttrickleUp(msg.sender);\r\n\t\t// Retrieve the dividends associated with the address the request came from.\r\n\t\tuint256 balance = dividends(msg.sender);\r\n\t\t//uint256 pocketBalance = tricklePocket[msg.sender];\r\n\t\t//tricklePocket[msg.sender] = 0;\r\n\t\t// Update the payouts array, incrementing the request address by `balance`.\r\n\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\n\t\t\r\n\t\t// Increase the total amount that's been paid out to maintain invariance.\r\n\t\ttotalPayouts += (int256) (balance * scaleFactor);\r\n\r\n\t\tuint256 pocketETH = pocket[msg.sender];\r\n\t\tpocket[msg.sender] = 0;\r\n\t\ttrickleSum -= pocketETH;\r\n\r\n\t\tbalance += pocketETH;\r\n\t\t// Send the dividends to the address that requested the withdraw.\r\n\t\twithdrawSum += balance;\r\n\t\tto.transfer(balance);\r\n\t\temit onCashDividends(msg.sender,to,balance);\r\n\t}\r\n\tfunction fullCycleSellBonds(uint256 balance) internal {\r\n\t\t// Send the cashed out stake to the address that requested the withdraw.\r\n\t\twithdrawSum += balance;\r\n\t\tmsg.sender.transfer(balance);\r\n\t\temit onWithdraw(msg.sender, balance);\r\n\t}\r\n\r\n\r\n\t// Sells your tokens for Ether. This Ether is assigned to the callers entry\r\n\t// in the tokenBalance array, and therefore is shown as a dividend. A second\r\n\t// call to withdraw() must be made to invoke the transfer of Ether back to your address.\r\n\tfunction sellBonds(uint256 _amount) public {\r\n\t\tuint256 bondBalance = holdings[msg.sender];\r\n\t\tif(_amount <= bondBalance && _amount > 0){\r\n\t\t\tsell(_amount);\r\n\t\t}else{\r\n\t\t\tsell(bondBalance);\r\n\t\t}\r\n\t}\r\n\r\n\t// The slam-the-button escape hatch. Sells the callers tokens for Ether, then immediately\r\n\t// invokes the withdraw() function, sending the resulting Ether to the callers address.\r\n    function getMeOutOfHere() public {\r\n\t\tsellBonds( holdings[msg.sender] );\r\n        withdraw(msg.sender);\r\n\t}\r\n\r\n\tfunction reffUp(address _reff) internal{\r\n\t\taddress sender = msg.sender;\r\n\t\tif (_reff == 0x0000000000000000000000000000000000000000 || _reff == msg.sender){\r\n\t\t\t_reff = reff[sender];\r\n\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\tif(  holdings[_reff] < stakingRequirement ){//if req not met\r\n\t\t\tif(lastGateway == 0x0000000000000000000000000000000000000000){\r\n\t\t\t\tlastGateway = sender;//first buyer ever\r\n\t\t\t\t_reff = sender;//first buyer is their own gateway/masternode\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\t_reff = lastGateway;//the lucky last player gets to be the gate way.\r\n\t\t}\r\n\t\treff[sender] = _reff;\r\n\t}\r\n\tfunction rgbLimit(uint256 _rgb)internal pure returns(uint256){\r\n\t\tif(_rgb > 255)\r\n\t\t\treturn 255;\r\n\t\telse\r\n\t\t\treturn _rgb;\r\n\t}\r\n\t//BONUS\r\n\t//when you don't pick a color, the contract will need a default. which will be your current color\r\n\tfunction edgePigment(uint8 C)internal view returns (uint256 x)\r\n\t{\t\r\n\t\tuint256 holding = holdings[msg.sender];\r\n\t\tif(holding==0)\r\n\t\t\treturn 0;\r\n\t\telse{\r\n\t\t\tif(C==0){\r\n\t\t\t\treturn 255 * color_R[msg.sender]/holding;\r\n\t\t\t}else if(C==1){\r\n\t\t\t\treturn 255 * color_G[msg.sender]/holding;\r\n\t\t\t}else if(C==2){\r\n\t\t\t\treturn 255 * color_B[msg.sender]/holding;\r\n\t\t\t}\r\n\t\t} \r\n\t}\r\n\tfunction fund(address reffo, address forWho) payable public {\r\n\t\tfund_color( reffo, forWho, edgePigment(0),edgePigment(1),edgePigment(2) );\r\n\t}\r\n\tfunction fund_color( address _reff, address forWho,uint256 cR,uint256 cG,uint256 cB) payable public {\r\n\t\t// Don't allow for funding if the amount of Ether sent is less than 1 szabo.\r\n\t\treffUp(_reff);\r\n\t\tif (msg.value > 0.000001 ether){\r\n\t\t\tinvestSum += msg.value;\r\n\t\t\tcR=rgbLimit(cR);\r\n\t\t\tcG=rgbLimit(cG);\r\n\t\t\tcB=rgbLimit(cB);\r\n\t\t    buy( forWho ,cR,cG,cB);\r\n\t\t\tlastGateway = msg.sender;\r\n\t\t} else {\r\n\t\t\trevert();\r\n\t\t}\r\n    }\r\n\r\n    function reinvest_color(address forWho,uint256 cR,uint256 cG,uint256 cB) public {\r\n    \tcR=rgbLimit(cR);\r\n\t\tcG=rgbLimit(cG);\r\n\t\tcB=rgbLimit(cB);\r\n\t\tprocessReinvest( forWho, cR,cG,cB);\r\n\t}\r\n    function reinvest(address forWho) public {\r\n\t\tprocessReinvest( forWho, edgePigment(0),edgePigment(1),edgePigment(2) );\r\n\t}\r\n\r\n\t// Function that returns the (dynamic) price of a single token.\r\n\tfunction price(bool buyOrSell) public constant returns (uint) {\r\n        if(buyOrSell){\r\n        \treturn getTokensForEther(1 finney);\r\n        }else{\r\n        \tuint256 eth = getEtherForTokens(1 finney);\r\n        \tuint256 fee = fluxFeed(eth, false, false);\r\n\t        return eth - fee;\r\n        }\r\n    }\r\n\r\n\tfunction fluxFeed(uint256 _eth, bool slim_reinvest,bool newETH) public constant returns (uint256 amount) {\r\n\t\tuint256 finalInvestSum;\r\n\t\tif(newETH)\r\n\t\t\tfinalInvestSum = investSum-_eth;//bigger buy bonus\r\n\t\telse\r\n\t\t\tfinalInvestSum = investSum;\r\n\r\n\t\tuint256 contract_ETH = finalInvestSum - withdrawSum;\r\n\t\tif(slim_reinvest){//trickleSum can never be 0, trust me\r\n\t\t\treturn  _eth/(contract_ETH/trickleSum) *  contract_ETH /investSum;\r\n\t\t}else{\r\n\t\t\treturn  _eth *  contract_ETH / investSum;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\tFee\r\n\t\t\t100eth IN & 100eth OUT = 0% tax fee (returning 1)\r\n\t\t\t100eth IN & 50eth OUT = 50% tax fee (returning 2)\r\n\t\t\t100eth IN & 33eth OUT = 66% tax fee (returning 3)\r\n\t\t\t100eth IN & 25eth OUT = 75% tax fee (returning 4)\r\n\t\t\t100eth IN & 10eth OUT = 90% tax fee (returning 10)\r\n\t\t*/\r\n\t}\r\n\r\n\t// Calculate the current dividends associated with the caller address. This is the net result\r\n\t// of multiplying the number of tokens held by their current value in Ether and subtracting the\r\n\t// Ether that has already been paid out.\r\n\tfunction dividends(address _owner) public constant returns (uint256 amount) {\r\n\t\treturn (uint256) ((int256)( earningsPerBond * holdings[_owner] ) - payouts[_owner] ) / scaleFactor;\r\n\t}\r\n\r\n\t// Internal balance function, used to calculate the dynamic reserve value.\r\n\tfunction contractBalance() internal constant returns (uint256 amount){\r\n\t\t// msg.value is the amount of Ether sent by the transaction.\r\n\t\treturn investSum - withdrawSum - msg.value - trickleSum;\r\n\t}\r\n\t\t\t\tfunction trickleUp(address fromWho) internal{//you can trickle up other people by giving them some.\r\n\t\t\t\t\tuint256 tricks = tricklingPass[ fromWho ];//this is the amount moving in the trickle flo\r\n\t\t\t\t\tif(tricks > 0){\r\n\t\t\t\t\t\ttricklingPass[ fromWho ] = 0;//we've already captured the amount so set your tricklingPass flo to 0\r\n\t\t\t\t\t\tuint256 passUp = tricks * (investSum - withdrawSum)/investSum;//to get the amount we're gonna pass up. divide by trickTax\r\n\t\t\t\t\t\tuint256 reward = tricks-passUp;//and our remaining reward for ourselves is the amount we just slice off subtracted from the flo\r\n\t\t\t\t\t\taddress finalReff;//we're not exactly sure who we're gonna pass this up to yet\r\n\t\t\t\t\t\taddress reffo =  reff[ fromWho ];//this is who it should go up to. if everything is legit\r\n\t\t\t\t\t\tif( holdings[reffo] >= stakingRequirement){\r\n\t\t\t\t\t\t\tfinalReff = reffo;//if that address is holding enough to stake, it's a legit node to flo up to.\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tfinalReff = lastGateway;//if not, then we use the last buyer\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttricklingPass[ finalReff ] += passUp;//so now we add that flo you've passed up to the tricklingPass of the final Reff\r\n\t\t\t\t\t\tpocket[ finalReff ] += reward;// Reward\r\n\t\t\t\t\t\temit onTrickle(fromWho, finalReff, reward, passUp);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfunction buy(address forWho,uint256 cR,uint256 cG,uint256 cB) internal {\r\n\t\t\t\t\t\t\t\t\t// Any transaction of less than 1 szabo is likely to be worth less than the gas used to send it.\r\n\t\t\t\t\t\t\t\t\tif (msg.value < 0.000001 ether || msg.value > 1000000 ether)\r\n\t\t\t\t\t\t\t\t\t\trevert();\t\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t//Fee to pay existing holders, and the referral commission\r\n\t\t\t\t\t\t\t\t\tuint256 fee = 0; \r\n\t\t\t\t\t\t\t\t\tuint256 trickle = 0; \r\n\t\t\t\t\t\t\t\t\tif(holdings[forWho] != totalBondSupply){\r\n\t\t\t\t\t\t\t\t\t\tfee = fluxFeed(msg.value,false,true);\r\n\t\t\t\t\t\t\t\t\t\ttrickle = fee/trickTax;\r\n\t\t\t\t\t\t\t\t\t\tfee = fee - trickle;\r\n\t\t\t\t\t\t\t\t\t\ttricklingPass[forWho] += trickle;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tuint256 numEther = msg.value - (fee+trickle);// The amount of Ether used to purchase new tokens for the caller.\r\n\t\t\t\t\t\t\t\t\tuint256 numTokens = getTokensForEther(numEther);// The number of tokens which can be purchased for numEther.\r\n\r\n\t\t\t\t\t\t\t\t\tbuyCalcAndPayout( forWho, fee, numTokens, numEther, reserve() );\r\n\r\n\t\t\t\t\t\t\t\t\taddPigment(forWho, numTokens,cR,cG,cB);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif(forWho != msg.sender){//make sure you're not yourself\r\n\t\t\t\t\t\t\t\t\t\t//if forWho doesn't have a reff or if that masternode is weak, then reset it\r\n\t\t\t\t\t\t\t\t\t\tif(reff[forWho] == 0x0000000000000000000000000000000000000000 || (holdings[reff[forWho]] < stakingRequirement) )\r\n\t\t\t\t\t\t\t\t\t\t\treff[forWho] = msg.sender;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\temit onBoughtFor(msg.sender, forWho, numEther, numTokens, reff[forWho] );\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\temit onTokenPurchase(forWho, numEther ,numTokens , reff[forWho] );\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\ttrickleSum += trickle;//add to trickle's Sum after reserve calculations\r\n\t\t\t\t\t\t\t\t\ttrickleUp(forWho);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfunction buyCalcAndPayout(address forWho,uint256 fee,uint256 numTokens,uint256 numEther,uint256 res)internal{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The buyer fee, scaled by the scaleFactor variable.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint256 buyerFee = fee * scaleFactor;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (totalBondSupply > 0){// because ...\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Compute the bonus co-efficient for all existing holders and the buyer.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The buyer receives part of the distribution for each token bought in the\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// same way they would have if they bought each token individually.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint256 bonusCoEff = (scaleFactor - (res + numEther) * numTokens * scaleFactor / ( totalBondSupply  + numTokens) / numEther)\r\n\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t*(uint)(crr_d) / (uint)(crr_d-crr_n);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The total reward to be distributed amongst the masses is the fee (in Ether)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// multiplied by the bonus co-efficient.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuint256 holderReward = fee * bonusCoEff;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuyerFee -= holderReward;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The Ether value per token is increased proportionally.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tearningsPerBond +=  holderReward / totalBondSupply;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//resolve reward tracking stuff\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tavgFactor_ethSpent[forWho] += numEther;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Add the numTokens which were just created to the total supply. We're a crypto central bank!\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttotalBondSupply += numTokens;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Assign the tokens to the balance of the buyer.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tholdings[forWho] += numTokens;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Update the payout array so that the buyer cannot claim dividends on previous purchases.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Also include the fee paid for entering the scheme.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// First we compute how much was just paid out to the buyer...\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tint256 payoutDiff = (int256) ((earningsPerBond * numTokens) - buyerFee);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Then we update the payouts array for the buyer with this amount...\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpayouts[forWho] += payoutDiff;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// And then we finally add it to the variable tracking the total amount spent to maintain invariance.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttotalPayouts += payoutDiff;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Sell function that takes tokens and converts them into Ether. Also comes with a 10% fee\r\n\t\t\t\t\t\t\t\t// to discouraging dumping, and means that if someone near the top sells, the fee distributed\r\n\t\t\t\t\t\t\t\t// will be *significant*.\r\n\t\t\t\t\t\t\t\tfunction TOKEN_scaleDown(uint256 value,uint256 reduce) internal view returns(uint256 x){\r\n\t\t\t\t\t\t\t\t\tuint256 holdingsOfSender = holdings[msg.sender];\r\n\t\t\t\t\t\t\t\t\treturn value * ( holdingsOfSender - reduce) / holdingsOfSender;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tfunction sell(uint256 amount) internal {\r\n\t\t\t\t\t\t\t\t    uint256 numEthersBeforeFee = getEtherForTokens(amount);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// x% of the resulting Ether is used to pay remaining holders.\r\n\t\t\t\t\t\t\t\t\tuint256 fee = 0;\r\n\t\t\t\t\t\t\t\t\tuint256 trickle = 0;\r\n\t\t\t\t\t\t\t\t\tif(totalBondSupply != holdings[msg.sender]){\r\n\t\t\t\t\t\t\t\t\t\tfee = fluxFeed(numEthersBeforeFee, false,false);\r\n\t\t\t\t\t\t\t        \ttrickle = fee/ trickTax;\r\n\t\t\t\t\t\t\t\t\t\tfee -= trickle;\r\n\t\t\t\t\t\t\t\t\t\ttricklingPass[msg.sender] +=trickle;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// Net Ether for the seller after the fee has been subtracted.\r\n\t\t\t\t\t\t\t        uint256 numEthers = numEthersBeforeFee - (fee+trickle);\r\n\r\n\t\t\t\t\t\t\t\t\t//How much you bought it for divided by how much you're getting back.\r\n\t\t\t\t\t\t\t\t\t//This means that if you get dumped on, you can get more resolve tokens if you sell out.\r\n\t\t\t\t\t\t\t\t\tuint256 resolved = mint(\r\n\t\t\t\t\t\t\t\t\t\tcalcResolve(msg.sender,amount,numEthersBeforeFee),\r\n\t\t\t\t\t\t\t\t\t\tmsg.sender\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t\t// *Remove* the numTokens which were just sold from the total supply.\r\n\t\t\t\t\t\t\t\t\tavgFactor_ethSpent[msg.sender] = TOKEN_scaleDown(avgFactor_ethSpent[msg.sender] , amount);\r\n\r\n\t\t\t\t\t\t\t\t\tcolor_R[msg.sender] = TOKEN_scaleDown(color_R[msg.sender] , amount);\r\n\t\t\t\t\t\t\t\t\tcolor_G[msg.sender] = TOKEN_scaleDown(color_G[msg.sender] , amount);\r\n\t\t\t\t\t\t\t\t\tcolor_B[msg.sender] = TOKEN_scaleDown(color_B[msg.sender] , amount);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\ttotalBondSupply -= amount;\r\n\t\t\t\t\t\t\t\t\t// Remove the tokens from the balance of the buyer.\r\n\t\t\t\t\t\t\t\t\tholdings[msg.sender] -= amount;\r\n\r\n\t\t\t\t\t\t\t\t\tint256 payoutDiff = (int256) (earningsPerBond * amount);//we don't add in numETH because it is immedietly paid out.\r\n\t\t\r\n\t\t\t\t\t\t\t        // We reduce the amount paid out to the seller (this effectively resets their payouts value to zero,\r\n\t\t\t\t\t\t\t\t\t// since they're selling all of their tokens). This makes sure the seller isn't disadvantaged if\r\n\t\t\t\t\t\t\t\t\t// they decide to buy back in.\r\n\t\t\t\t\t\t\t\t\tpayouts[msg.sender] -= payoutDiff;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// Decrease the total amount that's been paid out to maintain invariance.\r\n\t\t\t\t\t\t\t        totalPayouts -= payoutDiff;\r\n\t\t\t\t\t\t\t        \r\n\r\n\t\t\t\t\t\t\t\t\t// Check that we have tokens in existence (this is a bit of an irrelevant check since we're\r\n\t\t\t\t\t\t\t\t\t// selling tokens, but it guards against division by zero).\r\n\t\t\t\t\t\t\t\t\tif (totalBondSupply > 0) {\r\n\t\t\t\t\t\t\t\t\t\t// Scale the Ether taken as the selling fee by the scaleFactor variable.\r\n\t\t\t\t\t\t\t\t\t\tuint256 etherFee = fee * scaleFactor;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// Fee is distributed to all remaining token holders.\r\n\t\t\t\t\t\t\t\t\t\t// rewardPerShare is the amount gained per token thanks to this sell.\r\n\t\t\t\t\t\t\t\t\t\tuint256 rewardPerShare = etherFee / totalBondSupply;\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t// The Ether value per token is increased proportionally.\r\n\t\t\t\t\t\t\t\t\t\tearningsPerBond +=  rewardPerShare;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tfullCycleSellBonds(numEthers);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\ttrickleSum += trickle;\r\n\t\t\t\t\t\t\t\t\ttrickleUp(msg.sender);\r\n\t\t\t\t\t\t\t\t\temit onTokenSell(msg.sender,holdings[msg.sender]+amount,amount,numEthers,resolved,reff[msg.sender]);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t// Converts the Ether accrued as dividends back into Staking tokens without having to\r\n\t\t\t\t// withdraw it first. Saves on gas and potential price spike loss.\r\n\t\t\t\tfunction processReinvest(address forWho,uint256 cR,uint256 cG,uint256 cB) internal{\r\n\t\t\t\t\t// Retrieve the dividends associated with the address the request came from.\r\n\t\t\t\t\tuint256 balance = dividends(msg.sender);\r\n\r\n\t\t\t\t\t// Update the payouts array, incrementing the request address by `balance`.\r\n\t\t\t\t\t// Since this is essentially a shortcut to withdrawing and reinvesting, this step still holds.\r\n\t\t\t\t\tpayouts[msg.sender] += (int256) (balance * scaleFactor);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Increase the total amount that's been paid out to maintain invariance.\r\n\t\t\t\t\ttotalPayouts += (int256) (balance * scaleFactor);\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t// Assign balance to a new variable.\r\n\t\t\t\t\tuint256 pocketETH = pocket[msg.sender];\r\n\t\t\t\t\tuint value_ = (uint) (balance + pocketETH);\r\n\t\t\t\t\tpocket[msg.sender] = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If your dividends are worth less than 1 szabo, or more than a million Ether\r\n\t\t\t\t\t// (in which case, why are you even here), abort.\r\n\t\t\t\t\tif (value_ < 0.000001 ether || value_ > 1000000 ether)\r\n\t\t\t\t\t\trevert();\r\n\r\n\t\t\t\t\tuint256 fee = 0; \r\n\t\t\t\t\tuint256 trickle = 0;\r\n\t\t\t\t\tif(holdings[forWho] != totalBondSupply){\r\n\t\t\t\t\t\tfee = fluxFeed(value_, true,false );// reinvestment fees are lower than regular ones.\r\n\t\t\t\t\t\ttrickle = fee/ trickTax;\r\n\t\t\t\t\t\tfee = fee - trickle;\r\n\t\t\t\t\t\ttricklingPass[forWho] += trickle;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// A temporary reserve variable used for calculating the reward the holder gets for buying tokens.\r\n\t\t\t\t\t// (Yes, the buyer receives a part of the distribution as well!)\r\n\t\t\t\t\tuint256 res = reserve() - balance;\r\n\r\n\t\t\t\t\t// The amount of Ether used to purchase new tokens for the caller.\r\n\t\t\t\t\tuint256 numEther = value_ - (fee+trickle);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// The number of tokens which can be purchased for numEther.\r\n\t\t\t\t\tuint256 numTokens = calculateDividendTokens(numEther, balance);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbuyCalcAndPayout( forWho, fee, numTokens, numEther, res );\r\n\r\n\t\t\t\t\taddPigment(forWho, numTokens,cR,cG,cB);\r\n\t\t\t\t\t\r\n\r\n\t\t\t\t\tif(forWho != msg.sender){//make sure you're not yourself\r\n\t\t\t\t\t\t//if forWho doesn't have a reff, then reset it\r\n\t\t\t\t\t\taddress reffOfWho = reff[forWho];\r\n\t\t\t\t\t\tif(reffOfWho == 0x0000000000000000000000000000000000000000 || (holdings[reffOfWho] < stakingRequirement) )\r\n\t\t\t\t\t\t\treff[forWho] = msg.sender;\r\n\r\n\t\t\t\t\t\temit onReinvestFor(msg.sender,forWho,numEther,numTokens,reff[forWho]);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\temit onReinvestment(forWho,numEther,numTokens,reff[forWho]);\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttrickleUp(forWho);\r\n\t\t\t\t\ttrickleSum += trickle - pocketETH;\r\n\t\t\t\t}\r\n\t\r\n\tfunction addPigment(address forWho, uint256 tokens,uint256 r,uint256 g,uint256 b) internal{\r\n\t\tcolor_R[forWho] += tokens * r / 255;\r\n\t\tcolor_G[forWho] += tokens * g / 255;\r\n\t\tcolor_B[forWho] += tokens * b / 255;\r\n\t\temit onColor(forWho,r,g,b,color_R[forWho] ,color_G[forWho] ,color_B[forWho] );\r\n\t}\r\n\t// Dynamic value of Ether in reserve, according to the CRR requirement.\r\n\tfunction reserve() internal constant returns (uint256 amount){\r\n\t\treturn contractBalance()-((uint256) ((int256) (earningsPerBond * totalBondSupply) - totalPayouts ) / scaleFactor);\r\n\t}\r\n\r\n\t// Calculates the number of tokens that can be bought for a given amount of Ether, according to the\r\n\t// dynamic reserve and totalSupply values (derived from the buy and sell prices).\r\n\tfunction getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {\r\n\t\treturn fixedExp(fixedLog(reserve() + ethervalue)*crr_n/crr_d + price_coeff) - totalBondSupply ;\r\n\t}\r\n\r\n\t// Semantically similar to getTokensForEther, but subtracts the callers balance from the amount of Ether returned for conversion.\r\n\tfunction calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {\r\n\t\treturn fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff) -  totalBondSupply;\r\n\t}\r\n\r\n\t// Converts a number tokens into an Ether value.\r\n\tfunction getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) {\r\n\t\t// How much reserve Ether do we have left in the contract?\r\n\t\tuint256 reserveAmount = reserve();\r\n\r\n\t\t// If you're the Highlander (or bagholder), you get The Prize. Everything left in the vault.\r\n\t\tif (tokens == totalBondSupply )\r\n\t\t\treturn reserveAmount;\r\n\r\n\t\t// If there would be excess Ether left after the transaction this is called within, return the Ether\r\n\t\t// corresponding to the equation in Dr Jochen Hoenicke's original Ponzi paper, which can be found\r\n\t\t// at https://test.jochen-hoenicke.de/eth/ponzitoken/ in the third equation, with the CRR numerator \r\n\t\t// and denominator altered to 1 and 2 respectively.\r\n\t\treturn reserveAmount - fixedExp((fixedLog(totalBondSupply  - tokens) - price_coeff) * crr_d/crr_n);\r\n\t}\r\n\r\n\tfunction () payable public {\r\n\t\tif (msg.value > 0) {\r\n\t\t\tfund(lastGateway,msg.sender);\r\n\t\t} else {\r\n\t\t\twithdraw(msg.sender);\r\n\t\t}\r\n\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\taddress public resolver = this;\r\n\t\t\t\t\t\t\t\t\t    uint256 public totalSupply;\r\n\t\t\t\t\t\t\t\t\t    uint256 constant private MAX_UINT256 = 2**256 - 1;\r\n\t\t\t\t\t\t\t\t\t    mapping (address => uint256) public balances;\r\n\t\t\t\t\t\t\t\t\t    mapping (address => mapping (address => uint256)) public allowed;\r\n\t\t\t\t\t\t\t\t\t    \r\n\t\t\t\t\t\t\t\t\t    string public name = \"0xBabylon\";\r\n\t\t\t\t\t\t\t\t\t    uint8 public decimals = 18;\r\n\t\t\t\t\t\t\t\t\t    string public symbol = \"PoWHr\";\r\n\t\t\t\t\t\t\t\t\t    \r\n\t\t\t\t\t\t\t\t\t    event Transfer(address indexed _from, address indexed _to, uint256 _value); \r\n\t\t\t\t\t\t\t\t\t    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\t\t\t\t\t\t\t\t\t    event Resolved(address indexed _owner, uint256 amount);\r\n\r\n\t\t\t\t\t\t\t\t\t    function mint(uint256 amount,address _account) internal returns (uint minted){\r\n\t\t\t\t\t\t\t\t\t    \ttotalSupply += amount;\r\n\t\t\t\t\t\t\t\t\t    \tbalances[_account] += amount;\r\n\t\t\t\t\t\t\t\t\t    \temit Resolved(_account,amount);\r\n\t\t\t\t\t\t\t\t\t    \treturn amount;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\t\t\t\t\t\t\t\t        return balances[_owner];\r\n\t\t\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t\t\t    \r\n\r\n\t\t\t\t\t\t\t\t\t\tfunction calcResolve(address _owner,uint256 amount,uint256 _eth) public constant returns (uint256 calculatedResolveTokens) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn amount*amount*avgFactor_ethSpent[_owner]/holdings[_owner]/_eth/1000000;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\t\t\t\t\t\t\t\t        require( balanceOf(msg.sender) >= _value);\r\n\t\t\t\t\t\t\t\t\t        balances[msg.sender] -= _value;\r\n\t\t\t\t\t\t\t\t\t        balances[_to] += _value;\r\n\t\t\t\t\t\t\t\t\t        emit Transfer(msg.sender, _to, _value);\r\n\t\t\t\t\t\t\t\t\t        return true;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\r\n\t\t\t\t\t\t\t\t\t        uint256 allowance = allowed[_from][msg.sender];\r\n\t\t\t\t\t\t\t\t\t        require(    balanceOf(_from)  >= _value && allowance >= _value );\r\n\t\t\t\t\t\t\t\t\t        balances[_to] += _value;\r\n\t\t\t\t\t\t\t\t\t        balances[_from] -= _value;\r\n\t\t\t\t\t\t\t\t\t        if (allowance < MAX_UINT256) {\r\n\t\t\t\t\t\t\t\t\t            allowed[_from][msg.sender] -= _value;\r\n\t\t\t\t\t\t\t\t\t        }\r\n\t\t\t\t\t\t\t\t\t        emit Transfer(_from, _to, _value);\r\n\t\t\t\t\t\t\t\t\t        return true;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\t\t\t\t\t\t\t\t        allowed[msg.sender][_spender] = _value;\r\n\t\t\t\t\t\t\t\t\t        emit Approval(msg.sender, _spender, _value);\r\n\t\t\t\t\t\t\t\t\t        return true;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t    function resolveSupply() public view returns (uint256 balance) {\r\n\t\t\t\t\t\t\t\t\t        return totalSupply;\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n\t\t\t\t\t\t\t\t\t    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n\t\t\t\t\t\t\t\t\t        return allowed[_owner][_spender];\r\n\t\t\t\t\t\t\t\t\t    }\r\n\r\n    // You don't care about these, but if you really do they're hex values for \r\n\t// co-efficients used to simulate approximations of the log and exp functions.\r\n\tint256  constant one        = 0x10000000000000000;\r\n\tuint256 constant sqrt2      = 0x16a09e667f3bcc908;\r\n\tuint256 constant sqrtdot5   = 0x0b504f333f9de6484;\r\n\tint256  constant ln2        = 0x0b17217f7d1cf79ac;\r\n\tint256  constant ln2_64dot5 = 0x2cb53f09f05cc627c8;\r\n\tint256  constant c1         = 0x1ffffffffff9dac9b;\r\n\tint256  constant c3         = 0x0aaaaaaac16877908;\r\n\tint256  constant c5         = 0x0666664e5e9fa0c99;\r\n\tint256  constant c7         = 0x049254026a7630acf;\r\n\tint256  constant c9         = 0x038bd75ed37753d68;\r\n\tint256  constant c11        = 0x03284a0c14610924f;\r\n\r\n\t// The polynomial R = c1*x + c3*x^3 + ... + c11 * x^11\r\n\t// approximates the function log(1+x)-log(1-x)\r\n\t// Hence R(s) = log((1+s)/(1-s)) = log(a)\r\n\tfunction fixedLog(uint256 a) internal pure returns (int256 log) {\r\n\t\tint32 scale = 0;\r\n\t\twhile (a > sqrt2) {\r\n\t\t\ta /= 2;\r\n\t\t\tscale++;\r\n\t\t}\r\n\t\twhile (a <= sqrtdot5) {\r\n\t\t\ta *= 2;\r\n\t\t\tscale--;\r\n\t\t}\r\n\t\tint256 s = (((int256)(a) - one) * one) / ((int256)(a) + one);\r\n\t\tint256 z = (s*s) / one;\r\n\t\treturn scale * ln2 +\r\n\t\t\t(s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11/one))\r\n\t\t\t\t/one))/one))/one))/one))/one);\r\n\t}\r\n\r\n\tint256 constant c2 =  0x02aaaaaaaaa015db0;\r\n\tint256 constant c4 = -0x000b60b60808399d1;\r\n\tint256 constant c6 =  0x0000455956bccdd06;\r\n\tint256 constant c8 = -0x000001b893ad04b3a;\r\n\r\n\t// The polynomial R = 2 + c2*x^2 + c4*x^4 + ...\r\n\t// approximates the function x*(exp(x)+1)/(exp(x)-1)\r\n\t// Hence exp(x) = (R(x)+x)/(R(x)-x)\r\n\tfunction fixedExp(int256 a) internal pure returns (uint256 exp) {\r\n\t\tint256 scale = (a + (ln2_64dot5)) / ln2 - 64;\r\n\t\ta -= scale*ln2;\r\n\t\tint256 z = (a*a) / one;\r\n\t\tint256 R = ((int256)(2) * one) +\r\n\t\t\t(z*(c2 + (z*(c4 + (z*(c6 + (z*c8/one))/one))/one))/one);\r\n\t\texp = (uint256) (((R + a) * one) / (R - a));\r\n\t\tif (scale >= 0)\r\n\t\t\texp <<= scale;\r\n\t\telse\r\n\t\t\texp >>= -scale;\r\n\t\treturn exp;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"holdingsOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"slim_reinvest\",\"type\":\"bool\"},{\"name\":\"newETH\",\"type\":\"bool\"}],\"name\":\"fluxFeed\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBondSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"avgFactor_ethSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcResolve\",\"outputs\":[{\"name\":\"calculatedResolveTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolveSupply\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"forWho\",\"type\":\"address\"},{\"name\":\"cR\",\"type\":\"uint256\"},{\"name\":\"cG\",\"type\":\"uint256\"},{\"name\":\"cB\",\"type\":\"uint256\"}],\"name\":\"reinvest_color\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trickleSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethervalue\",\"type\":\"uint256\"}],\"name\":\"getTokensForEther\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payouts\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"dividends\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buyOrSell\",\"type\":\"bool\"}],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"reff\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"color_B\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastGateway\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reffo\",\"type\":\"address\"},{\"name\":\"forWho\",\"type\":\"address\"}],\"name\":\"fund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMeOutOfHere\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"forWho\",\"type\":\"address\"}],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"getEtherForTokens\",\"outputs\":[{\"name\":\"ethervalue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethervalue\",\"type\":\"uint256\"},{\"name\":\"subvalue\",\"type\":\"uint256\"}],\"name\":\"calculateDividendTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tricklingPass\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"holdings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pocket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"color_R\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellBonds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reff\",\"type\":\"address\"},{\"name\":\"forWho\",\"type\":\"address\"},{\"name\":\"cR\",\"type\":\"uint256\"},{\"name\":\"cG\",\"type\":\"uint256\"},{\"name\":\"cB\",\"type\":\"uint256\"}],\"name\":\"fund_color\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"color_G\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gateway\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"forWho\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gateway\",\"type\":\"address\"}],\"name\":\"onBoughtFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"forWho\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gateway\",\"type\":\"address\"}],\"name\":\"onReinvestFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalTokensAtTheTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"resolved\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gateway\",\"type\":\"address\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"gateway\",\"type\":\"address\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ownerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiverAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onCashDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldR\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldG\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newR\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newG\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newB\",\"type\":\"uint256\"}],\"name\":\"onColor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromWho\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"finalReff\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"passUp\",\"type\":\"uint256\"}],\"name\":\"onTrickle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Resolved\",\"type\":\"event\"}]","ContractName":"_0xBabylon","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b6a350da4792f8542063b38d1bd37b25294d2fc0273cb1bd67fc2932edc446d9"}]}