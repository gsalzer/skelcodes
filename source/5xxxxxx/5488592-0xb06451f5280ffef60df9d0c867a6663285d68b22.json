{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// @author - vivekjibw@gmail.com\r\n// Website: http://CryptoStockMarket.co\r\n// Only CEO can change CEO and CFO address\r\n\r\ncontract CompanyAccessControl {\r\n    \r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n\r\n    bool public paused = false;\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) \r\n    onlyCEO \r\n    external {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCFO(address _newCFO) \r\n    onlyCEO \r\n    external {\r\n        require(_newCFO != address(0));\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() \r\n    onlyCLevel\r\n    external \r\n    whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() \r\n    onlyCLevel \r\n    whenPaused \r\n    external {\r\n        paused = false;\r\n    }\r\n}\r\n\r\n// Keeps a mapping of onwerAddress to the number of shares owned\r\ncontract BookKeeping {\r\n    \r\n    struct ShareHolders {\r\n        mapping(address => uint) ownerAddressToShares;\r\n        uint numberOfShareHolders;\r\n    }\r\n    \r\n    // _amount should be greator than 0\r\n    function _sharesBought(ShareHolders storage _shareHolders, address _owner, uint _amount) \r\n    internal {\r\n        // If user didn't have shares earlier, he is now a share holder!\r\n        if (_shareHolders.ownerAddressToShares[_owner] == 0) {\r\n            _shareHolders.numberOfShareHolders += 1;\r\n        }\r\n        _shareHolders.ownerAddressToShares[_owner] += _amount;\r\n        \r\n    }\r\n\r\n    // _amount should be greator or equal to what user already have, otherwise will result in underflow\r\n    function _sharesSold(ShareHolders storage _shareHolders, address _owner, uint _amount) \r\n    internal {\r\n        _shareHolders.ownerAddressToShares[_owner] -= _amount;\r\n        \r\n        // if user sold all his tokens, then there is one less share holder\r\n        if (_shareHolders.ownerAddressToShares[_owner] == 0) {\r\n            _shareHolders.numberOfShareHolders -= 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract CompanyConstants {\r\n    // Days after which trading volume competiton result will be annouced\r\n    uint constant TRADING_COMPETITION_PERIOD = 5 days;\r\n    \r\n    // Max Percentage of shares that can be released per cycle\r\n    uint constant MAX_PERCENTAGE_SHARE_RELEASE = 5;\r\n    \r\n    uint constant MAX_CLAIM_SHARES_PERCENTAGE = 5;\r\n    \r\n    // Release cycle! Every company needs to wait for \"at least\" 10 days\r\n    // before releasing next set of shares!\r\n    uint constant MIN_COOLDOWN_TIME = 10; // in days\r\n    uint constant MAX_COOLDOWN_TIME = 255;\r\n    \r\n    // A company can start with min 100 tokens or max 10K tokens\r\n    // and min(10%, 500) new tokens will be released every x days where\r\n    // x >= 10;\r\n    uint constant INIT_MAX_SHARES_IN_CIRCULATION = 10000;\r\n    uint constant INIT_MIN_SHARES_IN_CIRCULATION = 100;\r\n    uint constant MAX_SHARES_RELEASE_IN_ONE_CYCLE = 500;\r\n    \r\n    // Company will take a cut of 10% from the share sales!\r\n    uint constant SALES_CUT = 10;\r\n    \r\n    // Company will take a cut of 2% when an order is claimed.\r\n    uint constant ORDER_CUT = 2;\r\n    \r\n    // Type of orders\r\n    enum OrderType {Buy, Sell}\r\n    \r\n    // A new company is listed!\r\n    event Listed(uint companyId, string companyName, uint sharesInCirculation, uint pricePerShare,\r\n    uint percentageSharesToRelease, uint nextSharesReleaseTime, address owner);\r\n    \r\n    // Tokens are claimed!\r\n    event Claimed(uint companyId, uint numberOfShares, address owner);\r\n    \r\n    // Tokens are transfered\r\n    event Transfer(uint companyId, address from, address to, uint numberOfShares);\r\n    \r\n    // There is a new CEO of the company\r\n    event CEOChanged(uint companyId, address previousCEO, address newCEO);\r\n    \r\n    // Shares are relased for the company\r\n    event SharesReleased(uint companyId, address ceo, uint numberOfShares, uint nextSharesReleaseTime);\r\n    \r\n    // A new order is placed\r\n    event OrderPlaced(uint companyId, uint orderIndex, uint amount, uint pricePerShare, OrderType orderType, address owner);\r\n    \r\n    // An order is claimed!\r\n    event OrderFilled(uint companyId, uint orderIndex, uint amount, address buyer);\r\n    \r\n    // A placed order is cancelled!\r\n    event OrderCancelled(uint companyId, uint orderIndex);\r\n    \r\n    event TradingWinnerAnnounced(uint companyId, address winner, uint sharesAwarded);\r\n}\r\n\r\ncontract CompanyBase is BookKeeping, CompanyConstants {\r\n\r\n    struct Company {\r\n        // Company names are stored as hashes to save gas cost during execution\r\n        bytes32 companyNameHash;\r\n\r\n        // Percentage of shares to release\r\n        // will be less than maxPercentageSharesRelease\r\n        uint32 percentageSharesToRelease;\r\n\r\n        // The time of the release cycle in days. If it is set to 10\r\n        // then it means shares can only be released every 10 days \r\n        // Min values is 10\r\n        uint32 coolDownTime;\r\n        \r\n        // Total number of shares that are in circulation right now!\r\n        uint32 sharesInCirculation; \r\n\r\n        // Total number of shares that are still with the company and can be claimed by paying the price\r\n        uint32 unclaimedShares; \r\n        \r\n        // Address of the person who owns more tha 50% shares of the company.\r\n        address ceoOfCompany; \r\n\r\n        // Address of person who registered this company and will receive money from the share sales.\r\n        address ownedBy; \r\n        \r\n        // The exact time in future before which shares can't be released!\r\n        // if shares are just released then nextSharesReleaseTime will be (now + coolDownTime);\r\n        uint nextSharesReleaseTime; \r\n\r\n        // Price of one share as set by the company\r\n        uint pricePerShare; \r\n\r\n        // Share holders of the company\r\n        ShareHolders shareHolders;\r\n    }\r\n\r\n    Company[] companies;\r\n    \r\n    function getCompanyDetails(uint _companyId) \r\n    view\r\n    external \r\n    returns (\r\n        bytes32 companyNameHash,\r\n        uint percentageSharesToRelease,\r\n        uint coolDownTime,\r\n        uint nextSharesReleaseTime,\r\n        uint sharesInCirculation,\r\n        uint unclaimedShares,\r\n        uint pricePerShare,\r\n        uint sharesRequiredToBeCEO,\r\n        address ceoOfCompany,     \r\n        address owner,\r\n        uint numberOfShareHolders) {\r\n\r\n        Company storage company = companies[_companyId];\r\n\r\n        companyNameHash = company.companyNameHash;\r\n        percentageSharesToRelease = company.percentageSharesToRelease;\r\n        coolDownTime = company.coolDownTime;\r\n        nextSharesReleaseTime = company.nextSharesReleaseTime;\r\n        sharesInCirculation = company.sharesInCirculation;\r\n        unclaimedShares = company.unclaimedShares;\r\n        pricePerShare = company.pricePerShare; \r\n        sharesRequiredToBeCEO = (sharesInCirculation/2) + 1;\r\n        ceoOfCompany = company.ceoOfCompany;\r\n        owner = company.ownedBy;\r\n        numberOfShareHolders = company.shareHolders.numberOfShareHolders;\r\n    }\r\n\r\n    function getNumberOfShareHolders(uint _companyId) \r\n    view\r\n    external\r\n    returns (uint) {\r\n        return companies[_companyId].shareHolders.numberOfShareHolders;\r\n    }\r\n\r\n    function getNumberOfSharesForAddress(uint _companyId, address _user) \r\n    view\r\n    external \r\n    returns(uint) {\r\n        return companies[_companyId].shareHolders.ownerAddressToShares[_user];\r\n    }\r\n    \r\n    function getTotalNumberOfRegisteredCompanies()\r\n    view\r\n    external\r\n    returns (uint) {\r\n        return companies.length;\r\n    }\r\n}\r\n\r\ncontract TradingVolume is CompanyConstants {\r\n    \r\n    struct Traders {\r\n        uint relaseTime;\r\n        address winningTrader;\r\n        mapping (address => uint) sharesTraded;\r\n    }\r\n    \r\n    mapping (uint => Traders) companyIdToTraders;\r\n    \r\n    // unique _companyId\r\n    function _addNewCompanyTraders(uint _companyId) \r\n    internal {\r\n        Traders memory traders = Traders({\r\n            winningTrader : 0x0,\r\n            relaseTime : now + TRADING_COMPETITION_PERIOD \r\n        });\r\n        \r\n        companyIdToTraders[_companyId] = traders;\r\n    }\r\n    \r\n    // _from!=_to , _amount > 0\r\n    function _updateTradingVolume(Traders storage _traders, address _from, address _to, uint _amount) \r\n    internal {\r\n        _traders.sharesTraded[_from] += _amount;\r\n        _traders.sharesTraded[_to] += _amount;\r\n        \r\n        if (_traders.sharesTraded[_from] > _traders.sharesTraded[_traders.winningTrader]) {\r\n            _traders.winningTrader = _from;\r\n        } \r\n        \r\n        if (_traders.sharesTraded[_to] > _traders.sharesTraded[_traders.winningTrader]) {\r\n            _traders.winningTrader = _to;\r\n        } \r\n    }\r\n    \r\n    // Get reference of winningTrader before clearing\r\n    function _clearWinner(Traders storage _traders) \r\n    internal {\r\n        delete _traders.sharesTraded[_traders.winningTrader];\r\n        delete _traders.winningTrader;\r\n        _traders.relaseTime = now + TRADING_COMPETITION_PERIOD;\r\n    }\r\n}\r\n\r\ncontract ApprovalContract is CompanyAccessControl {\r\n    // Approver who are approved to launch a company a particular name\r\n    // the bytes32 hash is the hash of the company name!\r\n    mapping(bytes32 => address) public approvedToLaunch;\r\n    \r\n    // Make sure that we don't add two companies with same name\r\n    mapping(bytes32 => bool) public registredCompanyNames;\r\n    \r\n    // Approve addresses to launch a company with the given name\r\n    // Only ceo or cfo can approve a company;\r\n    // the owner who launched the company would receive 90% from the sales of\r\n    // shares and 10% will be kept by the contract!\r\n    function addApprover(address _owner, string _companyName) \r\n    onlyCLevel\r\n    whenNotPaused\r\n    external {\r\n        approvedToLaunch[keccak256(_companyName)] = _owner;\r\n    }\r\n}\r\n\r\ncontract CompanyMain is CompanyBase, ApprovalContract, TradingVolume {\r\n    uint public withdrawableBalance;\r\n    \r\n    // The cut contract takes from the share sales of an approved company.\r\n    // price is in wei\r\n    function _computeSalesCut(uint _price) \r\n    pure\r\n    internal \r\n    returns (uint) {\r\n        return (_price * SALES_CUT)/100;\r\n    }\r\n    \r\n    // Whenever there is transfer of tokens from _from to _to, CEO of company might get changed!\r\n    function _updateCEOIfRequired(Company storage _company, uint _companyId, address _to) \r\n    internal {\r\n        uint sharesRequiredToBecomeCEO = (_company.sharesInCirculation/2 ) + 1;\r\n        address currentCEO = _company.ceoOfCompany;\r\n        \r\n        if (_company.shareHolders.ownerAddressToShares[currentCEO] >= sharesRequiredToBecomeCEO) {\r\n            return;\r\n        } \r\n        \r\n        if (_to != address(this) && _company.shareHolders.ownerAddressToShares[_to] >= sharesRequiredToBecomeCEO) {\r\n            _company.ceoOfCompany = _to;\r\n            emit CEOChanged(_companyId, currentCEO, _to);\r\n            return;\r\n        }\r\n        \r\n        if (currentCEO == 0x0) {\r\n            return;\r\n        }\r\n        _company.ceoOfCompany = 0x0;\r\n        emit CEOChanged(_companyId, currentCEO, 0x0);\r\n    }\r\n    \r\n\r\n    /// Transfer tokens from _from to _to and verify if CEO of company has changed!\r\n    // _from should have enough tokens before calling this functions!\r\n    // _numberOfTokens should be greator than 0\r\n    function _transfer(uint _companyId, address _from, address _to, uint _numberOfTokens) \r\n    internal {\r\n        Company storage company = companies[_companyId];\r\n        \r\n        _sharesSold(company.shareHolders, _from, _numberOfTokens);\r\n        _sharesBought(company.shareHolders, _to, _numberOfTokens);\r\n\r\n        _updateCEOIfRequired(company, _companyId, _to);\r\n        \r\n        emit Transfer(_companyId, _from, _to, _numberOfTokens);\r\n    }\r\n    \r\n    function transferPromotionalShares(uint _companyId, address _to, uint _amount)\r\n    onlyCLevel\r\n    whenNotPaused\r\n    external\r\n    {\r\n        Company storage company = companies[_companyId];\r\n        // implies a promotional company\r\n        require(company.pricePerShare == 0);\r\n        require(companies[_companyId].shareHolders.ownerAddressToShares[msg.sender] >= _amount);\r\n        _transfer(_companyId, msg.sender, _to, _amount);\r\n    }\r\n    \r\n    function addPromotionalCompany(string _companyName, uint _precentageSharesToRelease, uint _coolDownTime, uint _sharesInCirculation)\r\n    onlyCLevel\r\n    whenNotPaused \r\n    external\r\n    {\r\n        bytes32 companyNameHash = keccak256(_companyName);\r\n        \r\n        // There shouldn't be a company that is already registered with same name!\r\n        require(registredCompanyNames[companyNameHash] == false);\r\n        \r\n        // Max 10% shares can be released in one release cycle, to control liquidation\r\n        // and uncontrolled issuing of new tokens. Furthermore the max shares that can\r\n        // be released in one cycle can only be upto 500.\r\n        require(_precentageSharesToRelease <= MAX_PERCENTAGE_SHARE_RELEASE);\r\n        \r\n        // The min release cycle should be at least 10 days\r\n        require(_coolDownTime >= MIN_COOLDOWN_TIME && _coolDownTime <= MAX_COOLDOWN_TIME);\r\n\r\n        uint _companyId = companies.length;\r\n        uint _nextSharesReleaseTime = now + _coolDownTime * 1 days;\r\n        \r\n        Company memory company = Company({\r\n            companyNameHash: companyNameHash,\r\n            \r\n            percentageSharesToRelease : uint32(_precentageSharesToRelease),\r\n            coolDownTime : uint32(_coolDownTime),\r\n            \r\n            sharesInCirculation : uint32(_sharesInCirculation),\r\n            nextSharesReleaseTime : _nextSharesReleaseTime,\r\n            unclaimedShares : 0,\r\n            \r\n            pricePerShare : 0,\r\n            \r\n            ceoOfCompany : 0x0,\r\n            ownedBy : msg.sender,\r\n            shareHolders : ShareHolders({numberOfShareHolders : 0})\r\n            });\r\n\r\n        companies.push(company);\r\n        _addNewCompanyTraders(_companyId);\r\n        // Register company name\r\n        registredCompanyNames[companyNameHash] = true;\r\n        _sharesBought(companies[_companyId].shareHolders, msg.sender, _sharesInCirculation);\r\n        emit Listed(_companyId, _companyName, _sharesInCirculation, 0, _precentageSharesToRelease, _nextSharesReleaseTime, msg.sender);\r\n    }\r\n\r\n    // Add a new company with the given name  \r\n    function addNewCompany(string _companyName, uint _precentageSharesToRelease, uint _coolDownTime, uint _sharesInCirculation, uint _pricePerShare) \r\n    external \r\n    whenNotPaused \r\n    {\r\n        bytes32 companyNameHash = keccak256(_companyName);\r\n        \r\n        // There shouldn't be a company that is already registered with same name!\r\n        require(registredCompanyNames[companyNameHash] == false);\r\n        \r\n        // Owner have the permissions to launch the company\r\n        require(approvedToLaunch[companyNameHash] == msg.sender);\r\n        \r\n        // Max 10% shares can be released in one release cycle, to control liquidation\r\n        // and uncontrolled issuing of new tokens. Furthermore the max shares that can\r\n        // be released in one cycle can only be upto 500.\r\n        require(_precentageSharesToRelease <= MAX_PERCENTAGE_SHARE_RELEASE);\r\n        \r\n        // The min release cycle should be at least 10 days\r\n        require(_coolDownTime >= MIN_COOLDOWN_TIME && _coolDownTime <= MAX_COOLDOWN_TIME);\r\n        \r\n        require(_sharesInCirculation >= INIT_MIN_SHARES_IN_CIRCULATION &&\r\n        _sharesInCirculation <= INIT_MAX_SHARES_IN_CIRCULATION);\r\n\r\n        uint _companyId = companies.length;\r\n        uint _nextSharesReleaseTime = now + _coolDownTime * 1 days;\r\n\r\n        Company memory company = Company({\r\n            companyNameHash: companyNameHash,\r\n            \r\n            percentageSharesToRelease : uint32(_precentageSharesToRelease),\r\n            nextSharesReleaseTime : _nextSharesReleaseTime,\r\n            coolDownTime : uint32(_coolDownTime),\r\n            \r\n            sharesInCirculation : uint32(_sharesInCirculation),\r\n            unclaimedShares : uint32(_sharesInCirculation),\r\n            \r\n            pricePerShare : _pricePerShare,\r\n            \r\n            ceoOfCompany : 0x0,\r\n            ownedBy : msg.sender,\r\n            shareHolders : ShareHolders({numberOfShareHolders : 0})\r\n            });\r\n\r\n        companies.push(company);\r\n        _addNewCompanyTraders(_companyId);\r\n        // Register company name\r\n        registredCompanyNames[companyNameHash] = true;\r\n        emit Listed(_companyId, _companyName, _sharesInCirculation, _pricePerShare, _precentageSharesToRelease, _nextSharesReleaseTime, msg.sender);\r\n    }\r\n    \r\n    // People can claim shares from the company! \r\n    // The share price is fixed. However, once bought the users can place buy/sell\r\n    // orders of any amount!\r\n    function claimShares(uint _companyId, uint _numberOfShares) \r\n    whenNotPaused\r\n    external \r\n    payable {\r\n        Company storage company = companies[_companyId];\r\n        \r\n        require (_numberOfShares > 0 &&\r\n            _numberOfShares <= (company.sharesInCirculation * MAX_CLAIM_SHARES_PERCENTAGE)/100);\r\n\r\n        require(company.unclaimedShares >= _numberOfShares);\r\n        \r\n        uint totalPrice = company.pricePerShare * _numberOfShares;\r\n        require(msg.value >= totalPrice);\r\n\r\n        company.unclaimedShares -= uint32(_numberOfShares);\r\n\r\n        _sharesBought(company.shareHolders, msg.sender, _numberOfShares);\r\n        _updateCEOIfRequired(company, _companyId, msg.sender);\r\n\r\n        if (totalPrice > 0) {\r\n            uint salesCut = _computeSalesCut(totalPrice);\r\n            withdrawableBalance += salesCut;\r\n            uint sellerProceeds = totalPrice - salesCut;\r\n\r\n            company.ownedBy.transfer(sellerProceeds);\r\n        } \r\n\r\n        emit Claimed(_companyId, _numberOfShares, msg.sender);\r\n    }\r\n    \r\n    // Company's next shares can be released only by the CEO of the company! \r\n    // So there should exist a CEO first\r\n    function releaseNextShares(uint _companyId) \r\n    external \r\n    whenNotPaused {\r\n\r\n        Company storage company = companies[_companyId];\r\n        \r\n        require(company.ceoOfCompany == msg.sender);\r\n        \r\n        // If there are unclaimedShares with the company, then new shares can't be relased!\r\n        require(company.unclaimedShares == 0 );\r\n        \r\n        require(now >= company.nextSharesReleaseTime);\r\n\r\n        company.nextSharesReleaseTime = now + company.coolDownTime * 1 days;\r\n        \r\n        // In worst case, we will be relasing max 500 tokens every 10 days! \r\n        // If we will start with max(10K) tokens, then on average we will be adding\r\n        // 18000 tokens every year! In 100 years, it will be 1.8 millions. Multiplying it\r\n        // by 10 makes it 18 millions. There is no way we can overflow the multiplication here!\r\n        uint sharesToRelease = (company.sharesInCirculation * company.percentageSharesToRelease)/100;\r\n        \r\n        // Max 500 tokens can be relased\r\n        if (sharesToRelease > MAX_SHARES_RELEASE_IN_ONE_CYCLE) {\r\n            sharesToRelease = MAX_SHARES_RELEASE_IN_ONE_CYCLE;\r\n        }\r\n        \r\n        if (sharesToRelease > 0) {\r\n            company.sharesInCirculation += uint32(sharesToRelease);\r\n            _sharesBought(company.shareHolders, company.ceoOfCompany, sharesToRelease);\r\n            emit SharesReleased(_companyId, company.ceoOfCompany, sharesToRelease, company.nextSharesReleaseTime);\r\n        }\r\n    }\r\n    \r\n    function _updateTradingVolume(uint _companyId, address _from, address _to, uint _amount) \r\n    internal {\r\n        Traders storage traders = companyIdToTraders[_companyId];\r\n        _updateTradingVolume(traders, _from, _to, _amount);\r\n        \r\n        if (now < traders.relaseTime) {\r\n            return;\r\n        }\r\n        \r\n        Company storage company = companies[_companyId];\r\n        uint _newShares = company.sharesInCirculation/100;\r\n        if (_newShares > MAX_SHARES_RELEASE_IN_ONE_CYCLE) {\r\n            _newShares = 100;\r\n        }\r\n        company.sharesInCirculation += uint32(_newShares);\r\n         _sharesBought(company.shareHolders, traders.winningTrader, _newShares);\r\n        _updateCEOIfRequired(company, _companyId, traders.winningTrader);\r\n        emit TradingWinnerAnnounced(_companyId, traders.winningTrader, _newShares);\r\n        _clearWinner(traders);\r\n    }\r\n}\r\n\r\ncontract MarketBase is CompanyMain {\r\n    \r\n    function MarketBase() public {\r\n        ceoAddress = msg.sender;\r\n        cfoAddress = msg.sender;\r\n    }\r\n    \r\n    struct Order {\r\n        // Owner who placed the order\r\n        address owner;\r\n                \r\n        // Total number of tokens in order\r\n        uint32 amount;\r\n        \r\n        // Amount of tokens that are already bought/sold by other people\r\n        uint32 amountFilled;\r\n        \r\n        // Type of the order\r\n        OrderType orderType;\r\n        \r\n        // Price of one share\r\n        uint pricePerShare;\r\n    }\r\n    \r\n    // A mapping of companyId to orders\r\n    mapping (uint => Order[]) companyIdToOrders;\r\n    \r\n    // _amount > 0\r\n    function _createOrder(uint _companyId, uint _amount, uint _pricePerShare, OrderType _orderType) \r\n    internal {\r\n        Order memory order = Order({\r\n            owner : msg.sender,\r\n            pricePerShare : _pricePerShare,\r\n            amount : uint32(_amount),\r\n            amountFilled : 0,\r\n            orderType : _orderType\r\n        });\r\n        \r\n        uint index = companyIdToOrders[_companyId].push(order) - 1;\r\n        emit OrderPlaced(_companyId, index, order.amount, order.pricePerShare, order.orderType, msg.sender);\r\n    }\r\n    \r\n    // Place a sell request if seller have enough tokens!\r\n    function placeSellRequest(uint _companyId, uint _amount, uint _pricePerShare) \r\n    whenNotPaused\r\n    external {\r\n        require (_amount > 0);\r\n        require (_pricePerShare > 0);\r\n\r\n        // Seller should have enough tokens to place a sell order!\r\n        _verifyOwnershipOfTokens(_companyId, msg.sender, _amount);\r\n\r\n        _transfer(_companyId, msg.sender, this, _amount);\r\n        _createOrder(_companyId, _amount, _pricePerShare, OrderType.Sell);\r\n    }\r\n    \r\n    // Place a request to buy shares of a particular company!\r\n    function placeBuyRequest(uint _companyId, uint _amount, uint _pricePerShare) \r\n    external \r\n    payable \r\n    whenNotPaused {\r\n        require(_amount > 0);\r\n        require(_pricePerShare > 0);\r\n        require(_amount == uint(uint32(_amount)));\r\n        \r\n        // Should have enough eth!\r\n        require(msg.value >= _amount * _pricePerShare);\r\n\r\n        _createOrder(_companyId, _amount, _pricePerShare, OrderType.Buy);\r\n    }\r\n    \r\n    // Cancel a placed order!\r\n    function cancelRequest(uint _companyId, uint _orderIndex) \r\n    external {        \r\n        Order storage order = companyIdToOrders[_companyId][_orderIndex];\r\n        \r\n        require(order.owner == msg.sender);\r\n        \r\n        uint sharesRemaining = _getRemainingSharesInOrder(order);\r\n        \r\n        require(sharesRemaining > 0);\r\n\r\n        order.amountFilled += uint32(sharesRemaining);\r\n        \r\n        if (order.orderType == OrderType.Buy) {\r\n\r\n             // If its a buy order, transfer the ether back to owner;\r\n            uint price = _getTotalPrice(order, sharesRemaining);\r\n            \r\n            // Sends money back to owner!\r\n            msg.sender.transfer(price);\r\n        } else {\r\n            \r\n            // Send the tokens back to the owner\r\n            _transfer(_companyId, this, msg.sender, sharesRemaining);\r\n        }\r\n\r\n        emit OrderCancelled(_companyId, _orderIndex);\r\n    }\r\n    \r\n    // Fill the sell order!\r\n    function fillSellOrder(uint _companyId, uint _orderIndex, uint _amount) \r\n    whenNotPaused\r\n    external \r\n    payable {\r\n        require(_amount > 0);\r\n        \r\n        Order storage order = companyIdToOrders[_companyId][_orderIndex];\r\n        require(order.orderType == OrderType.Sell);\r\n        \r\n        require(msg.sender != order.owner);\r\n       \r\n        _verifyRemainingSharesInOrder(order, _amount);\r\n\r\n        uint price = _getTotalPrice(order, _amount);\r\n        require(msg.value >= price);\r\n\r\n        order.amountFilled += uint32(_amount);\r\n        \r\n        // transfer tokens to the buyer\r\n        _transfer(_companyId, this, msg.sender, _amount);\r\n        \r\n        // send money to seller after taking a small share\r\n        _transferOrderMoney(price, order.owner);  \r\n        \r\n        _updateTradingVolume(_companyId, msg.sender, order.owner, _amount);\r\n        \r\n        emit OrderFilled(_companyId, _orderIndex, _amount, msg.sender);\r\n    }\r\n    \r\n    // Fill the sell order!\r\n    function fillSellOrderPartially(uint _companyId, uint _orderIndex, uint _maxAmount) \r\n    whenNotPaused\r\n    external \r\n    payable {\r\n        require(_maxAmount > 0);\r\n        \r\n        Order storage order = companyIdToOrders[_companyId][_orderIndex];\r\n        require(order.orderType == OrderType.Sell);\r\n        \r\n        require(msg.sender != order.owner);\r\n       \r\n        uint buyableShares = _getRemainingSharesInOrder(order);\r\n        require(buyableShares > 0);\r\n        \r\n        if (buyableShares > _maxAmount) {\r\n            buyableShares = _maxAmount;\r\n        }\r\n\r\n        uint price = _getTotalPrice(order, buyableShares);\r\n        require(msg.value >= price);\r\n\r\n        order.amountFilled += uint32(buyableShares);\r\n        \r\n        // transfer tokens to the buyer\r\n        _transfer(_companyId, this, msg.sender, buyableShares);\r\n        \r\n        // send money to seller after taking a small share\r\n        _transferOrderMoney(price, order.owner); \r\n        \r\n        _updateTradingVolume(_companyId, msg.sender, order.owner, buyableShares);\r\n        \r\n        uint buyerProceeds = msg.value - price;\r\n        msg.sender.transfer(buyerProceeds);\r\n        \r\n        emit OrderFilled(_companyId, _orderIndex, buyableShares, msg.sender);\r\n    }\r\n\r\n    // Fill the buy order!\r\n    function fillBuyOrder(uint _companyId, uint _orderIndex, uint _amount) \r\n    whenNotPaused\r\n    external {\r\n        require(_amount > 0);\r\n        \r\n        Order storage order = companyIdToOrders[_companyId][_orderIndex];\r\n        require(order.orderType == OrderType.Buy);\r\n        \r\n        require(msg.sender != order.owner);\r\n        \r\n        // There should exist enought shares to fulfill the request!\r\n        _verifyRemainingSharesInOrder(order, _amount);\r\n        \r\n        // The seller have enought tokens to fulfill the request!\r\n        _verifyOwnershipOfTokens(_companyId, msg.sender, _amount);\r\n        \r\n        order.amountFilled += uint32(_amount);\r\n        \r\n        // transfer the tokens from the seller to the buyer!\r\n        _transfer(_companyId, msg.sender, order.owner, _amount);\r\n        \r\n        uint price = _getTotalPrice(order, _amount);\r\n        \r\n        // transfer the money from this contract to the seller\r\n        _transferOrderMoney(price , msg.sender);\r\n        \r\n        _updateTradingVolume(_companyId, msg.sender, order.owner, _amount);\r\n\r\n        emit OrderFilled(_companyId, _orderIndex, _amount, msg.sender);\r\n    }\r\n    \r\n    // Fill buy order partially if possible!\r\n    function fillBuyOrderPartially(uint _companyId, uint _orderIndex, uint _maxAmount) \r\n    whenNotPaused\r\n    external {\r\n        require(_maxAmount > 0);\r\n        \r\n        Order storage order = companyIdToOrders[_companyId][_orderIndex];\r\n        require(order.orderType == OrderType.Buy);\r\n        \r\n        require(msg.sender != order.owner);\r\n        \r\n        // There should exist enought shares to fulfill the request!\r\n        uint buyableShares = _getRemainingSharesInOrder(order);\r\n        require(buyableShares > 0);\r\n        \r\n        if ( buyableShares > _maxAmount) {\r\n            buyableShares = _maxAmount;\r\n        }\r\n        \r\n        // The seller have enought tokens to fulfill the request!\r\n        _verifyOwnershipOfTokens(_companyId, msg.sender, buyableShares);\r\n        \r\n        order.amountFilled += uint32(buyableShares);\r\n        \r\n        // transfer the tokens from the seller to the buyer!\r\n        _transfer(_companyId, msg.sender, order.owner, buyableShares);\r\n        \r\n        uint price = _getTotalPrice(order, buyableShares);\r\n        \r\n        // transfer the money from this contract to the seller\r\n        _transferOrderMoney(price , msg.sender);\r\n        \r\n        _updateTradingVolume(_companyId, msg.sender, order.owner, buyableShares);\r\n\r\n        emit OrderFilled(_companyId, _orderIndex, buyableShares, msg.sender);\r\n    }\r\n\r\n    // transfer money to the owner!\r\n    function _transferOrderMoney(uint _price, address _owner) \r\n    internal {\r\n        uint priceCut = (_price * ORDER_CUT)/100;\r\n        _owner.transfer(_price - priceCut);\r\n        withdrawableBalance += priceCut;\r\n    }\r\n\r\n    // Returns the price for _amount tokens for the given order\r\n    // _amount > 0\r\n    // order should be verified\r\n    function _getTotalPrice(Order storage _order, uint _amount) \r\n    view\r\n    internal \r\n    returns (uint) {\r\n        return _amount * _order.pricePerShare;\r\n    }\r\n    \r\n    // Gets the number of remaining shares that can be bought or sold under this order\r\n    function _getRemainingSharesInOrder(Order storage _order) \r\n    view\r\n    internal \r\n    returns (uint) {\r\n        return _order.amount - _order.amountFilled;\r\n    }\r\n\r\n    // Verifies if the order have _amount shares to buy/sell\r\n    // _amount > 0\r\n    function _verifyRemainingSharesInOrder(Order storage _order, uint _amount) \r\n    view\r\n    internal {\r\n        require(_getRemainingSharesInOrder(_order) >= _amount);\r\n    }\r\n\r\n    // Checks if the owner have at least '_amount' shares of the company\r\n    // _amount > 0\r\n    function _verifyOwnershipOfTokens(uint _companyId, address _owner, uint _amount) \r\n    view\r\n    internal {\r\n        require(companies[_companyId].shareHolders.ownerAddressToShares[_owner] >= _amount);\r\n    }\r\n    \r\n    // Returns the length of array! All orders might not be active\r\n    function getNumberOfOrders(uint _companyId) \r\n    view\r\n    external \r\n    returns (uint numberOfOrders) {\r\n        numberOfOrders = companyIdToOrders[_companyId].length;\r\n    }\r\n\r\n    function getOrderDetails(uint _comanyId, uint _orderIndex) \r\n    view\r\n    external \r\n    returns (address _owner,\r\n        uint _pricePerShare,\r\n        uint _amount,\r\n        uint _amountFilled,\r\n        OrderType _orderType) {\r\n            Order storage order =  companyIdToOrders[_comanyId][_orderIndex];\r\n            \r\n            _owner = order.owner;\r\n            _pricePerShare = order.pricePerShare;\r\n            _amount = order.amount;\r\n            _amountFilled = order.amountFilled;\r\n            _orderType = order.orderType;\r\n    }\r\n    \r\n    function withdrawBalance(address _address) \r\n    onlyCLevel\r\n    external {\r\n        require(_address != 0x0);\r\n        uint balance = withdrawableBalance;\r\n        withdrawableBalance = 0;\r\n        _address.transfer(balance);\r\n    }\r\n    \r\n    // Only when the contract is paused and there is a subtle bug!\r\n    function kill(address _address) \r\n    onlyCLevel\r\n    whenPaused\r\n    external {\r\n        require(_address != 0x0);\r\n        selfdestruct(_address);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"}],\"name\":\"getNumberOfShareHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferPromotionalShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_orderIndex\",\"type\":\"uint256\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"fillSellOrderPartially\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyName\",\"type\":\"string\"},{\"name\":\"_precentageSharesToRelease\",\"type\":\"uint256\"},{\"name\":\"_coolDownTime\",\"type\":\"uint256\"},{\"name\":\"_sharesInCirculation\",\"type\":\"uint256\"}],\"name\":\"addPromotionalCompany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_comanyId\",\"type\":\"uint256\"},{\"name\":\"_orderIndex\",\"type\":\"uint256\"}],\"name\":\"getOrderDetails\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_pricePerShare\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_amountFilled\",\"type\":\"uint256\"},{\"name\":\"_orderType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_pricePerShare\",\"type\":\"uint256\"}],\"name\":\"placeBuyRequest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"registredCompanyNames\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyName\",\"type\":\"string\"},{\"name\":\"_precentageSharesToRelease\",\"type\":\"uint256\"},{\"name\":\"_coolDownTime\",\"type\":\"uint256\"},{\"name\":\"_sharesInCirculation\",\"type\":\"uint256\"},{\"name\":\"_pricePerShare\",\"type\":\"uint256\"}],\"name\":\"addNewCompany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNumberOfSharesForAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"}],\"name\":\"getNumberOfOrders\",\"outputs\":[{\"name\":\"numberOfOrders\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"approvedToLaunch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_companyName\",\"type\":\"string\"}],\"name\":\"addApprover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalNumberOfRegisteredCompanies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_orderIndex\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fillSellOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"}],\"name\":\"releaseNextShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_numberOfShares\",\"type\":\"uint256\"}],\"name\":\"claimShares\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_orderIndex\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fillBuyOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_orderIndex\",\"type\":\"uint256\"}],\"name\":\"cancelRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"}],\"name\":\"getCompanyDetails\",\"outputs\":[{\"name\":\"companyNameHash\",\"type\":\"bytes32\"},{\"name\":\"percentageSharesToRelease\",\"type\":\"uint256\"},{\"name\":\"coolDownTime\",\"type\":\"uint256\"},{\"name\":\"nextSharesReleaseTime\",\"type\":\"uint256\"},{\"name\":\"sharesInCirculation\",\"type\":\"uint256\"},{\"name\":\"unclaimedShares\",\"type\":\"uint256\"},{\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"name\":\"sharesRequiredToBeCEO\",\"type\":\"uint256\"},{\"name\":\"ceoOfCompany\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"numberOfShareHolders\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_orderIndex\",\"type\":\"uint256\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"fillBuyOrderPartially\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_companyId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_pricePerShare\",\"type\":\"uint256\"}],\"name\":\"placeSellRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"companyName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"sharesInCirculation\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"percentageSharesToRelease\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextSharesReleaseTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Listed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numberOfShares\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberOfShares\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"previousCEO\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCEO\",\"type\":\"address\"}],\"name\":\"CEOChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ceo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberOfShares\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextSharesReleaseTime\",\"type\":\"uint256\"}],\"name\":\"SharesReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OrderPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"OrderFilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderIndex\",\"type\":\"uint256\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sharesAwarded\",\"type\":\"uint256\"}],\"name\":\"TradingWinnerAnnounced\",\"type\":\"event\"}]","ContractName":"MarketBase","CompilerVersion":"v0.4.24-nightly.2018.4.20+commit.f328431","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ef30e4432a3a21b96b0e3e29bfc239bbaab0e5b2077532e5d5cb29e5969776ca"}]}