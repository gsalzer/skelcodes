{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract controlled{\r\n  address public owner;\r\n  uint256 public tokenFrozenUntilBlock;\r\n  uint256 public tokenFrozenSinceBlock;\r\n  uint256 public blockLock;\r\n\r\n  mapping (address => bool) restrictedAddresses;\r\n\r\n  // @dev Constructor function that sets freeze parameters so they don't unintentionally hinder operations.\r\n  function controlled() public{\r\n    owner = 0x24bF9FeCA8894A78d231f525c054048F5932dc6B;\r\n    tokenFrozenSinceBlock = (2 ** 256) - 1;\r\n    tokenFrozenUntilBlock = 0;\r\n    blockLock = 5571500;\r\n  }\r\n\r\n  /*\r\n  * @dev Transfers ownership rights to current owner to the new owner.\r\n  * @param newOwner address Address to become the new SC owner.\r\n  */\r\n  function transferOwnership (address newOwner) onlyOwner public{\r\n    owner = newOwner;\r\n  }\r\n\r\n  /*\r\n  * @dev Allows owner to restrict or reenable addresses to use the token.\r\n  * @param _restrictedAddress address Address of the user whose state we are planning to modify.\r\n  * @param _restrict bool Restricts uder from using token. true restricts the address while false enables it.\r\n  */\r\n  function editRestrictedAddress(address _restrictedAddress, bool _restrict) public onlyOwner{\r\n    if(!restrictedAddresses[_restrictedAddress] && _restrict){\r\n      restrictedAddresses[_restrictedAddress] = _restrict;\r\n    }\r\n    else if(restrictedAddresses[_restrictedAddress] && !_restrict){\r\n      restrictedAddresses[_restrictedAddress] = _restrict;\r\n    }\r\n    else{\r\n      revert();\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /************ Modifiers to restrict access to functions. ************/\r\n\r\n  // @dev Modifier to make sure the owner's functions are only called by the owner.\r\n  modifier onlyOwner{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /*\r\n  * @dev Modifier to check whether destination of sender aren't forbidden from using the token.\r\n  * @param _to address Address of the transfer destination.\r\n  */\r\n  modifier instForbiddenAddress(address _to){\r\n    require(_to != 0x0);\r\n    require(_to != address(this));\r\n    require(!restrictedAddresses[_to]);\r\n    require(!restrictedAddresses[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  // @dev Modifier to check if the token is operational at the moment.\r\n  modifier unfrozenToken{\r\n    require(block.number >= blockLock || msg.sender == owner);\r\n    require(block.number >= tokenFrozenUntilBlock);\r\n    require(block.number <= tokenFrozenSinceBlock);\r\n    _;\r\n  }\r\n}\r\n\r\ncontract blocktrade is controlled{\r\n  string public name = \"blocktrade.com\";\r\n  string public symbol = \"BTT\";\r\n  uint8 public decimals = 18;\r\n  uint256 public initialSupply = 57746762*(10**18);\r\n  uint256 public supply;\r\n  string public tokenFrozenUntilNotice;\r\n  string public tokenFrozenSinceNotice;\r\n  bool public airDropFinished;\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowances;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event TokenFrozenUntil(uint256 _frozenUntilBlock, string _reason);\r\n  event TokenFrozenSince(uint256 _frozenSinceBlock, string _reason);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n  event Burn(address indexed from, uint256 value);\r\n\r\n  /*\r\n  * @dev Constructor function.\r\n  */\r\n  function blocktrade() public{\r\n    supply = 57746762*(10**18);\r\n    airDropFinished = false;\r\n    balances[owner] = 57746762*(10**18);\r\n  }\r\n\r\n\r\n  /************ Constant return functions ************/\r\n  //@dev Returns the name of the token.\r\n  function tokenName() constant public returns(string _tokenName){\r\n    return name;\r\n  }\r\n\r\n  //@dev Returns the symbol of the token.\r\n  function tokenSymbol() constant public returns(string _tokenSymbol){\r\n    return symbol;\r\n  }\r\n\r\n  //@dev Returns the number of decimals the token uses - e.g. 8, means to divide the token amount by 100000000 to get its user representation.\r\n  function tokenDecimals() constant public returns(uint8 _tokenDecimals){\r\n    return decimals;\r\n  }\r\n\r\n  //@dev Returns the total supply of the token\r\n  function totalSupply() constant public returns(uint256 _totalSupply){\r\n    return supply;\r\n  }\r\n\r\n  /*\r\n  * @dev Allows us to view the token balance of the account.\r\n  * @param _tokenOwner address Address of the user whose token balance we are trying to view.\r\n  */\r\n  function balanceOf(address _tokenOwner) constant public returns(uint256 accountBalance){\r\n    return balances[_tokenOwner];\r\n  }\r\n\r\n  /*\r\n  * @dev Allows us to view the token balance of the account.\r\n  * @param _owner address Address of the user whose token we are allowed to spend from sender address.\r\n  * @param _spender address Address of the user allowed to spend owner's tokens.\r\n  */\r\n  function allowance(address _owner, address _spender) constant public returns(uint256 remaining) {\r\n    return allowances[_owner][_spender];\r\n  }\r\n\r\n  // @dev Returns when will the token become operational again and why it was frozen.\r\n  function getFreezeUntilDetails() constant public returns(uint256 frozenUntilBlock, string notice){\r\n    return(tokenFrozenUntilBlock, tokenFrozenUntilNotice);\r\n  }\r\n\r\n  //@dev Returns when will the operations of token stop and why.\r\n  function getFreezeSinceDetails() constant public returns(uint frozenSinceBlock, string notice){\r\n    return(tokenFrozenSinceBlock, tokenFrozenSinceNotice);\r\n  }\r\n\r\n  /*\r\n  * @dev Returns info whether address can use the token or not.\r\n  * @param _queryAddress address Address of the account we want to check.\r\n  */\r\n  function isRestrictedAddress(address _queryAddress) constant public returns(bool answer){\r\n    return restrictedAddresses[_queryAddress];\r\n  }\r\n\r\n\r\n  /************ Operational functions ************/\r\n  /*\r\n  * @dev Used for sending own tokens to other addresses. Keep in mind that you have to take decimals into account. Multiply the value in tokens with 10^tokenDecimals.\r\n  * @param _to address Destination where we want to send the tokens to.\r\n  * @param _value uint256 Amount of tokens we want to sender.\r\n  */\r\n  function transfer(address _to, uint256 _value) unfrozenToken instForbiddenAddress(_to) public returns(bool success){\r\n    require(balances[msg.sender] >= _value);           // Check if the sender has enough\r\n    require(balances[_to] + _value >= balances[_to]) ;  // Check for overflows\r\n\r\n    balances[msg.sender] -= _value;                     // Subtract from the sender\r\n    balances[_to] += _value;                            // Add the same to the recipient\r\n    emit Transfer(msg.sender, _to, _value);                  // Notify anyone listening that this transfer took place\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * @dev Sets allowance to the spender from our address.\r\n  * @param _spender address Address of the spender we are giving permissions to.\r\n  * @param _value uint256 Amount of tokens the spender is allowed to spend from owner's accoun. Note the decimal spaces.\r\n  */\r\n  function approve(address _spender, uint256 _value) unfrozenToken public returns (bool success){\r\n    allowances[msg.sender][_spender] = _value;          // Set allowance\r\n    emit Approval(msg.sender, _spender, _value);             // Raise Approval event\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * @dev Used by spender to transfer some one else's tokens.\r\n  * @param _form address Address of the owner of the tokens.\r\n  * @param _to address Address where we want to transfer tokens to.\r\n  * @param _value uint256 Amount of tokens we want to transfer. Note the decimal spaces.\r\n  */\r\n  function transferFrom(address _from, address _to, uint256 _value) unfrozenToken instForbiddenAddress(_to) public returns(bool success){\r\n    require(balances[_from] >= _value);                // Check if the sender has enough\r\n    require(balances[_to] + _value >= balances[_to]);  // Check for overflows\r\n    require(_value <= allowances[_from][msg.sender]);  // Check allowance\r\n\r\n    balances[_from] -= _value;                          // Subtract from the sender\r\n    balances[_to] += _value;                            // Add the same to the recipient\r\n    allowances[_from][msg.sender] -= _value;            // Deduct allowance for this address\r\n    emit Transfer(_from, _to, _value);                       // Notify anyone listening that this transfer took place\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * @dev Ireversibly destroy the specified amount of tokens.\r\n  * @param _value uint256 Amount of tokens we want to destroy.\r\n  */\r\n  function burn(uint256 _value) onlyOwner public returns(bool success){\r\n    require(balances[msg.sender] >= _value);                 // Check if the sender has enough\r\n    balances[msg.sender] -= _value;                          // Subtract from the sender\r\n    supply -= _value;\r\n    emit Burn(msg.sender, _value);\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * @dev Freezes transfers untill the specified block. Afterwards all of the operations are carried on as normal.\r\n  * @param _frozenUntilBlock uint256 Number of block untill which all of the transfers are frozen.\r\n  * @param _freezeNotice string Reason fot the freeze of operations.\r\n  */\r\n  function freezeTransfersUntil(uint256 _frozenUntilBlock, string _freezeNotice) onlyOwner public returns(bool success){\r\n    tokenFrozenUntilBlock = _frozenUntilBlock;\r\n    tokenFrozenUntilNotice = _freezeNotice;\r\n    emit TokenFrozenUntil(_frozenUntilBlock, _freezeNotice);\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * @dev Freezes all of the transfers after specified block.\r\n  * @param _frozenSinceBlock uint256 Number of block after which all of the transfers are frozen.\r\n  * @param _freezeNotice string Reason for the freeze.\r\n  */\r\n  function freezeTransfersSince(uint256 _frozenSinceBlock, string _freezeNotice) onlyOwner public returns(bool success){\r\n    tokenFrozenSinceBlock = _frozenSinceBlock;\r\n    tokenFrozenSinceNotice = _freezeNotice;\r\n    emit TokenFrozenSince(_frozenSinceBlock, _freezeNotice);\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * @dev Reenables the operation before the specified block was reached.\r\n  * @param _unfreezeNotice string Reason for the unfreeze or explanation of solution.\r\n  */\r\n  function unfreezeTransfersUntil(string _unfreezeNotice) onlyOwner public returns(bool success){\r\n    tokenFrozenUntilBlock = 0;\r\n    tokenFrozenUntilNotice = _unfreezeNotice;\r\n    emit TokenFrozenUntil(0, _unfreezeNotice);\r\n    return true;\r\n  }\r\n\r\n  /*\r\n  * @dev Reenabling after the freeze since was initiated.\r\n  * @param _unfreezeNotice string Reason for the unfreeze or the explanation of solution.\r\n  */\r\n  function unfreezeTransfersSince(string _unfreezeNotice) onlyOwner public returns(bool success){\r\n    tokenFrozenSinceBlock = (2 ** 256) - 1;\r\n    tokenFrozenSinceNotice = _unfreezeNotice;\r\n    emit TokenFrozenSince((2 ** 256) - 1, _unfreezeNotice);\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n  /************ AirDrop part of the SC. ************/\r\n\r\n  /*\r\n  * @dev Allocates the specified amount of tokens to the address.\r\n  * @param _beneficiary address Address of the ouser that receives the tokens.\r\n  * @param _tokens uint256 Amount of tokens to allocate.\r\n  */\r\n  function airDrop(address _beneficiary, uint256 _tokens) onlyOwner public returns(bool success){\r\n    require(!airDropFinished);\r\n    balances[owner] -= _tokens;\r\n    balances[_beneficiary] += _tokens;\r\n    return true;\r\n  }\r\n\r\n  // @dev Function that irreversively disables airDrop and should be called right after airDrop is completed.\r\n  function endAirDrop() onlyOwner public returns(bool success){\r\n    require(!airDropFinished);\r\n    airDropFinished = true;\r\n    return true;\r\n  }\r\n}\r\n//JA","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_queryAddress\",\"type\":\"address\"}],\"name\":\"isRestrictedAddress\",\"outputs\":[{\"name\":\"answer\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"airDrop\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDecimals\",\"outputs\":[{\"name\":\"_tokenDecimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_restrictedAddress\",\"type\":\"address\"},{\"name\":\"_restrict\",\"type\":\"bool\"}],\"name\":\"editRestrictedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unfreezeNotice\",\"type\":\"string\"}],\"name\":\"unfreezeTransfersUntil\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFrozenUntilNotice\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFrozenSinceNotice\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenName\",\"outputs\":[{\"name\":\"_tokenName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endAirDrop\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"accountBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSymbol\",\"outputs\":[{\"name\":\"_tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFreezeUntilDetails\",\"outputs\":[{\"name\":\"frozenUntilBlock\",\"type\":\"uint256\"},{\"name\":\"notice\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFrozenUntilBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unfreezeNotice\",\"type\":\"string\"}],\"name\":\"unfreezeTransfersSince\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_frozenUntilBlock\",\"type\":\"uint256\"},{\"name\":\"_freezeNotice\",\"type\":\"string\"}],\"name\":\"freezeTransfersUntil\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFrozenSinceBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockLock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFreezeSinceDetails\",\"outputs\":[{\"name\":\"frozenSinceBlock\",\"type\":\"uint256\"},{\"name\":\"notice\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_frozenSinceBlock\",\"type\":\"uint256\"},{\"name\":\"_freezeNotice\",\"type\":\"string\"}],\"name\":\"freezeTransfersSince\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_frozenUntilBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"TokenFrozenUntil\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_frozenSinceBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"TokenFrozenSince\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"blocktrade","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://16bdd8402a535b04e56a96702f1e58f70a852467270d4334de9270a2139ce7b0"}]}