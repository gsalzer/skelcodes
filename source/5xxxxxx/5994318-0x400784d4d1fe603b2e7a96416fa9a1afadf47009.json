{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/Owned.sol\r\n\r\n// ----------------------------------------------------------------------------\r\n// Ownership functionality for authorization controls and user permissions\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\n// ----------------------------------------------------------------------------\r\n// Pause functionality\r\n// ----------------------------------------------------------------------------\r\ncontract Pausable is Owned {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  // Modifier to make a function callable only when the contract is not paused.\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  // Modifier to make a function callable only when the contract is paused.\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  // Called by the owner to pause, triggers stopped state\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  // Called by the owner to unpause, returns to normal state\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\ncontract SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n// File: contracts/ERC20.sol\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Standard Interface\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// File: contracts/UncToken.sol\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'UNC' 'Uncloak' token contract\r\n// Symbol      : UNC\r\n// Name        : Uncloak\r\n// Total supply: 4,200,000,000\r\n// Decimals    : 18\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals\r\n// Receives ETH and generates tokens\r\n// ----------------------------------------------------------------------------\r\ncontract UncToken is SafeMath, Owned, ERC20 {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    // Track whether the coin can be transfered\r\n    bool private transferEnabled = false;\r\n\r\n    // track addresses that can transfer regardless of whether transfers are enables\r\n    mapping(address => bool) public transferAdmins;\r\n\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) internal allowed;\r\n\r\n    event Burned(address indexed burner, uint256 value);\r\n\r\n    // Check if transfer is valid\r\n    modifier canTransfer(address _sender) {\r\n        require(transferEnabled || transferAdmins[_sender]);\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        symbol = \"UNC\";\r\n        name = \"Uncloak\";\r\n        decimals = 18;\r\n        _totalSupply = 4200000000 * 10**uint(decimals);\r\n        transferAdmins[owner] = true; // Enable transfers for owner\r\n        balances[owner] = _totalSupply;\r\n        emit Transfer(address(0), owner, _totalSupply);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) canTransfer (msg.sender) public returns (bool success) {\r\n        require(to != address(this)); //make sure we're not transfering to this contract\r\n\r\n        //check edge cases\r\n        if (balances[msg.sender] >= tokens\r\n            && tokens > 0) {\r\n\r\n                //update balances\r\n                balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n                balances[to] = safeAdd(balances[to], tokens);\r\n\r\n                //log event\r\n                emit Transfer(msg.sender, to, tokens);\r\n                return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        // Ownly allow changes to or from 0. Mitigates vulnerabiilty of race description\r\n        // described here: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((tokens == 0) || (allowed[msg.sender][spender] == 0));\r\n\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    //\r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) canTransfer(from) public returns (bool success) {\r\n        require(to != address(this));\r\n\r\n        //check edge cases\r\n        if (allowed[from][msg.sender] >= tokens\r\n            && balances[from] >= tokens\r\n            && tokens > 0) {\r\n\r\n            //update balances and allowances\r\n            balances[from] = safeSub(balances[from], tokens);\r\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n            balances[to] = safeAdd(balances[to], tokens);\r\n\r\n            //log event\r\n            emit Transfer(from, to, tokens);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // Owner can allow transfers for a particular address. Use for crowdsale contract.\r\n    function setTransferAdmin(address _addr, bool _canTransfer) onlyOwner public {\r\n        transferAdmins[_addr] = _canTransfer;\r\n    }\r\n\r\n    // Enable transfers for token holders\r\n    function enablesTransfers() public onlyOwner {\r\n        transferEnabled = true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Burns a specific number of tokens\r\n    // ------------------------------------------------------------------------\r\n    function burn(uint256 _value) public onlyOwner {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = safeSub(balances[burner], _value);\r\n        _totalSupply = safeSub(_totalSupply, _value);\r\n        emit Burned(burner, _value);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Doesn't Accept Eth\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}\r\n\r\n// File: contracts/TimeLock.sol\r\n\r\n// ----------------------------------------------------------------------------\r\n// The timeLock contract is used for locking up the tokens of early backers.\r\n// It distributes 40% at launch, 40% 3 months later, 20% 6 months later.\r\n// ----------------------------------------------------------------------------\r\ncontract TimeLock is SafeMath, Owned {\r\n\r\n  // Token we are using\r\n  UncToken public token;\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  // timestamp when token release is enabled\r\n  uint256 public releaseTime1;\r\n  uint256 public releaseTime2;\r\n  uint256 public releaseTime3;\r\n\r\n  // track initial balance of time lock\r\n  uint256 public initialBalance;\r\n\r\n  // Keep track of step of distribution\r\n  uint public step = 0;\r\n\r\n  // constructor\r\n  constructor(UncToken _token, address _beneficiary, uint256 _releaseTime) public {\r\n    require(_releaseTime > now);\r\n    token = _token;\r\n    beneficiary = _beneficiary;\r\n    releaseTime1 = _releaseTime;\r\n    releaseTime2 = safeAdd(releaseTime1, 7776000);  // Add 3 months\r\n    releaseTime3 = safeAdd(releaseTime1, 15552000);  // Add 6 months\r\n  }\r\n\r\n\r\n  // Sets the initial balance, used because timelock distribution based on % of initial balance\r\n  function setInitialBalance() public onlyOwner {\r\n  \tinitialBalance = token.balanceOf(address(this));\r\n  }\r\n\r\n  // Function to move release time frame earlier if needed\r\n  function updateReleaseTime(uint256 _releaseTime) public onlyOwner {\r\n  \t// Check that release schedule has not started\r\n  \trequire(now < releaseTime1);\r\n  \trequire(_releaseTime < releaseTime1);\r\n\r\n  \t// Update times\r\n  \treleaseTime1 = _releaseTime;\r\n    releaseTime2 = safeAdd(releaseTime1, 7776000);  // Add 3 months\r\n    releaseTime3 = safeAdd(releaseTime1, 15552000);  // Add 6 months\r\n  }\r\n\r\n  // Transfers tokens held by timelock to beneficiary.\r\n  function release() public {\r\n    require(now >= releaseTime1);\r\n\r\n    uint256 unlockAmount = 0;\r\n\r\n    // Initial balance of tokens in this contract\r\n    uint256 amount = initialBalance;\r\n    require(amount > 0);\r\n\r\n    // Determine release amount\r\n    if (step == 0 && now > releaseTime1) {\r\n    \tunlockAmount = safeDiv(safeMul(amount, 4), 10); //40%\r\n    }\r\n    else if (step == 1 && now > releaseTime2) {\r\n    \tunlockAmount = safeDiv(safeMul(amount, 4), 10); //40%\r\n    }\r\n    else if (step == 2 && now > releaseTime3) {\r\n    \tunlockAmount = token.balanceOf(address(this));\r\n    }\r\n    // Make sure there is new tokens to release, otherwise don't advance step\r\n    require(unlockAmount != 0);\r\n\r\n    // Increase step for next time\r\n    require(token.transfer(beneficiary, unlockAmount));\r\n    step++;\r\n\r\n  }\r\n}\r\n\r\n// File: contracts/UncTokenSale.sol\r\n\r\n// ----------------------------------------------------------------------------\r\n// The UncTokenSale smart contract is used for selling UncToken (UNC).\r\n// It calculates UNC allocation based on the ETH contributed and the sale stage.\r\n// ----------------------------------------------------------------------------\r\ncontract UncTokenSale is SafeMath, Pausable {\r\n\r\n\t// The beneficiary is the address that receives the ETH raised if sale is successful\r\n\taddress public beneficiary;\r\n\r\n\t// Token to be sold\r\n\tUncToken  public token;\r\n\r\n\t// Crowdsale variables set in constructor\r\n\tuint public hardCap;\r\n    uint public highBonusRate = 115;\r\n    uint public lowBonusRate = 110;\r\n\tuint public constant highBonus = 160000000000000000000; // 160 Eth\r\n\tuint public constant minContribution = 4000000000000000000; // 4 Eth\r\n\tuint public constant preMaxContribution = 200000000000000000000; // 200 Eth\r\n\tuint public constant mainMaxContribution = 200000000000000000000; // 200 Eth\r\n\r\n\t// List of addresses that can add KYC verified addresses\r\n\tmapping(address => bool) public isVerifier;\r\n\t// List of addresses that are kycVerified\r\n\tmapping(address => bool) public kycVerified;\r\n\r\n\t// Time periods of sale stages\r\n\tuint public preSaleTime;\r\n\tuint public mainSaleTime;\r\n\tuint public endSaleTime;\r\n\r\n\t// Keeps track of amount raised\r\n\tuint public amountRaised;\r\n\r\n\t// Booleans to track sale state\r\n\tbool public beforeSale = true;\r\n\tbool public preSale = false;\r\n\tbool public mainSale = false;\r\n\tbool public saleEnded = false;\r\n\tbool public hardCapReached = false;\r\n\r\n\t// Mapping of token timelocks\r\n\tmapping(address => address) public timeLocks;\r\n\r\n\t// Ratio of Wei to UNC. LOW HIGH NEED TO BE UPDATED\r\n\tuint public rate = 45000; // $0.01 per UNC\r\n\tuint public constant lowRate = 10000;\r\n\tuint public constant highRate = 1000000;\r\n\r\n\t// Mapping to track contributions\r\n\tmapping(address => uint256) public contributionAmtOf;\r\n\r\n\t// The tokens allocated to an address\r\n\tmapping(address => uint256) public tokenBalanceOf;\r\n\r\n    // A mapping that tracks the tokens allocated to team and advisors\r\n\tmapping(address => uint256) public teamTokenBalanceOf;\r\n\r\n    event HardReached(address _beneficiary, uint _amountRaised);\r\n    event BalanceTransfer(address _to, uint _amount);\r\n    event AddedOffChain(address indexed _beneficiary, uint256 tokensAllocated);\r\n    event RateChanged(uint newRate);\r\n    event VerifiedKYC(address indexed person);\r\n    //other potential events: transfer of tokens to investors,\r\n\r\n    modifier beforeEnd() { require (now < endSaleTime); _; }\r\n    modifier afterEnd() { require (now >= endSaleTime); _; }\r\n    modifier afterStart() { require (now >= preSaleTime); _; }\r\n\r\n    modifier saleActive() { require (!(beforeSale || saleEnded)); _; }\r\n\r\n    modifier verifierOnly() { require(isVerifier[msg.sender]); _; }\r\n\r\n    // Constructor, lay out the structure of the sale\r\n    constructor (\r\n    UncToken  _token,\r\n    address _beneficiary,\r\n    uint _preSaleTime,\r\n    uint _mainSaleTime,\r\n    uint _endSaleTime,\r\n    uint _hardCap\r\n    ) public\r\n    {\r\n    //require(_beneficiary != address(0) && _beneficiary != address(this));\r\n    //require(_endSaleTime > _mainSaleTime && _mainSaleTime > _preSaleTime);\r\n\r\n    // This sets the contract owner as a verifier, then they can add other verifiers\r\n    isVerifier[msg.sender] = true;\r\n\r\n    \ttoken = _token;\r\n    \tbeneficiary = _beneficiary;\r\n    \tpreSaleTime = _preSaleTime;\r\n    \tmainSaleTime = _mainSaleTime;\r\n    \tendSaleTime = _endSaleTime;\r\n    \thardCap = _hardCap;\r\n\r\n    \t//may want to deal with vesting and lockup here\r\n\r\n    }\r\n\r\n\r\n    /* Fallback function is called when Ether is sent to the contract. It can\r\n    *  Only be executed when the crowdsale is not closed, paused, or before the\r\n    *  deadline is reached. The function will update state variables and make\r\n    *  a function call to calculate number of tokens to be allocated to investor\r\n    */\r\n    function () public payable whenNotPaused {\r\n    \t// Contribution amount in wei\r\n    \tuint amount = msg.value;\r\n\r\n    \tuint newTotalContribution = safeAdd(contributionAmtOf[msg.sender], msg.value);\r\n\r\n    \t// amount must be greater than or equal to the minimum contribution amount\r\n    \trequire(amount >= minContribution);\r\n\r\n    \tif (preSale) {\r\n    \t\trequire(newTotalContribution <= preMaxContribution);\r\n    \t}\r\n\r\n    \tif (mainSale) {\r\n    \t\trequire(newTotalContribution <= mainMaxContribution);\r\n    \t}\r\n\r\n    \t// Convert wei to UNC and allocate token amount\r\n    \tallocateTokens(msg.sender, amount);\r\n    }\r\n\r\n\r\n    // Caluclates the number of tokens to allocate to investor and updates balance\r\n    function allocateTokens(address investor, uint _amount) internal {\r\n    \t// Make sure investor has been verified\r\n    \trequire(kycVerified[investor]);\r\n\r\n    \t// Calculate baseline number of tokens\r\n    \tuint numTokens = safeMul(_amount, rate);\r\n\r\n    \t//logic for adjusting the number of tokens they get based on stage and amount\r\n    \tif (preSale) {\r\n    \t\t// greater than 160 Eth\r\n    \t\tif (_amount >= highBonus) {\r\n    \t\t\tnumTokens = safeDiv(safeMul(numTokens, highBonusRate), 100);\r\n    \t\t}\r\n\r\n            else {\r\n                numTokens = safeDiv(safeMul(numTokens, lowBonusRate), 100);\r\n            }\r\n    \t}\r\n    \telse {\r\n    \t\t\tnumTokens = safeDiv(safeMul(numTokens, lowBonusRate), 100);\r\n    \t\t}\r\n\r\n    \t// Check that there are enough tokens left for sale to execute purchase and update balances\r\n    \trequire(token.balanceOf(address(this)) >= numTokens);\r\n    \ttokenBalanceOf[investor] = safeAdd(tokenBalanceOf[investor], numTokens);\r\n\r\n    \t// Crowdsale contract sends investor their tokens\r\n    \ttoken.transfer(investor, numTokens);\r\n\r\n    \t// Update the amount this investor has contributed\r\n    \tcontributionAmtOf[investor] = safeAdd(contributionAmtOf[investor], _amount);\r\n    \tamountRaised = safeAdd(amountRaised, _amount);\r\n\r\n    \t\r\n    }\r\n\r\n    // Function to transfer tokens from this contract to an address\r\n    function tokenTransfer(address recipient, uint numToks) public onlyOwner {\r\n        token.transfer(recipient, numToks);\r\n    }\r\n\r\n    /*\r\n    * Owner can call this function to withdraw funds sent to this contract.\r\n    * The funds will be sent to the beneficiary specified when the\r\n    * crowdsale was created.\r\n    */\r\n    function beneficiaryWithdrawal() external onlyOwner {\r\n    \tuint contractBalance = address(this).balance;\r\n    \t// Send eth in contract to the beneficiary\r\n    \tbeneficiary.transfer(contractBalance);\r\n    \temit BalanceTransfer(beneficiary, contractBalance);\r\n    }\r\n\r\n    \t// The owner can end crowdsale at any time.\r\n    \tfunction terminate() external onlyOwner {\r\n        saleEnded = true;\r\n    }\r\n\r\n    // Allows owner to update the rate (UNC to ETH)\r\n    function setRate(uint _rate) public onlyOwner {\r\n    \trequire(_rate >= lowRate && _rate <= highRate);\r\n    \trate = _rate;\r\n\r\n    \temit RateChanged(rate);\r\n    }\r\n\r\n\r\n    // Checks if there are any tokens left to sell. Updates\r\n    // state variables and triggers event hardReached\r\n    function checkHardReached() internal {\r\n    \tif(!hardCapReached) {\r\n    \t\tif (token.balanceOf(address(this)) == 0) {\r\n    \t\t\thardCapReached = true;\r\n    \t\t\tsaleEnded = true;\r\n    \t\t\temit HardReached(beneficiary, amountRaised);\r\n    \t\t}\r\n    \t}\r\n    }\r\n\r\n    // Starts the preSale stage.\r\n    function startPreSale() public onlyOwner {\r\n    \tbeforeSale = false;\r\n    \tpreSale = true;\r\n    }\r\n\r\n    // Starts the mainSale stage\r\n    function startMainSale() public afterStart onlyOwner {\r\n    \tpreSale = false;\r\n    \tmainSale = true;\r\n    }\r\n\r\n    // Ends the preSale and mainSale stage.\r\n    function endSale() public afterStart onlyOwner {\r\n    \tpreSale = false;\r\n    \tmainSale = false;\r\n    \tsaleEnded = true;\r\n    }\r\n\r\n    /*\r\n    * Function to update the start time of the pre-sale. Checks that the sale\r\n    * has not started and that the new time is valid\r\n    */\r\n    function updatePreSaleTime(uint newTime) public onlyOwner {\r\n    \trequire(beforeSale == true);\r\n    \trequire(now < preSaleTime);\r\n    \trequire(now < newTime);\r\n\r\n    \tpreSaleTime = newTime;\r\n    }\r\n\r\n    /*\r\n    * Function to update the start time of the main-sale. Checks that the main\r\n    * sale has not started and that the new time is valid\r\n    */\r\n    function updateMainSaleTime(uint newTime) public onlyOwner {\r\n    \trequire(mainSale != true);\r\n    \trequire(now < mainSaleTime);\r\n    \trequire(now < newTime);\r\n\r\n    \tmainSaleTime = newTime;\r\n    }\r\n\r\n    /*\r\n    * Function to update the end of the sale. Checks that the main\r\n    * sale has not ended and that the new time is valid\r\n    */\r\n    function updateEndSaleTime(uint newTime) public onlyOwner {\r\n    \trequire(saleEnded != true);\r\n    \trequire(now < endSaleTime);\r\n    \trequire(now < newTime);\r\n\r\n    \tendSaleTime = newTime;\r\n    }\r\n\r\n    // Function to burn all unsold tokens after sale has ended\r\n    function burnUnsoldTokens() public afterEnd onlyOwner {\r\n    \t// All unsold tokens that are held by this contract get burned\r\n    \tuint256 tokensToBurn = token.balanceOf(address(this));\r\n    \ttoken.burn(tokensToBurn);\r\n    }\r\n\r\n    // Adds an address to the list of verifiers\r\n    function addVerifier (address _address) public onlyOwner {\r\n        isVerifier[_address] = true;\r\n    }\r\n\r\n    // Removes an address from the list of verifiers\r\n    function removeVerifier (address _address) public onlyOwner {\r\n        isVerifier[_address] = false;\r\n    }\r\n\r\n    // Function to update an addresses KYC verification status\r\n    function verifyKYC(address[] participants) public verifierOnly {\r\n    \trequire(participants.length > 0);\r\n\r\n    \t// KYC verify all addresses in array participants\r\n    \tfor (uint256 i = 0; i < participants.length; i++) {\r\n    \t\tkycVerified[participants[i]] = true;\r\n    \t\temit VerifiedKYC(participants[i]);\r\n    \t}\r\n    }\r\n\r\n    // Function to update the start time of a particular timeLock\r\n    function moveReleaseTime(address person, uint256 newTime) public onlyOwner {\r\n    \trequire(timeLocks[person] != 0x0);\r\n    \trequire(now < newTime);\r\n\r\n    \t// Get the timeLock instance for this person\r\n    \tTimeLock lock = TimeLock(timeLocks[person]);\r\n\r\n    \tlock.updateReleaseTime(newTime);\r\n    }\r\n\r\n    // Release unlocked tokens\r\n    function releaseLock(address person) public {\r\n    \trequire(timeLocks[person] != 0x0);\r\n\r\n    \t// Get the timeLock instance for this person\r\n    \tTimeLock lock = TimeLock(timeLocks[person]);\r\n\r\n    \t// Release the vested tokens for this person\r\n    \tlock.release();\r\n    }\r\n\r\n    // Adds an address for commitments made off-chain\r\n    function offChainTrans(address participant, uint256 tokensAllocated, uint256 contributionAmt, bool isFounder) public onlyOwner {\r\n    \tuint256 startTime;\r\n\r\n        // Store tokensAllocated in a variable\r\n    \tuint256 tokens = tokensAllocated;\r\n    \t// Check that there are enough tokens to allocate to participant\r\n    \trequire(token.balanceOf(address(this)) >= tokens);\r\n\r\n    \t// Update how much this participant has contributed\r\n    \tcontributionAmtOf[participant] = safeAdd(contributionAmtOf[participant], contributionAmt);\r\n\r\n    \t// increase tokenBalanceOf by tokensAllocated for this person\r\n    \ttokenBalanceOf[participant] = safeAdd(tokenBalanceOf[participant], tokens);\r\n\r\n    \t// Set the start date for their vesting. Founders: June 1, 2019. Everyone else: Aug 3, 2018\r\n    \tif (isFounder) {\r\n            // June 1, 2019\r\n            startTime = 1559347200;\r\n        }\r\n        else {\r\n            // October 30th, 2018\r\n            startTime = 1540886400;\r\n        }\r\n\r\n    \t// declare an object of type timeLock\r\n    \tTimeLock lock;\r\n\r\n    \t// Create or update timelock for this participant\r\n    \tif (timeLocks[participant] == 0x0) {\r\n    \t\tlock = new TimeLock(token, participant, startTime);\r\n    \t\ttimeLocks[participant] = address(lock);\r\n    \t} else {\r\n    \t\tlock = TimeLock(timeLocks[participant]);\r\n    \t}\r\n\r\n    \t// Transfer tokens to the time lock and set its initial balance\r\n    \ttoken.transfer(lock, tokens);\r\n    \tlock.setInitialBalance();\r\n\r\n    \t//Make event for private investor and invoke it here\r\n    \temit AddedOffChain(participant, tokensAllocated);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributionAmtOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowBonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"updateEndSaleTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isVerifier\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"beneficiaryWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"tokensAllocated\",\"type\":\"uint256\"},{\"name\":\"contributionAmt\",\"type\":\"uint256\"},{\"name\":\"isFounder\",\"type\":\"bool\"}],\"name\":\"offChainTrans\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preMaxContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highBonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"updateMainSaleTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"person\",\"type\":\"address\"},{\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"moveReleaseTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPreSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startMainSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endSaleTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beforeSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"numToks\",\"type\":\"uint256\"}],\"name\":\"tokenTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"participants\",\"type\":\"address[]\"}],\"name\":\"verifyKYC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"timeLocks\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"updatePreSaleTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addVerifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnUnsoldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"kycVerified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainMaxContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeVerifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"person\",\"type\":\"address\"}],\"name\":\"releaseLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainSaleTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamTokenBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_preSaleTime\",\"type\":\"uint256\"},{\"name\":\"_mainSaleTime\",\"type\":\"uint256\"},{\"name\":\"_endSaleTime\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountRaised\",\"type\":\"uint256\"}],\"name\":\"HardReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BalanceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensAllocated\",\"type\":\"uint256\"}],\"name\":\"AddedOffChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"RateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"person\",\"type\":\"address\"}],\"name\":\"VerifiedKYC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UncTokenSale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006d835879a256978755b8f3a3ec2c76c5188404f50000000000000000000000001e15892eb4ee41874ad7e8a771586a80dee5fd4d000000000000000000000000000000000000000000000000000000005b5102d8000000000000000000000000000000000000000000000000000000005ba9eb00000000000000000000000000000000000000000000000000000000005bb32580000000000000000000000000000000000000000006c9144c1c690d4cb4000000","Library":"","SwarmSource":"bzzr://d64c64edfdcd86f7b325d4206b791ec4d94f6caaaf9334fef9ffada1df2b9c8a"}]}