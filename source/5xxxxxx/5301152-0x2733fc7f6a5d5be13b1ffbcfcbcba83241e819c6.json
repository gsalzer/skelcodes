{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract DigixConstants {\r\n  /// general constants\r\n  uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\r\n\r\n  /// asset events\r\n  uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\r\n  uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\r\n  uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\r\n  uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\r\n  uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\r\n  uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\r\n  uint256 constant ASSET_EVENT_MINTED = 7;\r\n  uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\r\n  uint256 constant ASSET_EVENT_RECASTED = 9;\r\n  uint256 constant ASSET_EVENT_REDEEMED = 10;\r\n  uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\r\n  uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\r\n  uint256 constant ASSET_EVENT_REMINTED = 13;\r\n\r\n  /// roles\r\n  uint256 constant ROLE_ZERO_ANYONE = 0;\r\n  uint256 constant ROLE_ROOT = 1;\r\n  uint256 constant ROLE_VENDOR = 2;\r\n  uint256 constant ROLE_XFERAUTH = 3;\r\n  uint256 constant ROLE_POPADMIN = 4;\r\n  uint256 constant ROLE_CUSTODIAN = 5;\r\n  uint256 constant ROLE_AUDITOR = 6;\r\n  uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\r\n  uint256 constant ROLE_KYC_ADMIN = 8;\r\n  uint256 constant ROLE_FEES_ADMIN = 9;\r\n  uint256 constant ROLE_DOCS_UPLOADER = 10;\r\n  uint256 constant ROLE_KYC_RECASTER = 11;\r\n  uint256 constant ROLE_FEES_DISTRIBUTION_ADMIN = 12;\r\n\r\n  /// states\r\n  uint256 constant STATE_ZERO_UNDEFINED = 0;\r\n  uint256 constant STATE_CREATED = 1;\r\n  uint256 constant STATE_VENDOR_ORDER = 2;\r\n  uint256 constant STATE_TRANSFER = 3;\r\n  uint256 constant STATE_CUSTODIAN_DELIVERY = 4;\r\n  uint256 constant STATE_MINTED = 5;\r\n  uint256 constant STATE_AUDIT_FAILURE = 6;\r\n  uint256 constant STATE_REPLACEMENT_ORDER = 7;\r\n  uint256 constant STATE_REPLACEMENT_DELIVERY = 8;\r\n  uint256 constant STATE_RECASTED = 9;\r\n  uint256 constant STATE_REDEEMED = 10;\r\n  uint256 constant STATE_ADMIN_FAILURE = 11;\r\n\r\n  /// interactive contracts\r\n  bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER = \"i:asset:explorer\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_DIGIX_DIRECTORY = \"i:directory\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE = \"i:mp\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN = \"i:mpadmin\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_POPADMIN = \"i:popadmin\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_PRODUCTS_LIST = \"i:products\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_TOKEN = \"i:token\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_BULK_WRAPPER = \"i:bulk-wrapper\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_TOKEN_CONFIG = \"i:token:config\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_TOKEN_INFORMATION = \"i:token:information\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION = \"i:mp:information\";\r\n  bytes32 constant CONTRACT_INTERACTIVE_IDENTITY = \"i:identity\";\r\n\r\n  /// controller contracts\r\n  bytes32 constant CONTRACT_CONTROLLER_ASSETS = \"c:asset\";\r\n  bytes32 constant CONTRACT_CONTROLLER_ASSETS_RECAST = \"c:asset:recast\";\r\n  bytes32 constant CONTRACT_CONTROLLER_ASSETS_EXPLORER = \"c:explorer\";\r\n  bytes32 constant CONTRACT_CONTROLLER_DIGIX_DIRECTORY = \"c:directory\";\r\n  bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE = \"c:mp\";\r\n  bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN = \"c:mpadmin\";\r\n  bytes32 constant CONTRACT_CONTROLLER_PRODUCTS_LIST = \"c:products\";\r\n\r\n  bytes32 constant CONTRACT_CONTROLLER_TOKEN_APPROVAL = \"c:token:approval\";\r\n  bytes32 constant CONTRACT_CONTROLLER_TOKEN_CONFIG = \"c:token:config\";\r\n  bytes32 constant CONTRACT_CONTROLLER_TOKEN_INFO = \"c:token:info\";\r\n  bytes32 constant CONTRACT_CONTROLLER_TOKEN_TRANSFER = \"c:token:transfer\";\r\n\r\n  bytes32 constant CONTRACT_CONTROLLER_JOB_ID = \"c:jobid\";\r\n  bytes32 constant CONTRACT_CONTROLLER_IDENTITY = \"c:identity\";\r\n\r\n  /// storage contracts\r\n  bytes32 constant CONTRACT_STORAGE_ASSETS = \"s:asset\";\r\n  bytes32 constant CONTRACT_STORAGE_ASSET_EVENTS = \"s:asset:events\";\r\n  bytes32 constant CONTRACT_STORAGE_DIGIX_DIRECTORY = \"s:directory\";\r\n  bytes32 constant CONTRACT_STORAGE_MARKETPLACE = \"s:mp\";\r\n  bytes32 constant CONTRACT_STORAGE_PRODUCTS_LIST = \"s:products\";\r\n  bytes32 constant CONTRACT_STORAGE_GOLD_TOKEN = \"s:goldtoken\";\r\n  bytes32 constant CONTRACT_STORAGE_JOB_ID = \"s:jobid\";\r\n  bytes32 constant CONTRACT_STORAGE_IDENTITY = \"s:identity\";\r\n\r\n  /// service contracts\r\n  bytes32 constant CONTRACT_SERVICE_TOKEN_DEMURRAGE = \"sv:tdemurrage\";\r\n  bytes32 constant CONTRACT_SERVICE_MARKETPLACE = \"sv:mp\";\r\n  bytes32 constant CONTRACT_SERVICE_DIRECTORY = \"sv:directory\";\r\n\r\n  /// fees distributors\r\n  bytes32 constant CONTRACT_DEMURRAGE_FEES_DISTRIBUTOR = \"fees:distributor:demurrage\";\r\n  bytes32 constant CONTRACT_RECAST_FEES_DISTRIBUTOR = \"fees:distributor:recast\";\r\n  bytes32 constant CONTRACT_TRANSFER_FEES_DISTRIBUTOR = \"fees:distributor:transfer\";\r\n}\r\n\r\ncontract ContractResolver {\r\n  address public owner;\r\n  bool public locked;\r\n  function init_register_contract(bytes32 _key, address _contract_address) public returns (bool _success);\r\n  function unregister_contract(bytes32 _key) public returns (bool _success);\r\n  function get_contract(bytes32 _key) public constant returns (address _contract);\r\n}\r\n\r\ncontract ResolverClient {\r\n\r\n  /// The address of the resolver contract for this project\r\n  address public resolver;\r\n  /// The key to identify this contract\r\n  bytes32 public key;\r\n\r\n  /// Make our own address available to us as a constant\r\n  address public CONTRACT_ADDRESS;\r\n\r\n  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\r\n  /// @param _contract The resolver key\r\n  modifier if_sender_is(bytes32 _contract) {\r\n    require(msg.sender == ContractResolver(resolver).get_contract(_contract));\r\n    _;\r\n  }\r\n\r\n  /// Function modifier to check resolver's locking status.\r\n  modifier unless_resolver_is_locked() {\r\n    require(is_locked() == false);\r\n    _;\r\n  }\r\n\r\n  /// @dev Initialize new contract\r\n  /// @param _key the resolver key for this contract\r\n  /// @return _success if the initialization is successful\r\n  function init(bytes32 _key, address _resolver)\r\n           internal\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(_resolver).locked();\r\n    if (_is_locked == false) {\r\n      CONTRACT_ADDRESS = address(this);\r\n      resolver = _resolver;\r\n      key = _key;\r\n      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\r\n      _success = true;\r\n    }  else {\r\n      _success = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Destroy the contract and unregister self from the ContractResolver\r\n  /// @dev Can only be called by the owner of ContractResolver\r\n  function destroy()\r\n           public\r\n           returns (bool _success)\r\n  {\r\n    bool _is_locked = ContractResolver(resolver).locked();\r\n    require(!_is_locked);\r\n\r\n    address _owner_of_contract_resolver = ContractResolver(resolver).owner();\r\n    require(msg.sender == _owner_of_contract_resolver);\r\n\r\n    _success = ContractResolver(resolver).unregister_contract(key);\r\n    require(_success);\r\n\r\n    selfdestruct(_owner_of_contract_resolver);\r\n  }\r\n\r\n  /// @dev Check if resolver is locked\r\n  /// @return _locked if the resolver is currently locked\r\n  function is_locked()\r\n           private\r\n           constant\r\n           returns (bool _locked)\r\n  {\r\n    _locked = ContractResolver(resolver).locked();\r\n  }\r\n\r\n  /// @dev Get the address of a contract\r\n  /// @param _key the resolver key to look up\r\n  /// @return _contract the address of the contract\r\n  function get_contract(bytes32 _key)\r\n           public\r\n           constant\r\n           returns (address _contract)\r\n  {\r\n    _contract = ContractResolver(resolver).get_contract(_key);\r\n  }\r\n}\r\n\r\n/// @title Some useful constants\r\n/// @author Digix Holdings Pte Ltd\r\ncontract Constants {\r\n  address constant NULL_ADDRESS = address(0x0);\r\n  uint256 constant ZERO = uint256(0);\r\n  bytes32 constant EMPTY = bytes32(0x0);\r\n}\r\n\r\n/// @title Condition based access control\r\n/// @author Digix Holdings Pte Ltd\r\ncontract ACConditions is Constants {\r\n\r\n  modifier not_null_address(address _item) {\r\n    require(_item != NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier if_null_address(address _item) {\r\n    require(_item == NULL_ADDRESS);\r\n    _;\r\n  }\r\n\r\n  modifier not_null_uint(uint256 _item) {\r\n    require(_item != ZERO);\r\n    _;\r\n  }\r\n\r\n  modifier if_null_uint(uint256 _item) {\r\n    require(_item == ZERO);\r\n    _;\r\n  }\r\n\r\n  modifier not_empty_bytes(bytes32 _item) {\r\n    require(_item != EMPTY);\r\n    _;\r\n  }\r\n\r\n  modifier if_empty_bytes(bytes32 _item) {\r\n    require(_item == EMPTY);\r\n    _;\r\n  }\r\n\r\n  modifier not_null_string(string _item) {\r\n    bytes memory _i = bytes(_item);\r\n    require(_i.length > 0);\r\n    _;\r\n  }\r\n\r\n  modifier if_null_string(string _item) {\r\n    bytes memory _i = bytes(_item);\r\n    require(_i.length == 0);\r\n    _;\r\n  }\r\n\r\n  modifier require_gas(uint256 _requiredgas) {\r\n    require(msg.gas  >= (_requiredgas - 22000));\r\n    _;\r\n  }\r\n\r\n  function is_contract(address _contract)\r\n           public\r\n           constant\r\n           returns (bool _is_contract)\r\n  {\r\n    uint32 _code_length;\r\n\r\n    assembly {\r\n      _code_length := extcodesize(_contract)\r\n    }\r\n\r\n    if(_code_length > 1) {\r\n      _is_contract = true;\r\n    } else {\r\n      _is_contract = false;\r\n    }\r\n  }\r\n\r\n  modifier if_contract(address _contract) {\r\n    require(is_contract(_contract) == true);\r\n    _;\r\n  }\r\n\r\n  modifier unless_contract(address _contract) {\r\n    require(is_contract(_contract) == false);\r\n    _;\r\n  }\r\n}\r\n\r\ncontract IdentityStorage {\r\n  function read_user(address _user) public constant returns (uint256 _id_expiration, bytes32 _doc);\r\n}\r\n\r\ncontract MarketplaceStorage {\r\n  function read_user(address _user) public constant returns (uint256 _daily_dgx_limit, uint256 _total_purchased_today);\r\n  function read_user_daily_limit(address _user) public constant returns (uint256 _daily_dgx_limit);\r\n  function read_config() public constant returns (uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector);\r\n  function read_dgx_inventory_balance_ng() public constant returns (uint256 _balance);\r\n  function read_total_number_of_purchases() public constant returns (uint256 _total_number_of_purchases);\r\n  function read_total_number_of_user_purchases(address _user) public constant returns (uint256 _total_number_of_user_purchases);\r\n  function read_purchase_at_index(uint256 _index) public constant returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price);\r\n  function read_user_purchase_at_index(address _user, uint256 _index) public constant returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price);\r\n  function read_total_global_purchased_today() public constant returns (uint256 _total_global_purchased_today);\r\n  function read_total_purchased_today(address _user) public constant returns (uint256 _total_purchased_today);\r\n  function read_max_dgx_available_daily() public constant returns (uint256 _max_dgx_available_daily);\r\n  function read_price_floor() public constant returns (uint256 _price_floor_wei_per_dgx_mg);\r\n}\r\n\r\ncontract MarketplaceControllerCommon {\r\n}\r\n\r\ncontract MarketplaceController {\r\n}\r\n\r\ncontract MarketplaceAdminController {\r\n}\r\n\r\ncontract MarketplaceCommon is ResolverClient, ACConditions, DigixConstants {\r\n\r\n  function marketplace_admin_controller()\r\n           internal\r\n           constant\r\n           returns (MarketplaceAdminController _contract)\r\n  {\r\n    _contract = MarketplaceAdminController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN));\r\n  }\r\n\r\n  function marketplace_storage()\r\n           internal\r\n           constant\r\n           returns (MarketplaceStorage _contract)\r\n  {\r\n    _contract = MarketplaceStorage(get_contract(CONTRACT_STORAGE_MARKETPLACE));\r\n  }\r\n\r\n  function marketplace_controller()\r\n           internal\r\n           constant\r\n           returns (MarketplaceController _contract)\r\n  {\r\n    _contract = MarketplaceController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE));\r\n  }\r\n}\r\n\r\n/// @title Digix Marketplace Information\r\n/// @author Digix Holdings Pte Ltd\r\n/// @notice This contract is used to read the configuration of the Digix's Marketplace\r\ncontract MarketplaceInformation is MarketplaceCommon {\r\n\r\n  function MarketplaceInformation(address _resolver) public\r\n  {\r\n    require(init(CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION, _resolver));\r\n  }\r\n\r\n  function identity_storage()\r\n           internal\r\n           constant\r\n           returns (IdentityStorage _contract)\r\n  {\r\n    _contract = IdentityStorage(get_contract(CONTRACT_STORAGE_IDENTITY));\r\n  }\r\n\r\n  /// @dev show user's current marketplace information and configuration, as well as some global configurations\r\n  /// @param _user the user's ethereum address\r\n  /// @return {\r\n  ///   \"_user_daily_dgx_limit\": \"the amount of DGX that the user can purchase at any given day\",\r\n  ///   \"_user_id_expiration\": \"if KYC approved this will be a non-zero value as Unix timestamp when the submitted ID will expire\",\r\n  ///   \"_user_total_purchased_today\": \"The amount of tokens that the user has purchased in the last 24 hours\",\r\n  ///   \"_config_maximum_block_drift\": \"The number of ethereum blocks for which a pricefeed is valid for\"\r\n  ///   \"_config_minimum_purchase_dgx_ng\": \"The minimum amount of DGX that has to be purchased in one order\",\r\n  ///   \"_config_payment_collector\": \"Ethereum address of the collector which collects marketplace ether sent by buyers to buy DGX\"\r\n  /// }\r\n  function getUserInfoAndConfig(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _user_daily_dgx_limit, uint256 _user_id_expiration, uint256 _user_total_purchased_today,\r\n                    uint256 _config_global_daily_dgx_ng_limit, uint256 _config_maximum_block_drift,\r\n                    uint256 _config_minimum_purchase_dgx_ng, address _config_payment_collector)\r\n  {\r\n    (_user_daily_dgx_limit, _user_total_purchased_today) =\r\n      marketplace_storage().read_user(_user);\r\n\r\n    (_user_id_expiration,) = identity_storage().read_user(_user);\r\n\r\n    (_config_global_daily_dgx_ng_limit, _config_minimum_purchase_dgx_ng, _config_maximum_block_drift, _config_payment_collector) =\r\n      marketplace_storage().read_config();\r\n  }\r\n\r\n  /// @dev get global marketplace configuration\r\n  /// @return {\r\n  ///     \"_global_daily_dgx_ng_limit,\": \"the default max amount of DGX in nanograms the user can purchase daily\",\r\n  ///     \"_minimum_purchase_dgx_ng\": \"The minimum DGX nanograms that can be purchased\",\r\n  ///     \"_maximum_block_drift\": \"The number of blocks a pricefeed is valid for\",\r\n  ///     \"_payment_collector\": \"The ETH address where the payment should be sent to\"\r\n  /// }\r\n  function getConfig()\r\n           public\r\n           constant\r\n           returns (uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector)\r\n  {\r\n     (_global_daily_dgx_ng_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector) =\r\n       marketplace_storage().read_config();\r\n  }\r\n\r\n  /// @dev show the user's daily limit on DGX purchase\r\n  /// @param _user the user's ethereum address\r\n  /// @return {\r\n  ///   \"_maximum_purchase_amount_ng\": \"The amount in DGX nanograms that the user can purchase daily\"\r\n  /// }\r\n  function userMaximumPurchaseAmountNg(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _maximum_purchase_amount_ng)\r\n  {\r\n    _maximum_purchase_amount_ng = marketplace_storage().read_user_daily_limit(_user);\r\n  }\r\n\r\n  /// @dev show how many nanograms of DGX is in the Marketplace's inventory\r\n  /// @return {\r\n  ///   \"_available_ng\": \"The amount in DGX nanograms in the inventory\"\r\n  /// }\r\n  function availableDgxNg()\r\n           public\r\n           constant\r\n           returns (uint256 _available_ng)\r\n  {\r\n    _available_ng = marketplace_storage().read_dgx_inventory_balance_ng();\r\n  }\r\n\r\n  /// @dev return the total number of purchases done on marketplace\r\n  /// @return _total_number_of_purchases the total number of purchases on marketplace\r\n  function readTotalNumberOfPurchases()\r\n           public\r\n           constant\r\n           returns (uint256 _total_number_of_purchases)\r\n  {\r\n    _total_number_of_purchases = marketplace_storage().read_total_number_of_purchases();\r\n  }\r\n\r\n  /// @dev read the total number of purchases by a user\r\n  /// @param _user Ethereum address of the user\r\n  /// @return _total_number_of_user_purchases the total number of purchases made by the user on marketplace\r\n  function readTotalNumberOfUserPurchases(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _total_number_of_user_purchases)\r\n  {\r\n    _total_number_of_user_purchases = marketplace_storage().read_total_number_of_user_purchases(_user);\r\n  }\r\n\r\n  /// @dev read the purchase details at an index from all purchases\r\n  /// @param _index the index of the purchase in all purchases (index starts from 0)\r\n  /// @return {\r\n  ///   \"_recipient\": \"DGX was purchases to this Ethereum address\",\r\n  ///   \"_timestamp\": \"the time at which the purchase was made\",\r\n  ///   \"_amount\": \"the amount of DGX nanograms purchased in this purchase\",\r\n  ///   \"_price\": \"the price paid by purchaser in web per dgx milligram\"\r\n  /// }\r\n  function readPurchaseAtIndex(uint256 _index)\r\n           public\r\n           constant\r\n           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\r\n  {\r\n    (_recipient, _timestamp, _amount, _price) = marketplace_storage().read_purchase_at_index(_index);\r\n  }\r\n\r\n  /// @dev read the purchase details by a user at an index from all the user's purchases\r\n  /// @param _index the index of the purchase in all purchases by this user (index starts from 0)\r\n  /// @return {\r\n  ///   \"_recipient\": \"DGX was purchases to this Ethereum address\",\r\n  ///   \"_timestamp\": \"the time at which the purchase was made\",\r\n  ///   \"_amount\": \"the amount of DGX nanograms purchased in this purchase\",\r\n  ///   \"_price\": \"the price paid by purchaser in web per dgx milligram\"\r\n  /// }\r\n  function readUserPurchaseAtIndex(address _user, uint256 _index)\r\n           public\r\n           constant\r\n           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\r\n  {\r\n    (_recipient, _timestamp, _amount, _price) = marketplace_storage().read_user_purchase_at_index(_user, _index);\r\n  }\r\n\r\n  /// @dev read the total amount of DGX purchased today\r\n  /// @return _total_purchased_today the total amount of DGX purchased today at marketplace\r\n  function readGlobalPurchasedToday()\r\n           public\r\n           constant\r\n           returns (uint256 _total_purchased_today)\r\n  {\r\n    _total_purchased_today = marketplace_storage().read_total_global_purchased_today();\r\n  }\r\n\r\n  /// @dev read the amount of DGX purchased today by a user\r\n  /// @param _user Ethereum address of the user\r\n  /// @return _user_total_purchased_today the total amount of DGX purchased today by a user\r\n  function readUserPurchasedToday(address _user)\r\n           public\r\n           constant\r\n           returns (uint256 _user_total_purchased_today)\r\n  {\r\n    _user_total_purchased_today = marketplace_storage().read_total_purchased_today(_user);\r\n  }\r\n\r\n  /// @dev read the marketplace configurations\r\n  /// @return {\r\n  ///   \"_global_default_user_daily_limit,\": \"Default maximum number of DGX nanograms that a user can purchase per day\",\r\n  ///   \"_minimum_purchase_dgx_ng\": \"minimum number of DGX nanograms that has to be purchased in a single purchase\",\r\n  ///   \"_maximum_block_drift\": \"the number of ethereum blocks for which the pricefeed is valid for\",\r\n  ///   \"_payment_collector\": \"the ethereum address that will receive the eth paid for a purchase\",\r\n  ///   \"_max_dgx_available_daily\": \"maximum number of DGX nanograms that are available for purchase on marketplace in a day\",\r\n  ///   \"_price_floor_wei_per_dgx_mg\": \"the price floor, minimum price, below which a purchase is invalid\"\r\n  function readMarketplaceConfigs()\r\n           public\r\n           constant\r\n           returns (uint256 _global_default_user_daily_limit,\r\n                    uint256 _minimum_purchase_dgx_ng,\r\n                    uint256 _maximum_block_drift,\r\n                    address _payment_collector,\r\n                    uint256 _max_dgx_available_daily,\r\n                    uint256 _price_floor_wei_per_dgx_mg)\r\n  {\r\n    (_global_default_user_daily_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector)\r\n      = marketplace_storage().read_config();\r\n    _max_dgx_available_daily = marketplace_storage().read_max_dgx_available_daily();\r\n    _price_floor_wei_per_dgx_mg = marketplace_storage().read_price_floor();\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readMarketplaceConfigs\",\"outputs\":[{\"name\":\"_global_default_user_daily_limit\",\"type\":\"uint256\"},{\"name\":\"_minimum_purchase_dgx_ng\",\"type\":\"uint256\"},{\"name\":\"_maximum_block_drift\",\"type\":\"uint256\"},{\"name\":\"_payment_collector\",\"type\":\"address\"},{\"name\":\"_max_dgx_available_daily\",\"type\":\"uint256\"},{\"name\":\"_price_floor_wei_per_dgx_mg\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableDgxNg\",\"outputs\":[{\"name\":\"_available_ng\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserInfoAndConfig\",\"outputs\":[{\"name\":\"_user_daily_dgx_limit\",\"type\":\"uint256\"},{\"name\":\"_user_id_expiration\",\"type\":\"uint256\"},{\"name\":\"_user_total_purchased_today\",\"type\":\"uint256\"},{\"name\":\"_config_global_daily_dgx_ng_limit\",\"type\":\"uint256\"},{\"name\":\"_config_maximum_block_drift\",\"type\":\"uint256\"},{\"name\":\"_config_minimum_purchase_dgx_ng\",\"type\":\"uint256\"},{\"name\":\"_config_payment_collector\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"key\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"get_contract\",\"outputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"readUserPurchasedToday\",\"outputs\":[{\"name\":\"_user_total_purchased_today\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"is_contract\",\"outputs\":[{\"name\":\"_is_contract\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readGlobalPurchasedToday\",\"outputs\":[{\"name\":\"_total_purchased_today\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"name\":\"_global_daily_dgx_ng_limit\",\"type\":\"uint256\"},{\"name\":\"_minimum_purchase_dgx_ng\",\"type\":\"uint256\"},{\"name\":\"_maximum_block_drift\",\"type\":\"uint256\"},{\"name\":\"_payment_collector\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"readTotalNumberOfUserPurchases\",\"outputs\":[{\"name\":\"_total_number_of_user_purchases\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userMaximumPurchaseAmountNg\",\"outputs\":[{\"name\":\"_maximum_purchase_amount_ng\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readTotalNumberOfPurchases\",\"outputs\":[{\"name\":\"_total_number_of_purchases\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"readPurchaseAtIndex\",\"outputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"readUserPurchaseAtIndex\",\"outputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MarketplaceInformation","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000db2ddb220b8a55e0e4412130e6ae74d136c04ba2","Library":"","SwarmSource":"bzzr://60ad41540801e25dd9ab9c7d78f1559187b75365268d9fcff2a7fe591c046e50"}]}