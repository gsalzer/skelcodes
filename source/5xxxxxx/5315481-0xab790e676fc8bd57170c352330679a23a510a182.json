{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18; // solhint-disable-line\r\n\r\n\r\n\r\ncontract TicTacPotato{\r\n\r\n    /***EVENTS***/\r\n    event StalematePayout(address adr, uint256 amount);\r\n\r\n    address public ceoAddress;\r\n    uint256 public lastBidTime;\r\n    uint256 public contestStartTime;\r\n    uint256 public lastPot;\r\n    \r\n    //mapping (address => uint256) public numTilesOwnedByAddress;\r\n    mapping (uint256 => address) public indexToAddress;\r\n    mapping (address => uint256) public cantBidUntil;\r\n    Tile[] public tiles;\r\n    \r\n    uint256 public TIME_TO_STALEMATE=30 minutes;\r\n    uint256 public NUM_TILES=12;\r\n    uint256 public START_PRICE=0.005 ether;\r\n    uint256 public CONTEST_INTERVAL=15 minutes;\r\n    uint256 public COOLDOWN_TIME=7 minutes;//time you have to wait between buying tiles\r\n    uint[][]  tests = [[0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6]];\r\n    /*** DATATYPES ***/\r\n    struct Tile {\r\n        address owner;\r\n        uint256 price;\r\n    }\r\n    \r\n    /*** CONSTRUCTOR ***/\r\n    function TicTacPotato() public{\r\n        ceoAddress=msg.sender;\r\n        contestStartTime=SafeMath.add(now,1 hours);\r\n        for(uint i = 0; i<NUM_TILES; i++){\r\n            Tile memory newtile=Tile({owner:address(this),price: START_PRICE});\r\n            tiles.push(newtile);\r\n            indexToAddress[i]=address(this);\r\n        }\r\n    }\r\n    \r\n    /*** PUBLIC FUNCTIONS ***/\r\n    function buyTile(uint256 index) public payable{\r\n        require(now>contestStartTime);\r\n        if(_endContestIfNeededStalemate()){ \r\n\r\n        }\r\n        else{\r\n            Tile storage tile=tiles[index];\r\n            require(msg.value >= tile.price);\r\n            require(now >= cantBidUntil[msg.sender]);//ensure timeout has expired\r\n            cantBidUntil[msg.sender]=SafeMath.add(now,COOLDOWN_TIME);\r\n            //allow calling transfer() on these addresses without risking re-entrancy attacks\r\n            require(msg.sender != tile.owner);\r\n            require(msg.sender != ceoAddress);\r\n            uint256 sellingPrice=tile.price;\r\n            uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\r\n            uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 70), 100));\r\n            uint256 devFee= uint256(SafeMath.div(SafeMath.mul(sellingPrice, 4), 100));\r\n            //26 percent remaining in the contract goes to the pot\r\n            //if the owner is the contract, this is the first purchase, and payment should go to the pot\r\n            if(tile.owner!=address(this)){\r\n                tile.owner.transfer(payment);\r\n            }\r\n            ceoAddress.transfer(devFee);\r\n            //numTilesOwnedByAddress[tile.owner]=SafeMath.sub(numTilesOwnedByAddress[tile.owner],1)\r\n            tile.price= SafeMath.div(SafeMath.mul(sellingPrice, 115), 70);\r\n            tile.owner=msg.sender;//transfer ownership\r\n            indexToAddress[index]=msg.sender;\r\n            lastBidTime=block.timestamp;\r\n            if(!_endContestIfNeeded()){//if contest ended through this method, caller will receive entire contract balance anyways.\r\n                msg.sender.transfer(purchaseExcess);//returns excess eth\r\n            }\r\n        }\r\n    }\r\n    function pause() public {\r\n        require(msg.sender==ceoAddress);\r\n        require(now<contestStartTime);\r\n        contestStartTime=SafeMath.add(now,7 days);\r\n    }\r\n    function unpause() public{\r\n        require(msg.sender==ceoAddress);\r\n        require(now<contestStartTime);\r\n        _setNewStartTime();\r\n    }\r\n    function getBalance() public view returns(uint256 value){\r\n        return this.balance;\r\n    }\r\n    function timePassed() public view returns(uint256 time){\r\n        if(lastBidTime==0){\r\n            return 0;\r\n        }\r\n        return SafeMath.sub(block.timestamp,lastBidTime);\r\n    }\r\n    function timeLeftToContestStart() public view returns(uint256 time){\r\n        if(block.timestamp>contestStartTime){\r\n            return 0;\r\n        }\r\n        return SafeMath.sub(contestStartTime,block.timestamp);\r\n    }\r\n    function timeLeftToBid(address addr) public view returns(uint256 time){\r\n        if(now>cantBidUntil[addr]){\r\n            return 0;\r\n        }\r\n        return SafeMath.sub(cantBidUntil[addr],now);\r\n    }\r\n    function timeLeftToCook() public view returns(uint256 time){\r\n        return SafeMath.sub(TIME_TO_STALEMATE,timePassed());\r\n    }\r\n    function contestOver() public view returns(bool){\r\n        return timePassed()>=TIME_TO_STALEMATE;\r\n    }\r\n    function haveIWon() public view returns(bool){\r\n        return checkWinner(msg.sender);\r\n    }\r\n    \r\n     // 0 1 2\r\n    // 3 4 5\r\n    // 6 7 8\r\n    function checkWinner(address a) constant returns (bool){\r\n        for(uint i =0; i < 8;i++){\r\n            uint[] memory b = tests[i];\r\n            if(indexToAddress[b[0]] ==a && indexToAddress[b[1]]==a && indexToAddress[b[2]]==a) return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /*** PRIVATE FUNCTIONS ***/\r\n    \r\n    function _endContestIfNeeded() private returns(bool){\r\n        if(haveIWon()){\r\n            lastPot=this.balance;\r\n            msg.sender.transfer(this.balance);//send winner the pot\r\n            lastBidTime=0;\r\n            _resetTiles();\r\n            _setNewStartTime();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    //for ending the contest in a stalemate\r\n    function _endContestIfNeededStalemate() private returns(bool){\r\n        if(timePassed()>=TIME_TO_STALEMATE){\r\n            //contest over, refund anything paid\r\n            msg.sender.transfer(msg.value);\r\n            lastPot=this.balance;\r\n            _stalemateTransfer();\r\n            lastBidTime=0;\r\n            _resetTiles();\r\n            _setNewStartTime();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    //transfers various amounts to the holders of the stalemate cards\r\n    function _stalemateTransfer() private{\r\n        uint payout=this.balance;\r\n        //pay the pot to holders of the stalemate cards\r\n        for(uint i=9;i<12;i++){\r\n            require(msg.sender != indexToAddress[i]);\r\n            if(indexToAddress[i]!=address(this)){\r\n                uint proportion=(i-8)*15;\r\n                indexToAddress[i].transfer(uint256(SafeMath.div(SafeMath.mul(payout, proportion), 100)));\r\n                emit StalematePayout(indexToAddress[i], uint256(SafeMath.div(SafeMath.mul(payout, proportion), 100)));\r\n            }\r\n        }\r\n    }\r\n    function _resetTiles() private{\r\n        for(uint i = 0; i<NUM_TILES; i++){\r\n            //numTilesOwnedByAddress[tiles[i].owner]=0;\r\n            Tile memory newtile=Tile({owner:address(this),price: START_PRICE});\r\n            tiles[i]=newtile;\r\n            indexToAddress[i]=address(this);\r\n        }\r\n        //numTilesOwnedByAddress[address(this)]=9;\r\n    }\r\n    function _setNewStartTime() private{\r\n            contestStartTime=SafeMath.add(now,CONTEST_INTERVAL);\r\n    }\r\n}\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"timeLeftToBid\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tiles\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"buyTile\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLeftToContestStart\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NUM_TILES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"checkWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBidTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"cantBidUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COOLDOWN_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTEST_INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contestStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLeftToCook\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"haveIWon\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_TO_STALEMATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timePassed\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contestOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StalematePayout\",\"type\":\"event\"}]","ContractName":"TicTacPotato","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7a57447cfdd17ff4357c786ff488e06e2104de16495d48f71a8dc2eb7d16d6e9"}]}