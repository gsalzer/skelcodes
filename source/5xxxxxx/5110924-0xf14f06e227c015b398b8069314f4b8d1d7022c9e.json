{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary ArrayUtils {\r\n\r\n    /**\r\n     * Replace bytes in an array with bytes in another array, guarded by a \"bytemask\"\r\n     * \r\n     * @dev Mask must be 1/8th the size of the byte array. A 1-bit means the byte array can be changed.\r\n     * @param array The original array\r\n     * @param desired The target array\r\n     * @param mask The mask specifying which bytes can be changed\r\n     * @return The updated byte array (the parameter will be modified inplace)\r\n     */\r\n    function guardedArrayReplace(bytes memory array, bytes memory desired, bytes memory mask)\r\n        pure\r\n        internal\r\n    {\r\n        byte[8] memory bitmasks = [byte(2 ** 7), byte(2 ** 6), byte(2 ** 5), byte(2 ** 4), byte(2 ** 3), byte(2 ** 2), byte(2 ** 1), byte(2 ** 0)];\r\n        require(array.length == desired.length);\r\n        require(mask.length >= array.length / 8);\r\n        for (uint i = 0; i < array.length; i++ ) {\r\n            /* 1-bit means value can be changed. */\r\n            bool masked = (mask[i / 8] & bitmasks[i % 8]) == 0;\r\n            if (!masked) {\r\n                array[i] = desired[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if two arrays are equal\r\n     * \r\n     * @dev Arrays must be of equal length, otherwise will return false\r\n     * @param a First array\r\n     * @param b Second array\r\n     * @return Whether or not all bytes in the arrays are equal\r\n     */\r\n    function arrayEq(bytes memory a, bytes memory b)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (a.length != b.length) {\r\n            return false;\r\n        }\r\n        for (uint i = 0; i < a.length; i++) {\r\n            if (a[i] != b[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract ReentrancyGuarded {\r\n\r\n    bool reentrancyLock = false;\r\n\r\n    /* Prevent a contract function from being reentrant-called. */\r\n    modifier reentrancyGuard {\r\n        if (reentrancyLock) {\r\n            revert();\r\n        }\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n}\r\n\r\ncontract TokenRecipient {\r\n    event ReceivedEther(address indexed sender, uint amount);\r\n    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\r\n\r\n    /**\r\n     * @dev Receive tokens and generate a log event\r\n     * @param from Address from which to transfer tokens\r\n     * @param value Amount of tokens to transfer\r\n     * @param token Address of token\r\n     * @param extraData Additional data to log\r\n     */\r\n    function receiveApproval(address from, uint256 value, address token, bytes extraData) public {\r\n        ERC20 t = ERC20(token);\r\n        require(t.transferFrom(from, this, value));\r\n        ReceivedTokens(from, value, token, extraData);\r\n    }\r\n\r\n    /**\r\n     * @dev Receive Ether and generate a log event\r\n     */\r\n    function () payable public {\r\n        ReceivedEther(msg.sender, msg.value);\r\n    }\r\n}\r\n\r\ncontract ExchangeCore is ReentrancyGuarded {\r\n\r\n    /* The token used to pay exchange fees. */\r\n    ERC20 public exchangeToken;\r\n\r\n    /* User registry. */\r\n    ProxyRegistry public registry;\r\n\r\n    /* Cancelled / finalized orders, by hash. */\r\n    mapping(bytes32 => bool) public cancelledOrFinalized;\r\n\r\n    /* Orders verified by on-chain approval (alternative to ECDSA signatures so that smart contracts can place orders directly). */\r\n    mapping(bytes32 => bool) public approvedOrders;\r\n\r\n    /* An ECDSA signature. */ \r\n    struct Sig {\r\n        /* v parameter */\r\n        uint8 v;\r\n        /* r parameter */\r\n        bytes32 r;\r\n        /* s parameter */\r\n        bytes32 s;\r\n    }\r\n\r\n    /* An order on the exchange. */\r\n    struct Order {\r\n        /* Exchange address, intended as a versioning mechanism. */\r\n        address exchange;\r\n        /* Order maker address. */\r\n        address maker;\r\n        /* Order taker address, if specified. */\r\n        address taker;\r\n        /* Maker fee of the order (in Exchange fee tokens), unused for taker order. */\r\n        uint makerFee;\r\n        /* Taker fee of the order (in Exchange fee tokens), or maximum taker fee for a taker order. */\r\n        uint takerFee;\r\n        /* Order fee recipient or zero address for taker order. */\r\n        address feeRecipient;\r\n        /* Side (buy/sell). */\r\n        SaleKindInterface.Side side;\r\n        /* Kind of sale. */\r\n        SaleKindInterface.SaleKind saleKind;\r\n        /* Target. */\r\n        address target;\r\n        /* HowToCall. */\r\n        AuthenticatedProxy.HowToCall howToCall;\r\n        /* Calldata. */\r\n        bytes calldata;\r\n        /* Calldata replacement pattern. */\r\n        bytes replacementPattern;\r\n        /* Static call target, zero-address for no static call. */\r\n        address staticTarget;\r\n        /* Static call extra data. */\r\n        bytes staticExtradata;\r\n        /* Token used to pay for the order. */\r\n        ERC20 paymentToken;\r\n        /* Base price of the order (in paymentTokens). */\r\n        uint basePrice;\r\n        /* Auction extra parameter - minimum bid increment for English auctions, starting/ending price difference. */\r\n        uint extra;\r\n        /* Listing timestamp. */\r\n        uint listingTime;\r\n        /* Expiration timestamp - 0 for no expiry. */\r\n        uint expirationTime;\r\n        /* Order salt, used to prevent duplicate hashes. */\r\n        uint salt;\r\n    }\r\n    \r\n    event OrderApprovedPartOne    (bytes32 indexed hash, address exchange, address indexed maker, address taker, uint makerFee, uint takerFee, address indexed feeRecipient, SaleKindInterface.Side side, SaleKindInterface.SaleKind saleKind, address target, AuthenticatedProxy.HowToCall howToCall, bytes calldata);\r\n    event OrderApprovedPartTwo    (bytes32 indexed hash, bytes replacementPattern, address staticTarget, bytes staticExtradata, ERC20 paymentToken, uint basePrice, uint extra, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired);\r\n    event OrderCancelled          (bytes32 indexed hash);\r\n    event OrdersMatched           (bytes32 buyHash, bytes32 sellHash, address indexed maker, address indexed taker, uint price, bytes32 indexed metadata);\r\n\r\n    /**\r\n     * @dev Charge an address fees in protocol tokens\r\n     * @param from Address to charge fees\r\n     * @param to Address to receive fees\r\n     * @param amount Amount of protocol tokens to charge\r\n     */\r\n    function chargeFee(address from, address to, uint amount)\r\n        internal\r\n    {\r\n        if (amount > 0) {\r\n            require(exchangeToken.transferFrom(from, to, amount));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Execute a STATICCALL (introduced with Ethereum Metropolis, non-state-modifying external call)\r\n     * @param target Contract to call\r\n     * @param calldata Calldata (appended to extradata)\r\n     * @param extradata Base data for STATICCALL (probably function selector and argument encoding)\r\n     * @return The result of the call (success or failure)\r\n     */\r\n    function staticCall(address target, bytes memory calldata, bytes memory extradata)\r\n        public\r\n        view\r\n        returns (bool result)\r\n    {\r\n        bytes memory combined = new bytes(SafeMath.add(calldata.length, extradata.length));\r\n        for (uint i = 0; i < extradata.length; i++) {\r\n            combined[i] = extradata[i];\r\n        }\r\n        for (uint j = 0; j < calldata.length; j++) {\r\n            combined[j + extradata.length] = calldata[j];\r\n        }\r\n        assembly {\r\n            result := staticcall(gas, target, add(combined, 0x20), mload(combined), mload(0x40), 0)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Keccak256 order hash, part one\r\n     * @param order Order to hash\r\n     * @return Part one of the order hash \r\n     */\r\n    function hashOrderPartOne(Order memory order)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(order.exchange, order.maker, order.taker, order.makerFee, order.takerFee, order.feeRecipient, order.side, order.saleKind, order.target, order.howToCall, order.calldata, order.replacementPattern);\r\n    }\r\n\r\n    /**\r\n     * @dev Keccak256 order hash, part two\r\n     * @param order Order to hash\r\n     * @return Part two of the order hash\r\n     */\r\n    function hashOrderPartTwo(Order memory order)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(order.staticTarget, order.staticExtradata, order.paymentToken, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt);\r\n    }\r\n\r\n    /**\r\n     * @dev Hash an order, returning the hash that a client must sign, including the standard message prefix\r\n     * @param order Order to hash\r\n     * @return Hash of message prefix, order hash part one, and order hash part two concatenated\r\n     */\r\n    function hashToSign(Order memory order)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 hash = keccak256(prefix, hashOrderPartOne(order), hashOrderPartTwo(order));\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * @dev Assert an order is valid and return its hash\r\n     * @param order Order to validate\r\n     * @param sig ECDSA signature\r\n     */\r\n    function requireValidOrder(Order memory order, Sig memory sig)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        bytes32 hash = hashToSign(order);\r\n        require(validateOrder(hash, order, sig));\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * @dev Validate a provided order, hash, and signature\r\n     * @param hash Order hash (already calculated, passed to avoid recalculation)\r\n     * @param order Order to validate\r\n     * @param sig ECDSA signature\r\n     */\r\n    function validateOrder(bytes32 hash, Order memory order, Sig memory sig) \r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        /* Not done in an if-conditional to prevent unnecessary ecrecover evaluation, which seems to happen even though it should short-circuit. */\r\n\r\n        /* Order must be targeted at this protocol version (this Exchange contract). */\r\n        if (order.exchange != address(this)) {\r\n            return false;\r\n        }\r\n\r\n        /* Order must have not been canceled or already filled. */\r\n        if (cancelledOrFinalized[hash]) {\r\n            return false;\r\n        }\r\n        \r\n        /* Order must possess valid sale kind parameter combination. */\r\n        if (!SaleKindInterface.validateParameters(order.saleKind, order.expirationTime)) {\r\n            return false;\r\n        }\r\n\r\n        /* Order authentication. Order must be either:\r\n           (a) sent by maker */\r\n        if (msg.sender == order.maker) {\r\n            return true;\r\n        }\r\n  \r\n        /* (b) previously approved */\r\n        if (approvedOrders[hash]) {\r\n            return true;\r\n        }\r\n\r\n        /* or (c) ECDSA-signed by maker. */\r\n        if (ecrecover(hash, sig.v, sig.r, sig.s) == order.maker) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve an order and optionally mark it for orderbook inclusion. Must be called by the maker of the order\r\n     * @param order Order to approve\r\n     * @param orderbookInclusionDesired Whether orderbook providers should include the order in their orderbooks\r\n     */\r\n    function approveOrder(Order memory order, bool orderbookInclusionDesired)\r\n        internal\r\n    {\r\n        /* CHECKS */\r\n\r\n        /* Assert sender is authorized to approve order. */\r\n        require(msg.sender == order.maker);\r\n\r\n        /* Calculate order hash. */\r\n        bytes32 hash = hashToSign(order);\r\n\r\n        /* Assert order has not already been approved. */\r\n        require(!approvedOrders[hash]);\r\n\r\n        /* EFFECTS */\r\n    \r\n        /* Mark order as approved. */\r\n        approvedOrders[hash] = true;\r\n  \r\n        /* Log approval event. Must be split in two due to Solidity stack size limitations. */\r\n        {\r\n            OrderApprovedPartOne(hash, order.exchange, order.maker, order.taker, order.makerFee, order.takerFee, order.feeRecipient, order.side, order.saleKind, order.target, order.howToCall, order.calldata);\r\n        }\r\n        {   \r\n            OrderApprovedPartTwo(hash, order.replacementPattern, order.staticTarget, order.staticExtradata, order.paymentToken, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt, orderbookInclusionDesired);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel an order, preventing it from being matched. Must be called by the maker of the order\r\n     * @param order Order to cancel\r\n     * @param sig ECDSA signature\r\n     */\r\n    function cancelOrder(Order memory order, Sig memory sig) \r\n        internal\r\n    {\r\n        /* CHECKS */\r\n\r\n        /* Calculate order hash. */\r\n        bytes32 hash = requireValidOrder(order, sig);\r\n\r\n        /* Assert sender is authorized to cancel order. */\r\n        require(msg.sender == order.maker);\r\n  \r\n        /* EFFECTS */\r\n      \r\n        /* Mark order as cancelled, preventing it from being matched. */\r\n        cancelledOrFinalized[hash] = true;\r\n\r\n        /* Log cancel event. */\r\n        OrderCancelled(hash);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the current price of an order (convenience function)\r\n     * @param order Order to calculate the price of\r\n     * @return The current price of the order\r\n     */\r\n    function calculateCurrentPrice (Order memory order)\r\n        internal  \r\n        view\r\n        returns (uint)\r\n    {\r\n        return SaleKindInterface.calculateFinalPrice(order.side, order.saleKind, order.basePrice, order.extra, order.listingTime, order.expirationTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the price two orders would match at, if in fact they would match (otherwise fail)\r\n     * @param buy Buy-side order\r\n     * @param sell Sell-side order\r\n     * @return Match price\r\n     */\r\n    function calculateMatchPrice(Order memory buy, Order memory sell)\r\n        view\r\n        internal\r\n        returns (uint)\r\n    {\r\n        /* Calculate sell price. */\r\n        uint sellPrice = SaleKindInterface.calculateFinalPrice(sell.side, sell.saleKind, sell.basePrice, sell.extra, sell.listingTime, sell.expirationTime);\r\n\r\n        /* Calculate buy price. */\r\n        uint buyPrice = SaleKindInterface.calculateFinalPrice(buy.side, buy.saleKind, buy.basePrice, buy.extra, buy.listingTime, buy.expirationTime);\r\n\r\n        /* Require price cross. */\r\n        require(buyPrice >= sellPrice);\r\n        \r\n        /* Maker/taker priority. */\r\n        return sell.feeRecipient != address(0) ? sellPrice : buyPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Execute all ERC20 token transfers associated with an order match (fees and buyer => seller transfer)\r\n     * @param buy Buy-side order\r\n     * @param sell Sell-side order\r\n     */\r\n    function executeFundsTransfer(Order memory buy, Order memory sell)\r\n        internal\r\n        returns (uint)\r\n    {\r\n        /* Calculate match price. */\r\n        uint price = calculateMatchPrice(buy, sell);\r\n\r\n        /* Determine maker/taker and charge fees accordingly. */\r\n        if (sell.feeRecipient != address(0)) {\r\n            /* Sell-side order is maker. */\r\n      \r\n            /* Assert taker fee is less than or equal to maximum fee specified by buyer. */\r\n            require(sell.takerFee <= buy.takerFee);\r\n            \r\n            /* Charge maker fee to seller. */\r\n            chargeFee(sell.maker, sell.feeRecipient, sell.makerFee);\r\n\r\n            /* Charge taker fee to buyer. */\r\n            chargeFee(buy.maker, sell.feeRecipient, sell.takerFee);\r\n        } else {\r\n            /* Buy-side order is maker. */\r\n\r\n            /* Assert taker fee is less than or equal to maximum fee specified by seller. */\r\n            require(buy.takerFee <= sell.takerFee);\r\n\r\n            /* Charge maker fee to buyer. */\r\n            chargeFee(buy.maker, buy.feeRecipient, buy.makerFee);\r\n      \r\n            /* Charge taker fee to seller. */\r\n            chargeFee(sell.maker, buy.feeRecipient, buy.takerFee);\r\n        }\r\n\r\n        if (price > 0) {\r\n            /* Debit buyer and credit seller. */\r\n            require(sell.paymentToken.transferFrom(buy.maker, sell.maker, price));\r\n        }\r\n\r\n        return price;\r\n    }\r\n\r\n    /**\r\n     * @dev Return whether or not two orders can be matched with each other by basic parameters (does not check order signatures / calldata or perform static calls)\r\n     * @param buy Buy-side order\r\n     * @param sell Sell-side order\r\n     * @return Whether or not the two orders can be matched\r\n     */\r\n    function ordersCanMatch(Order memory buy, Order memory sell)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            /* Must be opposite-side. */\r\n            (buy.side == SaleKindInterface.Side.Buy && sell.side == SaleKindInterface.Side.Sell) &&     \r\n            /* Must use same payment token. */\r\n            (buy.paymentToken == sell.paymentToken) &&\r\n            /* Must match maker/taker addresses. */\r\n            (sell.taker == address(0) || sell.taker == buy.maker) &&\r\n            (buy.taker == address(0) || buy.taker == sell.maker) &&\r\n            /* One must be maker and the other must be taker (no bool XOR in Solidity). */\r\n            ((sell.feeRecipient == address(0) && buy.feeRecipient != address(0)) || (sell.feeRecipient != address(0) && buy.feeRecipient == address(0))) &&\r\n            /* Must match target. */\r\n            (buy.target == sell.target) &&\r\n            /* Must match howToCall. */\r\n            (buy.howToCall == sell.howToCall) &&\r\n            /* Buy-side order must be settleable. */\r\n            SaleKindInterface.canSettleOrder(buy.listingTime, buy.expirationTime) &&\r\n            /* Sell-side order must be settleable. */\r\n            SaleKindInterface.canSettleOrder(sell.listingTime, sell.expirationTime)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Match two orders, ensuring validity of the match, and execute all associated state transitions. Protected against reentrancy by a contract-global lock.\r\n     * @param buy Buy-side order\r\n     * @param buySig Buy-side order signature\r\n     * @param sell Sell-side order\r\n     * @param sellSig Sell-side order signature\r\n     */\r\n    function atomicMatch(Order memory buy, Sig memory buySig, Order memory sell, Sig memory sellSig, bytes32 metadata)\r\n        internal\r\n        reentrancyGuard\r\n    {\r\n        /* CHECKS */\r\n      \r\n        /* Ensure buy order validity and calculate hash. */\r\n        bytes32 buyHash = requireValidOrder(buy, buySig);\r\n\r\n        /* Ensure sell order validity and calculate hash. */\r\n        bytes32 sellHash = requireValidOrder(sell, sellSig); \r\n        \r\n        /* Must be matchable. */\r\n        require(ordersCanMatch(buy, sell));\r\n\r\n        /* Target must exist (prevent malicious selfdestructs just prior to order settlement). */\r\n        uint size;\r\n        address target = sell.target;\r\n        assembly {\r\n            size := extcodesize(target)\r\n        }\r\n        require(size > 0);\r\n      \r\n        /* Must match calldata after replacement, if specified. */ \r\n        if (buy.replacementPattern.length > 0) {\r\n          ArrayUtils.guardedArrayReplace(buy.calldata, sell.calldata, buy.replacementPattern);\r\n        }\r\n        if (sell.replacementPattern.length > 0) {\r\n          ArrayUtils.guardedArrayReplace(sell.calldata, buy.calldata, sell.replacementPattern);\r\n        }\r\n        require(ArrayUtils.arrayEq(buy.calldata, sell.calldata));\r\n\r\n        /* Retrieve proxy (the registry contract is trusted). */\r\n        AuthenticatedProxy proxy = registry.proxies(sell.maker);\r\n\r\n        /* Proxy must exist. */\r\n        require(proxy != address(0));\r\n\r\n        /* EFFECTS */\r\n\r\n        /* Mark orders as finalized. */\r\n        cancelledOrFinalized[buyHash] = true;\r\n        cancelledOrFinalized[sellHash] = true;\r\n\r\n        /* INTERACTIONS */\r\n\r\n        /* Execute funds transfer and pay fees. */\r\n        uint price = executeFundsTransfer(buy, sell);\r\n\r\n        /* Execute specified call through proxy. */\r\n        require(proxy.proxy(sell.target, sell.howToCall, sell.calldata));\r\n\r\n        /* Static calls are intentionally done after the effectful call so they can check resulting state. */\r\n\r\n        /* Handle buy-side static call if specified. */\r\n        if (buy.staticTarget != address(0)) {\r\n            require(staticCall(buy.staticTarget, sell.calldata, buy.staticExtradata));\r\n        }\r\n\r\n        /* Handle sell-side static call if specified. */\r\n        if (sell.staticTarget != address(0)) {\r\n            require(staticCall(sell.staticTarget, sell.calldata, sell.staticExtradata));\r\n        }\r\n\r\n        /* Log match event. */\r\n        OrdersMatched(buyHash, sellHash, sell.feeRecipient != address(0) ? sell.maker : buy.maker, sell.feeRecipient != address(0) ? buy.maker : sell.maker, price, metadata);\r\n    }\r\n\r\n}\r\n\r\ncontract Exchange is ExchangeCore {\r\n\r\n    /**\r\n     * @dev Call guardedArrayReplace - library function exposed for testing.\r\n     */\r\n    function guardedArrayReplace(bytes array, bytes desired, bytes mask)\r\n        public\r\n        pure\r\n        returns (bytes)\r\n    {\r\n        ArrayUtils.guardedArrayReplace(array, desired, mask);\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * @dev Call calculateFinalPrice - library function exposed for testing.\r\n     */\r\n    function calculateFinalPrice(SaleKindInterface.Side side, SaleKindInterface.SaleKind saleKind, uint basePrice, uint extra, uint listingTime, uint expirationTime)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return SaleKindInterface.calculateFinalPrice(side, saleKind, basePrice, extra, listingTime, expirationTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Call hashOrder - Solidity ABI encoding limitation workaround, hopefully temporary.\r\n     */\r\n    function hashOrder_(\r\n        address[7] addrs,\r\n        uint[7] uints,\r\n        SaleKindInterface.Side side,\r\n        SaleKindInterface.SaleKind saleKind,\r\n        AuthenticatedProxy.HowToCall howToCall,\r\n        bytes calldata,\r\n        bytes replacementPattern,\r\n        bytes staticExtradata)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    { \r\n        return hashToSign(\r\n          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Call validateOrder - Solidity ABI encoding limitation workaround, hopefully temporary.\r\n     */\r\n    function validateOrder_ (\r\n        address[7] addrs,\r\n        uint[7] uints,\r\n        SaleKindInterface.Side side,\r\n        SaleKindInterface.SaleKind saleKind,\r\n        AuthenticatedProxy.HowToCall howToCall,\r\n        bytes calldata,\r\n        bytes replacementPattern,\r\n        bytes staticExtradata,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        view\r\n        public\r\n        returns (bool)\r\n    {\r\n        Order memory order = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]);\r\n        return validateOrder(\r\n          hashToSign(order),\r\n          order,\r\n          Sig(v, r, s)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Call approveOrder - Solidity ABI encoding limitation workaround, hopefully temporary.\r\n     */\r\n    function approveOrder_ (\r\n        address[7] addrs,\r\n        uint[7] uints,\r\n        SaleKindInterface.Side side,\r\n        SaleKindInterface.SaleKind saleKind,\r\n        AuthenticatedProxy.HowToCall howToCall,\r\n        bytes calldata,\r\n        bytes replacementPattern,\r\n        bytes staticExtradata,\r\n        bool orderbookInclusionDesired) \r\n        public\r\n    {\r\n        Order memory order = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]);\r\n        return approveOrder(order, orderbookInclusionDesired);\r\n    }\r\n\r\n    /**\r\n     * @dev Call cancelOrder - Solidity ABI encoding limitation workaround, hopefully temporary.\r\n     */\r\n    function cancelOrder_(\r\n        address[7] addrs,\r\n        uint[7] uints,\r\n        SaleKindInterface.Side side,\r\n        SaleKindInterface.SaleKind saleKind,\r\n        AuthenticatedProxy.HowToCall howToCall,\r\n        bytes calldata,\r\n        bytes replacementPattern,\r\n        bytes staticExtradata,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n    {\r\n\r\n        return cancelOrder(\r\n          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]),\r\n          Sig(v, r, s)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Call calculateCurrentPrice - Solidity ABI encoding limitation workaround, hopefully temporary.\r\n     */\r\n    function calculateCurrentPrice_(\r\n        address[7] addrs,\r\n        uint[7] uints,\r\n        SaleKindInterface.Side side,\r\n        SaleKindInterface.SaleKind saleKind,\r\n        AuthenticatedProxy.HowToCall howToCall,\r\n        bytes calldata,\r\n        bytes replacementPattern,\r\n        bytes staticExtradata)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return calculateCurrentPrice(\r\n          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Call ordersCanMatch - Solidity ABI encoding limitation workaround, hopefully temporary.\r\n     */\r\n    function ordersCanMatch_(\r\n        address[14] addrs,\r\n        uint[14] uints,\r\n        uint8[6] sidesKindsHowToCalls,\r\n        bytes calldataBuy,\r\n        bytes calldataSell,\r\n        bytes replacementPatternBuy,\r\n        bytes replacementPatternSell,\r\n        bytes staticExtradataBuy,\r\n        bytes staticExtradataSell)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        Order memory buy = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], SaleKindInterface.Side(sidesKindsHowToCalls[0]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[1]), addrs[4], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[2]), calldataBuy, replacementPatternBuy, addrs[5], staticExtradataBuy, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]);\r\n        Order memory sell = Order(addrs[7], addrs[8], addrs[9], uints[7], uints[8], addrs[10], SaleKindInterface.Side(sidesKindsHowToCalls[3]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[4]), addrs[11], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[5]), calldataSell, replacementPatternSell, addrs[12], staticExtradataSell, ERC20(addrs[13]), uints[9], uints[10], uints[11], uints[12], uints[13]);\r\n        return ordersCanMatch(\r\n          buy,\r\n          sell\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Return whether or not two orders' calldata specifications can match\r\n     * @param buyCalldata Buy-side order calldata\r\n     * @param buyReplacementPattern Buy-side order calldata replacement mask\r\n     * @param sellCalldata Sell-side order calldata\r\n     * @param sellReplacementPattern Sell-side order calldata replacement mask\r\n     * @return Whether the orders' calldata can be matched\r\n     */\r\n    function orderCalldataCanMatch(bytes buyCalldata, bytes buyReplacementPattern, bytes sellCalldata, bytes sellReplacementPattern)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        ArrayUtils.guardedArrayReplace(buyCalldata, sellCalldata, buyReplacementPattern);\r\n        ArrayUtils.guardedArrayReplace(sellCalldata, buyCalldata, sellReplacementPattern);\r\n        return ArrayUtils.arrayEq(buyCalldata, sellCalldata);\r\n    }\r\n\r\n    /**\r\n     * @dev Call calculateMatchPrice - Solidity ABI encoding limitation workaround, hopefully temporary.\r\n     */\r\n    function calculateMatchPrice_(\r\n        address[14] addrs,\r\n        uint[14] uints,\r\n        uint8[6] sidesKindsHowToCalls,\r\n        bytes calldataBuy,\r\n        bytes calldataSell,\r\n        bytes replacementPatternBuy,\r\n        bytes replacementPatternSell,\r\n        bytes staticExtradataBuy,\r\n        bytes staticExtradataSell)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        Order memory buy = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], SaleKindInterface.Side(sidesKindsHowToCalls[0]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[1]), addrs[4], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[2]), calldataBuy, replacementPatternBuy, addrs[5], staticExtradataBuy, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]);\r\n        Order memory sell = Order(addrs[7], addrs[8], addrs[9], uints[7], uints[8], addrs[10], SaleKindInterface.Side(sidesKindsHowToCalls[3]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[4]), addrs[11], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[5]), calldataSell, replacementPatternSell, addrs[12], staticExtradataSell, ERC20(addrs[13]), uints[9], uints[10], uints[11], uints[12], uints[13]);\r\n        return calculateMatchPrice(\r\n          buy,\r\n          sell\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.\r\n     */\r\n    function atomicMatch_(\r\n        address[14] addrs,\r\n        uint[14] uints,\r\n        uint8[6] sidesKindsHowToCalls,\r\n        bytes calldataBuy,\r\n        bytes calldataSell,\r\n        bytes replacementPatternBuy,\r\n        bytes replacementPatternSell,\r\n        bytes staticExtradataBuy,\r\n        bytes staticExtradataSell,\r\n        uint8[2] vs,\r\n        bytes32[5] rssMetadata)\r\n        public\r\n    {\r\n        return atomicMatch(\r\n          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], SaleKindInterface.Side(sidesKindsHowToCalls[0]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[1]), addrs[4], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[2]), calldataBuy, replacementPatternBuy, addrs[5], staticExtradataBuy, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]),\r\n          Sig(vs[0], rssMetadata[0], rssMetadata[1]),\r\n          Order(addrs[7], addrs[8], addrs[9], uints[7], uints[8], addrs[10], SaleKindInterface.Side(sidesKindsHowToCalls[3]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[4]), addrs[11], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[5]), calldataSell, replacementPatternSell, addrs[12], staticExtradataSell, ERC20(addrs[13]), uints[9], uints[10], uints[11], uints[12], uints[13]),\r\n          Sig(vs[1], rssMetadata[2], rssMetadata[3]),\r\n          rssMetadata[4]\r\n        );\r\n    }\r\n\r\n}\r\n\r\ncontract WyvernExchange is Exchange {\r\n\r\n    string public constant name = \"Project Wyvern Exchange\";\r\n\r\n    /**\r\n     * @dev Initialize a WyvernExchange instance\r\n     * @param registryAddress Address of the registry instance which this Exchange instance will use\r\n     * @param tokenAddress Address of the token used for protocol fees\r\n     */\r\n    function WyvernExchange (ProxyRegistry registryAddress, ERC20 tokenAddress) public {\r\n        exchangeToken = tokenAddress;\r\n        registry = registryAddress;\r\n    }\r\n\r\n}\r\n\r\nlibrary SaleKindInterface {\r\n\r\n    /**\r\n     * Side: buy or sell.\r\n     */\r\n    enum Side { Buy, Sell }\r\n\r\n    /**\r\n     * Currently supported kinds of sale: fixed price, Dutch auction. \r\n     * English auctions cannot be supported without stronger escrow guarantees.\r\n     * Future interesting options: Vickrey auction, nonlinear Dutch auctions.\r\n     */\r\n    enum SaleKind { FixedPrice, DutchAuction }\r\n\r\n    /**\r\n     * @dev Check whether the parameters of a sale are valid\r\n     * @param saleKind Kind of sale\r\n     * @param expirationTime Order expiration time\r\n     * @return Whether the parameters were valid\r\n     */\r\n    function validateParameters(SaleKind saleKind, uint expirationTime)\r\n        pure\r\n        internal\r\n        returns (bool)\r\n    {\r\n        /* Auctions must have a set expiration date. */\r\n        return (saleKind == SaleKind.FixedPrice || expirationTime > 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Return whether or not an order can be settled\r\n     * @dev Precondition: parameters have passed validateParameters\r\n     * @param listingTime Order listing time\r\n     * @param expirationTime Order expiration time\r\n     */\r\n    function canSettleOrder(uint listingTime, uint expirationTime)\r\n        view\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return (listingTime < now) && (expirationTime == 0 || now < expirationTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the settlement price of an order\r\n     * @dev Precondition: parameters have passed validateParameters.\r\n     * @param side Order side\r\n     * @param saleKind Method of sale\r\n     * @param basePrice Order base price\r\n     * @param extra Order extra price data\r\n     * @param listingTime Order listing time\r\n     * @param expirationTime Order expiration time\r\n     */\r\n    function calculateFinalPrice(Side side, SaleKind saleKind, uint basePrice, uint extra, uint listingTime, uint expirationTime)\r\n        view\r\n        internal\r\n        returns (uint finalPrice)\r\n    {\r\n        if (saleKind == SaleKind.FixedPrice) {\r\n            return basePrice;\r\n        } else if (saleKind == SaleKind.DutchAuction) {\r\n            uint diff = SafeMath.div(SafeMath.mul(extra, SafeMath.sub(now, listingTime)), SafeMath.sub(expirationTime, listingTime));\r\n            if (side == Side.Sell) {\r\n                /* Sell-side - start price: basePrice. End price: basePrice - extra. */\r\n                return SafeMath.sub(basePrice, diff);\r\n            } else {\r\n                /* Buy-side - start price: basePrice. End price: basePrice + extra. */\r\n                return SafeMath.add(basePrice, diff);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract AuthenticatedProxy is TokenRecipient {\r\n\r\n    /* Address which owns this proxy. */\r\n    address public user;\r\n\r\n    /* Associated registry with contract authentication information. */\r\n    ProxyRegistry public registry;\r\n\r\n    /* Whether access has been revoked. */\r\n    bool public revoked;\r\n\r\n    /* Delegate call could be used to atomically transfer multiple assets owned by the proxy contract with one order. */\r\n    enum HowToCall { Call, DelegateCall }\r\n\r\n    /* Event fired when the proxy access is revoked or unrevoked. */\r\n    event Revoked(bool revoked);\r\n\r\n    /**\r\n     * Create an AuthenticatedProxy\r\n     *\r\n     * @param addrUser Address of user on whose behalf this proxy will act\r\n     * @param addrRegistry Address of ProxyRegistry contract which will manage this proxy\r\n     */\r\n    function AuthenticatedProxy(address addrUser, ProxyRegistry addrRegistry) public {\r\n        user = addrUser;\r\n        registry = addrRegistry;\r\n    }\r\n\r\n    /**\r\n     * Set the revoked flag (allows a user to revoke ProxyRegistry access)\r\n     *\r\n     * @dev Can be called by the user only\r\n     * @param revoke Whether or not to revoke access\r\n     */\r\n    function setRevoke(bool revoke)\r\n        public\r\n    {\r\n        require(msg.sender == user);\r\n        revoked = revoke;\r\n        Revoked(revoke);\r\n    }\r\n\r\n    /**\r\n     * Execute a message call from the proxy contract\r\n     *\r\n     * @dev Can be called by the user, or by a contract authorized by the registry as long as the user has not revoked access\r\n     * @param dest Address to which the call will be sent\r\n     * @param howToCall Which kind of call to make\r\n     * @param calldata Calldata to send\r\n     * @return Result of the call (success or failure)\r\n     */\r\n    function proxy(address dest, HowToCall howToCall, bytes calldata)\r\n        public\r\n        returns (bool result)\r\n    {\r\n        require(msg.sender == user || (!revoked && registry.contracts(msg.sender)));\r\n        if (howToCall == HowToCall.Call) {\r\n            result = dest.call(calldata);\r\n        } else if (howToCall == HowToCall.DelegateCall) {\r\n            result = dest.delegatecall(calldata);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Execute a message call and assert success\r\n     * \r\n     * @dev Same functionality as `proxy`, just asserts the return value\r\n     * @param dest Address to which the call will be sent\r\n     * @param howToCall What kind of call to make\r\n     * @param calldata Calldata to send\r\n     */\r\n    function proxyAssert(address dest, HowToCall howToCall, bytes calldata)\r\n        public\r\n    {\r\n        require(proxy(dest, howToCall, calldata));\r\n    }\r\n\r\n}\r\n\r\ncontract ProxyRegistry is Ownable {\r\n\r\n    /* Authenticated proxies by user. */\r\n    mapping(address => AuthenticatedProxy) public proxies;\r\n\r\n    /* Contracts pending access. */\r\n    mapping(address => uint) public pending;\r\n\r\n    /* Contracts allowed to call those proxies. */\r\n    mapping(address => bool) public contracts;\r\n\r\n    /* Delay period for adding an authenticated contract.\r\n       This mitigates a particular class of potential attack on the Wyvern DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the WYV supply (votes in the DAO),\r\n       a malicious but rational attacker could buy half the Wyvern and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given two weeks, if that happened, users would have\r\n       plenty of time to notice and transfer their assets.\r\n    */\r\n    uint public DELAY_PERIOD = 2 weeks;\r\n\r\n    /**\r\n     * Start the process to enable access for specified contract. Subject to delay period.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address to which to grant permissions\r\n     */\r\n    function startGrantAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(!contracts[addr] && pending[addr] == 0);\r\n        pending[addr] = now;\r\n    }\r\n\r\n    /**\r\n     * End the process to nable access for specified contract after delay period has passed.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address to which to grant permissions\r\n     */\r\n    function endGrantAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < now));\r\n        pending[addr] = 0;\r\n        contracts[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * Revoke access for specified contract. Can be done instantly.\r\n     *\r\n     * @dev ProxyRegistry owner only\r\n     * @param addr Address of which to revoke permissions\r\n     */    \r\n    function revokeAuthentication (address addr)\r\n        public\r\n        onlyOwner\r\n    {\r\n        contracts[addr] = false;\r\n    }\r\n\r\n    /**\r\n     * Register a proxy contract with this registry\r\n     *\r\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\r\n     * @return New AuthenticatedProxy contract\r\n     */\r\n    function registerProxy()\r\n        public\r\n        returns (AuthenticatedProxy proxy)\r\n    {\r\n        require(proxies[msg.sender] == address(0));\r\n        proxy = new AuthenticatedProxy(msg.sender, this);\r\n        proxies[msg.sender] = proxy;\r\n        return proxy;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"calldata\",\"type\":\"bytes\"},{\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"staticCall\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[14]\"},{\"name\":\"uints\",\"type\":\"uint256[14]\"},{\"name\":\"sidesKindsHowToCalls\",\"type\":\"uint8[6]\"},{\"name\":\"calldataBuy\",\"type\":\"bytes\"},{\"name\":\"calldataSell\",\"type\":\"bytes\"},{\"name\":\"replacementPatternBuy\",\"type\":\"bytes\"},{\"name\":\"replacementPatternSell\",\"type\":\"bytes\"},{\"name\":\"staticExtradataBuy\",\"type\":\"bytes\"},{\"name\":\"staticExtradataSell\",\"type\":\"bytes\"}],\"name\":\"ordersCanMatch_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[7]\"},{\"name\":\"uints\",\"type\":\"uint256[7]\"},{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"saleKind\",\"type\":\"uint8\"},{\"name\":\"howToCall\",\"type\":\"uint8\"},{\"name\":\"calldata\",\"type\":\"bytes\"},{\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"name\":\"orderbookInclusionDesired\",\"type\":\"bool\"}],\"name\":\"approveOrder_\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"array\",\"type\":\"bytes\"},{\"name\":\"desired\",\"type\":\"bytes\"},{\"name\":\"mask\",\"type\":\"bytes\"}],\"name\":\"guardedArrayReplace\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[7]\"},{\"name\":\"uints\",\"type\":\"uint256[7]\"},{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"saleKind\",\"type\":\"uint8\"},{\"name\":\"howToCall\",\"type\":\"uint8\"},{\"name\":\"calldata\",\"type\":\"bytes\"},{\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder_\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buyCalldata\",\"type\":\"bytes\"},{\"name\":\"buyReplacementPattern\",\"type\":\"bytes\"},{\"name\":\"sellCalldata\",\"type\":\"bytes\"},{\"name\":\"sellReplacementPattern\",\"type\":\"bytes\"}],\"name\":\"orderCalldataCanMatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[14]\"},{\"name\":\"uints\",\"type\":\"uint256[14]\"},{\"name\":\"sidesKindsHowToCalls\",\"type\":\"uint8[6]\"},{\"name\":\"calldataBuy\",\"type\":\"bytes\"},{\"name\":\"calldataSell\",\"type\":\"bytes\"},{\"name\":\"replacementPatternBuy\",\"type\":\"bytes\"},{\"name\":\"replacementPatternSell\",\"type\":\"bytes\"},{\"name\":\"staticExtradataBuy\",\"type\":\"bytes\"},{\"name\":\"staticExtradataSell\",\"type\":\"bytes\"}],\"name\":\"calculateMatchPrice_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"saleKind\",\"type\":\"uint8\"},{\"name\":\"basePrice\",\"type\":\"uint256\"},{\"name\":\"extra\",\"type\":\"uint256\"},{\"name\":\"listingTime\",\"type\":\"uint256\"},{\"name\":\"expirationTime\",\"type\":\"uint256\"}],\"name\":\"calculateFinalPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[7]\"},{\"name\":\"uints\",\"type\":\"uint256[7]\"},{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"saleKind\",\"type\":\"uint8\"},{\"name\":\"howToCall\",\"type\":\"uint8\"},{\"name\":\"calldata\",\"type\":\"bytes\"},{\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"validateOrder_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelledOrFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[14]\"},{\"name\":\"uints\",\"type\":\"uint256[14]\"},{\"name\":\"sidesKindsHowToCalls\",\"type\":\"uint8[6]\"},{\"name\":\"calldataBuy\",\"type\":\"bytes\"},{\"name\":\"calldataSell\",\"type\":\"bytes\"},{\"name\":\"replacementPatternBuy\",\"type\":\"bytes\"},{\"name\":\"replacementPatternSell\",\"type\":\"bytes\"},{\"name\":\"staticExtradataBuy\",\"type\":\"bytes\"},{\"name\":\"staticExtradataSell\",\"type\":\"bytes\"},{\"name\":\"vs\",\"type\":\"uint8[2]\"},{\"name\":\"rssMetadata\",\"type\":\"bytes32[5]\"}],\"name\":\"atomicMatch_\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"approvedOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[7]\"},{\"name\":\"uints\",\"type\":\"uint256[7]\"},{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"saleKind\",\"type\":\"uint8\"},{\"name\":\"howToCall\",\"type\":\"uint8\"},{\"name\":\"calldata\",\"type\":\"bytes\"},{\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"name\":\"staticExtradata\",\"type\":\"bytes\"}],\"name\":\"calculateCurrentPrice_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[7]\"},{\"name\":\"uints\",\"type\":\"uint256[7]\"},{\"name\":\"side\",\"type\":\"uint8\"},{\"name\":\"saleKind\",\"type\":\"uint8\"},{\"name\":\"howToCall\",\"type\":\"uint8\"},{\"name\":\"calldata\",\"type\":\"bytes\"},{\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"name\":\"staticExtradata\",\"type\":\"bytes\"}],\"name\":\"hashOrder_\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"registryAddress\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"exchange\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"takerFee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"feeRecipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"saleKind\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"howToCall\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"calldata\",\"type\":\"bytes\"}],\"name\":\"OrderApprovedPartOne\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"staticTarget\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"basePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"extra\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"listingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"orderbookInclusionDesired\",\"type\":\"bool\"}],\"name\":\"OrderApprovedPartTwo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sellHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"metadata\",\"type\":\"bytes32\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"}]","ContractName":"WyvernExchange","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a4306692b00795f97010ec7237980141d08c6d56000000000000000000000000056017c55ae7ae32d12aef7c679df83a85ca75ff","Library":"","SwarmSource":"bzzr://984a41db91f5420a2be4a862f49a9fe3287aa86004e31d7941555c28a54d4fba"}]}