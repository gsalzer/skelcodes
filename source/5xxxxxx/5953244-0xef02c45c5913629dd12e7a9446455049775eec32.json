{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\ncontract RuletkaIo {\r\n    \r\n    /*** EVENTS ***/\r\n    \r\n    /// @dev A russian Roulette has been executed between 6 players\r\n    /// in room roomId and unfortunately, victim got shot and didn't \r\n    /// make it out alive... RIP\r\n    event partyOver(uint256 roomId, address victim, address[] winners);\r\n\r\n    /// @dev A new player has enter a room\r\n    event newPlayer(uint256 roomId, address player);\r\n    \r\n    /// @dev A room is full, we close the door. Game can start.\r\n    event fullRoom(uint256 roomId);\r\n    \r\n    /// @dev A safety mechanism has been triggered to empty the room and refund entirely the players (Should never happen)\r\n    event  roomRefunded(uint256 _roomId, address[] refundedPlayers);\r\n\r\n    /*** Founders addresses ***/\r\n    address CTO;\r\n    address CEO;\r\n    \r\n     Room[] private allRooms;\r\n\r\n    function () public payable {} // Give the ability of receiving ether\r\n\r\n    function RuletkaIo() public {\r\n        CTO = msg.sender;\r\n        CEO = msg.sender;\r\n    }\r\n    \r\n    /*** ACCESS MODIFIERS ***/\r\n    /// @dev Access modifier for CTO-only functionality\r\n    modifier onlyCTO() {\r\n        require(msg.sender == CTO);\r\n        _;\r\n    }\r\n    \r\n    /// @dev Assigns a new address to act as the CTO.\r\n    /// @param _newCTO The address of the new CTO\r\n    function setCTO(address _newCTO) public onlyCTO {\r\n        require(_newCTO != address(0));\r\n        CTO = _newCTO;\r\n    }\r\n    \r\n    /// @dev Assigns a new address to act as the CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) public onlyCTO {\r\n        require(_newCEO != address(0));\r\n        CEO = _newCEO;\r\n    }\r\n    \r\n    /*** DATATYPES ***/\r\n      struct Room {\r\n        string name;\r\n        uint256 entryPrice; //  The price to enter the room and play Russian Roulette\r\n        uint256 balance;\r\n        address[] players;\r\n      }\r\n    \r\n    \r\n    /// For creating Room\r\n  function createRoom(string _name, uint256 _entryPrice) public onlyCTO{\r\n    address[] memory players;\r\n    Room memory _room = Room({\r\n      name: _name,\r\n      players: players,\r\n      balance: 0,\r\n      entryPrice: _entryPrice\r\n    });\r\n\r\n    allRooms.push(_room);\r\n  }\r\n    \r\n    function enter(uint256 _roomId) public payable {\r\n        Room storage room = allRooms[_roomId-1]; //if _roomId doesn't exist in array, exits.\r\n        \r\n        require(room.players.length < 6);\r\n        require(msg.value >= room.entryPrice);\r\n        \r\n        room.players.push(msg.sender);\r\n        room.balance += room.entryPrice;\r\n        \r\n        emit newPlayer(_roomId, msg.sender);\r\n        \r\n        if(room.players.length == 6){\r\n            executeRoom(_roomId);\r\n        }\r\n    }\r\n    \r\n    function enterWithReferral(uint256 _roomId, address referrer) public payable {\r\n        \r\n        Room storage room = allRooms[_roomId-1]; //if _roomId doesn't exist in array, exits.\r\n        \r\n        require(room.players.length < 6);\r\n        require(msg.value >= room.entryPrice);\r\n        \r\n        uint256 referrerCut = SafeMath.div(room.entryPrice, 100); // Referrer get one percent of the bet as reward\r\n        referrer.transfer(referrerCut);\r\n         \r\n        room.players.push(msg.sender);\r\n        room.balance += room.entryPrice - referrerCut;\r\n        \r\n        emit newPlayer(_roomId, msg.sender);\r\n        \r\n        if(room.players.length == 6){\r\n            emit fullRoom(_roomId);\r\n            executeRoom(_roomId);\r\n        }\r\n    }\r\n    \r\n    function executeRoom(uint256 _roomId) public {\r\n        \r\n        Room storage room = allRooms[_roomId-1]; //if _roomId doesn't exist in array, exits.\r\n        \r\n        //Check if the room is really full before shooting people...\r\n        require(room.players.length == 6);\r\n        \r\n        uint256 halfFee = SafeMath.div(room.entryPrice, 20);\r\n        CTO.transfer(halfFee);\r\n        CEO.transfer(halfFee);\r\n        room.balance -= halfFee * 2;\r\n        \r\n        uint256 deadSeat = random();\r\n        \r\n        distributeFunds(_roomId, deadSeat);\r\n        \r\n        delete room.players;\r\n    }\r\n    \r\n    function distributeFunds(uint256 _roomId, uint256 _deadSeat) private returns(uint256) {\r\n        \r\n        Room storage room = allRooms[_roomId-1]; //if _roomId doesn't exist in array, exits.\r\n        uint256 balanceToDistribute = SafeMath.div(room.balance,5);\r\n        \r\n        address victim = room.players[_deadSeat];\r\n        address[] memory winners = new address[](5);\r\n        uint256 j = 0; \r\n        for (uint i = 0; i<6; i++) {\r\n            if(i != _deadSeat){\r\n               room.players[i].transfer(balanceToDistribute);\r\n               room.balance -= balanceToDistribute;\r\n               winners[j] = room.players[i];\r\n               j++;\r\n            }\r\n        }\r\n        \r\n        emit partyOver(_roomId, victim, winners);\r\n       \r\n        return address(this).balance;\r\n    }\r\n    \r\n     /// @dev Empty the room and refund each player. Safety mechanism which shouldn't be used.\r\n    /// @param _roomId The Room id to empty and refund\r\n    function refundPlayersInRoom(uint256 _roomId) public onlyCTO{\r\n        Room storage room = allRooms[_roomId-1]; //if _roomId doesn't exist in array, exits.\r\n        uint256 nbrOfPlayers = room.players.length;\r\n        uint256 balanceToRefund = SafeMath.div(room.balance,nbrOfPlayers);\r\n        for (uint i = 0; i<nbrOfPlayers; i++) {\r\n             room.players[i].transfer(balanceToRefund);\r\n             room.balance -= balanceToRefund;\r\n        }\r\n        \r\n        emit roomRefunded(_roomId, room.players);\r\n        delete room.players;\r\n    }\r\n    \r\n    \r\n    /// @dev A clean and efficient way to generate random and make sure that it\r\n    /// will remain the same accross the executing nodes of random value \r\n    /// Ethereum Blockchain. We base our computation on the block.timestamp\r\n    /// and difficulty which will remain the same accross the nodes to ensure\r\n    /// same result for the same execution.\r\n    function random() private view returns (uint256) {\r\n        return uint256(uint256(keccak256(block.timestamp, block.difficulty))%6);\r\n    }\r\n    \r\n    function getRoom(uint256 _roomId) public view returns (\r\n    string name,\r\n    address[] players,\r\n    uint256 entryPrice,\r\n    uint256 balance\r\n  ) {\r\n    Room storage room = allRooms[_roomId-1];\r\n    name = room.name;\r\n    players = room.players;\r\n    entryPrice = room.entryPrice;\r\n    balance = room.balance;\r\n  }\r\n  \r\n  function payout(address _to) public onlyCTO {\r\n    _payout(_to);\r\n  }\r\n\r\n  /// For paying out balance on contract\r\n  function _payout(address _to) private {\r\n    if (_to == address(0)) {\r\n      CTO.transfer(SafeMath.div(address(this).balance, 2));\r\n      CEO.transfer(address(this).balance);\r\n    } else {\r\n      _to.transfer(address(this).balance);\r\n    }\r\n  }\r\n  \r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_entryPrice\",\"type\":\"uint256\"}],\"name\":\"createRoom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roomId\",\"type\":\"uint256\"}],\"name\":\"executeRoom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roomId\",\"type\":\"uint256\"}],\"name\":\"refundPlayersInRoom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_roomId\",\"type\":\"uint256\"}],\"name\":\"getRoom\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"players\",\"type\":\"address[]\"},{\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roomId\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roomId\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"enterWithReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCTO\",\"type\":\"address\"}],\"name\":\"setCTO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"victim\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winners\",\"type\":\"address[]\"}],\"name\":\"partyOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"newPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roomId\",\"type\":\"uint256\"}],\"name\":\"fullRoom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roomId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refundedPlayers\",\"type\":\"address[]\"}],\"name\":\"roomRefunded\",\"type\":\"event\"}]","ContractName":"RuletkaIo","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7aa7db68274ad83d2d451eb43a97910e83616afc377062ced3b7fbd575c82a72"}]}