{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\nRead code from https://github.com/onbjerg/dai.how\r\n\r\n*/\r\ninterface IMaker {\r\n    function sai() public view returns (ERC20);\r\n    function skr() public view returns (ERC20);\r\n    function gem() public view returns (ERC20);\r\n\r\n    function open() public returns (bytes32 cup);\r\n    function give(bytes32 cup, address guy) public;\r\n\r\n    function gap() public view returns (uint);\r\n    function per() public view returns (uint);\r\n\r\n    function ask(uint wad) public view returns (uint);\r\n    function bid(uint wad) public view returns (uint);\r\n\r\n    function join(uint wad) public;\r\n    function lock(bytes32 cup, uint wad) public;\r\n    function free(bytes32 cup, uint wad) public;\r\n    function draw(bytes32 cup, uint wad) public;\r\n    function cage(uint fit_, uint jam) public;\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() public payable;\r\n    function withdraw(uint wad) public;\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) public pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) public pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DaiMaker is DSMath {\r\n    IMaker public maker;\r\n    ERC20 public weth;\r\n    ERC20 public peth;\r\n    ERC20 public dai;\r\n\r\n    event MakeDai(address indexed daiOwner, address indexed cdpOwner, uint256 ethAmount, uint256 daiAmount, uint256 pethAmount);\r\n\r\n    function DaiMaker(IMaker _maker) {\r\n        maker = _maker;\r\n        weth = maker.gem();\r\n        peth = maker.skr();\r\n        dai = maker.sai();\r\n    }\r\n\r\n    function makeDai(uint256 daiAmount, address cdpOwner, address daiOwner) payable public returns (bytes32 cdpId) {\r\n        IWETH(weth).deposit.value(msg.value)();      // wrap eth in weth token\r\n        weth.approve(maker, msg.value);              // allow maker to pull weth\r\n\r\n        // calculate how much peth we need to enter with\r\n        uint256 inverseAsk = rdiv(msg.value, wmul(maker.gap(), maker.per())) - 1;\r\n\r\n        maker.join(inverseAsk);                      // convert weth to peth\r\n        uint256 pethAmount = peth.balanceOf(this);\r\n\r\n        peth.approve(maker, pethAmount);             // allow maker to pull peth\r\n\r\n        cdpId = maker.open();                        // create cdp in maker\r\n        maker.lock(cdpId, pethAmount);               // lock peth into cdp\r\n        maker.draw(cdpId, daiAmount);                // create dai from cdp\r\n\r\n        dai.transfer(daiOwner, daiAmount);           // transfer dai to owner\r\n        maker.give(cdpId, cdpOwner);                 // transfer cdp to owner\r\n\r\n        MakeDai(daiOwner, cdpOwner, msg.value, daiAmount, pethAmount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"rdiv\",\"outputs\":[{\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"name\":\"cdpOwner\",\"type\":\"address\"},{\"name\":\"daiOwner\",\"type\":\"address\"}],\"name\":\"makeDai\",\"outputs\":[{\"name\":\"cdpId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"wdiv\",\"outputs\":[{\"name\":\"z\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"peth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_maker\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"daiOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"cdpOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pethAmount\",\"type\":\"uint256\"}],\"name\":\"MakeDai\",\"type\":\"event\"}]","ContractName":"DaiMaker","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000448a5065aebb8e423f0896e6c5d525c040f59af3","Library":"","SwarmSource":"bzzr://aecd4219764aa1971e33e810b8c0bdedc31d2bb0340833e70db21b3ec2e1706a"}]}