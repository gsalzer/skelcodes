{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity\r\n^0.4.21;\r\n\r\n/*\r\nhttp://www.cryptophoenixes.fun/\r\nCryptoPhoenixes: Civil War Edition\r\n\r\nOriginal game design and website development by Anyhowclick.\r\nArt design by Tilly.\r\n*/\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract CryptoPhoenixesCivilWar is Ownable, Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  address public subDevOne;\r\n  address public subDevTwo;\r\n  \r\n  Phoenix[] public PHOENIXES;\r\n  /*\r\n  id 0: Rainbow Phoenix\r\n  ids 1-2: Red / Blue capt respectively\r\n  ids 3-6: Red bombers\r\n  ids 7-10: Red thieves\r\n  ids 11-14: Blue bombers\r\n  ids 15-18: Blue thieves\r\n  */\r\n  \r\n  uint256 public DENOMINATOR = 10000; //Eg explosivePower = 300 -> 3%\r\n  \r\n  uint256[2] public POOLS; //0 = red, 1 = blue\r\n  uint256[2] public SCORES; //0 = red, 1 = blue\r\n  \r\n  bool public GAME_STARTED = false;\r\n  uint public GAME_END = 0;\r\n  \r\n  // devFunds\r\n  mapping (address => uint256) public devFunds;\r\n\r\n  // userFunds\r\n  mapping (address => uint256) public userFunds;\r\n\r\n  // Constant\r\n  uint256 constant public BASE_PRICE = 0.0025 ether;\r\n  \r\n  //Permission control\r\n  modifier onlyAuthorized() {\r\n      require(msg.sender == owner || msg.sender == subDevOne); //subDevTwo is NOT authorized\r\n      _;\r\n  }\r\n  \r\n  //to check that a game has ended\r\n  modifier gameHasEnded() {\r\n      require(GAME_STARTED); //Check if a game was started in the first place\r\n      require(now >= GAME_END); //Check if game has ended\r\n      _;\r\n  }\r\n  \r\n  //to check that a game is in progress\r\n  modifier gameInProgress() {\r\n      require(GAME_STARTED);\r\n      require(now <= GAME_END);\r\n      _;\r\n  }\r\n  \r\n  //to check the reverse, that no game is in progress\r\n  modifier noGameInProgress() {\r\n      require(!GAME_STARTED);\r\n      _;\r\n  }\r\n  \r\n  // Events\r\n  event GameStarted();\r\n      \r\n  event PhoenixPurchased(\r\n      uint256 phoenixID,\r\n      address newOwner,\r\n      uint256 price,\r\n      uint256 nextPrice,\r\n      uint256 currentPower,\r\n      uint abilityAvailTime\r\n  );\r\n\r\n  event CaptainAbilityUsed(\r\n      uint256 captainID\r\n  );\r\n  \r\n  event PhoenixAbilityUsed(\r\n      uint256 phoenixID,\r\n      uint256 payout,\r\n      uint256 price,\r\n      uint256 currentPower,\r\n      uint abilityAvailTime,\r\n      address previousOwner\r\n  );\r\n  \r\n  event GameEnded();\r\n\r\n  event WithdrewFunds(\r\n    address owner\r\n  );\r\n  \r\n  // Struct to store Phoenix Data\r\n  struct Phoenix {\r\n    uint256 price;  // Current price of phoenix\r\n    uint256 payoutPercentage; // The percent of the funds awarded upon explosion / steal / end game\r\n    uint abilityAvailTime; // Time when phoenix's ability is available\r\n    uint cooldown; // Time to add after cooldown\r\n    uint cooldownDecreaseAmt; // Amt of time to decrease upon each flip\r\n    uint basePower; // Starting exploding / stealing power of phoenix\r\n    uint currentPower; // Current exploding / stealing power of phoenix\r\n    uint powerIncreaseAmt; // Amt of power to increase with every flip\r\n    uint powerDrop; // Power drop of phoenix upon ability usage\r\n    uint powerCap; // Power should not exceed this amount\r\n    address previousOwner;  // Owner of phoenix in previous round\r\n    address currentOwner; // Current owner of phoenix\r\n  }\r\n  \r\n// Main function to set the beta period and sub developer\r\n  function CryptoPhoenixesCivilWar(address _subDevOne, address _subDevTwo) {\r\n    subDevOne = _subDevOne;\r\n    subDevTwo = _subDevTwo;\r\n    createPhoenixes();\r\n  }\r\n\r\n  function createPhoenixes() private {\r\n      //First, create rainbow phoenix and captains\r\n      for (uint256 i = 0; i < 3; i++) {\r\n          Phoenix memory phoenix = Phoenix({\r\n              price: 0.005 ether,\r\n              payoutPercentage: 2400, //redundant for rainbow phoenix. Set to 24% for captains\r\n              cooldown: 20 hours, //redundant for rainbow phoenix\r\n              abilityAvailTime: 0, //will be set when game starts\r\n              //Everything else not used\r\n              cooldownDecreaseAmt: 0,\r\n              basePower: 0,\r\n              currentPower: 0,\r\n              powerIncreaseAmt: 0,\r\n              powerDrop: 0,\r\n              powerCap: 0,\r\n              previousOwner: address(0),\r\n              currentOwner: address(0)\r\n          });\r\n          \r\n          PHOENIXES.push(phoenix);\r\n      }\r\n      \r\n      //set rainbow phoenix price to 0.01 ether\r\n      PHOENIXES[0].price = 0.01 ether;\r\n      \r\n      //Now, for normal phoenixes\r\n      uint16[4] memory PAYOUTS = [400,700,1100,1600]; //4%, 7%, 11%, 16%\r\n      uint16[4] memory COOLDOWN = [2 hours, 4 hours, 8 hours, 16 hours];\r\n      uint16[4] memory COOLDOWN_DECREASE = [9 minutes, 15 minutes, 26 minutes, 45 minutes];\r\n      uint8[4] memory POWER_INC_AMT = [25,50,100,175]; //0.25%, 0.5%, 1%, 1.75%\r\n      uint16[4] memory POWER_DROP = [150,300,600,1000]; //1.5%, 3%, 6%, 10%\r\n      uint16[4] memory CAPPED_POWER = [800,1500,3000,5000]; //8%, 15%, 30%, 50%\r\n      \r\n      \r\n      for (i = 0; i < 4; i++) {\r\n          for (uint256 j = 0; j < 4; j++) {\r\n              phoenix = Phoenix({\r\n              price: BASE_PRICE,\r\n              payoutPercentage: PAYOUTS[j],\r\n              abilityAvailTime: 0,\r\n              cooldown: COOLDOWN[j],\r\n              cooldownDecreaseAmt: COOLDOWN_DECREASE[j],\r\n              basePower: (j+1)*100, //100, 200, 300, 400 = 1%, 2%, 3%, 4%\r\n              currentPower: (j+1)*100,\r\n              powerIncreaseAmt: POWER_INC_AMT[j],\r\n              powerDrop: POWER_DROP[j],\r\n              powerCap: CAPPED_POWER[j],\r\n              previousOwner: address(0),\r\n              currentOwner: address(0)\r\n              });\r\n              \r\n              PHOENIXES.push(phoenix);\r\n          }\r\n      }\r\n  }\r\n  \r\n  function startGame() public noGameInProgress onlyAuthorized {\r\n      //reset scores\r\n      SCORES[0] = 0;\r\n      SCORES[1] = 0;\r\n      \r\n      //reset normal phoenixes' abilityAvailTimes\r\n      for (uint i = 1; i < 19; i++) {\r\n          PHOENIXES[i].abilityAvailTime = now + PHOENIXES[i].cooldown;\r\n      }\r\n      \r\n      GAME_STARTED = true;\r\n      //set game duration to be 1 day\r\n      GAME_END = now + 1 days;\r\n      emit GameStarted();\r\n  }\r\n  \r\n  //Set bag holders from version 1.0\r\n  function setPhoenixOwners(address[19] _owners) onlyOwner public {\r\n      require(PHOENIXES[0].previousOwner == address(0)); //Just need check once\r\n      for (uint256 i = 0; i < 19; i++) {\r\n          Phoenix storage phoenix = PHOENIXES[i];\r\n          phoenix.previousOwner = _owners[i];\r\n          phoenix.currentOwner = _owners[i];\r\n      }\r\n  }\r\n\r\nfunction purchasePhoenix(uint256 _phoenixID) whenNotPaused gameInProgress public payable {\r\n      //checking prerequisite\r\n      require(_phoenixID < 19);\r\n    \r\n      Phoenix storage phoenix = PHOENIXES[_phoenixID];\r\n      //Get current price of phoenix\r\n      uint256 price = phoenix.price;\r\n      \r\n      //checking more prerequisites\r\n      require(phoenix.currentOwner != address(0)); //check if phoenix was initialised\r\n      require(msg.value >= phoenix.price);\r\n      require(phoenix.currentOwner != msg.sender); //prevent consecutive purchases\r\n      \r\n      uint256 outgoingOwnerCut;\r\n      uint256 purchaseExcess;\r\n      uint256 poolCut;\r\n      uint256 rainbowCut;\r\n      uint256 captainCut;\r\n      \r\n      (outgoingOwnerCut, \r\n      purchaseExcess, \r\n      poolCut,\r\n      rainbowCut,\r\n      captainCut) = calculateCuts(msg.value,price);\r\n      \r\n      //give 1% for previous owner, abusing variable name here\r\n      userFunds[phoenix.previousOwner] = userFunds[phoenix.previousOwner].add(captainCut); \r\n      \r\n      //If purchasing rainbow phoenix, give the 2% rainbowCut and 1% captainCut to outgoingOwner\r\n      if (_phoenixID == 0) {\r\n          outgoingOwnerCut = outgoingOwnerCut.add(rainbowCut).add(captainCut);\r\n          rainbowCut = 0; //necessary to set to zero since variable is used for other cases\r\n          poolCut = poolCut.div(2); //split poolCut equally into 2, distribute to both POOLS\r\n          POOLS[0] = POOLS[0].add(poolCut); //add pool cut to red team\r\n          POOLS[1] = POOLS[1].add(poolCut); //add pool cut to blue team\r\n          \r\n      } else if (_phoenixID < 3) { //if captain, return 1% captainCut to outgoingOwner\r\n          outgoingOwnerCut = outgoingOwnerCut.add(captainCut);\r\n          uint256 poolID = _phoenixID.sub(1); //1 --> 0, 2--> 1 (detemine which pool to add pool cut to)\r\n          POOLS[poolID] = POOLS[poolID].add(poolCut);\r\n          \r\n      } else if (_phoenixID < 11) { //for normal red phoenixes, set captain and adjust stats\r\n          //transfer 1% captainCut to red captain\r\n          userFunds[PHOENIXES[1].currentOwner] = userFunds[PHOENIXES[1].currentOwner].add(captainCut);\r\n          upgradePhoenixStats(_phoenixID);\r\n          POOLS[0] = POOLS[0].add(poolCut); //add pool cut to red team\r\n      } else {\r\n          //transfer 1% captainCut to blue captain\r\n          userFunds[PHOENIXES[2].currentOwner] = userFunds[PHOENIXES[2].currentOwner].add(captainCut);\r\n          upgradePhoenixStats(_phoenixID);\r\n          POOLS[1] = POOLS[1].add(poolCut); //add pool cut to blue team\r\n      }\r\n      \r\n      //transfer rainbowCut to rainbow phoenix owner\r\n      userFunds[PHOENIXES[0].currentOwner] = userFunds[PHOENIXES[0].currentOwner].add(rainbowCut);\r\n\r\n      // set new price\r\n      phoenix.price = getNextPrice(price);\r\n      \r\n      // send funds to old owner \r\n      sendFunds(phoenix.currentOwner, outgoingOwnerCut);\r\n    \r\n      // set new owner\r\n      phoenix.currentOwner = msg.sender;\r\n\r\n      // Send refund to owner if needed\r\n      if (purchaseExcess > 0) {\r\n        sendFunds(msg.sender,purchaseExcess);\r\n      }\r\n      \r\n      // raise event\r\n      emit PhoenixPurchased(_phoenixID, msg.sender, price, phoenix.price, phoenix.currentPower, phoenix.abilityAvailTime);\r\n  }\r\n  \r\n  function calculateCuts(\r\n      uint256 _amtPaid,\r\n      uint256 _price\r\n      )\r\n      private\r\n      returns (uint256 outgoingOwnerCut, uint256 purchaseExcess, uint256 poolCut, uint256 rainbowCut, uint256 captainCut)\r\n      {\r\n      outgoingOwnerCut = _price;\r\n      purchaseExcess = _amtPaid.sub(_price);\r\n      \r\n      //Take 5% cut from excess\r\n      uint256 excessPoolCut = purchaseExcess.div(20); //5%, will be added to poolCut\r\n      purchaseExcess = purchaseExcess.sub(excessPoolCut);\r\n      \r\n      //3% of price to devs\r\n      uint256 cut = _price.mul(3).div(100); //3%\r\n      outgoingOwnerCut = outgoingOwnerCut.sub(cut);\r\n      distributeDevCut(cut);\r\n      \r\n      //1% of price to owner in previous round, 1% to captain (if applicable)\r\n      //abusing variable name to use for previous owner and captain fees, since they are the same\r\n      captainCut = _price.div(100); //1%\r\n      outgoingOwnerCut = outgoingOwnerCut.sub(captainCut).sub(captainCut); //subtract twice, reason as explained\r\n      \r\n      //2% of price to rainbow (if applicable)\r\n      rainbowCut = _price.mul(2).div(100); //2%\r\n      outgoingOwnerCut = outgoingOwnerCut.sub(rainbowCut);\r\n      \r\n      //11-13% of price will go to the respective team pools\r\n      poolCut = calculatePoolCut(_price);\r\n      outgoingOwnerCut = outgoingOwnerCut.sub(poolCut);\r\n      /*\r\n      add the poolCut and excessPoolCut together\r\n      so poolCut = 11-13% of price + 5% of purchaseExcess\r\n      */\r\n      poolCut = poolCut.add(excessPoolCut);\r\n  }\r\n  \r\n  function distributeDevCut(uint256 _cut) private {\r\n      devFunds[owner] = devFunds[owner].add(_cut.div(2)); //50% to owner\r\n      devFunds[subDevOne] = devFunds[subDevOne].add(_cut.div(4)); //25% to subDevOne\r\n      devFunds[subDevTwo] = devFunds[subDevTwo].add(_cut.div(4)); //25% to subDevTwo\r\n  }\r\n  \r\n/**\r\n  * @dev Determines next price of phoenix\r\n*/\r\n  function getNextPrice (uint256 _price) private pure returns (uint256 _nextPrice) {\r\n    if (_price < 0.25 ether) {\r\n      return _price.mul(3).div(2); //1.5x\r\n    } else if (_price < 1 ether) {\r\n      return _price.mul(14).div(10); //1.4x\r\n    } else {\r\n      return _price.mul(13).div(10); //1.3x\r\n    }\r\n  }\r\n  \r\n  function calculatePoolCut (uint256 _price) private pure returns (uint256 poolCut) {\r\n      if (_price < 0.25 ether) {\r\n          poolCut = _price.mul(13).div(100); //13%\r\n      } else if (_price < 1 ether) {\r\n          poolCut = _price.mul(12).div(100); //12%\r\n      } else {\r\n          poolCut = _price.mul(11).div(100); //11%\r\n      }\r\n  }\r\n \r\n  function upgradePhoenixStats(uint256 _phoenixID) private {\r\n      Phoenix storage phoenix = PHOENIXES[_phoenixID];\r\n      //increase current power of phoenix\r\n      phoenix.currentPower = phoenix.currentPower.add(phoenix.powerIncreaseAmt);\r\n      //handle boundary case where current power exceeds cap\r\n      if (phoenix.currentPower > phoenix.powerCap) {\r\n          phoenix.currentPower = phoenix.powerCap;\r\n      }\r\n      //decrease cooldown of phoenix\r\n      //no base case to take care off. Time shouldnt decrease too much to ever reach zero\r\n      phoenix.abilityAvailTime = phoenix.abilityAvailTime.sub(phoenix.cooldownDecreaseAmt);\r\n  }\r\n  \r\n  function useCaptainAbility(uint256 _captainID) whenNotPaused gameInProgress public {\r\n      require(_captainID > 0 && _captainID < 3); //either 1 or 2\r\n      Phoenix storage captain = PHOENIXES[_captainID];\r\n      require(msg.sender == captain.currentOwner); //Only owner of captain can use ability\r\n      require(now >= captain.abilityAvailTime); //Ability must be available for use\r\n      \r\n      if (_captainID == 1) { //red team\r\n          uint groupIDStart = 3; //Start index of _groupID in PHOENIXES\r\n          uint groupIDEnd = 11; //End index (excluding) of _groupID in PHOENIXES\r\n      } else {\r\n          groupIDStart = 11; \r\n          groupIDEnd = 19; \r\n      }\r\n      \r\n      for (uint i = groupIDStart; i < groupIDEnd; i++) {\r\n          //Multiply team power by 1.5x\r\n          PHOENIXES[i].currentPower = PHOENIXES[i].currentPower.mul(3).div(2); \r\n          //ensure cap not breached\r\n          if (PHOENIXES[i].currentPower > PHOENIXES[i].powerCap) {\r\n              PHOENIXES[i].currentPower = PHOENIXES[i].powerCap;\r\n          }\r\n      }\r\n      \r\n      captain.abilityAvailTime = GAME_END + 10 seconds; //Prevent ability from being used again in current round\r\n      \r\n      emit CaptainAbilityUsed(_captainID);\r\n  }\r\n  \r\n  function useAbility(uint256 _phoenixID) whenNotPaused gameInProgress public {\r\n      //phoenixID must be between 3 to 18\r\n      require(_phoenixID > 2);\r\n      require(_phoenixID < 19);\r\n      \r\n      Phoenix storage phoenix = PHOENIXES[_phoenixID];\r\n      require(msg.sender == phoenix.currentOwner); //Only owner of phoenix can use ability\r\n      require(now >= phoenix.abilityAvailTime); //Ability must be available for use\r\n\r\n      //calculate which pool to take from\r\n      //ids 3-6, 15-18 --> red\r\n      //ids 7-14 --> blue\r\n      if (_phoenixID >=7 &&  _phoenixID <= 14) {\r\n          require(POOLS[1] > 0); //blue pool\r\n          uint256 payout = POOLS[1].mul(phoenix.currentPower).div(DENOMINATOR); //calculate payout\r\n          POOLS[1] = POOLS[1].sub(payout); //subtract from pool\r\n      } else {\r\n          require(POOLS[0] > 0); //red pool\r\n          payout = POOLS[0].mul(phoenix.currentPower).div(DENOMINATOR);\r\n          POOLS[0] = POOLS[0].sub(payout);\r\n      }\r\n      \r\n      //determine which team the phoenix is on\r\n      if (_phoenixID < 11) { //red team\r\n          bool isRed = true; //to determine which team to distribute the 9% payout to\r\n          SCORES[0] = SCORES[0].add(payout); //add payout to score (ie. payout is the score)\r\n      } else {\r\n          //blue team\r\n          isRed = false;\r\n          SCORES[1] = SCORES[1].add(payout);\r\n      }\r\n      \r\n      uint256 ownerCut = payout;\r\n      \r\n      //drop power of phoenix\r\n      decreasePower(_phoenixID);\r\n      \r\n      //decrease phoenix price\r\n      decreasePrice(_phoenixID);\r\n      \r\n      //reset cooldown\r\n      phoenix.abilityAvailTime = now + phoenix.cooldown;\r\n\r\n      // set previous owner to be current owner, so he can get the 1% dividend from subsequent purchases\r\n      phoenix.previousOwner = msg.sender;\r\n      \r\n      // Calculate the different cuts\r\n      // 2% to rainbow\r\n      uint256 cut = payout.div(50); //2%\r\n      ownerCut = ownerCut.sub(cut);\r\n      userFunds[PHOENIXES[0].currentOwner] = userFunds[PHOENIXES[0].currentOwner].add(cut);\r\n      \r\n      // 1% to dev\r\n      cut = payout.div(100); //1%\r\n      ownerCut = ownerCut.sub(cut);\r\n      distributeDevCut(cut);\r\n      \r\n      //9% to team\r\n      cut = payout.mul(9).div(100); //9%\r\n      ownerCut = ownerCut.sub(cut);\r\n      distributeTeamCut(isRed,cut);\r\n      \r\n      //Finally, send money to user\r\n      sendFunds(msg.sender,ownerCut);\r\n      \r\n      emit PhoenixAbilityUsed(_phoenixID,ownerCut,phoenix.price,phoenix.currentPower,phoenix.abilityAvailTime,phoenix.previousOwner);\r\n  }\r\n  \r\n  function decreasePrice(uint256 _phoenixID) private {\r\n      Phoenix storage phoenix = PHOENIXES[_phoenixID];\r\n      if (phoenix.price >= 0.75 ether) {\r\n        phoenix.price = phoenix.price.mul(20).div(100); //drop to 20%\r\n      } else {\r\n        phoenix.price = phoenix.price.mul(10).div(100); //drop to 10%\r\n        if (phoenix.price < BASE_PRICE) {\r\n          phoenix.price = BASE_PRICE;\r\n          }\r\n      }\r\n  }\r\n  \r\n  function decreasePower(uint256 _phoenixID) private {\r\n      Phoenix storage phoenix = PHOENIXES[_phoenixID];\r\n      phoenix.currentPower = phoenix.currentPower.sub(phoenix.powerDrop);\r\n      //handle boundary case where currentPower is below basePower\r\n      if (phoenix.currentPower < phoenix.basePower) {\r\n          phoenix.currentPower = phoenix.basePower; \r\n      }\r\n  }\r\n  \r\n  function distributeTeamCut(bool _isRed, uint256 _cut) private {\r\n      /* \r\n      Note that captain + phoenixes payout percentages add up to 100%.\r\n      Captain: 24%\r\n      Phoenix 1 & 5: 4% x 2 = 8%\r\n      Phoenix 2 & 6: 7% x 2 = 14%\r\n      Phoenix 3 & 7: 11% x 2 = 22%\r\n      Phoenix 4 & 8: 16% x 2 = 32%\r\n      */\r\n      \r\n      if (_isRed) {\r\n          uint captainID = 1;\r\n          uint groupIDStart = 3;\r\n          uint groupIDEnd = 11;\r\n      } else {\r\n          captainID = 2;\r\n          groupIDStart = 11;\r\n          groupIDEnd = 19;\r\n      }\r\n      \r\n      //calculate and transfer capt payout\r\n      uint256 payout = PHOENIXES[captainID].payoutPercentage.mul(_cut).div(DENOMINATOR);\r\n      userFunds[PHOENIXES[captainID].currentOwner] = userFunds[PHOENIXES[captainID].currentOwner].add(payout);\r\n      \r\n      for (uint i = groupIDStart; i < groupIDEnd; i++) {\r\n          //calculate how much to pay to each phoenix owner in the team\r\n          payout = PHOENIXES[i].payoutPercentage.mul(_cut).div(DENOMINATOR);\r\n          //transfer payout\r\n          userFunds[PHOENIXES[i].currentOwner] = userFunds[PHOENIXES[i].currentOwner].add(payout);\r\n      }\r\n  }\r\n  \r\n  function endGame() gameHasEnded public {\r\n      GAME_STARTED = false; //to allow this function to only be called once after the end of every round\r\n      uint256 remainingPoolAmt = POOLS[0].add(POOLS[1]); //add the 2 pools together\r\n      \r\n      //Distribution structure -> 15% rainbow, 75% teams, 10% for next game\r\n      uint256 rainbowCut = remainingPoolAmt.mul(15).div(100); //15% to rainbow\r\n      uint256 teamCut = remainingPoolAmt.mul(75).div(100); //75% to teams\r\n      remainingPoolAmt = remainingPoolAmt.sub(rainbowCut).sub(teamCut);\r\n      \r\n      //distribute 15% to rainbow phoenix owner\r\n      userFunds[PHOENIXES[0].currentOwner] = userFunds[PHOENIXES[0].currentOwner].add(rainbowCut);\r\n      \r\n      //distribute 75% to teams\r\n      //in the unlikely event of a draw, split evenly, so 37.5% cut to each team\r\n      if (SCORES[0] == SCORES[1]) {\r\n          teamCut = teamCut.div(2);\r\n          distributeTeamCut(true,teamCut); //redTeam\r\n          distributeTeamCut(false,teamCut); //blueTeam\r\n      } else {\r\n          //25% to losing team\r\n          uint256 losingTeamCut = teamCut.div(3); // 1 third of 75% = 25%\r\n          //SCORES[0] = red, SCORES[1] = blue\r\n          //if red > blue, then award to redTeam, so bool _isRed = red > blue\r\n          distributeTeamCut((SCORES[0] > SCORES[1]),losingTeamCut);\r\n          \r\n          //50% to winning team\r\n          teamCut = teamCut.sub(losingTeamCut); //take the remainder\r\n          //inverse of the winning condition\r\n          distributeTeamCut(!(SCORES[0] > SCORES[1]),teamCut); \r\n      }\r\n      \r\n      // 5% to each pool for next game\r\n      POOLS[0] = remainingPoolAmt.div(2);\r\n      POOLS[1] = POOLS[0];\r\n      \r\n      resetPhoenixes();\r\n      emit GameEnded();\r\n  }\r\n  \r\n  function resetPhoenixes() private {\r\n      //reset attributes of phoenixes\r\n      PHOENIXES[0].price = 0.01 ether;\r\n      PHOENIXES[1].price = 0.005 ether;\r\n      PHOENIXES[2].price = 0.005 ether;\r\n      \r\n      for (uint i = 0; i < 3; i++) {\r\n          PHOENIXES[i].previousOwner = PHOENIXES[i].currentOwner;\r\n      }\r\n      \r\n      for (i = 3; i < 19; i++) {\r\n          //Reset price and power levels of phoenixes\r\n          //Ability time will be set during game start\r\n          Phoenix storage phoenix = PHOENIXES[i];\r\n          phoenix.price = BASE_PRICE;\r\n          phoenix.currentPower = phoenix.basePower;\r\n          phoenix.previousOwner = phoenix.currentOwner;\r\n      }\r\n  }\r\n  \r\n/**\r\n* @dev Try to send funds immediately\r\n* If it fails, user has to manually withdraw.\r\n*/\r\n  function sendFunds(address _user, uint256 _payout) private {\r\n    if (!_user.send(_payout)) {\r\n      userFunds[_user] = userFunds[_user].add(_payout);\r\n    }\r\n  }\r\n\r\n/**\r\n* @dev Withdraw dev cut.\r\n*/\r\n  function devWithdraw() public {\r\n    uint256 funds = devFunds[msg.sender];\r\n    require(funds > 0);\r\n    devFunds[msg.sender] = 0;\r\n    msg.sender.transfer(funds);\r\n  }\r\n\r\n/**\r\n* @dev Users can withdraw their funds\r\n*/\r\n  function withdrawFunds() public {\r\n    uint256 funds = userFunds[msg.sender];\r\n    require(funds > 0);\r\n    userFunds[msg.sender] = 0;\r\n    msg.sender.transfer(funds);\r\n    emit WithdrewFunds(msg.sender);\r\n  }\r\n\r\n/**\r\n* @dev Transfer contract balance in case of bug or contract upgrade\r\n*/ \r\n function upgradeContract(address _newContract) public onlyOwner whenPaused {\r\n        _newContract.transfer(address(this).balance);\r\n }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SCORES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phoenixID\",\"type\":\"uint256\"}],\"name\":\"useAbility\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_captainID\",\"type\":\"uint256\"}],\"name\":\"useCaptainAbility\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"devFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subDevOne\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PHOENIXES\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"payoutPercentage\",\"type\":\"uint256\"},{\"name\":\"abilityAvailTime\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"uint256\"},{\"name\":\"cooldownDecreaseAmt\",\"type\":\"uint256\"},{\"name\":\"basePower\",\"type\":\"uint256\"},{\"name\":\"currentPower\",\"type\":\"uint256\"},{\"name\":\"powerIncreaseAmt\",\"type\":\"uint256\"},{\"name\":\"powerDrop\",\"type\":\"uint256\"},{\"name\":\"powerCap\",\"type\":\"uint256\"},{\"name\":\"previousOwner\",\"type\":\"address\"},{\"name\":\"currentOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[19]\"}],\"name\":\"setPhoenixOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phoenixID\",\"type\":\"uint256\"}],\"name\":\"purchasePhoenix\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAME_STARTED\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"POOLS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAME_END\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"upgradeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subDevTwo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_subDevOne\",\"type\":\"address\"},{\"name\":\"_subDevTwo\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phoenixID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentPower\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"abilityAvailTime\",\"type\":\"uint256\"}],\"name\":\"PhoenixPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"captainID\",\"type\":\"uint256\"}],\"name\":\"CaptainAbilityUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phoenixID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentPower\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"abilityAvailTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"PhoenixAbilityUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"WithdrewFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"CryptoPhoenixesCivilWar","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000096c3170d0981b7321c618ff35aade41dffedaac90000000000000000000000000a8831f8dc2d96501571fa25b8ce32c673639123","Library":"","SwarmSource":"bzzr://2c7336572c7e8c2bc850adaa4f892121789e74630b487d53a609af3fc736d6b0"}]}