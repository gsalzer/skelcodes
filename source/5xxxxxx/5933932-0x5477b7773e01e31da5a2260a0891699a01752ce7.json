{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor () public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ninterface Token {\r\n    function transfer(address _to, uint256 _amount)external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function decimals()external view returns (uint8);\r\n}\r\n\r\n/**\r\n * @title Vault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Funds will be transferred to owner on adhoc requests\r\n */\r\ncontract Vault is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) public deposited;\r\n    address public wallet;\r\n    \r\n    event Withdrawn(address _wallet);\r\n    \r\n    constructor (address _wallet) public {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;\r\n    }\r\n\r\n    function deposit(address investor) public onlyOwner  payable{\r\n        \r\n        deposited[investor] = deposited[investor].add(msg.value);\r\n        \r\n    }\r\n\r\n    \r\n    function withdrawToWallet() public onlyOwner {\r\n     wallet.transfer(address(this).balance);\r\n     emit Withdrawn(wallet);\r\n  }\r\n  \r\n}\r\n\r\n\r\ncontract CLXTokenSale is Ownable{\r\n      using SafeMath for uint256;\r\n      \r\n      //Token to be used for this sale\r\n      Token public token;\r\n      \r\n      //All funds will go into this vault\r\n      Vault public vault;\r\n      \r\n     // This mapping stores the addresses of whitelisted users\r\n      mapping(address => bool) public whitelisted;\r\n  \r\n      //rate of token in ether 1ETH = 8000 CLX\r\n      uint256 public rate = 8000;\r\n      \r\n      /*\r\n      *There will be 2 phases\r\n      * 1. Pre-sale\r\n      * 2. ICO Phase 1\r\n      */\r\n\r\n      struct PhaseInfo{\r\n          uint256 hardcap;\r\n          uint256 startTime;\r\n          uint256 endTime;\r\n          uint8   bonusPercentages;\r\n          uint256 minEtherContribution;\r\n          uint256 weiRaised;\r\n      }\r\n      \r\n         \r\n      //info of each phase\r\n      PhaseInfo[] public phases;\r\n      \r\n      //Total funding\r\n      uint256 public totalFunding;\r\n\r\n      //total tokens available for sale considering 8 decimal places\r\n      uint256 tokensAvailableForSale = 17700000000000000;\r\n      \r\n      \r\n      uint8 public noOfPhases;\r\n      \r\n      \r\n      //Keep track of whether contract is up or not\r\n      bool public contractUp;\r\n      \r\n      //Keep track of whether the sale has ended or not\r\n      bool public saleEnded;\r\n\r\n       //Keep track of emergency stop\r\n      bool public ifEmergencyStop ;\r\n      \r\n      //Event to trigger Sale stop\r\n      event SaleStopped(address _owner, uint256 time);\r\n      \r\n      //Event to trigger Sale restart\r\n      event SaleRestarted(address _owner, uint256 time);\r\n      \r\n      //Event to trigger normal flow of sale end\r\n      event Finished(address _owner, uint256 time);\r\n      \r\n       //Event to add user to the whitelist\r\n      event LogUserAdded(address user);\r\n\r\n      //Event to remove user to the whitelist\r\n      event LogUserRemoved(address user);\r\n    \r\n     /**\r\n     * event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n    \r\n    //modifiers    \r\n    modifier _contractUp(){\r\n        require(contractUp);\r\n        _;\r\n    }\r\n  \r\n     modifier nonZeroAddress(address _to) {\r\n        require(_to != address(0));\r\n        _;\r\n    }\r\n    \r\n    modifier _saleEnded() {\r\n        require(saleEnded);\r\n        _;\r\n    }\r\n    \r\n    modifier _saleNotEnded() {\r\n        require(!saleEnded);\r\n        _;\r\n    }\r\n\r\n    modifier _ifNotEmergencyStop() {\r\n        require(!ifEmergencyStop);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *     @dev Check if sale contract has enough tokens on its account balance \r\n    *     to reward all possible participations within sale period\r\n    */\r\n    function powerUpContract() external onlyOwner {\r\n        // Contract should not be powered up previously\r\n        require(!contractUp);\r\n\r\n        // Contract should have enough CLX credits\r\n        require(token.balanceOf(this) >= tokensAvailableForSale);\r\n        \r\n        //activate the sale process\r\n        contractUp = true;\r\n    }\r\n    \r\n    //for Emergency stop of the sale\r\n    function emergencyStop() external onlyOwner _contractUp {\r\n        require(!ifEmergencyStop);\r\n \r\n        ifEmergencyStop = true;  \r\n        \r\n        emit SaleStopped(msg.sender, now);\r\n    }\r\n\r\n    //to restart the sale after emergency stop\r\n    function emergencyRestart() external onlyOwner _contractUp  {\r\n        require(ifEmergencyStop);\r\n       \r\n        ifEmergencyStop = false;\r\n\r\n        emit SaleRestarted(msg.sender, now);\r\n    }\r\n  \r\n      // @return true if all the tiers has been ended\r\n  function saleTimeOver() public view returns (bool) {\r\n    \r\n    return (phases[noOfPhases-1].endTime != 0);\r\n  }\r\n  \r\n   \r\n  /**\r\n  * @dev Can be called only once. The method to allow owner to set tier information\r\n  * @param _noOfPhases The integer to set number of tiers\r\n  * @param _startTimes The array containing start time of each tier\r\n  * @param _endTimes The array containing end time of each tier\r\n  * @param _hardCaps The array containing hard cap for each tier\r\n  * @param _bonusPercentages The array containing bonus percentage for each tier\r\n  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3 and 4 .\r\n  * Sales hard cap will be the hard cap of last tier\r\n  */\r\n  function setTiersInfo(uint8 _noOfPhases, uint256[] _startTimes, uint256[] _endTimes, uint256[] _hardCaps ,uint256[] _minEtherContribution, uint8[2] _bonusPercentages)private {\r\n    \r\n    \r\n    require(_noOfPhases == 2);\r\n    \r\n    //Each array should contain info about each tier\r\n    require(_startTimes.length ==  2);\r\n   require(_endTimes.length == _noOfPhases);\r\n    require(_hardCaps.length == _noOfPhases);\r\n    require(_bonusPercentages.length == _noOfPhases);\r\n    \r\n    noOfPhases = _noOfPhases;\r\n    \r\n    for(uint8 i = 0; i < _noOfPhases; i++){\r\n\r\n        require(_hardCaps[i] > 0);\r\n       \r\n        if(i>0){\r\n\r\n            phases.push(PhaseInfo({\r\n                hardcap:_hardCaps[i],\r\n                startTime:_startTimes[i],\r\n                endTime:_endTimes[i],\r\n                minEtherContribution : _minEtherContribution[i],\r\n                bonusPercentages:_bonusPercentages[i],\r\n                weiRaised:0\r\n            }));\r\n        }\r\n        else{\r\n            //start time of tier1 should be greater than current time\r\n            require(_startTimes[i] > now);\r\n          \r\n            phases.push(PhaseInfo({\r\n                hardcap:_hardCaps[i],\r\n                startTime:_startTimes[i],\r\n                minEtherContribution : _minEtherContribution[i],\r\n                endTime:_endTimes[i],\r\n                bonusPercentages:_bonusPercentages[i],\r\n                weiRaised:0\r\n            }));\r\n        }\r\n    }\r\n  }\r\n  \r\n  \r\n    /**\r\n    * @dev Constructor method\r\n    * @param _tokenToBeUsed Address of the token to be used for Sales\r\n    * @param _wallet Address of the wallet which will receive the collected funds\r\n    */  \r\n    constructor (address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\r\n        \r\n        token = Token(_tokenToBeUsed);\r\n        vault = new Vault(_wallet);\r\n        \r\n        uint256[] memory startTimes = new uint256[](2);\r\n        uint256[] memory endTimes = new uint256[](2);\r\n        uint256[] memory hardCaps = new uint256[](2);\r\n        uint256[] memory minEtherContribution = new uint256[](2);\r\n        uint8[2] memory bonusPercentages;\r\n        \r\n        //pre-sales\r\n        startTimes[0] = 1531180800; //JULY 10, 2018 00:00 AM GMT\r\n        endTimes[0] = 0; //NO END TIME INITIALLY\r\n        hardCaps[0] = 7500 ether;\r\n        minEtherContribution[0] = 0.3 ether;\r\n        bonusPercentages[0] = 20;\r\n        \r\n        //phase-1: Public Sale\r\n        startTimes[1] = 0; //NO START TIME INITIALLY\r\n        endTimes[1] = 0; //NO END TIME INITIALLY\r\n        hardCaps[1] = 12500 ether;\r\n        minEtherContribution[1] = 0.1 ether;\r\n        bonusPercentages[1] = 5;\r\n        \r\n        setTiersInfo(2, startTimes, endTimes, hardCaps, minEtherContribution, bonusPercentages);\r\n        \r\n    }\r\n    \r\n   //Fallback function used to buytokens\r\n   function()public payable{\r\n       buyTokens(msg.sender);\r\n   }\r\n\r\n   function startNextPhase() public onlyOwner _saleNotEnded _contractUp _ifNotEmergencyStop returns(bool){\r\n\r\n       int8 currentPhaseIndex = getCurrentlyRunningPhase();\r\n       \r\n       require(currentPhaseIndex == 0);\r\n\r\n       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\r\n       \r\n       uint256 tokensLeft;\r\n       uint256 tokensInPreICO = 7200000000000000; //considering 8 decimal places\r\n             \r\n       //Checking if tokens are left after the Pre ICO sale, if left, transfer all to the owner   \r\n       if(currentlyRunningPhase.weiRaised <= 7500 ether) {\r\n           tokensLeft = tokensInPreICO.sub(currentlyRunningPhase.weiRaised.mul(9600).div(10000000000));\r\n           token.transfer(msg.sender, tokensLeft);\r\n       }\r\n       \r\n       phases[0].endTime = now;\r\n       phases[1].startTime = now;\r\n\r\n       return true;\r\n       \r\n   }\r\n\r\n   /**\r\n   * @dev Must be called after sale ends, to do some extra finalization\r\n   * work. It finishes the sale, sends the unsold tokens to the owner's address \r\n   * and transfer the remaining funds in contract to the owner.\r\n   */\r\n  function finishSale() public onlyOwner _contractUp _saleNotEnded returns (bool){\r\n      \r\n      int8 currentPhaseIndex = getCurrentlyRunningPhase();\r\n      require(currentPhaseIndex == 1);\r\n      \r\n      PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\r\n       \r\n      uint256 tokensLeft;\r\n      uint256 tokensInPublicSale = 10500000000000000; //considering 8 decimal places\r\n          \r\n          //Checking if tokens are left after the Public sale, if left, transfer all to the owner   \r\n       if(currentlyRunningPhase.weiRaised <= 12500 ether) {\r\n           tokensLeft = tokensInPublicSale.sub(currentlyRunningPhase.weiRaised.mul(8400).div(10000000000));\r\n           token.transfer(msg.sender, tokensLeft);\r\n       }\r\n      //End the sale\r\n      saleEnded = true;\r\n      \r\n      //Set the endTime of Public Sale\r\n      phases[noOfPhases-1].endTime = now;\r\n      \r\n      emit Finished(msg.sender, now);\r\n      return true;\r\n  }\r\n\r\n   \r\n   /**\r\n   * @dev Low level token purchase function\r\n   * @param beneficiary The address who will receive the tokens for this transaction\r\n   */\r\n   function buyTokens(address beneficiary)public _contractUp _saleNotEnded _ifNotEmergencyStop nonZeroAddress(beneficiary) payable returns(bool){\r\n       \r\n       require(whitelisted[beneficiary]);\r\n\r\n       int8 currentPhaseIndex = getCurrentlyRunningPhase();\r\n       assert(currentPhaseIndex >= 0);\r\n       \r\n        // recheck this for storage and memory\r\n       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\r\n       \r\n       \r\n       uint256 weiAmount = msg.value;\r\n\r\n       //Check hard cap for this phase has not been reached\r\n       require(weiAmount.add(currentlyRunningPhase.weiRaised) <= currentlyRunningPhase.hardcap);\r\n       \r\n       //check the minimum ether contribution\r\n       require(weiAmount >= currentlyRunningPhase.minEtherContribution);\r\n       \r\n       \r\n       uint256 tokens = weiAmount.mul(rate).div(10000000000);//considering decimal places to be 8 for token\r\n       \r\n       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningPhase.bonusPercentages);\r\n\r\n\r\n       totalFunding = totalFunding.add(weiAmount);\r\n             \r\n       currentlyRunningPhase.weiRaised = currentlyRunningPhase.weiRaised.add(weiAmount);\r\n       \r\n       vault.deposit.value(msg.value)(msg.sender);\r\n       \r\n       token.transfer(beneficiary, bonusedTokens);\r\n       \r\n       emit TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\r\n\r\n       return true;\r\n       \r\n   }\r\n   \r\n   //Check balance of token of each phase\r\n   function tokensLeftInPhase(int8 phase) public view returns(uint256) {\r\n       \r\n       PhaseInfo storage currentlyRunningPhase = phases[uint256(phase)];\r\n       uint256 tokensLeft;\r\n       \r\n       if(phase == 0) {\r\n            uint256 tokensInPreICO= 7200000000000000;\r\n            tokensLeft = tokensInPreICO.sub(currentlyRunningPhase.weiRaised.mul(9600).div(10000000000));\r\n            return tokensLeft;\r\n       }\r\n       else {\r\n           uint256 tokensInPublicSale = 10500000000000000;\r\n           tokensLeft = tokensInPublicSale.sub(currentlyRunningPhase.weiRaised.mul(8400).div(10000000000));\r\n            return tokensLeft;\r\n           }\r\n   }\r\n   \r\n    /**\r\n    *@dev Method to calculate bonus for the user as per currently running phase and contribution by the user\r\n    * @param tokens Total tokens purchased by the user\r\n    * @param percentage Array of bonus percentages for the phase\r\n    */\r\n     function applyBonus(uint256 tokens, uint8 percentage) private pure returns  (uint256) {\r\n         \r\n         uint256 tokensToAdd = 0;\r\n         tokensToAdd = tokens.mul(percentage).div(100);\r\n         return tokens.add(tokensToAdd);\r\n    }\r\n    \r\n   /**\r\n    * @dev returns the currently running tier index as per time\r\n    * Return -1 if no tier is running currently\r\n    * */\r\n   function getCurrentlyRunningPhase()public view returns(int8){\r\n      for(uint8 i=0;i<noOfPhases;i++){\r\n\r\n          if(phases[i].startTime!=0 && now>=phases[i].startTime && phases[i].endTime == 0){\r\n              return int8(i);\r\n          }\r\n      }   \r\n      return -1;\r\n   }\r\n\r\n   \r\n   // Add a user to the whitelist\r\n   function addUser(address user) public nonZeroAddress(user) onlyOwner returns (bool) {\r\n\r\n       require(whitelisted[user] == false);\r\n       \r\n       whitelisted[user] = true;\r\n\r\n       emit LogUserAdded(user);\r\n       \r\n       return true;\r\n\r\n    }\r\n\r\n    // Remove an user from the whitelist\r\n    function removeUser(address user) public nonZeroAddress(user) onlyOwner returns(bool){\r\n      \r\n        require(whitelisted[user] = true);\r\n\r\n        whitelisted[user] = false;\r\n        \r\n        emit LogUserRemoved(user);\r\n        \r\n        return true;\r\n\r\n\r\n    }\r\n\r\n    // Add many users in one go to the whitelist\r\n    function addManyUsers(address[] users)public onlyOwner {\r\n        \r\n        require(users.length < 100);\r\n\r\n        for (uint8 index = 0; index < users.length; index++) {\r\n\r\n             whitelisted[users[index]] = true;\r\n\r\n             emit LogUserAdded(users[index]);\r\n\r\n        }\r\n    }\r\n\r\n     //Method to check whether a user is there in the whitelist or not\r\n    function checkUser(address user) onlyOwner public view  returns (bool){\r\n        return whitelisted[user];\r\n    }\r\n   \r\n   //method to check the user balance\r\n   function checkUserTokenBalance(address _user) public view returns(uint256) {\r\n       return token.balanceOf(_user);\r\n   }\r\n   \r\n   /**\r\n   * @dev Get funding info of user/address.\r\n   * It will return how much funding the user has made in terms of wei\r\n   */\r\n   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\r\n       return vault.deposited(_user);\r\n   }\r\n\r\n   /**\r\n   * @dev Allow owner to withdraw funds to his wallet anytime in between the sale process \r\n   */\r\n\r\n    function withDrawFunds()public onlyOwner _contractUp {\r\n      \r\n       vault.withdrawToWallet();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getFundingInfoForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ifEmergencyStop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentlyRunningPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"int8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phases\",\"outputs\":[{\"name\":\"hardcap\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"bonusPercentages\",\"type\":\"uint8\"},{\"name\":\"minEtherContribution\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkUserTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"powerUpContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"phase\",\"type\":\"int8\"}],\"name\":\"tokensLeftInPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleTimeOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishSale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noOfPhases\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyRestart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractUp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withDrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNextPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"addManyUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenToBeUsed\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SaleStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SaleRestarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Finished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogUserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogUserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CLXTokenSale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004e2f7de090ed3a32a3ba1940e5c01f8e24ddf5120000000000000000000000002776d085a799be3cf78c269baaec249763397fb4","Library":"","SwarmSource":"bzzr://f995800bc838aa049a6dac4bd1b62b0ebf851596d26c73df14e0174214d52319"}]}