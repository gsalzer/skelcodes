{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\nlibrary Shared {\r\n    struct Spinner {\r\n        string name;\r\n        uint256 class;\r\n        uint8 speed;\r\n        uint8 momentum;\r\n        uint8 inertia;\r\n        uint256 _id;\r\n        address spinnerOwner;\r\n        uint256 created;\r\n        uint256 purchasePrice;\r\n        uint256 purchaseIndex;    \r\n    }\r\n\r\n    struct SpinnerMint {\r\n        bool purchasable;\r\n        uint startPrice;\r\n        uint currentPrice;\r\n        uint returnPrice;\r\n    }\r\n}\r\n\r\n\r\ncontract SpinnerDatabase is Ownable {\r\n    \r\n    uint256 public totalSpinners;\r\n    uint256 public availableThemedSpinners;\r\n    uint256 public maxSpinners; //prevent hoarding\r\n    uint256 public currentUniqueSpinnerPrice;\r\n    uint256 spinnerModulus = 16777216; //16,777,216 or 256^3 possible unique spinners\r\n    uint256 public uniqueSpinners;\r\n\r\n    address[] public uniqueSpinnerOwners;\r\n    \r\n    address public owner;\r\n    address public processorAddress;\r\n    address public factoryAddress;\r\n    address public marketAddress;\r\n\r\n    function setProcessorAddress(address processAddress) public onlyOwner {\r\n        processorAddress = processAddress;\r\n    }\r\n\r\n    function setFactoryAddress(address factorAddress) public onlyOwner {\r\n        factoryAddress = factorAddress;\r\n    }\r\n\r\n    function setMarketAddress(address market) public onlyOwner {\r\n        marketAddress = market;\r\n    }\r\n\r\n    mapping (uint => uint) public spinnerCounts;\r\n    mapping (address => uint) public balances;\r\n    mapping (address => uint) public earn;\r\n    mapping (uint => Shared.SpinnerMint) public themedSpinners;\r\n    mapping (address => Shared.Spinner[]) public SpinnersByAddress;\r\n    mapping (uint => address[]) public OwnersBySpinner;\r\n    mapping (address => uint) public SpinnerCountsByAddress;\r\n    mapping (uint => uint) public originalPricesBySpinner;\r\n    mapping (uint => uint) public spinnerCountsByType;\r\n\r\n    function SpinnerDatabase() public {\r\n        totalSpinners = 0;\r\n        maxSpinners = 512;\r\n        availableThemedSpinners = 0;\r\n        uniqueSpinners = 0;\r\n        currentUniqueSpinnerPrice = 1 ether;\r\n        owner = msg.sender;\r\n        \r\n    }\r\n\r\n    function addSpinner(string _name, uint _type, address creator, uint value, uint8 speed, uint8 momentum, uint8 inertia) external {\r\n        require(msg.sender == factoryAddress);\r\n        uint256 _id = uint(uint(keccak256(_type)) + uint(keccak256(block.timestamp + uint(keccak256(msg.sender)))));\r\n        uint256 purchaseIndex = spinnerCountsByType[_type];\r\n        SpinnersByAddress[creator].push(Shared.Spinner(_name, _type, speed, momentum, inertia, _id, creator, block.timestamp, value, purchaseIndex));\r\n        incrementBalances(_type); //payout owners\r\n        OwnersBySpinner[_type].push(creator); //Add new owner of Spinner\r\n        incrementThemedSpinnerPrice(_type); //increase price\r\n        spinnerCounts[_type]++; //Total Purchased of Spinner\r\n        totalSpinners++; //Total Purchased overall\r\n        SpinnerCountsByAddress[creator]++; //Total Owned\r\n        spinnerCountsByType[_type]++; //increment count of type    \r\n    }\r\n\r\n    function addUniqueSpinner(string _name, uint _type, address creator, uint value, uint8 speed, uint8 momentum, uint8 inertia) external {\r\n        require(msg.sender == factoryAddress); \r\n        uint256 _id = uint(uint(keccak256(_type)) + uint(keccak256(block.timestamp + uint(keccak256(msg.sender)))));\r\n        uint256 purchaseIndex = uniqueSpinners;\r\n        SpinnersByAddress[creator].push(Shared.Spinner(_name, _type, speed, momentum, inertia, _id, creator, block.timestamp, value, purchaseIndex));\r\n        uniqueSpinnerOwners.push(creator); //Add new owner of Spinner\r\n        uniqueSpinners++; //Total Purchased of Spinner\r\n        totalSpinners++; //Total Purchased overall\r\n        SpinnerCountsByAddress[creator]++; //Total Owned\r\n    }\r\n\r\n    function changeOwnership(string _name, uint _id, uint _type, address originalOwner, address newOwner) external {\r\n        require(msg.sender == marketAddress);\r\n        uint256 totalSpinnersOwned = SpinnerCountsByAddress[originalOwner];\r\n        for (uint256 i = 0; i < totalSpinnersOwned; i++) {\r\n            uint mySpinnerId = getSpinnerData(originalOwner, i)._id;\r\n            if (mySpinnerId == _id) {\r\n                executeOwnershipChange(i, _id, _type, originalOwner, newOwner, _name);\r\n                break;\r\n            }\r\n        }\r\n        changeOwnershipStepTwo(_type, originalOwner, newOwner);\r\n    }\r\n\r\n    function changeOwnershipStepTwo(uint _type, address originalOwner, address newOwner) private {\r\n        uint totalSpinnersOfType = spinnerCountsByType[_type];\r\n        address[] storage owners = OwnersBySpinner[_type];\r\n        for (uint j = 0; j < totalSpinnersOfType; j++) {\r\n            if (owners[j] == originalOwner) {\r\n                owners[j] = newOwner;\r\n                break;\r\n            }\r\n        }\r\n        OwnersBySpinner[_type] = owners;    \r\n    }\r\n\r\n    function changeUniqueOwnership(string _name, uint _id, address originalOwner, address newOwner) external {\r\n        require(msg.sender == marketAddress);\r\n        uint256 totalSpinnersOwned = SpinnerCountsByAddress[originalOwner];\r\n        for (uint256 i = 0; i < totalSpinnersOwned; i++) {\r\n            uint mySpinnerId = getSpinnerData(originalOwner, i)._id;\r\n            if (mySpinnerId == _id) {\r\n                uint spinnerType = getSpinnerData(originalOwner, i).class;\r\n                executeOwnershipChange(i, _id, spinnerType, originalOwner, newOwner, _name);\r\n                break;\r\n            }\r\n        }\r\n        changeUniqueOwnershipStepTwo(originalOwner, newOwner);\r\n    }\r\n    \r\n    function changeUniqueOwnershipStepTwo(address originalOwner, address newOwner) private {\r\n        uint totalUniqueSpinners = uniqueSpinners;\r\n        for (uint j = 0; j < totalUniqueSpinners; j++) {\r\n            if (uniqueSpinnerOwners[j] == originalOwner) {\r\n                uniqueSpinnerOwners[j] = newOwner;\r\n                break;\r\n            }\r\n        }  \r\n    }\r\n\r\n    function executeOwnershipChange(uint i, uint _id, uint _type, address originalOwner, address newOwner, string _name) private {\r\n        uint8 spinnerSpeed = getSpinnerData(originalOwner, i).speed;\r\n        uint8 spinnerMomentum = getSpinnerData(originalOwner, i).momentum;\r\n        uint8 spinnerInertia = getSpinnerData(originalOwner, i).inertia;\r\n        uint spinnerTimestamp = getSpinnerData(originalOwner, i).created;\r\n        uint spinnerPurchasePrice = getSpinnerData(originalOwner, i).purchasePrice;\r\n        uint spinnerPurchaseIndex  = getSpinnerData(originalOwner, i).purchaseIndex;\r\n        SpinnerCountsByAddress[originalOwner]--;\r\n        delete SpinnersByAddress[originalOwner][i];\r\n        SpinnersByAddress[newOwner].push(Shared.Spinner(_name, _type, spinnerSpeed, spinnerMomentum, spinnerInertia, _id, newOwner, spinnerTimestamp, spinnerPurchasePrice, spinnerPurchaseIndex));\r\n        SpinnerCountsByAddress[newOwner]++;  \r\n    }\r\n\r\n\r\n    function generateThemedSpinners(uint seed, uint price, uint returnPrice) external {\r\n        require(msg.sender == factoryAddress);\r\n        themedSpinners[seed] = Shared.SpinnerMint(true, price, price, returnPrice);\r\n        originalPricesBySpinner[seed] = price;\r\n        availableThemedSpinners++;\r\n    }\r\n\r\n    function incrementThemedSpinnerPrice(uint seed) private {\r\n        themedSpinners[seed].currentPrice = themedSpinners[seed].currentPrice + themedSpinners[seed].returnPrice;\r\n    }\r\n\r\n    function getSpinnerPrice(uint seed) public view returns (uint) {\r\n        return themedSpinners[seed].currentPrice;\r\n    }\r\n\r\n    function getUniqueSpinnerPrice() public view returns (uint) {\r\n        return currentUniqueSpinnerPrice;\r\n    }\r\n\r\n    function setUniqueSpinnerPrice(uint cost) public onlyOwner {\r\n        currentUniqueSpinnerPrice = cost;\r\n    }\r\n\r\n    function getBalance(address walletAddress) public view returns (uint) {\r\n        return balances[walletAddress];\r\n    }\r\n\r\n    function getSpinnerData(address walletAddress, uint index) public view returns (Shared.Spinner) {\r\n        return SpinnersByAddress[walletAddress][index];\r\n    } \r\n\r\n    function getOriginalSpinnerPrice(uint256 _id) public view returns (uint) {\r\n        return originalPricesBySpinner[_id];\r\n    }\r\n\r\n    function doesAddressOwnSpinner(address walletAddress, uint _id) public view returns (bool) {\r\n        uint count = spinnerCountsByType[_id + spinnerModulus];\r\n        for (uint i=0; i<count; i++) {\r\n            if (keccak256(SpinnersByAddress[walletAddress][i].spinnerOwner) == keccak256(walletAddress)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function incrementBalances(uint _type) private {\r\n        uint totalPurchased = spinnerCounts[_type];\r\n        address[] storage owners = OwnersBySpinner[_type];\r\n        uint payout = themedSpinners[_type].returnPrice;\r\n        for (uint i = 0; i < totalPurchased; i++) {\r\n            balances[owners[i]] = balances[owners[i]] + payout;\r\n            earn[owners[i]] = earn[owners[i]] + payout;\r\n        }\r\n    }\r\n\r\n    function decrementBalance(address walletAddress, uint amount) external {\r\n        require(msg.sender == processorAddress);\r\n        require(amount <= balances[walletAddress]);\r\n        balances[walletAddress] = balances[walletAddress] - amount;\r\n    }\r\n}\r\n\r\ncontract SpinnerFactory is Ownable {\r\n\r\n    function SpinnerFactory(address _spinnerDatabaseAddress) public {\r\n        databaseAddress = _spinnerDatabaseAddress;\r\n    }\r\n\r\n    address public databaseAddress;\r\n    address public processorAddress;\r\n    uint256 public spinnerModulus = 16777216; //16,777,216 or 256^3 possible unique spinners\r\n\r\n    address public owner;\r\n\r\n    mapping (uint => bool) public initialSpinners; //mapping of initial spinners\r\n\r\n    function setProcessorAddress(address processAddress) public onlyOwner {\r\n        processorAddress = processAddress;\r\n    }\r\n\r\n    function _generateRandomSeed() internal view returns (uint) {\r\n        uint rand = uint(keccak256(uint(block.blockhash(block.number-1)) + uint(keccak256(msg.sender))));\r\n        return rand % spinnerModulus;\r\n    }\r\n\r\n    function createUniqueSpinner(string _name, address creator, uint value) external {\r\n        require(msg.sender == processorAddress);\r\n        uint _seed = _generateRandomSeed();\r\n        SpinnerDatabase database = SpinnerDatabase(databaseAddress);\r\n        database.addUniqueSpinner(_name, _seed, creator, value, uint8(keccak256(_seed + 1)) % 64 + 64, uint8(keccak256(_seed + 2)) % 64 + 64, uint8(keccak256(_seed + 3)) % 64 + 64);\r\n    }\r\n\r\n   function createThemedSpinner(string _name, uint _type, address creator, uint value) external {\r\n        require(msg.sender == processorAddress);\r\n        require(initialSpinners[_type] == true);\r\n        uint _seed = _generateRandomSeed();\r\n        SpinnerDatabase database = SpinnerDatabase(databaseAddress);\r\n        database.addSpinner(_name, _type, creator, value, uint8(keccak256(_seed + 1)) % 64 + 64, uint8(keccak256(_seed + 2)) % 64 + 64, uint8(keccak256(_seed + 3)) % 64 + 64);\r\n    }\r\n\r\n    function addNewSpinner(uint _type) public onlyOwner {\r\n        initialSpinners[_type] = true;\r\n    }\r\n\r\n    function blockNewSpinnerPurchase(uint _type) public onlyOwner {\r\n        initialSpinners[_type] = false;\r\n    }\r\n\r\n    function mintGen0Spinners() public onlyOwner {\r\n        SpinnerDatabase database = SpinnerDatabase(databaseAddress);\r\n        addNewSpinner(1 + spinnerModulus);\r\n        database.generateThemedSpinners(1 + spinnerModulus, 1 ether, .01 ether);\r\n        addNewSpinner(2 + spinnerModulus);\r\n        database.generateThemedSpinners(2 + spinnerModulus, 1 ether, .01 ether);\r\n        addNewSpinner(3 + spinnerModulus);\r\n        database.generateThemedSpinners(3 + spinnerModulus, .75 ether, .0075 ether);\r\n        addNewSpinner(4 + spinnerModulus);\r\n        database.generateThemedSpinners(4 + spinnerModulus, .75 ether, .0075 ether);\r\n        addNewSpinner(5 + spinnerModulus);\r\n        database.generateThemedSpinners(5 + spinnerModulus, .75 ether, .0075 ether);\r\n        addNewSpinner(6 + spinnerModulus);\r\n        database.generateThemedSpinners(6 + spinnerModulus, .75 ether, .0075 ether);\r\n        addNewSpinner(7 + spinnerModulus);\r\n        database.generateThemedSpinners(7 + spinnerModulus, .75 ether, .0075 ether);\r\n        addNewSpinner(8 + spinnerModulus);\r\n        database.generateThemedSpinners(8 + spinnerModulus, .75 ether, .0075 ether);\r\n        addNewSpinner(9 + spinnerModulus);\r\n        database.generateThemedSpinners(9 + spinnerModulus, .5 ether, .005 ether);\r\n        addNewSpinner(10 + spinnerModulus);\r\n        database.generateThemedSpinners(10 + spinnerModulus, .5 ether, .005 ether);\r\n        addNewSpinner(11 + spinnerModulus);\r\n        database.generateThemedSpinners(11 + spinnerModulus, .5 ether, .005 ether);\r\n        addNewSpinner(12 + spinnerModulus);\r\n        database.generateThemedSpinners(12 + spinnerModulus, .5 ether, .005 ether);\r\n        addNewSpinner(13 + spinnerModulus);\r\n        database.generateThemedSpinners(13 + spinnerModulus, .2 ether, .002 ether);\r\n        addNewSpinner(14 + spinnerModulus);\r\n        database.generateThemedSpinners(14 + spinnerModulus, .2 ether, .002 ether);\r\n        addNewSpinner(15 + spinnerModulus);\r\n        database.generateThemedSpinners(15 + spinnerModulus, .3 ether, .003 ether);\r\n        addNewSpinner(16 + spinnerModulus);\r\n        database.generateThemedSpinners(16 + spinnerModulus, .3 ether, .003 ether);\r\n        addNewSpinner(17 + spinnerModulus);\r\n        database.generateThemedSpinners(17 + spinnerModulus, .05 ether, .0005 ether);\r\n        addNewSpinner(18 + spinnerModulus);\r\n        database.generateThemedSpinners(18 + spinnerModulus, .05 ether, .0005 ether);\r\n        addNewSpinner(19 + spinnerModulus);\r\n        database.generateThemedSpinners(19 + spinnerModulus, .008 ether, .00008 ether);\r\n        addNewSpinner(20 + spinnerModulus);\r\n        database.generateThemedSpinners(20 + spinnerModulus, .001 ether, .00001 ether);\r\n    }\r\n\r\n    function mintNewSpinner(uint _id, uint price, uint returnPrice) public onlyOwner {\r\n        SpinnerDatabase database = SpinnerDatabase(databaseAddress);\r\n        addNewSpinner(_id + spinnerModulus);\r\n        database.generateThemedSpinners(_id + spinnerModulus, price, returnPrice);\r\n    }\r\n}\r\n    \r\ncontract SpinnerProcessor is Ownable {\r\n\r\n    uint256 spinnerModulus = 16777216; //16,777,216 or 256^3 possible unique spinners\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier uniqueSpinnersActivated() {\r\n        require(uniqueSpinnersActive);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    function pause() public onlyOwner {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        paused = false;\r\n    }\r\n\r\n    function activateUniqueSpinners() public onlyOwner {\r\n        uniqueSpinnersActive = true;\r\n    }   \r\n    \r\n    bool public paused;\r\n    bool public uniqueSpinnersActive;\r\n\r\n    address factoryAddress;\r\n    address databaseAddress;\r\n    address ownerAddress;\r\n\r\n    uint256 ownerEarn;\r\n    uint256 ownerBalance;\r\n\r\n    function viewBalance() view public returns (uint256) {\r\n        return this.balance;\r\n    }\r\n\r\n    function SpinnerProcessor(address _spinnerFactoryAddress, address _spinnerDatabaseAddress, address _ownerAddress) public {\r\n        factoryAddress = _spinnerFactoryAddress;\r\n        databaseAddress = _spinnerDatabaseAddress;\r\n        ownerAddress = _ownerAddress;\r\n        paused = true;\r\n        uniqueSpinnersActive = false;\r\n    }\r\n\r\n    function purchaseThemedSpinner(string _name, uint _id) public payable whenNotPaused {\r\n        SpinnerDatabase database = SpinnerDatabase(databaseAddress);\r\n        uint currentPrice = database.getSpinnerPrice(_id + spinnerModulus);\r\n        require(msg.value == currentPrice);\r\n        uint ownerPayout = database.getOriginalSpinnerPrice(_id + spinnerModulus);\r\n        ownerEarn = ownerEarn + ownerPayout;\r\n        ownerBalance = ownerBalance + ownerPayout;    \r\n        SpinnerFactory factory = SpinnerFactory(factoryAddress);\r\n        factory.createThemedSpinner(_name, _id + spinnerModulus, msg.sender, msg.value);\r\n    }\r\n\r\n    function purchaseUniqueSpinner(string _name) public payable whenNotPaused uniqueSpinnersActivated {\r\n        SpinnerDatabase database = SpinnerDatabase(databaseAddress);\r\n        uint currentPrice = database.getUniqueSpinnerPrice();\r\n        require(msg.value == currentPrice);\r\n        SpinnerFactory factory = SpinnerFactory(factoryAddress);\r\n        factory.createUniqueSpinner(_name, msg.sender, msg.value);\r\n    }\r\n\r\n    function cashOut() public whenNotPaused {\r\n        SpinnerDatabase database = SpinnerDatabase(databaseAddress);\r\n        uint balance = database.getBalance(msg.sender);\r\n        uint contractBalance = this.balance;\r\n        require(balance <= contractBalance);\r\n        database.decrementBalance(msg.sender, balance);\r\n        msg.sender.transfer(balance);\r\n    }\r\n\r\n    function OwnerCashout() public onlyOwner {\r\n        require(ownerBalance <= this.balance);\r\n        msg.sender.transfer(ownerBalance);\r\n        ownerBalance = 0;\r\n    }\r\n\r\n    function transferBalance(address newProcessor) public onlyOwner {\r\n        newProcessor.transfer(this.balance);\r\n    }\r\n\r\n    function () payable public {}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"purchaseUniqueSpinner\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"OwnerCashout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newProcessor\",\"type\":\"address\"}],\"name\":\"transferBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"purchaseThemedSpinner\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniqueSpinnersActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateUniqueSpinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_spinnerFactoryAddress\",\"type\":\"address\"},{\"name\":\"_spinnerDatabaseAddress\",\"type\":\"address\"},{\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SpinnerProcessor","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005f0ca657fc96b0fa616ca01ca42d9414d02d54600000000000000000000000000bbfe2b67a4caded4d6c607cb91be5354ba6617d0000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://b1da5e18b2a1b35f9d343f75e2dac4c8336aea590f25762fa200f69906f57851"}]}