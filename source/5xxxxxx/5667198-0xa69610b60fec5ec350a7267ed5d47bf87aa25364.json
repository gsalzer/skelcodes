{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\n//TODO : Store Games in a Map instead of array. See if that has any advantages.\r\ncontract owned { \r\n    address owner;\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract priced {\r\n    modifier costs(uint256 price) {\r\n        require(msg.value >= price);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract SplitStealContract is owned, priced {\r\n\r\n    //Global Variables\r\n    uint constant STEAL = 0;\r\n    uint constant SPLIT = 1;\r\n    mapping(address=>bool) suspended;\r\n    mapping(address=>uint) totalGamesStarted;\r\n    mapping(address=>uint) totalGamesParticipated;   \r\n    uint256 contractEarnings = 0;\r\n    //Game Rules\r\n    uint256 REGISTRATION_COST = 10**14;// 0.0001 Ether //Editable by Owner\r\n    uint256 MINIMUM_COST_OF_BET = 10**17;// 0.1 Ether //Editable by Owner\r\n    uint256 MAXIMUM_COST_OF_BET = 5 * 10**18;//5 Ether //Editable by Owner\r\n    uint256 STAGE_TIMEOUT = 60*60*24*7;//1 Week\r\n\r\n    //Reward Matrix Parameters\r\n    uint256 K = 25; //Editable by Owner\r\n\r\n    //Events\r\n    event RegisterationOpened(uint indexed _gameNumber);\r\n    event RegisterationClosed(uint indexed _gameNumber);\r\n    event RevealStart(uint indexed _gameNumber);\r\n    event RevealStop(uint indexed _gameNumber);\r\n    event Transferred(uint indexed _gameNumber,address _to, uint256 _amount);\r\n    event ContractEarnings(uint indexed _gameNumber, uint256 _amount, string _reason);\r\n    event Disqualified(uint indexed _gameNumber, address indexed _player, bytes32 _encryptedChoice, uint _actualChoice, bytes32 _encryptedActualChoice);\r\n    event NewGameRules(uint _oldFees, uint _newFees, uint _oldMinBet, uint _newMinBet, uint _oldMaxBet, uint _newMaxBet, uint _oldStageTimeout, uint _newStageTimeout);\r\n    event NewRewardMatrix(uint _n1, uint _n2, uint _n3, uint _d);\r\n    event NewRewardPercentage(uint256 _oldK, uint256 _k);\r\n    event Suspended(address indexed _player);\r\n    event UnSuspended(address indexed _player);\r\n\r\n    //BET Struct\r\n    struct Bet {\r\n        bytes32 encryptedChoice;\r\n        uint256 betAmount;\r\n        uint actualChoice;\r\n    }\r\n\r\n    //GAME Struct\r\n    struct Game {\r\n        uint startTime;\r\n        uint revealTime;\r\n        uint finishTime;\r\n        address player1; \r\n        address player2;\r\n        uint256 registrationCost;\r\n        uint256 k;\r\n        uint stageTimeout;\r\n        bool registerationOpen;\r\n        bool revealing;\r\n        bool lastGameFinished;\r\n        mapping(address=>address) opponent;\r\n        mapping(address=>bool) registered;\r\n        mapping(address=>Bet) bets;\r\n        mapping(address=>bool) revealed;\r\n        mapping(address=>bool) disqualified;\r\n        mapping(address=>bool) claimedReward;\r\n        mapping(address=>uint256) reward;\r\n    }\r\n    \r\n    Game[] games;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }   \r\n\r\n    function fund() payable external {\r\n        contractEarnings = contractEarnings + msg.value;\r\n    }\r\n\r\n    // UTILITY METHODS STARTS\r\n    function isEven(uint num) private pure returns(bool _isEven) {\r\n        uint halfNum = num / 2;\r\n        return (halfNum * 2) == num;\r\n    }\r\n    // UTILITY METHODS END\r\n\r\n    // ADMIN METHODS START\r\n    function changeOwner(address _to) public onlyOwner {\r\n        require(_to != address(0));\r\n        owner = _to;\r\n    }\r\n    /** @dev So Owner can't take away player's money in the middle of the game.\r\n    Owner can only withdraw earnings of the game contract and not the entire balance.\r\n    Earnings are calculated after every game is finished, i.e.; when both players\r\n    have cliamed reward. If a player doens't claim reward for a game, those ether \r\n    can not be reclaimed until 1 week. After 1 week Owner of contract has power of disqualifying \r\n    Players who did not finihs the game. FAIR ENOUGH ?\r\n    */\r\n    function transferEarningsToOwner() public onlyOwner {\r\n        require(address(this).balance >= contractEarnings);\r\n        uint256 _contractEarnings = contractEarnings;\r\n        contractEarnings = 0;\r\n        // VERY IMPORTANT\r\n        // PREVENTS REENTRANCY ATTACK BY CONTRACT OWNER\r\n        // contract Earnings need to be set to 0 first,\r\n        // and then transferred to owner\r\n        owner.transfer(_contractEarnings);\r\n    }\r\n\r\n    function suspend(address _player) public onlyOwner returns(bool _suspended){\r\n        require(!suspended[_player]);\r\n        require(_player != owner);\r\n        suspended[_player] = true;\r\n        emit Suspended(_player);\r\n        return true;\r\n    }\r\n\r\n    function unSuspend(address _player) public onlyOwner returns(bool _unSuspended){\r\n        require(suspended[_player]);\r\n        suspended[_player] = false;\r\n        emit UnSuspended(_player);\r\n        return true;\r\n    }\r\n\r\n    function setRewardPercentageK(uint256 _k) public onlyOwner {\r\n        //Max earnings is double.\r\n        require(_k <= 100);\r\n        emit NewRewardPercentage(K, _k);\r\n        K = _k;\r\n    }\r\n\r\n    function setGameRules(uint256 _fees, uint256 _minBet, uint256 _maxBet, uint256 _stageTimeout) public onlyOwner {\r\n        require(_stageTimeout >= 60*60*24*7);//Owner can't set it to below 1 week\r\n        require((_fees * 100 ) < _minBet);//Fees will always be less that 1 % of bet\r\n        require(_minBet < _maxBet);\r\n        emit NewGameRules(REGISTRATION_COST, _fees, MINIMUM_COST_OF_BET, _minBet, MAXIMUM_COST_OF_BET, _maxBet, STAGE_TIMEOUT, _stageTimeout);\r\n        REGISTRATION_COST = _fees;\r\n        MINIMUM_COST_OF_BET = _minBet;\r\n        MAXIMUM_COST_OF_BET = _maxBet;\r\n        STAGE_TIMEOUT = _stageTimeout;\r\n    }\r\n    //ADMIN METHODS ENDS\r\n\r\n    //VIEW APIs STARTS\r\n    function getOwner() public view returns(address _owner) {\r\n        return owner;\r\n    }\r\n\r\n    function getContractBalance() public view returns(uint256 _balance) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getContractEarnings() public view returns(uint _earnings) {\r\n        return contractEarnings;\r\n    }\r\n\r\n    function getRewardMatrix() public view returns(uint _k) {\r\n        return (K);\r\n    }\r\n\r\n    function getGameRules() public view returns(uint256 _fees, uint256 _minBet, uint256 _maxBet, uint256 _stageTimeout) {\r\n        return (REGISTRATION_COST, MINIMUM_COST_OF_BET, MAXIMUM_COST_OF_BET, STAGE_TIMEOUT);\r\n    }\r\n\r\n    function getGameState(uint gameNumber) public view returns(bool _registerationOpen, bool _revealing, bool _lastGameFinished, uint _startTime, uint _revealTime, uint _finishTime, uint _stageTimeout) {\r\n        require(games.length >= gameNumber);    \r\n        Game storage game = games[gameNumber - 1];    \r\n        return (game.registerationOpen, game.revealing, game.lastGameFinished, game.startTime, game.revealTime, game.finishTime, game.stageTimeout);\r\n    }\r\n\r\n    function getPlayerState(uint gameNumber) public view returns(bool _suspended, bool _registered, bool _revealed, bool _disqualified, bool _claimedReward, uint256 _betAmount, uint256 _reward) {\r\n        require(games.length >= gameNumber);\r\n        uint index = gameNumber - 1;\r\n        address player = msg.sender;\r\n        uint256 betAmount = games[index].bets[player].betAmount;\r\n        return (suspended[player], games[index].registered[player], games[index].revealed[player], games[index].disqualified[player], games[index].claimedReward[player], betAmount, games[index].reward[player] );\r\n    }\r\n\r\n    function getTotalGamesStarted() public view returns(uint _totalGames) {\r\n        return totalGamesStarted[msg.sender];\r\n    }\r\n\r\n    function getTotalGamesParticipated() public view returns(uint _totalGames) {\r\n        return totalGamesParticipated[msg.sender];\r\n    }\r\n\r\n    function getTotalGames() public view returns(uint _totalGames) {\r\n        return games.length;\r\n    }\r\n    //VIEW APIs ENDS\r\n\r\n    //GAME PLAY STARTS\r\n    function startGame(uint256 _betAmount, bytes32 _encryptedChoice) public  payable costs(_betAmount) returns(uint _gameNumber) {\r\n        address player = msg.sender;\r\n        require(!suspended[player]);   \r\n        require(_betAmount >= MINIMUM_COST_OF_BET);\r\n        require(_betAmount <= MAXIMUM_COST_OF_BET);\r\n        Game memory _game = Game(now, now, now, player, address(0), REGISTRATION_COST, K, STAGE_TIMEOUT, true, false, false);  \r\n        games.push(_game); \r\n        Game storage game = games[games.length-1]; \r\n        game.registered[player] = true;\r\n        game.bets[player] = Bet(_encryptedChoice, _betAmount, 0);                   \r\n        totalGamesStarted[player] = totalGamesStarted[player] + 1;\r\n        emit RegisterationOpened(games.length);\r\n        return games.length;\r\n    }\r\n\r\n    function joinGame(uint _gameNumber, uint256 _betAmount, bytes32 _encryptedChoice) public  payable costs(_betAmount) {\r\n        require(games.length >= _gameNumber);\r\n        Game storage game = games[_gameNumber-1];\r\n        address player = msg.sender;\r\n        require(game.registerationOpen); \r\n        require(game.player1 != player); // Can also put ```require(game.registered[player]);``` meaning, Same player cannot join the game.\r\n        require(!suspended[player]);   \r\n        require(_betAmount >= MINIMUM_COST_OF_BET);\r\n        require(_betAmount <= MAXIMUM_COST_OF_BET);\r\n        require(game.player2 == address(0)); \r\n        game.player2 = player;\r\n        game.registered[player] = true;\r\n        game.bets[player] = Bet(_encryptedChoice, _betAmount, 0);    \r\n        game.registerationOpen = false;\r\n        game.revealing = true;  \r\n        game.revealTime = now; // Set Game Reveal time in order to resolve dead lock if no one claims reward.\r\n        game.finishTime = now; // If both do not reveal for one week, Admin can immidiately finish game.\r\n        game.opponent[game.player1] = game.player2;    \r\n        game.opponent[game.player2] = game.player1;\r\n        totalGamesParticipated[player] = totalGamesParticipated[player] + 1;\r\n        emit RegisterationClosed(_gameNumber);\r\n        emit RevealStart(_gameNumber);\r\n    }\r\n\r\n    function reveal(uint _gameNumber, uint256 _choice) public {\r\n        require(games.length >= _gameNumber);\r\n        Game storage game = games[_gameNumber-1];\r\n        require(game.revealing);\r\n        address player = msg.sender;\r\n        require(!suspended[player]);\r\n        require(game.registered[player]);\r\n        require(!game.revealed[player]);\r\n        game.revealed[player] = true;\r\n        game.bets[player].actualChoice = _choice;\r\n        bytes32 encryptedChoice = game.bets[player].encryptedChoice;\r\n        bytes32 encryptedActualChoice = keccak256(_choice);\r\n        if( encryptedActualChoice != encryptedChoice) {\r\n            game.disqualified[player] = true;\r\n            //Mark them as Claimed Reward so that \r\n            //contract earnings can be accounted for\r\n            game.claimedReward[player] = true;\r\n            game.reward[player] = 0;\r\n            if (game.disqualified[game.opponent[player]]) {\r\n                uint256 gameEarnings = game.bets[player].betAmount + game.bets[game.opponent[player]].betAmount;\r\n                contractEarnings = contractEarnings + gameEarnings;\r\n                emit ContractEarnings(_gameNumber, gameEarnings, \"BOTH_DISQUALIFIED\");\r\n            }\r\n            emit Disqualified(_gameNumber, player, encryptedChoice, _choice, encryptedActualChoice);\r\n        }\r\n        if(game.revealed[game.player1] && game.revealed[game.player2]) {\r\n            game.revealing = false;\r\n            game.lastGameFinished = true;\r\n            game.finishTime = now; //Set Game finish time in order to resolve dead lock if no one claims reward.\r\n            emit RevealStop(_gameNumber);\r\n        }\r\n    }\r\n    //GAME PLAY ENDS\r\n\r\n\r\n    //REWARD WITHDRAW STARTS\r\n    function ethTransfer(uint gameNumber, address _to, uint256 _amount) private {\r\n        require(!suspended[_to]);\r\n        require(_to != address(0));\r\n        if ( _amount > games[gameNumber-1].registrationCost) {\r\n            //Take game Commission\r\n            uint256 amount = _amount - games[gameNumber-1].registrationCost;\r\n            require(address(this).balance >= amount);\r\n            _to.transfer(amount);\r\n            emit Transferred(gameNumber, _to, amount);\r\n        }\r\n    }\r\n\r\n\r\n    function claimRewardK(uint gameNumber) public returns(bool _claimedReward)  {\r\n        require(games.length >= gameNumber);\r\n        Game storage game = games[gameNumber-1];\r\n        address player = msg.sender;\r\n        require(!suspended[player]);\r\n        require(!game.claimedReward[player]);\r\n        uint commission = games[gameNumber-1].registrationCost;\r\n        if (game.registerationOpen) {\r\n            game.claimedReward[player] = true;\r\n            game.registerationOpen = false;\r\n            game.lastGameFinished = true;\r\n            if ( now > (game.startTime + game.stageTimeout)) {\r\n                //No commision if game was open till stage timeout.\r\n                commission = 0;\r\n            }\r\n            game.reward[player] = game.bets[player].betAmount - commission;\r\n            if (commission > 0) {\r\n                contractEarnings = contractEarnings + commission;\r\n                emit ContractEarnings(gameNumber, commission, \"GAME_ABANDONED\");\r\n            }\r\n            //Bet amount can't be less than commission.\r\n            //Hence no -ve check is required\r\n            ethTransfer(gameNumber, player, game.bets[player].betAmount);\r\n            return true;\r\n        }\r\n        require(game.lastGameFinished);\r\n        require(!game.disqualified[player]);\r\n        require(game.registered[player]);\r\n        require(game.revealed[player]);\r\n        require(!game.claimedReward[player]);\r\n        game.claimedReward[player] = true;\r\n        address opponent = game.opponent[player];\r\n        uint256 reward = 0;\r\n        uint256 gameReward = 0;\r\n        uint256 totalBet = (game.bets[player].betAmount + game.bets[opponent].betAmount);\r\n        if ( game.disqualified[opponent]) {\r\n            gameReward = ((100 + game.k) * game.bets[player].betAmount) / 100;\r\n            reward = gameReward < totalBet ? gameReward : totalBet; //Min (X+Y, (100+K)*X/100)\r\n            game.reward[player] = reward - commission;\r\n            //Min (X+Y, (100+K)*X/100) can't be less than commision.\r\n            //Hence no -ve check is required\r\n            contractEarnings = contractEarnings + (totalBet - game.reward[player]);\r\n            emit ContractEarnings(gameNumber, (totalBet - game.reward[player]), \"OPPONENT_DISQUALIFIED\");\r\n            ethTransfer(gameNumber, player, reward);\r\n            return true;\r\n        }\r\n        if ( !isEven(game.bets[player].actualChoice) && !isEven(game.bets[opponent].actualChoice) ) { // Split Split\r\n            reward = (game.bets[player].betAmount + game.bets[opponent].betAmount) / 2;\r\n            game.reward[player] = reward - commission;\r\n            //(X+Y)/2 can't be less than commision.\r\n            //Hence no -ve check is required\r\n            if ( game.claimedReward[opponent] ) {\r\n                uint256 gameEarnings = (totalBet - game.reward[player] - game.reward[opponent]);\r\n                contractEarnings = contractEarnings + gameEarnings;\r\n                emit ContractEarnings(gameNumber, gameEarnings, \"SPLIT_SPLIT\");\r\n            }\r\n            ethTransfer(gameNumber, player, reward);\r\n            return true;\r\n        }\r\n        if ( !isEven(game.bets[player].actualChoice) && isEven(game.bets[opponent].actualChoice) ) { // Split Steal\r\n            game.reward[player] = 0;\r\n            if ( game.claimedReward[opponent] ) {\r\n                gameEarnings = (totalBet - game.reward[player] - game.reward[opponent]);\r\n                contractEarnings = contractEarnings + gameEarnings;\r\n                emit ContractEarnings(gameNumber, gameEarnings, \"SPLIT_STEAL\");\r\n            }\r\n            return true;\r\n        }\r\n        if ( isEven(game.bets[player].actualChoice) && !isEven(game.bets[opponent].actualChoice) ) { // Steal Split\r\n            gameReward = (((100 + game.k) * game.bets[player].betAmount)/100);\r\n            reward = gameReward < totalBet ? gameReward : totalBet; \r\n            game.reward[player] = reward - commission;\r\n            //Min (X+Y, (100+K)*X/100) can't be less than commision.\r\n            //Hence no -ve check is required\r\n            if ( game.claimedReward[opponent] ) {\r\n                gameEarnings = (totalBet - game.reward[player] - game.reward[opponent]);\r\n                contractEarnings = contractEarnings + gameEarnings;\r\n                emit ContractEarnings(gameNumber, gameEarnings, \"STEAL_SPLIT\");\r\n            }\r\n            ethTransfer(gameNumber, player, reward);\r\n            return true;\r\n        }\r\n        if ( isEven(game.bets[player].actualChoice) && isEven(game.bets[opponent].actualChoice) ) { // Steal Steal\r\n            reward = 0;\r\n            if( game.bets[player].betAmount > game.bets[opponent].betAmount) {\r\n                //((100-K)*(X-Y)/2)/100 will always be less than X+Y so no need for min check on X+Y and reward\r\n                reward = ((100 - game.k) * (game.bets[player].betAmount - game.bets[opponent].betAmount) / 2) / 100;\r\n            }\r\n            if(reward > 0) {\r\n                //((100-K)*(X-Y)/2)/100 CAN BE LESS THAN COMMISSION.\r\n                game.reward[player] = reward > commission ? reward - commission : 0;\r\n            }\r\n            if ( game.claimedReward[opponent] ) {\r\n                gameEarnings = (totalBet - game.reward[player] - game.reward[opponent]);\r\n                contractEarnings = contractEarnings + gameEarnings;\r\n                emit ContractEarnings(gameNumber, gameEarnings, \"STEAL_STEAL\");\r\n            }\r\n            ethTransfer(gameNumber, player, reward);\r\n            return true;\r\n        }\r\n    }\r\n    //REWARD WITHDRAW ENDS\r\n\r\n\r\n    //OWNER OVERRIDE SECTION STARTS\r\n    /** \r\n     *  Give back to game creator instead of consuming to contract.\r\n     *  So in case Game owner has PTSD and wants al game finished,\r\n     *  Game owner will call this on game which is in registeration open\r\n     *  state since past stage timeout.\r\n     *  Do some good :)\r\n     *  ALTHOUGH if game creator wants to abandon after stage timeout\r\n     *  No fees is charged. See claimReward Method for that.\r\n     */\r\n    function ownerAbandonOverride(uint _gameNumber) private returns(bool _overriden) {\r\n        Game storage game = games[_gameNumber-1];\r\n        if (game.registerationOpen) {\r\n            if (now > (game.startTime + game.stageTimeout)) {\r\n                game.claimedReward[game.player1] = true;\r\n                game.registerationOpen = false;\r\n                game.lastGameFinished = true;\r\n                game.reward[game.player1] = game.bets[game.player1].betAmount; \r\n                //Do not cut commision as no one came to play. \r\n                //This also incentivisies users to keep the game open for long time.\r\n                ethTransfer(_gameNumber, game.player1, game.bets[game.player1].betAmount);\r\n                return true;\r\n            }                  \r\n        }      \r\n        return false;\r\n    }\r\n\r\n    /** \r\n     *  If both palayer(s) does(-es) not reveal choice in time they get disqualified.\r\n     *  If both players do not reveal choice in time, Game's earnings are updated.\r\n     *  If one of the player does not reveal choice, then game's earnings are not updated.\r\n     *  Player who has revealed is given chance to claim reward.\r\n     */\r\n\r\n    function ownerRevealOverride(uint _gameNumber) private returns(bool _overriden) {\r\n        Game storage game = games[_gameNumber-1];\r\n        if ( game.revealing) {\r\n            if (now > (game.revealTime + game.stageTimeout)) {\r\n                if(!game.revealed[game.player1] && !game.revealed[game.player1]) {\r\n                    //Mark Player as following,\r\n                    //  1.)Revealed (To maintain sane state of game)\r\n                    //  2.)Disqualified (Since player did not finish the game in time)\r\n                    //  3.)Claimed Reward ( So that contract earnings can be accounted for)\r\n                    //  Also set reward amount as 0\r\n                    game.revealed[game.player1] = true;\r\n                    game.disqualified[game.player1] = true;\r\n                    game.claimedReward[game.player1] = true;\r\n                    game.reward[game.player1] = 0;\r\n                    emit Disqualified(_gameNumber, game.player1, \"\", 0, \"\");\r\n                    game.revealed[game.player2] = true;\r\n                    game.disqualified[game.player2] = true;\r\n                    game.claimedReward[game.player2] = true;\r\n                    game.reward[game.player2] = 0;\r\n                    emit Disqualified(_gameNumber, game.player2, \"\", 0, \"\");\r\n                    game.finishTime = now;\r\n                    uint256 gameEarnings = game.bets[game.player1].betAmount + game.bets[game.player2].betAmount;\r\n                    contractEarnings = contractEarnings + gameEarnings;\r\n                    emit ContractEarnings(_gameNumber, gameEarnings, \"BOTH_NO_REVEAL\");\r\n                } else if (game.revealed[game.player1] && !game.revealed[game.player2]) {\r\n                    game.revealed[game.player2] = true;\r\n                    game.disqualified[game.player2] = true;\r\n                    game.claimedReward[game.player2] = true;\r\n                    game.reward[game.player2] = 0;\r\n                    emit Disqualified(_gameNumber, game.player2, \"\", 0, \"\");\r\n                    game.finishTime = now;\r\n                } else if (!game.revealed[game.player1] && game.revealed[game.player2]) {           \r\n                    game.revealed[game.player1] = true;\r\n                    game.disqualified[game.player1] = true;\r\n                    game.claimedReward[game.player1] = true;\r\n                    game.reward[game.player1] = 0;\r\n                    emit Disqualified(_gameNumber, game.player1, \"\", 0, \"\");\r\n                    game.finishTime = now;\r\n                }\r\n                game.revealing = false;\r\n                game.lastGameFinished = true;\r\n                emit RevealStop(_gameNumber);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     *  If both palayer(s) does(-es) not claim reward in time \r\n     *  they loose their chance to claim reward.\r\n     *  Game earnings are calculated as if this gets executed successully,\r\n     *  both players have claimed rewards eseentialy.      \r\n     */\r\n    function ownerClaimOverride(uint _gameNumber) private returns(bool _overriden) {\r\n        Game storage game = games[_gameNumber-1];\r\n        if ( game.lastGameFinished) {\r\n            if (now > (game.finishTime + game.stageTimeout)) {\r\n                if(!game.claimedReward[game.player1] && !game.claimedReward[game.player1]) {\r\n                    game.claimedReward[game.player1] = true;\r\n                    game.reward[game.player1] = 0;\r\n                    game.claimedReward[game.player2] = true;\r\n                    game.reward[game.player2] = 0;\r\n                } else if (game.claimedReward[game.player1] && !game.claimedReward[game.player2]) {\r\n                    game.claimedReward[game.player2] = true;\r\n                    game.reward[game.player2] = 0;\r\n                } else if (!game.claimedReward[game.player1] && game.claimedReward[game.player2]) {           \r\n                    game.claimedReward[game.player1] = true;\r\n                    game.reward[game.player1] = 0;\r\n                } else {\r\n                    //Both players have alreay claimed reward.\r\n                    return false;\r\n                }\r\n                uint256 totalBet = (game.bets[game.player1].betAmount + game.bets[game.player2].betAmount);\r\n                uint gameEarnings = totalBet - game.reward[game.player1] - game.reward[game.player2];\r\n                contractEarnings = contractEarnings + gameEarnings;\r\n                emit ContractEarnings(_gameNumber, gameEarnings, \"OWNER_CLAIM_OVERRIDE\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function ownerOverride(uint _gameNumber) public onlyOwner returns(bool _overriden){\r\n        if (msg.sender == owner) {\r\n            if( ownerAbandonOverride(_gameNumber) || ownerRevealOverride(_gameNumber) || ownerClaimOverride(_gameNumber) ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    //OWNER OVERRIDE SECTION ENDS\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"suspend\",\"outputs\":[{\"name\":\"_suspended\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferEarningsToOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameNumber\",\"type\":\"uint256\"},{\"name\":\"_betAmount\",\"type\":\"uint256\"},{\"name\":\"_encryptedChoice\",\"type\":\"bytes32\"}],\"name\":\"joinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalGames\",\"outputs\":[{\"name\":\"_totalGames\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalGamesStarted\",\"outputs\":[{\"name\":\"_totalGames\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_k\",\"type\":\"uint256\"}],\"name\":\"setRewardPercentageK\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameNumber\",\"type\":\"uint256\"}],\"name\":\"ownerOverride\",\"outputs\":[{\"name\":\"_overriden\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameNumber\",\"type\":\"uint256\"},{\"name\":\"_choice\",\"type\":\"uint256\"}],\"name\":\"reveal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractEarnings\",\"outputs\":[{\"name\":\"_earnings\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_betAmount\",\"type\":\"uint256\"},{\"name\":\"_encryptedChoice\",\"type\":\"bytes32\"}],\"name\":\"startGame\",\"outputs\":[{\"name\":\"_gameNumber\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameNumber\",\"type\":\"uint256\"}],\"name\":\"claimRewardK\",\"outputs\":[{\"name\":\"_claimedReward\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameRules\",\"outputs\":[{\"name\":\"_fees\",\"type\":\"uint256\"},{\"name\":\"_minBet\",\"type\":\"uint256\"},{\"name\":\"_maxBet\",\"type\":\"uint256\"},{\"name\":\"_stageTimeout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"unSuspend\",\"outputs\":[{\"name\":\"_unSuspended\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalGamesParticipated\",\"outputs\":[{\"name\":\"_totalGames\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameNumber\",\"type\":\"uint256\"}],\"name\":\"getPlayerState\",\"outputs\":[{\"name\":\"_suspended\",\"type\":\"bool\"},{\"name\":\"_registered\",\"type\":\"bool\"},{\"name\":\"_revealed\",\"type\":\"bool\"},{\"name\":\"_disqualified\",\"type\":\"bool\"},{\"name\":\"_claimedReward\",\"type\":\"bool\"},{\"name\":\"_betAmount\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRewardMatrix\",\"outputs\":[{\"name\":\"_k\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fees\",\"type\":\"uint256\"},{\"name\":\"_minBet\",\"type\":\"uint256\"},{\"name\":\"_maxBet\",\"type\":\"uint256\"},{\"name\":\"_stageTimeout\",\"type\":\"uint256\"}],\"name\":\"setGameRules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameNumber\",\"type\":\"uint256\"}],\"name\":\"getGameState\",\"outputs\":[{\"name\":\"_registerationOpen\",\"type\":\"bool\"},{\"name\":\"_revealing\",\"type\":\"bool\"},{\"name\":\"_lastGameFinished\",\"type\":\"bool\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_revealTime\",\"type\":\"uint256\"},{\"name\":\"_finishTime\",\"type\":\"uint256\"},{\"name\":\"_stageTimeout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameNumber\",\"type\":\"uint256\"}],\"name\":\"RegisterationOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameNumber\",\"type\":\"uint256\"}],\"name\":\"RegisterationClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameNumber\",\"type\":\"uint256\"}],\"name\":\"RevealStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameNumber\",\"type\":\"uint256\"}],\"name\":\"RevealStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"ContractEarnings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_encryptedChoice\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_actualChoice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_encryptedActualChoice\",\"type\":\"bytes32\"}],\"name\":\"Disqualified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldFees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newFees\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_oldMinBet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newMinBet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_oldMaxBet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newMaxBet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_oldStageTimeout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newStageTimeout\",\"type\":\"uint256\"}],\"name\":\"NewGameRules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_n1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_n2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_n3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_d\",\"type\":\"uint256\"}],\"name\":\"NewRewardMatrix\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldK\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_k\",\"type\":\"uint256\"}],\"name\":\"NewRewardPercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"Suspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"UnSuspended\",\"type\":\"event\"}]","ContractName":"SplitStealContract","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://26bbd0254c029bb11b557c50d41418307860664ac77039c21c3f386e084edb1a"}]}