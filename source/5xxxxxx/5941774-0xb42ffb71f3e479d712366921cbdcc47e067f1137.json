{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title EIP20/ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract EIP20 is ERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n}\r\n\r\ninterface NonCompliantEIP20 {\r\n    function transfer(address _to, uint _value) external;\r\n    function transferFrom(address _from, address _to, uint _value) external;\r\n    function approve(address _spender, uint _value) external;\r\n}\r\n\r\n/**\r\n * @title EIP20/ERC20 wrapper that will support noncompliant ERC20s\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * @dev see https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ncontract EIP20Wrapper {\r\n\r\n    function eip20Transfer(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transfer(to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Transfer failed\");\r\n    }\r\n\r\n    function eip20TransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transferFrom(from, to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20TransferFrom failed\");\r\n    }\r\n\r\n    function eip20Approve(\r\n        address token,\r\n        address spender,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).approve(spender, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Approve failed\");\r\n    }\r\n}\r\n\r\n// This provides a gatekeeping modifier for functions that can only be used by the bZx contract\r\n// Since it inherits Ownable provides typical ownership functionality with a slight modification to the transferOwnership function\r\n// Setting owner and bZxContractAddress to the same address is not supported.\r\ncontract BZxOwnable is Ownable {\r\n\r\n    address public bZxContractAddress;\r\n\r\n    event BZxOwnershipTransferred(address indexed previousBZxContract, address indexed newBZxContract);\r\n\r\n    // modifier reverts if bZxContractAddress isn't set\r\n    modifier onlyBZx() {\r\n        require(msg.sender == bZxContractAddress, \"only bZx contracts can call this function\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer the bZx contract owner to a new contract address\r\n    * @param newBZxContractAddress The bZx contract address to transfer ownership to.\r\n    */\r\n    function transferBZxOwnership(address newBZxContractAddress) public onlyOwner {\r\n        require(newBZxContractAddress != address(0) && newBZxContractAddress != owner, \"transferBZxOwnership::unauthorized\");\r\n        emit BZxOwnershipTransferred(bZxContractAddress, newBZxContractAddress);\r\n        bZxContractAddress = newBZxContractAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    * This overrides transferOwnership in Ownable to prevent setting the new owner the same as the bZxContract\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0) && newOwner != bZxContractAddress, \"transferOwnership::unauthorized\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface ExchangeInterface {\r\n    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\r\n\r\n    function fillOrder(\r\n          address[5] orderAddresses,\r\n          uint[6] orderValues,\r\n          uint fillTakerTokenAmount,\r\n          bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n          uint8 v,\r\n          bytes32 r,\r\n          bytes32 s)\r\n          external\r\n          returns (uint filledTakerTokenAmount);\r\n\r\n    function fillOrdersUpTo(\r\n        address[5][] orderAddresses,\r\n        uint[6][] orderValues,\r\n        uint fillTakerTokenAmount,\r\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n        uint8[] v,\r\n        bytes32[] r,\r\n        bytes32[] s)\r\n        external\r\n        returns (uint);\r\n\r\n    function isValidSignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        external\r\n        constant\r\n        returns (bool);\r\n}\r\n\r\ncontract BZxTo0x is EIP20Wrapper, BZxOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    address public exchangeContract;\r\n    address public zrxTokenContract;\r\n    address public tokenTransferProxyContract;\r\n\r\n    constructor(\r\n        address _exchange, \r\n        address _zrxToken,\r\n        address _proxy) \r\n        public \r\n    {\r\n        exchangeContract = _exchange;\r\n        zrxTokenContract = _zrxToken;\r\n        tokenTransferProxyContract = _proxy;\r\n    }\r\n\r\n    function() \r\n        public {\r\n        revert();\r\n    }\r\n\r\n   function take0xTrade(\r\n        address trader,\r\n        address vaultAddress,\r\n        uint sourceTokenAmountToUse,\r\n        bytes orderData0x, // 0x order arguments, converted to hex, padded to 32 bytes and concatenated\r\n        bytes signature0x) // ECDSA of the 0x order\r\n        public\r\n        onlyBZx\r\n        returns (\r\n            address destTokenAddress,\r\n            uint destTokenAmount,\r\n            uint sourceTokenUsedAmount)\r\n    {\r\n        (address[5][] memory orderAddresses0x, uint[6][] memory orderValues0x) = getOrderValuesFromData(orderData0x);\r\n\r\n        (sourceTokenUsedAmount, destTokenAmount) = _take0xTrade(\r\n            trader,\r\n            sourceTokenAmountToUse,\r\n            orderAddresses0x,\r\n            orderValues0x,\r\n            signature0x);\r\n\r\n        if (sourceTokenUsedAmount < sourceTokenAmountToUse) {\r\n            // all sourceToken has to be traded\r\n            revert(\"BZxTo0x::take0xTrade: sourceTokenUsedAmount < sourceTokenAmountToUse\");\r\n        }\r\n\r\n        // transfer the destToken to the vault\r\n        eip20Transfer(\r\n            orderAddresses0x[0][2],\r\n            vaultAddress,\r\n            destTokenAmount);\r\n\r\n        destTokenAddress = orderAddresses0x[0][2]; // makerToken (aka destTokenAddress)\r\n    }\r\n\r\n    function getOrderValuesFromData(\r\n        bytes orderData0x)\r\n        public\r\n        pure\r\n        returns (\r\n            address[5][] orderAddresses,\r\n            uint[6][] orderValues) \r\n    {\r\n        address maker;\r\n        address taker;\r\n        address makerToken;\r\n        address takerToken;\r\n        address feeRecipient;\r\n        uint makerTokenAmount;\r\n        uint takerTokenAmount;\r\n        uint makerFee;\r\n        uint takerFee;\r\n        uint expirationTimestampInSec;\r\n        uint salt;\r\n        orderAddresses = new address[5][](orderData0x.length/352);\r\n        orderValues = new uint[6][](orderData0x.length/352);\r\n        for (uint i = 0; i < orderData0x.length/352; i++) {\r\n            assembly {\r\n                maker := mload(add(orderData0x, add(mul(i, 352), 32)))\r\n                taker := mload(add(orderData0x, add(mul(i, 352), 64)))\r\n                makerToken := mload(add(orderData0x, add(mul(i, 352), 96)))\r\n                takerToken := mload(add(orderData0x, add(mul(i, 352), 128)))\r\n                feeRecipient := mload(add(orderData0x, add(mul(i, 352), 160)))\r\n                makerTokenAmount := mload(add(orderData0x, add(mul(i, 352), 192)))\r\n                takerTokenAmount := mload(add(orderData0x, add(mul(i, 352), 224)))\r\n                makerFee := mload(add(orderData0x, add(mul(i, 352), 256)))\r\n                takerFee := mload(add(orderData0x, add(mul(i, 352), 288)))\r\n                expirationTimestampInSec := mload(add(orderData0x, add(mul(i, 352), 320)))\r\n                salt := mload(add(orderData0x, add(mul(i, 352), 352)))\r\n            }\r\n            orderAddresses[i] = [\r\n                maker,\r\n                taker,\r\n                makerToken,\r\n                takerToken,\r\n                feeRecipient\r\n            ];\r\n            orderValues[i] = [\r\n                makerTokenAmount,\r\n                takerTokenAmount,\r\n                makerFee,\r\n                takerFee,\r\n                expirationTimestampInSec,\r\n                salt\r\n            ];\r\n        }\r\n    }\r\n\r\n    /// @param signatures ECDSA signatures in raw bytes (rsv).\r\n    function getSignatureParts(\r\n        bytes signatures)\r\n        public\r\n        pure\r\n        returns (\r\n            uint8[] vs,\r\n            bytes32[] rs,\r\n            bytes32[] ss)\r\n    {\r\n        vs = new uint8[](signatures.length/65);\r\n        rs = new bytes32[](signatures.length/65);\r\n        ss = new bytes32[](signatures.length/65);\r\n        for (uint i = 0; i < signatures.length/65; i++) {\r\n            uint8 v;\r\n            bytes32 r;\r\n            bytes32 s;\r\n            assembly {\r\n                r := mload(add(signatures, add(mul(i, 65), 32)))\r\n                s := mload(add(signatures, add(mul(i, 65), 64)))\r\n                v := mload(add(signatures, add(mul(i, 65), 65)))\r\n            }\r\n            if (v < 27) {\r\n                v = v + 27;\r\n            }\r\n            vs[i] = v;\r\n            rs[i] = r;\r\n            ss[i] = s;\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates partial value given a numerator and denominator.\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to calculate partial of.\r\n    /// @return Partial value of target.\r\n    function getPartialAmount(uint numerator, uint denominator, uint target)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(numerator, target), denominator);\r\n    }\r\n\r\n    function set0xExchange (\r\n        address _exchange)\r\n        public\r\n        onlyOwner\r\n    {\r\n        exchangeContract = _exchange;\r\n    }\r\n\r\n    function setZRXToken (\r\n        address _zrxToken)\r\n        public\r\n        onlyOwner\r\n    {\r\n        zrxTokenContract = _zrxToken;\r\n    }\r\n\r\n    function set0xTokenProxy (\r\n        address _proxy)\r\n        public\r\n        onlyOwner\r\n    {\r\n        tokenTransferProxyContract = _proxy;\r\n    }\r\n\r\n    function approveFor (\r\n        address token,\r\n        address spender,\r\n        uint value)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        eip20Approve(\r\n            token,\r\n            spender,\r\n            value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _take0xTrade(\r\n        address trader,\r\n        uint sourceTokenAmountToUse,\r\n        address[5][] orderAddresses0x,\r\n        uint[6][] orderValues0x,\r\n        bytes signature)\r\n        internal\r\n        returns (uint sourceTokenUsedAmount, uint destTokenAmount) \r\n    {\r\n        uint[3] memory summations; // takerTokenAmountTotal, makerTokenAmountTotal, zrxTokenAmount\r\n\r\n        for (uint i = 0; i < orderAddresses0x.length; i++) {\r\n            summations[0] += orderValues0x[0][1]; // takerTokenAmountTotal\r\n            summations[1] += orderValues0x[0][0]; // makerTokenAmountTotal\r\n            \r\n            if (orderAddresses0x[i][4] != address(0) && // feeRecipient\r\n                    orderValues0x[i][3] > 0 // takerFee\r\n            ) {\r\n                summations[2] += orderValues0x[i][3]; // zrxTokenAmount\r\n            }\r\n        }\r\n        if (summations[2] > 0) {\r\n            // The 0x TokenTransferProxy already has unlimited transfer allowance for ZRX from this contract (set during deployment of this contract)\r\n            eip20TransferFrom(\r\n                zrxTokenContract,\r\n                trader,\r\n                this,\r\n                summations[2]);\r\n        }\r\n\r\n        (uint8[] memory v, bytes32[] memory r, bytes32[] memory s) = getSignatureParts(signature);\r\n\r\n        // Increase the allowance for 0x Exchange Proxy to transfer the sourceToken needed for the 0x trade\r\n        // orderAddresses0x[0][3] -> takerToken/sourceToken\r\n        eip20Approve(\r\n            orderAddresses0x[0][3],\r\n            tokenTransferProxyContract,\r\n            EIP20(orderAddresses0x[0][3]).allowance(this, tokenTransferProxyContract).add(sourceTokenAmountToUse));\r\n\r\n        if (orderAddresses0x.length > 0) {\r\n            sourceTokenUsedAmount = ExchangeInterface(exchangeContract).fillOrdersUpTo(\r\n                orderAddresses0x,\r\n                orderValues0x,\r\n                sourceTokenAmountToUse,\r\n                false, // shouldThrowOnInsufficientBalanceOrAllowance\r\n                v,\r\n                r,\r\n                s);\r\n        } else {\r\n            sourceTokenUsedAmount = ExchangeInterface(exchangeContract).fillOrder(\r\n                orderAddresses0x[0],\r\n                orderValues0x[0],\r\n                sourceTokenAmountToUse,\r\n                false, // shouldThrowOnInsufficientBalanceOrAllowance\r\n                v[0],\r\n                r[0],\r\n                s[0]);\r\n        }\r\n\r\n        destTokenAmount = getPartialAmount(\r\n            sourceTokenUsedAmount,\r\n            summations[0], // takerTokenAmountTotal (aka sourceTokenAmount)\r\n            summations[1]  // makerTokenAmountTotal (aka destTokenAmount)\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_exchange\",\"type\":\"address\"}],\"name\":\"set0xExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_zrxToken\",\"type\":\"address\"}],\"name\":\"setZRXToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"trader\",\"type\":\"address\"},{\"name\":\"vaultAddress\",\"type\":\"address\"},{\"name\":\"sourceTokenAmountToUse\",\"type\":\"uint256\"},{\"name\":\"orderData0x\",\"type\":\"bytes\"},{\"name\":\"signature0x\",\"type\":\"bytes\"}],\"name\":\"take0xTrade\",\"outputs\":[{\"name\":\"destTokenAddress\",\"type\":\"address\"},{\"name\":\"destTokenAmount\",\"type\":\"uint256\"},{\"name\":\"sourceTokenUsedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBZxContractAddress\",\"type\":\"address\"}],\"name\":\"transferBZxOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderData0x\",\"type\":\"bytes\"}],\"name\":\"getOrderValuesFromData\",\"outputs\":[{\"name\":\"orderAddresses\",\"type\":\"address[5][]\"},{\"name\":\"orderValues\",\"type\":\"uint256[6][]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"},{\"name\":\"target\",\"type\":\"uint256\"}],\"name\":\"getPartialAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenTransferProxyContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zrxTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"getSignatureParts\",\"outputs\":[{\"name\":\"vs\",\"type\":\"uint8[]\"},{\"name\":\"rs\",\"type\":\"bytes32[]\"},{\"name\":\"ss\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"set0xTokenProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_exchange\",\"type\":\"address\"},{\"name\":\"_zrxToken\",\"type\":\"address\"},{\"name\":\"_proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousBZxContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newBZxContract\",\"type\":\"address\"}],\"name\":\"BZxOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BZxTo0x","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000012459c951127e0c374ff9105dda097662a027093000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f4980000000000000000000000008da0d80f5007ef1e431dd2127178d224e32c2ef4","Library":"","SwarmSource":"bzzr://7ab99ef6750be92b7cc2e00db6e56f36ea0e29760b56e3fa50015859e312935c"}]}