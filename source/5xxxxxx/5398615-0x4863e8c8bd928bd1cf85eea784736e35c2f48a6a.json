{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ERC20 {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract BasicToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public totalSupply;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => uint256) balances;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\r\n            revert();\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    /// @param _owner address The address which owns the funds.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @return uint256 specifying the amount of tokens still available for the spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner address The address to query the the balance of.\r\n    /// @return uint256 representing the amount owned by the passed address.\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @dev transfer token to a specified address.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another.\r\n    /// @param _from address The address which you want to send tokens from.\r\n    /// @param _to address The address which you want to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed _by, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    /// account.\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerCandidate() {\r\n        if (msg.sender != newOwnerCandidate) {\r\n            revert();\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        require(_newOwnerCandidate != address(0));\r\n\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accept ownership transfer. This method needs to be called by the previously proposed owner.\r\n    function acceptOwnership() external onlyOwnerCandidate {\r\n        address previousOwner = owner;\r\n\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = address(0);\r\n\r\n        OwnershipTransferred(previousOwner, owner);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract TokenHolder is Ownable {\r\n    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\r\n    /// @param _tokenAddress address The address of the ERC20 contract.\r\n    /// @param _amount uint256 The amount of tokens to be transferred.\r\n    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) onlyOwner returns (bool success) {\r\n        return ERC20(_tokenAddress).transfer(owner, _amount);\r\n    }\r\n}\r\n\r\ncontract BlokToken is Ownable, BasicToken, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Blok\";\r\n    string public constant symbol = \"BLO\";\r\n\r\n    // Using same decimal value as ETH (makes ETH-BLO conversion much easier).\r\n    uint8 public constant decimals = 18;\r\n\r\n    // States whether creating more tokens is allowed or not.\r\n    // Used during token sale.\r\n    bool public isMinting = true;\r\n\r\n    event MintingEnded();\r\n\r\n    modifier onlyDuringMinting() {\r\n        require(isMinting);\r\n\r\n        _;\r\n    }\r\n\r\n    modifier onlyAfterMinting() {\r\n        require(!isMinting);\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Mint Blok tokens.\r\n    /// @param _to address Address to send minted Blok to.\r\n    /// @param _amount uint256 Amount of Blok tokens to mint.\r\n    function mint(address _to, uint256 _amount) external onlyOwner onlyDuringMinting {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n\r\n        Transfer(0x0, _to, _amount);\r\n    }\r\n\r\n    /// @dev End minting mode.\r\n    function endMinting() external onlyOwner {\r\n        if (isMinting == false) {\r\n            return;\r\n        }\r\n\r\n        isMinting = false;\r\n\r\n        MintingEnded();\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if still minting.\r\n    /// @param _spender address The address which will spend the funds.\r\n    /// @param _value uint256 The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public onlyAfterMinting returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if still minting.\r\n    /// @param _to address The address to transfer to.\r\n    /// @param _value uint256 The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public onlyAfterMinting returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /// @dev Same ERC20 behavior, but reverts if still minting.\r\n    /// @param _from address The address which you want to send tokens from.\r\n    /// @param _to address The address which you want to transfer to.\r\n    /// @param _value uint256 the amount of tokens to be transferred.\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyAfterMinting returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n}\r\n\r\ncontract BlokTokenSale is Ownable, TokenHolder {\r\n    using SafeMath for uint256;\r\n\r\n    // External parties:\r\n\r\n    // BLO token contract.\r\n    BlokToken public blok;\r\n\r\n    // Vesting contract for pre-sale participants.\r\n    VestingTrustee public trustee;\r\n\r\n    // Received funds are forwarded to this address.\r\n    address public fundingRecipient;\r\n\r\n    // Blok token unit.\r\n    // Using same decimal value as ETH (makes ETH-BLO conversion much easier).\r\n    // This is the same as in Blok token contract.\r\n    uint256 public constant TOKEN_UNIT = 10 ** 18;\r\n\r\n    // Maximum number of tokens in circulation: 10 trillion.\r\n    uint256 public constant MAX_TOKENS = 360000000 * TOKEN_UNIT;\r\n\r\n    // Maximum tokens offered in the sale.\r\n    uint256 public constant MAX_TOKENS_SOLD = 234000000 * TOKEN_UNIT;\r\n\r\n    // BLO to 1 wei ratio.\r\n    uint256 public constant BLO_PER_WEI = 5700;\r\n\r\n    // Sale start and end timestamps.\r\n    uint256 public constant SALE_DURATION = 30 days;\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    // Amount of tokens sold until now in the sale.\r\n    uint256 public tokensSold = 0;\r\n\r\n    // Participation caps, according to KYC tiers.\r\n    uint256 public constant TIER_1_CAP = 20000 ether; // Maximum uint256 value\r\n\r\n    // Accumulated amount each participant has contributed so far.\r\n    mapping (address => uint256) public participationHistory;\r\n\r\n    // Maximum amount that each participant is allowed to contribute (in WEI).\r\n    mapping (address => uint256) public participationCaps;\r\n\r\n    // Maximum amount ANYBODY is currently allowed to contribute.\r\n    uint256 public hardParticipationCap = uint256(-1);\r\n\r\n    // Vesting information for special addresses:\r\n    struct TokenGrant {\r\n        uint256 value;\r\n        uint256 startOffset;\r\n        uint256 cliffOffset;\r\n        uint256 endOffset;\r\n        uint256 installmentLength;\r\n        uint8 percentVested;\r\n    }\r\n\r\n    address[] public tokenGrantees;\r\n    mapping (address => TokenGrant) public tokenGrants;\r\n    uint256 public lastGrantedIndex = 0;\r\n    uint256 public constant MAX_TOKEN_GRANTEES = 100;\r\n    uint256 public constant GRANT_BATCH_SIZE = 10;\r\n\r\n    address public constant RESERVE_TOKENS = 0xA67E1c56A5e0363B61a23670FFC0FcD8F09f178d;\r\n    address public constant TEAM_WALLET = 0x52aA6A62404107742ac01Ff247ED47b49b16c40A;\r\n    address public constant BOUNTY_WALLET = 0xCf1e64Ce2740A03192F1d7a3234AABd88c025c4B;    \r\n\r\n    event TokensIssued(address indexed _to, uint256 _tokens);\r\n\r\n    /// @dev Reverts if called when not during sale.\r\n    modifier onlyDuringSale() {\r\n        require(!saleEnded() && now >= startTime);\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Reverts if called before sale ends.\r\n    modifier onlyAfterSale() {\r\n        require(saleEnded());\r\n\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor that initializes the sale conditions.\r\n    /// @param _fundingRecipient address The address of the funding recipient.\r\n    /// @param _startTime uint256 The start time of the token sale.\r\n    function BlokTokenSale(address _fundingRecipient, uint256 _startTime) {\r\n        require(_fundingRecipient != address(0));\r\n        require(_startTime > now);\r\n\r\n        // Deploy new BlokToken contract.\r\n        blok = new BlokToken();\r\n\r\n        // Deploy new VestingTrustee contract.\r\n        trustee = new VestingTrustee(blok);\r\n\r\n        fundingRecipient = _fundingRecipient;\r\n        startTime = _startTime;\r\n        endTime = startTime + SALE_DURATION;\r\n\r\n        // Initialize special vesting grants.\r\n        initTokenGrants();\r\n    }\r\n\r\n    /// @dev Initialize token grants.\r\n    function initTokenGrants() private onlyOwner {\r\n        tokenGrantees.push(RESERVE_TOKENS);\r\n        tokenGrants[RESERVE_TOKENS] = TokenGrant(MAX_TOKENS.mul(18).div(100), 0, 0, 10 days, 1 days, 0);\r\n\r\n        tokenGrantees.push(TEAM_WALLET);\r\n        tokenGrants[TEAM_WALLET] = TokenGrant(MAX_TOKENS.mul(13).div(100), 0, 0, 10 days, 1 days, 0);\r\n\r\n        tokenGrantees.push(BOUNTY_WALLET);\r\n        tokenGrants[BOUNTY_WALLET] = TokenGrant(MAX_TOKENS.mul(4).div(100), 0, 0, 10 days, 1 days, 0);\r\n    }\r\n\r\n    /// @dev Adds a Blok token vesting grant.\r\n    /// @param _grantee address The address of the token grantee. Can be granted only once.\r\n    /// @param _value uint256 The value of the grant.\r\n    function addTokenGrant(address _grantee, uint256 _value) external onlyOwner {\r\n        require(_grantee != address(0));\r\n        require(_value > 0);\r\n        require(tokenGrantees.length + 1 <= MAX_TOKEN_GRANTEES);\r\n\r\n        // Verify the grant doesn't already exist.\r\n        require(tokenGrants[_grantee].value == 0);\r\n        for (uint i = 0; i < tokenGrantees.length; i++) {\r\n            require(tokenGrantees[i] != _grantee);\r\n        }\r\n\r\n        // Add grant and add to grantee list.\r\n        tokenGrantees.push(_grantee);\r\n        tokenGrants[_grantee] = TokenGrant(_value, 0, 1 years, 1 years, 1 days, 50);\r\n    }\r\n\r\n    /// @dev Deletes a Blok token grant.\r\n    /// @param _grantee address The address of the token grantee.\r\n    function deleteTokenGrant(address _grantee) external onlyOwner {\r\n        require(_grantee != address(0));\r\n\r\n        // Delete the grant from the keys array.\r\n        for (uint i = 0; i < tokenGrantees.length; i++) {\r\n            if (tokenGrantees[i] == _grantee) {\r\n                delete tokenGrantees[i];\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Delete the grant from the mapping.\r\n        delete tokenGrants[_grantee];\r\n    }\r\n\r\n    /// @dev Add a list of participants to a capped participation tier.\r\n    /// @param _participants address[] The list of participant addresses.\r\n    /// @param _cap uint256 The cap amount (in ETH).\r\n    function setParticipationCap(address[] _participants, uint256 _cap) private onlyOwner {\r\n        for (uint i = 0; i < _participants.length; i++) {\r\n            participationCaps[_participants[i]] = _cap;\r\n        }\r\n    }\r\n\r\n    /// @dev Add a list of participants to cap tier #1.\r\n    /// @param _participants address[] The list of participant addresses.\r\n    function setTier1Participants(address[] _participants) external onlyOwner {\r\n        setParticipationCap(_participants, TIER_1_CAP);\r\n    }\r\n\r\n    /// @dev Set hard participation cap for all participants.\r\n    /// @param _cap uint256 The hard cap amount.\r\n    function setHardParticipationCap(uint256 _cap) external onlyOwner {\r\n        require(_cap > 0);\r\n\r\n        hardParticipationCap = _cap;\r\n    }\r\n\r\n    /// @dev Fallback function that will delegate the request to create().\r\n    function () external payable onlyDuringSale {\r\n        create(msg.sender);\r\n    }\r\n\r\n    /// @dev Create and sell tokens to the caller.\r\n    /// @param _recipient address The address of the recipient receiving the tokens.\r\n    function create(address _recipient) public payable onlyDuringSale {\r\n        require(_recipient != address(0));\r\n\r\n        // Enforce participation cap (in Wei received).\r\n        uint256 weiAlreadyParticipated = participationHistory[msg.sender];\r\n        uint256 participationCap = SafeMath.min256(TOKEN_UNIT.mul(15).add(participationCaps[msg.sender]), hardParticipationCap);\r\n        uint256 cappedWeiReceived = SafeMath.min256(msg.value, participationCap.sub(weiAlreadyParticipated));\r\n        require(cappedWeiReceived > 0);\r\n\r\n        // Accept funds and transfer to funding recipient.\r\n        uint256 weiLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold).div(BLO_PER_WEI);\r\n        uint256 weiToParticipate = SafeMath.min256(cappedWeiReceived, weiLeftInSale);\r\n        participationHistory[msg.sender] = weiAlreadyParticipated.add(weiToParticipate);\r\n        fundingRecipient.transfer(weiToParticipate);\r\n\r\n        // Issue tokens and transfer to recipient.\r\n        uint256 tokensLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold);\r\n        uint256 tokensToIssue = weiToParticipate.mul(BLO_PER_WEI);\r\n        if (tokensLeftInSale.sub(tokensToIssue) < BLO_PER_WEI) {\r\n            // If purchase would cause less than BLO_PER_WEI tokens left then nobody could ever buy them.\r\n            // So, gift them to the last buyer.\r\n            tokensToIssue = tokensLeftInSale;\r\n        }\r\n        tokensSold = tokensSold.add(tokensToIssue);\r\n        issueTokens(_recipient, tokensToIssue);\r\n\r\n        // Partial refund if full participation not possible\r\n        // e.g. due to cap being reached.\r\n        uint256 refund = msg.value.sub(weiToParticipate);\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n    }\r\n\r\n    /// @dev Finalizes the token sale event, by stopping token minting.\r\n    function finalize() external onlyAfterSale onlyOwner {\r\n        if (!blok.isMinting()) {\r\n            revert();\r\n        }\r\n\r\n        require(lastGrantedIndex == tokenGrantees.length);\r\n\r\n        // Finish minting.\r\n        blok.endMinting();\r\n    }\r\n\r\n    /// @dev Grants pre-configured token grants in batches. When the method is called, it'll resume from the last grant,\r\n    /// from its previous run, and will finish either after granting GRANT_BATCH_SIZE grants or finishing the whole list\r\n    /// of grants.\r\n    function grantTokens() external onlyAfterSale onlyOwner {\r\n        uint endIndex = SafeMath.min256(tokenGrantees.length, lastGrantedIndex + GRANT_BATCH_SIZE);\r\n        for (uint i = lastGrantedIndex; i < endIndex; i++) {\r\n            address grantee = tokenGrantees[i];\r\n\r\n            // Calculate how many tokens have been granted, vested, and issued such that: granted = vested + issued.\r\n            TokenGrant memory tokenGrant = tokenGrants[grantee];\r\n            uint256 tokensGranted = tokenGrant.value;\r\n            uint256 tokensVesting = tokensGranted.mul(tokenGrant.percentVested).div(100);\r\n            uint256 tokensIssued = tokensGranted.sub(tokensVesting);\r\n\r\n            // Transfer issued tokens that have yet to be transferred to grantee.\r\n            if (tokensIssued > 0) {\r\n                issueTokens(grantee, tokensIssued);\r\n            }\r\n\r\n            // Transfer vested tokens that have yet to be transferred to vesting trustee, and initialize grant.\r\n            if (tokensVesting > 0) {\r\n                issueTokens(trustee, tokensVesting);\r\n                trustee.grant(grantee, tokensVesting, now.add(tokenGrant.startOffset), now.add(tokenGrant.cliffOffset),\r\n                    now.add(tokenGrant.endOffset), tokenGrant.installmentLength, true);\r\n            }\r\n\r\n            lastGrantedIndex++;\r\n        }\r\n    }\r\n\r\n    /// @dev Issues tokens for the recipient.\r\n    /// @param _recipient address The address of the recipient.\r\n    /// @param _tokens uint256 The amount of tokens to issue.\r\n    function issueTokens(address _recipient, uint256 _tokens) private {\r\n        // Request Blok token contract to mint the requested tokens for the buyer.\r\n        blok.mint(_recipient, _tokens);\r\n\r\n        TokensIssued(_recipient, _tokens);\r\n    }\r\n\r\n    /// @dev Returns whether the sale has ended.\r\n    /// @return bool Whether the sale has ended or not.\r\n    function saleEnded() private constant returns (bool) {\r\n        return tokensSold >= MAX_TOKENS_SOLD || now >= endTime;\r\n    }\r\n\r\n    /// @dev Requests to transfer control of the Blok token contract to a new owner.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    ///\r\n    /// NOTE:\r\n    ///   1. The new owner will need to call Blok token contract's acceptOwnership directly in order to accept the ownership.\r\n    ///   2. Calling this method during the token sale will prevent the token sale to continue, since only the owner of\r\n    ///      the Blok token contract can issue new tokens.\r\n    function requestBlokTokenOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        blok.requestOwnershipTransfer(_newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accepts new ownership on behalf of the Blok token contract.\r\n    // This can be used by the sale contract itself to claim back ownership of the Blok token contract.\r\n    function acceptBlokTokenOwnership() external onlyOwner {\r\n        blok.acceptOwnership();\r\n    }\r\n\r\n    /// @dev Requests to transfer control of the VestingTrustee contract to a new owner.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    ///\r\n    /// NOTE:\r\n    ///   1. The new owner will need to call VestingTrustee's acceptOwnership directly in order to accept the ownership.\r\n    ///   2. Calling this method during the token sale will prevent the token sale from finalizaing, since only the owner\r\n    ///      of the VestingTrustee contract can issue new token grants.\r\n    function requestVestingTrusteeOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        trustee.requestOwnershipTransfer(_newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accepts new ownership on behalf of the VestingTrustee contract.\r\n    /// This can be used by the token sale contract itself to claim back ownership of the VestingTrustee contract.\r\n    function acceptVestingTrusteeOwnership() external onlyOwner {\r\n        trustee.acceptOwnership();\r\n    }\r\n}\r\n\r\ncontract VestingTrustee is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // Blok token contract.\r\n    BlokToken public blok;\r\n\r\n    // Vesting grant for a speicifc holder.\r\n    struct Grant {\r\n        uint256 value;\r\n        uint256 start;\r\n        uint256 cliff;\r\n        uint256 end;\r\n        uint256 installmentLength; // In seconds.\r\n        uint256 transferred;\r\n        bool revokable;\r\n    }\r\n\r\n    // Holder to grant information mapping.\r\n    mapping (address => Grant) public grants;\r\n\r\n    // Total tokens available for vesting.\r\n    uint256 public totalVesting;\r\n\r\n    event NewGrant(address indexed _from, address indexed _to, uint256 _value);\r\n    event TokensUnlocked(address indexed _to, uint256 _value);\r\n    event GrantRevoked(address indexed _holder, uint256 _refund);\r\n\r\n    /// @dev Constructor that initializes the address of the Blok token contract.\r\n    /// @param _blok BlokToken The address of the previously deployed Blok token contract.\r\n    function VestingTrustee(BlokToken _blok) {\r\n        require(_blok != address(0));\r\n\r\n        blok = _blok;\r\n    }\r\n\r\n    /// @dev Grant tokens to a specified address.\r\n    /// @param _to address The holder address.\r\n    /// @param _value uint256 The amount of tokens to be granted.\r\n    /// @param _start uint256 The beginning of the vesting period.\r\n    /// @param _cliff uint256 Duration of the cliff period (when the first installment is made).\r\n    /// @param _end uint256 The end of the vesting period.\r\n    /// @param _installmentLength uint256 The length of each vesting installment (in seconds).\r\n    /// @param _revokable bool Whether the grant is revokable or not.\r\n    function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\r\n        uint256 _installmentLength, bool _revokable)\r\n        external onlyOwner {\r\n\r\n        require(_to != address(0));\r\n        require(_to != address(this)); // Don't allow holder to be this contract.\r\n        require(_value > 0);\r\n\r\n        // Require that every holder can be granted tokens only once.\r\n        require(grants[_to].value == 0);\r\n\r\n        // Require for time ranges to be consistent and valid.\r\n        require(_start <= _cliff && _cliff <= _end);\r\n\r\n        // Require installment length to be valid and no longer than (end - start).\r\n        require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\r\n\r\n        // Grant must not exceed the total amount of tokens currently available for vesting.\r\n        require(totalVesting.add(_value) <= blok.balanceOf(address(this)));\r\n\r\n        // Assign a new grant.\r\n        grants[_to] = Grant({\r\n            value: _value,\r\n            start: _start,\r\n            cliff: _cliff,\r\n            end: _end,\r\n            installmentLength: _installmentLength,\r\n            transferred: 0,\r\n            revokable: _revokable\r\n        });\r\n\r\n        // Since tokens have been granted, reduce the total amount available for vesting.\r\n        totalVesting = totalVesting.add(_value);\r\n\r\n        NewGrant(msg.sender, _to, _value);\r\n    }\r\n\r\n    /// @dev Revoke the grant of tokens of a specifed address.\r\n    /// @param _holder The address which will have its tokens revoked.\r\n    function revoke(address _holder) public onlyOwner {\r\n        Grant memory grant = grants[_holder];\r\n\r\n        // Grant must be revokable.\r\n        require(grant.revokable);\r\n\r\n        // Calculate amount of remaining tokens that are still available to be\r\n        // returned to owner.\r\n        uint256 refund = grant.value.sub(grant.transferred);\r\n\r\n        // Remove grant information.\r\n        delete grants[_holder];\r\n\r\n        // Update total vesting amount and transfer previously calculated tokens to owner.\r\n        totalVesting = totalVesting.sub(refund);\r\n        blok.transfer(msg.sender, refund);\r\n\r\n        GrantRevoked(_holder, refund);\r\n    }\r\n\r\n    /// @dev Calculate the total amount of vested tokens of a holder at a given time.\r\n    /// @param _holder address The address of the holder.\r\n    /// @param _time uint256 The specific time to calculate against.\r\n    /// @return a uint256 Representing a holder's total amount of vested tokens.\r\n    function vestedTokens(address _holder, uint256 _time) external constant returns (uint256) {\r\n        Grant memory grant = grants[_holder];\r\n        if (grant.value == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return calculateVestedTokens(grant, _time);\r\n    }\r\n\r\n    /// @dev Calculate amount of vested tokens at a specifc time.\r\n    /// @param _grant Grant The vesting grant.\r\n    /// @param _time uint256 The time to be checked\r\n    /// @return a uint256 Representing the amount of vested tokens of a specific grant.\r\n    function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\r\n        // If we're before the cliff, then nothing is vested.\r\n        if (_time < _grant.cliff) {\r\n            return 0;\r\n        }\r\n\r\n        // If we're after the end of the vesting period - everything is vested;\r\n        if (_time >= _grant.end) {\r\n            return _grant.value;\r\n        }\r\n\r\n        // Calculate amount of installments past until now.\r\n        //\r\n        // NOTE result gets floored because of integer division.\r\n        uint256 installmentsPast = _time.sub(_grant.start).div(_grant.installmentLength);\r\n\r\n        // Calculate amount of days in entire vesting period.\r\n        uint256 vestingDays = _grant.end.sub(_grant.start);\r\n\r\n        // Calculate and return installments that have passed according to vesting days that have passed.\r\n        return _grant.value.mul(installmentsPast.mul(_grant.installmentLength)).div(vestingDays);\r\n    }\r\n\r\n    /// @dev Unlock vested tokens and transfer them to their holder.\r\n    /// @return a uint256 Representing the amount of vested tokens transferred to their holder.\r\n    function unlockVestedTokens() external {\r\n        Grant storage grant = grants[msg.sender];\r\n\r\n        // Require that there will be funds left in grant to tranfser to holder.\r\n        require(grant.value != 0);\r\n\r\n        // Get the total amount of vested tokens, acccording to grant.\r\n        uint256 vested = calculateVestedTokens(grant, now);\r\n        if (vested == 0) {\r\n            return;\r\n        }\r\n\r\n        // Make sure the holder doesn't transfer more than what he already has.\r\n        uint256 transferable = vested.sub(grant.transferred);\r\n        if (transferable == 0) {\r\n            return;\r\n        }\r\n\r\n        // Update transferred and total vesting amount, then transfer remaining vested funds to holder.\r\n        grant.transferred = grant.transferred.add(transferable);\r\n        totalVesting = totalVesting.sub(transferable);\r\n        blok.transfer(msg.sender, transferable);\r\n\r\n        TokensUnlocked(msg.sender, transferable);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastGrantedIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS_SOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestBlokTokenOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blok\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"grantTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_grantee\",\"type\":\"address\"}],\"name\":\"deleteTokenGrant\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participationHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setHardParticipationCap\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardParticipationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participationCaps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER_1_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKEN_GRANTEES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptBlokTokenOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participants\",\"type\":\"address[]\"}],\"name\":\"setTier1Participants\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BLO_PER_WEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenGrants\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"startOffset\",\"type\":\"uint256\"},{\"name\":\"cliffOffset\",\"type\":\"uint256\"},{\"name\":\"endOffset\",\"type\":\"uint256\"},{\"name\":\"installmentLength\",\"type\":\"uint256\"},{\"name\":\"percentVested\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_grantee\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addTokenGrant\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestVestingTrusteeOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVE_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptVestingTrusteeOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenGrantees\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BOUNTY_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GRANT_BATCH_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trustee\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fundingRecipient\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"TokensIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BlokTokenSale","CompilerVersion":"v0.4.13+commit.fb4cb1a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f354e8d1030168d32d94435fc23de1fd6b46840f000000000000000000000000000000000000000000000000000000005acbfe80","Library":"","SwarmSource":"bzzr://70fe28d3116ed1d12e84879db9c3bea2f6f03d1a331ab0bf6d956e6a4b5006bb"}]}