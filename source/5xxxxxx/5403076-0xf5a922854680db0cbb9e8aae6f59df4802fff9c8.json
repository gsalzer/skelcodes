{"status":"1","message":"OK","result":[{"SourceCode":"//  ___             _                         ___              _\r\n// | _ )  _  _   __| |  __ _    __ __  ___   | _ \\  ___   ___ | |_\r\n// | _ \\ | || | / _` | / _` |   \\ V / (_-<   |  _/ / -_) (_-< |  _|\r\n// |___/  \\_,_| \\__,_| \\__,_|    \\_/  /__/   |_|   \\___| /__/  \\__|\r\n\r\n// Buda vs Pest\r\n// the most ridiculous Rock-Scissor-Paper game on Ethereum\r\n// Copyright 2018 www.budapestgame.com\r\n\r\n\r\npragma solidity ^0.4.18;\r\n\r\n// File: contracts-raw/Ownable.sol\r\n\r\ncontract Ownable {\r\n      address public        owner;\r\n\r\n\r\n        event OwnershipTransferred (address indexed prevOwner, address indexed newOwner);\r\n\r\n        function Ownable () public {\r\n                owner       = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner () {\r\n                require (msg.sender == owner);\r\n                _;\r\n        }\r\n\r\n        function transferOwnership (address newOwner) public onlyOwner {\r\n              require (newOwner != address (0));\r\n\r\n              OwnershipTransferred (owner, newOwner);\r\n              owner     = newOwner;\r\n        }\r\n}\r\n\r\n// File: contracts-raw/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n        function add (uint256 a, uint256 b) internal pure returns (uint256) {\r\n              uint256   c = a + b;\r\n              assert (c >= a);\r\n              return c;\r\n        }\r\n\r\n        function sub (uint256 a, uint256 b) internal pure returns (uint256) {\r\n              assert (b <= a);\r\n              return a - b;\r\n        }\r\n\r\n        function mul (uint256 a, uint256 b) internal pure returns (uint256) {\r\n                if (a == 0) {\r\n                        return 0;\r\n                }\r\n                uint256 c = a * b;\r\n                assert (c/a == b);\r\n                return c;\r\n        }\r\n\r\n        // Solidty automatically throws\r\n        // function div (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        //       // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        //       uint256   c = a/b;\r\n        //       // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        //       return c;\r\n        // }\r\n}\r\n\r\n// File: contracts-raw/StandardToken.sol\r\n\r\n// ERC20 is ERC20Basic\r\n\r\n\r\n// ERC20 standard\r\ncontract ERC20 {\r\n        // Basic\r\n        function totalSupply () public view returns (uint256);\r\n        function balanceOf (address tokenOwner) public view returns (uint256);\r\n        function transfer (address to, uint256 amount) public returns (bool);\r\n        event Transfer (address indexed from, address indexed to, uint256 amount);\r\n\r\n        // Additional\r\n        function allowance (address tokenOwner, address spender) public view returns (uint256);\r\n        function approve (address spender, uint256 amount) public returns (bool);\r\n        function transferFrom (address from, address to, uint256 amount) public returns (bool);\r\n        event Approval (address indexed tokenOwner, address indexed spender, uint256 amount);\r\n}\r\n\r\n\r\n// BasicToken is ERC20Basic\r\n\r\ncontract StandardToken is ERC20 {\r\n        using SafeMath for uint256;\r\n\r\n        // Basic\r\n        uint256                             _tokenTotal;\r\n        mapping (address => uint256)        _tokenBalances;\r\n\r\n        function totalSupply () public view returns (uint256) {\r\n                return _tokenTotal;\r\n        }\r\n\r\n        function balanceOf (address tokenOwner) public view returns (uint256) {\r\n                return _tokenBalances[tokenOwner];\r\n        }\r\n\r\n        function _transfer (address to, uint256 amount) internal {\r\n                // SafeMath.sub will throw if there is not enough balance.\r\n                // SafeMath.add will throw if overflows\r\n                _tokenBalances[msg.sender]      = _tokenBalances[msg.sender].sub (amount);\r\n                _tokenBalances[to]              = _tokenBalances[to].add (amount);\r\n\r\n                Transfer (msg.sender, to, amount);\r\n        }\r\n\r\n        function transfer (address to, uint256 amount) public returns (bool) {\r\n                require (to != address (0));\r\n                require (amount <= _tokenBalances[msg.sender]);     // should not be necessary, but double checks\r\n\r\n                _transfer (to, amount);\r\n                return true;\r\n        }\r\n\r\n\r\n        // Additional\r\n        mapping (address => mapping (address => uint256)) internal  _tokenAllowance;\r\n\r\n        function allowance (address tokenOwner, address spender) public view returns (uint256) {\r\n                return _tokenAllowance[tokenOwner][spender];\r\n        }\r\n\r\n        function approve (address spender, uint256 amount) public returns (bool) {\r\n                _tokenAllowance[msg.sender][spender]   = amount;\r\n                Approval (msg.sender, spender, amount);\r\n                return true;\r\n        }\r\n\r\n        function _transferFrom (address from, address to, uint256 amount) internal {\r\n                // SafeMath.sub will throw if there is not enough balance.\r\n                // SafeMath.add will throw if overflows\r\n                _tokenBalances[from]    = _tokenBalances[from].sub (amount);\r\n                _tokenBalances[to]      = _tokenBalances[to].add (amount);\r\n\r\n                Transfer (from, to, amount);\r\n        }\r\n\r\n        function transferFrom (address from, address to, uint256 amount) public returns (bool) {\r\n                require (to != address (0));\r\n                require (amount <= _tokenBalances[from]);\r\n                require (amount <= _tokenAllowance[from][msg.sender]);\r\n\r\n                _transferFrom (from, to, amount);\r\n\r\n                _tokenAllowance[from][msg.sender]     = _tokenAllowance[from][msg.sender].sub (amount);\r\n                return true;\r\n        }\r\n}\r\n\r\n// File: contracts-raw/RockScissorPaper.sol\r\n\r\n//  ___             _                         ___              _\r\n// | _ )  _  _   __| |  __ _    __ __  ___   | _ \\  ___   ___ | |_\r\n// | _ \\ | || | / _` | / _` |   \\ V / (_-<   |  _/ / -_) (_-< |  _|\r\n// |___/  \\_,_| \\__,_| \\__,_|    \\_/  /__/   |_|   \\___| /__/  \\__|\r\n\r\n// Buda vs Pest\r\n// the most ridiculous Rock-Scissor-Paper game on Ethereum\r\n// Copyright 2018 www.budapestgame.com\r\n\r\npragma solidity ^0.4.18;\r\n\r\n\r\n\r\n\r\n\r\ncontract RSPScienceInterface {\r\n\r\n        function isRSPScience() public pure returns (bool);\r\n        function calcPoseBits (uint256 sek, uint256 posesek0, uint256 posesek1) public pure returns (uint256);\r\n}\r\n\r\n\r\ncontract RockScissorPaper is StandardToken, Ownable {\r\n        using SafeMath for uint256;\r\n\r\n        string public   name                = 'RockScissorPaper';\r\n        string public   symbol              = 'RSP';\r\n        uint8 public    decimals            = 18;\r\n\r\n        uint8 public    version             = 7;\r\n\r\n        // uint256 public  initialAmount        = 5 * 10**uint(decimals+6);\r\n\r\n        RSPScienceInterface public      rspScience;\r\n\r\n\r\n        function _setRSPScienceAddress (address addr) internal {\r\n                RSPScienceInterface     candidate   = RSPScienceInterface (addr);\r\n                require (candidate.isRSPScience ());\r\n                rspScience      = candidate;\r\n        }\r\n\r\n        function setRSPScienceAddress (address addr) public onlyOwner {\r\n                _setRSPScienceAddress (addr);\r\n        }\r\n\r\n        // Constructor is not called multiple times, fortunately\r\n        function RockScissorPaper (address addr) public {\r\n                // Onwer should be set up and become msg.sender\r\n                // During test, mint owner some amount\r\n                // During deployment, onwer himself has to buy tokens to be fair\r\n                // _mint (msg.sender, initialAmount);\r\n\r\n                if (addr != address(0)) {\r\n                        _setRSPScienceAddress (addr);\r\n                }\r\n        }\r\n\r\n        function () public payable {\r\n                revert ();\r\n        }\r\n\r\n\r\n        mapping (address => uint256) public         weiInvested;\r\n        mapping (address => uint256) public         weiRefunded;\r\n\r\n        mapping (address => address) public         referrals;\r\n        mapping (address => uint256) public         nRefs;\r\n        mapping (address => uint256) public         weiFromRefs;\r\n\r\n        event TokenInvest (address indexed purchaser, uint256 nWeis, uint256 nTokens, address referral);\r\n        event TokenRefund (address indexed purchaser, uint256 nWeis, uint256 nTokens);\r\n\r\n        // Buying and selling incur minting and burning\r\n        function _mint (address tokenOwner, uint256 amount) internal {\r\n                _tokenTotal                     = _tokenTotal.add (amount);\r\n                _tokenBalances[tokenOwner]     += amount;   // no need to require, overflow already checked above\r\n\r\n                // Just emit a Transfer Event\r\n                Transfer (address (0), tokenOwner, amount);\r\n        }\r\n\r\n        function _burn (address tokenOwner, uint256 amount) internal {\r\n                _tokenBalances[tokenOwner]  = _tokenBalances[tokenOwner].sub (amount);\r\n                _tokenTotal                -= amount;       // no need to require, underflow already checked above\r\n\r\n                // Just emit a Transfer Event\r\n                Transfer (tokenOwner, address (0), amount);\r\n        }\r\n\r\n        // Only owner is allowed to do this\r\n        function mint (uint256 amount) onlyOwner public {\r\n                _mint (msg.sender, amount);\r\n        }\r\n\r\n\r\n        function buyTokens (address referral) public payable {\r\n                // minimum buys: 1 token\r\n                uint256     amount      = msg.value.mul (5000);\r\n                require (amount >= 1 * 10**uint(decimals));\r\n\r\n                // _processPurchase, _deliverTokens using Minting\r\n                _mint (msg.sender, amount);\r\n\r\n                if ( referrals[msg.sender] == address(0) &&\r\n                     referral != msg.sender ) {\r\n                        if (referral == address(0)) {\r\n                                referral    = owner;\r\n                        }\r\n\r\n                        referrals[msg.sender]   = referral;\r\n                        nRefs[referral]        += 1;\r\n                }\r\n\r\n                // Fund logs\r\n                weiInvested[msg.sender]    += msg.value;\r\n                TokenInvest (msg.sender, msg.value, amount, referral);\r\n        }\r\n\r\n        function sellTokens (uint256 amount) public {\r\n                _burn (msg.sender, amount);\r\n\r\n                // uint256     nWeis   = amount/rate * 0.9;\r\n                uint256     nWeis   = amount / 5000;\r\n                // gameBalance        -= nWeis;\r\n\r\n                // Fund logs\r\n                weiRefunded[msg.sender]     += nWeis;\r\n                TokenRefund (msg.sender, nWeis, amount);\r\n\r\n                msg.sender.transfer (nWeis);\r\n        }\r\n\r\n\r\n\r\n        // Gamings\r\n        struct GameRSP {\r\n                address         creator;\r\n                uint256         creatorPose;\r\n                // uint256\r\n                uint256         nTokens;\r\n\r\n                address         player;\r\n                uint256         playerPose;\r\n                uint256         sek;\r\n                uint256         posebits;\r\n        }\r\n\r\n\r\n        GameRSP[]   games;\r\n        // mapping (address => uint256) public         lastGameId;\r\n\r\n        function totalGames () public view returns (uint256) {\r\n                return games.length;\r\n        }\r\n\r\n        function gameInfo (uint256 gameId) public view returns (address, uint256, uint256, address, uint256, uint256, uint256) {\r\n                GameRSP storage     game    = games[gameId];\r\n\r\n                return (\r\n                    game.creator,\r\n                    game.creatorPose,\r\n                    game.nTokens,\r\n                    game.player,\r\n                    game.playerPose,\r\n                    game.sek,\r\n                    game.posebits\r\n                );\r\n        }\r\n\r\n\r\n        uint8 public        ownerCut            = 5;                // 5 percent\r\n        uint8 public        referralCut         = 5;                // 5 percent\r\n        function changeFeeCut (uint8 ownCut, uint8 refCut) onlyOwner public {\r\n                ownerCut        = ownCut;\r\n                referralCut     = refCut;\r\n        }\r\n\r\n\r\n        event GameCreated (address indexed creator, uint256 gameId, uint256 pose);\r\n        event GamePlayed (address indexed player, uint256 gameId, uint256 pose);\r\n        event GameSolved (address indexed solver, uint256 gameId, uint256 posebits, address referral, uint256 solverFee);\r\n\r\n        function createGame (uint256 amount, uint256 pose) public {\r\n                // Will check tokenBalance of sender in transfer ()\r\n                // require (_tokenBalances[msg.sender] >= amount && amount >= 100 * 10**uint(decimals));\r\n                require (_tokenBalances[msg.sender] >= amount);\r\n\r\n                // We set 1 as the minimal token required, but 100 tokens probably is the minimum viable\r\n                require (amount >= 1 * 10**uint(decimals));\r\n\r\n\r\n                // escrew tokens;\r\n                _transfer (this, amount);\r\n\r\n                GameRSP memory      game    = GameRSP ({\r\n                        creator:        msg.sender,\r\n                        creatorPose:    pose,\r\n                        nTokens:        amount,\r\n                        player:         address (0),\r\n                        playerPose:     0,\r\n                        sek:            0,\r\n                        posebits:       0\r\n                });\r\n\r\n                uint256     gameId          = games.push (game) - 1;\r\n\r\n                // lastGameId[msg.sender]      = gameId;\r\n                // Todo: Last GameId\r\n                // Let's be absolutely sure array don't hit its limits\r\n                require (gameId == uint256(uint32(gameId)));\r\n                GameCreated (msg.sender, gameId, pose);\r\n        }\r\n\r\n\r\n        function playGame (uint256 gameId, uint256 pose) public {\r\n                GameRSP storage     game    = games[gameId];\r\n\r\n                require (msg.sender != game.creator);\r\n                require (game.player == address (0));\r\n\r\n                uint256     nTokens = game.nTokens;\r\n                // Will check tokenBalance of sender in transfer ()\r\n                require (_tokenBalances[msg.sender] >= nTokens);\r\n\r\n                // escrew tokens;\r\n                _transfer (this, nTokens);\r\n\r\n                game.player         = msg.sender;\r\n                game.playerPose     = pose;\r\n\r\n                GamePlayed (msg.sender, gameId, pose);\r\n        }\r\n\r\n        // Convenience functions\r\n        function buyAndCreateGame (uint256 amount, uint256 pose, address referral) public payable {\r\n                buyTokens (referral);\r\n                createGame (amount, pose);\r\n        }\r\n\r\n        function buyAndPlayGame (uint256 gameId, uint256 pose, address referral) public payable {\r\n                buyTokens (referral);\r\n                playGame (gameId, pose);\r\n        }\r\n\r\n\r\n        function _solveGame (uint256 gameId, uint256 sek, uint256 solFee) public {\r\n                GameRSP storage     game    = games[gameId];\r\n\r\n                require (game.player != address (0));\r\n                uint256     nTokens     = game.nTokens;\r\n\r\n                require (_tokenBalances[this] >= nTokens * 2);\r\n\r\n                uint256     ownerFee            = nTokens * 2 * ownerCut / 100;\r\n                uint256     referralFee         = nTokens * 2 * referralCut / 100;\r\n                uint256     winnerPrize         = nTokens * 2 - ownerFee - referralFee - solFee;\r\n                uint256     drawPrize           = nTokens - solFee/2;\r\n\r\n                require (game.sek == 0 && sek != 0);\r\n                game.sek        = sek;\r\n\r\n                address     referral;\r\n                // Let's start solving the game\r\n                uint256     posebits        = rspScience.calcPoseBits (sek, game.creatorPose, game.playerPose);\r\n\r\n                // RK, SC, PA,   RK, SC, PA\r\n                // 1,  2,  4,    8,  16, 32\r\n                if ((posebits % 9) == 0) {                                  // 9, 18 or 36\r\n                        require (drawPrize >= 0);\r\n\r\n                        // draw (we don't take any fees - fair enough?)\r\n                        _transferFrom (this, game.creator, drawPrize);\r\n                        _transferFrom (this, game.player, drawPrize);\r\n                }\r\n                else if ((posebits % 17) == 0 || posebits == 12) {          // 12, 17, or 34\r\n                        require (winnerPrize >= 0);\r\n\r\n                        referral            = referrals[game.creator];\r\n                        if (referral == address(0)) {\r\n                                referral    = owner;\r\n                        }\r\n\r\n                        // creator wins\r\n                        _transferFrom (this, game.creator, winnerPrize);\r\n                        _transferFrom (this, referral, referralFee);\r\n                        _transferFrom (this, owner, ownerFee);\r\n\r\n                        weiFromRefs[referral]     += referralFee;\r\n                }\r\n                else if ((posebits % 10) == 0 || posebits == 33) {          // 10, 20, or 33\r\n                        require (winnerPrize >= 0);\r\n\r\n                        referral            = referrals[game.player];\r\n                        if (referral == address(0)) {\r\n                                referral    = owner;\r\n                        }\r\n\r\n                        // player wins\r\n                        _transferFrom (this, game.player, winnerPrize);\r\n                        _transferFrom (this, referral, referralFee);\r\n                        _transferFrom (this, owner, ownerFee);\r\n\r\n                        weiFromRefs[referral]     += referralFee;\r\n                }\r\n\r\n                if (solFee > 0) {\r\n                        _transferFrom (this, msg.sender, solFee);\r\n                }\r\n\r\n                game.posebits    = posebits;\r\n                GameSolved (msg.sender, gameId, game.posebits, referral, solFee);\r\n        }\r\n\r\n\r\n\r\n        // Anyone could call this to claim the prize (an pay gas himself)\r\n        function solveGame (uint256 gameId, uint256 sek) public {\r\n                _solveGame (gameId, sek, 0);\r\n        }\r\n\r\n        // Or the game could be automatically solved a few moments later by the owner,\r\n        // charging a 'solverFee'\r\n        function autoSolveGame (uint256 gameId, uint256 sek, uint256 solFee) onlyOwner public {\r\n                _solveGame (gameId, sek, solFee);\r\n        }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"weiRefunded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"pose\",\"type\":\"uint256\"},{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"buyAndCreateGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"sek\",\"type\":\"uint256\"},{\"name\":\"solFee\",\"type\":\"uint256\"}],\"name\":\"_solveGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"pose\",\"type\":\"uint256\"}],\"name\":\"playGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nRefs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"pose\",\"type\":\"uint256\"}],\"name\":\"createGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setRSPScienceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ownCut\",\"type\":\"uint8\"},{\"name\":\"refCut\",\"type\":\"uint8\"}],\"name\":\"changeFeeCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"weiInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"gameInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"sek\",\"type\":\"uint256\"},{\"name\":\"solFee\",\"type\":\"uint256\"}],\"name\":\"autoSolveGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rspScience\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"weiFromRefs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"pose\",\"type\":\"uint256\"},{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"buyAndPlayGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"sek\",\"type\":\"uint256\"}],\"name\":\"solveGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nWeis\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"TokenInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nWeis\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nTokens\",\"type\":\"uint256\"}],\"name\":\"TokenRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pose\",\"type\":\"uint256\"}],\"name\":\"GameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pose\",\"type\":\"uint256\"}],\"name\":\"GamePlayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"solver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"posebits\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"solverFee\",\"type\":\"uint256\"}],\"name\":\"GameSolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RockScissorPaper","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"0000000000000000000000009f0215d233d2fb3aa936ea4874ed733f95ef1dfe","Library":"","SwarmSource":"bzzr://a04f0caf7a869681e18837cb812e0dbcfaf64d0a941434f8338f0e01cbbeda0f"}]}