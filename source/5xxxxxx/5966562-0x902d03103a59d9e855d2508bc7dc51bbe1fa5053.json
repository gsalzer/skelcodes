{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/**\r\n * @title Utility interfaces\r\n * @author Biglabs Pte. Ltd.\r\n * @dev Smart contract with owner\r\n*/\r\n\r\ncontract Owner {\r\n    /**\r\n    * @dev Get smart contract's owner\r\n    * @return The owner of the smart contract\r\n    */\r\n    function owner() public view returns (address);\r\n    \r\n    //check address is a valid owner (owner or coOwner)\r\n    function isValidOwner(address _address) public view returns(bool);\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Utility smart contracts\r\n * @author Biglabs Pte. Ltd.\r\n * @dev Upgradable contract with agent\r\n */\r\n \r\ncontract Upgradable {\r\n    function upgrade() public;\r\n    function getRequiredTokens(uint _level) public pure returns (uint);\r\n    function getLevel() public view returns (uint);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Utility smart contracts\r\n * @author Biglabs Pte. Ltd.\r\n * @dev Timeline smart contract (within the period)\r\n */\r\n \r\ncontract Timeline {\r\n    //start time\r\n    uint public startTime;\r\n\r\n    //end time\r\n    uint public endTime;\r\n\r\n    modifier started() {\r\n        require(now >= startTime);\r\n        _;\r\n    }\r\n\r\n    modifier notEnded() {\r\n        require(now <= endTime);\r\n        _;\r\n    }\r\n\r\n    modifier isEnded() {\r\n        require(now >= endTime);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhileOpen() {\r\n        require(now >= startTime && now <= endTime);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Timeline constructor\r\n     * @param _startTime The opening time in seconds (unix Time)\r\n     * @param _endTime The closing time in seconds (unix Time)\r\n     */\r\n    function Timeline(\r\n        uint256 _startTime,\r\n        uint256 _endTime\r\n    )\r\n        public \r\n    {\r\n        require(_startTime > now);\r\n        require(_endTime > _startTime);\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Utility interfaces\r\n * @author Biglabs Pte. Ltd.\r\n * @dev ERC20 smart contract with owner\r\n*/\r\n\r\ncontract OwnerERC20 is ERC20Basic, Owner {\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Utility smart contracts\r\n * @author Biglabs Pte. Ltd.\r\n * @dev Chain smart contract with the same owner\r\n */\r\n \r\ncontract ChainOwner is Owner {\r\n    //parent contract\r\n    OwnerERC20 internal parent;\r\n\r\n    /**\r\n    * @param _parent The parent smart contract\r\n    */\r\n    function ChainOwner(OwnerERC20 _parent) internal {\r\n        parent = _parent;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(parent.isValidOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return parent.owner();\r\n    }\r\n\r\n    modifier validOwner(OwnerERC20 _smzoToken) {\r\n        //check if function not called by owner or coOwner\r\n        if (!parent.isValidOwner(msg.sender)) {\r\n            //require this called from smart contract\r\n            OwnerERC20 ico = OwnerERC20(msg.sender);\r\n            //this will throw exception if not\r\n\r\n            //ensure the same owner\r\n            require(ico.owner() == _smzoToken.owner());\r\n        }\r\n        _;\r\n    }\r\n    \r\n    function isValidOwner(address _address) public view returns(bool) {\r\n        if (_address == owner()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Utility smart contracts\r\n * @author Biglabs Pte. Ltd.\r\n * @dev Chain smart contract with the same owner\r\n */\r\n \r\ncontract ChainCoOwner is ChainOwner {\r\n\r\n    mapping(address=>bool) internal coOwner;\r\n    \r\n    address[] internal coOwnerList;\r\n\r\n    /**\r\n     * @param _parent The parent smart contract\r\n     * @param _coOwner Array of coOwner\r\n    */\r\n    function ChainCoOwner(OwnerERC20 _parent, address[] _coOwner) ChainOwner(_parent) internal {\r\n        _addCoOwners(_coOwner);\r\n    }\r\n    \r\n    function _addCoOwners(address[] _coOwner) internal {\r\n        uint len = _coOwner.length;\r\n        for (uint i=0; i < len; i++) {\r\n            coOwner[_coOwner[i]] = true;\r\n            coOwnerList.push(_coOwner[i]);\r\n        }\r\n    }\r\n\r\n    function _addCoOwner(address _coOwner) internal {\r\n        coOwner[_coOwner] = true;\r\n        coOwnerList.push(_coOwner);\r\n    }\r\n\r\n    function _disableCoOwners(address[] _coOwner) internal {\r\n        uint len = _coOwner.length;\r\n        for (uint i=0; i < len; i++) {\r\n            coOwner[_coOwner[i]] = false;\r\n        }\r\n    }\r\n\r\n    function _disableCoOwner(address _coOwner) internal {\r\n        coOwner[_coOwner] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check address is valid owner (owner or coOwner)\r\n     * @param _address Address to check\r\n     * \r\n    */\r\n    function isValidOwner(address _address) public view returns(bool) {\r\n        if (_address == owner() || coOwner[_address] == true) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Utility interfaces\r\n * @author Biglabs Pte. Ltd.\r\n * @dev ICO smart contract\r\n */\r\n \r\ncontract ICO is OwnerERC20 {\r\n    //transfer tokens (use wei contribution information)\r\n    function transferByEth(address _to, uint _weiAmount, uint _value) public returns (bool);\r\n\r\n    //calculate no tokens\r\n    function calculateNoToken(uint _weiAmount) public view returns(uint);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Mozo sale token for ICO\r\n * @author Biglabs Pte. Ltd.\r\n */\r\n\r\ncontract MozoSaleToken is BasicToken, Timeline, ChainCoOwner, ICO {\r\n    using SafeMath for uint;\r\n\r\n    //sale token name, use in ICO phase only\r\n    string public constant name = \"Mozo Sale Token\";\r\n\r\n    //sale token symbol, use in ICO phase only\r\n    string public constant symbol = \"SMZO\";\r\n\r\n    //token symbol\r\n    uint8 public constant decimals = 2;\r\n\r\n    //KYC/AML threshold: 20k SGD = 15k USD = 165k token (x100)\r\n    uint public constant AML_THRESHOLD = 16500000;\r\n\r\n    //No. repicients that has bonus tokens\r\n    uint public noBonusTokenRecipients;\r\n\r\n    //total no. bonus tokens\r\n    uint public totalBonusToken;\r\n\r\n    //bonus transferred flags\r\n    mapping(address => bool) bonus_transferred_repicients;\r\n\r\n    //maximum transferring per function\r\n    uint public constant MAX_TRANSFER = 80;\r\n\r\n    //number of transferred address\r\n    uint public transferredIndex;\r\n\r\n    //indicate hardcap is reached or not\r\n    bool public isCapped = false;\r\n\r\n    //total wei collected\r\n    uint public totalCapInWei;\r\n\r\n    //rate\r\n    uint public rate;\r\n\r\n    //flag indicate whether ICO is stopped for bonus\r\n    bool public isStopped;\r\n\r\n    //hold all address to transfer Mozo tokens when releasing\r\n    address[] public transferAddresses;\r\n\r\n    //whitelist (Already register KYC/AML)\r\n    mapping(address => bool) public whitelist;\r\n\r\n    //contain map of address that buy over the threshold for KYC/AML \r\n    //but buyer is not in the whitelist yes\r\n    mapping(address => uint) public pendingAmounts;\r\n\r\n    /**\r\n     * @dev Throws if called by any account that's not whitelisted.\r\n     */\r\n    modifier onlyWhitelisted() {\r\n        require(whitelist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Only owner or coOwner\r\n    */\r\n    modifier onlyOwnerOrCoOwner() {\r\n        require(isValidOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Only stopping for bonus distribution\r\n    */\r\n    modifier onlyStopping() {\r\n        require(isStopped == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Only owner or smart contract of the same owner in chain.\r\n     */\r\n    modifier onlySameChain() {\r\n        //check if function not called by owner or coOwner\r\n        if (!isValidOwner(msg.sender)) {\r\n            //require this called from smart contract\r\n            ChainOwner sm = ChainOwner(msg.sender);\r\n            //this will throw exception if not\r\n\r\n            //ensure the same owner\r\n            require(sm.owner() == owner());\r\n        }\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice owner should transfer to this smart contract {_supply} Mozo tokens manually\r\n     * @param _mozoToken Mozo token smart contract\r\n     * @param _coOwner Array of coOwner\r\n     * @param _supply Total number of tokens = No. tokens * 10^decimals = No. tokens * 100\r\n     * @param _rate number of wei to buy 0.01 Mozo sale token\r\n     * @param _openingTime The opening time in seconds (unix Time)\r\n     * @param _closingTime The closing time in seconds (unix Time)\r\n     */\r\n    function MozoSaleToken(\r\n        OwnerERC20 _mozoToken,\r\n        address[] _coOwner,\r\n        uint _supply,\r\n        uint _rate,\r\n        uint _openingTime,\r\n        uint _closingTime\r\n    )\r\n    public\r\n    ChainCoOwner(_mozoToken, _coOwner)\r\n    Timeline(_openingTime, _closingTime)\r\n    onlyOwner()\r\n    {\r\n        require(_supply > 0);\r\n        require(_rate > 0);\r\n\r\n        rate = _rate;\r\n        totalSupply_ = _supply;\r\n\r\n        //assign all sale tokens to owner\r\n        balances[_mozoToken.owner()] = totalSupply_;\r\n\r\n        //add owner and co_owner to whitelist\r\n        addAddressToWhitelist(msg.sender);\r\n        addAddressesToWhitelist(_coOwner);\r\n        emit Transfer(0x0, _mozoToken.owner(), totalSupply_);\r\n    }\r\n    \r\n    function addCoOwners(address[] _coOwner) public onlyOwner {\r\n        _addCoOwners(_coOwner);\r\n    }\r\n\r\n    function addCoOwner(address _coOwner) public onlyOwner {\r\n        _addCoOwner(_coOwner);\r\n    }\r\n\r\n    function disableCoOwners(address[] _coOwner) public onlyOwner {\r\n        _disableCoOwners(_coOwner);\r\n    }\r\n\r\n    function disableCoOwner(address _coOwner) public onlyOwner {\r\n        _disableCoOwner(_coOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Get Rate: number of wei to buy 0.01 Mozo token\r\n     */\r\n    function getRate() public view returns (uint) {\r\n        return rate;\r\n    }\r\n\r\n    /**\r\n     * @dev Set Rate: \r\n     * @param _rate Number of wei to buy 0.01 Mozo token\r\n     */\r\n    function setRate(uint _rate) public onlyOwnerOrCoOwner {\r\n        rate = _rate;\r\n    }\r\n\r\n    /**\r\n     * @dev Get flag indicates ICO reached hardcap\r\n     */\r\n    function isReachCapped() public view returns (bool) {\r\n        return isCapped;\r\n    }\r\n\r\n    /**\r\n     * @dev add an address to the whitelist, sender must have enough tokens\r\n     * @param _address address for adding to whitelist\r\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n     */\r\n    function addAddressToWhitelist(address _address) onlyOwnerOrCoOwner public returns (bool success) {\r\n        if (!whitelist[_address]) {\r\n            whitelist[_address] = true;\r\n            //transfer pending amount of tokens to user\r\n            uint noOfTokens = pendingAmounts[_address];\r\n            if (noOfTokens > 0) {\r\n                pendingAmounts[_address] = 0;\r\n                transfer(_address, noOfTokens);\r\n            }\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev add addresses to the whitelist, sender must have enough tokens\r\n     * @param _addresses addresses for adding to whitelist\r\n     * @return true if at least one address was added to the whitelist, \r\n     * false if all addresses were already in the whitelist  \r\n     */\r\n    function addAddressesToWhitelist(address[] _addresses) onlyOwnerOrCoOwner public returns (bool success) {\r\n        uint length = _addresses.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            if (addAddressToWhitelist(_addresses[i])) {\r\n                success = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address from the whitelist\r\n     * @param _address address\r\n     * @return true if the address was removed from the whitelist, \r\n     * false if the address wasn't in the whitelist in the first place \r\n     */\r\n    function removeAddressFromWhitelist(address _address) onlyOwnerOrCoOwner public returns (bool success) {\r\n        if (whitelist[_address]) {\r\n            whitelist[_address] = false;\r\n            success = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev remove addresses from the whitelist\r\n     * @param _addresses addresses\r\n     * @return true if at least one address was removed from the whitelist, \r\n     * false if all addresses weren't in the whitelist in the first place\r\n     */\r\n    function removeAddressesFromWhitelist(address[] _addresses) onlyOwnerOrCoOwner public returns (bool success) {\r\n        uint length = _addresses.length;\r\n        for (uint i = 0; i < length; i++) {\r\n            if (removeAddressFromWhitelist(_addresses[i])) {\r\n                success = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop selling for bonus transfer\r\n     * @notice Owner should release InvestmentDiscount smart contract before call this\r\n     */\r\n    function setStop() onlyOwnerOrCoOwner {\r\n        isStopped = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Set hardcap is reached\r\n     * @notice Owner must release all sale smart contracts\r\n     */\r\n    function setReachCapped() public onlyOwnerOrCoOwner {\r\n        isCapped = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Get total distribution in Wei\r\n     */\r\n    function getCapInWei() public view returns (uint) {\r\n        return totalCapInWei;\r\n    }\r\n\r\n    /**\r\n     * @dev Get no. investors\r\n     */\r\n    function getNoInvestor() public view returns (uint) {\r\n        return transferAddresses.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Get unsold tokens\r\n     */\r\n    function getUnsoldToken() public view returns (uint) {\r\n        uint unsold = balances[owner()];\r\n        for (uint j = 0; j < coOwnerList.length; j++) {\r\n            unsold = unsold.add(balances[coOwnerList[j]]);\r\n        }\r\n\r\n        return unsold;\r\n    }\r\n\r\n    /**\r\n     * @dev Get distributed tokens\r\n     */\r\n    function getDistributedToken() public view returns (uint) {\r\n        return totalSupply_.sub(getUnsoldToken());\r\n    }\r\n\r\n    /**\r\n     * @dev Override transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        //required this contract has enough Mozo tokens\r\n        //obsolete\r\n        //if (msg.sender == owner()) {\r\n        //    require(parent.balanceOf(this) >= getDistributedToken().add(_value));\r\n        //}\r\n        //we will check it when releasing smart contract\r\n\r\n        //owners or balances already greater than 0, no need to add to list\r\n        bool notAddToList = isValidOwner(_to) || (balances[_to] > 0);\r\n\r\n        //check AML threshold\r\n        if (!isStopped) {\r\n            if (!whitelist[_to]) {\r\n                if ((_value + balances[_to]) > AML_THRESHOLD) {\r\n                    pendingAmounts[_to] = pendingAmounts[_to].add(_value);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (BasicToken.transfer(_to, _value)) {\r\n            if (!notAddToList) {\r\n                transferAddresses.push(_to);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @param _weiAmount Contribution in wei\r\n     * \r\n     */\r\n    function calculateNoToken(uint _weiAmount) public view returns (uint) {\r\n        return _weiAmount.div(rate);\r\n    }\r\n\r\n    /**\r\n     * @dev Override transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _weiAmount The wei amount spent to by token\r\n     */\r\n    function transferByEth(address _to, uint _weiAmount, uint _value)\r\n    public\r\n    onlyWhileOpen\r\n    onlySameChain()\r\n    returns (bool)\r\n    {\r\n        if (transfer(_to, _value)) {\r\n            totalCapInWei = totalCapInWei.add(_weiAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Release smart contract\r\n     * @notice Owner must release all sale smart contracts\r\n     */\r\n    function release() public onlyOwnerOrCoOwner {\r\n        _release();\r\n    }\r\n\r\n    /**\r\n     * @dev Investor claim tokens\r\n     */\r\n    function claim() public isEnded {\r\n        require(balances[msg.sender] > 0);\r\n        uint investorBalance = balances[msg.sender];\r\n\r\n        balances[msg.sender] = 0;\r\n        parent.transfer(msg.sender, investorBalance);\r\n    }\r\n\r\n    /**\r\n     * @param _recipients list of repicients\r\n     * @param _amount list of no. tokens\r\n    */\r\n    function bonusToken(address[] _recipients, uint[] _amount) public onlyOwnerOrCoOwner onlyStopping {\r\n        uint len = _recipients.length;\r\n        uint len1 = _amount.length;\r\n        require(len == len1);\r\n        require(len <= MAX_TRANSFER);\r\n        uint i;\r\n        uint total = 0;\r\n        for (i = 0; i < len; i++) {\r\n            if (bonus_transferred_repicients[_recipients[i]] == false) {\r\n                bonus_transferred_repicients[_recipients[i]] = transfer(_recipients[i], _amount[i]);\r\n                total = total.add(_amount[i]);\r\n            }\r\n        }\r\n        totalBonusToken = totalBonusToken.add(total);\r\n        noBonusTokenRecipients = noBonusTokenRecipients.add(len);\r\n    }\r\n\r\n    function min(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Only call after releasing all sale smart contracts, this smart contract must have enough Mozo tokens\r\n     * @dev Release smart contract\r\n     */\r\n    function _release() internal {\r\n        uint length = min(transferAddresses.length, transferredIndex + MAX_TRANSFER);\r\n        uint i = transferredIndex;\r\n\r\n        if (isCapped) {\r\n            //Reach hardcap, burn all owner sale token\r\n            for (; i < length; i++) {\r\n                address ad = transferAddresses[i];\r\n                uint b = balances[ad];\r\n                if (b == 0) {\r\n                    continue;\r\n                }\r\n\r\n                balances[ad] = 0;\r\n                // send Mozo token from ICO account to investor address\r\n                parent.transfer(ad, b);\r\n            }\r\n        } else {\r\n            uint unsold = getUnsoldToken();\r\n            uint sold = totalSupply_.sub(unsold);\r\n\r\n            if (sold <= 0) {\r\n                //very bad if we reach here\r\n                return;\r\n            }\r\n            for (; i < length; i++) {\r\n                ad = transferAddresses[i];\r\n                //obsolete\r\n                //no need to check because we checked before adding\r\n                //if (ad == owner()) {\r\n                //    continue;\r\n                //}\r\n                b = balances[ad];\r\n                if (b == 0) {\r\n                    continue;\r\n                }\r\n                //distribute all unsold token to investors\r\n                b = b.add(b.mul(unsold).div(sold));\r\n\r\n                // send Mozo token from ICO account to investor address\r\n                balances[ad] = 0;\r\n                parent.transfer(ad, b);\r\n            }\r\n        }\r\n\r\n        transferredIndex = i - 1;\r\n\r\n        //transfer remain tokens to owner\r\n        //for testing only\r\n        //parent.transfer(owner(), parent.balanceOf(address(this)));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"isReachCapped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCapInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferredIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDistributedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coOwner\",\"type\":\"address[]\"}],\"name\":\"disableCoOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coOwner\",\"type\":\"address[]\"}],\"name\":\"addCoOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coOwner\",\"type\":\"address\"}],\"name\":\"addCoOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCapped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferByEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noBonusTokenRecipients\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUnsoldToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBonusToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TRANSFER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AML_THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isValidOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setReachCapped\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCapInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_coOwner\",\"type\":\"address\"}],\"name\":\"disableCoOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"calculateNoToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNoInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"bonusToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_mozoToken\",\"type\":\"address\"},{\"name\":\"_coOwner\",\"type\":\"address[]\"},{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MozoSaleToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000044bf22949f9cc84b61b9328a9d885d1b5c806b4100000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000104c533c00000000000000000000000000000000000000000000000000000001bfc050c4a0000000000000000000000000000000000000000000000000000000005b4ad4df000000000000000000000000000000000000000000000000000000005b67299b0000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://2adf467a4795fdaf42bae5f76c8d6410441a024d82d07fd1f08ae4baaca2aa3e"}]}