{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * @dev Supports unlimited numbers of roles and addresses.\r\n * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n *  for you to write your own implementation of this interface using Enums or similar.\r\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\r\n *  to avoid typos.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n/**\r\n * @title RBACWithAdmin\r\n * @author Matt Condon (@Shrugs)\r\n * @dev It's recommended that you define constants in the contract,\r\n * @dev like ROLE_ADMIN below, to avoid typos.\r\n */\r\ncontract RBACWithAdmin is RBAC {\r\n  /**\r\n   * A constant role name for indicating admins.\r\n   */\r\n  string public constant ROLE_ADMIN = \"admin\";\r\n\r\n  /**\r\n   * @dev modifier to scope access to admins\r\n   * // reverts\r\n   */\r\n  modifier onlyAdmin()\r\n  {\r\n    checkRole(msg.sender, ROLE_ADMIN);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev constructor. Sets msg.sender as admin by default\r\n   */\r\n  function RBACWithAdmin()\r\n    public\r\n  {\r\n    addRole(msg.sender, ROLE_ADMIN);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminAddRole(address addr, string roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    addRole(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminRemoveRole(address addr, string roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    removeRole(addr, roleName);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n}\r\n\r\n\r\n// Contract Code for Faculty - Faculty Devs\r\ncontract FacultyPool is RBACWithAdmin {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // Constants\r\n    // ========================================================\r\n    uint8 constant CONTRACT_OPEN = 1;\r\n    uint8 constant CONTRACT_CLOSED = 2;\r\n    uint8 constant CONTRACT_SUBMIT_FUNDS = 3;\r\n    // 500,000 max gas\r\n    uint256 constant public gasLimit = 50000000000;\r\n    // 0.1 ether\r\n    uint256 constant public minContribution = 100000000000000000;\r\n\r\n    // State Vars\r\n    // ========================================================\r\n    // recipient address for fee\r\n    address public owner;\r\n    // the fee taken in tokens from the pool\r\n    uint256 public feePct;\r\n    // open our contract initially\r\n    uint8 public contractStage = CONTRACT_OPEN;\r\n    // the current Beneficiary Cap level in wei\r\n    uint256 public currentBeneficiaryCap;\r\n    // the total cap in wei of the pool\r\n    uint256 public totalPoolCap;\r\n    // the destination for this contract\r\n    address public receiverAddress;\r\n    // our beneficiaries\r\n    mapping (address => Beneficiary) beneficiaries;\r\n    // the total we raised before closing pool\r\n    uint256 public finalBalance;\r\n    // a set of refund amounts we may need to process\r\n    uint256[] public ethRefundAmount;\r\n    // mapping that holds the token allocation struct for each token address\r\n    mapping (address => TokenAllocation) tokenAllocationMap;\r\n    // the default token address\r\n    address public defaultToken;\r\n\r\n\r\n    // Modifiers and Structs\r\n    // ========================================================\r\n    // only run certain methods when contract is open\r\n    modifier isOpenContract() {\r\n        require (contractStage == CONTRACT_OPEN);\r\n        _;\r\n    }\r\n\r\n    // stop double processing attacks\r\n    bool locked;\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    // Beneficiary\r\n    struct Beneficiary {\r\n        uint256 ethRefund;\r\n        uint256 balance;\r\n        uint256 cap;\r\n        mapping (address => uint256) tokensClaimed;\r\n    }\r\n\r\n    // data structure for holding information related to token withdrawals.\r\n    struct TokenAllocation {\r\n        ERC20 token;\r\n        uint256[] pct;\r\n        uint256 balanceRemaining;\r\n    }\r\n\r\n    // Events\r\n    // ========================================================\r\n    event BeneficiaryBalanceChanged(address indexed beneficiary, uint256 totalBalance);\r\n    event ReceiverAddressSet(address indexed receiverAddress);\r\n    event ERC223Received(address indexed token, uint256 value);\r\n    event DepositReceived(address indexed beneficiary, uint256 amount, uint256 gas, uint256 gasprice, uint256 gasLimit);\r\n    event PoolStageChanged(uint8 stage);\r\n    event PoolSubmitted(address indexed receiver, uint256 amount);\r\n    event RefundReceived(address indexed sender, uint256 amount);\r\n    event TokenWithdrawal(address indexed beneficiary, address indexed token, uint256 amount);\r\n    event EthRefunded(address indexed beneficiary, uint256 amount);\r\n\r\n    // CODE BELOW HERE\r\n    // ========================================================\r\n\r\n    /*\r\n     * Construct a pool with a set of admins, the poolCap and the cap each beneficiary gets. And,\r\n     * optionally, the receiving address if know at time of contract creation.\r\n     * fee is in bips so 3.5% would be set as 350 and 100% == 100*100 => 10000\r\n     */\r\n    constructor(address[] _admins, uint256 _poolCap, uint256 _beneficiaryCap, address _receiverAddr, uint256 _feePct) public {\r\n        require(_admins.length > 0, \"Must have at least one admin apart from msg.sender\");\r\n        require(_poolCap >= _beneficiaryCap, \"Cannot have the poolCap <= beneficiaryCap\");\r\n        require(_feePct >=  0 && _feePct < 10000);\r\n        feePct = _feePct;\r\n        receiverAddress = _receiverAddr;\r\n        totalPoolCap = _poolCap;\r\n        currentBeneficiaryCap = _beneficiaryCap;\r\n        // setup privileges\r\n        owner = msg.sender;\r\n        addRole(msg.sender, ROLE_ADMIN);\r\n        for (uint8 i = 0; i < _admins.length; i++) {\r\n            addRole(_admins[i], ROLE_ADMIN);\r\n        }\r\n    }\r\n\r\n    // we pay in here\r\n    function () payable public {\r\n        if (contractStage == CONTRACT_OPEN) {\r\n            emit DepositReceived(msg.sender, msg.value, gasleft(), tx.gasprice, gasLimit);\r\n            _receiveDeposit();\r\n        } else {\r\n            _receiveRefund();\r\n        }\r\n    }\r\n\r\n    // receive funds. gas limited. min contrib.\r\n    function _receiveDeposit() isOpenContract internal {\r\n        require(tx.gasprice <= gasLimit, \"Gas too high\");\r\n        require(address(this).balance <= totalPoolCap, \"Deposit will put pool over limit. Reverting.\");\r\n        // Now the code\r\n        Beneficiary storage b = beneficiaries[msg.sender];\r\n        uint256 newBalance = b.balance.add(msg.value);\r\n        require(newBalance >= minContribution, \"contribution is lower than minContribution\");\r\n        if(b.cap > 0){\r\n            require(newBalance <= b.cap, \"balance is less than set cap for beneficiary\");\r\n        } else if(currentBeneficiaryCap == 0) {\r\n            // we have an open cap, no limits\r\n            b.cap = totalPoolCap;\r\n        }else {\r\n            require(newBalance <= currentBeneficiaryCap, \"balance is more than currentBeneficiaryCap\");\r\n            // we set it to the default cap\r\n            b.cap = currentBeneficiaryCap;\r\n        }\r\n        b.balance = newBalance;\r\n        emit BeneficiaryBalanceChanged(msg.sender, newBalance);\r\n    }\r\n\r\n    // Handle refunds only in closed state.\r\n    function _receiveRefund() internal {\r\n        assert(contractStage >= 2);\r\n        require(hasRole(msg.sender, ROLE_ADMIN) || msg.sender == receiverAddress, \"Receiver or Admins only\");\r\n        ethRefundAmount.push(msg.value);\r\n        emit RefundReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    function getCurrentBeneficiaryCap() public view returns(uint256 cap) {\r\n        return currentBeneficiaryCap;\r\n    }\r\n\r\n    function getPoolDetails() public view returns(uint256 total, uint256 currentBalance, uint256 remaining) {\r\n        remaining = totalPoolCap.sub(address(this).balance);\r\n        return (totalPoolCap, address(this).balance, remaining);\r\n    }\r\n\r\n    // close the pool from receiving more funds\r\n    function closePool() onlyAdmin isOpenContract public {\r\n        contractStage = CONTRACT_CLOSED;\r\n        emit PoolStageChanged(contractStage);\r\n    }\r\n\r\n    function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {\r\n        require(contractStage < CONTRACT_SUBMIT_FUNDS, \"Cannot resubmit pool.\");\r\n        require(receiverAddress != 0x00, \"receiver address cannot be empty\");\r\n        uint256 contractBalance = address(this).balance;\r\n        if(weiAmount == 0){\r\n            weiAmount = contractBalance;\r\n        }\r\n        require(minContribution <= weiAmount && weiAmount <= contractBalance, \"submitted amount too small or larger than the balance\");\r\n        finalBalance = contractBalance;\r\n        // transfer to upstream receiverAddress\r\n        require(receiverAddress.call.value(weiAmount)\r\n            .gas(gasleft().sub(5000))(),\r\n            \"Error submitting pool to receivingAddress\");\r\n        // get balance post transfer\r\n        contractBalance = address(this).balance;\r\n        if(contractBalance > 0) {\r\n            ethRefundAmount.push(contractBalance);\r\n        }\r\n        contractStage = CONTRACT_SUBMIT_FUNDS;\r\n        emit PoolSubmitted(receiverAddress, weiAmount);\r\n    }\r\n\r\n    function viewBeneficiaryDetails(address beneficiary) public view returns (uint256 cap, uint256 balance, uint256 remaining, uint256 ethRefund){\r\n        Beneficiary storage b = beneficiaries[beneficiary];\r\n        return (b.cap, b.balance, b.cap.sub(b.balance), b.ethRefund);\r\n    }\r\n\r\n    function withdraw(address _tokenAddress) public {\r\n        Beneficiary storage b = beneficiaries[msg.sender];\r\n        require(b.balance > 0, \"msg.sender has no balance. Nice Try!\");\r\n        if(contractStage == CONTRACT_OPEN){\r\n            uint256 transferAmt = b.balance;\r\n            b.balance = 0;\r\n            msg.sender.transfer(transferAmt);\r\n            emit BeneficiaryBalanceChanged(msg.sender, 0);\r\n        } else {\r\n            _withdraw(msg.sender, _tokenAddress);\r\n        }\r\n    }\r\n\r\n    // This function allows the contract owner to force a withdrawal to any contributor.\r\n    function withdrawFor (address _beneficiary, address tokenAddr) public onlyAdmin {\r\n        require (contractStage == CONTRACT_SUBMIT_FUNDS, \"Can only be done on Submitted Contract\");\r\n        require (beneficiaries[_beneficiary].balance > 0, \"Beneficary has no funds to withdraw\");\r\n        _withdraw(_beneficiary, tokenAddr);\r\n    }\r\n\r\n    function _withdraw (address _beneficiary, address _tokenAddr) internal {\r\n        require(contractStage == CONTRACT_SUBMIT_FUNDS, \"Cannot withdraw when contract is not CONTRACT_SUBMIT_FUNDS\");\r\n        Beneficiary storage b = beneficiaries[_beneficiary];\r\n        if (_tokenAddr == 0x00) {\r\n            _tokenAddr = defaultToken;\r\n        }\r\n        TokenAllocation storage ta = tokenAllocationMap[_tokenAddr];\r\n        require ( (ethRefundAmount.length > b.ethRefund) || ta.pct.length > b.tokensClaimed[_tokenAddr] );\r\n\r\n        if (ethRefundAmount.length > b.ethRefund) {\r\n            uint256 pct = _toPct(b.balance,finalBalance);\r\n            uint256 ethAmount = 0;\r\n            for (uint i= b.ethRefund; i < ethRefundAmount.length; i++) {\r\n                ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct));\r\n            }\r\n            b.ethRefund = ethRefundAmount.length;\r\n            if (ethAmount > 0) {\r\n                _beneficiary.transfer(ethAmount);\r\n                emit EthRefunded(_beneficiary, ethAmount);\r\n            }\r\n        }\r\n        if (ta.pct.length > b.tokensClaimed[_tokenAddr]) {\r\n            uint tokenAmount = 0;\r\n            for (i= b.tokensClaimed[_tokenAddr]; i< ta.pct.length; i++) {\r\n                tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i]));\r\n            }\r\n            b.tokensClaimed[_tokenAddr] = ta.pct.length;\r\n            if (tokenAmount > 0) {\r\n                require(ta.token.transfer(_beneficiary,tokenAmount));\r\n                ta.balanceRemaining = ta.balanceRemaining.sub(tokenAmount);\r\n                emit TokenWithdrawal(_beneficiary, _tokenAddr, tokenAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setReceiver(address addr) public onlyAdmin {\r\n        require (contractStage < CONTRACT_SUBMIT_FUNDS);\r\n        receiverAddress = addr;\r\n        emit ReceiverAddressSet(addr);\r\n    }\r\n\r\n    // once we have tokens we can enable the withdrawal\r\n    // setting this _useAsDefault to true will set this incoming address to the defaultToken.\r\n    function enableTokenWithdrawals (address _tokenAddr, bool _useAsDefault) public onlyAdmin noReentrancy {\r\n        require (contractStage == CONTRACT_SUBMIT_FUNDS, \"wrong contract stage\");\r\n        if (_useAsDefault) {\r\n            defaultToken = _tokenAddr;\r\n        } else {\r\n            require (defaultToken != 0x00, \"defaultToken must be set\");\r\n        }\r\n        TokenAllocation storage ta  = tokenAllocationMap[_tokenAddr];\r\n        if (ta.pct.length==0){\r\n            ta.token = ERC20(_tokenAddr);\r\n        }\r\n        uint256 amount = ta.token.balanceOf(this).sub(ta.balanceRemaining);\r\n        require (amount > 0);\r\n        if (feePct > 0) {\r\n            uint256 feePctFromBips = _toPct(feePct, 10000);\r\n            uint256 feeAmount = _applyPct(amount, feePctFromBips);\r\n            require (ta.token.transfer(owner, feeAmount));\r\n            emit TokenWithdrawal(owner, _tokenAddr, feeAmount);\r\n        }\r\n        amount = ta.token.balanceOf(this).sub(ta.balanceRemaining);\r\n        ta.balanceRemaining = ta.token.balanceOf(this);\r\n        ta.pct.push(_toPct(amount,finalBalance));\r\n    }\r\n\r\n    // get the available tokens\r\n    function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) {\r\n        Beneficiary storage b = beneficiaries[addr];\r\n        TokenAllocation storage ta = tokenAllocationMap[tokenAddr];\r\n        for (uint i = b.tokensClaimed[tokenAddr]; i < ta.pct.length; i++) {\r\n            tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i]));\r\n        }\r\n        return tokenAmount;\r\n    }\r\n\r\n    // This is a standard function required for ERC223 compatibility.\r\n    function tokenFallback (address from, uint value, bytes data) public {\r\n        emit ERC223Received (from, value);\r\n    }\r\n\r\n    // returns a value as a % accurate to 20 decimal points\r\n    function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\r\n        return numerator.mul(10 ** 20) / denominator;\r\n    }\r\n\r\n    // returns % of any number, where % given was generated with toPct\r\n    function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\r\n        return numerator.mul(pct) / (10 ** 20);\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"contractStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiverAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBeneficiaryCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"submitPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"viewBeneficiaryDetails\",\"outputs\":[{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"},{\"name\":\"ethRefund\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"name\":\"_useAsDefault\",\"type\":\"bool\"}],\"name\":\"enableTokenWithdrawals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethRefundAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"checkAvailableTokens\",\"outputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminRemoveRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolDetails\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminAddRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPoolCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBeneficiaryCap\",\"outputs\":[{\"name\":\"cap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admins\",\"type\":\"address[]\"},{\"name\":\"_poolCap\",\"type\":\"uint256\"},{\"name\":\"_beneficiaryCap\",\"type\":\"uint256\"},{\"name\":\"_receiverAddr\",\"type\":\"address\"},{\"name\":\"_feePct\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"BeneficiaryBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiverAddress\",\"type\":\"address\"}],\"name\":\"ReceiverAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ERC223Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasprice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"DepositReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stage\",\"type\":\"uint8\"}],\"name\":\"PoolStageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"}]","ContractName":"FacultyPool","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000caa54db3f9faefd0a16f5afd84c1dfea4813191e000000000000000000000000000000000000000000000000000000000000015e0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000a7a6faa276553df654b91f229caa683f359e1c0800000000000000000000000023973488f652f08a72e218e53de1463fbbc8a10f","Library":"","SwarmSource":"bzzr://4c18d86ff03f643897e74b16b45314825245575b40936ac67e65065646fbb03b"}]}