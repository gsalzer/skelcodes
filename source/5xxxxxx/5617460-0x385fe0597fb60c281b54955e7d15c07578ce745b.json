{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address and\r\n *      provides basic authorization control functions\r\n */\r\ncontract Ownable {\r\n    // Public properties\r\n    address public owner;\r\n\r\n    // Log if ownership has been changed\r\n    event ChangeOwnership(address indexed _owner, address indexed _newOwner);\r\n\r\n    // Checks if address is an owner\r\n    modifier OnlyOwner() {\r\n        require(msg.sender == owner);\r\n\r\n        _;\r\n    }\r\n\r\n    // The Ownable constructor sets the owner address\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Transfer current ownership to the new account\r\n    function transferOwnership(address _newOwner) public OnlyOwner {\r\n        require(_newOwner != address(0x0));\r\n\r\n        owner = _newOwner;\r\n\r\n        emit ChangeOwnership(owner, _newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    /*\r\n    * @dev Event to notify listeners about pause.\r\n    * @param pauseReason  string Reason the token was paused for.\r\n    */\r\n    event Pause(string pauseReason);\r\n    /*\r\n    * @dev Event to notify listeners about pause.\r\n    * @param unpauseReason  string Reason the token was unpaused for.\r\n    */\r\n    event Unpause(string unpauseReason);\r\n\r\n    bool public isPaused;\r\n    string public pauseNotice;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier IsNotPaused() {\r\n        require(!isPaused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier IsPaused() {\r\n        require(isPaused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    * @param _reason string The reason for the pause.\r\n    */\r\n    function pause(string _reason) OnlyOwner IsNotPaused public {\r\n        isPaused = true;\r\n        pauseNotice = _reason;\r\n        emit Pause(_reason);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     * @param _reason string Reason for the un pause.\r\n     */\r\n    function unpause(string _reason) OnlyOwner IsPaused public {\r\n        isPaused = false;\r\n        pauseNotice = _reason;\r\n        emit Unpause(_reason);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns(uint256 theBalance);\r\n    function transfer(address to, uint256 value) public returns(bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns(uint256 theAllowance);\r\n    function transferFrom(address from, address to, uint256 value) public returns(bool success);\r\n    function approve(address spender, uint256 value) public returns(bool success);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken without allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n    * @dev Get the token balance for account\r\n    * @param _address The address to query the balance of._address\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _address) public constant returns(uint256 theBalance){\r\n        return balances[_address];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer the balance from owner's account to another account\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    * @return Returns true if transfer has been successful\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns(bool success){\r\n        require(_to != address(0x0) && _value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is BasicToken, ERC20 {\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens approved by the owner that can be transferred to the spender's account\r\n     * @param _owner The address which owns the funds.\r\n     * @param _spender The address which will spend the funds.\r\n     * @return An uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns(uint256 theAllowance){\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * To change the approve amount you first have to reduce the addresses`\r\n     * allowance to zero by calling `approve(_spender, 0)` if it is not\r\n     * already 0 to mitigate the race condition described here:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns(bool success){\r\n        require(allowed[msg.sender][_spender] == 0 || _value == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer from `from` account to `to` account using allowance in `from` account to the sender\r\n     *\r\n     * @param _from  Origin address\r\n     * @param _to    Destination address\r\n     * @param _value Amount of CHR tokens to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n\r\n        emit Burn(msg.sender, _value);\r\n    }\r\n}\r\n\r\n/**\r\n * CHERR.IO is a standard ERC20 token with some additional functionalities:\r\n * - Transfers are only enabled after contract owner enables it (after the ICO)\r\n * - Contract sets 60% of the total supply as allowance for ICO contract\r\n */\r\ncontract Cherrio is StandardToken, BurnableToken, Ownable, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    // Metadata\r\n    string  public constant name = \"CHERR.IO\";\r\n    string  public constant symbol = \"CHR\";\r\n    uint8   public constant decimals = 18;\r\n\r\n    // Token supplies\r\n    uint256 public constant INITIAL_SUPPLY =  200000000 * (10 ** uint256(decimals));\r\n    uint256 public constant ADMIN_ALLOWANCE =  80000000 * (10 ** uint256(decimals));\r\n    uint256 public constant CONTRACT_ALLOWANCE = INITIAL_SUPPLY - ADMIN_ALLOWANCE;\r\n\r\n    // Funding cap in ETH. Change to equal $12M at time of token offering\r\n    uint256 public constant FUNDING_ETH_HARD_CAP = 15000 ether;\r\n    // Minimum cap in ETH. Change to equal $3M at time of token offering\r\n    uint256 public constant MINIMUM_ETH_SOFT_CAP = 3750 ether;\r\n    // Min contribution is 0.1 ether\r\n    uint256 public constant MINIMUM_CONTRIBUTION = 100 finney;\r\n    // Price of the tokens as in tokens per ether\r\n    uint256 public constant RATE = 5333;\r\n    // Price of the tokens in tier 1\r\n    uint256 public constant RATE_TIER1 = 8743;\r\n    // Price of the tokens in tier 2\r\n    uint256 public constant RATE_TIER2 = 7306;\r\n    // Price of the tokens in tier 3\r\n    uint256 public constant RATE_TIER3 = 6584;\r\n    // Price of the tokens in public sale for limited timeline\r\n    uint256 public constant RATE_PUBLIC_SALE = 5926;\r\n    // Maximum cap for tier 1 (60M CHR tokens)\r\n    uint256 public constant TIER1_CAP = 60000000 * (10 ** uint256(decimals));\r\n    // Maximum cap for tier 2 (36M CHR tokens)\r\n    uint256 public constant TIER2_CAP = 36000000 * (10 ** uint256(decimals));\r\n\r\n    // Maximum cap for each contributor in tier 1\r\n    uint256 public participantCapTier1;\r\n    // Maximum cap for each contributor in tier 2\r\n    uint256 public participantCapTier2;\r\n\r\n    // ETH cap for pool addres only in tier 1\r\n    uint256 public poolAddressCapTier1;\r\n    // ETH cap for pool addres only in tier 2\r\n    uint256 public poolAddressCapTier2;\r\n\r\n    // The address of the token admin\r\n    address public adminAddress;\r\n    // The address where ETH funds are collected\r\n    address public beneficiaryAddress;\r\n    // The address of the contract\r\n    address public contractAddress;\r\n    // The address of the pool who can send unlimited ETH to the contract\r\n    address public poolAddress;\r\n\r\n    // Enable transfers after conclusion of the token offering\r\n    bool public transferIsEnabled;\r\n\r\n    // Amount of raised in Wei\r\n    uint256 public weiRaised;\r\n\r\n    // Amount of CHR tokens sent to participant for presale and public sale\r\n    uint256[4] public tokensSent;\r\n\r\n    // Start of public pre-sale in timestamp\r\n    uint256 startTimePresale;\r\n\r\n    // Start and end time of public sale in timestamp\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n\r\n    // Discount period for public sale\r\n    uint256 publicSaleDiscountEndTime;\r\n\r\n    // End time limits in timestamp for each tier bonus\r\n    uint256[3] public tierEndTime;\r\n\r\n    //Check if contract address is already set\r\n    bool contractAddressIsSet;\r\n\r\n    struct Contributor {\r\n        bool canContribute;\r\n        uint8 tier;\r\n        uint256 contributionInWeiTier1;\r\n        uint256 contributionInWeiTier2;\r\n        uint256 contributionInWeiTier3;\r\n        uint256 contributionInWeiPublicSale;\r\n    }\r\n\r\n    struct Pool {\r\n        uint256 contributionInWei;\r\n    }\r\n\r\n    enum Stages {\r\n        Pending,\r\n        PreSale,\r\n        PublicSale,\r\n        Ended\r\n    }\r\n\r\n    // The current stage of the offering\r\n    Stages public stage;\r\n\r\n    mapping(address => Contributor) public contributors;\r\n    mapping(address => mapping(uint8 => Pool)) public pool;\r\n\r\n    // Check if transfer is enabled\r\n    modifier TransferIsEnabled {\r\n        require(transferIsEnabled || msg.sender == adminAddress || msg.sender == contractAddress);\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if address is a valid destination to transfer tokens to\r\n     * - must not be zero address\r\n     * - must not be the token address\r\n     * - must not be the owner's address\r\n     * - must not be the admin's address\r\n     * - must not be the token offering contract address\r\n     * - must not be the beneficiary address\r\n     */\r\n    modifier ValidDestination(address _to) {\r\n        require(_to != address(0x0));\r\n        require(_to != address(this));\r\n        require(_to != owner);\r\n        require(_to != address(adminAddress));\r\n        require(_to != address(contractAddress));\r\n        require(_to != address(beneficiaryAddress));\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Modifier that requires certain stage before executing the main function body\r\n     *\r\n     * @param _expectedStage Value that the current stage is required to match\r\n     */\r\n    modifier AtStage(Stages _expectedStage) {\r\n        require(stage == _expectedStage);\r\n\r\n        _;\r\n    }\r\n\r\n    // Check if ICO is live\r\n    modifier CheckIfICOIsLive() {\r\n        require(stage != Stages.Pending && stage != Stages.Ended);\r\n\r\n        if(stage == Stages.PreSale) {\r\n            require(\r\n                startTimePresale > 0 &&\r\n                now >= startTimePresale &&\r\n                now <= tierEndTime[2]\r\n            );\r\n        }\r\n        else {\r\n            require(\r\n                startTime > 0 &&\r\n                now >= startTime &&\r\n                now <= endTime\r\n            );\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    // Check if participant sent more then miniminum required contribution\r\n    modifier CheckPurchase() {\r\n        require(msg.value >= MINIMUM_CONTRIBUTION);\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Event for token purchase logging\r\n     *\r\n     * @param _purchaser Participant who paid for CHR tokens\r\n     * @param _value     Amount in WEI paid for token\r\n     * @param _tokens    Amount of tokens purchased\r\n     */\r\n    event TokenPurchase(address indexed _purchaser, uint256 _value, uint256 _tokens);\r\n\r\n    /**\r\n     * Event when token offering started\r\n     *\r\n     * @param _msg       Message\r\n     * @param _startTime Start time in timestamp\r\n     * @param _endTime   End time in timestamp\r\n     */\r\n    event OfferingOpens(string _msg, uint256 _startTime, uint256 _endTime);\r\n\r\n    /**\r\n     * Event when token offering ended and how much has been raised in wei\r\n     *\r\n     * @param _endTime        End time in timestamp\r\n     * @param _totalWeiRaised Total raised funds in wei\r\n     */\r\n    event OfferingCloses(uint256 _endTime, uint256 _totalWeiRaised);\r\n\r\n    /**\r\n     * Cherrio constructor\r\n     */\r\n    function Cherrio() public {\r\n        totalSupply = INITIAL_SUPPLY;\r\n\r\n        // Mint tokens\r\n        balances[msg.sender] = totalSupply;\r\n        emit Transfer(address(0x0), msg.sender, totalSupply);\r\n\r\n        // Aprove an allowance for admin account\r\n        adminAddress = 0xe0509bB3921aacc433108D403f020a7c2f92e936;\r\n        approve(adminAddress, ADMIN_ALLOWANCE);\r\n\r\n        participantCapTier1 = 100 ether;\r\n        participantCapTier2 = 100 ether;\r\n        poolAddressCapTier1 = 2000 ether; \r\n        poolAddressCapTier2 = 2000 ether;\r\n\r\n        weiRaised = 0;\r\n        startTimePresale = 0;\r\n        startTime = 0;\r\n        endTime = 0;\r\n        publicSaleDiscountEndTime = 0;\r\n        transferIsEnabled = false;\r\n        contractAddressIsSet = false;\r\n    }\r\n\r\n    /**\r\n     * Add approved addresses\r\n     *\r\n     * @param _addresses Array of approved addresses\r\n     * @param _tier      Tier\r\n     */\r\n    function addApprovedAddresses(address[] _addresses, uint8 _tier) external OnlyOwner {\r\n        uint256 length = _addresses.length;\r\n\r\n        for(uint256 i = 0; i < length; i++) {\r\n            if(!contributors[_addresses[i]].canContribute) {\r\n                contributors[_addresses[i]].canContribute = true;\r\n                contributors[_addresses[i]].tier = _tier;\r\n                contributors[_addresses[i]].contributionInWeiTier1 = 0;\r\n                contributors[_addresses[i]].contributionInWeiTier2 = 0;\r\n                contributors[_addresses[i]].contributionInWeiTier3 = 0;\r\n                contributors[_addresses[i]].contributionInWeiPublicSale = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add approved address\r\n     *\r\n     * @param _address Approved address\r\n     * @param _tier    Tier\r\n     */\r\n    function addSingleApprovedAddress(address _address, uint8 _tier) external OnlyOwner {\r\n        if(!contributors[_address].canContribute) {\r\n            contributors[_address].canContribute = true;\r\n            contributors[_address].tier = _tier;\r\n            contributors[_address].contributionInWeiTier1 = 0;\r\n            contributors[_address].contributionInWeiTier2 = 0;\r\n            contributors[_address].contributionInWeiTier3 = 0;\r\n            contributors[_address].contributionInWeiPublicSale = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set token offering address to approve allowance for offering contract to distribute tokens\r\n     */\r\n    function setTokenOffering() external OnlyOwner{\r\n        require(!contractAddressIsSet);\r\n        require(!transferIsEnabled);\r\n\r\n        contractAddress = address(this);\r\n        approve(contractAddress, CONTRACT_ALLOWANCE);\r\n\r\n        beneficiaryAddress = 0xAec8c4242c8c2E532c6D6478A7de380263234845;\r\n        poolAddress = 0x1A2C916B640520E1e93A78fEa04A49D8345a5aa9;\r\n\r\n        pool[poolAddress][0].contributionInWei = 0;\r\n        pool[poolAddress][1].contributionInWei = 0;\r\n        pool[poolAddress][2].contributionInWei = 0;\r\n        pool[poolAddress][3].contributionInWei = 0;\r\n\r\n        tokensSent[0] = 0;\r\n        tokensSent[1] = 0;\r\n        tokensSent[2] = 0;\r\n        tokensSent[3] = 0;\r\n\r\n        stage = Stages.Pending;\r\n        contractAddressIsSet = true;\r\n    }\r\n\r\n    /**\r\n     * Set when presale starts\r\n     *\r\n     * @param _startTimePresale Start time of presale in timestamp\r\n     */\r\n    function startPresale(uint256 _startTimePresale) external OnlyOwner AtStage(Stages.Pending) {\r\n        if(_startTimePresale == 0) {\r\n            startTimePresale = now;\r\n        }\r\n        else {\r\n            startTimePresale = _startTimePresale;\r\n        }\r\n\r\n        setTierEndTime();\r\n\r\n        stage = Stages.PreSale;\r\n    }\r\n\r\n    /**\r\n     * Set when public sale starts\r\n     *\r\n     * @param _startTime Start time of public sale in timestamp\r\n     */\r\n    function startPublicSale(uint256 _startTime) external OnlyOwner AtStage(Stages.PreSale) {\r\n        if(_startTime == 0) {\r\n            startTime = now;\r\n        }\r\n        else {\r\n            startTime = _startTime;\r\n        }\r\n\r\n        endTime = startTime + 15 days;\r\n        publicSaleDiscountEndTime = startTime + 3 days;\r\n\r\n        stage = Stages.PublicSale;\r\n    }\r\n\r\n    // Fallback function can be used to buy CHR tokens\r\n    function () public payable {\r\n        buy();\r\n    }\r\n\r\n    function buy() public payable IsNotPaused CheckIfICOIsLive returns(bool _success) {\r\n        uint8 currentTier = getCurrentTier();\r\n\r\n        if(currentTier > 3) {\r\n            revert();\r\n        }\r\n\r\n        if(!buyTokens(currentTier)) {\r\n            revert();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @param _tier Current Token Sale tier\r\n     */\r\n    function buyTokens(uint8 _tier) internal ValidDestination(msg.sender) CheckPurchase returns(bool _success) {\r\n        if(weiRaised.add(msg.value) > FUNDING_ETH_HARD_CAP) {\r\n            revert();\r\n        }\r\n\r\n        uint256 contributionInWei = msg.value;\r\n\r\n        if(!checkTierCap(_tier, contributionInWei)) {\r\n            revert();\r\n        }\r\n\r\n        uint256 rate = getTierTokens(_tier);\r\n        uint256 tokens = contributionInWei.mul(rate);\r\n\r\n        if(msg.sender != poolAddress) {\r\n            if(stage == Stages.PreSale) {\r\n                if(!checkAllowedTier(msg.sender, _tier)) {\r\n                    revert();\r\n                }\r\n            }\r\n\r\n            if(!checkAllowedContribution(msg.sender, contributionInWei, _tier)) {\r\n                revert();\r\n            }\r\n\r\n            if(!this.transferFrom(owner, msg.sender, tokens)) {\r\n                revert();\r\n            }\r\n\r\n            if(stage == Stages.PreSale) {\r\n                if(_tier == 0) {\r\n                    contributors[msg.sender].contributionInWeiTier1 = contributors[msg.sender].contributionInWeiTier1.add(contributionInWei);\r\n                }\r\n                else if(_tier == 1) {\r\n                    contributors[msg.sender].contributionInWeiTier2 = contributors[msg.sender].contributionInWeiTier2.add(contributionInWei);\r\n                }\r\n                else if(_tier == 2) {\r\n                    contributors[msg.sender].contributionInWeiTier3 = contributors[msg.sender].contributionInWeiTier3.add(contributionInWei);\r\n                }\r\n            }\r\n            else {\r\n                contributors[msg.sender].contributionInWeiPublicSale = contributors[msg.sender].contributionInWeiPublicSale.add(contributionInWei);\r\n            }\r\n        }\r\n        else {\r\n            if(!checkPoolAddressTierCap(_tier, contributionInWei)) {\r\n                revert();\r\n            }\r\n\r\n            if(!this.transferFrom(owner, msg.sender, tokens)) {\r\n                revert();\r\n            }\r\n\r\n            pool[poolAddress][_tier].contributionInWei = pool[poolAddress][_tier].contributionInWei.add(contributionInWei);\r\n        }\r\n\r\n        weiRaised = weiRaised.add(contributionInWei);\r\n        tokensSent[_tier] = tokensSent[_tier].add(tokens);\r\n\r\n        if(weiRaised >= FUNDING_ETH_HARD_CAP) {\r\n            offeringEnded();\r\n        }\r\n\r\n        beneficiaryAddress.transfer(address(this).balance);\r\n        emit TokenPurchase(msg.sender, contributionInWei, tokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Manually withdraw tokens to private investors\r\n     *\r\n     * @param _to    Address of private investor\r\n     * @param _value The number of tokens to send to private investor\r\n     */\r\n    function withdrawCrowdsaleTokens(address _to, uint256 _value) external OnlyOwner ValidDestination(_to) returns (bool _success) {\r\n        if(!this.transferFrom(owner, _to, _value)) {\r\n            revert();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer from sender to another account\r\n     *\r\n     * @param _to    Destination address\r\n     * @param _value Amount of CHR tokens to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public ValidDestination(_to) TransferIsEnabled IsNotPaused returns(bool _success){\r\n         return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * Transfer from `from` account to `to` account using allowance in `from` account to the sender\r\n     *\r\n     * @param _from  Origin address\r\n     * @param _to    Destination address\r\n     * @param _value Amount of CHR tokens to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public ValidDestination(_to) TransferIsEnabled IsNotPaused returns(bool _success){\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Check if participant is allowed to contribute in current tier\r\n     *\r\n     * @param _address Participant address\r\n     * @param _tier    Current tier\r\n     */\r\n    function checkAllowedTier(address _address, uint8 _tier) internal view returns (bool _allowed) {\r\n        if(contributors[_address].tier <= _tier) {\r\n            return true;\r\n        }\r\n        else{\r\n          return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check contribution cap for only tier 1 and 2\r\n     *\r\n     * @param _tier  Current tier\r\n     * @param _value Participant contribution\r\n     */\r\n    function checkTierCap(uint8 _tier, uint256 _value) internal view returns (bool _success) {\r\n        uint256 currentlyTokensSent = tokensSent[_tier];\r\n        bool status = true;\r\n\r\n        if(_tier == 0) {\r\n            if(TIER1_CAP < currentlyTokensSent.add(_value)) {\r\n                status = false;\r\n            }\r\n        }\r\n        else if(_tier == 1) {\r\n            if(TIER2_CAP < currentlyTokensSent.add(_value)) {\r\n                status = false;\r\n            }\r\n        }\r\n\r\n        return status;\r\n    }\r\n    \r\n    /**\r\n     * Check cap for pool address in tier 1 and 2\r\n     *\r\n     * @param _tier  Current tier\r\n     * @param _value Pool contribution\r\n     */\r\n    function checkPoolAddressTierCap(uint8 _tier, uint256 _value) internal view returns (bool _success) {\r\n        uint256 currentContribution = pool[poolAddress][_tier].contributionInWei;\r\n\r\n        if((_tier == 0 && (poolAddressCapTier1 < currentContribution.add(_value))) || (_tier == 1 && (poolAddressCapTier2 < currentContribution.add(_value)))) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Check cap for pool address in tier 1 and 2\r\n     *\r\n     * @param _address  Participant address\r\n     * @param _value    Participant contribution\r\n     * @param _tier     Current tier\r\n     */\r\n    function checkAllowedContribution(address _address, uint256 _value, uint8 _tier) internal view returns (bool _success) {\r\n        bool status = false;\r\n\r\n        if(contributors[_address].canContribute) {\r\n            if(_tier == 0) {\r\n                if(participantCapTier1 >= contributors[_address].contributionInWeiTier1.add(_value)) {\r\n                    status = true;\r\n                }\r\n            }\r\n            else if(_tier == 1) {\r\n                if(participantCapTier2 >= contributors[_address].contributionInWeiTier2.add(_value)) {\r\n                    status = true;\r\n                }\r\n            }\r\n            else if(_tier == 2) {\r\n                status = true;\r\n            }\r\n            else {\r\n                status = true;\r\n            }\r\n        }\r\n\r\n        return status;\r\n    }\r\n    \r\n    /**\r\n     * Get current tier tokens rate\r\n     *\r\n     * @param _tier     Current tier\r\n     */\r\n    function getTierTokens(uint8 _tier) internal view returns(uint256 _tokens) {\r\n        uint256 tokens = RATE_TIER1;\r\n\r\n        if(_tier == 1) {\r\n            tokens = RATE_TIER2;\r\n        }\r\n        else if(_tier == 2) {\r\n            tokens = RATE_TIER3;\r\n        }\r\n        else if(_tier == 3) {\r\n            if(now <= publicSaleDiscountEndTime) {\r\n                tokens = RATE_PUBLIC_SALE;\r\n            }\r\n            else {\r\n                tokens = RATE;\r\n            }\r\n        }\r\n\r\n        return tokens;\r\n    }\r\n\r\n    // Get current tier\r\n    function getCurrentTier() public view returns(uint8 _tier) {\r\n        uint8 currentTier = 3; // 3 is public sale\r\n\r\n        if(stage == Stages.PreSale) {\r\n            if(now <= tierEndTime[0]) {\r\n                currentTier = 0;\r\n            }\r\n            else if(now <= tierEndTime[1]) {\r\n                currentTier = 1;\r\n            }\r\n            else if(now <= tierEndTime[2]) {\r\n                currentTier = 2;\r\n            }\r\n        }\r\n        else {\r\n            if(now > endTime) {\r\n                currentTier = 4; // Token offering ended\r\n            }\r\n        }\r\n\r\n        return currentTier;\r\n    }\r\n\r\n    // Set end time for each tier\r\n    function setTierEndTime() internal AtStage(Stages.Pending) {\r\n        tierEndTime[0] = startTimePresale + 1 days; \r\n        tierEndTime[1] = tierEndTime[0] + 2 days;   \r\n        tierEndTime[2] = tierEndTime[1] + 6 days;   \r\n    }\r\n\r\n    // End the token offering\r\n    function endOffering() public OnlyOwner {\r\n        offeringEnded();\r\n    }\r\n\r\n    // Token offering is ended\r\n    function offeringEnded() internal {\r\n        endTime = now;\r\n        stage = Stages.Ended;\r\n\r\n        emit OfferingCloses(endTime, weiRaised);\r\n    }\r\n\r\n    // Enable transfers, burn unsold tokens & set tokenOfferingAddress to 0\r\n    function enableTransfer() public OnlyOwner returns(bool _success){\r\n        transferIsEnabled = true;\r\n        uint256 tokensToBurn = allowed[msg.sender][contractAddress];\r\n\r\n        if(tokensToBurn != 0){\r\n            burn(tokensToBurn);\r\n            approve(contractAddress, 0);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Extend end time\r\n     *\r\n     * @param _addedTime Addtional time in secods\r\n     */\r\n    function extendEndTime(uint256 _addedTime) external OnlyOwner {\r\n        endTime = endTime + _addedTime;\r\n    }\r\n    \r\n    /**\r\n     * Extend public sale discount time\r\n     *\r\n     * @param _addedPublicSaleDiscountEndTime Addtional time in secods\r\n     */\r\n    function extendPublicSaleDiscountEndTime(uint256 _addedPublicSaleDiscountEndTime) external OnlyOwner {\r\n        publicSaleDiscountEndTime = publicSaleDiscountEndTime + _addedPublicSaleDiscountEndTime;\r\n    }\r\n    \r\n    /**\r\n     * Update pool cap for tier 1\r\n     *\r\n     * @param _poolAddressCapTier1 Tier cap\r\n     */\r\n    function updatePoolAddressCapTier1(uint256 _poolAddressCapTier1) external OnlyOwner {\r\n        poolAddressCapTier1 = _poolAddressCapTier1;\r\n    }\r\n    \r\n    /**\r\n     * Update pool cap for tier 2\r\n     *\r\n     * @param _poolAddressCapTier2 Tier cap\r\n     */\r\n    function updatePoolAddressCapTier2(uint256 _poolAddressCapTier2) external OnlyOwner {\r\n        poolAddressCapTier2 = _poolAddressCapTier2;\r\n    }\r\n\r\n    //\r\n    \r\n    /**\r\n     * Update participant cap for tier 1\r\n     *\r\n     * @param _participantCapTier1 Tier cap\r\n     */\r\n    function updateParticipantCapTier1(uint256 _participantCapTier1) external OnlyOwner {\r\n        participantCapTier1 = _participantCapTier1;\r\n    }\r\n    \r\n    /**\r\n     * Update participant cap for tier 2\r\n     *\r\n     * @param _participantCapTier2 Tier cap\r\n     */\r\n    function updateParticipantCapTier2(uint256 _participantCapTier2) external OnlyOwner {\r\n        participantCapTier2 = _participantCapTier2;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_ALLOWANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participantCapTier1\",\"type\":\"uint256\"}],\"name\":\"updateParticipantCapTier1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributors\",\"outputs\":[{\"name\":\"canContribute\",\"type\":\"bool\"},{\"name\":\"tier\",\"type\":\"uint8\"},{\"name\":\"contributionInWeiTier1\",\"type\":\"uint256\"},{\"name\":\"contributionInWeiTier2\",\"type\":\"uint256\"},{\"name\":\"contributionInWeiTier3\",\"type\":\"uint256\"},{\"name\":\"contributionInWeiPublicSale\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolAddressCapTier1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferIsEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tierEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauseNotice\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"pool\",\"outputs\":[{\"name\":\"contributionInWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE_TIER3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_tier\",\"type\":\"uint8\"}],\"name\":\"addApprovedAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participantCapTier2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"theBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setTokenOffering\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTier\",\"outputs\":[{\"name\":\"_tier\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"startPublicSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE_TIER1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participantCapTier2\",\"type\":\"uint256\"}],\"name\":\"updateParticipantCapTier2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addedTime\",\"type\":\"uint256\"}],\"name\":\"extendEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_CONTRIBUTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_tier\",\"type\":\"uint8\"}],\"name\":\"addSingleApprovedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER1_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"poolAddressCapTier2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endOffering\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTimePresale\",\"type\":\"uint256\"}],\"name\":\"startPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolAddressCapTier2\",\"type\":\"uint256\"}],\"name\":\"updatePoolAddressCapTier2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER2_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participantCapTier1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_poolAddressCapTier1\",\"type\":\"uint256\"}],\"name\":\"updatePoolAddressCapTier1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiaryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"theAllowance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FUNDING_ETH_HARD_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE_PUBLIC_SALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawCrowdsaleTokens\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE_TIER2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableTransfer\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_ETH_SOFT_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN_ALLOWANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addedPublicSaleDiscountEndTime\",\"type\":\"uint256\"}],\"name\":\"extendPublicSaleDiscountEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"OfferingOpens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalWeiRaised\",\"type\":\"uint256\"}],\"name\":\"OfferingCloses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pauseReason\",\"type\":\"string\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"unpauseReason\",\"type\":\"string\"}],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"Cherrio","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://22e215f661d78eb641dd83534c19cb916ddbcf51dac40cf0707cdc08cd5ec7db"}]}