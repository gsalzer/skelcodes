{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n* @title ERC20Basic\r\n* @dev Simpler version of ERC20 interface\r\n* @dev see https://github.com/ethereum/EIPs/issues/179\r\n*/\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n* @title ERC20 interface\r\n* @dev see https://github.com/ethereum/EIPs/issues/20\r\n*/\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n* @title Basic token\r\n* @dev Basic version of StandardToken, with no allowances.\r\n*/\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n    mapping(address => uint256) balances;\r\n    uint256 totalSupply_;\r\n    /**\r\n    * @dev total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n/**\r\n* @title Standard ERC20 token\r\n*\r\n* @dev Implementation of the basic standard token.\r\n* @dev https://github.com/ethereum/EIPs/issues/20\r\n* @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n*/\r\ncontract StandardToken is ERC20, BasicToken {\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        }\r\n        else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n* @title Pausable\r\n* @dev Base contract which allows children to implement an emergency stop mechanism.\r\n*/\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public\r\n    {paused = true;\r\n        Pause();\r\n    }\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n/**\r\n* @title Pausable token\r\n* @dev StandardToken modified with pausable transfers.\r\n**/\r\ncontract PausableToken is StandardToken, Pausable {\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool){\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success)\r\n    {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n}\r\n\r\n/**\r\n* @title Mintable token\r\n* @dev Simple ERC20 Token example, with mintable token creation\r\n* @dev Issue:\r\n* https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n* Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n*/\r\ncontract MintableToken is StandardToken, Ownable {event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n\r\n    bool public mintingFinished = false;\r\n    modifier canMint() {require(!mintingFinished);\r\n        _;\r\n    }\r\n    /**\r\n    * @dev Function to mint tokens\r\n    * @param _to The address that will receive the minted tokens.\r\n    * @param _amount The amount of tokens to mint.\r\n    * @return A boolean that indicates if the operation was successful.\r\n    */\r\n    function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Mint(_to, _amount);\r\n        Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Function to stop minting new tokens.\r\n    * @return True if the operation was successful.\r\n    */\r\n    function finishMinting() onlyOwner canMint public returns (bool) {mintingFinished = true;\r\n        MintFinished();\r\n        return true;}\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title SafeERC20\r\n* @dev Wrappers around ERC20 operations that throw on failure.\r\n* To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n* which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n*/\r\nlibrary SafeERC20 {\r\n    function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n        assert(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n        assert(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n        assert(token.approve(spender, value));\r\n    }\r\n}\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        // assert(b > 0);\r\n        // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b);\r\n        // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n/**\r\n* @title SimpleToken\r\n* @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\r\n* Note they can later distribute these tokens as they wish using `transfer` and other\r\n* `StandardToken` functions.\r\n*/\r\ncontract SimpleToken is StandardToken {\r\n    string public constant name = \"SimpleToken\";\r\n    // solium-disable-line uppercase\r\n    string public constant symbol = \"SIM\";\r\n    // solium-disable-line uppercase\r\n    uint8 public constant decimals = 18;\r\n    // solium-disable-line uppercase\r\n    uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));\r\n    /**\r\n    * @dev Constructor that gives msg.sender all of existing tokens.\r\n    */\r\n    function SimpleToken() public {\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n        Transfer(0x0, msg.sender, INITIAL_SUPPLY);\r\n    }\r\n}\r\n\r\n/**\r\n* @title BiometricLock\r\n* @dev BiometricLock in which only unlocked users can execute methods\r\n*/\r\ncontract BiometricLockable is Ownable {\r\n    event BiometricLocked(address beneficiary, bytes32 sha);\r\n    event BiometricUnlocked(address beneficiary);\r\n\r\n    address BOPS;\r\n    mapping(address => bool) biometricLock;\r\n    mapping(bytes32 => bool) biometricCompleted;\r\n    mapping(bytes32 => uint256) biometricNow;\r\n    /**\r\n    * @dev Locks msg.sender address\r\n    */\r\n    function bioLock() external {\r\n        uint rightNow = now;\r\n        bytes32 sha = keccak256(\"bioLock\", msg.sender, rightNow);\r\n        biometricLock[msg.sender] = true;\r\n        biometricNow[sha] = rightNow;\r\n        BiometricLocked(msg.sender, sha);\r\n    }\r\n    /**\r\n    * @dev Unlocks msg.sender single address.  v,r,s is the sign(sha) by BOPS\r\n    */\r\n    function bioUnlock(bytes32 sha, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(biometricLock[msg.sender]);\r\n        require(!biometricCompleted[sha]);\r\n        bytes32 bioLockSha = keccak256(\"bioLock\", msg.sender, biometricNow[sha]);\r\n        require(sha == bioLockSha);\r\n        require(verify(sha, v, r, s) == true);\r\n        biometricLock[msg.sender] = false;\r\n        BiometricUnlocked(msg.sender);\r\n        biometricCompleted[sha] = true;\r\n    }\r\n\r\n    function isSenderBiometricLocked() external view returns (bool) {\r\n        return biometricLock[msg.sender];\r\n    }\r\n\r\n    function isBiometricLocked(address _beneficiary) internal view returns (bool){\r\n        return biometricLock[_beneficiary];\r\n    }\r\n\r\n    function isBiometricLockedOnlyOwner(address _beneficiary) external onlyOwner view returns (bool){\r\n        return biometricLock[_beneficiary];\r\n    }\r\n    /**\r\n    * @dev BOPS Address setter.  BOPS signs biometric authentications to ensure user's identity\r\n    *\r\n    */\r\n    function setBOPSAddress(address _BOPS) external onlyOwner {\r\n        require(_BOPS != address(0));\r\n        BOPS = _BOPS;\r\n    }\r\n\r\n    function verify(bytes32 sha, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {\r\n        require(BOPS != address(0));\r\n        return ecrecover(sha, v, r, s) == BOPS;\r\n    }\r\n\r\n    function isBiometricCompleted(bytes32 sha) external view returns (bool) {\r\n        return biometricCompleted[sha];\r\n    }\r\n}\r\n\r\n/**\r\n* @title BiometricToken\r\n* @dev BiometricToken is a token contract that can enable Biometric features for ERC20 functions\r\n*/\r\ncontract BiometricToken is Ownable, MintableToken, BiometricLockable {\r\n    event BiometricTransferRequest(address from, address to, uint256 amount, bytes32 sha);\r\n    event BiometricApprovalRequest(address indexed owner, address indexed spender, uint256 value, bytes32 sha);\r\n    // Transfer related methods variables\r\n    mapping(bytes32 => address) biometricFrom;\r\n    mapping(bytes32 => address) biometricAllowee;\r\n    mapping(bytes32 => address) biometricTo;\r\n    mapping(bytes32 => uint256) biometricAmount;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        if (isBiometricLocked(msg.sender)) {\r\n            require(_value <= balances[msg.sender]);\r\n            require(_to != address(0));\r\n            require(_value > 0);\r\n            uint rightNow = now;\r\n            bytes32 sha = keccak256(\"transfer\", msg.sender, _to, _value, rightNow);\r\n            biometricFrom[sha] = msg.sender;\r\n            biometricTo[sha] = _to;\r\n            biometricAmount[sha] = _value;\r\n            biometricNow[sha] = rightNow;\r\n            BiometricTransferRequest(msg.sender, _to, _value, sha);\r\n            return true;\r\n        }\r\n        else {\r\n            return super.transfer(_to, _value);\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        if (isBiometricLocked(_from)) {\r\n            require(_value <= balances[_from]);\r\n            require(_value <= allowed[_from][msg.sender]);\r\n            require(_to != address(0));\r\n            require(_from != address(0));\r\n            require(_value > 0);\r\n            uint rightNow = now;\r\n            bytes32 sha = keccak256(\"transferFrom\", _from, _to, _value, rightNow);\r\n            biometricAllowee[sha] = msg.sender;\r\n            biometricFrom[sha] = _from;\r\n            biometricTo[sha] = _to;\r\n            biometricAmount[sha] = _value;\r\n            biometricNow[sha] = rightNow;\r\n            BiometricTransferRequest(_from, _to, _value, sha);\r\n            return true;\r\n        }\r\n        else {\r\n            return super.transferFrom(_from, _to, _value);\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        if (isBiometricLocked(msg.sender)) {\r\n            uint rightNow = now;\r\n            bytes32 sha = keccak256(\"approve\", msg.sender, _spender, _value, rightNow);\r\n            biometricFrom[sha] = msg.sender;\r\n            biometricTo[sha] = _spender;\r\n            biometricAmount[sha] = _value;\r\n            biometricNow[sha] = rightNow;\r\n            BiometricApprovalRequest(msg.sender, _spender, _value, sha);\r\n            return true;\r\n        }\r\n        else {\r\n            return super.approve(_spender, _value);\r\n        }\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        if (isBiometricLocked(msg.sender)) {\r\n            uint newValue = allowed[msg.sender][_spender].add(_addedValue);\r\n            uint rightNow = now;\r\n            bytes32 sha = keccak256(\"increaseApproval\", msg.sender, _spender, newValue, rightNow);\r\n            biometricFrom[sha] = msg.sender;\r\n            biometricTo[sha] = _spender;\r\n            biometricAmount[sha] = newValue;\r\n            biometricNow[sha] = rightNow;\r\n            BiometricApprovalRequest(msg.sender, _spender, newValue, sha);\r\n            return true;\r\n        }\r\n        else {\r\n            return super.increaseApproval(_spender, _addedValue);\r\n        }\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        if (isBiometricLocked(msg.sender)) {\r\n            uint oldValue = allowed[msg.sender][_spender];\r\n            uint newValue;\r\n            if (_subtractedValue > oldValue) {\r\n                newValue = 0;\r\n            }\r\n            else {\r\n                newValue = oldValue.sub(_subtractedValue);\r\n            }\r\n            uint rightNow = now;\r\n            bytes32 sha = keccak256(\"decreaseApproval\", msg.sender, _spender, newValue, rightNow);\r\n            biometricFrom[sha] = msg.sender;\r\n            biometricTo[sha] = _spender;\r\n            biometricAmount[sha] = newValue;\r\n            biometricNow[sha] = rightNow;\r\n            BiometricApprovalRequest(msg.sender, _spender, newValue, sha);\r\n            return true;\r\n        }\r\n        else {\r\n            return super.decreaseApproval(_spender, _subtractedValue);\r\n        }\r\n    }\r\n    /**\r\n    * @notice Complete pending transfer, can only be called by msg.sender if it is the originator of Transfer\r\n    */\r\n    function releaseTransfer(bytes32 sha, uint8 v, bytes32 r, bytes32 s) public returns (bool){\r\n        require(msg.sender == biometricFrom[sha]);\r\n        require(!biometricCompleted[sha]);\r\n        bytes32 transferFromSha = keccak256(\"transferFrom\", biometricFrom[sha], biometricTo[sha], biometricAmount[sha], biometricNow[sha]);\r\n        bytes32 transferSha = keccak256(\"transfer\", biometricFrom[sha], biometricTo[sha], biometricAmount[sha], biometricNow[sha]);\r\n        require(sha == transferSha || sha == transferFromSha);\r\n        require(verify(sha, v, r, s) == true);\r\n        if (transferFromSha == sha) {\r\n            address _spender = biometricAllowee[sha];\r\n            address _from = biometricFrom[sha];\r\n            address _to = biometricTo[sha];\r\n            uint256 _value = biometricAmount[sha];\r\n            require(_to != address(0));\r\n            require(_value <= balances[_from]);\r\n            require(_value <= allowed[_from][_spender]);\r\n            balances[_from] = balances[_from].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            allowed[msg.sender][_spender] = allowed[msg.sender][_spender].sub(_value);\r\n            Transfer(_from, _to, _value);\r\n        }\r\n        if (transferSha == sha) {\r\n            super.transfer(biometricTo[sha], biometricAmount[sha]);\r\n        }\r\n        biometricCompleted[sha] = true;\r\n        return true;\r\n    }\r\n    /**\r\n    * @notice Cancel pending transfer, can only be called by msg.sender == biometricFrom[sha]\r\n    */\r\n    function cancelTransfer(bytes32 sha) public returns (bool){\r\n        require(msg.sender == biometricFrom[sha]);\r\n        require(!biometricCompleted[sha]);\r\n        biometricCompleted[sha] = true;\r\n        return true;\r\n    }\r\n    /**\r\n    * @notice Complete pending Approval, can only be called by msg.sender if it is the originator of Approval\r\n    */\r\n    function releaseApprove(bytes32 sha, uint8 v, bytes32 r, bytes32 s) public returns (bool){\r\n        require(msg.sender == biometricFrom[sha]);\r\n        require(!biometricCompleted[sha]);\r\n        bytes32 approveSha = keccak256(\"approve\", biometricFrom[sha], biometricTo[sha], biometricAmount[sha], biometricNow[sha]);\r\n        bytes32 increaseApprovalSha = keccak256(\"increaseApproval\", biometricFrom[sha], biometricTo[sha], biometricAmount[sha], biometricNow[sha]);\r\n        bytes32 decreaseApprovalSha = keccak256(\"decreaseApproval\", biometricFrom[sha], biometricTo[sha], biometricAmount[sha], biometricNow[sha]);\r\n        require(approveSha == sha || increaseApprovalSha == sha || decreaseApprovalSha == sha);\r\n        require(verify(sha, v, r, s) == true);\r\n        super.approve(biometricTo[sha], biometricAmount[sha]);\r\n        biometricCompleted[sha] = true;\r\n        return true;\r\n    }\r\n    /**\r\n    * @notice Cancel pending Approval, can only be called by msg.sender == biometricFrom[sha]\r\n    */\r\n    function cancelApprove(bytes32 sha) public returns (bool){\r\n        require(msg.sender == biometricFrom[sha]);\r\n        require(!biometricCompleted[sha]);\r\n        biometricCompleted[sha] = true;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract CompliantToken is BiometricToken {\r\n    //list of praticipants that have purchased during the presale period\r\n    mapping(address => bool) presaleHolder;\r\n    //list of presale participants and date when their tokens are unlocked\r\n    mapping(address => uint256) presaleHolderUnlockDate;\r\n    //list of participants from the United States\r\n    mapping(address => bool) utilityHolder;\r\n    //list of Hoyos Integrity Corp addresses that accept RSN as payment for service\r\n    mapping(address => bool) allowedHICAddress;\r\n    //list of addresses that can add to presale address list (i.e. crowdsale contract)\r\n    mapping(address => bool) privilegeAddress;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        if (presaleHolder[msg.sender]) {\r\n            if (now >= presaleHolderUnlockDate[msg.sender]) {\r\n                return super.transfer(_to, _value);\r\n            }\r\n            else {\r\n                require(allowedHICAddress[_to]);\r\n                return super.transfer(_to, _value);\r\n            }\r\n        }\r\n        if (utilityHolder[msg.sender]) {\r\n            require(allowedHICAddress[_to]);\r\n            return super.transfer(_to, _value);\r\n        }\r\n        else {\r\n            return super.transfer(_to, _value);\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        if (presaleHolder[_from]) {\r\n            if (now >= presaleHolderUnlockDate[_from]) {\r\n                return super.transferFrom(_from, _to, _value);\r\n            }\r\n            else {\r\n                require(allowedHICAddress[_to]);\r\n                return super.transferFrom(_from, _to, _value);\r\n            }\r\n        }\r\n        if (utilityHolder[_from]) {\r\n            require(allowedHICAddress[_to]);\r\n            return super.transferFrom(_from, _to, _value);\r\n        }\r\n        else {\r\n            return super.transferFrom(_from, _to, _value);\r\n        }\r\n    }\r\n    // Allowed HIC addresses to methods: set, remove, is\r\n    function addAllowedHICAddress(address _beneficiary) onlyOwner public {\r\n        allowedHICAddress[_beneficiary] = true;\r\n    }\r\n\r\n    function removeAllowedHICAddress(address _beneficiary) onlyOwner public {\r\n        allowedHICAddress[_beneficiary] = false;\r\n    }\r\n\r\n    function isAllowedHICAddress(address _beneficiary) onlyOwner public view returns (bool){\r\n        return allowedHICAddress[_beneficiary];\r\n    }\r\n    // Utility Holders methods: set, remove, is\r\n    function addUtilityHolder(address _beneficiary) public {\r\n        require(privilegeAddress[msg.sender]);\r\n        utilityHolder[_beneficiary] = true;}\r\n\r\n    function removeUtilityHolder(address _beneficiary) onlyOwner public {\r\n        utilityHolder[_beneficiary] = false;\r\n    }\r\n\r\n    function isUtilityHolder(address _beneficiary) onlyOwner public view returns (bool){\r\n        return utilityHolder[_beneficiary];\r\n    }\r\n    // Presale Holders methods: set, remove, is\r\n    function addPresaleHolder(address _beneficiary) public {\r\n        require(privilegeAddress[msg.sender]);\r\n        presaleHolder[_beneficiary] = true;\r\n        presaleHolderUnlockDate[_beneficiary] = now + 1 years;\r\n    }\r\n\r\n    function removePresaleHolder(address _beneficiary) onlyOwner public {\r\n        presaleHolder[_beneficiary] = false;\r\n        presaleHolderUnlockDate[_beneficiary] = now;\r\n    }\r\n\r\n    function isPresaleHolder(address _beneficiary) onlyOwner public view returns (bool){\r\n        return presaleHolder[_beneficiary];\r\n    }\r\n    // Presale Priviledge Addresses methods: set, remove, is\r\n    function addPrivilegeAddress(address _beneficiary) onlyOwner public {\r\n        privilegeAddress[_beneficiary] = true;\r\n    }\r\n\r\n    function removePrivilegeAddress(address _beneficiary) onlyOwner public {\r\n        privilegeAddress[_beneficiary] = false;\r\n    }\r\n\r\n    function isPrivilegeAddress(address _beneficiary) onlyOwner public view returns (bool){\r\n        return privilegeAddress[_beneficiary];\r\n    }\r\n}\r\n\r\ncontract RISENCoin is CompliantToken, PausableToken {\r\n    string public name = \"RISEN\";\r\n    string public symbol = \"RSN\";\r\n    uint8 public decimals = 18;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sha\",\"type\":\"bytes32\"}],\"name\":\"cancelApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"isPrivilegeAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"isBiometricLockedOnlyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"isAllowedHICAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addPrivilegeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addAllowedHICAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removePresaleHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_BOPS\",\"type\":\"address\"}],\"name\":\"setBOPSAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"isUtilityHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addPresaleHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bioLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeAllowedHICAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sha\",\"type\":\"bytes32\"}],\"name\":\"cancelTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"isPresaleHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sha\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"releaseTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addUtilityHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSenderBiometricLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removePrivilegeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeUtilityHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sha\",\"type\":\"bytes32\"}],\"name\":\"isBiometricCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sha\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"releaseApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sha\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"bioUnlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sha\",\"type\":\"bytes32\"}],\"name\":\"BiometricTransferRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sha\",\"type\":\"bytes32\"}],\"name\":\"BiometricApprovalRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sha\",\"type\":\"bytes32\"}],\"name\":\"BiometricLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"BiometricUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"RISENCoin","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c7c37b7e54aa436f7ab2efda5f1d77968eab6399d93b3b7cb97d0a2a194eade4"}]}