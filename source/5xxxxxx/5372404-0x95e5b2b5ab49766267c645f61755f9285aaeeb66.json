{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20Token {\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract GroupBuy {\r\n    using SafeMath for uint256;\r\n\r\n    enum Phase { Init, Contribute, Wait, Claim, Lock }\r\n    uint256 private constant MAX_TOTAL = 500 ether;\r\n    uint256 private constant MAX_EACH = 2 ether;\r\n\r\n    address private tokenAddr;\r\n    address private owner;\r\n    mapping(address => uint256) private amounts;\r\n    uint256 private totalEth;\r\n    uint256 private totalToken;\r\n    Phase private currentPhase;\r\n\r\n    function GroupBuy() public {\r\n        owner = msg.sender;\r\n        currentPhase = Phase.Init;\r\n    }\r\n\r\n    modifier isOwner() {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // admin function\r\n    function beginContrib() isOwner public {\r\n        require(currentPhase == Phase.Init || currentPhase == Phase.Wait);\r\n        currentPhase = Phase.Contribute;\r\n    }\r\n\r\n    function endContrib() isOwner public {\r\n        require(currentPhase == Phase.Contribute);\r\n        currentPhase = Phase.Wait;\r\n        owner.transfer(address(this).balance); // collect eth to buy token\r\n    }\r\n\r\n    function allowClaim(address _addr) isOwner public returns (uint256) {\r\n        require(currentPhase == Phase.Wait);\r\n        currentPhase = Phase.Claim;\r\n        tokenAddr = _addr;\r\n        \r\n        ERC20Token tok = ERC20Token(tokenAddr);\r\n        totalToken = tok.balanceOf(this);\r\n        require(totalToken > 0);\r\n        return totalToken;\r\n    }\r\n\r\n    // rescue function\r\n    function lock() isOwner public {\r\n        require(currentPhase == Phase.Claim);\r\n        currentPhase = Phase.Lock;\r\n    }\r\n\r\n    function unlock() isOwner public {\r\n        require(currentPhase == Phase.Lock);\r\n        currentPhase = Phase.Claim;\r\n    }\r\n\r\n    function collectEth() isOwner public {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    function setTotalToken(uint _total) isOwner public {\r\n        require(_total > 0);\r\n        totalToken = _total;\r\n    }\r\n\r\n    function setTokenAddr(address _addr) isOwner public {\r\n        tokenAddr = _addr;\r\n    }\r\n\r\n    function withdrawToken(address _erc20, uint _amount) isOwner public returns (bool success) {\r\n        return ERC20Token(_erc20).transfer(owner, _amount);\r\n    } \r\n\r\n    // user function\r\n    function() public payable {\r\n        revert();\r\n    }\r\n\r\n    function info() public view returns (uint phase, uint userEth, uint userToken, uint allEth, uint allToken) {\r\n        phase = uint(currentPhase);\r\n        userEth = amounts[msg.sender];\r\n        userToken = totalEth > 0 ? totalToken.mul(userEth).div(totalEth) : 0;\r\n        allEth = totalEth;\r\n        allToken = totalToken;\r\n    }\r\n\r\n    function contribute() public payable returns (uint _value) {\r\n        require(msg.value > 0);\r\n        require(currentPhase == Phase.Contribute);\r\n        uint cur = amounts[msg.sender];\r\n        require(cur < MAX_EACH && totalEth < MAX_TOTAL);\r\n\r\n        _value = msg.value > MAX_EACH.sub(cur) ? MAX_EACH.sub(cur) : msg.value;\r\n        _value = _value > MAX_TOTAL.sub(totalEth) ? MAX_TOTAL.sub(totalEth) : _value;\r\n        amounts[msg.sender] = cur.add(_value);\r\n        totalEth = totalEth.add(_value);\r\n\r\n        // return redundant eth to user\r\n        if (msg.value.sub(_value) > 0) {\r\n            msg.sender.transfer(msg.value.sub(_value));\r\n        }\r\n    }\r\n\r\n    function claim() public returns (uint amountToken) {\r\n        require(currentPhase == Phase.Claim);\r\n        uint contributed = amounts[msg.sender];\r\n        amountToken = totalEth > 0 ? totalToken.mul(contributed).div(totalEth) : 0;\r\n\r\n        require(amountToken > 0);\r\n        require(ERC20Token(tokenAddr).transfer(msg.sender, amountToken));\r\n        amounts[msg.sender] = 0;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"allowClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTokenAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"info\",\"outputs\":[{\"name\":\"phase\",\"type\":\"uint256\"},{\"name\":\"userEth\",\"type\":\"uint256\"},{\"name\":\"userToken\",\"type\":\"uint256\"},{\"name\":\"allEth\",\"type\":\"uint256\"},{\"name\":\"allToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"beginContrib\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"name\":\"amountToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"setTotalToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_erc20\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endContrib\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"GroupBuy","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8abc3377270858859c6baf0ee950e544532c2dd38ad0c54aa4d915957710989f"}]}