{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Certificate is Ownable {\r\n\r\n  event LogAddCertificateAuthority(address indexed ca_address);\r\n  event LogRemoveCertificateAuthority(address indexed ca_address);\r\n  event LogAddCertificate(address indexed ca_address, bytes32 certificate_hash);\r\n  event LogRevokeCertificate(address indexed ca_address, bytes32 certificate_hash);\r\n  event LogBindCertificate2Wallet(address indexed ca_address, bytes32 certificate_hash, address indexed wallet);\r\n\r\n  struct CertificateAuthority {\r\n    string lookup_api;\r\n    string organization;\r\n    string common_name;\r\n    string country;\r\n    string province;\r\n    string locality;\r\n  }\r\n\r\n  struct CertificateMeta {\r\n    address ca_address;\r\n    uint256 expires;\r\n    bytes32 sealed_hash;\r\n    bytes32 certificate_hash;\r\n  }\r\n\r\n  // Mapping of certificate authority address to the certificate authority\r\n  mapping(address => CertificateAuthority) private certificate_authority;\r\n\r\n  // Mapping of Ethereum wallet address to mapping of certificate authority address to wallet certificate hash\r\n  mapping(address => mapping(address => bytes32)) private wallet_authority_certificate;\r\n\r\n  // Mapping of wallet certificate hash to wallet certificate meta data\r\n  mapping(bytes32 => CertificateMeta) private certificates;\r\n\r\n  modifier onlyCA() {\r\n    require(bytes(certificate_authority[msg.sender].lookup_api).length != 0);\r\n    _;\r\n  }\r\n\r\n  /// @dev Adds a new approved certificate authority\r\n  /// @param ca_address Address of certificate authority to add\r\n  /// @param lookup_api certificate lookup API for the given authority\r\n  /// @param organization Name of the organization this certificate authority represents\r\n  /// @param common_name Common name of this certificate authority\r\n  /// @param country Certificate authority jurisdiction country\r\n  /// @param province Certificate authority jurisdiction state/province\r\n  /// @param locality Certificate authority jurisdiction locality\r\n  function addCA(\r\n    address ca_address,\r\n    string lookup_api,\r\n    string organization,\r\n    string common_name,\r\n    string country,\r\n    string province,\r\n    string locality\r\n  ) public onlyOwner {\r\n    require (ca_address != 0x0);\r\n    require (ca_address != msg.sender);\r\n    require (bytes(lookup_api).length != 0);\r\n    require (bytes(organization).length > 3);\r\n    require (bytes(common_name).length > 3);\r\n    require (bytes(country).length > 1);\r\n\r\n    certificate_authority[ca_address] = CertificateAuthority(\r\n      lookup_api,\r\n      organization,\r\n      common_name,\r\n      country,\r\n      province,\r\n      locality\r\n    );\r\n    LogAddCertificateAuthority(ca_address);\r\n  }\r\n\r\n  /// @dev Removes an existing certificate authority, preventing it from issuing new certificates\r\n  /// @param ca_address Address of certificate authority to remove\r\n  function removeCA(address ca_address) public onlyOwner {\r\n    delete certificate_authority[ca_address];\r\n    LogRemoveCertificateAuthority(ca_address);\r\n  }\r\n\r\n  /// @dev Checks whether an address represents a certificate authority\r\n  /// @param ca_address Address to check\r\n  /// @return true if the address is a valid certificate authority; false otherwise\r\n  function isCA(address ca_address) public view returns (bool) {\r\n    return bytes(certificate_authority[ca_address].lookup_api).length != 0;\r\n  }\r\n\r\n  /// @dev Returns the certificate lookup API for the certificate authority\r\n  /// @param ca_address Address of certificate authority\r\n  /// @return lookup api, organization name, common name, country, state/province, and locality of the certificate authority\r\n  function getCA(address ca_address) public view returns (string, string, string, string, string, string) {\r\n    CertificateAuthority storage ca = certificate_authority[ca_address];\r\n    return (ca.lookup_api, ca.organization, ca.common_name, ca.country, ca.province, ca.locality);\r\n  }\r\n\r\n  /// @dev Adds a new certificate by the calling certificate authority\r\n  /// @param expires seconds from epoch until certificate expires\r\n  /// @param sealed_hash hash of sealed portion of the certificate\r\n  /// @param certificate_hash hash of public portion of the certificate\r\n  function addNewCertificate(uint256 expires, bytes32 sealed_hash, bytes32 certificate_hash) public onlyCA {\r\n    require(expires > now);\r\n\r\n    CertificateMeta storage cert = certificates[certificate_hash];\r\n    require(cert.expires == 0);\r\n\r\n    certificates[certificate_hash] = CertificateMeta(msg.sender, expires, sealed_hash, certificate_hash);\r\n    LogAddCertificate(msg.sender, certificate_hash);\r\n  }\r\n\r\n  /// @dev Adds a new certificate by the calling certificate authority and binds to given wallet\r\n  /// @param wallet Wallet to which the certificate is being bound to\r\n  /// @param expires seconds from epoch until certificate expires\r\n  /// @param sealed_hash hash of sealed portion of the certificate\r\n  /// @param certificate_hash hash of public portion of the certificate\r\n  function addCertificateAndBind2Wallet(address wallet, uint256 expires, bytes32 sealed_hash, bytes32 certificate_hash) public onlyCA {\r\n    require(expires > now);\r\n\r\n    CertificateMeta storage cert = certificates[certificate_hash];\r\n    require(cert.expires == 0);\r\n\r\n    certificates[certificate_hash] = CertificateMeta(msg.sender, expires, sealed_hash, certificate_hash);\r\n    LogAddCertificate(msg.sender, certificate_hash);\r\n    wallet_authority_certificate[wallet][msg.sender] = certificate_hash;\r\n    LogBindCertificate2Wallet(msg.sender, certificate_hash, wallet);\r\n  }\r\n\r\n  /// @dev Bind an existing certificate to a wallet - can be called by certificate authority that issued the certificate or a wallet already bound to the certificate\r\n  /// @param wallet Wallet to which the certificate is being bound to\r\n  /// @param certificate_hash hash of public portion of the certificate\r\n  function bindCertificate2Wallet(address wallet, bytes32 certificate_hash) public {\r\n    CertificateMeta storage cert = certificates[certificate_hash];\r\n    require(cert.expires > now);\r\n\r\n    bytes32 sender_certificate_hash = wallet_authority_certificate[msg.sender][cert.ca_address];\r\n\r\n    require(cert.ca_address == msg.sender || cert.certificate_hash == sender_certificate_hash);\r\n\r\n    wallet_authority_certificate[wallet][cert.ca_address] = certificate_hash;\r\n    LogBindCertificate2Wallet(msg.sender, certificate_hash, wallet);\r\n  }\r\n\r\n  /// @dev Revokes an existing certificate - can be called by certificate authority that issued the certificate\r\n  /// @param certificate_hash hash of public portion of the certificate\r\n  function revokeCertificate(bytes32 certificate_hash) public onlyCA {\r\n    CertificateMeta storage cert = certificates[certificate_hash];\r\n    require(cert.ca_address == msg.sender);\r\n    cert.expires = 0;\r\n    LogRevokeCertificate(msg.sender, certificate_hash);\r\n  }\r\n\r\n  /// @dev returns certificate metadata given the certificate hash\r\n  /// @param certificate_hash hash of public portion of the certificate\r\n  /// @return certificate authority address, certificate expiration time, hash of sealed portion of the certificate, hash of public portion of the certificate\r\n  function getCertificate(bytes32 certificate_hash) public view returns (address, uint256, bytes32, bytes32) {\r\n    CertificateMeta storage cert = certificates[certificate_hash];\r\n    if (isCA(cert.ca_address)) {\r\n      return (cert.ca_address, cert.expires, cert.sealed_hash, cert.certificate_hash);\r\n    } else {\r\n      return (0x0, 0, 0x0, 0x0);\r\n    }\r\n  }\r\n\r\n  /// @dev returns certificate metadata for a given wallet from a particular certificate authority\r\n  /// @param wallet Wallet for which the certificate is being looked up\r\n  /// @param ca_address Address of certificate authority\r\n  /// @return certificate expiration time, hash of sealed portion of the certificate, hash of public portion of the certificate\r\n  function getCertificateForWallet(address wallet, address ca_address) public view returns (uint256, bytes32, bytes32) {\r\n    bytes32 certificate_hash = wallet_authority_certificate[wallet][ca_address];\r\n    CertificateMeta storage cert = certificates[certificate_hash];\r\n    if (isCA(cert.ca_address)) {\r\n      return (cert.expires, cert.sealed_hash, cert.certificate_hash);\r\n    } else {\r\n      return (0, 0x0, 0x0);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"ca_address\",\"type\":\"address\"}],\"name\":\"removeCA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"sealed_hash\",\"type\":\"bytes32\"},{\"name\":\"certificate_hash\",\"type\":\"bytes32\"}],\"name\":\"addCertificateAndBind2Wallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"certificate_hash\",\"type\":\"bytes32\"}],\"name\":\"bindCertificate2Wallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"ca_address\",\"type\":\"address\"}],\"name\":\"getCertificateForWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ca_address\",\"type\":\"address\"},{\"name\":\"lookup_api\",\"type\":\"string\"},{\"name\":\"organization\",\"type\":\"string\"},{\"name\":\"common_name\",\"type\":\"string\"},{\"name\":\"country\",\"type\":\"string\"},{\"name\":\"province\",\"type\":\"string\"},{\"name\":\"locality\",\"type\":\"string\"}],\"name\":\"addCA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ca_address\",\"type\":\"address\"}],\"name\":\"isCA\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"sealed_hash\",\"type\":\"bytes32\"},{\"name\":\"certificate_hash\",\"type\":\"bytes32\"}],\"name\":\"addNewCertificate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certificate_hash\",\"type\":\"bytes32\"}],\"name\":\"revokeCertificate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ca_address\",\"type\":\"address\"}],\"name\":\"getCA\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"certificate_hash\",\"type\":\"bytes32\"}],\"name\":\"getCertificate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ca_address\",\"type\":\"address\"}],\"name\":\"LogAddCertificateAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ca_address\",\"type\":\"address\"}],\"name\":\"LogRemoveCertificateAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ca_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"certificate_hash\",\"type\":\"bytes32\"}],\"name\":\"LogAddCertificate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ca_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"certificate_hash\",\"type\":\"bytes32\"}],\"name\":\"LogRevokeCertificate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ca_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"certificate_hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"LogBindCertificate2Wallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Certificate","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cec7330a60cf6f6084f8f6f6229a2d3d22fa8a14fe8faabae1235e2df6c9d8a1"}]}