{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n   OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 interface\r\n * @dev see https://github.com/ethereum/eips/issues/721\r\n */\r\ncontract ERC721 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function transfer(address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function takeOwnership(uint256 _tokenId) public;\r\n}\r\n\r\n\r\n/// @title CryptoCelebritiesMarket\r\n/// @dev Contains models, variables, and internal methods for sales.\r\ncontract CelebrityMarket is Pausable{\r\n\r\n    ERC721 ccContract;\r\n\r\n    // Represents a sale item on an NFT\r\n    struct Sale {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) at beginning of a sale item\r\n        uint256 salePrice;\r\n        // Time when sale started\r\n        // NOTE: 0 if this sale has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Owner of this contract\r\n    address public owner;\r\n\r\n    // Map from token ID to their corresponding sale.\r\n    mapping (uint256 => Sale) tokenIdToSale;\r\n\r\n    event SaleCreated(address seller,uint256 tokenId, uint256 salePrice, uint256 startedAt);\r\n    event SaleSuccessful(address seller, uint256 tokenId, uint256 totalPrice, address winner);\r\n    event SaleCancelled(address seller, uint256 tokenId);\r\n    event SaleUpdated(address seller, uint256 tokenId, uint256 oldPrice, uint256 newPrice);\r\n    \r\n    /// @dev Constructor registers the nft address (CCAddress)\r\n    /// @param _ccAddress - Address of the CryptoCelebrities contract\r\n    function CelebrityMarket(address _ccAddress) public {\r\n        ccContract = ERC721(_ccAddress);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev DON'T give me your money.\r\n    function() external {}\r\n\r\n\r\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\r\n    ///  as well as any Ether sent directly to the contract address.\r\n    ///  Always transfers to the NFT contract, but can be called either by\r\n    ///  the owner or the NFT contract.\r\n    function withdrawBalance() external {\r\n        require(\r\n            msg.sender == owner\r\n        );\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    /// @dev Creates and begins a new sale.\r\n    /// @param _tokenId - ID of token to sell, sender must be owner.\r\n    /// @param _salePrice - Sale Price of item (in wei).\r\n    function createSale(\r\n        uint256 _tokenId,\r\n        uint256 _salePrice\r\n    )\r\n        public\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _tokenId));\r\n        _escrow(_tokenId);\r\n        Sale memory sale = Sale(\r\n            msg.sender,\r\n            _salePrice,\r\n            uint64(now)\r\n        );\r\n        _addSale(_tokenId, sale);\r\n    }\r\n\r\n    /// @dev Update sale price of a sale item that hasn't been completed yet.\r\n    /// @notice This is a state-modifying function that can\r\n    ///  be called while the contract is paused.\r\n    /// @param _tokenId - ID of token on sale\r\n    /// @param _newPrice - new sale price\r\n    function updateSalePrice(uint256 _tokenId, uint256 _newPrice)\r\n        public\r\n    {\r\n        Sale storage sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        address seller = sale.seller;\r\n        require(msg.sender == seller);\r\n        _updateSalePrice(_tokenId, _newPrice, seller);\r\n    }\r\n\r\n    /// @dev Allows to buy a sale item, completing the sale and transferring\r\n    /// ownership of the NFT if enough Ether is supplied.\r\n    /// @param _tokenId - ID of token to buy.\r\n    function buy(uint256 _tokenId)\r\n        public\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        // _bid will throw if the bid or funds transfer fails\r\n        _buy(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels a sale that hasn't been completed yet.\r\n    ///  Returns the NFT to original owner.\r\n    /// @notice This is a state-modifying function that can\r\n    ///  be called while the contract is paused.\r\n    /// @param _tokenId - ID of token on sale\r\n    function cancelSale(uint256 _tokenId)\r\n        public\r\n    {\r\n        Sale storage sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        address seller = sale.seller;\r\n        require(msg.sender == seller);\r\n        _cancelSale(_tokenId, seller);\r\n    }\r\n\r\n    /// @dev Cancels a sale when the contract is paused.\r\n    ///  Only the owner may do this, and NFTs are returned to\r\n    ///  the seller. This should only be used in emergencies.\r\n    /// @param _tokenId - ID of the NFT on sale to cancel.\r\n    function cancelSaleWhenPaused(uint256 _tokenId)\r\n        whenPaused\r\n        onlyOwner\r\n        public\r\n    {\r\n        Sale storage sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        _cancelSale(_tokenId, sale.seller);\r\n    }\r\n\r\n    /// @dev Returns sale info for an NFT on sale.\r\n    /// @param _tokenId - ID of NFT on sale.\r\n    function getSale(uint256 _tokenId)\r\n        public\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 salePrice,\r\n        uint256 startedAt\r\n    ) {\r\n        Sale storage sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        return (\r\n            sale.seller,\r\n            sale.salePrice,\r\n            sale.startedAt\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the current price of a sale item.\r\n    /// @param _tokenId - ID of the token price we are checking.\r\n    function getSalePrice(uint256 _tokenId)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Sale storage sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        return sale.salePrice;\r\n    }\r\n\r\n    /// @dev Returns true if the claimant owns the token.\r\n    /// @param _claimant - Address claiming to own the token.\r\n    /// @param _tokenId - ID of token whose ownership to verify.\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (ccContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /// @dev Escrows the CCToken, assigning ownership to this contract.\r\n    /// Throws if the escrow fails.\r\n    /// @param _tokenId - ID of token whose approval to verify.\r\n    function _escrow(uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        ccContract.takeOwnership(_tokenId);\r\n    }\r\n\r\n    /// @dev Transfers a CCToken owned by this contract to another address.\r\n    /// Returns true if the transfer succeeds.\r\n    /// @param _receiver - Address to transfer NFT to.\r\n    /// @param _tokenId - ID of token to transfer.\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        ccContract.transfer(_receiver, _tokenId);\r\n    }\r\n\r\n    /// @dev Adds a sale to the list of open sales. Also fires the\r\n    ///  SaleCreated event.\r\n    /// @param _tokenId The ID of the token to be put on sale.\r\n    /// @param _sale Sale to add.\r\n    function _addSale(uint256 _tokenId, Sale _sale) internal {\r\n\r\n        tokenIdToSale[_tokenId] = _sale;\r\n        \r\n        SaleCreated(\r\n            address(_sale.seller),\r\n            uint256(_tokenId),\r\n            uint256(_sale.salePrice),\r\n            uint256(_sale.startedAt)\r\n        );\r\n    }\r\n\r\n    /// @dev Cancels a sale unconditionally.\r\n    function _cancelSale(uint256 _tokenId, address _seller) internal {\r\n        _removeSale(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        SaleCancelled(_seller, _tokenId);\r\n    }\r\n\r\n    /// @dev updates sale price of item\r\n    function _updateSalePrice(uint256 _tokenId, uint256 _newPrice, address _seller) internal {\r\n        // Get a reference to the sale struct\r\n        Sale storage sale = tokenIdToSale[_tokenId];\r\n        uint256 oldPrice = sale.salePrice;\r\n        sale.salePrice = _newPrice;\r\n        SaleUpdated(_seller, _tokenId, oldPrice, _newPrice);\r\n    }\r\n\r\n    /// @dev Computes the price and transfers winnings.\r\n    /// Does NOT transfer ownership of token.\r\n    function _buy(uint256 _tokenId, uint256 _amount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // Get a reference to the sale struct\r\n        Sale storage sale = tokenIdToSale[_tokenId];\r\n\r\n        // Explicitly check that this sale is currently live.\r\n        // (Because of how Ethereum mappings work, we can't just count\r\n        // on the lookup above failing. An invalid _tokenId will just\r\n        // return an sale object that is all zeros.)\r\n        require(_isOnSale(sale));\r\n\r\n        // Check that the incoming bid is higher than the current\r\n        // price\r\n        uint256 price = sale.salePrice;\r\n\r\n        require(_amount >= price);\r\n\r\n        // Grab a reference to the seller before the sale struct\r\n        // gets deleted.\r\n        address seller = sale.seller;\r\n\r\n        // The bid is good! Remove the sale before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        _removeSale(_tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            //  Calculate the market owner's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            //  value <= price, so this subtraction can't go negative.)\r\n            uint256 ownerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - ownerCut;\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the sale item\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelSale(). )\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 amountExcess = _amount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the sale is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(amountExcess);\r\n\r\n        // Tell the world!\r\n        SaleSuccessful(seller, _tokenId, price, msg.sender);\r\n\r\n        return price;\r\n    }\r\n\r\n    /// @dev Removes a sale item from the list of open sales.\r\n    /// @param _tokenId - ID of NFT on sale.\r\n    function _removeSale(uint256 _tokenId) internal {\r\n        delete tokenIdToSale[_tokenId];\r\n    }\r\n\r\n    /// @dev Returns true if the NFT is on sale.\r\n    /// @param _sale - Sale to check.\r\n    function _isOnSale(Sale storage _sale) internal view returns (bool) {\r\n        return (_sale.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Computes owner's cut of a sale.\r\n    /// @param _price - Sale price of NFT.\r\n    function _computeCut(uint256 _price) internal pure returns (uint256) {\r\n        return uint256(SafeMath.div(SafeMath.mul(_price, 6), 100));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelSaleWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"updateSalePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"createSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getSale\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"salePrice\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getSalePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ccAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"salePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"SaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"SaleSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"SaleCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"SaleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CelebrityMarket","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bb5ed1edeb5149af3ab43ea9c7a6963b3c1374f7","Library":"","SwarmSource":"bzzr://f13e4d2aeb4d860fdbf00ec777500f905c8fdf6ddaa51b1c8f0d292e01005ba6"}]}