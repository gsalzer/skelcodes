{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title MultiOwnable\r\n * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\r\n * functions, this simplifies the implementation of \"users permissions\".\r\n */\r\ncontract MultiOwnable {\r\n    address public manager; // address used to set owners\r\n    address[] public owners;\r\n    mapping(address => bool) public ownerByAddress;\r\n\r\n    event SetManager(address manager);\r\n    event SetOwners(address[] owners);\r\n\r\n    modifier onlyOwner() {\r\n        require(ownerByAddress[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev MultiOwnable constructor sets the manager\r\n     */\r\n    constructor() public {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to set owners addresses\r\n     */\r\n    function setOwners(address[] _owners) onlyManager public {\r\n        _setOwners(_owners);\r\n    }\r\n\r\n    function _setOwners(address[] _owners) internal {\r\n        for(uint256 i = 0; i < owners.length; i++) {\r\n            ownerByAddress[owners[i]] = false;\r\n        }\r\n\r\n        for(uint256 j = 0; j < _owners.length; j++) {\r\n            ownerByAddress[_owners[j]] = true;\r\n        }\r\n        owners = _owners;\r\n        emit SetOwners(_owners);\r\n    }\r\n\r\n    function getOwners() public constant returns (address[]) {\r\n        return owners;\r\n    }\r\n\r\n    function setManager(address _manager) onlyManager public {\r\n        manager = _manager;\r\n        emit SetManager(_manager);\r\n    }\r\n}\r\n\r\n\r\ncontract WorldCup is MultiOwnable, SafeMath {\r\n\r\n    enum Result {Unknown, HomeWin, HomeDraw, HomeLoss}\r\n\r\n    // Data Struct\r\n\r\n    struct Match {\r\n        bool created;\r\n\r\n        // Match Info\r\n        string team;\r\n        string teamDetail;\r\n        int32  pointSpread;\r\n        uint64 startTime;\r\n        uint64 endTime;\r\n\r\n        // Current Stakes\r\n        uint256 stakesOfWin;\r\n        uint256 stakesOfDraw;\r\n        uint256 stakesOfLoss;\r\n\r\n        // Result\r\n        Result result;\r\n    }\r\n\r\n    struct Prediction {\r\n        Result result;\r\n        uint256 stake;\r\n        bool withdraw;\r\n    }\r\n\r\n    // Storage\r\n\r\n    uint public numMatches;\r\n    mapping(uint => Match) public matches;\r\n    mapping(uint => mapping(address => Prediction)) public predictions;\r\n    uint256 public rate;\r\n\r\n    // Event\r\n\r\n    event NewMatch(uint indexed id, string team, string detail, int32 spread, uint64 start, uint64 end);\r\n    event MatchInfo(uint indexed id, string detail);\r\n    event MatchResult(uint indexed id, Result result, uint256 fee);\r\n    event Bet(address indexed user, uint indexed id, Result result, uint256 stake,\r\n        uint256 stakesOfWin, uint256 stakesOfDraw, uint256 stakesOfLoss);\r\n    event Withdraw(address indexed user, uint indexed id, uint256 bonus);\r\n\r\n    modifier validId(uint _id) {\r\n        require(matches[_id].created == true);\r\n        _;\r\n    }\r\n\r\n    modifier validResult(Result _result) {\r\n        require(_result == Result.HomeWin || _result == Result.HomeDraw || _result == Result.HomeLoss);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        rate = 20; // 5%\r\n    }\r\n\r\n    // For Owner & Manager\r\n\r\n    function createMatch(uint _id, string _team, string _teamDetail, int32 _pointSpread, uint64 _startTime, uint64 _endTime)\r\n    onlyOwner\r\n    public {\r\n\r\n        require(_startTime < _endTime);\r\n        require(matches[_id].created == false);\r\n\r\n        // Create new match\r\n        Match memory _match = Match({\r\n            created:true,\r\n            team: _team,\r\n            teamDetail: _teamDetail,\r\n            pointSpread: _pointSpread,\r\n            startTime: _startTime,\r\n            endTime: _endTime,\r\n            stakesOfWin: 0,\r\n            stakesOfDraw: 0,\r\n            stakesOfLoss: 0,\r\n            result: Result.Unknown\r\n            });\r\n\r\n        // Insert into matches\r\n        matches[_id] = _match;\r\n        numMatches++;\r\n\r\n        // Set event\r\n        emit NewMatch(_id, _team, _teamDetail, _pointSpread, _startTime, _endTime);\r\n    }\r\n\r\n    function updateMatchInfo(uint _id, string _teamDetail, uint64 _startTime, uint64 _endTime)\r\n    onlyOwner\r\n    validId(_id)\r\n    public {\r\n\r\n        // Update match info\r\n        if (bytes(_teamDetail).length > 0) {\r\n            matches[_id].teamDetail = _teamDetail;\r\n        }\r\n        if (_startTime != 0) {\r\n            matches[_id].startTime = _startTime;\r\n        }\r\n        if (_endTime != 0) {\r\n            matches[_id].endTime = _endTime;\r\n        }\r\n\r\n        // Set event\r\n        emit MatchInfo(_id, _teamDetail);\r\n    }\r\n\r\n    function announceMatchResult(uint _id, Result _result)\r\n    onlyManager\r\n    validId(_id)\r\n    validResult(_result)\r\n    public {\r\n\r\n        // Check current result\r\n        require(matches[_id].result == Result.Unknown);\r\n\r\n        // Update result\r\n        matches[_id].result = _result;\r\n\r\n        // Calculate bonus and fee\r\n        uint256 bonus;\r\n        uint256 fee;\r\n        Match storage _match = matches[_id];\r\n\r\n        if (_result == Result.HomeWin) {\r\n            bonus = add(_match.stakesOfDraw, _match.stakesOfLoss);\r\n            if (_match.stakesOfWin > 0) {\r\n                fee = div(bonus, rate);\r\n            } else {\r\n                fee = bonus;\r\n            }\r\n        } else if (_result == Result.HomeDraw) {\r\n            bonus = add(_match.stakesOfWin, _match.stakesOfLoss);\r\n            if (_match.stakesOfDraw > 0) {\r\n                fee = div(bonus, rate);\r\n            } else {\r\n                fee = bonus;\r\n            }\r\n        } else if (_result == Result.HomeLoss) {\r\n            bonus = add(_match.stakesOfWin, _match.stakesOfDraw);\r\n            if (_match.stakesOfLoss > 0) {\r\n                fee = div(bonus, rate);\r\n            } else {\r\n                fee = bonus;\r\n            }\r\n        }\r\n\r\n        address thiz = address(this);\r\n        require(thiz.balance >= fee);\r\n        manager.transfer(fee);\r\n\r\n        // Set event\r\n        emit MatchResult(_id, _result, fee);\r\n    }\r\n\r\n    // For Player\r\n\r\n    function bet(uint _id, Result _result)\r\n    validId(_id)\r\n    validResult(_result)\r\n    public\r\n    payable {\r\n\r\n        // Check value\r\n        require(msg.value > 0);\r\n\r\n        // Check match state\r\n        Match storage _match = matches[_id];\r\n        require(_match.result == Result.Unknown);\r\n        require(_match.startTime <= now);\r\n        require(_match.endTime >= now);\r\n\r\n        // Update matches\r\n        if (_result == Result.HomeWin) {\r\n            _match.stakesOfWin = add(_match.stakesOfWin, msg.value);\r\n        } else if (_result == Result.HomeDraw) {\r\n            _match.stakesOfDraw = add(_match.stakesOfDraw, msg.value);\r\n        } else if (_result == Result.HomeLoss) {\r\n            _match.stakesOfLoss = add(_match.stakesOfLoss, msg.value);\r\n        }\r\n\r\n        // Update predictions\r\n        Prediction storage _prediction = predictions[_id][msg.sender];\r\n        if (_prediction.result == Result.Unknown) {\r\n            _prediction.stake = msg.value;\r\n            _prediction.result = _result;\r\n        } else {\r\n            require(_prediction.result == _result);\r\n            _prediction.stake = add(_prediction.stake, msg.value);\r\n        }\r\n\r\n        // Set event\r\n        emit Bet(msg.sender, _id, _result, msg.value, _match.stakesOfWin, _match.stakesOfDraw, _match.stakesOfLoss);\r\n    }\r\n\r\n    function getBonus(uint _id, address addr)\r\n    validId(_id)\r\n    public\r\n    view\r\n    returns (uint256) {\r\n\r\n        // Get match state\r\n        Match storage _match = matches[_id];\r\n        if (_match.result == Result.Unknown) {\r\n            return 0;\r\n        }\r\n\r\n        // Get prediction state\r\n        Prediction storage _prediction = predictions[_id][addr];\r\n        if (_prediction.result == Result.Unknown) {\r\n            return 0;\r\n        }\r\n\r\n        // Check result\r\n        if (_match.result != _prediction.result) {\r\n            return 0;\r\n        }\r\n\r\n        // Calculate bonus\r\n        uint256 bonus = _calcBouns(_match, _prediction);\r\n        bonus = add(bonus, _prediction.stake);\r\n\r\n        return bonus;\r\n    }\r\n\r\n    function withdraw(uint _id)\r\n    validId(_id)\r\n    public {\r\n        // Check match state\r\n        Match storage _match = matches[_id];\r\n        require(_match.result != Result.Unknown);\r\n\r\n        // Check prediction state\r\n        Prediction storage _prediction = predictions[_id][msg.sender];\r\n        require(_prediction.result != Result.Unknown);\r\n        require(_prediction.stake > 0);\r\n        require(_prediction.withdraw == false);\r\n        _prediction.withdraw = true;\r\n\r\n        // Check result\r\n        require(_prediction.result == _match.result);\r\n\r\n        // Calc bonus\r\n        uint256 bonus = _calcBouns(_match, _prediction);\r\n        bonus = add(bonus, _prediction.stake);\r\n\r\n        address thiz = address(this);\r\n        require(thiz.balance >= bonus);\r\n        msg.sender.transfer(bonus);\r\n\r\n        // Set event\r\n        emit Withdraw(msg.sender, _id, bonus);\r\n    }\r\n\r\n    function _calcBouns(Match storage _match, Prediction storage _prediction)\r\n    internal\r\n    view\r\n    returns (uint256) {\r\n\r\n        uint256 bonus;\r\n\r\n        if (_match.result != _prediction.result) {\r\n            return 0;\r\n        }\r\n\r\n        if (_match.result == Result.HomeWin && _match.stakesOfWin > 0) {\r\n            bonus = add(_match.stakesOfDraw, _match.stakesOfLoss);\r\n            bonus = sub(bonus, div(bonus, rate));\r\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfWin);\r\n        } else if (_match.result == Result.HomeDraw && _match.stakesOfDraw > 0 ) {\r\n            bonus = add(_match.stakesOfWin, _match.stakesOfLoss);\r\n            bonus = sub(bonus, div(bonus, rate));\r\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfDraw);\r\n        } else if (_match.result == Result.HomeLoss && _match.stakesOfLoss > 0) {\r\n            bonus = add(_match.stakesOfWin, _match.stakesOfDraw);\r\n            bonus = sub(bonus, div(bonus, rate));\r\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfLoss);\r\n        }\r\n\r\n        return bonus;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_result\",\"type\":\"uint8\"}],\"name\":\"announceMatchResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matches\",\"outputs\":[{\"name\":\"created\",\"type\":\"bool\"},{\"name\":\"team\",\"type\":\"string\"},{\"name\":\"teamDetail\",\"type\":\"string\"},{\"name\":\"pointSpread\",\"type\":\"int32\"},{\"name\":\"startTime\",\"type\":\"uint64\"},{\"name\":\"endTime\",\"type\":\"uint64\"},{\"name\":\"stakesOfWin\",\"type\":\"uint256\"},{\"name\":\"stakesOfDraw\",\"type\":\"uint256\"},{\"name\":\"stakesOfLoss\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"string\"},{\"name\":\"_teamDetail\",\"type\":\"string\"},{\"name\":\"_pointSpread\",\"type\":\"int32\"},{\"name\":\"_startTime\",\"type\":\"uint64\"},{\"name\":\"_endTime\",\"type\":\"uint64\"}],\"name\":\"createMatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_teamDetail\",\"type\":\"string\"},{\"name\":\"_startTime\",\"type\":\"uint64\"},{\"name\":\"_endTime\",\"type\":\"uint64\"}],\"name\":\"updateMatchInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numMatches\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"predictions\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"stake\",\"type\":\"uint256\"},{\"name\":\"withdraw\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_result\",\"type\":\"uint8\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"}],\"name\":\"setOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"team\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"detail\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"spread\",\"type\":\"int32\"},{\"indexed\":false,\"name\":\"start\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"NewMatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"detail\",\"type\":\"string\"}],\"name\":\"MatchInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"MatchResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakesOfWin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakesOfDraw\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakesOfLoss\",\"type\":\"uint256\"}],\"name\":\"Bet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonus\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"SetManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owners\",\"type\":\"address[]\"}],\"name\":\"SetOwners\",\"type\":\"event\"}]","ContractName":"WorldCup","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9acb94fafb30f877552b71113a959d59a3f13bbef36a11038456129f6fbd5184"}]}