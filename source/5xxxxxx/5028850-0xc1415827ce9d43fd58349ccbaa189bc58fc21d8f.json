{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n\r\ncontract Token {\r\n    function totalSupply() constant returns (uint totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n\r\n    function issue(address _to, uint _value) public returns (bool);\r\n    function transferOwnership(address _newOwner) public;\r\n}\r\n\r\n\r\ncontract Registry {\r\n    function updateFee(uint256 _fee) public;\r\n    function transferOwnership(address _newOwner) public;\r\n}\r\n\r\n\r\ncontract DAO {\r\n    function payFee() public payable;\r\n}\r\n\r\n\r\ncontract TokenRecipient {\r\n    address public receiver = 0xD86b17d42E4385293B961BE704602eDF0f4b3eB8;\r\n\r\n    event receivedEther(address sender, uint amount);\r\n\r\n    // Dev donations\r\n    function () public payable {\r\n        receiver.transfer(msg.value);\r\n        receivedEther(msg.sender, msg.value);\r\n    }\r\n\r\n    function payFee() public payable {\r\n        receivedEther(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdrawTokenBalance(uint256 _value, address _token) public {\r\n        Token erc20 = Token(_token);\r\n        require(erc20.transfer(receiver, _value));\r\n    }\r\n\r\n    function withdrawFullTokenBalance(address _token) public {\r\n        Token erc20 = Token(_token);\r\n        require(erc20.transfer(receiver, erc20.balanceOf(this)));\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * The shareholder association contract itself\r\n */\r\ncontract EngravedDAO is TokenRecipient {\r\n\r\n    event ProposalAdded(uint proposalID);\r\n    event Voted(uint proposalID, bool position, address voter);\r\n    event ProposalTallied(uint proposalID, uint result, uint quorum, bool active);\r\n    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newEgcToken);\r\n\r\n    uint public dividend;\r\n\r\n    uint public minimumQuorum;\r\n    uint public debatingPeriodInMinutes;\r\n    Proposal[] public proposals;\r\n    uint public numProposals;\r\n\r\n    uint public minAmount;\r\n\r\n    Token public egcToken;\r\n    Token public egrToken;\r\n\r\n    Registry public ownership;\r\n    Registry public integrity;\r\n\r\n    // Payment dates\r\n    uint256 public withdrawStart;\r\n\r\n    // EGC stored balances for dividends\r\n    mapping (address => uint256) internal lockedBalances;\r\n\r\n    enum ProposalType {\r\n        TransferOwnership,\r\n        ChangeOwnershipFee,\r\n        ChangeIntegrityFee\r\n    }\r\n\r\n    struct Proposal {\r\n        string description;\r\n        uint votingDeadline;\r\n        bool executed;\r\n        bool proposalPassed;\r\n        uint numberOfVotes;\r\n        Vote[] votes;\r\n        mapping (address => bool) voted;\r\n        ProposalType proposalType;\r\n        uint newFee;\r\n        address newDao;\r\n    }\r\n\r\n    struct Vote {\r\n        bool inSupport;\r\n        address voter;\r\n    }\r\n\r\n    // Modifier that allows only shareholders to vote and create new proposals\r\n    modifier onlyShareholders {\r\n        require(egcToken.balanceOf(msg.sender) > 0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor function\r\n     *\r\n     * First time setup\r\n     */\r\n    function EngravedDAO(\r\n        address _ownershipAddress,\r\n        address _integrityAddress,\r\n        address _egrTokenAddress,\r\n        address _egcTokenAddress,\r\n        uint _minimumQuorum,\r\n        uint _debatingPeriodInMinutes,\r\n        uint _minAmount\r\n    ) public {\r\n        ownership = Registry(_ownershipAddress);\r\n        integrity = Registry(_integrityAddress);\r\n        egrToken = Token(_egrTokenAddress);\r\n        egcToken = Token(_egcTokenAddress);\r\n\r\n        withdrawStart = block.timestamp;\r\n\r\n        if (_minimumQuorum == 0) {\r\n            _minimumQuorum = 1;\r\n        }\r\n\r\n        minimumQuorum = _minimumQuorum;\r\n        debatingPeriodInMinutes = _debatingPeriodInMinutes;\r\n        ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, egcToken);\r\n\r\n        minAmount = _minAmount;\r\n    }\r\n\r\n    function withdrawDividends() public {\r\n        // Locked balance is positive\r\n        require(lockedBalances[msg.sender] > 0);\r\n\r\n        // On time\r\n        require(block.timestamp >= withdrawStart + 3 days && block.timestamp < withdrawStart + 1 weeks);\r\n\r\n        uint256 locked = lockedBalances[msg.sender];\r\n        lockedBalances[msg.sender] = 0;\r\n\r\n        uint256 earnings = dividend * locked / 1e18;\r\n\r\n        // Send tokens back to the stakeholder\r\n        egcToken.transfer(msg.sender, locked);\r\n        msg.sender.transfer(earnings);\r\n    }\r\n\r\n    function unlockFunds() public {\r\n        // Locked balance is positive\r\n        require(lockedBalances[msg.sender] > 0);\r\n\r\n        uint256 locked = lockedBalances[msg.sender];\r\n        lockedBalances[msg.sender] = 0;\r\n\r\n        // Send tokens back to the stakeholder\r\n        egcToken.transfer(msg.sender, locked);\r\n    }\r\n\r\n    // Lock funds for dividends payment\r\n    function lockFunds(uint _value) public {\r\n        // Three days before the payment date\r\n        require(block.timestamp >= withdrawStart && block.timestamp < withdrawStart + 3 days);\r\n\r\n        lockedBalances[msg.sender] += _value;\r\n\r\n        require(egcToken.allowance(msg.sender, this) >= _value);\r\n        require(egcToken.transferFrom(msg.sender, this, _value));\r\n    }\r\n\r\n    function newOwnershipFeeProposal(\r\n        uint256 _newFee,\r\n        string _jobDescription\r\n    )\r\n        public onlyShareholders\r\n        returns (uint proposalID)\r\n    {\r\n        proposalID = proposals.length++;\r\n        Proposal storage p = proposals[proposalID];\r\n        p.description = _jobDescription;\r\n        p.votingDeadline = block.timestamp + debatingPeriodInMinutes * 1 minutes;\r\n        p.executed = false;\r\n        p.proposalPassed = false;\r\n        p.numberOfVotes = 0;\r\n        p.proposalType = ProposalType.ChangeOwnershipFee;\r\n        p.newFee = _newFee;\r\n        ProposalAdded(proposalID);\r\n        numProposals = proposalID+1;\r\n\r\n        return proposalID;\r\n    }\r\n\r\n    function newIntegrityFeeProposal(\r\n        uint256 _newFee,\r\n        string _jobDescription\r\n    )\r\n        public onlyShareholders\r\n        returns (uint proposalID)\r\n    {\r\n        proposalID = proposals.length++;\r\n        Proposal storage p = proposals[proposalID];\r\n        p.description = _jobDescription;\r\n        p.votingDeadline = block.timestamp + debatingPeriodInMinutes * 1 minutes;\r\n        p.executed = false;\r\n        p.proposalPassed = false;\r\n        p.numberOfVotes = 0;\r\n        p.proposalType = ProposalType.ChangeIntegrityFee;\r\n        p.newFee = _newFee;\r\n        ProposalAdded(proposalID);\r\n        numProposals = proposalID+1;\r\n\r\n        return proposalID;\r\n    }\r\n\r\n    function newTransferProposal(\r\n        address _newDao,\r\n        string _jobDescription\r\n    )\r\n        public onlyShareholders\r\n        returns (uint proposalID)\r\n    {\r\n        proposalID = proposals.length++;\r\n        Proposal storage p = proposals[proposalID];\r\n        p.description = _jobDescription;\r\n        p.votingDeadline = block.timestamp + debatingPeriodInMinutes * 1 minutes;\r\n        p.executed = false;\r\n        p.proposalPassed = false;\r\n        p.numberOfVotes = 0;\r\n        p.proposalType = ProposalType.TransferOwnership;\r\n        p.newDao = _newDao;\r\n        ProposalAdded(proposalID);\r\n        numProposals = proposalID+1;\r\n\r\n        return proposalID;\r\n    }\r\n\r\n    /**\r\n     * Log a vote for a proposal\r\n     *\r\n     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\r\n     *\r\n     * @param proposalNumber number of proposal\r\n     * @param supportsProposal either in favor or against it\r\n     */\r\n    function vote(\r\n        uint proposalNumber,\r\n        bool supportsProposal\r\n    )\r\n        public onlyShareholders\r\n        returns (uint voteID)\r\n    {\r\n        Proposal storage p = proposals[proposalNumber];\r\n        require(p.voted[msg.sender] != true);\r\n\r\n        voteID = p.votes.length++;\r\n        p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender});\r\n        p.voted[msg.sender] = true;\r\n        p.numberOfVotes = voteID + 1;\r\n        Voted(proposalNumber, supportsProposal, msg.sender);\r\n        return voteID;\r\n    }\r\n\r\n    /**\r\n     * Finish vote\r\n     *\r\n     * Count the votes proposal #`proposalNumber` and execute it if approved\r\n     *\r\n     * @param proposalNumber proposal number\r\n     */\r\n    function executeProposal(uint proposalNumber) public {\r\n        Proposal storage p = proposals[proposalNumber];\r\n\r\n        require(block.timestamp > p.votingDeadline && !p.executed);\r\n\r\n        // ...then tally the results\r\n        uint quorum = 0;\r\n        uint yea = 0;\r\n        uint nay = 0;\r\n\r\n        for (uint i = 0; i < p.votes.length; ++i) {\r\n            Vote storage v = p.votes[i];\r\n            uint voteWeight = egcToken.balanceOf(v.voter);\r\n            quorum += voteWeight;\r\n            if (v.inSupport) {\r\n                yea += voteWeight;\r\n            } else {\r\n                nay += voteWeight;\r\n            }\r\n        }\r\n\r\n        require(quorum >= minimumQuorum); // Check if a minimum quorum has been reached\r\n\r\n        if (yea > nay) {\r\n            // Proposal passed; execute the transaction\r\n\r\n            p.executed = true;\r\n\r\n            if (p.proposalType == ProposalType.ChangeOwnershipFee) {\r\n                changeOwnershipFee(p.newFee);\r\n            } else if (p.proposalType == ProposalType.ChangeIntegrityFee) {\r\n                changeIntegrityFee(p.newFee);\r\n            } else if (p.proposalType == ProposalType.TransferOwnership) {\r\n                transferOwnership(p.newDao);\r\n            }\r\n\r\n            p.proposalPassed = true;\r\n        } else {\r\n            // Proposal failed\r\n            p.proposalPassed = false;\r\n        }\r\n\r\n        // Fire Events\r\n        ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);\r\n    }\r\n\r\n    function startIncomeDistribution() public {\r\n        require(withdrawStart + 90 days < block.timestamp);\r\n\r\n        uint256 totalSupply = egcToken.totalSupply();\r\n        require(totalSupply > 0);\r\n\r\n        // At least 1 wei per XEG so dividend > 0\r\n        dividend = this.balance * 1e18 / totalSupply;\r\n        require(dividend >= minAmount);\r\n\r\n        withdrawStart = block.timestamp;\r\n    }\r\n\r\n    function tokenExchange(uint _amount) public {\r\n        require(egrToken.allowance(msg.sender, this) >= _amount);\r\n        require(egrToken.transferFrom(msg.sender, 0x0, _amount));\r\n        // 100 XEG (18 decimals) per EGR (3 decimals)\r\n        require(egcToken.issue(msg.sender, _amount * 1e17));\r\n    }\r\n\r\n    function changeOwnershipFee(uint256 _newFee) private {\r\n        ownership.updateFee(_newFee);\r\n    }\r\n\r\n    function changeIntegrityFee(uint256 _newFee) private {\r\n        integrity.updateFee(_newFee);\r\n    }\r\n\r\n    function transferOwnership(address _newDao) private {\r\n        require(block.timestamp > withdrawStart + 1 weeks);\r\n\r\n        // Transfer all ether to the new DAO\r\n        DAO(_newDao).payFee.value(this.balance)();\r\n\r\n        // Transfer ownership of the owned contracts\r\n        ownership.transferOwnership(_newDao);\r\n        integrity.transferOwnership(_newDao);\r\n        egrToken.transferOwnership(_newDao);\r\n        egcToken.transferOwnership(_newDao);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"votingDeadline\",\"type\":\"uint256\"},{\"name\":\"executed\",\"type\":\"bool\"},{\"name\":\"proposalPassed\",\"type\":\"bool\"},{\"name\":\"numberOfVotes\",\"type\":\"uint256\"},{\"name\":\"proposalType\",\"type\":\"uint8\"},{\"name\":\"newFee\",\"type\":\"uint256\"},{\"name\":\"newDao\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"}],\"name\":\"executeProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint256\"},{\"name\":\"_jobDescription\",\"type\":\"string\"}],\"name\":\"newIntegrityFeeProposal\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payFee\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDao\",\"type\":\"address\"},{\"name\":\"_jobDescription\",\"type\":\"string\"}],\"name\":\"newTransferProposal\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"egcToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownership\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"debatingPeriodInMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"lockFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawFullTokenBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint256\"},{\"name\":\"_jobDescription\",\"type\":\"string\"}],\"name\":\"newOwnershipFeeProposal\",\"outputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"egrToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"tokenExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawTokenBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalNumber\",\"type\":\"uint256\"},{\"name\":\"supportsProposal\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[{\"name\":\"voteID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIncomeDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"integrity\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownershipAddress\",\"type\":\"address\"},{\"name\":\"_integrityAddress\",\"type\":\"address\"},{\"name\":\"_egrTokenAddress\",\"type\":\"address\"},{\"name\":\"_egcTokenAddress\",\"type\":\"address\"},{\"name\":\"_minimumQuorum\",\"type\":\"uint256\"},{\"name\":\"_debatingPeriodInMinutes\",\"type\":\"uint256\"},{\"name\":\"_minAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"position\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"ProposalTallied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newMinimumQuorum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDebatingPeriodInMinutes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newEgcToken\",\"type\":\"address\"}],\"name\":\"ChangeOfRules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"receivedEther\",\"type\":\"event\"}]","ContractName":"EngravedDAO","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000c5dac2da37676a33ba79fb3688c319eb3e5f6cc60000000000000000000000001a7a1cc695ebd484cb7d19c82c0df0e7bd278985000000000000000000000000044dd17bbbcbf1cf65f543918561bf8cf8130e7b00000000000000000000000085a7c57a4068280dd1166089a18acf35b4ba11e2000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000027600000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://1487b5363ce6e045dcbabccf78fbad4df17c1db6e06120c3dddc1b5f4fc6e8c0"}]}