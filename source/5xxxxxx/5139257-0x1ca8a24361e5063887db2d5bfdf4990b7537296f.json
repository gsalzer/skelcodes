{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath\r\n{\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20\r\n{\r\n    function totalSupply()public view returns (uint total_Supply);\r\n    function balanceOf(address who)public view returns (uint256);\r\n    function allowance(address owner, address spender)public view returns (uint);\r\n    function transferFrom(address from, address to, uint value)public returns (bool ok);\r\n    function approve(address spender, uint value)public returns (bool ok);\r\n    function transfer(address to, uint value)public returns (bool ok);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract FiatContract\r\n{\r\n    function USD(uint _id) external constant returns (uint256);\r\n}\r\n\r\ncontract SATCrowdsale\r\n{\r\n    using SafeMath for uint256;\r\n    \r\n    address public owner;\r\n    bool stopped = false;\r\n    uint256 public startdate;\r\n    uint256 ico_first;\r\n    uint256 ico_second;\r\n    uint256 ico_third;\r\n    uint256 ico_fourth;\r\n    \r\n    enum Stages\r\n    {\r\n        NOTSTARTED,\r\n        ICO,\r\n        PAUSED,\r\n        ENDED\r\n    }\r\n    \r\n    Stages public stage;\r\n    \r\n    FiatContract price = FiatContract(0x8055d0504666e2B6942BeB8D6014c964658Ca591);\r\n    ERC20 public constant tokenContract = ERC20(0xc56b13ebbCFfa67cFb7979b900b736b3fb480D78);\r\n    \r\n    modifier atStage(Stages _stage)\r\n    {\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function SATCrowdsale() public\r\n    {\r\n        owner = msg.sender;\r\n        stage = Stages.NOTSTARTED;\r\n    }\r\n    \r\n    function () external payable atStage(Stages.ICO)\r\n    {\r\n        require(msg.value >= 1 finney); //for round up and security measures\r\n        require(!stopped && msg.sender != owner);\r\n        \r\n        uint256 ethCent = price.USD(0); //one USD cent in wei\r\n        uint256 tokPrice = ethCent.mul(9); // 1Sat = 9 USD cent\r\n        \r\n        tokPrice = tokPrice.div(10 ** 8); //limit to 10 places\r\n        uint256 no_of_tokens = msg.value.div(tokPrice);\r\n        \r\n        uint256 bonus_token = 0;\r\n        \r\n        // Determine the bonus based on the time and the purchased amount\r\n        if (now < ico_first)\r\n        {\r\n            if (no_of_tokens >=  2000 * (uint256(10)**8) &&\r\n                no_of_tokens <= 19999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(50).div(100); // 50% bonus\r\n            }\r\n            else if (no_of_tokens >   19999 * (uint256(10)**8) &&\r\n                     no_of_tokens <= 149999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(55).div(100); // 55% bonus\r\n            }\r\n            else if (no_of_tokens > 149999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(60).div(100); // 60% bonus\r\n            }\r\n            else\r\n            {\r\n                bonus_token = no_of_tokens.mul(45).div(100); // 45% bonus\r\n            }\r\n        }\r\n        else if (now >= ico_first && now < ico_second)\r\n        {\r\n            if (no_of_tokens >=  2000 * (uint256(10)**8) &&\r\n                no_of_tokens <= 19999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(40).div(100); // 40% bonus\r\n            }\r\n            else if (no_of_tokens >   19999 * (uint256(10)**8) &&\r\n                     no_of_tokens <= 149999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(45).div(100); // 45% bonus\r\n            }\r\n            else if (no_of_tokens >  149999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(50).div(100); // 50% bonus\r\n            }\r\n            else\r\n            {\r\n                bonus_token = no_of_tokens.mul(35).div(100); // 35% bonus\r\n            }\r\n        }\r\n        else if (now >= ico_second && now < ico_third)\r\n        {\r\n            if (no_of_tokens >=  2000 * (uint256(10)**8) &&\r\n                no_of_tokens <= 19999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(30).div(100); // 30% bonus\r\n            }\r\n            else if (no_of_tokens >   19999 * (uint256(10)**8) &&\r\n                     no_of_tokens <= 149999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(35).div(100); // 35% bonus\r\n            }\r\n            else if (no_of_tokens >  149999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(40).div(100); // 40% bonus\r\n            }\r\n            else\r\n            {\r\n                bonus_token = no_of_tokens.mul(25).div(100); // 25% bonus\r\n            }\r\n        }\r\n        else if (now >= ico_third && now < ico_fourth)\r\n        {\r\n            if (no_of_tokens >=  2000 * (uint256(10)**8) &&\r\n                no_of_tokens <= 19999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(20).div(100); // 20% bonus\r\n            }\r\n            else if (no_of_tokens >   19999 * (uint256(10)**8) &&\r\n                     no_of_tokens <= 149999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(25).div(100); // 25% bonus\r\n            }\r\n            else if (no_of_tokens >  149999 * (uint256(10)**8))\r\n            {\r\n                bonus_token = no_of_tokens.mul(30).div(100); // 30% bonus\r\n            }\r\n            else\r\n            {\r\n                bonus_token = no_of_tokens.mul(15).div(100); // 15% bonus\r\n            }\r\n        }\r\n        \r\n        uint256 total_token = no_of_tokens + bonus_token;\r\n        tokenContract.transfer(msg.sender, total_token);\r\n    }\r\n    \r\n    function startICO(uint256 _startDate) public onlyOwner atStage(Stages.NOTSTARTED)\r\n    {\r\n        stage = Stages.ICO;\r\n        stopped = false;\r\n        startdate = _startDate;\r\n        ico_first = _startDate + 14 days;\r\n        ico_second = ico_first + 14 days;\r\n        ico_third = ico_second + 14 days;\r\n        ico_fourth = ico_third + 14 days;\r\n    }\r\n    \r\n    function pauseICO() external onlyOwner atStage(Stages.ICO)\r\n    {\r\n        stopped = true;\r\n        stage = Stages.PAUSED;\r\n    }\r\n    \r\n    function resumeICO() external onlyOwner atStage(Stages.PAUSED)\r\n    {\r\n        stopped = false;\r\n        stage = Stages.ICO;\r\n    }\r\n    \r\n    function endICO() external onlyOwner atStage(Stages.ICO)\r\n    {\r\n        require(now > ico_fourth);\r\n        stage = Stages.ENDED;\r\n        tokenContract.transfer(0x1, tokenContract.balanceOf(address(this)));\r\n    }\r\n    \r\n    function transferAllUnsoldTokens(address _destination) external onlyOwner \r\n    {\r\n        require(_destination != 0x0);\r\n        tokenContract.transfer(_destination, tokenContract.balanceOf(address(this)));\r\n    }\r\n    \r\n    function transferPartOfUnsoldTokens(address _destination, uint256 _amount) external onlyOwner\r\n    {\r\n        require(_destination != 0x0);\r\n        tokenContract.transfer(_destination, _amount);\r\n    }\r\n    \r\n    function transferOwnership(address _newOwner) external onlyOwner\r\n    {\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    function drain() external onlyOwner\r\n    {\r\n        owner.transfer(this.balance);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"pauseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startDate\",\"type\":\"uint256\"}],\"name\":\"startICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"transferAllUnsoldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferPartOfUnsoldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"SATCrowdsale","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bf554707ee7c688186bb27eaa763b7320dce5850f4aa7b60272528335c0f863b"}]}