{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n/// @title ServiceAllowance.\r\n///\r\n/// Provides a way to delegate operation allowance decision to a service contract\r\ncontract ServiceAllowance {\r\n    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\r\n}\r\n\r\n/// @title DepositWalletInterface\r\n///\r\n/// Defines an interface for a wallet that can be deposited/withdrawn by 3rd contract\r\ncontract DepositWalletInterface {\r\n    function deposit(address _asset, address _from, uint256 amount) public returns (uint);\r\n    function withdraw(address _asset, address _to, uint256 amount) public returns (uint);\r\n}\r\n\r\n/**\r\n * @title Owned contract with safe ownership pass.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public contractOwner;\r\n\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public pendingContractOwner;\r\n\r\n    function Owned() {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner check modifier\r\n    */\r\n    modifier onlyContractOwner() {\r\n        if (contractOwner == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can call it\r\n     */\r\n    function destroy() onlyContractOwner {\r\n        suicide(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Prepares ownership pass.\r\n     *\r\n     * Can only be called by current owner.\r\n     *\r\n     * @param _to address of the next owner. 0x0 is not allowed.\r\n     *\r\n     * @return success.\r\n     */\r\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\r\n        if (_to  == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Finalize ownership pass.\r\n     *\r\n     * Can only be called by pending owner.\r\n     *\r\n     * @return success.\r\n     */\r\n    function claimContractOwnership() returns(bool) {\r\n        if (pendingContractOwner != msg.sender) {\r\n            return false;\r\n        }\r\n\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\r\n\r\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\r\n        for(uint i=0;i<tokens.length;i++) {\r\n            address token = tokens[i];\r\n            uint balance = ERC20Interface(token).balanceOf(this);\r\n            if(balance != 0)\r\n                ERC20Interface(token).transfer(_to,balance);\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function checkOnlyContractOwner() internal constant returns(uint) {\r\n        if (contractOwner == msg.sender) {\r\n            return OK;\r\n        }\r\n\r\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\r\n    }\r\n}\r\n\r\ncontract OracleContractAdapter is Object {\r\n\r\n    event OracleAdded(address _oracle);\r\n    event OracleRemoved(address _oracle);\r\n\r\n    mapping(address => bool) public oracles;\r\n\r\n    /// @dev Allow access only for oracle\r\n    modifier onlyOracle {\r\n        if (oracles[msg.sender]) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyOracleOrOwner {\r\n        if (oracles[msg.sender] || msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /// @notice Add oracles to whitelist.\r\n    ///\r\n    /// @param _whitelist user list.\r\n    function addOracles(address[] _whitelist) external onlyContractOwner returns (uint)    {\r\n        for (uint _idx = 0; _idx < _whitelist.length; ++_idx) {\r\n            address _oracle = _whitelist[_idx];\r\n            if (!oracles[_oracle]) {\r\n                oracles[_oracle] = true;\r\n                _emitOracleAdded(_oracle);\r\n            }\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Removes oracles from whitelist.\r\n    ///\r\n    /// @param _blacklist user in whitelist.\r\n    function removeOracles(address[] _blacklist) external onlyContractOwner returns (uint)    {\r\n        for (uint _idx = 0; _idx < _blacklist.length; ++_idx) {\r\n            address _oracle = _blacklist[_idx];\r\n            if (oracles[_oracle]) {\r\n                delete oracles[_oracle];\r\n                _emitOracleRemoved(_oracle);\r\n            }\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function _emitOracleAdded(address _oracle) internal {\r\n        OracleAdded(_oracle);\r\n    }\r\n\r\n    function _emitOracleRemoved(address _oracle) internal {\r\n        OracleRemoved(_oracle);\r\n    }\r\n}\r\n\r\ncontract ProfiteroleEmitter {\r\n\r\n    event DepositPendingAdded(uint amount, address from, uint timestamp);\r\n    event BonusesWithdrawn(bytes32 userKey, uint amount, uint timestamp);\r\n\r\n    event Error(uint errorCode);\r\n\r\n    function _emitError(uint _errorCode) internal returns (uint) {\r\n        Error(_errorCode);\r\n        return _errorCode;\r\n    }\r\n}\r\n\r\ncontract TreasuryEmitter {\r\n    event TreasuryDeposited(bytes32 userKey, uint value, uint lockupDate);\r\n    event TreasuryWithdrawn(bytes32 userKey, uint value);\r\n}\r\n\r\ncontract ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Treasury contract.\r\n///\r\n/// Treasury for CCs deposits for particular fund with bmc-days calculations.\r\n/// Accept BMC deposits from Continuous Contributors via oracle and\r\n/// calculates bmc-days metric for each CC's role.\r\ncontract Treasury is OracleContractAdapter, ServiceAllowance, TreasuryEmitter {\r\n\r\n    /* ERROR CODES */\r\n\r\n    uint constant PERCENT_PRECISION = 10000;\r\n\r\n    uint constant TREASURY_ERROR_SCOPE = 108000;\r\n    uint constant TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE = TREASURY_ERROR_SCOPE + 1;\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct LockedDeposits {\r\n        uint counter;\r\n        mapping(uint => uint) index2Date;\r\n        mapping(uint => uint) date2deposit;\r\n    }\r\n\r\n    struct Period {\r\n        uint transfersCount;\r\n        uint totalBmcDays;\r\n        uint bmcDaysPerDay;\r\n        uint startDate;\r\n        mapping(bytes32 => uint) user2bmcDays;\r\n        mapping(bytes32 => uint) user2lastTransferIdx;\r\n        mapping(bytes32 => uint) user2balance;\r\n        mapping(uint => uint) transfer2date;\r\n    }\r\n\r\n    /* FIELDS */\r\n\r\n    address token;\r\n    address profiterole;\r\n    uint periodsCount;\r\n\r\n    mapping(uint => Period) periods;\r\n    mapping(uint => uint) periodDate2periodIdx;\r\n    mapping(bytes32 => uint) user2lastPeriodParticipated;\r\n    mapping(bytes32 => LockedDeposits) user2lockedDeposits;\r\n\r\n    /* MODIFIERS */\r\n\r\n    /// @dev Only profiterole contract allowed to invoke guarded functions\r\n    modifier onlyProfiterole {\r\n        require(profiterole == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /* PUBLIC */\r\n    \r\n    function Treasury(address _token) public {\r\n        require(address(_token) != 0x0);\r\n        token = _token;\r\n        periodsCount = 1;\r\n    }\r\n\r\n    function init(address _profiterole) public onlyContractOwner returns (uint) {\r\n        require(_profiterole != 0x0);\r\n        profiterole = _profiterole;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Do not accept Ether transfers\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    /* EXTERNAL */\r\n\r\n    /// @notice Deposits tokens on behalf of users\r\n    /// Allowed only for oracle.\r\n    ///\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @param _value amount of tokens to deposit\r\n    /// @param _feeAmount amount of tokens that will be taken from _value as fee\r\n    /// @param _feeAddress destination address for fee transfer\r\n    /// @param _lockupDate lock up date for deposit. Until that date the deposited value couldn't be withdrawn\r\n    ///\r\n    /// @return result code of an operation\r\n    function deposit(bytes32 _userKey, uint _value, uint _feeAmount, address _feeAddress, uint _lockupDate) external onlyOracle returns (uint) {\r\n        require(_userKey != bytes32(0));\r\n        require(_value != 0);\r\n        require(_feeAmount < _value);\r\n\r\n        ERC20 _token = ERC20(token);\r\n        if (_token.allowance(msg.sender, address(this)) < _value) {\r\n            return TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE;\r\n        }\r\n\r\n        uint _depositedAmount = _value - _feeAmount;\r\n        _makeDepositForPeriod(_userKey, _depositedAmount, _lockupDate);\r\n\r\n        uint _periodsCount = periodsCount;\r\n        user2lastPeriodParticipated[_userKey] = _periodsCount;\r\n        delete periods[_periodsCount].startDate;\r\n\r\n        if (!_token.transferFrom(msg.sender, address(this), _value)) {\r\n            revert();\r\n        }\r\n\r\n        if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {\r\n            revert();\r\n        }\r\n\r\n        TreasuryDeposited(_userKey, _depositedAmount, _lockupDate);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Withdraws deposited tokens on behalf of users\r\n    /// Allowed only for oracle\r\n    ///\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @param _value an amount of tokens that is requrested to withdraw\r\n    /// @param _withdrawAddress address to withdraw; should not be 0x0\r\n    /// @param _feeAmount amount of tokens that will be taken from _value as fee\r\n    /// @param _feeAddress destination address for fee transfer\r\n    ///\r\n    /// @return result of an operation\r\n    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOracle returns (uint) {\r\n        require(_userKey != bytes32(0));\r\n        require(_value != 0);\r\n        require(_feeAmount < _value);\r\n\r\n        _makeWithdrawForPeriod(_userKey, _value);\r\n        uint _periodsCount = periodsCount;\r\n        user2lastPeriodParticipated[_userKey] = periodsCount;\r\n        delete periods[_periodsCount].startDate;\r\n\r\n        ERC20 _token = ERC20(token);\r\n        if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {\r\n            revert();\r\n        }\r\n\r\n        uint _withdrawnAmount = _value - _feeAmount;\r\n        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {\r\n            revert();\r\n        }\r\n\r\n        TreasuryWithdrawn(_userKey, _withdrawnAmount);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Gets shares (in percents) the user has on provided date\r\n    ///\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @param _date date where period ends\r\n    ///\r\n    /// @return percent from total amount of bmc-days the treasury has on this date.\r\n    /// Use PERCENT_PRECISION to get right precision\r\n    function getSharesPercentForPeriod(bytes32 _userKey, uint _date) public view returns (uint) {\r\n        uint _periodIdx = periodDate2periodIdx[_date];\r\n        if (_date != 0 && _periodIdx == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (_date == 0) {\r\n            _date = now;\r\n            _periodIdx = periodsCount;\r\n        }\r\n\r\n        uint _bmcDays = _getBmcDaysAmountForUser(_userKey, _date, _periodIdx);\r\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(_date, _periodIdx);\r\n        return _totalBmcDeposit != 0 ? _bmcDays * PERCENT_PRECISION / _totalBmcDeposit : 0;\r\n    }\r\n\r\n    /// @notice Gets user balance that is deposited\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @return an amount of tokens deposited on behalf of user\r\n    function getUserBalance(bytes32 _userKey) public view returns (uint) {\r\n        uint _lastPeriodForUser = user2lastPeriodParticipated[_userKey];\r\n        if (_lastPeriodForUser == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (_lastPeriodForUser <= periodsCount.sub(1)) {\r\n            return periods[_lastPeriodForUser].user2balance[_userKey];\r\n        }\r\n\r\n        return periods[periodsCount].user2balance[_userKey];\r\n    }\r\n\r\n    /// @notice Gets amount of locked deposits for user\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @return an amount of tokens locked\r\n    function getLockedUserBalance(bytes32 _userKey) public returns (uint) {\r\n        return _syncLockedDepositsAmount(_userKey);\r\n    }\r\n\r\n    /// @notice Gets list of locked up deposits with dates when they will be available to withdraw\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @return {\r\n    ///     \"_lockupDates\": \"list of lockup dates of deposits\",\r\n    ///     \"_deposits\": \"list of deposits\"\r\n    /// }\r\n    function getLockedUserDeposits(bytes32 _userKey) public view returns (uint[] _lockupDates, uint[] _deposits) {\r\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\r\n        uint _lockedDepositsCounter = _lockedDeposits.counter;\r\n        _lockupDates = new uint[](_lockedDepositsCounter);\r\n        _deposits = new uint[](_lockedDepositsCounter);\r\n\r\n        uint _pointer = 0;\r\n        for (uint _idx = 1; _idx < _lockedDepositsCounter; ++_idx) {\r\n            uint _lockDate = _lockedDeposits.index2Date[_idx];\r\n\r\n            if (_lockDate > now) {\r\n                _lockupDates[_pointer] = _lockDate;\r\n                _deposits[_pointer] = _lockedDeposits.date2deposit[_lockDate];\r\n                ++_pointer;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Gets total amount of bmc-day accumulated due provided date\r\n    /// @param _date date where period ends\r\n    /// @return an amount of bmc-days\r\n    function getTotalBmcDaysAmount(uint _date) public view returns (uint) {\r\n        return _getTotalBmcDaysAmount(_date, periodsCount);\r\n    }\r\n\r\n    /// @notice Makes a checkpoint to start counting a new period\r\n    /// @dev Should be used only by Profiterole contract\r\n    function addDistributionPeriod() public onlyProfiterole returns (uint) {\r\n        uint _periodsCount = periodsCount;\r\n        uint _nextPeriod = _periodsCount.add(1);\r\n        periodDate2periodIdx[now] = _periodsCount;\r\n\r\n        Period storage _previousPeriod = periods[_periodsCount];\r\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(now, _periodsCount);\r\n        periods[_nextPeriod].startDate = now;\r\n        periods[_nextPeriod].bmcDaysPerDay = _previousPeriod.bmcDaysPerDay;\r\n        periods[_nextPeriod].totalBmcDays = _totalBmcDeposit;\r\n        periodsCount = _nextPeriod;\r\n\r\n        return OK;\r\n    }\r\n\r\n    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /* INTERNAL */\r\n\r\n    function _makeDepositForPeriod(bytes32 _userKey, uint _value, uint _lockupDate) internal {\r\n        Period storage _transferPeriod = periods[periodsCount];\r\n\r\n        _transferPeriod.user2bmcDays[_userKey] = _getBmcDaysAmountForUser(_userKey, now, periodsCount);\r\n        _transferPeriod.totalBmcDays = _getTotalBmcDaysAmount(now, periodsCount);\r\n        _transferPeriod.bmcDaysPerDay = _transferPeriod.bmcDaysPerDay.add(_value);\r\n\r\n        uint _userBalance = getUserBalance(_userKey);\r\n        uint _updatedTransfersCount = _transferPeriod.transfersCount.add(1);\r\n        _transferPeriod.transfersCount = _updatedTransfersCount;\r\n        _transferPeriod.transfer2date[_transferPeriod.transfersCount] = now;\r\n        _transferPeriod.user2balance[_userKey] = _userBalance.add(_value);\r\n        _transferPeriod.user2lastTransferIdx[_userKey] = _updatedTransfersCount;\r\n\r\n        _registerLockedDeposits(_userKey, _value, _lockupDate);\r\n    }\r\n\r\n    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {\r\n        uint _userBalance = getUserBalance(_userKey);\r\n        uint _lockedBalance = _syncLockedDepositsAmount(_userKey);\r\n        require(_userBalance.sub(_lockedBalance) >= _value);\r\n\r\n        uint _periodsCount = periodsCount;\r\n        Period storage _transferPeriod = periods[_periodsCount];\r\n\r\n        _transferPeriod.user2bmcDays[_userKey] = _getBmcDaysAmountForUser(_userKey, now, _periodsCount);\r\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(now, _periodsCount);\r\n        _transferPeriod.totalBmcDays = _totalBmcDeposit;\r\n        _transferPeriod.bmcDaysPerDay = _transferPeriod.bmcDaysPerDay.sub(_value);\r\n\r\n        uint _updatedTransferCount = _transferPeriod.transfersCount.add(1);\r\n        _transferPeriod.transfer2date[_updatedTransferCount] = now;\r\n        _transferPeriod.user2lastTransferIdx[_userKey] = _updatedTransferCount;\r\n        _transferPeriod.user2balance[_userKey] = _userBalance.sub(_value);\r\n        _transferPeriod.transfersCount = _updatedTransferCount;\r\n    }\r\n\r\n    function _registerLockedDeposits(bytes32 _userKey, uint _amount, uint _lockupDate) internal {\r\n        if (_lockupDate <= now) {\r\n            return;\r\n        }\r\n\r\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\r\n        uint _lockedBalance = _lockedDeposits.date2deposit[_lockupDate];\r\n\r\n        if (_lockedBalance == 0) {\r\n            uint _lockedDepositsCounter = _lockedDeposits.counter.add(1);\r\n            _lockedDeposits.counter = _lockedDepositsCounter;\r\n            _lockedDeposits.index2Date[_lockedDepositsCounter] = _lockupDate;\r\n        }\r\n        _lockedDeposits.date2deposit[_lockupDate] = _lockedBalance.add(_amount);\r\n    }\r\n\r\n    function _syncLockedDepositsAmount(bytes32 _userKey) internal returns (uint _lockedSum) {\r\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\r\n        uint _lockedDepositsCounter = _lockedDeposits.counter;\r\n\r\n        for (uint _idx = 1; _idx <= _lockedDepositsCounter; ++_idx) {\r\n            uint _lockDate = _lockedDeposits.index2Date[_idx];\r\n\r\n            if (_lockDate <= now) {\r\n                _lockedDeposits.index2Date[_idx] = _lockedDeposits.index2Date[_lockedDepositsCounter];\r\n\r\n                delete _lockedDeposits.index2Date[_lockedDepositsCounter];\r\n                delete _lockedDeposits.date2deposit[_lockDate];\r\n\r\n                _lockedDepositsCounter = _lockedDepositsCounter.sub(1);\r\n                continue;\r\n            }\r\n\r\n            _lockedSum = _lockedSum.add(_lockedDeposits.date2deposit[_lockDate]);\r\n        }\r\n\r\n        _lockedDeposits.counter = _lockedDepositsCounter;\r\n    }\r\n\r\n    function _getBmcDaysAmountForUser(bytes32 _userKey, uint _date, uint _periodIdx) internal view returns (uint) {\r\n        uint _lastPeriodForUserIdx = user2lastPeriodParticipated[_userKey];\r\n        if (_lastPeriodForUserIdx == 0) {\r\n            return 0;\r\n        }\r\n\r\n        Period storage _transferPeriod = _lastPeriodForUserIdx <= _periodIdx ? periods[_lastPeriodForUserIdx] : periods[_periodIdx];\r\n        uint _lastTransferDate = _transferPeriod.transfer2date[_transferPeriod.user2lastTransferIdx[_userKey]];\r\n        // NOTE: It is an intended substraction separation to correctly round dates\r\n        uint _daysLong = (_date / 1 days) - (_lastTransferDate / 1 days);\r\n        uint _bmcDays = _transferPeriod.user2bmcDays[_userKey];\r\n        return _bmcDays.add(_transferPeriod.user2balance[_userKey] * _daysLong);\r\n    }\r\n\r\n    /* PRIVATE */\r\n\r\n    function _getTotalBmcDaysAmount(uint _date, uint _periodIdx) private view returns (uint) {\r\n        Period storage _depositPeriod = periods[_periodIdx];\r\n        uint _transfersCount = _depositPeriod.transfersCount;\r\n        uint _lastRecordedDate = _transfersCount != 0 ? _depositPeriod.transfer2date[_transfersCount] : _depositPeriod.startDate;\r\n\r\n        if (_lastRecordedDate == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // NOTE: It is an intended substraction separation to correctly round dates\r\n        uint _daysLong = (_date / 1 days).sub((_lastRecordedDate / 1 days));\r\n        uint _totalBmcDeposit = _depositPeriod.totalBmcDays.add(_depositPeriod.bmcDaysPerDay.mul(_daysLong));\r\n        return _totalBmcDeposit;\r\n    }\r\n}\r\n\r\n/// @title Profiterole contract\r\n/// Collector and distributor for creation and redemption fees.\r\n/// Accepts bonus tokens from EmissionProvider, BurningMan or other distribution source.\r\n/// Calculates CCs shares in bonuses. Uses Treasury Contract as source of shares in bmc-days.\r\n/// Allows to withdraw bonuses on request.\r\ncontract Profiterole is OracleContractAdapter, ServiceAllowance, ProfiteroleEmitter {\r\n\r\n    uint constant PERCENT_PRECISION = 10000;\r\n\r\n    uint constant PROFITEROLE_ERROR_SCOPE = 102000;\r\n    uint constant PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE = PROFITEROLE_ERROR_SCOPE + 1;\r\n    uint constant PROFITEROLE_ERROR_INSUFFICIENT_BONUS_BALANCE = PROFITEROLE_ERROR_SCOPE + 2;\r\n    uint constant PROFITEROLE_ERROR_TRANSFER_ERROR = PROFITEROLE_ERROR_SCOPE + 3;\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Balance {\r\n        uint left;\r\n        bool initialized;\r\n    }\r\n\r\n    struct Deposit {\r\n        uint balance;\r\n        uint left;\r\n        uint nextDepositDate;\r\n        mapping(bytes32 => Balance) leftToWithdraw;\r\n    }\r\n\r\n    struct UserBalance {\r\n        uint lastWithdrawDate;\r\n    }\r\n\r\n    mapping(address => bool) distributionSourcesList;\r\n    mapping(bytes32 => UserBalance) bonusBalances;\r\n    mapping(uint => Deposit) public distributionDeposits;\r\n\r\n    uint public firstDepositDate;\r\n    uint public lastDepositDate;\r\n\r\n    address public bonusToken;\r\n    address public treasury;\r\n    address public wallet;\r\n\r\n    /// @dev Guards functions only for distributionSource invocations\r\n    modifier onlyDistributionSource {\r\n        if (!distributionSourcesList[msg.sender]) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function Profiterole(address _bonusToken, address _treasury, address _wallet) public {\r\n        require(_bonusToken != 0x0);\r\n        require(_treasury != 0x0);\r\n        require(_wallet != 0x0);\r\n\r\n        bonusToken = _bonusToken;\r\n        treasury = _treasury;\r\n        wallet = _wallet;\r\n    }\r\n\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    /* EXTERNAL */\r\n\r\n    /// @notice Sets new treasury address\r\n    /// Only for contract owner.\r\n    function updateTreasury(address _treasury) external onlyContractOwner returns (uint) {\r\n        require(_treasury != 0x0);\r\n        treasury = _treasury;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Sets new wallet address for profiterole\r\n    /// Only for contract owner.\r\n    function updateWallet(address _wallet) external onlyContractOwner returns (uint) {\r\n        require(_wallet != 0x0);\r\n        wallet = _wallet;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Add distribution sources to whitelist.\r\n    ///\r\n    /// @param _whitelist addresses list.\r\n    function addDistributionSources(address[] _whitelist) external onlyContractOwner returns (uint) {\r\n        for (uint _idx = 0; _idx < _whitelist.length; ++_idx) {\r\n            distributionSourcesList[_whitelist[_idx]] = true;\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Removes distribution sources from whitelist.\r\n    /// Only for contract owner.\r\n    ///\r\n    /// @param _blacklist addresses in whitelist.\r\n    function removeDistributionSources(address[] _blacklist) external onlyContractOwner returns (uint) {\r\n        for (uint _idx = 0; _idx < _blacklist.length; ++_idx) {\r\n            delete distributionSourcesList[_blacklist[_idx]];\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Allows to withdraw user's bonuses that he deserves due to Treasury shares for\r\n    /// every distribution period.\r\n    /// Only oracles allowed to invoke this function.\r\n    ///\r\n    /// @param _userKey aggregated user key (user ID + role ID) on behalf of whom bonuses will be withdrawn\r\n    /// @param _value an amount of tokens to withdraw\r\n    /// @param _withdrawAddress destination address of withdrawal (usually user's address)\r\n    /// @param _feeAmount an amount of fee that will be taken from resulted _value\r\n    /// @param _feeAddress destination address of fee transfer\r\n    ///\r\n    /// @return result code of an operation\r\n    function withdrawBonuses(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOracle returns (uint) {\r\n        require(_userKey != bytes32(0));\r\n        require(_value != 0);\r\n        require(_feeAmount < _value);\r\n        require(_withdrawAddress != 0x0);\r\n\r\n        DepositWalletInterface _wallet = DepositWalletInterface(wallet);\r\n        ERC20Interface _bonusToken = ERC20Interface(bonusToken);\r\n        if (_bonusToken.balanceOf(_wallet) < _value) {\r\n            return _emitError(PROFITEROLE_ERROR_INSUFFICIENT_BONUS_BALANCE);\r\n        }\r\n\r\n        if (OK != _withdrawBonuses(_userKey, _value)) {\r\n            revert();\r\n        }\r\n\r\n        if (!(_feeAddress == 0x0 || _feeAmount == 0 || OK == _wallet.withdraw(_bonusToken, _feeAddress, _feeAmount))) {\r\n            revert();\r\n        }\r\n\r\n        if (OK != _wallet.withdraw(_bonusToken, _withdrawAddress, _value - _feeAmount)) {\r\n            revert();\r\n        }\r\n\r\n        BonusesWithdrawn(_userKey, _value, now);\r\n        return OK;\r\n    }\r\n\r\n    /* PUBLIC */\r\n\r\n    /// @notice Gets total amount of bonuses user has during all distribution periods\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @return _sum available amount of bonuses to withdraw\r\n    function getTotalBonusesAmountAvailable(bytes32 _userKey) public view returns (uint _sum) {\r\n        uint _startDate = _getCalculationStartDate(_userKey);\r\n        Treasury _treasury = Treasury(treasury);\r\n\r\n        for (\r\n            uint _endDate = lastDepositDate;\r\n            _startDate <= _endDate && _startDate != 0;\r\n            _startDate = distributionDeposits[_startDate].nextDepositDate\r\n        ) {\r\n            Deposit storage _pendingDeposit = distributionDeposits[_startDate];\r\n            Balance storage _userBalance = _pendingDeposit.leftToWithdraw[_userKey];\r\n\r\n            if (_userBalance.initialized) {\r\n                _sum = _sum.add(_userBalance.left);\r\n            } else {\r\n                uint _sharesPercent = _treasury.getSharesPercentForPeriod(_userKey, _startDate);\r\n                _sum = _sum.add(_pendingDeposit.balance.mul(_sharesPercent).div(PERCENT_PRECISION));\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Gets an amount of bonuses user has for concrete distribution date\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @param _distributionDate date of distribution operation\r\n    /// @return available amount of bonuses to withdraw for selected distribution date\r\n    function getBonusesAmountAvailable(bytes32 _userKey, uint _distributionDate) public view returns (uint) {\r\n        Deposit storage _deposit = distributionDeposits[_distributionDate];\r\n        if (_deposit.leftToWithdraw[_userKey].initialized) {\r\n            return _deposit.leftToWithdraw[_userKey].left;\r\n        }\r\n\r\n        uint _sharesPercent = Treasury(treasury).getSharesPercentForPeriod(_userKey, _distributionDate);\r\n        return _deposit.balance.mul(_sharesPercent).div(PERCENT_PRECISION);\r\n    }\r\n\r\n    /// @notice Gets total amount of deposits that has left after users' bonus withdrawals\r\n    /// @return amount of deposits available for bonus payments\r\n    function getTotalDepositsAmountLeft() public view returns (uint _amount) {\r\n        uint _lastDepositDate = lastDepositDate;\r\n        for (\r\n            uint _startDate = firstDepositDate;\r\n            _startDate <= _lastDepositDate || _startDate != 0;\r\n            _startDate = distributionDeposits[_startDate].nextDepositDate\r\n        ) {\r\n            _amount = _amount.add(distributionDeposits[_startDate].left);\r\n        }\r\n    }\r\n\r\n    /// @notice Gets an amount of deposits that has left after users' bonus withdrawals for selected date\r\n    /// @param _distributionDate date of distribution operation\r\n    /// @return amount of deposits available for bonus payments for concrete distribution date\r\n    function getDepositsAmountLeft(uint _distributionDate) public view returns (uint _amount) {\r\n        return distributionDeposits[_distributionDate].left;\r\n    }\r\n\r\n    /// @notice Makes checkmark and deposits tokens on profiterole account\r\n    /// to pay them later as bonuses for Treasury shares holders. Timestamp of transaction\r\n    /// counts as the distribution period date.\r\n    /// Only addresses that were added as a distributionSource are allowed to call this function.\r\n    ///\r\n    /// @param _amount an amount of tokens to distribute\r\n    ///\r\n    /// @return result code of an operation.\r\n    /// PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE, PROFITEROLE_ERROR_TRANSFER_ERROR errors\r\n    /// are possible\r\n    function distributeBonuses(uint _amount) public onlyDistributionSource returns (uint) {\r\n\r\n        ERC20Interface _bonusToken = ERC20Interface(bonusToken);\r\n\r\n        if (_bonusToken.allowance(msg.sender, address(this)) < _amount) {\r\n            return _emitError(PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE);\r\n        }\r\n\r\n        if (!_bonusToken.transferFrom(msg.sender, wallet, _amount)) {\r\n            return _emitError(PROFITEROLE_ERROR_TRANSFER_ERROR);\r\n        }\r\n\r\n        if (firstDepositDate == 0) {\r\n            firstDepositDate = now;\r\n        }\r\n\r\n        uint _lastDepositDate = lastDepositDate;\r\n        if (_lastDepositDate != 0) {\r\n            distributionDeposits[_lastDepositDate].nextDepositDate = now;\r\n        }\r\n\r\n        lastDepositDate = now;\r\n        distributionDeposits[now] = Deposit(_amount, _amount, 0);\r\n\r\n        Treasury(treasury).addDistributionPeriod();\r\n\r\n        DepositPendingAdded(_amount, msg.sender, now);\r\n        return OK;\r\n    }\r\n\r\n    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /* PRIVATE */\r\n\r\n    function _getCalculationStartDate(bytes32 _userKey) private view returns (uint _startDate) {\r\n        _startDate = bonusBalances[_userKey].lastWithdrawDate;\r\n        return _startDate != 0 ? _startDate : firstDepositDate;\r\n    }\r\n\r\n    function _withdrawBonuses(bytes32 _userKey, uint _value) private returns (uint) {\r\n        uint _startDate = _getCalculationStartDate(_userKey);\r\n        uint _lastWithdrawDate = _startDate;\r\n        Treasury _treasury = Treasury(treasury);\r\n\r\n        for (\r\n            uint _endDate = lastDepositDate;\r\n            _startDate <= _endDate && _startDate != 0 && _value > 0;\r\n            _startDate = distributionDeposits[_startDate].nextDepositDate\r\n        ) {\r\n            uint _balanceToWithdraw = _withdrawBonusesFromDeposit(_userKey, _startDate, _value, _treasury);\r\n            _value = _value.sub(_balanceToWithdraw);\r\n        }\r\n\r\n        if (_lastWithdrawDate != _startDate) {\r\n            bonusBalances[_userKey].lastWithdrawDate = _lastWithdrawDate;\r\n        }\r\n\r\n        if (_value > 0) {\r\n            revert();\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    function _withdrawBonusesFromDeposit(bytes32 _userKey, uint _periodDate, uint _value, Treasury _treasury) private returns (uint) {\r\n        Deposit storage _pendingDeposit = distributionDeposits[_periodDate];\r\n        Balance storage _userBalance = _pendingDeposit.leftToWithdraw[_userKey];\r\n\r\n        uint _balanceToWithdraw;\r\n        if (_userBalance.initialized) {\r\n            _balanceToWithdraw = _userBalance.left;\r\n        } else {\r\n            uint _sharesPercent = _treasury.getSharesPercentForPeriod(_userKey, _periodDate);\r\n            _balanceToWithdraw = _pendingDeposit.balance.mul(_sharesPercent).div(PERCENT_PRECISION);\r\n            _userBalance.initialized = true;\r\n        }\r\n\r\n        if (_balanceToWithdraw > _value) {\r\n            _userBalance.left = _balanceToWithdraw - _value;\r\n            _balanceToWithdraw = _value;\r\n        } else {\r\n            delete _userBalance.left;\r\n        }\r\n\r\n        _pendingDeposit.left = _pendingDeposit.left.sub(_balanceToWithdraw);\r\n        return _balanceToWithdraw;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastDepositDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"},{\"name\":\"_distributionDate\",\"type\":\"uint256\"}],\"name\":\"getBonusesAmountAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distributeBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address[]\"}],\"name\":\"addOracles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"distributionDeposits\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"left\",\"type\":\"uint256\"},{\"name\":\"nextDepositDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blacklist\",\"type\":\"address[]\"}],\"name\":\"removeOracles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"}],\"name\":\"getTotalBonusesAmountAvailable\",\"outputs\":[{\"name\":\"_sum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_distributionDate\",\"type\":\"uint256\"}],\"name\":\"getDepositsAmountLeft\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstDepositDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blacklist\",\"type\":\"address[]\"}],\"name\":\"removeDistributionSources\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"updateTreasury\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"updateWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_withdrawAddress\",\"type\":\"address\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"withdrawBonuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracles\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address[]\"}],\"name\":\"addDistributionSources\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalDepositsAmountLeft\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bonusToken\",\"type\":\"address\"},{\"name\":\"_treasury\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DepositPendingAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"userKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BonusesWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"OracleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"OracleRemoved\",\"type\":\"event\"}]","ContractName":"Profiterole","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000df6ef343350780bf8c3410bf062e0c015b1dd671000000000000000000000000b72ed33e7e42ebaf0fdd7df92b246bcb2a0ed2920000000000000000000000002c69d65ad4156710b84bd4395a9c3cb5e04eb9ef","Library":"","SwarmSource":"bzzr://32d05498a202ac3523df82387a08b322b8b6d306d9624b7ce599ebdc1d60b453"}]}