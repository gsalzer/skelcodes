{"status":"1","message":"OK","result":[{"SourceCode":"//v1.0.14\r\n//License: Apache2.0\r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract TokenSpender {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n * last open zepplin version used for : add sub mul div function : https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n* commit : https://github.com/OpenZeppelin/zeppelin-solidity/commit/815d9e1f457f57cfbb1b4e889f2255c9a517f661\r\n */\r\nlibrary SafeMathOZ\r\n{\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\tif (a == 0)\r\n\t\t{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn a >= b ? a : b;\r\n\t}\r\n\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn a < b ? a : b;\r\n\t}\r\n\r\n\tfunction mulByFraction(uint256 a, uint256 b, uint256 c) internal pure returns (uint256)\r\n\t{\r\n\t\treturn div(mul(a, b), c);\r\n\t}\r\n\r\n\tfunction percentage(uint256 a, uint256 b) internal pure returns (uint256)\r\n\t{\r\n\t\treturn mulByFraction(a, b, 100);\r\n\t}\r\n\t// Source : https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\r\n\tfunction log(uint x) internal pure returns (uint y)\r\n\t{\r\n\t\tassembly\r\n\t\t{\r\n\t\t\tlet arg := x\r\n\t\t\tx := sub(x,1)\r\n\t\t\tx := or(x, div(x, 0x02))\r\n\t\t\tx := or(x, div(x, 0x04))\r\n\t\t\tx := or(x, div(x, 0x10))\r\n\t\t\tx := or(x, div(x, 0x100))\r\n\t\t\tx := or(x, div(x, 0x10000))\r\n\t\t\tx := or(x, div(x, 0x100000000))\r\n\t\t\tx := or(x, div(x, 0x10000000000000000))\r\n\t\t\tx := or(x, div(x, 0x100000000000000000000000000000000))\r\n\t\t\tx := add(x, 1)\r\n\t\t\tlet m := mload(0x40)\r\n\t\t\tmstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\r\n\t\t\tmstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\r\n\t\t\tmstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\r\n\t\t\tmstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\r\n\t\t\tmstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\r\n\t\t\tmstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\r\n\t\t\tmstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\r\n\t\t\tmstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\r\n\t\t\tmstore(0x40, add(m, 0x100))\r\n\t\t\tlet magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\r\n\t\t\tlet shift := 0x100000000000000000000000000000000000000000000000000000000000000\r\n\t\t\tlet a := div(mul(x, magic), shift)\r\n\t\t\ty := div(mload(add(m,sub(255,a))), shift)\r\n\t\t\ty := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\npragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract OwnableOZ\r\n{\r\n\taddress public m_owner;\r\n\tbool    public m_changeable;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner()\r\n\t{\r\n\t\trequire(msg.sender == m_owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tfunction OwnableOZ() public\r\n\t{\r\n\t\tm_owner      = msg.sender;\r\n\t\tm_changeable = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param _newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction setImmutableOwnership(address _newOwner) public onlyOwner\r\n\t{\r\n\t\trequire(m_changeable);\r\n\t\trequire(_newOwner != address(0));\r\n\t\temit OwnershipTransferred(m_owner, _newOwner);\r\n\t\tm_owner      = _newOwner;\r\n\t\tm_changeable = false;\r\n\t}\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.8;\r\n\r\ncontract RLC is ERC20, SafeMath, Ownable {\r\n\r\n    /* Public variables of the token */\r\n  string public name;       //fancy name\r\n  string public symbol;\r\n  uint8 public decimals;    //How many decimals to show.\r\n  string public version = 'v0.1';\r\n  uint public initialSupply;\r\n  uint public totalSupply;\r\n  bool public locked;\r\n  //uint public unlockBlock;\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  // lock transfer during the ICO\r\n  modifier onlyUnlocked() {\r\n    if (msg.sender != owner && locked) throw;\r\n    _;\r\n  }\r\n\r\n  /*\r\n   *  The RLC Token created with the time at which the crowdsale end\r\n   */\r\n\r\n  function RLC() {\r\n    // lock the transfer function during the crowdsale\r\n    locked = true;\r\n    //unlockBlock=  now + 45 days; // (testnet) - for mainnet put the block number\r\n\r\n    initialSupply = 87000000000000000;\r\n    totalSupply = initialSupply;\r\n    balances[msg.sender] = initialSupply;// Give the creator all initial tokens\r\n    name = 'iEx.ec Network Token';        // Set the name for display purposes\r\n    symbol = 'RLC';                       // Set the symbol for display purposes\r\n    decimals = 9;                        // Amount of decimals for display purposes\r\n  }\r\n\r\n  function unlock() onlyOwner {\r\n    locked = false;\r\n  }\r\n\r\n  function burn(uint256 _value) returns (bool){\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\r\n    totalSupply = safeSub(totalSupply, _value);\r\n    Transfer(msg.sender, 0x0, _value);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyUnlocked returns (bool) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n    /* Approve and then comunicate the approved contract in a single tx */\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData){\r\n      TokenSpender spender = TokenSpender(_spender);\r\n      if (approve(_spender, _value)) {\r\n          spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n      }\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract IexecHubInterface\r\n{\r\n\tRLC public rlc;\r\n\r\n\tfunction attachContracts(\r\n\t\taddress _tokenAddress,\r\n\t\taddress _marketplaceAddress,\r\n\t\taddress _workerPoolHubAddress,\r\n\t\taddress _appHubAddress,\r\n\t\taddress _datasetHubAddress)\r\n\t\tpublic;\r\n\r\n\tfunction setCategoriesCreator(\r\n\t\taddress _categoriesCreator)\r\n\tpublic;\r\n\r\n\tfunction createCategory(\r\n\t\tstring  _name,\r\n\t\tstring  _description,\r\n\t\tuint256 _workClockTimeRef)\r\n\tpublic returns (uint256 catid);\r\n\r\n\tfunction createWorkerPool(\r\n\t\tstring  _description,\r\n\t\tuint256 _subscriptionLockStakePolicy,\r\n\t\tuint256 _subscriptionMinimumStakePolicy,\r\n\t\tuint256 _subscriptionMinimumScorePolicy)\r\n\texternal returns (address createdWorkerPool);\r\n\r\n\tfunction createApp(\r\n\t\tstring  _appName,\r\n\t\tuint256 _appPrice,\r\n\t\tstring  _appParams)\r\n\texternal returns (address createdApp);\r\n\r\n\tfunction createDataset(\r\n\t\tstring  _datasetName,\r\n\t\tuint256 _datasetPrice,\r\n\t\tstring  _datasetParams)\r\n\texternal returns (address createdDataset);\r\n\r\n\tfunction buyForWorkOrder(\r\n\t\tuint256 _marketorderIdx,\r\n\t\taddress _workerpool,\r\n\t\taddress _app,\r\n\t\taddress _dataset,\r\n\t\tstring  _params,\r\n\t\taddress _callback,\r\n\t\taddress _beneficiary)\r\n\texternal returns (address);\r\n\r\n\tfunction isWoidRegistred(\r\n\t\taddress _woid)\r\n\tpublic view returns (bool);\r\n\r\n\tfunction lockWorkOrderCost(\r\n\t\taddress _requester,\r\n\t\taddress _workerpool, // Address of a smartcontract\r\n\t\taddress _app,        // Address of a smartcontract\r\n\t\taddress _dataset)    // Address of a smartcontract\r\n\tinternal returns (uint256);\r\n\r\n\tfunction claimFailedConsensus(\r\n\t\taddress _woid)\r\n\tpublic returns (bool);\r\n\r\n\tfunction finalizeWorkOrder(\r\n\t\taddress _woid,\r\n\t\tstring  _stdout,\r\n\t\tstring  _stderr,\r\n\t\tstring  _uri)\r\n\tpublic returns (bool);\r\n\r\n\tfunction getCategoryWorkClockTimeRef(\r\n\t\tuint256 _catId)\r\n\tpublic view returns (uint256 workClockTimeRef);\r\n\r\n\tfunction existingCategory(\r\n\t\tuint256 _catId)\r\n\tpublic view  returns (bool categoryExist);\r\n\r\n\tfunction getCategory(\r\n\t\tuint256 _catId)\r\n\t\tpublic view returns (uint256 catid, string name, string  description, uint256 workClockTimeRef);\r\n\r\n\tfunction getWorkerStatus(\r\n\t\taddress _worker)\r\n\tpublic view returns (address workerPool, uint256 workerScore);\r\n\r\n\tfunction getWorkerScore(address _worker) public view returns (uint256 workerScore);\r\n\r\n\tfunction registerToPool(address _worker) public returns (bool subscribed);\r\n\r\n\tfunction unregisterFromPool(address _worker) public returns (bool unsubscribed);\r\n\r\n\tfunction evictWorker(address _worker) public returns (bool unsubscribed);\r\n\r\n\tfunction removeWorker(address _workerpool, address _worker) internal returns (bool unsubscribed);\r\n\r\n\tfunction lockForOrder(address _user, uint256 _amount) public returns (bool);\r\n\r\n\tfunction unlockForOrder(address _user, uint256 _amount) public returns (bool);\r\n\r\n\tfunction lockForWork(address _woid, address _user, uint256 _amount) public returns (bool);\r\n\r\n\tfunction unlockForWork(address _woid, address _user, uint256 _amount) public returns (bool);\r\n\r\n\tfunction rewardForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public returns (bool);\r\n\r\n\tfunction seizeForWork(address _woid, address _worker, uint256 _amount, bool _reputation) public returns (bool);\r\n\r\n\tfunction deposit(uint256 _amount) external returns (bool);\r\n\r\n\tfunction withdraw(uint256 _amount) external returns (bool);\r\n\r\n\tfunction checkBalance(address _owner) public view returns (uint256 stake, uint256 locked);\r\n\r\n\tfunction reward(address _user, uint256 _amount) internal returns (bool);\r\n\r\n\tfunction seize(address _user, uint256 _amount) internal returns (bool);\r\n\r\n\tfunction lock(address _user, uint256 _amount) internal returns (bool);\r\n\r\n\tfunction unlock(address _user, uint256 _amount) internal returns (bool);\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract IexecHubAccessor\r\n{\r\n\tIexecHubInterface internal iexecHubInterface;\r\n\r\n\tmodifier onlyIexecHub()\r\n\t{\r\n\t\trequire(msg.sender == address(iexecHubInterface));\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction IexecHubAccessor(address _iexecHubAddress) public\r\n\t{\r\n\t\trequire(_iexecHubAddress != address(0));\r\n\t\tiexecHubInterface = IexecHubInterface(_iexecHubAddress);\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract Dataset is OwnableOZ, IexecHubAccessor\r\n{\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tstring            public m_datasetName;\r\n\tuint256           public m_datasetPrice;\r\n\tstring            public m_datasetParams;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction Dataset(\r\n\t\taddress _iexecHubAddress,\r\n\t\tstring  _datasetName,\r\n\t\tuint256 _datasetPrice,\r\n\t\tstring  _datasetParams)\r\n\tIexecHubAccessor(_iexecHubAddress)\r\n\tpublic\r\n\t{\r\n\t\t// tx.origin == owner\r\n\t\t// msg.sender == DatasetHub\r\n\t\trequire(tx.origin != msg.sender);\r\n\t\tsetImmutableOwnership(tx.origin); // owner → tx.origin\r\n\r\n\t\tm_datasetName   = _datasetName;\r\n\t\tm_datasetPrice  = _datasetPrice;\r\n\t\tm_datasetParams = _datasetParams;\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\ncontract DatasetHub is OwnableOZ // is Owned by IexecHub\r\n{\r\n\tusing SafeMathOZ for uint256;\r\n\r\n\t/**\r\n\t * Members\r\n\t */\r\n\tmapping(address => uint256)                     m_datasetCountByOwner;\r\n\tmapping(address => mapping(uint256 => address)) m_datasetByOwnerByIndex;\r\n\tmapping(address => bool)                        m_datasetRegistered;\r\n\r\n\tmapping(uint256 => address)                     m_datasetByIndex;\r\n\tuint256 public                                  m_totalDatasetCount;\r\n\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tfunction DatasetHub() public\r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t * Methods\r\n\t */\r\n\tfunction isDatasetRegistred(address _dataset) public view returns (bool)\r\n\t{\r\n\t\treturn m_datasetRegistered[_dataset];\r\n\t}\r\n\tfunction getDatasetsCount(address _owner) public view returns (uint256)\r\n\t{\r\n\t\treturn m_datasetCountByOwner[_owner];\r\n\t}\r\n\tfunction getDataset(address _owner, uint256 _index) public view returns (address)\r\n\t{\r\n\t\treturn m_datasetByOwnerByIndex[_owner][_index];\r\n\t}\r\n\tfunction getDatasetByIndex(uint256 _index) public view returns (address)\r\n\t{\r\n\t\treturn m_datasetByIndex[_index];\r\n\t}\r\n\r\n\tfunction addDataset(address _owner, address _dataset) internal\r\n\t{\r\n\t\tuint id = m_datasetCountByOwner[_owner].add(1);\r\n\t\tm_totalDatasetCount = m_totalDatasetCount.add(1);\r\n\t\tm_datasetByIndex       [m_totalDatasetCount] = _dataset;\r\n\t\tm_datasetCountByOwner  [_owner]              = id;\r\n\t\tm_datasetByOwnerByIndex[_owner][id]          = _dataset;\r\n\t\tm_datasetRegistered    [_dataset]            = true;\r\n\t}\r\n\r\n\tfunction createDataset(\r\n\t\tstring _datasetName,\r\n\t\tuint256 _datasetPrice,\r\n\t\tstring _datasetParams)\r\n\tpublic onlyOwner /*owner == IexecHub*/ returns (address createdDataset)\r\n\t{\r\n\t\t// tx.origin == owner\r\n\t\t// msg.sender == IexecHub\r\n\t\taddress newDataset = new Dataset(\r\n\t\t\tmsg.sender,\r\n\t\t\t_datasetName,\r\n\t\t\t_datasetPrice,\r\n\t\t\t_datasetParams\r\n\t\t);\r\n\t\taddDataset(tx.origin, newDataset);\r\n\t\treturn newDataset;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_dataset\",\"type\":\"address\"}],\"name\":\"isDatasetRegistred\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getDatasetsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getDatasetByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getDataset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_datasetName\",\"type\":\"string\"},{\"name\":\"_datasetPrice\",\"type\":\"uint256\"},{\"name\":\"_datasetParams\",\"type\":\"string\"}],\"name\":\"createDataset\",\"outputs\":[{\"name\":\"createdDataset\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setImmutableOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_changeable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_totalDatasetCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DatasetHub","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c6b63c7fbf6b53812b0fa390d88c1f1cad0ed3058cd9658ae4a3300af6c84035"}]}