{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// File: contracts/ERC721Draft.sol\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\ncontract ERC721 {\r\n    function implementsERC721() public pure returns (bool);\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function transfer(address _to, uint256 _tokenId) public;\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\r\n    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\r\n}\r\n\r\n// File: contracts/FighterCoreInterface.sol\r\n\r\ncontract FighterCoreInterface is ERC721 {\r\n    function getFighter(uint256 _id)\r\n        public\r\n        view\r\n        returns (\r\n        uint256 prizeCooldownEndTime,\r\n        uint256 battleCooldownEndTime,\r\n        uint256 prizeCooldownIndex,\r\n        uint256 battlesFought,\r\n        uint256 battlesWon,\r\n        uint256 generation,\r\n        uint256 genes,\r\n        uint256 dexterity,\r\n        uint256 strength,\r\n        uint256 vitality,\r\n        uint256 luck,\r\n        uint256 experience\r\n    );\r\n    \r\n    function createPrizeFighter(\r\n        uint16 _generation,\r\n        uint256 _genes,\r\n        uint8 _dexterity,\r\n        uint8 _strength,\r\n        uint8 _vitality,\r\n        uint8 _luck,\r\n        address _owner\r\n    ) public;\r\n    \r\n    function updateFighter(\r\n        uint256 _fighterId,\r\n        uint8 _dexterity,\r\n        uint8 _strength,\r\n        uint8 _vitality,\r\n        uint8 _luck,\r\n        uint32 _experience,\r\n        uint64 _prizeCooldownEndTime,\r\n        uint16 _prizeCooldownIndex,\r\n        uint64 _battleCooldownEndTime,\r\n        uint16 _battlesFought,\r\n        uint16 _battlesWon\r\n    ) public;\r\n\r\n    function updateFighterBattleStats(\r\n        uint256 _fighterId,\r\n        uint64 _prizeCooldownEndTime,\r\n        uint16 _prizeCooldownIndex,\r\n        uint64 _battleCooldownEndTime,\r\n        uint16 _battlesFought,\r\n        uint16 _battlesWon\r\n    ) public;\r\n\r\n    function updateDexterity(uint256 _fighterId, uint8 _dexterity) public;\r\n    function updateStrength(uint256 _fighterId, uint8 _strength) public;\r\n    function updateVitality(uint256 _fighterId, uint8 _vitality) public;\r\n    function updateLuck(uint256 _fighterId, uint8 _luck) public;\r\n    function updateExperience(uint256 _fighterId, uint32 _experience) public;\r\n}\r\n\r\n// File: contracts/Battle/BattleDeciderInterface.sol\r\n\r\ncontract BattleDeciderInterface {\r\n    function isBattleDecider() public pure returns (bool);\r\n    function determineWinner(uint256[7][] teamAttacker, uint256[7][] teamDefender) public returns (\r\n        bool attackerWon,\r\n        uint256 xpForAttacker,\r\n        uint256 xpForDefender\r\n    );\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/Battle/GeneScienceInterface.sol\r\n\r\n/// @title defined the interface that will be referenced in main Fighter contract\r\ncontract GeneScienceInterface {\r\n    /// @dev simply a boolean to indicate this is the contract we expect to be\r\n    function isGeneScience() public pure returns (bool);\r\n\r\n    /// @dev given genes of fighter 1 & 2, return a genetic combination - may have a random factor\r\n    /// @param genes1 genes of fighter1\r\n    /// @param genes2 genes of fighter1\r\n    /// @return the genes that are supposed to be passed down the new fighter\r\n    function mixGenes(uint256 genes1, uint256 genes2) public returns (uint256);\r\n}\r\n\r\n// File: contracts/Battle/BattleBase.sol\r\n\r\ncontract BattleBase is Ownable, Pausable {\r\n    event TeamCreated(uint256 indexed teamId, uint256[] fighterIds);\r\n    event TeamDeleted(uint256 indexed teamId, uint256[] fighterIds);\r\n    event BattleResult(address indexed winnerAddress, address indexed loserAddress, uint256[] attackerFighterIds, uint256[] defenderFighterIds, bool attackerWon, uint16 prizeFighterGeneration, uint256 prizeFighterGenes, uint32 attackerXpGained, uint32 defenderXpGained);\r\n    \r\n    struct Team {\r\n        address owner;\r\n        uint256[] fighterIds;\r\n    }\r\n\r\n    struct RaceBaseStats {\r\n        uint8 strength;\r\n        uint8 dexterity;\r\n        uint8 vitality;\r\n    }\r\n    \r\n    Team[] public teams;\r\n    // index => base stats (where index represents the race)\r\n    RaceBaseStats[] public raceBaseStats;\r\n    \r\n    uint256 internal randomCounter = 0;\r\n    \r\n    FighterCoreInterface public fighterCore;\r\n    GeneScienceInterface public geneScience;\r\n    BattleDeciderInterface public battleDecider;\r\n    \r\n    mapping (uint256 => uint256) public fighterIndexToTeam;\r\n    mapping (uint256 => bool) public teamIndexToExist;\r\n    // an array of deleted teamIds owned by each address so that we can reuse these again\r\n    // mapping (address => uint256[]) public addressToDeletedTeams;\r\n    \r\n    // an array of deleted teams we can reuse later\r\n    uint256[] public deletedTeamIds;\r\n    \r\n    uint256 public maxPerTeam = 5;\r\n\r\n    uint8[] public genBaseStats = [\r\n        16, // gen 0\r\n        12, // gen 1\r\n        10, // gen 2\r\n        8, // gen 3\r\n        7, // gen 4\r\n        6, // gen 5\r\n        5, // gen 6\r\n        4, // gen 7\r\n        3, // gen 8\r\n        2, // gen 9\r\n        1 // gen 10+\r\n    ];\r\n    \r\n    // modifier ownsFighters(uint256[] _fighterIds) {\r\n    //     uint len = _fighterIds.length;\r\n    //     for (uint i = 0; i < len; i++) {\r\n    //       require(fighterCore.ownerOf(_fighterIds[i]) == msg.sender);\r\n    //     }\r\n    //     _;\r\n    // }\r\n    \r\n    modifier onlyTeamOwner(uint256 _teamId) {\r\n        require(teams[_teamId].owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyExistingTeam(uint256 _teamId) {\r\n        require(teamIndexToExist[_teamId] == true);\r\n        _;\r\n    }\r\n\r\n    function teamExists(uint256 _teamId) public view returns (bool) {\r\n        return teamIndexToExist[_teamId] == true;\r\n    }\r\n\r\n    /// @dev random number from 0 to (_modulus - 1)\r\n    function randMod(uint256 _randCounter, uint _modulus) internal view returns (uint256) { \r\n        return uint(keccak256(now, msg.sender, _randCounter)) % _modulus;\r\n    }\r\n\r\n    function getDeletedTeams() public view returns (uint256[]) {\r\n        // return addressToDeletedTeams[_address];\r\n        return deletedTeamIds;\r\n    }\r\n\r\n    function getRaceBaseStats(uint256 _id) public view returns (\r\n        uint256 strength,\r\n        uint256 dexterity,\r\n        uint256 vitality\r\n    ) {\r\n        RaceBaseStats storage race = raceBaseStats[_id];\r\n        \r\n        strength = race.strength;\r\n        dexterity = race.dexterity;\r\n        vitality = race.vitality;\r\n    }\r\n}\r\n\r\n// File: contracts/Battle/BattleAdmin.sol\r\n\r\ncontract BattleAdmin is BattleBase {\r\n    event ContractUpgrade(address newContract);\r\n\r\n    address public newContractAddress;\r\n    \r\n    // An approximation of currently how many seconds are in between blocks.\r\n    uint256 public secondsPerBlock = 15;\r\n\r\n    uint32[7] public prizeCooldowns = [\r\n        uint32(1 minutes),\r\n        uint32(30 minutes),\r\n        uint32(2 hours),\r\n        uint32(6 hours),\r\n        uint32(12 hours),\r\n        uint32(1 days),\r\n        uint32(3 days)\r\n    ];\r\n\r\n    function setFighterCoreAddress(address _address) public onlyOwner {\r\n        _setFighterCoreAddress(_address);\r\n    }\r\n\r\n    function _setFighterCoreAddress(address _address) internal {\r\n        FighterCoreInterface candidateContract = FighterCoreInterface(_address);\r\n\r\n        require(candidateContract.implementsERC721());\r\n\r\n        fighterCore = candidateContract;\r\n    }\r\n    \r\n    function setGeneScienceAddress(address _address) public onlyOwner {\r\n        _setGeneScienceAddress(_address);\r\n    }\r\n\r\n    function _setGeneScienceAddress(address _address) internal {\r\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\r\n\r\n        require(candidateContract.isGeneScience());\r\n\r\n        geneScience = candidateContract;\r\n    }\r\n\r\n    function setBattleDeciderAddress(address _address) public onlyOwner {\r\n        _setBattleDeciderAddress(_address);\r\n    }\r\n\r\n    function _setBattleDeciderAddress(address _address) internal {\r\n        BattleDeciderInterface deciderCandidateContract = BattleDeciderInterface(_address);\r\n\r\n        require(deciderCandidateContract.isBattleDecider());\r\n\r\n        battleDecider = deciderCandidateContract;\r\n    }\r\n\r\n    function addRace(uint8 _strength, uint8 _dexterity, uint8 _vitality) public onlyOwner {\r\n        raceBaseStats.push(RaceBaseStats({\r\n            strength: _strength,\r\n            dexterity: _dexterity,\r\n            vitality: _vitality\r\n        }));\r\n    }\r\n\r\n    // in case we ever add a bad race type\r\n    function removeLastRace() public onlyOwner {\r\n        // don't allow the first 4 races to be removed\r\n        require(raceBaseStats.length > 4);\r\n        \r\n        delete raceBaseStats[raceBaseStats.length - 1];\r\n    }\r\n\r\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\r\n    ///  breaking bug. This method does nothing but keep track of the new contract and\r\n    ///  emit a message indicating that the new address is set. It's up to clients of this\r\n    ///  contract to update to the new contract address in that case.\r\n    /// @param _v2Address new address\r\n    function setNewAddress(address _v2Address) public onlyOwner whenPaused {\r\n        newContractAddress = _v2Address;\r\n        \r\n        ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    // Owner can fix how many seconds per blocks are currently observed.\r\n    function setSecondsPerBlock(uint256 _secs) external onlyOwner {\r\n        require(_secs < prizeCooldowns[0]);\r\n        secondsPerBlock = _secs;\r\n    }\r\n}\r\n\r\n// File: contracts/Battle/BattlePrize.sol\r\n\r\ncontract BattlePrize is BattleAdmin {\r\n    // array index is level, value is experience to reach that level\r\n    uint32[50] public stats = [\r\n        0,\r\n        100,\r\n        300,\r\n        600,\r\n        1000,\r\n        1500,\r\n        2100,\r\n        2800,\r\n        3600,\r\n        4500,\r\n        5500,\r\n        6600,\r\n        7800,\r\n        9100,\r\n        10500,\r\n        12000,\r\n        13600,\r\n        15300,\r\n        17100,\r\n        19000,\r\n        21000,\r\n        23100,\r\n        25300,\r\n        27600,\r\n        30000,\r\n        32500,\r\n        35100,\r\n        37800,\r\n        40600,\r\n        43500,\r\n        46500,\r\n        49600,\r\n        52800,\r\n        56100,\r\n        59500,\r\n        63000,\r\n        66600,\r\n        70300,\r\n        74100,\r\n        78000,\r\n        82000,\r\n        86100,\r\n        90300,\r\n        94600,\r\n        99000,\r\n        103500,\r\n        108100,\r\n        112800,\r\n        117600,\r\n        122500\r\n    ];\r\n\r\n    uint8[11] public extraStatsForGen = [\r\n        16, // 0 - here for ease of use even though we never create gen0s\r\n        12, // 1\r\n        10, // 2\r\n        8, // 3\r\n        7, // 4\r\n        6, // 5\r\n        5, // 6\r\n        4, // 7\r\n        3, // 8\r\n        2, // 9\r\n        1 // 10+\r\n    ];\r\n\r\n    // the number of battles before a delay to gain new exp kicks in\r\n    uint8 public battlesTillBattleCooldown = 5;\r\n    // the number of battles before a delay to gain new exp kicks in\r\n    uint32 public experienceDelay = uint32(6 hours);\r\n\r\n    // Luck is determined as follows:\r\n    // Rank 0 (5 stars) - random between 4~5\r\n    // Rank 1-2 (4 stars) - random between 2~4\r\n    // Rank 3-8 (3 stars) - random between 2~3\r\n    // Rank 9-15 (2 stars) - random between 1~3\r\n    // Rank 16+ (1 star) - random between 1~2\r\n    function genToLuck(uint256 _gen, uint256 _rand) public pure returns (uint8) {\r\n        if (_gen >= 1 || _gen <= 2) {\r\n            return 2 + uint8(_rand) % 3; // 2 to 4\r\n        } else if (_gen >= 3 || _gen <= 8) {\r\n            return 2 + uint8(_rand) % 2; // 2 to 3\r\n        }  else if (_gen >= 9 || _gen <= 15) {\r\n            return 1 + uint8(_rand) % 3; // 1 to 3\r\n        } else { // 16+\r\n            return 1 + uint8(_rand) % 2; // 1 to 2\r\n        }\r\n    }\r\n\r\n    function raceToBaseStats(uint _race) public view returns (\r\n        uint8 strength,\r\n        uint8 dexterity,\r\n        uint8 vitality\r\n    ) {\r\n        // in case we ever have an unknown race due to new races added\r\n        if (_race >= raceBaseStats.length) {\r\n            _race = 0;\r\n        }\r\n\r\n        RaceBaseStats memory raceStats = raceBaseStats[_race];\r\n\r\n        strength = raceStats.strength;\r\n        dexterity = raceStats.dexterity;\r\n        vitality = raceStats.vitality;\r\n    }\r\n\r\n    function genToExtraStats(uint256 _gen, uint256 _rand) public view returns (\r\n        uint8 extraStrength,\r\n        uint8 extraDexterity,\r\n        uint8 extraVitality\r\n    ) {\r\n        // in case we ever have an unknown race due to new races added\r\n        if (_gen >= 10) {\r\n            _gen = 10;\r\n        }\r\n\r\n        uint8 extraStats = extraStatsForGen[_gen];\r\n\r\n        uint256 rand1 = _rand & 0xff;\r\n        uint256 rand2 = _rand >> 16 & 0xff;\r\n        uint256 rand3 = _rand >> 16 >> 16 & 0xff;\r\n\r\n        uint256 sum = rand1 + rand2 + rand3;\r\n\r\n        extraStrength = uint8((extraStats * rand1) / sum);\r\n        extraDexterity = uint8((extraStats * rand2) / sum);\r\n        extraVitality = uint8((extraStats * rand3) / sum);\r\n\r\n        uint8 remainder = extraStats - (extraStrength + extraDexterity + extraVitality);\r\n\r\n        if (rand1 > rand2 && rand1 > rand3) {\r\n            extraStrength += remainder;\r\n        } else if (rand2 > rand3) {\r\n            extraDexterity += remainder;\r\n        } else {\r\n            extraVitality += remainder;\r\n        }\r\n    }\r\n\r\n    function _getStrengthDexterityVitality(uint256 _race, uint256 _generation, uint256 _rand) public view returns (\r\n        uint256 strength,\r\n        uint256 dexterity,\r\n        uint256 vitality\r\n    ) {\r\n        uint8 baseStrength;\r\n        uint8 baseDexterity;\r\n        uint8 baseVitality;\r\n        uint8 extraStrength;\r\n        uint8 extraDexterity;\r\n        uint8 extraVitality;\r\n\r\n        (baseStrength, baseDexterity, baseVitality) = raceToBaseStats(_race);\r\n        (extraStrength, extraDexterity, extraVitality) = genToExtraStats(_generation, _rand);\r\n\r\n        strength = baseStrength + extraStrength;\r\n        dexterity = baseDexterity + extraDexterity;\r\n        vitality = baseVitality + extraVitality;\r\n    }\r\n\r\n    // we return an array here, because we had an issue of too many local variables when returning a tuple\r\n    // function _generateFighterStats(uint256 _attackerLeaderId, uint256 _defenderLeaderId) internal returns (uint256[6]) {\r\n    function _generateFighterStats(uint256 generation1, uint256 genes1, uint256 generation2, uint256 genes2) internal returns (uint256[6]) {\r\n        // uint256 generation1;\r\n        // uint256 genes1;\r\n        // uint256 generation2;\r\n        // uint256 genes2;\r\n\r\n        uint256 generation256 = ((generation1 + generation2) / 2) + 1;\r\n\r\n        // making sure a gen 65536 doesn't turn out as a gen 0 :)\r\n        if (generation256 > 65535)\r\n            generation256 = 65535;\r\n        \r\n        uint16 generation = uint16(generation256);\r\n\r\n        uint256 genes = geneScience.mixGenes(genes1, genes2);\r\n\r\n        uint256 strength;\r\n        uint256 dexterity;\r\n        uint256 vitality;\r\n\r\n        uint256 rand = uint(keccak256(now, msg.sender, randomCounter++));\r\n\r\n        (strength, dexterity, vitality) = _getStrengthDexterityVitality(_getRaceFromGenes(genes), generation, rand);\r\n\r\n        uint256 luck = genToLuck(genes, rand);\r\n\r\n        return [\r\n            generation,\r\n            genes,\r\n            strength,\r\n            dexterity,\r\n            vitality,\r\n            luck\r\n        ];\r\n    }\r\n\r\n    // takes in genes and returns raceId\r\n    // race is first loci after version. \r\n    // [][]...[][race][version] \r\n    // each loci = 2B, race is also 2B. father's gene is determining the fighter's race\r\n    function _getRaceFromGenes(uint256 _genes) internal pure returns (uint256) {\r\n        return (_genes >> (16)) & 0xff;\r\n    }\r\n\r\n    function experienceToLevel(uint256 _experience) public view returns (uint256) {\r\n        for (uint256 i = 0; i < stats.length; i++) {\r\n            if (stats[i] > _experience) {\r\n                // current level is i\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return 50;\r\n    }\r\n\r\n    // returns a number between 0 and 4 based on which stat to increase\r\n    // 0 - no stat increase\r\n    // 1 - dexterity\r\n    // 2 - strength\r\n    // 3 - vitality\r\n    // 4 - luck\r\n    function _calculateNewStat(uint32 _currentExperience, uint32 _newExperience) internal returns (uint256) {\r\n        // find current level\r\n        for (uint256 i = 0; i < stats.length; i++) {\r\n            if (stats[i] > _currentExperience) {\r\n                // current level is i\r\n                if (stats[i] <= _newExperience) {\r\n                    // level up a random stat\r\n                    return 1 + randMod(randomCounter++, 4);\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // at max level\r\n        return 0;\r\n    }\r\n\r\n    // function _getFighterGenAndGenes(uint256 _fighterId) internal view returns (\r\n    //     uint256 generation,\r\n    //     uint256 genes\r\n    // ) {\r\n    //     (,,,,, generation, genes,,,,,) = fighterCore.getFighter(_fighterId);\r\n    // }\r\n\r\n    function _getFighterStatsData(uint256 _fighterId) internal view returns (uint256[6]) {\r\n        uint256 dexterity;\r\n        uint256 strength;\r\n        uint256 vitality;\r\n        uint256 luck;\r\n        uint256 experience;\r\n        uint256 battleCooldownEndTime;\r\n        \r\n        (\r\n            ,\r\n            battleCooldownEndTime,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            dexterity,\r\n            strength,\r\n            vitality,\r\n            luck,\r\n            experience\r\n        ) = fighterCore.getFighter(_fighterId);\r\n\r\n        return [\r\n            dexterity,\r\n            strength,\r\n            vitality,\r\n            luck,\r\n            experience,\r\n            battleCooldownEndTime\r\n        ];\r\n    }\r\n\r\n    function _getFighterBattleData(uint256 _fighterId) internal view returns (uint256[7]) {\r\n        uint256 prizeCooldownEndTime;\r\n        uint256 prizeCooldownIndex;\r\n        uint256 battleCooldownEndTime;\r\n        uint256 battlesFought;\r\n        uint256 battlesWon;\r\n        uint256 generation;\r\n        uint256 genes;\r\n        \r\n        (\r\n            prizeCooldownEndTime,\r\n            battleCooldownEndTime,\r\n            prizeCooldownIndex,\r\n            battlesFought,\r\n            battlesWon,\r\n            generation,\r\n            genes,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n        ) = fighterCore.getFighter(_fighterId);\r\n\r\n        return [\r\n            prizeCooldownEndTime,\r\n            prizeCooldownIndex,\r\n            battleCooldownEndTime,\r\n            battlesFought,\r\n            battlesWon,\r\n            generation,\r\n            genes\r\n        ];\r\n    }\r\n\r\n    function _increaseFighterStats(\r\n        uint256 _fighterId,\r\n        uint32 _experienceGained,\r\n        uint[6] memory data\r\n    ) internal {\r\n        // dont update if on cooldown\r\n        if (data[5] >= block.number) {\r\n            return;\r\n        }\r\n\r\n        uint32 experience = uint32(data[4]);\r\n        uint32 newExperience = experience + _experienceGained;\r\n        uint256 _statIncrease = _calculateNewStat(experience, newExperience);\r\n        \r\n        fighterCore.updateExperience(_fighterId, newExperience);\r\n\r\n        if (_statIncrease == 1) {\r\n            fighterCore.updateDexterity(_fighterId, uint8(++data[0]));\r\n        } else if (_statIncrease == 2) {\r\n            fighterCore.updateStrength(_fighterId, uint8(++data[1]));\r\n        } else if (_statIncrease == 3) {\r\n            fighterCore.updateVitality(_fighterId, uint8(++data[2]));\r\n        } else if (_statIncrease == 4) {\r\n            fighterCore.updateLuck(_fighterId, uint8(++data[3]));\r\n        }\r\n    }\r\n\r\n    function _increaseTeamFighterStats(uint256[] memory _fighterIds, uint32 _experienceGained) private {\r\n        for (uint i = 0; i < _fighterIds.length; i++) {\r\n            _increaseFighterStats(_fighterIds[i], _experienceGained, _getFighterStatsData(_fighterIds[i]));\r\n        }\r\n    }\r\n\r\n    function _updateFighterBattleStats(\r\n        uint256 _fighterId,\r\n        bool _winner,\r\n        bool _leader,\r\n        uint[7] memory data,\r\n        bool _skipAwardPrize\r\n    ) internal {\r\n        uint64 prizeCooldownEndTime = uint64(data[0]);\r\n        uint16 prizeCooldownIndex = uint16(data[1]);\r\n        uint64 battleCooldownEndTime = uint64(data[2]);\r\n        uint16 updatedBattlesFought = uint16(data[3]) + 1;\r\n\r\n        // trigger prize cooldown\r\n        if (_winner && _leader && !_skipAwardPrize) {\r\n            prizeCooldownEndTime = uint64((prizeCooldowns[prizeCooldownIndex] / secondsPerBlock) + block.number);\r\n\r\n            if (prizeCooldownIndex < 6) {\r\n               prizeCooldownIndex += 1;\r\n            }\r\n        }\r\n\r\n        if (updatedBattlesFought % battlesTillBattleCooldown == 0) {\r\n            battleCooldownEndTime = uint64((experienceDelay / secondsPerBlock) + block.number);\r\n        }\r\n\r\n        fighterCore.updateFighterBattleStats(\r\n            _fighterId,\r\n            prizeCooldownEndTime,\r\n            prizeCooldownIndex,\r\n            battleCooldownEndTime,\r\n            updatedBattlesFought,\r\n            uint16(data[4]) + (_winner ? 1 : 0) // battlesWon\r\n        );\r\n    }\r\n\r\n    function _updateTeamBattleStats(uint256[] memory _fighterIds, bool _attackerWin, bool _skipAwardPrize) private {\r\n        for (uint i = 0; i < _fighterIds.length; i++) {\r\n            _updateFighterBattleStats(_fighterIds[i], _attackerWin, i == 0, _getFighterBattleData(_fighterIds[i]), _skipAwardPrize);\r\n        }\r\n    }\r\n\r\n    function _awardPrizeFighter(\r\n        address _winner, uint256[7] _attackerLeader, uint256[7] _defenderLeader\r\n    )\r\n        internal\r\n        returns (uint16 prizeGen, uint256 prizeGenes)\r\n    {\r\n        uint256[6] memory newFighterData = _generateFighterStats(_attackerLeader[5], _attackerLeader[6], _defenderLeader[5], _defenderLeader[6]);\r\n\r\n        prizeGen = uint16(newFighterData[0]);\r\n        prizeGenes = newFighterData[1];\r\n\r\n        fighterCore.createPrizeFighter(\r\n            prizeGen,\r\n            prizeGenes,\r\n            uint8(newFighterData[2]),\r\n            uint8(newFighterData[3]),\r\n            uint8(newFighterData[4]),\r\n            uint8(newFighterData[5]),\r\n            _winner\r\n        );\r\n    }\r\n\r\n    function _updateFightersAndAwardPrizes(\r\n        uint256[] _attackerFighterIds,\r\n        uint256[] _defenderFighterIds,\r\n        bool _attackerWin,\r\n        address _winnerAddress,\r\n        uint32 _attackerExperienceGained,\r\n        uint32 _defenderExperienceGained\r\n    )\r\n        internal\r\n        returns (uint16 prizeGen, uint256 prizeGenes)\r\n    {\r\n        // grab prize cooldown info before it gets updated\r\n        uint256[7] memory attackerLeader = _getFighterBattleData(_attackerFighterIds[0]);\r\n        uint256[7] memory defenderLeader = _getFighterBattleData(_defenderFighterIds[0]);\r\n\r\n        bool skipAwardPrize = (_attackerWin && attackerLeader[0] >= block.number) || (!_attackerWin && defenderLeader[0] >= block.number);\r\n        \r\n        _increaseTeamFighterStats(_attackerFighterIds, _attackerExperienceGained);\r\n        _increaseTeamFighterStats(_defenderFighterIds, _defenderExperienceGained);\r\n        \r\n        _updateTeamBattleStats(_attackerFighterIds, _attackerWin, skipAwardPrize);\r\n        _updateTeamBattleStats(_defenderFighterIds, !_attackerWin, skipAwardPrize);\r\n        \r\n        // prizes\r\n\r\n        // dont award prize if on cooldown\r\n        if (skipAwardPrize) {\r\n            return;\r\n        }\r\n\r\n        return _awardPrizeFighter(_winnerAddress, attackerLeader, defenderLeader);\r\n    }\r\n}\r\n\r\n// File: contracts/Battle/BattleCore.sol\r\n\r\ncontract BattleCore is BattlePrize {\r\n    function BattleCore(address _coreAddress, address _geneScienceAddress, address _battleDeciderAddress) public {\r\n        addRace(4, 4, 4); // half elf\r\n        addRace(6, 2, 4); // orc\r\n        addRace(4, 5, 3); // succubbus\r\n        addRace(6, 4, 2); // mage\r\n        addRace(7, 1, 4);\r\n\r\n        _setFighterCoreAddress(_coreAddress);\r\n        _setGeneScienceAddress(_geneScienceAddress);\r\n        _setBattleDeciderAddress(_battleDeciderAddress);\r\n        \r\n        // no team 0\r\n        uint256[] memory fighterIds = new uint256[](1);\r\n        fighterIds[0] = uint256(0);\r\n        _createTeam(address(0), fighterIds);\r\n        teamIndexToExist[0] = false;\r\n    }\r\n\r\n    /// @dev DON'T give me your money.\r\n    function() external {}\r\n    \r\n    function totalTeams() public view returns (uint256) {\r\n        // team 0 doesn't exist\r\n        return teams.length - 1;\r\n    }\r\n    \r\n    function isValidTeam(uint256[] _fighterIds) public view returns (bool) {\r\n        for (uint i = 0; i < _fighterIds.length; i++) {\r\n            uint256 fighterId = _fighterIds[i];\r\n            if (fighterCore.ownerOf(fighterId) != msg.sender)\r\n                return false;\r\n            if (fighterIndexToTeam[fighterId] > 0)\r\n                return false;\r\n\r\n            // check for duplicate fighters\r\n            for (uint j = i + 1; j < _fighterIds.length; j++) {\r\n                if (_fighterIds[i] == _fighterIds[j]) {\r\n                    return false;            \r\n                }\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function createTeam(uint256[] _fighterIds)\r\n        public\r\n        whenNotPaused\r\n        returns(uint256)\r\n    {\r\n        require(_fighterIds.length > 0 && _fighterIds.length <= maxPerTeam);\r\n        \r\n        require(isValidTeam(_fighterIds));\r\n\r\n        return _createTeam(msg.sender, _fighterIds);\r\n    }\r\n    \r\n    function _createTeam(address _owner, uint256[] _fighterIds) internal returns(uint256) {\r\n        Team memory _team = Team({\r\n            owner: _owner,\r\n            fighterIds: _fighterIds\r\n        });\r\n\r\n        uint256 newTeamId;\r\n\r\n        // reuse teamId if address has deleted teams\r\n        if (deletedTeamIds.length > 0) {\r\n            newTeamId = deletedTeamIds[deletedTeamIds.length - 1];\r\n            delete deletedTeamIds[deletedTeamIds.length - 1];\r\n            deletedTeamIds.length--;\r\n            teams[newTeamId] = _team;\r\n        } else {\r\n            newTeamId = teams.push(_team) - 1;\r\n        }\r\n\r\n        require(newTeamId <= 4294967295);\r\n\r\n        for (uint i = 0; i < _fighterIds.length; i++) {\r\n            uint256 fighterId = _fighterIds[i];\r\n\r\n            fighterIndexToTeam[fighterId] = newTeamId;\r\n        }\r\n\r\n        teamIndexToExist[newTeamId] = true;\r\n\r\n        TeamCreated(newTeamId, _fighterIds);\r\n\r\n        return newTeamId;\r\n    }\r\n\r\n    function deleteTeam(uint256 _teamId)\r\n        public\r\n        whenNotPaused\r\n        onlyTeamOwner(_teamId)\r\n        onlyExistingTeam(_teamId)\r\n    {\r\n        _deleteTeam(_teamId);\r\n    }\r\n\r\n    function _deleteTeam(uint256 _teamId) private {\r\n        Team memory team = teams[_teamId];\r\n\r\n        for (uint256 i = 0; i < team.fighterIds.length; i++) {\r\n            fighterIndexToTeam[team.fighterIds[i]] = 0;\r\n        }\r\n\r\n        TeamDeleted(_teamId, team.fighterIds);\r\n\r\n        delete teams[_teamId];\r\n\r\n        deletedTeamIds.push(_teamId);\r\n        \r\n        teamIndexToExist[_teamId] = false;\r\n    }\r\n\r\n    function battle(uint256[] _attackerFighterIds, uint256 _defenderTeamId)\r\n        public\r\n        whenNotPaused\r\n        onlyExistingTeam(_defenderTeamId)\r\n        returns (bool)\r\n    {\r\n        require(_attackerFighterIds.length > 0 && _attackerFighterIds.length <= maxPerTeam);\r\n        require(isValidTeam(_attackerFighterIds));\r\n\r\n        Team memory defenderTeam = teams[_defenderTeamId];\r\n\r\n        // check that a user isn't attacking himself\r\n        require(msg.sender != defenderTeam.owner);\r\n\r\n        uint256[] memory defenderFighterIds = defenderTeam.fighterIds;\r\n        \r\n        bool attackerWon;\r\n        uint256 xpForAttacker;\r\n        uint256 xpForDefender;\r\n\r\n        _deleteTeam(_defenderTeamId);\r\n\r\n        (\r\n            attackerWon,\r\n            xpForAttacker,\r\n            xpForDefender\r\n        ) = battleDecider.determineWinner(getFighterArray(_attackerFighterIds), getFighterArray(defenderFighterIds));\r\n        \r\n        address winnerAddress;\r\n        address loserAddress;\r\n\r\n        if (attackerWon) {\r\n            winnerAddress = msg.sender;\r\n            loserAddress = defenderTeam.owner;\r\n        } else {\r\n            winnerAddress = defenderTeam.owner;\r\n            loserAddress = msg.sender;\r\n        }\r\n        \r\n        uint16 prizeGen;\r\n        uint256 prizeGenes;\r\n        (prizeGen, prizeGenes) = _updateFightersAndAwardPrizes(_attackerFighterIds, defenderFighterIds, attackerWon, winnerAddress, uint32(xpForAttacker), uint32(xpForDefender));\r\n        \r\n        BattleResult(winnerAddress, loserAddress, _attackerFighterIds, defenderFighterIds, attackerWon, prizeGen, prizeGenes, uint32(xpForAttacker), uint32(xpForDefender));\r\n\r\n        return attackerWon;\r\n    }\r\n        \r\n    /// @param _id The ID of the team of interest.\r\n    function getTeam(uint256 _id)\r\n        public\r\n        view\r\n        returns (\r\n        address owner,\r\n        uint256[] fighterIds\r\n    ) {\r\n        Team storage _team = teams[_id];\r\n\r\n        owner = _team.owner;\r\n        fighterIds = _team.fighterIds;\r\n    }\r\n\r\n    function getFighterArray(uint256[] _fighterIds) public view returns (uint256[7][]) {\r\n        uint256[7][] memory res = new uint256[7][](_fighterIds.length);\r\n\r\n        for (uint i = 0; i < _fighterIds.length; i++) {\r\n            uint256 generation;\r\n            uint256 genes;\r\n            uint256 dexterity;\r\n            uint256 strength;\r\n            uint256 vitality;\r\n            uint256 luck;\r\n            uint256 experience;\r\n            \r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                generation,\r\n                genes,\r\n                dexterity,\r\n                strength,\r\n                vitality,\r\n                luck,\r\n                experience\r\n            ) = fighterCore.getFighter(_fighterIds[i]);\r\n\r\n            uint256 level = experienceToLevel(experience);\r\n\r\n            res[i] = [\r\n                level,\r\n                generation,\r\n                strength,\r\n                dexterity,\r\n                vitality,\r\n                luck,\r\n                genes\r\n            ];\r\n        }\r\n\r\n        return res;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getTeam\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"fighterIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_race\",\"type\":\"uint256\"},{\"name\":\"_generation\",\"type\":\"uint256\"},{\"name\":\"_rand\",\"type\":\"uint256\"}],\"name\":\"_getStrengthDexterityVitality\",\"outputs\":[{\"name\":\"strength\",\"type\":\"uint256\"},{\"name\":\"dexterity\",\"type\":\"uint256\"},{\"name\":\"vitality\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fighterIndexToTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGeneScienceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gen\",\"type\":\"uint256\"},{\"name\":\"_rand\",\"type\":\"uint256\"}],\"name\":\"genToExtraStats\",\"outputs\":[{\"name\":\"extraStrength\",\"type\":\"uint8\"},{\"name\":\"extraDexterity\",\"type\":\"uint8\"},{\"name\":\"extraVitality\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fighterIds\",\"type\":\"uint256[]\"}],\"name\":\"getFighterArray\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[7][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"battlesTillBattleCooldown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prizeCooldowns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_experience\",\"type\":\"uint256\"}],\"name\":\"experienceToLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teams\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raceBaseStats\",\"outputs\":[{\"name\":\"strength\",\"type\":\"uint8\"},{\"name\":\"dexterity\",\"type\":\"uint8\"},{\"name\":\"vitality\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_race\",\"type\":\"uint256\"}],\"name\":\"raceToBaseStats\",\"outputs\":[{\"name\":\"strength\",\"type\":\"uint8\"},{\"name\":\"dexterity\",\"type\":\"uint8\"},{\"name\":\"vitality\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamIndexToExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secs\",\"type\":\"uint256\"}],\"name\":\"setSecondsPerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fighterCore\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTeams\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsPerBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeLastRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_strength\",\"type\":\"uint8\"},{\"name\":\"_dexterity\",\"type\":\"uint8\"},{\"name\":\"_vitality\",\"type\":\"uint8\"}],\"name\":\"addRace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extraStatsForGen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"battleDecider\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPerTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_attackerFighterIds\",\"type\":\"uint256[]\"},{\"name\":\"_defenderTeamId\",\"type\":\"uint256\"}],\"name\":\"battle\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint256\"}],\"name\":\"teamExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deletedTeamIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"genBaseStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setBattleDeciderAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"experienceDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeletedTeams\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setFighterCoreAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gen\",\"type\":\"uint256\"},{\"name\":\"_rand\",\"type\":\"uint256\"}],\"name\":\"genToLuck\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fighterIds\",\"type\":\"uint256[]\"}],\"name\":\"createTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getRaceBaseStats\",\"outputs\":[{\"name\":\"strength\",\"type\":\"uint256\"},{\"name\":\"dexterity\",\"type\":\"uint256\"},{\"name\":\"vitality\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint256\"}],\"name\":\"deleteTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fighterIds\",\"type\":\"uint256[]\"}],\"name\":\"isValidTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"geneScience\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_coreAddress\",\"type\":\"address\"},{\"name\":\"_geneScienceAddress\",\"type\":\"address\"},{\"name\":\"_battleDeciderAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"teamId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fighterIds\",\"type\":\"uint256[]\"}],\"name\":\"TeamCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"teamId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fighterIds\",\"type\":\"uint256[]\"}],\"name\":\"TeamDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"winnerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"loserAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attackerFighterIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"defenderFighterIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"attackerWon\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"prizeFighterGeneration\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"prizeFighterGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"attackerXpGained\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"defenderXpGained\",\"type\":\"uint32\"}],\"name\":\"BattleResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BattleCore","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000087d598064c736dd0c712d329afcfaa0ccc1921a100000000000000000000000092882f859e7179d6625e91a09e7b6e856870e5b1000000000000000000000000c6fb27e980e75aae48fbc793f362e3cf87409287","Library":"","SwarmSource":"bzzr://c2c9384736abe2552dd8c89d3d2b1145171f7e4a118a06c5eb5f4c28c951f7d1"}]}