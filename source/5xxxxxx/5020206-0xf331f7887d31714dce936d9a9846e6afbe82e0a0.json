{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\ncontract Owned\r\n{\r\n    address public owner;\r\n\r\n    modifier onlyOwner\r\n\t{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner()\r\n\t{\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Agricoin is Owned\r\n{\r\n    // Dividends payout struct.\r\n    struct DividendPayout\r\n    {\r\n        uint amount;            // Value of dividend payout.\r\n        uint momentTotalSupply; // Total supply in payout moment,\r\n    }\r\n\r\n    // Redemption payout struct.\r\n    struct RedemptionPayout\r\n    {\r\n        uint amount;            // Value of redemption payout.\r\n        uint momentTotalSupply; // Total supply in payout moment.\r\n        uint price;             // Price of Agricoin in weis.\r\n    }\r\n\r\n    // Balance struct with dividends and redemptions record.\r\n    struct Balance\r\n    {\r\n        uint icoBalance;\r\n        uint balance;                       // Agricoin balance.\r\n        uint posibleDividends;              // Dividend number, which user can get.\r\n        uint lastDividensPayoutNumber;      // Last dividend payout index, which user has gotten.\r\n        uint posibleRedemption;             // Redemption value in weis, which user can use.\r\n        uint lastRedemptionPayoutNumber;    // Last redemption payout index, which user has used.\r\n    }\r\n\r\n    // Can act only one from payers.\r\n    modifier onlyPayer()\r\n    {\r\n        require(payers[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n    // Can act only after token activation.\r\n    modifier onlyActivated()\r\n    {\r\n        require(isActive);\r\n        _;\r\n    }\r\n\r\n    // Transfer event.\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);    \r\n\r\n    // Approve event.\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    // Activate event.\r\n    event Activate(bool icoSuccessful);\r\n\r\n    // DividendPayout dividends event.\r\n    event PayoutDividends(uint etherAmount, uint indexed id);\r\n\r\n    // DividendPayout redemption event.\r\n    event PayoutRedemption(uint etherAmount, uint indexed id, uint price);\r\n\r\n    // Get unpaid event.\r\n    event GetUnpaid(uint etherAmount);\r\n\r\n    // Get dividends.\r\n    event GetDividends(address indexed investor, uint etherAmount);\r\n\r\n    // Constructor.\r\n    function Agricoin(uint payout_period_start, uint payout_period_end, address _payer) public\r\n    {\r\n        owner = msg.sender;// Save the owner.\r\n\r\n        // Set payout period.\r\n        payoutPeriodStart = payout_period_start;\r\n        payoutPeriodEnd = payout_period_end;\r\n\r\n        payers[_payer] = true;\r\n    }\r\n\r\n    // Activate token.\r\n\tfunction activate(bool icoSuccessful) onlyOwner() external returns (bool)\r\n\t{\r\n\t\trequire(!isActive);// Check once activation.\r\n\r\n        startDate = now;// Save activation date.\r\n\t\tisActive = true;// Make token active.\r\n\t\towner = 0x00;// Set owner to null.\r\n\t\t\r\n        if (icoSuccessful)\r\n        {\r\n            isSuccessfulIco = true;\r\n            totalSupply += totalSupplyOnIco;\r\n            Activate(true);// Call activation event.\r\n        }\r\n        else\r\n        {\r\n            Activate(false);// Call activation event.\r\n        }\r\n\r\n        return true;\r\n\t}\r\n\r\n    // Add new payer by payer.\r\n    function addPayer(address payer) onlyPayer() external\r\n    {\r\n        payers[payer] = true;\r\n    }\r\n\r\n    // Get balance of address.\r\n\tfunction balanceOf(address owner) public view returns (uint)\r\n\t{\r\n\t\treturn balances[owner].balance;\r\n\t}\r\n\r\n    // Get posible dividends value.\r\n    function posibleDividendsOf(address owner) public view returns (uint)\r\n    {\r\n        return balances[owner].posibleDividends;\r\n    }\r\n\r\n    // Get posible redemption value.\r\n    function posibleRedemptionOf(address owner) public view returns (uint)\r\n    {\r\n        return balances[owner].posibleRedemption;\r\n    }\r\n\r\n    // Transfer _value etheres to _to.\r\n    function transfer(address _to, uint _value) onlyActivated() external returns (bool)\r\n    {\r\n        require(balanceOf(msg.sender) >= _value);\r\n\r\n        recalculate(msg.sender);// Recalculate user's struct.\r\n        \r\n        if (_to != 0x00)// For normal transfer.\r\n        {\r\n            recalculate(_to);// Recalculate recipient's struct.\r\n\r\n            // Change balances.\r\n            balances[msg.sender].balance -= _value;\r\n            balances[_to].balance += _value;\r\n\r\n            Transfer(msg.sender, _to, _value);// Call transfer event.\r\n        }\r\n        else// For redemption transfer.\r\n        {\r\n            require(payoutPeriodStart <= now && now >= payoutPeriodEnd);// Check redemption period.\r\n            \r\n            uint amount = _value * redemptionPayouts[amountOfRedemptionPayouts].price;// Calculate amount of weis in redemption.\r\n\r\n            require(amount <= balances[msg.sender].posibleRedemption);// Check redemption limits.\r\n\r\n            // Change user's struct.\r\n            balances[msg.sender].posibleRedemption -= amount;\r\n            balances[msg.sender].balance -= _value;\r\n\r\n            totalSupply -= _value;// Decrease total supply.\r\n\r\n            msg.sender.transfer(amount);// Transfer redemption to user.\r\n\r\n            Transfer(msg.sender, _to, _value);// Call transfer event.\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Transfer from _from to _to _value tokens.\r\n    function transferFrom(address _from, address _to, uint _value) onlyActivated() external returns (bool)\r\n    {\r\n        // Check transfer posibility.\r\n        require(balances[_from].balance >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(_to != 0x00);\r\n\r\n        // Recalculate structs.\r\n        recalculate(_from);\r\n        recalculate(_to);\r\n\r\n        // Change balances.\r\n        balances[_from].balance -= _value;\r\n        balances[_to].balance += _value;\r\n        \r\n        Transfer(_from, _to, _value);// Call tranfer event.\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Approve for transfers.\r\n    function approve(address _spender, uint _value) onlyActivated() public returns (bool)\r\n    {\r\n        // Recalculate structs.\r\n        recalculate(msg.sender);\r\n        recalculate(_spender);\r\n\r\n        allowed[msg.sender][_spender] = _value;// Set allowed.\r\n        \r\n        Approval(msg.sender, _spender, _value);// Call approval event.\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Get allowance.\r\n    function allowance(address _owner, address _spender) onlyActivated() external view returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Mint _value tokens to _to address.\r\n    function mint(address _to, uint _value, bool icoMinting) onlyOwner() external returns (bool)\r\n    {\r\n        require(!isActive);// Check no activation.\r\n\r\n        if (icoMinting)\r\n        {\r\n            balances[_to].icoBalance += _value;\r\n            totalSupplyOnIco += _value;\r\n        }\r\n        else\r\n        {\r\n            balances[_to].balance += _value;// Increase user's balance.\r\n            totalSupply += _value;// Increase total supply.\r\n\r\n            Transfer(0x00, _to, _value);// Call transfer event.\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Pay dividends.\r\n    function payDividends() onlyPayer() onlyActivated() external payable returns (bool)\r\n    {\r\n        require(now >= payoutPeriodStart && now <= payoutPeriodEnd);// Check payout period.\r\n\r\n        dividendPayouts[amountOfDividendsPayouts].amount = msg.value;// Set payout amount in weis.\r\n        dividendPayouts[amountOfDividendsPayouts].momentTotalSupply = totalSupply;// Save total supply on that moment.\r\n        \r\n        PayoutDividends(msg.value, amountOfDividendsPayouts);// Call dividend payout event.\r\n\r\n        amountOfDividendsPayouts++;// Increment dividend payouts amount.\r\n\r\n        return true;\r\n    }\r\n\r\n    // Pay redemption.\r\n    function payRedemption(uint price) onlyPayer() onlyActivated() external payable returns (bool)\r\n    {\r\n        require(now >= payoutPeriodStart && now <= payoutPeriodEnd);// Check payout period.\r\n\r\n        redemptionPayouts[amountOfRedemptionPayouts].amount = msg.value;// Set payout amount in weis.\r\n        redemptionPayouts[amountOfRedemptionPayouts].momentTotalSupply = totalSupply;// Save total supply on that moment.\r\n        redemptionPayouts[amountOfRedemptionPayouts].price = price;// Set price of Agricoin in weis at this redemption moment.\r\n\r\n        PayoutRedemption(msg.value, amountOfRedemptionPayouts, price);// Call redemption payout event.\r\n\r\n        amountOfRedemptionPayouts++;// Increment redemption payouts amount.\r\n\r\n        return true;\r\n    }\r\n\r\n    // Get back unpaid dividends and redemption.\r\n    function getUnpaid() onlyPayer() onlyActivated() external returns (bool)\r\n    {\r\n        require(now >= payoutPeriodEnd);// Check end payout period.\r\n\r\n        GetUnpaid(this.balance);// Call getting unpaid ether event.\r\n\r\n        msg.sender.transfer(this.balance);// Transfer all ethers back to payer.\r\n\r\n        return true;\r\n    }\r\n\r\n    // Recalculates dividends and redumptions.\r\n    function recalculate(address user) onlyActivated() public returns (bool)\r\n    {\r\n        if (isSuccessfulIco)\r\n        {\r\n            if (balances[user].icoBalance != 0)\r\n            {\r\n                balances[user].balance += balances[user].icoBalance;\r\n                Transfer(0x00, user, balances[user].icoBalance);\r\n                balances[user].icoBalance = 0;\r\n            }\r\n        }\r\n\r\n        // Check for necessity of recalculation.\r\n        if (balances[user].lastDividensPayoutNumber == amountOfDividendsPayouts &&\r\n            balances[user].lastRedemptionPayoutNumber == amountOfRedemptionPayouts)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        uint addedDividend = 0;\r\n\r\n        // For dividends.\r\n        for (uint i = balances[user].lastDividensPayoutNumber; i < amountOfDividendsPayouts; i++)\r\n        {\r\n            addedDividend += (balances[user].balance * dividendPayouts[i].amount) / dividendPayouts[i].momentTotalSupply;\r\n        }\r\n\r\n        balances[user].posibleDividends += addedDividend;\r\n        balances[user].lastDividensPayoutNumber = amountOfDividendsPayouts;\r\n\r\n        uint addedRedemption = 0;\r\n\r\n        // For redemption.\r\n        for (uint j = balances[user].lastRedemptionPayoutNumber; j < amountOfRedemptionPayouts; j++)\r\n        {\r\n            addedRedemption += (balances[user].balance * redemptionPayouts[j].amount) / redemptionPayouts[j].momentTotalSupply;\r\n        }\r\n\r\n        balances[user].posibleRedemption += addedRedemption;\r\n        balances[user].lastRedemptionPayoutNumber = amountOfRedemptionPayouts;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Get dividends.\r\n    function () external payable\r\n    {\r\n        if (payoutPeriodStart >= now && now <= payoutPeriodEnd)// Check payout period.\r\n        {\r\n            if (posibleDividendsOf(msg.sender) > 0)// Check posible dividends.\r\n            {\r\n                uint dividendsAmount = posibleDividendsOf(msg.sender);// Get posible dividends amount.\r\n\r\n                GetDividends(msg.sender, dividendsAmount);// Call getting dividends event.\r\n\r\n                balances[msg.sender].posibleDividends = 0;// Set balance to zero.\r\n\r\n                msg.sender.transfer(dividendsAmount);// Transfer dividends amount.\r\n            }\r\n        }\r\n    }\r\n\r\n    // Token name.\r\n    string public constant name = \"Agricoin\";\r\n    \r\n    // Token market symbol.\r\n    string public constant symbol = \"AGR\";\r\n    \r\n    // Amount of digits after comma.\r\n    uint public constant decimals = 2;\r\n\r\n    // Total supply.\r\n    uint public totalSupply;\r\n\r\n    // Total supply on ICO only;\r\n    uint public totalSupplyOnIco;\r\n       \r\n    // Activation date.\r\n    uint public startDate;\r\n    \r\n    // Payment period start date, setted by ICO contract before activation.\r\n    uint public payoutPeriodStart;\r\n    \r\n    // Payment period last date, setted by ICO contract before activation.\r\n    uint public payoutPeriodEnd;\r\n    \r\n    // Dividends DividendPayout counter.\r\n    uint public amountOfDividendsPayouts = 0;\r\n\r\n    // Redemption DividendPayout counter.\r\n    uint public amountOfRedemptionPayouts = 0;\r\n\r\n    // Dividend payouts.\r\n    mapping (uint => DividendPayout) public dividendPayouts;\r\n    \r\n    // Redemption payouts.\r\n    mapping (uint => RedemptionPayout) public redemptionPayouts;\r\n\r\n    // Dividend and redemption payers.\r\n    mapping (address => bool) public payers;\r\n\r\n    // Balance records.\r\n    mapping (address => Balance) public balances;\r\n\r\n    // Allowed balances.\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n\r\n    // Set true for activating token. If false then token isn't working.\r\n    bool public isActive = false;\r\n\r\n    // Set true for activate ico minted tokens.\r\n    bool public isSuccessfulIco = false;\r\n}\r\n\r\n\r\ncontract Ico is Owned\r\n{\r\n    enum State\r\n    {\r\n        Runned,     // Ico is running.\r\n        Paused,     // Ico was paused.\r\n        Finished,   // Ico has finished successfully.\r\n        Expired,    // Ico has finished unsuccessfully.\r\n        Failed\r\n    }\r\n\r\n    // Refund event.\r\n    event Refund(address indexed investor, uint amount);\r\n\r\n    // Investment event.\r\n    event Invested(address indexed investor, uint amount);\r\n\r\n    // End of ICO event.\r\n    event End(bool result);\r\n\r\n    // Ico constructor.\r\n    function Ico(\r\n        address tokenAddress,       // Agricoin contract address.\r\n        uint tokenPreIcoPrice,      // Price of Agricoin in weis on Pre-ICO.\r\n        uint tokenIcoPrice,         // Price of Agricoin in weis on ICO.\r\n        uint preIcoStart,           // Date of Pre-ICO start.\r\n        uint preIcoEnd,             // Date of Pre-ICO end.\r\n        uint icoStart,              // Date of ICO start.\r\n        uint icoEnd,                // Date of ICO end.\r\n        uint preIcoEmissionTarget,  // Max number of Agricoins, which will be minted on Pre-ICO.\r\n        uint icoEmissionTarget,     // Max number of Agricoins, which will be minted on ICO.\r\n        uint icoSoftCap,\r\n        address bountyAddress) public\r\n    {\r\n        owner = msg.sender;\r\n        token = tokenAddress;\r\n        state = State.Runned;\r\n        \r\n        // Save prices.\r\n        preIcoPrice = tokenPreIcoPrice;\r\n        icoPrice = tokenIcoPrice;\r\n\r\n        // Save dates.\r\n        startPreIcoDate = preIcoStart;\r\n        endPreIcoDate = preIcoEnd;\r\n        startIcoDate = icoStart;\r\n        endIcoDate = icoEnd;\r\n\r\n        preIcoTarget = preIcoEmissionTarget;\r\n        icoTarget = icoEmissionTarget;\r\n        softCap = icoSoftCap;\r\n\r\n        bounty = bountyAddress;\r\n    }\r\n\r\n    // Returns true if ICO is active now.\r\n    function isActive() public view returns (bool)\r\n    {\r\n        return state == State.Runned;\r\n    }\r\n\r\n    // Returns true if date in Pre-ICO period.\r\n    function isRunningPreIco(uint date) public view returns (bool)\r\n    {\r\n        return startPreIcoDate <= date && date <= endPreIcoDate;\r\n    }\r\n\r\n    // Returns true if date in ICO period.\r\n    function isRunningIco(uint date) public view returns (bool)\r\n    {\r\n        return startIcoDate <= date && date <= endIcoDate;\r\n    }\r\n\r\n    // Fallback payable function.\r\n    function () external payable\r\n    {\r\n        // Initialize variables here.\r\n        uint value;\r\n        uint rest;\r\n        uint amount;\r\n        \r\n        if (state == State.Failed)\r\n        {\r\n            amount = invested[msg.sender] + investedOnPreIco[msg.sender];// Save amount of invested weis for user.\r\n            invested[msg.sender] = 0;// Set amount of invested weis to zero.\r\n            investedOnPreIco[msg.sender] = 0;\r\n            Refund(msg.sender, amount);// Call refund event.\r\n            msg.sender.transfer(amount + msg.value);// Returns funds to user.\r\n            return;\r\n        }\r\n\r\n        if (state == State.Expired)// Unsuccessful end of ICO.\r\n        {\r\n            amount = invested[msg.sender];// Save amount of invested weis for user.\r\n            invested[msg.sender] = 0;// Set amount of invested weis to zero.\r\n            Refund(msg.sender, amount);// Call refund event.\r\n            msg.sender.transfer(amount + msg.value);// Returns funds to user.\r\n            return;\r\n        }\r\n\r\n        require(state == State.Runned);// Only for active contract.\r\n\r\n        if (now >= endIcoDate)// After ICO period.\r\n        {\r\n            if (Agricoin(token).totalSupply() + Agricoin(token).totalSupplyOnIco() >= softCap)// Minted Agricoin amount above fixed SoftCap.\r\n            {\r\n                state = State.Finished;// Set state to Finished.\r\n\r\n                // Get Agricoin info for bounty.\r\n                uint decimals = Agricoin(token).decimals();\r\n                uint supply = Agricoin(token).totalSupply() + Agricoin(token).totalSupplyOnIco();\r\n                \r\n                // Transfer bounty funds to Bounty contract.\r\n                if (supply >= 1500000 * decimals)\r\n                {\r\n                    Agricoin(token).mint(bounty, 300000 * decimals, true);\r\n                }\r\n                else if (supply >= 1150000 * decimals)\r\n                {\r\n                    Agricoin(token).mint(bounty, 200000 * decimals, true);\r\n                }\r\n                else if (supply >= 800000 * decimals)\r\n                {\r\n                    Agricoin(token).mint(bounty, 100000 * decimals, true);\r\n                }\r\n                \r\n                Agricoin(token).activate(true);// Activate Agricoin contract.\r\n                End(true);// Call successful end event.\r\n                msg.sender.transfer(msg.value);// Returns user's funds to user.\r\n                return;\r\n            }\r\n            else// Unsuccessful end.\r\n            {\r\n                state = State.Expired;// Set state to Expired.\r\n                Agricoin(token).activate(false);// Activate Agricoin contract.\r\n                msg.sender.transfer(msg.value);// Returns user's funds to user.\r\n                End(false);// Call unsuccessful end event.\r\n                return;\r\n            }\r\n        }\r\n        else if (isRunningPreIco(now))// During Pre-ICO.\r\n        {\r\n            require(investedSumOnPreIco / preIcoPrice < preIcoTarget);// Check for target.\r\n\r\n            if ((investedSumOnPreIco + msg.value) / preIcoPrice >= preIcoTarget)// Check for target with new weis.\r\n            {\r\n                value = preIcoTarget * preIcoPrice - investedSumOnPreIco;// Value of invested weis without change.\r\n                require(value != 0);// Check value isn't zero.\r\n                investedSumOnPreIco = preIcoTarget * preIcoPrice;// Max posible number of invested weis in to Pre-ICO.\r\n                investedOnPreIco[msg.sender] += value;// Increase invested funds by investor.\r\n                Invested(msg.sender, value);// Call investment event.\r\n                Agricoin(token).mint(msg.sender, value / preIcoPrice, false);// Mint some Agricoins for investor.\r\n                msg.sender.transfer(msg.value - value);// Returns change to investor.\r\n                return;\r\n            }\r\n            else\r\n            {\r\n                rest = msg.value % preIcoPrice;// Calculate rest/change.\r\n                require(msg.value - rest >= preIcoPrice);\r\n                investedSumOnPreIco += msg.value - rest;\r\n                investedOnPreIco[msg.sender] += msg.value - rest;\r\n                Invested(msg.sender, msg.value - rest);// Call investment event.\r\n                Agricoin(token).mint(msg.sender, msg.value / preIcoPrice, false);// Mint some Agricoins for investor.\r\n                msg.sender.transfer(rest);// Returns change to investor.\r\n                return;\r\n            }\r\n        }\r\n        else if (isRunningIco(now))// During ICO.\r\n        {\r\n            require(investedSumOnIco / icoPrice < icoTarget);// Check for target.\r\n\r\n            if ((investedSumOnIco + msg.value) / icoPrice >= icoTarget)// Check for target with new weis.\r\n            {\r\n                value = icoTarget * icoPrice - investedSumOnIco;// Value of invested weis without change.\r\n                require(value != 0);// Check value isn't zero.\r\n                investedSumOnIco = icoTarget * icoPrice;// Max posible number of invested weis in to ICO.\r\n                invested[msg.sender] += value;// Increase invested funds by investor.\r\n                Invested(msg.sender, value);// Call investment event.\r\n                Agricoin(token).mint(msg.sender, value / icoPrice, true);// Mint some Agricoins for investor.\r\n                msg.sender.transfer(msg.value - value);// Returns change to investor.\r\n                return;\r\n            }\r\n            else\r\n            {\r\n                rest = msg.value % icoPrice;// Calculate rest/change.\r\n                require(msg.value - rest >= icoPrice);\r\n                investedSumOnIco += msg.value - rest;\r\n                invested[msg.sender] += msg.value - rest;\r\n                Invested(msg.sender, msg.value - rest);// Call investment event.\r\n                Agricoin(token).mint(msg.sender, msg.value / icoPrice, true);// Mint some Agricoins for investor.\r\n                msg.sender.transfer(rest);// Returns change to investor.\r\n                return;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    // Pause contract.\r\n    function pauseIco() onlyOwner external\r\n    {\r\n        require(state == State.Runned);// Only from Runned state.\r\n        state = State.Paused;// Set state to Paused.\r\n    }\r\n\r\n    // Continue paused contract.\r\n    function continueIco() onlyOwner external\r\n    {\r\n        require(state == State.Paused);// Only from Paused state.\r\n        state = State.Runned;// Set state to Runned.\r\n    }\r\n\r\n    // End contract unsuccessfully.\r\n    function endIco() onlyOwner external\r\n    {\r\n        require(state == State.Paused);// Only from Paused state.\r\n        state = State.Failed;// Set state to Expired.\r\n    }\r\n\r\n    // Get invested ethereum.\r\n    function getEthereum() onlyOwner external returns (uint)\r\n    {\r\n        require(state == State.Finished);// Only for successfull ICO.\r\n        uint amount = this.balance;// Save balance.\r\n        msg.sender.transfer(amount);// Transfer all funds to owner address.\r\n        return amount;// Returns amount of transfered weis.\r\n    }\r\n\r\n    // Get invested ethereum from Pre ICO.\r\n    function getEthereumFromPreIco() onlyOwner external returns (uint)\r\n    {\r\n        require(now >= endPreIcoDate);\r\n        require(state == State.Runned || state == State.Finished);\r\n        \r\n        uint value = investedSumOnPreIco;\r\n        investedSumOnPreIco = 0;\r\n        msg.sender.transfer(value);\r\n        return value;\r\n    }\r\n\r\n    // Invested balances.\r\n    mapping (address => uint) invested;\r\n\r\n    mapping (address => uint) investedOnPreIco;\r\n\r\n    // State of contract.\r\n    State public state;\r\n\r\n    // Agricoin price in weis on Pre-ICO.\r\n    uint public preIcoPrice;\r\n\r\n    // Agricoin price in weis on ICO.\r\n    uint public icoPrice;\r\n\r\n    // Date of Pre-ICO start.\r\n    uint public startPreIcoDate;\r\n\r\n    // Date of Pre-ICO end.\r\n    uint public endPreIcoDate;\r\n\r\n    // Date of ICO start.\r\n    uint public startIcoDate;\r\n\r\n    // Date of ICO end.\r\n    uint public endIcoDate;\r\n\r\n    // Agricoin contract address.\r\n    address public token;\r\n\r\n    // Bounty contract address.\r\n    address public bounty;\r\n\r\n    // Invested sum in weis on Pre-ICO.\r\n    uint public investedSumOnPreIco = 0;\r\n\r\n    // Invested sum in weis on ICO.\r\n    uint public investedSumOnIco = 0;\r\n\r\n    // Target in tokens minted on Pre-ICo.\r\n    uint public preIcoTarget;\r\n\r\n    // Target in tokens minted on ICO.\r\n    uint public icoTarget;\r\n\r\n    // SoftCap fot this ICO.\r\n    uint public softCap;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"icoTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preIcoPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getEthereum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getEthereumFromPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPreIcoDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPreIcoDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investedSumOnIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"isRunningPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bounty\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"isRunningIco\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endIcoDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"continueIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startIcoDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investedSumOnPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preIcoTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenPreIcoPrice\",\"type\":\"uint256\"},{\"name\":\"tokenIcoPrice\",\"type\":\"uint256\"},{\"name\":\"preIcoStart\",\"type\":\"uint256\"},{\"name\":\"preIcoEnd\",\"type\":\"uint256\"},{\"name\":\"icoStart\",\"type\":\"uint256\"},{\"name\":\"icoEnd\",\"type\":\"uint256\"},{\"name\":\"preIcoEmissionTarget\",\"type\":\"uint256\"},{\"name\":\"icoEmissionTarget\",\"type\":\"uint256\"},{\"name\":\"icoSoftCap\",\"type\":\"uint256\"},{\"name\":\"bountyAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"End\",\"type\":\"event\"}]","ContractName":"Ico","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d42c50dedae71f7ad62e7792e83d7736637689d9000000000000000000000000000000000000000000000000000005a030863e060000000000000000000000000000000000000000000000000000096050dfbcb4000000000000000000000000000000000000000000000000000000005a7452c0000000000000000000000000000000000000000000000000000000005a7edec0000000000000000000000000000000000000000000000000000000005a86c7c0000000000000000000000000000000000000000000000000000000005aabb1c00000000000000000000000000000000000000000000000000000000001c9c3800000000000000000000000000000000000000000000000000000000007270e000000000000000000000000000000000000000000000000000000000004c4b400000000000000000000000000e2ccc4f900bf1d74f76e43e5434c221ecc6a8a52","Library":"","SwarmSource":"bzzr://08e1dc493bfd8b49b769546c11ad9154d32296ad38d5b768c4db4f9455a9bbd6"}]}