{"status":"1","message":"OK","result":[{"SourceCode":"// MUSystem is based of the mathematical algorithm created \r\n// by the Mavrodi brothers - Sergey and Vyacheslav. \r\n// The solidity code was written by the enthusiast and devoted MMM participant Andrew from Russia.\r\n// According to these rules MMM worked in Russia in the nineties. \r\n// Today you help someone — Tomorrow you will be helped out!\r\n// Mutual Uniting System (MUSystem) email: mutualunitingsystem@gmail.com\r\n// http:// Musystem.online\r\n// Hello from Russia with love! ;) Привет из России! ;)\r\n// \"MMM IS A FINANCIAL NUCLEAR WEAPON.\r\n// They say Baba Vanga predicted, “Pyramid from Russia will travel the world.”\r\n// When Sergey Mavrodi passed away, many people thought this prediction \r\n// wasn't going to come true. What if it's just started to materialize?\"\r\n\r\n// Financial apocalypse is inevitable! Together we can do a lot!\r\n// Thank you Sergey Mavrodi. You've opened my eyes.\r\n\r\npragma solidity ^0.4.21;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a / b;\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract MUSystem {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    string public constant name = \"Mutual Uniting System\";\r\n    string public constant symbol = \"MUS\";\r\n    uint public constant decimals = 15;\r\n    uint public totalSupply;\r\n    address private creatorOwner;\r\n    address private userAddr;\r\n    mapping (address => uint) balances;\r\n    struct UserWhoBuy {\r\n        uint UserAmt;\r\n        uint UserTokenObtain;\r\n        uint UserBuyDate;\r\n        uint UserBuyFirstDate;\r\n        uint UserBuyTokenPackNum;\r\n        uint UserFirstAmt;\r\n        uint UserContinued;\r\n        uint UserTotalAmtDepositCurrentPack;\r\n    }\r\n    mapping (address => UserWhoBuy) usersWhoBuy;\r\n    address[] private userWhoBuyDatas;\r\n    struct UserWhoSell {\r\n        uint UserAmtWithdrawal;\r\n        uint UserTokenSell;\r\n        uint UserSellDate;\r\n        uint UserSellTokenPackNum;\r\n        uint UserTotalAmtWithdrawal;\r\n        uint UserTotalAmtWithdrawalCurrentPack;\r\n    }\r\n    mapping (address => UserWhoSell) usersWhoSell;\r\n    address[] private userWhoSellDatas;\r\n\r\n// The basic parameters of MUSystem that determine \r\n// the participant's income per package, \r\n// the initial price of one token, \r\n// the number of tokens in pack, Disparity mode percentage\r\n// and another internal constants.\r\n\r\n    uint private CoMargin = 101; \r\n    uint private CoOverlap = 110; \r\n    uint private Disparity = 70; \r\n    bool private DisparityMode;\r\n    uint private RestartModeDate;\r\n    bool private RestartMode;\r\n    uint private PackVolume = 50;  \r\n    uint private FirstPackTokenPriceSellout = 50;    \r\n    uint private BigAmt = 250 * 1 ether; \r\n    bool private feeTransfered;\r\n    uint private PrevPrevPackTokenPriceSellout;\r\n    uint private PrevPackTokenPriceSellout;\r\n    uint private PrevPackTokenPriceBuyout; \r\n    uint private PrevPackDelta; \r\n    uint private PrevPackCost;\r\n    uint private PrevPackTotalAmt;\r\n    uint private CurrentPackYield;\r\n    uint private CurrentPackDelta;\r\n    uint private CurrentPackCost;\r\n    uint private CurrentPackTotalToPay;\r\n    uint private CurrentPackTotalAmt;\r\n    uint private CurrentPackRestAmt;\r\n    uint private CurrentPackFee;\r\n    uint private CurrentPackTotalToPayDisparity;\r\n    uint private CurrentPackNumber; \r\n    uint private CurrentPackStartDate; \r\n    uint private CurrentPackTokenPriceSellout;  \r\n    uint private CurrentPackTokenPriceBuyout;\r\n    uint private CurrentPackTokenAvailablePercent;\r\n    uint private NextPackTokenPriceBuyout; \r\n    uint private NextPackYield; \r\n    uint private NextPackDelta;\r\n    uint private userContinued;\r\n    uint private userAmt; \r\n    uint private userFirstAmt;\r\n    uint private userTotalAmtDepositCurrentPack;\r\n    uint private userBuyFirstDate;\r\n    uint private userTotalAmtWithdrawal;\r\n    uint private userTotalAmtWithdrawalCurrentPack;\r\n    uint private UserTokensReturn;\r\n    bool private returnTokenInCurrentPack;\r\n    uint private withdrawAmtToCurrentPack;\r\n    uint private withdrawAmtAboveCurrentPack;\r\n    uint private UserTokensReturnToCurrentPack;\r\n    uint private UserTokensReturnAboveCurrentPack;\r\n    uint private bonus;\r\n    uint private userAmtOverloadToSend;\r\n\r\n// MUSystem is launched at the time of the contract deployment. \r\n// It all starts with the first package. \r\n// Settings are applied and the number of tokens is released.\r\n\r\n    constructor () public payable {\r\n        creatorOwner = msg.sender;\r\n        PackVolume = (10 ** decimals).mul(PackVolume);\r\n        DisparityMode = false;\r\n        RestartMode = false;\r\n        CurrentPackNumber = 1; \r\n        CurrentPackStartDate = now;\r\n        mint(PackVolume);\r\n        packSettings(CurrentPackNumber);\r\n    }\r\n\r\n// Write down participants who make deposits.\r\n\r\n    function addUserWhoBuy (\r\n    address _address, \r\n    uint _UserAmt, \r\n    uint _UserTokenObtain, \r\n    uint _UserBuyDate,\r\n    uint _UserBuyFirstDate,\r\n    uint _UserBuyTokenPackNum,\r\n    uint _UserFirstAmt,\r\n    uint _UserContinued,\r\n    uint _UserTotalAmtDepositCurrentPack) internal {\r\n        UserWhoBuy storage userWhoBuy = usersWhoBuy[_address];\r\n        userWhoBuy.UserAmt = _UserAmt;\r\n        userWhoBuy.UserTokenObtain = _UserTokenObtain;\r\n        userWhoBuy.UserBuyDate = _UserBuyDate;\r\n        userWhoBuy.UserBuyFirstDate = _UserBuyFirstDate;\r\n        userWhoBuy.UserBuyTokenPackNum = _UserBuyTokenPackNum;\r\n        userWhoBuy.UserFirstAmt = _UserFirstAmt;\r\n        userWhoBuy.UserContinued = _UserContinued;\r\n        userWhoBuy.UserTotalAmtDepositCurrentPack = _UserTotalAmtDepositCurrentPack;\r\n        userWhoBuyDatas.push(_address) -1;\r\n    }\r\n// Write down also participants who make withdrawals.\r\n\r\n    function addUserWhoSell (\r\n    address _address, \r\n    uint _UserAmtWithdrawal, \r\n    uint _UserTokenSell, \r\n    uint _UserSellDate,\r\n    uint _UserSellTokenPackNum,\r\n    uint _UserTotalAmtWithdrawal,\r\n    uint _UserTotalAmtWithdrawalCurrentPack) internal {\r\n        UserWhoSell storage userWhoSell = usersWhoSell[_address];\r\n        userWhoSell.UserAmtWithdrawal = _UserAmtWithdrawal;\r\n        userWhoSell.UserTokenSell = _UserTokenSell;\r\n        userWhoSell.UserSellDate = _UserSellDate;\r\n        userWhoSell.UserSellTokenPackNum = _UserSellTokenPackNum;\r\n        userWhoSell.UserTotalAmtWithdrawal = _UserTotalAmtWithdrawal; \r\n        userWhoSell.UserTotalAmtWithdrawalCurrentPack = _UserTotalAmtWithdrawalCurrentPack;\r\n        userWhoSellDatas.push(_address) -1;\r\n    }\r\n\r\n// Calculation of pack's parameters \"on the fly\". \r\n// Course (price) of tokens is growing by a special technique, \r\n// which designed increases with the passage of time the size \r\n// of a possible return donations for the participants, \r\n// subject to a maximum system stability.\r\n\r\n    function packSettings (uint _currentPackNumber) internal {\r\n        CurrentPackNumber = _currentPackNumber;\r\n        if(CurrentPackNumber == 1){\r\n            PrevPackDelta = 0;\r\n            PrevPackCost = 0;\r\n            PrevPackTotalAmt = 0;\r\n            CurrentPackStartDate = now;\r\n            CurrentPackTokenPriceSellout = FirstPackTokenPriceSellout;\r\n            CurrentPackTokenPriceBuyout = FirstPackTokenPriceSellout; \r\n            CurrentPackCost = PackVolume.mul(CurrentPackTokenPriceSellout);\r\n            CurrentPackTotalToPay = 0;\r\n            CurrentPackTotalToPayDisparity = 0;\r\n            CurrentPackYield = 0;\r\n            CurrentPackDelta = 0;\r\n            CurrentPackTotalAmt = CurrentPackCost;\r\n            CurrentPackFee = 0;\r\n            CurrentPackRestAmt = CurrentPackCost.sub(CurrentPackTotalToPay);\r\n            if (FirstPackTokenPriceSellout == 50){NextPackTokenPriceBuyout = 60;}else{NextPackTokenPriceBuyout = FirstPackTokenPriceSellout+5;}\r\n        }\r\n        if(CurrentPackNumber == 2){\r\n            PrevPrevPackTokenPriceSellout = 0;\r\n            PrevPackTokenPriceSellout = CurrentPackTokenPriceSellout;\r\n            PrevPackTokenPriceBuyout = CurrentPackTokenPriceBuyout;\r\n            PrevPackDelta = CurrentPackDelta;\r\n            PrevPackCost = CurrentPackCost;\r\n            PrevPackTotalAmt = CurrentPackTotalAmt;\r\n            CurrentPackYield = 0;\r\n            CurrentPackDelta = 0;\r\n            NextPackTokenPriceBuyout = PrevPackTokenPriceSellout.mul(CoOverlap).div(100);\r\n            NextPackYield = NextPackTokenPriceBuyout.sub(PrevPackTokenPriceSellout);\r\n            NextPackDelta = NextPackYield;\r\n            CurrentPackTokenPriceSellout = NextPackTokenPriceBuyout.add(NextPackDelta);\r\n            CurrentPackTokenPriceBuyout = CurrentPackTokenPriceSellout;\r\n            CurrentPackCost = PackVolume.mul(CurrentPackTokenPriceSellout);\r\n            CurrentPackTotalToPay = 0;\r\n            CurrentPackTotalAmt = CurrentPackCost.add(PrevPackTotalAmt);\r\n            CurrentPackFee = 0;\r\n            CurrentPackTotalToPayDisparity = PrevPackCost.mul(Disparity).div(100);\r\n            CurrentPackRestAmt = CurrentPackCost.sub(CurrentPackTotalToPay);\r\n        }\r\n        if(CurrentPackNumber > 2){\r\n            PrevPackTokenPriceSellout = CurrentPackTokenPriceSellout;\r\n            PrevPackTokenPriceBuyout = CurrentPackTokenPriceBuyout;\r\n            PrevPackDelta = CurrentPackDelta;\r\n            PrevPackCost = CurrentPackCost;\r\n            PrevPackTotalAmt = CurrentPackTotalAmt;\r\n            CurrentPackYield = NextPackYield;\r\n            CurrentPackDelta = NextPackDelta;\r\n            CurrentPackTokenPriceBuyout = NextPackTokenPriceBuyout;\r\n            NextPackTokenPriceBuyout = PrevPackTokenPriceSellout.mul(CoOverlap);\r\n            if(NextPackTokenPriceBuyout<=100){  \r\n                NextPackTokenPriceBuyout=PrevPackTokenPriceSellout.mul(CoOverlap).div(100);\r\n            }\r\n            if(NextPackTokenPriceBuyout>100){ \r\n                NextPackTokenPriceBuyout=NextPackTokenPriceBuyout*10**3;\r\n                NextPackTokenPriceBuyout=((NextPackTokenPriceBuyout/10000)+5)/10;\r\n            }\r\n            NextPackYield = NextPackTokenPriceBuyout.sub(PrevPackTokenPriceSellout);\r\n            NextPackDelta = NextPackYield.mul(CoMargin);\r\n            if(NextPackDelta <= 100){ \r\n                NextPackDelta = CurrentPackDelta.add(NextPackYield.mul(CoMargin).div(100));\r\n            }\r\n            if(NextPackDelta > 100){\r\n                NextPackDelta = NextPackDelta*10**3;\r\n                NextPackDelta = ((NextPackDelta/10000)+5)/10;\r\n                NextPackDelta = CurrentPackDelta.add(NextPackDelta);\r\n            }\r\n            CurrentPackTokenPriceSellout = NextPackTokenPriceBuyout.add(NextPackDelta);\r\n            CurrentPackCost = PackVolume.mul(CurrentPackTokenPriceSellout);\r\n            CurrentPackTotalToPay = PackVolume.mul(CurrentPackTokenPriceBuyout);\r\n            CurrentPackTotalToPayDisparity = PrevPackCost.mul(Disparity).div(100);\r\n            CurrentPackRestAmt = CurrentPackCost.sub(CurrentPackTotalToPay);\r\n            CurrentPackTotalAmt = CurrentPackRestAmt.add(PrevPackTotalAmt);\r\n            CurrentPackFee = PrevPackTotalAmt.sub(CurrentPackTotalToPay).sub(CurrentPackTotalToPayDisparity);\r\n        }\r\n        CurrentPackTokenAvailablePercent = balances[address(this)].mul(100).div(PackVolume);\r\n        emit NextPack(CurrentPackTokenPriceSellout, CurrentPackTokenPriceBuyout);\r\n    }\r\n\r\n// The data of the current package can be obtained \r\n// by performing this function.\r\n// Available tokens - the remaining number of available \r\n// tokens in the current package. \r\n// At onetime you can not buy more than this number of tokens.\r\n// Available tokens in percentage - the percentage of \r\n// remaining available tokens in the current package.\r\n// Available amount to deposit in wei - the maximum amount \r\n// that can be deposited in the current package.\r\n// Attempt to exceed this amount too much \r\n// (i.e., an attempt to buy more tokens than the Available tokens \r\n// in the current package) will be rejected. \r\n// In case of a small excess of the amount, the unused leftover \r\n// will return to your Ethereum account.\r\n// Current pack token price sellout -  the price at which \r\n// tokens are bought by a participant.\r\n// Current pack token price buyout - the price at which \r\n// tokens are sold by a participant (are bought by the system).\r\n\r\n    function aboutCurrentPack () public constant returns (uint availableTokens, uint availableTokensInPercentage, uint availableAmountToDepositInWei, uint tokenPriceSellout, uint tokenPriceBuyout){\r\n        uint _availableTokens = balances[address(this)];\r\n        uint _availableAmountToDepositInWei = _availableTokens.mul(CurrentPackTokenPriceSellout);\r\n        return (_availableTokens, CurrentPackTokenAvailablePercent, _availableAmountToDepositInWei, CurrentPackTokenPriceSellout, CurrentPackTokenPriceBuyout);\r\n    }\r\n\r\n// Move to the next package. Sending a reward to the owner. \r\n// Minting of new tokens.\r\n\r\n    function nextPack (uint _currentPackNumber) internal { \r\n        transferFee();\r\n        feeTransfered = false;\r\n        CurrentPackNumber=_currentPackNumber.add(1);\r\n        CurrentPackStartDate = now;\r\n        mint(PackVolume);\r\n        packSettings(CurrentPackNumber);\r\n    }\r\n\r\n// Restart occurs if the Disparity mode is enabled and \r\n// there were no new donations within 14 days. \r\n// Everything will start with the first package. \r\n// After restart, the system saves the participant's tokens. \r\n// Moreover, by participating from the very beginning \r\n// (starting from the first package of the new cycle), \r\n// the participant can easily compensate for his \r\n// insignificant losses. And quickly achieve a good profit!\r\n\r\n    function restart(bool _dm)internal{\r\n        if(_dm==true){if(RestartMode==false){RestartMode=true;RestartModeDate=now;}\r\n            else{if(now>RestartModeDate+14*1 days){RestartMode=false;DisparityMode=false;nextPack(0);}}}\r\n        else{if(RestartMode==true){RestartMode=false;RestartModeDate=0;}}\r\n    }\r\n\r\n// Sending reward to the owner. \r\n// No more and no less - just as much as it does not hurt. \r\n// Exactly as much as provided by the algorithm.\r\n\r\n    function transferFee()internal{\r\n        if(CurrentPackNumber > 2 && feeTransfered == false){\r\n            if(address(this).balance>=CurrentPackFee){\r\n                creatorOwner.transfer(CurrentPackFee);\r\n                feeTransfered = true;\r\n            }\r\n        }\r\n    }\r\n\r\n// Receiving a donation and calculating the number of participant tokens. \r\n// Bonuses, penalties.\r\n\r\n    function deposit() public payable returns (uint UserTokenObtain){ \r\n        require(msg.sender != 0x0 && msg.sender != 0);\r\n        require(msg.value < BigAmt); \r\n        uint availableTokens = balances[address(this)];\r\n        require(msg.value <= availableTokens.mul(CurrentPackTokenPriceSellout).add(availableTokens.mul(CurrentPackTokenPriceSellout).mul(10).div(100)).add(10*1 finney)); \r\n        require(msg.value.div(CurrentPackTokenPriceSellout) > 0);\r\n        userAddr = msg.sender;\r\n        userAmt = msg.value;\r\n        if(usersWhoBuy[userAddr].UserBuyTokenPackNum == CurrentPackNumber){\r\n            userTotalAmtDepositCurrentPack = usersWhoBuy[userAddr].UserTotalAmtDepositCurrentPack;\r\n        }\r\n        else{\r\n            userTotalAmtDepositCurrentPack = 0;\r\n        }\r\n        if(usersWhoBuy[userAddr].UserBuyTokenPackNum == CurrentPackNumber){\r\n            require(userTotalAmtDepositCurrentPack.add(userAmt) < BigAmt);\r\n        }\r\n\r\n// If the participant making a donation in the current package \r\n// has already received a backward donation in the same package, \r\n// the amount of the new donation is reduced by 5% of the amount\r\n// of the received donation; a kind of \"penalty\" is imposed in \r\n// the amount of 5% of the amount received earlier \r\n// by the participant in the same package.\r\n\r\n        if(usersWhoSell[userAddr].UserSellTokenPackNum == CurrentPackNumber){\r\n            uint penalty = usersWhoSell[userAddr].UserTotalAmtWithdrawalCurrentPack.mul(5).div(100);\r\n            userAmt = userAmt.sub(penalty);\r\n            require(userAmt.div(CurrentPackTokenPriceSellout) > 0);\r\n            penalty=0;\r\n        }\r\n        UserTokenObtain = userAmt.div(CurrentPackTokenPriceSellout);\r\n        bonus = 0;\r\n\r\n// Participants who made donation amounting to at least  0.1 ether:\r\n// In the 1st day of the current package is entitled to receive \r\n// the amount of possible backward donation to 0.75% more than usual.\r\n// In the 2nd day of the current package - 0.5% more than usual.\r\n// In the 3rd day of the current package - 0.25% more than usual.\r\n\r\n        if(userAmt >= 100*1 finney){\r\n            if(now <= (CurrentPackStartDate + 1*1 days)){\r\n                bonus = UserTokenObtain.mul(75).div(10000);\r\n            }\r\n            if(now > (CurrentPackStartDate + 1*1 days) && now <= (CurrentPackStartDate + 2*1 days)){\r\n                bonus = UserTokenObtain.mul(50).div(10000);\r\n            }\r\n            if(now > (CurrentPackStartDate + 2*1 days) && now <= (CurrentPackStartDate + 3*1 days)){\r\n                bonus = UserTokenObtain.mul(25).div(10000);\r\n            }\r\n        }\r\n\r\n// For continuous long-time participation, \r\n// starting from the second week of participation \r\n// (starting from the 4th participation package), \r\n// bonus incentives for the continuous participation \r\n// of 1% of the contributed amount for each subsequent \r\n// \"own\" package are accrued for the participant.\r\n\r\n        if(userContinued > 4 && now > (userBuyFirstDate + 1 * 1 weeks)){\r\n            bonus = bonus.add(UserTokenObtain.mul(1).div(100));\r\n        }\r\n        UserTokenObtain = UserTokenObtain.add(bonus);  \r\n        if(UserTokenObtain > availableTokens){\r\n            userAmtOverloadToSend = CurrentPackTokenPriceSellout.mul(UserTokenObtain.sub(availableTokens)); \r\n            transfer(address(this), userAddr, availableTokens);\r\n            UserTokenObtain = availableTokens;\r\n            if(address(this).balance>=userAmtOverloadToSend){\r\n                userAddr.transfer(userAmtOverloadToSend);\r\n            }\r\n        }                \r\n        else{                 \r\n            transfer(address(this), userAddr, UserTokenObtain);\r\n        }\r\n        if(usersWhoBuy[userAddr].UserBuyTokenPackNum == 0){\r\n            userFirstAmt = userAmt;\r\n            userBuyFirstDate = now;\r\n        }\r\n        else{\r\n            userFirstAmt = usersWhoBuy[userAddr].UserFirstAmt;\r\n            userBuyFirstDate = usersWhoBuy[userAddr].UserBuyFirstDate;\r\n        }\r\n        if(usersWhoBuy[userAddr].UserContinued == 0){\r\n            userContinued = 1;\r\n        }\r\n        else{\r\n            if(usersWhoBuy[userAddr].UserBuyTokenPackNum == CurrentPackNumber.sub(1)){\r\n                userContinued = userContinued.add(1);\r\n            }\r\n            else{\r\n                userContinued = 1;\r\n            }\r\n        }\r\n        userTotalAmtDepositCurrentPack = userTotalAmtDepositCurrentPack.add(userAmt);\r\n        addUserWhoBuy(userAddr, userAmt, UserTokenObtain, now, userBuyFirstDate, CurrentPackNumber, userFirstAmt, userContinued, userTotalAmtDepositCurrentPack);\r\n        CurrentPackTokenAvailablePercent = balances[address(this)].mul(100).div(PackVolume);\r\n        bonus = 0;\r\n        availableTokens = 0;\r\n        userAmtOverloadToSend = 0;\r\n        userAddr = 0;\r\n        userAmt = 0;\r\n        restart(false);\r\n        DisparityMode = false;\r\n\r\n// Move to the next pack, if all the tokens of the current one are over.\r\n\r\n        if(balances[address(this)] == 0){nextPack(CurrentPackNumber);}\r\n        return UserTokenObtain;\r\n    } \r\n\r\n// And here the participant decided to sell his tokens (some or all at once) and sends us his withdrawal request.\r\n\r\n    function withdraw(uint WithdrawAmount, uint WithdrawTokens) public returns (uint withdrawAmt){\r\n        require(msg.sender != 0x0 && msg.sender != 0);\r\n        require(WithdrawTokens > 0 || WithdrawAmount > 0);\r\n        require(WithdrawTokens<=balances[msg.sender]); \r\n        require(WithdrawAmount.mul(1 finney)<=balances[msg.sender].mul(CurrentPackTokenPriceSellout).add(balances[msg.sender].mul(CurrentPackTokenPriceSellout).mul(5).div(100)));\r\n\r\n// If the normal work is braked then Disparity mode is turning on.\r\n// If Disparity mode is already enabled, then we check whether it's time to restart.\r\n\r\n        if(RestartMode==true){restart(true);}\r\n        if(address(this).balance<=CurrentPackTotalToPayDisparity){\r\n            DisparityMode=true;}else{DisparityMode=false;}\r\n\r\n// The participant can apply at any time for the selling \r\n// his tokens at the buyout price of the last realized (current) package.\r\n// Let calculate how much tokens are returned in the current package, \r\n// and how much was purchased earlier.\r\n\r\n        userTotalAmtWithdrawal = usersWhoSell[msg.sender].UserTotalAmtWithdrawal;\r\n        if(usersWhoSell[msg.sender].UserSellTokenPackNum == CurrentPackNumber){\r\n            userTotalAmtWithdrawalCurrentPack = usersWhoSell[msg.sender].UserTotalAmtWithdrawalCurrentPack;\r\n        }\r\n        else{\r\n            userTotalAmtWithdrawalCurrentPack = 0;\r\n        }\r\n        if(usersWhoBuy[msg.sender].UserBuyTokenPackNum == CurrentPackNumber && userTotalAmtWithdrawalCurrentPack < usersWhoBuy[msg.sender].UserTotalAmtDepositCurrentPack){\r\n            returnTokenInCurrentPack = true;\r\n            withdrawAmtToCurrentPack = usersWhoBuy[msg.sender].UserTotalAmtDepositCurrentPack.sub(userTotalAmtWithdrawalCurrentPack);\r\n        }\r\n        else{ \r\n            returnTokenInCurrentPack = false;\r\n        }\r\n        if(WithdrawAmount > 0){\r\n            withdrawAmt = WithdrawAmount.mul(1 finney);\r\n            if(returnTokenInCurrentPack == true){\r\n                UserTokensReturnToCurrentPack = withdrawAmtToCurrentPack.div(CurrentPackTokenPriceSellout);\r\n                if(withdrawAmt>withdrawAmtToCurrentPack){ \r\n                    withdrawAmtAboveCurrentPack = withdrawAmt.sub(withdrawAmtToCurrentPack);\r\n                    UserTokensReturnAboveCurrentPack = withdrawAmtAboveCurrentPack.div(CurrentPackTokenPriceBuyout);\r\n                } \r\n                else{\r\n                    withdrawAmtToCurrentPack = withdrawAmt;\r\n                    UserTokensReturnToCurrentPack = withdrawAmtToCurrentPack.div(CurrentPackTokenPriceSellout);\r\n                    withdrawAmtAboveCurrentPack = 0;\r\n                    UserTokensReturnAboveCurrentPack = 0;\r\n                }\r\n            }\r\n            else{\r\n                withdrawAmtToCurrentPack = 0;\r\n                UserTokensReturnToCurrentPack = 0;\r\n                withdrawAmtAboveCurrentPack = withdrawAmt;\r\n                UserTokensReturnAboveCurrentPack = withdrawAmtAboveCurrentPack.div(CurrentPackTokenPriceBuyout);\r\n            }\r\n        }\r\n        else{\r\n            UserTokensReturn = WithdrawTokens;\r\n            if(returnTokenInCurrentPack == true){\r\n                UserTokensReturnToCurrentPack = withdrawAmtToCurrentPack.div(CurrentPackTokenPriceSellout);\r\n                if(UserTokensReturn>UserTokensReturnToCurrentPack){\r\n                    UserTokensReturnAboveCurrentPack = UserTokensReturn.sub(UserTokensReturnToCurrentPack);\r\n                    withdrawAmtAboveCurrentPack = UserTokensReturnAboveCurrentPack.mul(CurrentPackTokenPriceBuyout);\r\n                }\r\n                else{\r\n                    withdrawAmtToCurrentPack = UserTokensReturn.mul(CurrentPackTokenPriceSellout);\r\n                    UserTokensReturnToCurrentPack = UserTokensReturn;\r\n                    withdrawAmtAboveCurrentPack = 0;\r\n                    UserTokensReturnAboveCurrentPack = 0;\r\n                }\r\n            }\r\n            else{\r\n                withdrawAmtToCurrentPack = 0;\r\n                UserTokensReturnToCurrentPack = 0;\r\n                UserTokensReturnAboveCurrentPack = UserTokensReturn;\r\n                withdrawAmtAboveCurrentPack = UserTokensReturnAboveCurrentPack.mul(CurrentPackTokenPriceBuyout);\r\n            }    \r\n        }\r\n        withdrawAmt = withdrawAmtToCurrentPack.add(withdrawAmtAboveCurrentPack);\r\n\r\n// When applying for a donation, if the remaining number \r\n// of available tokens of the current package is less than 10%, \r\n// participants are entitled to withdraw of 1% more than usual.\r\n\r\n        if(balances[address(this)]<=(PackVolume.mul(10).div(100))){\r\n            withdrawAmtAboveCurrentPack = withdrawAmtAboveCurrentPack.add(withdrawAmt.mul(1).div(100));\r\n        }\r\n\r\n// With each withdrawal, the system checks the total balance \r\n// and if the system is on the verge, when it can pay to each participant \r\n// 70% of his initial donation, the protection mode called \"Disparity mode\" is activated.\r\n// In disparity mode: participant who made a donation in the current package \r\n// can withdraw up to 100% of his initial donation amount,\r\n// participant who made a donation earlier (in previous packs) \r\n// can withdraw up to 70% of his initial donation amount.\r\n\r\n        if(address(this).balance<CurrentPackTotalToPayDisparity || withdrawAmt > address(this).balance || DisparityMode == true){\r\n            uint disparityAmt = usersWhoBuy[msg.sender].UserFirstAmt.mul(Disparity).div(100);\r\n            if(userTotalAmtWithdrawal >= disparityAmt){\r\n                withdrawAmtAboveCurrentPack = 0;\r\n                UserTokensReturnAboveCurrentPack = 0;\r\n            }\r\n            else{\r\n                if(withdrawAmtAboveCurrentPack.add(userTotalAmtWithdrawal) >= disparityAmt){\r\n                    withdrawAmtAboveCurrentPack = disparityAmt.sub(userTotalAmtWithdrawal);\r\n                    UserTokensReturnAboveCurrentPack = withdrawAmtAboveCurrentPack.div(CurrentPackTokenPriceBuyout);\r\n                }\r\n            }\r\n            DisparityMode = true;\r\n            if(CurrentPackNumber>2){restart(true);}\r\n        }\r\n        if(withdrawAmt>address(this).balance){\r\n            withdrawAmt = address(this).balance;\r\n            withdrawAmtAboveCurrentPack = address(this).balance.sub(withdrawAmtToCurrentPack);\r\n            UserTokensReturnAboveCurrentPack = withdrawAmtAboveCurrentPack.div(CurrentPackTokenPriceBuyout);\r\n            if(CurrentPackNumber>2){restart(true);}\r\n        }\r\n        withdrawAmt = withdrawAmtToCurrentPack.add(withdrawAmtAboveCurrentPack);\r\n        UserTokensReturn = UserTokensReturnToCurrentPack.add(UserTokensReturnAboveCurrentPack);\r\n        require(UserTokensReturn<=balances[msg.sender]); \r\n        transfer(msg.sender, address(this), UserTokensReturn);\r\n        msg.sender.transfer(withdrawAmt);\r\n        userTotalAmtWithdrawal = userTotalAmtWithdrawal.add(withdrawAmt);\r\n        userTotalAmtWithdrawalCurrentPack = userTotalAmtWithdrawalCurrentPack.add(withdrawAmt);\r\n        addUserWhoSell(msg.sender, withdrawAmt, UserTokensReturn, now, CurrentPackNumber, userTotalAmtWithdrawal, userTotalAmtWithdrawalCurrentPack);\r\n        CurrentPackTokenAvailablePercent = balances[address(this)].mul(100).div(PackVolume);\r\n        withdrawAmtToCurrentPack = 0;\r\n        withdrawAmtAboveCurrentPack = 0;\r\n        UserTokensReturnToCurrentPack = 0;\r\n        UserTokensReturnAboveCurrentPack = 0;\r\n        return withdrawAmt;\r\n    }\r\n\r\n// If tokens purchased in the current package are returned, \r\n// they are again available for purchase by other participants.\r\n// If tokens purchased in previous packages are returned, \r\n// then such tokens are no longer available to anyone.\r\n\r\n    function transfer(address _from, address _to, uint _value) internal returns (bool success) {\r\n        balances[_from] = balances[_from].sub(_value); \r\n        if(_to == address(this)){ \r\n            if(returnTokenInCurrentPack == true){\r\n                balances[_to] = balances[_to].add(UserTokensReturnToCurrentPack);\r\n            }\r\n            else{\r\n                balances[_to] = balances[_to];\r\n            }\r\n            totalSupply = totalSupply.sub(UserTokensReturnAboveCurrentPack);\r\n        }\r\n        else{\r\n            balances[_to] = balances[_to].add(_value);\r\n        }\r\n        emit Transfer(_from, _to, _value); \r\n        return true;\r\n    }  \r\n\r\n// BalanceOf — get balance of tokens.\r\n\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n// Minting new tokens if the moving to a new package occurred.\r\n\r\n    function mint(uint _value) internal returns (bool) {\r\n        balances[address(this)] = balances[address(this)].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        return true;\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event NextPack(uint indexed CurrentPackTokenPriceSellout, uint indexed CurrentPackTokenPriceBuyout);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"WithdrawAmount\",\"type\":\"uint256\"},{\"name\":\"WithdrawTokens\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"withdrawAmt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"UserTokenObtain\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"aboutCurrentPack\",\"outputs\":[{\"name\":\"availableTokens\",\"type\":\"uint256\"},{\"name\":\"availableTokensInPercentage\",\"type\":\"uint256\"},{\"name\":\"availableAmountToDepositInWei\",\"type\":\"uint256\"},{\"name\":\"tokenPriceSellout\",\"type\":\"uint256\"},{\"name\":\"tokenPriceBuyout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"CurrentPackTokenPriceSellout\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"CurrentPackTokenPriceBuyout\",\"type\":\"uint256\"}],\"name\":\"NextPack\",\"type\":\"event\"}]","ContractName":"MUSystem","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3ce2a4aa512e887637a71fb6db38d20eb9fc84a658f60a5eef2a7c364857c9a8"}]}