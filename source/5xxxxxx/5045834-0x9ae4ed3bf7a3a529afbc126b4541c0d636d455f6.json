{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n/*\r\n\r\n  Copyright 2018 EasyTrade.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\ncontract Token {\r\n    \r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n    \r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) public returns (bool success) {}\r\n\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) public returns (bool success) {}\r\n    \r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    function safeMul(uint a, uint b) internal constant returns (uint256) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal constant returns (uint256) {\r\n        uint c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal constant returns (uint256) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract EtherToken is Token {\r\n\r\n    /// @dev Buys tokens with Ether, exchanging them 1:1.\r\n    function deposit()\r\n        public\r\n        payable\r\n    {}\r\n\r\n    /// @dev Sells tokens in exchange for Ether, exchanging them 1:1.\r\n    /// @param amount Number of tokens to sell.\r\n    function withdraw(uint amount)\r\n        public\r\n    {}\r\n}\r\n\r\ncontract Exchange {\r\n\r\n    /// @dev Fills the input order.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\r\n    /// @param v ECDSA signature parameter v.\r\n    /// @param r ECDSA signature parameters r.\r\n    /// @param s ECDSA signature parameters s.\r\n    /// @return Total amount of takerToken filled in trade.\r\n    function fillOrder(\r\n          address[5] orderAddresses,\r\n          uint[6] orderValues,\r\n          uint fillTakerTokenAmount,\r\n          bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n          uint8 v,\r\n          bytes32 r,\r\n          bytes32 s)\r\n          public\r\n          returns (uint filledTakerTokenAmount)\r\n    {}\r\n\r\n    /*\r\n    * Constant public functions\r\n    */\r\n    \r\n    /// @dev Calculates Keccak-256 hash of order with specified parameters.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @return Keccak-256 hash of order.\r\n    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\r\n        public\r\n        constant\r\n        returns (bytes32)\r\n    {}\r\n    \r\n     \r\n    /// @dev Calculates the sum of values already filled and cancelled for a given order.\r\n    /// @param orderHash The Keccak-256 hash of the given order.\r\n    /// @return Sum of values already filled and cancelled.\r\n    function getUnavailableTakerTokenAmount(bytes32 orderHash)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {}\r\n}\r\n\r\ncontract EtherDelta {\r\n  address public feeAccount; //the account that will receive fees\r\n  uint public feeTake; //percentage times (1 ether)\r\n  \r\n  function deposit() public payable {}\r\n\r\n  function withdraw(uint amount) public {}\r\n\r\n  function depositToken(address token, uint amount) public {}\r\n\r\n  function withdrawToken(address token, uint amount) public {}\r\n\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {}\r\n\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {}\r\n}\r\n\r\nlibrary EtherDeltaTrader {\r\n\r\n  address constant public ETHERDELTA_ADDR = 0x8d12a197cb00d4747a1fe03395095ce2a5cc6819; // EtherDelta contract address\r\n  \r\n  /// @dev Gets the address of EtherDelta contract\r\n  /// @return Address of EtherDelta Contract.\r\n  function getEtherDeltaAddresss() internal returns(address) {\r\n      return ETHERDELTA_ADDR;\r\n  }\r\n   \r\n  /// @dev Fills a sell order in EtherDelta.\r\n  /// @param orderAddresses Array of order's maker, makerToken, takerToken.\r\n  /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, expires and nonce.\r\n  /// @param exchangeFee Fee percentage of the exchange.\r\n  /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n  /// @param v ECDSA signature parameter v.\r\n  /// @param r ECDSA signature parameters r.\r\n  /// @param s ECDSA signature parameters s.\r\n  /// @return Total amount of takerToken filled in trade\r\n  function fillSellOrder(\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint exchangeFee,\r\n    uint fillTakerTokenAmount,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal returns(uint) {\r\n    \r\n    //Deposit ethers in EtherDelta\r\n    deposit(fillTakerTokenAmount);\r\n    \r\n    uint amountToTrade;\r\n    uint fee;\r\n      \r\n    //Substract EtherDelta fee\r\n    (amountToTrade, fee) = substractFee(exchangeFee, fillTakerTokenAmount);\r\n    \r\n    //Fill EtherDelta Order\r\n    trade(\r\n      orderAddresses,\r\n      orderValues, \r\n      amountToTrade,\r\n      v, \r\n      r, \r\n      s\r\n    );\r\n    \r\n    //Withdraw token from EtherDelta\r\n    withdrawToken(orderAddresses[1], getPartialAmount(orderValues[0], orderValues[1], amountToTrade));\r\n    \r\n    //Returns the amount of token obtained\r\n    return getPartialAmount(orderValues[0], orderValues[1], amountToTrade);\r\n \r\n  }\r\n  \r\n  /// @dev Fills a buy order in EtherDelta.\r\n  /// @param orderAddresses Array of order's maker, makerToken, takerToken.\r\n  /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, expires and nonce.\r\n  /// @param exchangeFee Fee percentage of the exchange.\r\n  /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n  /// @param v ECDSA signature parameter v.\r\n  /// @param r ECDSA signature parameters r.\r\n  /// @param s ECDSA signature parameters s.\r\n  /// @return Total amount of ethers filled in trade\r\n  function fillBuyOrder(\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint exchangeFee,\r\n    uint fillTakerTokenAmount,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal returns(uint) {\r\n    \r\n    //Deposit tokens in EtherDelta\r\n    depositToken(orderAddresses[2], fillTakerTokenAmount);\r\n    \r\n    uint amountToTrade;\r\n    uint fee;\r\n      \r\n    //Substract EtherDelta fee\r\n    (amountToTrade, fee) = substractFee(exchangeFee, fillTakerTokenAmount);\r\n\r\n    //Fill EtherDelta Order\r\n    trade(\r\n      orderAddresses,\r\n      orderValues, \r\n      amountToTrade,\r\n      v, \r\n      r, \r\n      s\r\n    );\r\n    \r\n    //Withdraw ethers obtained from EtherDelta\r\n    withdraw(getPartialAmount(orderValues[0], orderValues[1], amountToTrade));\r\n    \r\n    //Returns the amount of ethers obtained\r\n    return getPartialAmount(orderValues[0], orderValues[1], amountToTrade);\r\n  }\r\n  \r\n  /// @dev Trade an EtherDelta order.\r\n  /// @param orderAddresses Array of order's maker, makerToken, takerToken.\r\n  /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, expires and nonce.\r\n  /// @param amountToTrade Desired amount of takerToken to fill.\r\n  /// @param v ECDSA signature parameter v.\r\n  /// @param r ECDSA signature parameters r.\r\n  /// @param s ECDSA signature parameters s.\r\n  function trade(\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint amountToTrade,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal {\r\n      \r\n     //Fill EtherDelta Order\r\n     EtherDelta(ETHERDELTA_ADDR).trade(\r\n      orderAddresses[2], \r\n      orderValues[1], \r\n      orderAddresses[1], \r\n      orderValues[0], \r\n      orderValues[2], \r\n      orderValues[3], \r\n      orderAddresses[0], \r\n      v, \r\n      r, \r\n      s, \r\n      amountToTrade\r\n    );\r\n  }\r\n  \r\n  /// @dev Get the available amount of an EtherDelta order.\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param exchangeFee Fee percentage of the exchange.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  /// @return Available amount of the order.\r\n  function getAvailableAmount(\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint exchangeFee,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal returns(uint) {\r\n      \r\n    //If expired return 0 \r\n    if(block.number > orderValues[2])\r\n      return 0;\r\n      \r\n    //Fill EtherDelta Order\r\n    uint availableVolume = EtherDelta(ETHERDELTA_ADDR).availableVolume(\r\n      orderAddresses[2], \r\n      orderValues[1], \r\n      orderAddresses[1], \r\n      orderValues[0], \r\n      orderValues[2], \r\n      orderValues[3], \r\n      orderAddresses[0], \r\n      v, \r\n      r, \r\n      s\r\n    );\r\n    \r\n    //AvailableVolume adds the fee percentage (X - X * fee)\r\n    return getPartialAmount(availableVolume, SafeMath.safeSub(1 ether, exchangeFee), 1 ether);\r\n  }\r\n  \r\n  /// @dev Substracts the take fee from EtherDelta.\r\n  /// @param amount Amount to substract EtherDelta fee\r\n  /// @return Amount minus the EtherDelta fee.\r\n  function substractFee(uint feePercentage, uint amount) constant internal returns(uint, uint) {\r\n    uint fee = getPartialAmount(amount, 1 ether, feePercentage);\r\n    return (SafeMath.safeSub(amount, fee), fee);\r\n  }\r\n  \r\n  /// @dev Deposit ethers to EtherDelta.\r\n  /// @param amount Amount of ethers to deposit in EtherDelta\r\n  function deposit(uint amount) internal {\r\n    EtherDelta(ETHERDELTA_ADDR).deposit.value(amount)();\r\n  }\r\n  \r\n  /// @dev Deposit tokens to EtherDelta.\r\n  /// @param token Address of token to deposit in EtherDelta\r\n  /// @param amount Amount of tokens to deposit in EtherDelta\r\n  function depositToken(address token, uint amount) internal {\r\n    Token(token).approve(ETHERDELTA_ADDR, amount);\r\n    EtherDelta(ETHERDELTA_ADDR).depositToken(token, amount);\r\n  }\r\n  \r\n  /// @dev Withdraw ethers from EtherDelta\r\n  /// @param amount Amount of ethers to withdraw from EtherDelta\r\n  function withdraw(uint amount) internal { \r\n    EtherDelta(ETHERDELTA_ADDR).withdraw(amount);\r\n  }\r\n   \r\n  /// @dev Withdraw tokens from EtherDelta.\r\n  /// @param token Address of token to withdraw from EtherDelta\r\n  /// @param amount Amount of tokens to withdraw from EtherDelta\r\n  function withdrawToken(address token, uint amount) internal { \r\n    EtherDelta(ETHERDELTA_ADDR).withdrawToken(token, amount);\r\n  }\r\n  \r\n  \r\n  /// @dev Calculates partial value given a numerator and denominator.\r\n  /// @param numerator Numerator.\r\n  /// @param denominator Denominator.\r\n  /// @param target Value to calculate partial of.\r\n  /// @return Partial value of target.\r\n  function getPartialAmount(uint numerator, uint denominator, uint target)\r\n    public\r\n    constant\r\n    returns (uint)\r\n  {\r\n    return SafeMath.safeDiv(SafeMath.safeMul(numerator, target), denominator);\r\n  }\r\n\r\n}\r\n\r\nlibrary ZrxTrader {\r\n    \r\n  uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\r\n\r\n  address constant public ZRX_EXCHANGE_ADDR = 0x12459c951127e0c374ff9105dda097662a027093; // 0x Exchange contract address\r\n  address constant public TOKEN_TRANSFER_PROXY_ADDR = 0x8da0d80f5007ef1e431dd2127178d224e32c2ef4; // TokenTransferProxy contract address\r\n  address constant public WETH_ADDR = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2; // Wrapped ether address (WETH)\r\n  address constant public ZRX_TOKEN_ADDR = 0xe41d2489571d322189246dafa5ebde1f4699f498;\r\n  \r\n  /// @dev Gets the address of the Wrapped Ether contract\r\n  /// @return Address of Weth Contract.\r\n  function getWethAddress() internal returns(address) {\r\n      return WETH_ADDR;\r\n  }\r\n  \r\n  /// @dev Fills a sell order in 0x.\r\n  /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n  /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n  /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n  /// @param v ECDSA signature parameter v.\r\n  /// @param r ECDSA signature parameters r.\r\n  /// @param s ECDSA signature parameters s.\r\n  /// @return Total amount of takerToken filled in trade.\r\n  function fillSellOrder(\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint fillTakerTokenAmount,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal returns(uint) \r\n  {\r\n     \r\n    // Wrap ETH to WETH\r\n    depositWeth(fillTakerTokenAmount);\r\n    \r\n    // Allow 0x Transfer Token Proxy to transfer WETH\r\n    aproveToken(WETH_ADDR, fillTakerTokenAmount);\r\n    \r\n    //Allow ZRX Transfer Token Proxy to transfer the token for fees\r\n    aproveToken(ZRX_TOKEN_ADDR, getPartialAmount(fillTakerTokenAmount, orderValues[1], orderValues[3]));\r\n    \r\n    uint ethersSpent = Exchange(ZRX_EXCHANGE_ADDR).fillOrder(\r\n      orderAddresses,\r\n      orderValues,\r\n      fillTakerTokenAmount,\r\n      true,\r\n      v,\r\n      r,\r\n      s\r\n    );\r\n    \r\n    // Fill 0x order\r\n    return getPartialAmount(orderValues[0], orderValues[1], ethersSpent);\r\n    \r\n  }\r\n  \r\n  /// @dev Fills a buy order in 0x.\r\n  /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n  /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n  /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n  /// @param v ECDSA signature parameter v.\r\n  /// @param r ECDSA signature parameters r.\r\n  /// @param s ECDSA signature parameters s.\r\n  /// @return Total amount of takerToken filled in trade.\r\n  function fillBuyOrder(\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint fillTakerTokenAmount,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal returns(uint) \r\n  {\r\n    \r\n    //Allow 0x Transfer Token Proxy to transfer the token\r\n    aproveToken(orderAddresses[3], fillTakerTokenAmount);\r\n    \r\n    //Allow ZRX Transfer Token Proxy to transfer the token for fees\r\n    aproveToken(ZRX_TOKEN_ADDR, getPartialAmount(fillTakerTokenAmount, orderValues[1], orderValues[3]));\r\n    \r\n    // Fill 0x order\r\n    uint tokensSold = Exchange(ZRX_EXCHANGE_ADDR).fillOrder(\r\n      orderAddresses,\r\n      orderValues,\r\n      fillTakerTokenAmount,\r\n      true,\r\n      v,\r\n      r,\r\n      s\r\n    );\r\n    \r\n    uint ethersObtained = getPartialAmount(orderValues[0], orderValues[1], tokensSold);\r\n    \r\n    // Unwrap WETH to ETH\r\n    withdrawWeth(ethersObtained);\r\n    \r\n    return ethersObtained;\r\n  }\r\n  \r\n  /// @dev Get the available amount of a 0x order.\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  /// @return Available amount of a 0x order.\r\n  function getAvailableAmount(\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal returns(uint) {\r\n      \r\n      //If expired return 0 \r\n      if(block.timestamp >= orderValues[4])\r\n        return 0;\r\n          \r\n      bytes32 orderHash = Exchange(ZRX_EXCHANGE_ADDR).getOrderHash(orderAddresses, orderValues);\r\n      \r\n      uint unAvailable = Exchange(ZRX_EXCHANGE_ADDR).getUnavailableTakerTokenAmount(orderHash);\r\n  \r\n      //Gets the available amount acoording to 0x contract substracting takerTokenAmount with unavailable takerTokenAmount\r\n      uint availableByContract = SafeMath.safeSub(orderValues[1], unAvailable);\r\n      \r\n      //Gets the available amount according of the maker token balance\r\n      uint availableByBalance =  getPartialAmount(getBalance(orderAddresses[2], orderAddresses[0]), orderValues[0], orderValues[1]);\r\n      \r\n      //Gets the available amount according how much allowance of the token the maker has\r\n      uint availableByAllowance = getPartialAmount(getAllowance(orderAddresses[2], orderAddresses[0]), orderValues[0], orderValues[1]);\r\n    \r\n      //Get the available amount according to how much ZRX fee the maker can pay \r\n      uint zrxAmount = getAllowance(ZRX_TOKEN_ADDR, orderAddresses[0]);\r\n      uint availableByZRX = getPartialAmount(zrxAmount, orderValues[2], orderValues[1]);\r\n      \r\n      //Returns the min value of all available results\r\n      return SafeMath.min256(SafeMath.min256(SafeMath.min256(availableByContract, availableByBalance), availableByAllowance), availableByZRX);\r\n  }\r\n    \r\n  /// @dev Deposit WETH\r\n  /// @param amount Amount of ether to wrap.\r\n  function depositWeth(uint amount) internal {\r\n    EtherToken(WETH_ADDR).deposit.value(amount)();\r\n  }\r\n  \r\n  /// @dev Approve tokens to be transfered by 0x Token Transfer Proxy\r\n  /// @param token Address of token to approve.\r\n  /// @param amount Amount of tokens to approve.\r\n  function aproveToken(address token, uint amount) internal {\r\n    Token(token).approve(TOKEN_TRANSFER_PROXY_ADDR, amount);\r\n  }\r\n  \r\n  /// @dev Withdraw WETH\r\n  /// @param amount Amount of ether to unwrap.\r\n  function withdrawWeth(uint amount) internal { \r\n    EtherToken(WETH_ADDR).withdraw(amount);\r\n  }\r\n  \r\n  /// @dev Calculates partial value given a numerator and denominator.\r\n  /// @param numerator Numerator.\r\n  /// @param denominator Denominator.\r\n  /// @param target Value to calculate partial of.\r\n  /// @return Partial value of target.\r\n  function getPartialAmount(uint numerator, uint denominator, uint target) internal constant returns (uint)\r\n  {\r\n    return SafeMath.safeDiv(SafeMath.safeMul(numerator, target), denominator);\r\n  }\r\n\r\n  /// @dev Get token balance of an address.\r\n  /// @param token Address of token.\r\n  /// @param owner Address of owner.\r\n  /// @return Token balance of owner.\r\n  function getBalance(address token, address owner) internal constant returns (uint)\r\n  {\r\n    return Token(token).balanceOf.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner); // Limit gas to prevent reentrancy\r\n  }\r\n\r\n  /// @dev Get allowance of token given to TokenTransferProxy by an address.\r\n  /// @param token Address of token.\r\n  /// @param owner Address of owner.\r\n  /// @return Allowance of token given to TokenTransferProxy by owner.\r\n  function getAllowance(address token, address owner) internal constant returns (uint)\r\n  {\r\n    return Token(token).allowance.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner, TOKEN_TRANSFER_PROXY_ADDR); // Limit gas to prevent reentrancy\r\n  }\r\n  \r\n \r\n}\r\n\r\ncontract EasyTrade {\r\n    \r\n  string constant public VERSION = \"1.0.0\";\r\n  address constant public ZRX_TOKEN_ADDR = 0xe41d2489571d322189246dafa5ebde1f4699f498;\r\n  \r\n  address public admin; // Admin address\r\n  address public feeAccount; // Account that will receive the fee\r\n  uint public serviceFee; // Percentage times (1 ether)\r\n  uint public collectedFee = 0; // Total of fees accumulated\r\n \r\n  event FillSellOrder(address account, address token, uint tokens, uint ethers, uint tokensSold, uint ethersObtained, uint tokensRefunded);\r\n  event FillBuyOrder(address account, address token, uint tokens, uint ethers, uint tokensObtained, uint ethersSpent, uint ethersRefunded);\r\n  \r\n  modifier onlyAdmin() {\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n  \r\n  modifier onlyFeeAccount() {\r\n    require(msg.sender == feeAccount);\r\n    _;\r\n  }\r\n \r\n  function EasyTrade(\r\n    address admin_,\r\n    address feeAccount_,\r\n    uint serviceFee_) \r\n  {\r\n    admin = admin_;\r\n    feeAccount = feeAccount_;\r\n    serviceFee = serviceFee_;\r\n  } \r\n    \r\n  /// @dev For exchange contracts that send ethers back.\r\n  function() public payable { \r\n      //Only accepts payments from 0x Wrapped Ether or EtherDelta\r\n      require(msg.sender == ZrxTrader.getWethAddress() || msg.sender == EtherDeltaTrader.getEtherDeltaAddresss());\r\n  }\r\n\r\n  /// @dev Set the new admin. Only admin can set the new admin.\r\n  /// @param admin_ Address of the new admin.\r\n  function changeAdmin(address admin_) public onlyAdmin {\r\n    admin = admin_;\r\n  }\r\n  \r\n  /// @dev Set the new fee account. Only admin can set the new fee account.\r\n  /// @param feeAccount_ Address of the new fee account.\r\n  function changeFeeAccount(address feeAccount_) public onlyAdmin {\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  /// @dev Set the service fee. Only admin can set the new fee. Service fee can only be reduced, never increased\r\n  /// @param serviceFee_ Percentage times (1 ether).\r\n  function changeFeePercentage(uint serviceFee_) public onlyAdmin {\r\n    require(serviceFee_ < serviceFee);\r\n    serviceFee = serviceFee_;\r\n  }\r\n  \r\n  /// @dev Creates an order to sell a token. \r\n  /// @notice Needs first to call Token(tokend_address).approve(this, tokens_) so the contract can trade the tokens.\r\n  /// @param token Address of the token to sell.\r\n  /// @param tokensTotal Amount of the token to sell.\r\n  /// @param ethersTotal Amount of ethers to get.\r\n  /// @param exchanges Exchanges of each order (0: EtherDelta 1: 0x).\r\n  /// @param ethersTotal Amount of ethers to get.\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param exchangeFees Array of exchange fees to fill in orders.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  function createSellOrder(\r\n    address token, \r\n    uint tokensTotal, \r\n    uint ethersTotal,\r\n    uint8[] exchanges,\r\n    address[5][] orderAddresses,\r\n    uint[6][] orderValues,\r\n    uint[] exchangeFees,\r\n    uint8[] v,\r\n    bytes32[] r,\r\n    bytes32[] s\r\n  ) public\r\n  {\r\n    \r\n    //Transfer tokens to contract so it can sell them.\r\n    require(Token(token).transferFrom(msg.sender, this, tokensTotal));\r\n    \r\n    uint ethersObtained;\r\n    uint tokensSold;\r\n    uint tokensRefunded = tokensTotal;\r\n    \r\n    (ethersObtained, tokensSold) = fillOrdersForSellRequest(\r\n      tokensTotal,\r\n      exchanges,\r\n      orderAddresses,\r\n      orderValues,\r\n      exchangeFees,\r\n      v,\r\n      r,\r\n      s\r\n    );\r\n    \r\n    //We make sure that at least one order had some amount filled\r\n    require(ethersObtained > 0 && tokensSold >0);\r\n    \r\n    //Check that the price of what was sold is not smaller than the min agreed\r\n    require(SafeMath.safeDiv(ethersTotal, tokensTotal) <= SafeMath.safeDiv(ethersObtained, tokensSold));\r\n    \r\n    //Substracts the tokens sold\r\n    tokensRefunded = SafeMath.safeSub(tokensTotal, tokensSold);\r\n    \r\n    //Return tokens not sold \r\n    if(tokensRefunded > 0) \r\n     require(Token(token).transfer(msg.sender, tokensRefunded));\r\n    \r\n    //Send the ethersObtained\r\n    transfer(msg.sender, ethersObtained);\r\n    \r\n    FillSellOrder(msg.sender, token, tokensTotal, ethersTotal, tokensSold, ethersObtained, tokensRefunded);\r\n  }\r\n  \r\n  /// @dev Fills a sell order by synchronously executing exchange buy orders.\r\n  /// @param tokensTotal Total amount of tokens to sell.\r\n  /// @param exchanges Exchanges of each order (0: EtherDelta 1: 0x).\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param exchangeFees Array of exchange fees to fill in orders.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  /// @return Total amount of ethers obtained and total amount of tokens sold.\r\n  function fillOrdersForSellRequest(\r\n    uint tokensTotal,\r\n    uint8[] exchanges,\r\n    address[5][] orderAddresses,\r\n    uint[6][] orderValues,\r\n    uint[] exchangeFees,\r\n    uint8[] v,\r\n    bytes32[] r,\r\n    bytes32[] s\r\n  ) internal returns(uint, uint)\r\n  {\r\n    uint totalEthersObtained = 0;\r\n    uint tokensRemaining = tokensTotal;\r\n    \r\n    for (uint i = 0; i < orderAddresses.length; i++) {\r\n   \r\n      (totalEthersObtained, tokensRemaining) = fillOrderForSellRequest(\r\n         totalEthersObtained,\r\n         tokensRemaining,\r\n         exchanges[i],\r\n         orderAddresses[i],\r\n         orderValues[i],\r\n         exchangeFees[i],\r\n         v[i],\r\n         r[i],\r\n         s[i]\r\n      );\r\n\r\n    }\r\n    \r\n    //Substracts service fee\r\n    if(totalEthersObtained > 0) {\r\n      uint fee =  SafeMath.safeMul(totalEthersObtained, serviceFee) / (1 ether);\r\n      totalEthersObtained = collectServiceFee(SafeMath.min256(fee, totalEthersObtained), totalEthersObtained);\r\n    }\r\n    \r\n    //Returns ethers obtained\r\n    return (totalEthersObtained, SafeMath.safeSub(tokensTotal, tokensRemaining));\r\n  }\r\n  \r\n  /// @dev Fills a sell order with a buy order.\r\n  /// @param totalEthersObtained Total amount of ethers obtained so far.\r\n  /// @param initialTokensRemaining Total amount of tokens remaining to sell.\r\n  /// @param exchange 0: EtherDelta 1: 0x.\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param exchangeFee Exchange fees to fill the order.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  /// @return Total amount of ethers obtained and total amount of tokens remainint to sell.\r\n  function fillOrderForSellRequest(\r\n    uint totalEthersObtained,\r\n    uint initialTokensRemaining,\r\n    uint8 exchange,\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint exchangeFee,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n    ) internal returns(uint, uint)\r\n  {\r\n    uint ethersObtained = 0;\r\n    uint tokensRemaining = initialTokensRemaining;\r\n    \r\n    //Exchange fees should not be higher than 1% (in Wei)\r\n    require(exchangeFee < 10000000000000000);\r\n    \r\n    //Checks that there is enoughh amount to execute the trade\r\n    uint fillAmount = getFillAmount(\r\n      tokensRemaining,\r\n      exchange,\r\n      orderAddresses,\r\n      orderValues,\r\n      exchangeFee,\r\n      v,\r\n      r,\r\n      s\r\n    );\r\n    \r\n    if(fillAmount > 0) {\r\n          \r\n      //Substracts the amount to execute\r\n      tokensRemaining = SafeMath.safeSub(tokensRemaining, fillAmount);\r\n    \r\n      if(exchange == 0) {\r\n        //Executes EtherDelta buy order and returns the amount of ethers obtained, fullfill all or returns zero\r\n        ethersObtained = EtherDeltaTrader.fillBuyOrder(\r\n          orderAddresses,\r\n          orderValues,\r\n          exchangeFee,\r\n          fillAmount,\r\n          v,\r\n          r,\r\n          s\r\n        );    \r\n      } \r\n      else {\r\n        //Executes 0x buy order and returns the amount of ethers obtained, fullfill all or returns zero\r\n        ethersObtained = ZrxTrader.fillBuyOrder(\r\n          orderAddresses,\r\n          orderValues,\r\n          fillAmount,\r\n          v,\r\n          r,\r\n          s\r\n        );\r\n        \r\n        //If 0x, exchangeFee is collected by the contract to buy externally ZrxTrader\r\n        uint fee = SafeMath.safeMul(ethersObtained, exchangeFee) / (1 ether);\r\n        ethersObtained = collectServiceFee(fee, ethersObtained);\r\n    \r\n      }\r\n    }\r\n         \r\n    //Adds the amount of ethers obtained and tokens remaining\r\n    return (SafeMath.safeAdd(totalEthersObtained, ethersObtained), ethersObtained==0? initialTokensRemaining: tokensRemaining);\r\n   \r\n  }\r\n  \r\n  /// @dev Creates an order to buy a token. \r\n  /// @param token Address of the token to sell.\r\n  /// @param tokensTotal Amount of the token to sell.\r\n  /// @param exchanges Exchanges of each order (0: EtherDelta 1: 0x).\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param exchangeFees Array of exchange fees to fill in orders.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  function createBuyOrder(\r\n    address token, \r\n    uint tokensTotal,\r\n    uint8[] exchanges,\r\n    address[5][] orderAddresses,\r\n    uint[6][] orderValues,\r\n    uint[] exchangeFees,\r\n    uint8[] v,\r\n    bytes32[] r,\r\n    bytes32[] s\r\n  ) public payable \r\n  {\r\n    \r\n    \r\n    uint ethersTotal = msg.value;\r\n    uint tokensObtained;\r\n    uint ethersSpent;\r\n    uint ethersRefunded = ethersTotal;\r\n     \r\n    require(tokensTotal > 0 && msg.value > 0);\r\n    \r\n    (tokensObtained, ethersSpent) = fillOrdersForBuyRequest(\r\n      ethersTotal,\r\n      exchanges,\r\n      orderAddresses,\r\n      orderValues,\r\n      exchangeFees,\r\n      v,\r\n      r,\r\n      s\r\n    );\r\n    \r\n    //We make sure that at least one order had some amount filled\r\n    require(ethersSpent > 0 && tokensObtained >0);\r\n    \r\n    //Check that the price of what was bought is not greater than the max agreed\r\n    require(SafeMath.safeDiv(ethersTotal, tokensTotal) >= SafeMath.safeDiv(ethersSpent, tokensObtained));\r\n\r\n    //Substracts the ethers spent\r\n    ethersRefunded = SafeMath.safeSub(ethersTotal, ethersSpent);\r\n    \r\n    //Return ethers not spent \r\n    if(ethersRefunded > 0)\r\n     require(msg.sender.call.value(ethersRefunded)());\r\n   \r\n    //Send the tokens\r\n    transferToken(token, msg.sender, tokensObtained);\r\n    \r\n    FillBuyOrder(msg.sender, token, tokensTotal, ethersTotal, tokensObtained, ethersSpent, ethersRefunded);\r\n  }\r\n  \r\n  /// @dev Fills a buy order by synchronously executing exchange sell orders.\r\n  /// @param ethersTotal Total amount of ethers to spend.\r\n  /// @param exchanges Exchanges of each order (0: EtherDelta 1: 0x).\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param exchangeFees Array of exchange fees to fill in orders.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  /// @return Total of tokens obtained.\r\n  /// @return Total amount of tokens obtained and total amount of ethers spent.\r\n  function fillOrdersForBuyRequest(\r\n    uint ethersTotal,\r\n    uint8[] exchanges,\r\n    address[5][] orderAddresses,\r\n    uint[6][] orderValues,\r\n    uint[] exchangeFees,\r\n    uint8[] v,\r\n    bytes32[] r,\r\n    bytes32[] s\r\n  ) internal returns(uint, uint)\r\n  {\r\n    uint totalTokensObtained = 0;\r\n    uint ethersRemaining = ethersTotal;\r\n    \r\n    for (uint i = 0; i < orderAddresses.length; i++) {\r\n    \r\n      if(ethersRemaining > 0) {\r\n        (totalTokensObtained, ethersRemaining) = fillOrderForBuyRequest(\r\n          totalTokensObtained,\r\n          ethersRemaining,\r\n          exchanges[i],\r\n          orderAddresses[i],\r\n          orderValues[i],\r\n          exchangeFees[i],\r\n          v[i],\r\n          r[i],\r\n          s[i]\r\n        );\r\n      }\r\n    \r\n    }\r\n    \r\n    //Returns total of tokens obtained\r\n    return (totalTokensObtained, SafeMath.safeSub(ethersTotal, ethersRemaining));\r\n  }\r\n  \r\n  /// @dev Fills a buy order wtih a sell order.\r\n  /// @param totalTokensObtained Total amount of tokens obtained so far.\r\n  /// @param initialEthersRemaining Total amount of ethers remainint to spend.\r\n  /// @param exchange 0: EtherDelta 1: 0x.\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param exchangeFee Exchange fees to fill the order.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  /// @return Total of tokens obtained.\r\n  /// @return Total amount of tokens obtained and total amount of ethers remainint to spend.\r\n  function fillOrderForBuyRequest(\r\n    uint totalTokensObtained,\r\n    uint initialEthersRemaining,\r\n    uint8 exchange,\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint exchangeFee,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal returns(uint, uint)\r\n  {\r\n    uint tokensObtained = 0;\r\n    uint ethersRemaining = initialEthersRemaining;\r\n       \r\n    //Exchange fees should not be higher than 1% (in Wei)\r\n    require(exchangeFee < 10000000000000000);\r\n     \r\n    //Checks that there is enoughh amount to execute the trade\r\n    uint fillAmount = getFillAmount(\r\n      ethersRemaining,\r\n      exchange,\r\n      orderAddresses,\r\n      orderValues,\r\n      exchangeFee,\r\n      v,\r\n      r,\r\n      s\r\n    );\r\n   \r\n    if(fillAmount > 0) {\r\n     \r\n      //Substracts the amount to execute\r\n      ethersRemaining = SafeMath.safeSub(ethersRemaining, fillAmount);\r\n      \r\n      //Substract service fee\r\n      (fillAmount, ethersRemaining) = substractFee(serviceFee, fillAmount, ethersRemaining);\r\n         \r\n      if(exchange == 0) {\r\n        //Executes EtherDelta order, fee is paid directly to EtherDelta, fullfill all or returns zero\r\n        tokensObtained = EtherDeltaTrader.fillSellOrder(\r\n          orderAddresses,\r\n          orderValues,\r\n          exchangeFee,\r\n          fillAmount,\r\n          v,\r\n          r,\r\n          s\r\n        );\r\n      \r\n      } \r\n      else {\r\n          \r\n        //If 0x, exchangeFee is collected by the contract to buy externally ZrxTrader, fullfill all or returns zero\r\n        (fillAmount, ethersRemaining) = substractFee(exchangeFee, fillAmount, ethersRemaining);\r\n        \r\n        //Executes 0x order\r\n        tokensObtained = ZrxTrader.fillSellOrder(\r\n          orderAddresses,\r\n          orderValues,\r\n          fillAmount,\r\n          v,\r\n          r,\r\n          s\r\n        );\r\n      }\r\n    }\r\n        \r\n    //Returns total of tokens obtained and ethers remaining\r\n    return (SafeMath.safeAdd(totalTokensObtained, tokensObtained), tokensObtained==0? initialEthersRemaining: ethersRemaining);\r\n  }\r\n  \r\n  \r\n  /// @dev Get the amount to fill in the order.\r\n  /// @param amount Remaining amount of the order.\r\n  /// @param exchange 0: EtherDelta 1: 0x.\r\n  /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n  /// @param orderValues Array of uint arrays containing individual order values.\r\n  /// @param v Array ECDSA signature v parameters.\r\n  /// @param r Array of ECDSA signature r parameters.\r\n  /// @param s Array of ECDSA signature s parameters.\r\n  /// @return Min amount between the remaining and the order available.\r\n  function getFillAmount(\r\n    uint amount,\r\n    uint8 exchange,\r\n    address[5] orderAddresses,\r\n    uint[6] orderValues,\r\n    uint exchangeFee,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal returns(uint) \r\n  {\r\n    uint availableAmount;\r\n    if(exchange == 0) {\r\n      availableAmount = EtherDeltaTrader.getAvailableAmount(\r\n        orderAddresses,\r\n        orderValues,\r\n        exchangeFee,\r\n        v,\r\n        r,\r\n        s\r\n      );    \r\n    } \r\n    else {\r\n      availableAmount = ZrxTrader.getAvailableAmount(\r\n        orderAddresses,\r\n        orderValues,\r\n        v,\r\n        r,\r\n        s\r\n      );\r\n    }\r\n     \r\n    return SafeMath.min256(amount, availableAmount);\r\n  }\r\n  \r\n  /// @dev Substracts the service from the remaining amount if enough, if not from the amount to fill the order.\r\n  /// @param feePercentage Fee Percentage\r\n  /// @param fillAmount Amount to fill the order\r\n  /// @param ethersRemaining Remaining amount of ethers for other orders\r\n  /// @return Amount to fill the order and remaining amount\r\n  function substractFee(\r\n    uint feePercentage,\r\n    uint fillAmount,\r\n    uint ethersRemaining\r\n  ) internal returns(uint, uint) \r\n  {       \r\n      uint fee = SafeMath.safeMul(fillAmount, feePercentage) / (1 ether);\r\n      //If there is enough remaining to pay fee, it substracts the fee from the remaining\r\n      if(ethersRemaining >= fee)\r\n         ethersRemaining = collectServiceFee(fee, ethersRemaining);\r\n      else {\r\n         fillAmount = collectServiceFee(fee, SafeMath.safeAdd(fillAmount, ethersRemaining));\r\n         ethersRemaining = 0;\r\n      }\r\n      return (fillAmount, ethersRemaining);\r\n  }\r\n  \r\n  /// @dev Substracts the service fee in ethers.\r\n  /// @param fee Service fee in ethers\r\n  /// @param amount Amount to substract service fee\r\n  /// @return Amount minus service fee.\r\n  function collectServiceFee(uint fee, uint amount) internal returns(uint) {\r\n    collectedFee = SafeMath.safeAdd(collectedFee, fee);\r\n    return SafeMath.safeSub(amount, fee);\r\n  }\r\n  \r\n  /// @dev Transfer ethers to user account.\r\n  /// @param account User address where to send ethers.\r\n  /// @param amount Amount of ethers to send.\r\n  function transfer(address account, uint amount) internal {\r\n    require(account.send(amount));\r\n  }\r\n    \r\n  /// @dev Transfer token to user account.\r\n  /// @param token Address of token to transfer.\r\n  /// @param account User address where to transfer tokens.\r\n  /// @param amount Amount of tokens to transfer.\r\n  function transferToken(address token, address account, uint amount) internal {\r\n    require(Token(token).transfer(account, amount));\r\n  }\r\n   \r\n  /// @dev Withdraw collected service fees. Only by fee account.\r\n  /// @param amount Amount to withdraw\r\n  function withdrawFees(uint amount) public onlyFeeAccount {\r\n    require(collectedFee >= amount);\r\n    collectedFee = SafeMath.safeSub(collectedFee, amount);\r\n    require(feeAccount.send(amount));\r\n  }\r\n  \r\n   \r\n  /// @dev Withdraw contract ZRX in case new version is deployed. Only by admin.\r\n  /// @param amount Amount to withdraw\r\n  function withdrawZRX(uint amount) public onlyAdmin {\r\n    require(Token(ZRX_TOKEN_ADDR).transfer(admin, amount));\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZRX_TOKEN_ADDR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokensTotal\",\"type\":\"uint256\"},{\"name\":\"ethersTotal\",\"type\":\"uint256\"},{\"name\":\"exchanges\",\"type\":\"uint8[]\"},{\"name\":\"orderAddresses\",\"type\":\"address[5][]\"},{\"name\":\"orderValues\",\"type\":\"uint256[6][]\"},{\"name\":\"exchangeFees\",\"type\":\"uint256[]\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"createSellOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawZRX\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokensTotal\",\"type\":\"uint256\"},{\"name\":\"exchanges\",\"type\":\"uint8[]\"},{\"name\":\"orderAddresses\",\"type\":\"address[5][]\"},{\"name\":\"orderValues\",\"type\":\"uint256[6][]\"},{\"name\":\"exchangeFees\",\"type\":\"uint256[]\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"}],\"name\":\"createBuyOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"serviceFee_\",\"type\":\"uint256\"}],\"name\":\"changeFeePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"},{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"serviceFee_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethersObtained\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensRefunded\",\"type\":\"uint256\"}],\"name\":\"FillSellOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensObtained\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethersSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethersRefunded\",\"type\":\"uint256\"}],\"name\":\"FillBuyOrder\",\"type\":\"event\"}]","ContractName":"EasyTrade","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a065c23f48ae275c376eabc09b9b9b4557e57c14000000000000000000000000a065c23f48ae275c376eabc09b9b9b4557e57c140000000000000000000000000000000000000000000000000011c37937e08000","Library":"","SwarmSource":"bzzr://edb53d0cfbd0987e671d7ba31e05adee038dd37c23e2ab5882742386d4f4855d"}]}