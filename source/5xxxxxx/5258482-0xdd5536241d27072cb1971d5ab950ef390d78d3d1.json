{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n// File: contracts/ERC20Interface.sol\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/FeeBurnerInterface.sol\r\n\r\ninterface FeeBurnerInterface {\r\n    function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/PermissionGroups.sol\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Withdrawable.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers\r\n * @author Ilan Doron\r\n * @dev This allows to recover any tokens or Ethers received in a contract.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/FeeBurner.sol\r\n\r\ninterface BurnableToken {\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n    function burnFrom(address _from, uint256 _value) public returns (bool);\r\n}\r\n\r\n\r\ncontract FeeBurner is Withdrawable, FeeBurnerInterface, Utils {\r\n\r\n    mapping(address=>uint) public reserveFeesInBps;\r\n    mapping(address=>address) public reserveKNCWallet; //wallet holding knc per reserve. from here burn and send fees.\r\n    mapping(address=>uint) public walletFeesInBps; // wallet that is the source of tx is entitled so some fees.\r\n    mapping(address=>uint) public reserveFeeToBurn;\r\n    mapping(address=>uint) public feePayedPerReserve; // track burned fees and sent wallet fees per reserve.\r\n    mapping(address=>mapping(address=>uint)) public reserveFeeToWallet;\r\n    address public taxWallet;\r\n    uint public taxFeeBps = 0; // burned fees are taxed. % out of burned fees.\r\n\r\n    BurnableToken public knc;\r\n    address public kyberNetwork;\r\n    uint public kncPerETHRate = 300;\r\n\r\n    function FeeBurner(address _admin, BurnableToken kncToken, address _kyberNetwork) public {\r\n        require(_admin != address(0));\r\n        require(kncToken != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        admin = _admin;\r\n        knc = kncToken;\r\n    }\r\n\r\n    function setReserveData(address reserve, uint feesInBps, address kncWallet) public onlyAdmin {\r\n        require(feesInBps < 100); // make sure it is always < 1%\r\n        require(kncWallet != address(0));\r\n        reserveFeesInBps[reserve] = feesInBps;\r\n        reserveKNCWallet[reserve] = kncWallet;\r\n    }\r\n\r\n    function setWalletFees(address wallet, uint feesInBps) public onlyAdmin {\r\n        require(feesInBps < 10000); // under 100%\r\n        walletFeesInBps[wallet] = feesInBps;\r\n    }\r\n\r\n    function setTaxInBps(uint _taxFeeBps) public onlyAdmin {\r\n        require(_taxFeeBps < 10000); // under 100%\r\n        taxFeeBps = _taxFeeBps;\r\n    }\r\n\r\n    function setTaxWallet(address _taxWallet) public onlyAdmin {\r\n        require(_taxWallet != address(0));\r\n        taxWallet = _taxWallet;\r\n    }\r\n\r\n    function setKNCRate(uint rate) public onlyAdmin {\r\n        require(rate <= MAX_RATE);\r\n        kncPerETHRate = rate;\r\n    }\r\n\r\n    event AssignFeeToWallet(address reserve, address wallet, uint walletFee);\r\n    event AssignBurnFees(address reserve, uint burnFee);\r\n\r\n    function handleFees(uint tradeWeiAmount, address reserve, address wallet) public returns(bool) {\r\n        require(msg.sender == kyberNetwork);\r\n        require(tradeWeiAmount <= MAX_QTY);\r\n        require(kncPerETHRate <= MAX_RATE);\r\n\r\n        uint kncAmount = tradeWeiAmount * kncPerETHRate;\r\n        uint fee = kncAmount * reserveFeesInBps[reserve] / 10000;\r\n\r\n        uint walletFee = fee * walletFeesInBps[wallet] / 10000;\r\n        require(fee >= walletFee);\r\n        uint feeToBurn = fee - walletFee;\r\n\r\n        if (walletFee > 0) {\r\n            reserveFeeToWallet[reserve][wallet] += walletFee;\r\n            AssignFeeToWallet(reserve, wallet, walletFee);\r\n        }\r\n\r\n        if (feeToBurn > 0) {\r\n            AssignBurnFees(reserve, feeToBurn);\r\n            reserveFeeToBurn[reserve] += feeToBurn;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // this function is callable by anyone\r\n    event BurnAssignedFees(address indexed reserve, address sender, uint quantity);\r\n    event SendTaxFee(address indexed reserve, address sender, address taxWallet, uint quantity);\r\n\r\n    function burnReserveFees(address reserve) public {\r\n        uint burnAmount = reserveFeeToBurn[reserve];\r\n        uint taxToSend = 0;\r\n        require(burnAmount > 2);\r\n        reserveFeeToBurn[reserve] = 1; // leave 1 twei to avoid spikes in gas fee\r\n        if (taxWallet != address(0) && taxFeeBps != 0) {\r\n            taxToSend = (burnAmount - 1) * taxFeeBps / 10000;\r\n            require(burnAmount - 1 > taxToSend);\r\n            burnAmount -= taxToSend;\r\n            if (taxToSend > 0) {\r\n                require (knc.transferFrom(reserveKNCWallet[reserve], taxWallet, taxToSend));\r\n                SendTaxFee(reserve, msg.sender, taxWallet, taxToSend);\r\n            }\r\n        }\r\n        require(knc.burnFrom(reserveKNCWallet[reserve], burnAmount - 1));\r\n\r\n        //update reserve \"payments\" so far\r\n        feePayedPerReserve[reserve] += (taxToSend + burnAmount - 1);\r\n\r\n        BurnAssignedFees(reserve, msg.sender, (burnAmount - 1));\r\n    }\r\n\r\n    event SendWalletFees(address indexed wallet, address reserve, address sender);\r\n\r\n    // this function is callable by anyone\r\n    function sendFeeToWallet(address wallet, address reserve) public {\r\n        uint feeAmount = reserveFeeToWallet[reserve][wallet];\r\n        require(feeAmount > 1);\r\n        reserveFeeToWallet[reserve][wallet] = 1; // leave 1 twei to avoid spikes in gas fee\r\n        require(knc.transferFrom(reserveKNCWallet[reserve], wallet, feeAmount - 1));\r\n\r\n        feePayedPerReserve[reserve] += (feeAmount - 1);\r\n        SendWalletFees(wallet, reserve, msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts/wrapperContracts/WrapperBase.sol\r\n\r\ncontract WrapperBase is Withdrawable {\r\n\r\n    PermissionGroups public wrappedContract;\r\n\r\n    struct DataTracker {\r\n        address [] approveSignatureArray;\r\n        uint lastSetNonce;\r\n    }\r\n\r\n    DataTracker[] internal dataInstances;\r\n\r\n    function WrapperBase(PermissionGroups _wrappedContract, address _admin, uint _numDataInstances) public {\r\n        require(_wrappedContract != address(0));\r\n        require(_admin != address(0));\r\n        wrappedContract = _wrappedContract;\r\n        admin = _admin;\r\n\r\n        for (uint i = 0; i < _numDataInstances; i++){\r\n            addDataInstance();\r\n        }\r\n    }\r\n\r\n    function claimWrappedContractAdmin() public onlyOperator {\r\n        wrappedContract.claimAdmin();\r\n    }\r\n\r\n    function transferWrappedContractAdmin (address newAdmin) public onlyAdmin {\r\n        wrappedContract.transferAdmin(newAdmin);\r\n    }\r\n\r\n    function addDataInstance() internal {\r\n        address[] memory add = new address[](0);\r\n        dataInstances.push(DataTracker(add, 0));\r\n    }\r\n\r\n    function setNewData(uint dataIndex) internal {\r\n        require(dataIndex < dataInstances.length);\r\n        dataInstances[dataIndex].lastSetNonce++;\r\n        dataInstances[dataIndex].approveSignatureArray.length = 0;\r\n    }\r\n\r\n    function addSignature(uint dataIndex, uint signedNonce, address signer) internal returns(bool allSigned) {\r\n        require(dataIndex < dataInstances.length);\r\n        require(dataInstances[dataIndex].lastSetNonce == signedNonce);\r\n\r\n        for(uint i = 0; i < dataInstances[dataIndex].approveSignatureArray.length; i++) {\r\n            if (signer == dataInstances[dataIndex].approveSignatureArray[i]) revert();\r\n        }\r\n        dataInstances[dataIndex].approveSignatureArray.push(signer);\r\n\r\n        if (dataInstances[dataIndex].approveSignatureArray.length == operatorsGroup.length) {\r\n            allSigned = true;\r\n        } else {\r\n            allSigned = false;\r\n        }\r\n    }\r\n\r\n    function getDataTrackingParameters(uint index) internal view returns (address[], uint) {\r\n        require(index < dataInstances.length);\r\n        return(dataInstances[index].approveSignatureArray, dataInstances[index].lastSetNonce);\r\n    }\r\n}\r\n\r\n// File: contracts/wrapperContracts/WrapFeeBurner.sol\r\n\r\n//import \"../Withdrawable.sol\";\r\n\r\n\r\n\r\n\r\ncontract WrapFeeBurner is WrapperBase {\r\n\r\n    FeeBurner private feeBurnerContract;\r\n\r\n    //knc rate range\r\n    struct KncPerEth {\r\n        uint minRate;\r\n        uint maxRate;\r\n        uint pendingMinRate;\r\n        uint pendingMaxRate;\r\n    }\r\n\r\n    KncPerEth private kncPerEth;\r\n\r\n    //add reserve pending data\r\n    struct AddReserveData {\r\n        address reserve;\r\n        uint    feeBps;\r\n        address kncWallet;\r\n    }\r\n\r\n    AddReserveData private addReserve;\r\n\r\n    //wallet fee parameters\r\n    struct WalletFee {\r\n        address wAddress;\r\n        uint feeBps;\r\n    }\r\n\r\n    WalletFee private walletFee;\r\n\r\n    //tax pending parameters\r\n    struct TaxData {\r\n        address wallet;\r\n        uint    feeBps;\r\n    }\r\n\r\n    TaxData private taxData;\r\n    \r\n    //data indexes\r\n    uint private constant KNC_RATE_RANGE_INDEX = 0;\r\n    uint private constant ADD_RESERVE_INDEX = 1;\r\n    uint private constant WALLET_FEE_INDEX = 2;\r\n    uint private constant TAX_DATA_INDEX = 3;\r\n    uint private constant LAST_DATA_INDEX = 4;\r\n\r\n    //general functions\r\n    function WrapFeeBurner(FeeBurner _feeBurner, address _admin) public\r\n        WrapperBase(PermissionGroups(address(_feeBurner)), _admin, LAST_DATA_INDEX)\r\n    {\r\n        require(_feeBurner != address(0));\r\n        feeBurnerContract = _feeBurner;\r\n    }\r\n\r\n    // knc rate handling\r\n    //////////////////////\r\n    function setPendingKNCRateRange(uint minRate, uint maxRate) public onlyOperator {\r\n        require(minRate < maxRate);\r\n        require(minRate > 0);\r\n\r\n        //update data tracking\r\n        setNewData(KNC_RATE_RANGE_INDEX);\r\n\r\n        kncPerEth.pendingMinRate = minRate;\r\n        kncPerEth.pendingMaxRate = maxRate;\r\n    }\r\n\r\n    function approveKNCRateRange(uint nonce) public onlyOperator {\r\n        if (addSignature(KNC_RATE_RANGE_INDEX, nonce, msg.sender)) {\r\n            // can perform operation.\r\n            kncPerEth.minRate = kncPerEth.pendingMinRate;\r\n            kncPerEth.maxRate = kncPerEth.pendingMaxRate;\r\n        }\r\n    }\r\n\r\n    function getPendingKNCRateRange() public view returns(uint minRate, uint maxRate, uint nonce) {\r\n        address[] memory signatures;\r\n        minRate = kncPerEth.pendingMinRate;\r\n        maxRate = kncPerEth.pendingMaxRate;\r\n        (signatures, nonce) = getDataTrackingParameters(KNC_RATE_RANGE_INDEX);\r\n\r\n        return(minRate, maxRate, nonce);\r\n    }\r\n\r\n    function getKNCRateRange() public view returns(uint minRate, uint maxRate) {\r\n        minRate = kncPerEth.minRate;\r\n        maxRate = kncPerEth.maxRate;\r\n        return(minRate, maxRate);\r\n    }\r\n\r\n    function setKNCPerEthRate(uint kncPerEther) public onlyOperator {\r\n        require(kncPerEther >= kncPerEth.minRate);\r\n        require(kncPerEther <= kncPerEth.maxRate);\r\n        feeBurnerContract.setKNCRate(kncPerEther);\r\n    }\r\n\r\n    function getKNCRateRangeSignatures() public view returns (address[] signatures) {\r\n        uint nonce;\r\n        (signatures, nonce) = getDataTrackingParameters(KNC_RATE_RANGE_INDEX);\r\n        return(signatures);\r\n    }\r\n\r\n    //set reserve data\r\n    //////////////////\r\n    function setPendingReserveData(address _reserve, uint feeBps, address kncWallet) public onlyOperator {\r\n        require(_reserve != address(0));\r\n        require(kncWallet != address(0));\r\n        require(feeBps > 0);\r\n\r\n        addReserve.reserve = _reserve;\r\n        addReserve.feeBps = feeBps;\r\n        addReserve.kncWallet = kncWallet;\r\n        setNewData(ADD_RESERVE_INDEX);\r\n    }\r\n    \r\n    function approveAddReserveData(uint nonce) public onlyOperator {\r\n        if (addSignature(ADD_RESERVE_INDEX, nonce, msg.sender)) {\r\n            // can perform operation.\r\n            feeBurnerContract.setReserveData(addReserve.reserve, addReserve.feeBps, addReserve.kncWallet);\r\n        }\r\n    }\r\n\r\n    function getPendingAddReserveData() public view\r\n        returns(address _reserve, uint feeBps, address kncWallet, uint nonce)\r\n    {\r\n        address[] memory signatures;\r\n        (signatures, nonce) = getDataTrackingParameters(ADD_RESERVE_INDEX);\r\n        return(addReserve.reserve, addReserve.feeBps, addReserve.kncWallet, nonce);\r\n    }\r\n\r\n    function getAddReserveSignatures() public view returns (address[] signatures) {\r\n        uint nonce;\r\n        (signatures, nonce) = getDataTrackingParameters(ADD_RESERVE_INDEX);\r\n        return(signatures);\r\n    }\r\n\r\n    //wallet fee\r\n    /////////////\r\n    function setPendingWalletFee(address wallet, uint feeInBps) public onlyOperator {\r\n        require(wallet != address(0));\r\n        require(feeInBps > 0);\r\n        walletFee.wAddress = wallet;\r\n        walletFee.feeBps = feeInBps;\r\n        setNewData(WALLET_FEE_INDEX);\r\n    }\r\n\r\n    function approveWalletFeeData(uint nonce) public onlyOperator {\r\n        if (addSignature(WALLET_FEE_INDEX, nonce, msg.sender)) {\r\n            // can perform operation.\r\n            feeBurnerContract.setWalletFees(walletFee.wAddress, walletFee.feeBps);\r\n        }\r\n    }\r\n\r\n    function getPendingWalletFeeData() public view returns(address wallet, uint feeBps, uint nonce) {\r\n        address[] memory signatures;\r\n        (signatures, nonce) = getDataTrackingParameters(WALLET_FEE_INDEX);\r\n        return(walletFee.wAddress, walletFee.feeBps, nonce);\r\n    }\r\n\r\n    function getWalletFeeSignatures() public view returns (address[] signatures) {\r\n        uint nonce;\r\n        (signatures, nonce) = getDataTrackingParameters(WALLET_FEE_INDEX);\r\n        return(signatures);\r\n    }\r\n\r\n    //tax parameters\r\n    ////////////////\r\n    function setPendingTaxParameters(address _taxWallet, uint _taxFeeBps) public onlyOperator {\r\n        require(_taxWallet != address(0));\r\n        require(_taxFeeBps > 0);\r\n\r\n        taxData.wallet = _taxWallet;\r\n        taxData.feeBps = _taxFeeBps;\r\n        setNewData(TAX_DATA_INDEX);\r\n    }\r\n\r\n    function approveTaxData(uint nonce) public onlyOperator {\r\n        if (addSignature(TAX_DATA_INDEX, nonce, msg.sender)) {\r\n            // can perform operation.\r\n            feeBurnerContract.setTaxInBps(taxData.feeBps);\r\n            feeBurnerContract.setTaxWallet(taxData.wallet);\r\n        }\r\n    }\r\n\r\n    function getPendingTaxData() public view returns(address wallet, uint feeBps, uint nonce) {\r\n        address[] memory signatures;\r\n        (signatures, nonce) = getDataTrackingParameters(TAX_DATA_INDEX);\r\n        return(taxData.wallet, taxData.feeBps, nonce);\r\n    }\r\n\r\n    function getTaxDataSignatures() public view returns (address[] signatures) {\r\n        uint nonce;\r\n        (signatures, nonce) = getDataTrackingParameters(TAX_DATA_INDEX);\r\n        return(signatures);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"claimWrappedContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"approveTaxData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKNCRateRangeSignatures\",\"outputs\":[{\"name\":\"signatures\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPendingAddReserveData\",\"outputs\":[{\"name\":\"_reserve\",\"type\":\"address\"},{\"name\":\"feeBps\",\"type\":\"uint256\"},{\"name\":\"kncWallet\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPendingKNCRateRange\",\"outputs\":[{\"name\":\"minRate\",\"type\":\"uint256\"},{\"name\":\"maxRate\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"approveWalletFeeData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minRate\",\"type\":\"uint256\"},{\"name\":\"maxRate\",\"type\":\"uint256\"}],\"name\":\"setPendingKNCRateRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taxWallet\",\"type\":\"address\"},{\"name\":\"_taxFeeBps\",\"type\":\"uint256\"}],\"name\":\"setPendingTaxParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferWrappedContractAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPendingWalletFeeData\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"feeBps\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddReserveSignatures\",\"outputs\":[{\"name\":\"signatures\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKNCRateRange\",\"outputs\":[{\"name\":\"minRate\",\"type\":\"uint256\"},{\"name\":\"maxRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserve\",\"type\":\"address\"},{\"name\":\"feeBps\",\"type\":\"uint256\"},{\"name\":\"kncWallet\",\"type\":\"address\"}],\"name\":\"setPendingReserveData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"feeInBps\",\"type\":\"uint256\"}],\"name\":\"setPendingWalletFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"kncPerEther\",\"type\":\"uint256\"}],\"name\":\"setKNCPerEthRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"approveAddReserveData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWalletFeeSignatures\",\"outputs\":[{\"name\":\"signatures\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTaxDataSignatures\",\"outputs\":[{\"name\":\"signatures\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPendingTaxData\",\"outputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"feeBps\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wrappedContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"approveKNCRateRange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_feeBurner\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]","ContractName":"WrapFeeBurner","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b2cb365d803ad914e63ea49c95ec663715c2f673000000000000000000000000951b7455365a598cd5e8d28486bf75f90dbb87d0","Library":"","SwarmSource":"bzzr://5a536c11581dc0de59bbcd84e6c927464832ea5f1124b5edd78aeb7494c2f0ba"}]}