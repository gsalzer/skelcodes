{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n/*\r\n * Aethia egg giveaway.\r\n *\r\n * Every day, for a period of seven days, starting February 2nd 12:00:00 UTC,\r\n * this contract is allowed to distribute a maximum of one-hundred-and-twenty\r\n * (120) common Ethergotchi eggs, for a total of 820 eggs.\r\n *\r\n * These 120 eggs are divided over the four (4) slots of six (6) hours that\r\n * make up each day. Every six hours, thirty (30) common Ethergotchi eggs are\r\n * available for free (excluding the gas cost of a transaction).\r\n *\r\n * Eggs that remain at the end of a time slot are not transferred to the next\r\n * time slot.\r\n */\r\ncontract EggGiveaway {\r\n\r\n    /*\r\n     * The start and end dates respectively convert to the following\r\n     * timestamps:\r\n     *  START_DATE  => February 2nd, 12:00:00 UTC\r\n     *  END_DATE    => February 9th, 11:59:59 UTC\r\n     */\r\n    uint256 constant START_DATE = 1517572800;\r\n    uint256 constant END_DATE = 1518177600;\r\n\r\n    /*\r\n     * The amount of seconds within a single time slot.\r\n     *\r\n     * This is set to a total of six hours:\r\n     *      6 x 60 x 60 = 21600\r\n     */\r\n    uint16 constant SLOT_DURATION_IN_SECONDS = 21600;\r\n\r\n    /*\r\n     * Remaining free eggs per time slot.\r\n     *\r\n     * The structure is as follows:\r\n     * {\r\n     *  0   => 30,  February 2nd, 12:00:00 UTC until February 2nd, 17:59:59 UTC\r\n     *  1   => 30,  February 2nd, 18:00:00 UTC until February 2nd, 23:59:59 UTC\r\n     *  2   => 30,  February 3rd, 00:00:00 UTC until February 3rd, 05:59:59 UTC\r\n     *  3   => 30,  February 3rd, 06:00:00 UTC until February 3rd, 11:59:59 UTC\r\n     *  4   => 30,  February 3rd, 12:00:00 UTC until February 3rd, 17:59:59 UTC\r\n     *  5   => 30,  February 3rd, 18:00:00 UTC until February 3rd, 23:59:59 UTC\r\n     *  6   => 30,  February 4th, 00:00:00 UTC until February 4th, 05:59:59 UTC\r\n     *  7   => 30,  February 4th, 06:00:00 UTC until February 4th, 11:59:59 UTC\r\n     *  8   => 30,  February 4th, 12:00:00 UTC until February 4th, 17:59:59 UTC\r\n     *  9   => 30,  February 4th, 18:00:00 UTC until February 4th, 23:59:59 UTC\r\n     *  10  => 30,  February 5th, 00:00:00 UTC until February 5th, 05:59:59 UTC\r\n     *  11  => 30,  February 5th, 06:00:00 UTC until February 5th, 11:59:59 UTC\r\n     *  12  => 30,  February 5th, 12:00:00 UTC until February 5th, 17:59:59 UTC\r\n     *  13  => 30,  February 5th, 18:00:00 UTC until February 5th, 23:59:59 UTC\r\n     *  14  => 30,  February 6th, 00:00:00 UTC until February 6th, 05:59:59 UTC\r\n     *  15  => 30,  February 6th, 06:00:00 UTC until February 6th, 11:59:59 UTC\r\n     *  16  => 30,  February 6th, 12:00:00 UTC until February 6th, 17:59:59 UTC\r\n     *  17  => 30,  February 6th, 18:00:00 UTC until February 6th, 23:59:59 UTC\r\n     *  18  => 30,  February 7th, 00:00:00 UTC until February 7th, 05:59:59 UTC\r\n     *  19  => 30,  February 7th, 06:00:00 UTC until February 7th, 11:59:59 UTC\r\n     *  20  => 30,  February 7th, 12:00:00 UTC until February 7th, 17:59:59 UTC\r\n     *  21  => 30,  February 7th, 18:00:00 UTC until February 7th, 23:59:59 UTC\r\n     *  22  => 30,  February 8th, 00:00:00 UTC until February 8th, 05:59:59 UTC\r\n     *  23  => 30,  February 8th, 06:00:00 UTC until February 8th, 11:59:59 UTC\r\n     *  24  => 30,  February 8th, 12:00:00 UTC until February 8th, 17:59:59 UTC\r\n     *  25  => 30,  February 8th, 18:00:00 UTC until February 8th, 23:59:59 UTC\r\n     *  26  => 30,  February 9th, 00:00:00 UTC until February 8th, 05:59:59 UTC\r\n     *  27  => 30,  February 9th, 06:00:00 UTC until February 8th, 11:59:59 UTC\r\n     * }\r\n     */\r\n    mapping (uint8 => uint8) remainingFreeEggs;\r\n\r\n    /*\r\n     * Egg owners\r\n     *\r\n     * This is a mapping containing all owners of free eggs. While this does\r\n     * not prevent people from using multiple addresses to acquire multiple\r\n     * eggs, it does increase the difficulty slightly.\r\n     */\r\n    mapping (address => bool) eggOwners;\r\n\r\n    /*\r\n     * Store egg retrieval event on the blockchain.\r\n     *\r\n     * For audit and logging purposes, all acquisitions of Ethergotchi eggs are\r\n     * logged by acquirer and acquisition date.\r\n     */\r\n    event LogEggAcquisition(address indexed _acquirer, uint256 indexed _date);\r\n\r\n    /*\r\n     * The contract constructor.\r\n     * \r\n     * This generates all available free eggs per time slot by calculating the\r\n     * total amount of seconds within the entire giveaway period, and the number\r\n     * of time slots within this period.\r\n     *\r\n     * Each time slot is then assigned thirty (30) eggs.\r\n     */\r\n    function EggGiveaway() public {\r\n        uint256 secondsInGiveawayPeriod = END_DATE - START_DATE;\r\n        uint8 timeSlotCount = uint8(\r\n            secondsInGiveawayPeriod / SLOT_DURATION_IN_SECONDS\r\n        );\r\n\r\n        for (uint8 i = 0; i < timeSlotCount; i++) {\r\n            remainingFreeEggs[i] = 30;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Acquire free egg from the egg giveaway contract.\r\n     *\r\n     * To acquire an egg, a few conditions have to be met:\r\n     *  1. The sender is not allowed to send Ether. The game is free to play.\r\n     *  2. The transaction must occur within the giveaway period, as specified\r\n     *     at the top of this file.\r\n     *  3. The sender must not already have acquired a free egg.\r\n     *  4. There must be an availability of at least one (1) for the time slot\r\n     *     the transaction occurs in.\r\n     */\r\n    function acquireFreeEgg() payable external {\r\n        require(msg.value == 0);\r\n        require(START_DATE <= now && now < END_DATE);\r\n        require(eggOwners[msg.sender] == false);\r\n\r\n        uint8 currentTimeSlot = getTimeSlot(now);\r\n\r\n        require(remainingFreeEggs[currentTimeSlot] > 0);\r\n\r\n        remainingFreeEggs[currentTimeSlot] -= 1;\r\n        eggOwners[msg.sender] = true;\r\n\r\n        LogEggAcquisition(msg.sender, now);\r\n    }\r\n\r\n    /*\r\n     * Fallback payable method.\r\n     *\r\n     * This is in the case someone calls the contract without specifying the\r\n     * correct method to call. This method will ensure the failure of a\r\n     * transaction that was wrongfully executed.\r\n     */\r\n    function () payable external {\r\n        revert();\r\n    }\r\n\r\n    /*\r\n     * Calculates the time slot corresponding to the given UNIX timestamp.\r\n     *\r\n     * The time slot is calculated by subtracting the current date and time in\r\n     * seconds from the contract starting date and time in seconds. This is then\r\n     * divided by the number of seconds within a time slot, and floored, to get\r\n     * the correct time slot.\r\n     */\r\n    function getTimeSlot(uint256 _timestamp) private pure returns (uint8) {\r\n        uint256 secondsSinceGiveawayStart = _timestamp - START_DATE;\r\n        \r\n        return uint8(secondsSinceGiveawayStart / SLOT_DURATION_IN_SECONDS);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"acquireFreeEgg\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_acquirer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"LogEggAcquisition\",\"type\":\"event\"}]","ContractName":"EggGiveaway","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://09d9096d22395b9b443d5933f54c0f0bec5015079e258072ee01a5a9767b44d0"}]}