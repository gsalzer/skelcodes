{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.22;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ninterface Token {\r\n    function transfer(address _to, uint256 _amount) public returns (bool success);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function decimals()public view returns (uint8);\r\n}\r\n\r\n/**\r\n * @title Vault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Funds will be transferred to owner once sale ends\r\n */\r\ncontract Vault is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    enum State { Active, Closed }\r\n\r\n    mapping (address => uint256) public deposited;\r\n    address public wallet;\r\n    State public state;\r\n\r\n    event Closed();\r\n    event withdrawn(address _wallet);\r\n    function Vault(address _wallet) public {\r\n        require(_wallet != 0x0);\r\n        wallet = _wallet;\r\n        state = State.Active;\r\n    }\r\n\r\n    function deposit(address investor) public onlyOwner  payable {\r\n        require(state == State.Active);\r\n        deposited[investor] = deposited[investor].add(msg.value);\r\n    }\r\n\r\n    function close() public onlyOwner {\r\n        require(state == State.Active);\r\n        state = State.Closed;\r\n        Closed();\r\n    }\r\n\r\n    function withdrawToWallet() onlyOwner public{\r\n    require(state == State.Closed);\r\n    wallet.transfer(this.balance);\r\n    withdrawn(wallet);\r\n  }\r\n}\r\n\r\n\r\ncontract MIOTCrowdsales is Ownable{\r\n      using SafeMath for uint256;\r\n      \r\n      //Token to be used for this sale\r\n      Token public token;\r\n      \r\n      //All funds will go into this vault\r\n      Vault public vault;\r\n      \r\n      //Total tokens which is on for sale\r\n      uint256 public crowdSaleHardCap;\r\n      \r\n      \r\n      //There can be 5 tiers and it will contain info about each tier\r\n      struct TierInfo{\r\n          uint256 hardcap;\r\n          uint256 startTime;\r\n          uint256 endTime;\r\n          uint256 rate;\r\n          uint8 bonusPercentage;\r\n          uint256 weiRaised;\r\n      }\r\n      \r\n      //info of each tier\r\n      TierInfo[] public tiers;\r\n      \r\n      //Total funding\r\n      uint256 public totalFunding;\r\n      \r\n      uint8 public noOfTiers;\r\n      \r\n      uint256 public tokensSold;\r\n    \r\n      //Keep track whether sales is active or not\r\n      bool public salesActive;\r\n      \r\n      //Keep track of whether the sale has ended or not\r\n      bool public saleEnded;\r\n      \r\n      bool public unspentCreditsWithdrawn;\r\n      \r\n      //to make sure contract is poweredup only once\r\n      bool contractPoweredUp = false;\r\n      \r\n      //Event to trigger Sale stop\r\n      event SaleStopped(address _owner, uint256 time);\r\n      \r\n      //Event to trigger normal flow of sale end\r\n      event Finalized(address _owner, uint256 time);\r\n    \r\n     /**\r\n     * event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param beneficiary who got the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     */\r\n     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n    \r\n    //modifiers    \r\n    modifier _saleActive(){\r\n        require(salesActive);\r\n        _;\r\n    }\r\n  \r\n     modifier nonZeroAddress(address _to) {\r\n        require(_to != 0x0);\r\n        _;\r\n    }\r\n    \r\n    modifier nonZeroEth() {\r\n        require(msg.value > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier _saleEnded() {\r\n        require(saleEnded);\r\n        _;\r\n    }\r\n    \r\n    modifier tiersEmpty(){\r\n        require(noOfTiers==0);\r\n        _;\r\n    }\r\n    \r\n    function MIOTCrowdsales(address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\r\n        token = Token(_tokenToBeUsed);\r\n        vault = new Vault(_wallet);\r\n    }\r\n    \r\n    /**\r\n    *     @dev Check if sale contract has enough tokens on its account balance \r\n    *     to reward all possible participations within sale period\r\n    */\r\n    function powerUpContract() external onlyOwner {\r\n        \r\n        require(!contractPoweredUp);\r\n        \r\n        // Contract should not be powered up previously\r\n        require(!salesActive);\r\n\r\n        // Contract should have enough Parsec credits\r\n        require(token.balanceOf(this) >= crowdSaleHardCap);\r\n        \r\n        //check whether tier information has been entered\r\n        require(noOfTiers>0 && tiers.length==noOfTiers);\r\n      \r\n        //activate the sale process\r\n        salesActive=true;\r\n        \r\n        contractPoweredUp = true;\r\n    }\r\n    \r\n    //for Emergency stop of the sale\r\n    function emergencyStop() public onlyOwner _saleActive{\r\n        salesActive = false;\r\n        saleEnded = true;    \r\n        vault.close();\r\n        SaleStopped(msg.sender, now);\r\n    }\r\n    \r\n    /**\r\n   * @dev Must be called after sale ends, to do some extra finalization\r\n   * work. Calls the contract's finalization function.\r\n   */\r\n    function finalize()public onlyOwner _saleActive{\r\n        require(saleTimeOver());\r\n        salesActive = false;\r\n        saleEnded = true;\r\n        vault.close();\r\n        Finalized(msg.sender, now);\r\n    }\r\n    \r\n      // @return true if all the tiers has been ended\r\n  function saleTimeOver() public view returns (bool) {\r\n      if(noOfTiers==0){\r\n          //since no tiers has been provided yet, hence sales has not started to end\r\n          return false;\r\n      }\r\n      //If last tier has ended, it mean all tiers are finished\r\n    return now > tiers[noOfTiers-1].endTime;\r\n  }\r\n  \r\n    //if crowdsales is over, the money rasied should be transferred to the wallet address\r\n  function withdrawFunds() public onlyOwner _saleEnded{\r\n  \r\n      vault.withdrawToWallet();\r\n  }\r\n  \r\n  /**\r\n  * @dev Can be called only once. The method to allow owner to set tier information\r\n  * @param _noOfTiers The integer to set number of tiers\r\n  * @param _startTimes The array containing start time of each tier\r\n  * @param _endTimes The array containing end time of each tier\r\n  * @param _hardCaps The array containing hard cap for each tier\r\n  * @param _rates The array containing number of tokens per ether for each tier\r\n  * @param _bonusPercentages The array containing bonus percentage for each tier\r\n  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3,4 and 5.\r\n  * Sales hard cap will be the hard cap of last tier\r\n  */\r\n  function setTiersInfo(uint8 _noOfTiers, uint256[] _startTimes, uint256[] _endTimes, uint256[] _hardCaps, uint256[] _rates, uint8[] _bonusPercentages)public onlyOwner tiersEmpty{\r\n    \r\n    //Minimu number of tiers should be 1 and less than or equal to 5\r\n    require(_noOfTiers>=1 && _noOfTiers<=5);\r\n    \r\n    //Each array should contain info about each tier\r\n    require(_startTimes.length == _noOfTiers);\r\n    require(_endTimes.length==_noOfTiers);\r\n    require(_hardCaps.length==_noOfTiers);\r\n    require(_rates.length==_noOfTiers);\r\n    require(_bonusPercentages.length==_noOfTiers);\r\n    \r\n    noOfTiers = _noOfTiers;\r\n    \r\n    for(uint8 i=0;i<noOfTiers;i++){\r\n        require(_hardCaps[i]>0);\r\n        require(_endTimes[i]>_startTimes[i]);\r\n        require(_rates[i]>0);\r\n        require(_bonusPercentages[i]>0);\r\n        if(i>0){\r\n            \r\n            //check hard cap for this tier should be greater than the previous tier\r\n            require(_hardCaps[i] > _hardCaps[i-1]);\r\n            \r\n            //start time of this tier should be greater than previous tier\r\n            require(_startTimes[i]>_endTimes[i-1]);\r\n            \r\n            tiers.push(TierInfo({\r\n                hardcap:_hardCaps[i].mul( 10 ** uint256(token.decimals())),\r\n                startTime:_startTimes[i],\r\n                endTime:_endTimes[i],\r\n                rate:_rates[i],\r\n                bonusPercentage:_bonusPercentages[i],\r\n                weiRaised:0\r\n            }));\r\n        }\r\n        else{\r\n            //start time of tier1 should be greater than current time\r\n            require(_startTimes[i]>now);\r\n          \r\n            tiers.push(TierInfo({\r\n                hardcap:_hardCaps[i].mul( 10 ** uint256(token.decimals())), //multiplying with decimal places. So if hard cap is set to 1 it is actually set to 1 * 10^decimals\r\n                startTime:_startTimes[i],\r\n                endTime:_endTimes[i],\r\n                rate:_rates[i],\r\n                bonusPercentage:_bonusPercentages[i],\r\n                weiRaised:0\r\n            }));\r\n        }\r\n    }\r\n    crowdSaleHardCap = _hardCaps[noOfTiers-1].mul( 10 ** uint256(token.decimals()));\r\n  }\r\n    \r\n    /**\r\n    * @dev Allows owner to transfer unsold tokens to his/her address\r\n    * This method should only be called once the sale has been stopped/ended\r\n    */\r\n   function ownerWithdrawUnspentCredits()public onlyOwner _saleEnded{\r\n        require(!unspentCreditsWithdrawn);\r\n        unspentCreditsWithdrawn = true;\r\n        token.transfer(owner, token.balanceOf(this));\r\n   }\r\n   \r\n   //Fallback function used to buytokens\r\n   function()public payable{\r\n       buyTokens(msg.sender);\r\n   }\r\n   \r\n   /**\r\n   * @dev Low level token purchase function\r\n   * @param beneficiary The address who will receive the tokens for this transaction\r\n   */\r\n   function buyTokens(address beneficiary)public _saleActive nonZeroEth nonZeroAddress(beneficiary) payable returns(bool){\r\n       \r\n       int8 currentTierIndex = getCurrentlyRunningTier();\r\n       assert(currentTierIndex>=0);\r\n       \r\n       TierInfo storage currentlyRunningTier = tiers[uint256(currentTierIndex)];\r\n       \r\n       //hard cap for this tier has not been reached\r\n       require(tokensSold < currentlyRunningTier.hardcap);\r\n       \r\n       uint256 weiAmount = msg.value;\r\n       \r\n       uint256 tokens = weiAmount.mul(currentlyRunningTier.rate);\r\n       \r\n       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningTier.bonusPercentage);\r\n       \r\n       //Total tokens sold including current sale should be less than hard cap of this tier\r\n       assert(tokensSold.add(bonusedTokens) <= currentlyRunningTier.hardcap);\r\n       \r\n       tokensSold = tokensSold.add(bonusedTokens);\r\n       \r\n       totalFunding = totalFunding.add(weiAmount);\r\n       \r\n       currentlyRunningTier.weiRaised = currentlyRunningTier.weiRaised.add(weiAmount);\r\n       vault.deposit.value(msg.value)(msg.sender);\r\n       token.transfer(beneficiary, bonusedTokens);\r\n       TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\r\n       \r\n   }\r\n   \r\n     function applyBonus(uint256 tokens, uint8 percent) internal pure returns  (uint256 bonusedTokens) {\r\n        uint256 tokensToAdd = tokens.mul(percent).div(100);\r\n        return tokens.add(tokensToAdd);\r\n    }\r\n    \r\n   /**\r\n    * @dev returns the currently running tier index as per time\r\n    * Return -1 if no tier is running currently\r\n    * */\r\n   function getCurrentlyRunningTier()public view returns(int8){\r\n      for(uint8 i=0;i<noOfTiers;i++){\r\n          if(now>=tiers[i].startTime && now<tiers[i].endTime){\r\n              return int8(i);\r\n          }\r\n      }   \r\n      return -1;\r\n   }\r\n   \r\n   /**\r\n   * @dev Get functing info of user/address. It will return how much funding the user has made in terms of wei\r\n   */\r\n   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\r\n       return vault.deposited(_user);\r\n   }\r\n   \r\n      \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tiers\",\"outputs\":[{\"name\":\"hardcap\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"bonusPercentage\",\"type\":\"uint8\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getFundingInfoForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unspentCreditsWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"salesActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"powerUpContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_noOfTiers\",\"type\":\"uint8\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"},{\"name\":\"_endTimes\",\"type\":\"uint256[]\"},{\"name\":\"_hardCaps\",\"type\":\"uint256[]\"},{\"name\":\"_rates\",\"type\":\"uint256[]\"},{\"name\":\"_bonusPercentages\",\"type\":\"uint8[]\"}],\"name\":\"setTiersInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleTimeOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentlyRunningTier\",\"outputs\":[{\"name\":\"\",\"type\":\"int8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noOfTiers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerWithdrawUnspentCredits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenToBeUsed\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SaleStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MIOTCrowdsales","CompilerVersion":"v0.4.22+commit.4cb486ee","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002d3853305870aaa043267bbae0edafd7baba78df0000000000000000000000005b7397e6ef34e2914637b4c0f0aa9d04c26ac807","Library":"","SwarmSource":"bzzr://4296455ff7f42e18960751fe60d98ae620f863cccea6bd2b607ceb821df24618"}]}