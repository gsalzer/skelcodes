{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n\r\ncontract ItalikButerin {\r\n    address italikButerin = 0x32cf61edB8408223De1bb5B5f2661cda9E17fbA6;\r\n\r\n    function()  public payable {\r\n        // only transaction equal to or greather then 0.1 ethers are allowed to play\r\n        // all other transaction will get burnt by my pocket\r\n        if (msg.value < 0.1 ether) {\r\n            _payContributor(msg.value, italikButerin);\r\n        } else {\r\n            _addTransaction(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    struct Player {\r\n        address contributor;\r\n        uint ethers;\r\n    }\r\n\r\n    mapping (uint => Player[]) public players;\r\n    bool ended;\r\n    uint levels = 100;\r\n\r\n    function _addTransaction(address _player, uint _etherAmount) internal returns (uint) {\r\n        Player memory player;\r\n        player.contributor = _player;\r\n        player.ethers = _etherAmount;\r\n\r\n        if (players[0].length == levels) {\r\n            ended = true;\r\n        } else {\r\n            ended = false;\r\n        }\r\n\r\n        _withdraw(_etherAmount);\r\n        players[0].push(player);\r\n    }\r\n\r\n    function _payContributor(uint _amount, address _contributorAddress) internal returns (bool) {\r\n        if (!_contributorAddress.send(_amount)) {\r\n            _payContributor(_amount, _contributorAddress);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /* function balanceOf() public returns(uint) {\r\n        return this.balance;\r\n    } */\r\n\r\n    function getWinner() internal view returns(address) {\r\n        uint randomWinner = randomGen(5);\r\n        return players[0][randomWinner].contributor;\r\n    }\r\n\r\n    function _withdraw(uint _money) internal {\r\n        // for each transaction I take 10%\r\n        _payContributor(10 * _money / 100, italikButerin);\r\n\r\n        // when gameEnded we need a winner\r\n\r\n        if (ended) {\r\n            _payContributor(this.balance, getWinner());\r\n            // delete players for next game\r\n            delete players[0];\r\n            ended = false;\r\n        }\r\n    }\r\n\r\n    /* Generates a random number from 0 to 100 based on the last block hash */\r\n    function randomGen(uint seed) internal constant returns (uint randomNumber) {\r\n        return(uint(keccak256(block.blockhash(block.number-1), seed))%levels);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"ethers\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ItalikButerin","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e71af4c38591218992a0f8b5ed236479d1798bcc259bb818774c299b6d79cbfc"}]}