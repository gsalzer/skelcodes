{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Haltable is Ownable {\r\n\tbool public halted;\r\n\r\n\tmodifier stopInEmergency {\r\n\t\trequire(!halted);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyInEmergency {\r\n\t\trequire(halted);\r\n\t\t_;\r\n\t}\r\n\r\n\t// called by the owner on emergency, triggers stopped state\r\n\tfunction halt() public onlyOwner {\r\n\t\thalted = true;\r\n\t}\r\n\r\n\t// called by the owner on end of emergency, returns to normal state\r\n\tfunction unhalt() public onlyOwner onlyInEmergency {\r\n\t\thalted = false;\r\n\t}\r\n}\r\n\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Capped token\r\n * @dev Mintable token with a token cap.\r\n */\r\ncontract CappedToken is MintableToken {\r\n\r\n  uint256 public cap;\r\n\r\n  function CappedToken(uint256 _cap) public {\r\n    require(_cap > 0);\r\n    cap = _cap;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    require(totalSupply_.add(_amount) <= cap);\r\n\r\n    return super.mint(_to, _amount);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Merit token\r\n */\r\ncontract MeritToken is CappedToken {\r\n\tevent NewCap(uint256 value);\r\n\r\n\tstring public constant name = \"Merit Token\"; // solium-disable-line uppercase\r\n\tstring public constant symbol = \"MERIT\"; // solium-disable-line uppercase\r\n\tuint8 public constant decimals = 18; // solium-disable-line uppercase\r\n\tbool public tokensReleased;\r\n\r\n\tfunction MeritToken(uint256 _cap) public CappedToken(_cap * 10**uint256(decimals)) { }\r\n\r\n    modifier released {\r\n        require(mintingFinished);\r\n        _;\r\n    }\r\n    \r\n    modifier notReleased {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n    \r\n    // only allow these functions once the token is released (minting is done)\r\n    // basically the zeppelin 'Pausable' token but using my token release flag\r\n    // Only allow our token to be usable once the minting phase is over\r\n    function transfer(address _to, uint256 _value) public released returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public released returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) public released returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n    \r\n    function increaseApproval(address _spender, uint _addedValue) public released returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n    \r\n    function decreaseApproval(address _spender, uint _subtractedValue) public released returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n    \r\n    // for our token, the balance will always be zero if we're still minting them\r\n\t// once we're done minting, the tokens will be effectively released to their owners\r\n    function balanceOf(address _owner) public view released returns (uint256 balance) {\r\n        return super.balanceOf(_owner);\r\n    }\r\n\r\n    // lets us see the pre-allocated balance, since we're just letting the token keep track of all of the allocations\r\n    // instead of going through another complete allocation step for all users\r\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\r\n        return super.balanceOf(_owner);\r\n    }\r\n    \r\n    // revoke a user's tokens if they have been banned for violating the TOS.\r\n    // Note, this can only be called during the ICO phase and not once the tokens are released.\r\n    function revoke(address _owner) public onlyOwner notReleased returns (uint256 balance) {\r\n        // the balance should never ben greater than our total supply, so don't worry about checking\r\n        balance = balances[_owner];\r\n        balances[_owner] = 0;\r\n        totalSupply_ = totalSupply_.sub(balance);\r\n    }\r\n  }\r\n\r\n\r\ncontract MeritICO is Ownable, Haltable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tevent TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\t\t\r\n\t// token\r\n\tMeritToken public token;\r\n\taddress public reserveVault;\r\n\taddress public restrictedVault;\r\n\t//address public fundWallet;\r\n\r\n\tenum Stage \t\t{ None, Closed, PrivateSale, PreSale, Round1, Round2, Round3, Round4, Allocating, Done }\r\n\tStage public currentStage;\r\n\r\n\tuint256 public tokenCap;\r\n\tuint256 public icoCap;\r\n\tuint256 public marketingCap;\r\n\tuint256 public teamCap;\r\n\tuint256 public reserveCap;\r\n\r\n    // number of tokens per ether, kept with 3 decimals (so divide by 1000)\r\n\tuint public exchangeRate;\r\n\tuint public bonusRate;\r\n\tuint256 public currentSaleCap;\r\n\r\n\tuint256 public weiRaised;\r\n\tuint256 public baseTokensAllocated;\r\n\tuint256 public bonusTokensAllocated;\r\n\tbool public saleAllocated;\r\n\t\r\n\tstruct Contribution {\r\n\t    uint256 base;\r\n\t    uint256 bonus;\r\n\t}\r\n\t// current base and bonus balances for each contributor\r\n\tmapping (address => Contribution) contributionBalance;\r\n\r\n\t// map of any address that has been banned from participating in the ICO, for violations of TOS\r\n\tmapping (address => bool) blacklist;\r\n\r\n\tmodifier saleActive {\r\n\t\trequire(currentStage > Stage.Closed && currentStage < Stage.Allocating);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier saleAllocatable {\r\n\t\trequire(currentStage > Stage.Closed && currentStage <= Stage.Allocating);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier saleNotDone {\r\n\t\trequire(currentStage != Stage.Done);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier saleAllocating {\r\n\t\trequire (currentStage == Stage.Allocating);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier saleClosed {\r\n\t    require (currentStage == Stage.Closed);\r\n\t    _;\r\n\t}\r\n\t\r\n\tmodifier saleDone {\r\n\t    require (currentStage == Stage.Done);\r\n\t    _;\r\n\t}\r\n\r\n\t// _token is the address of an already deployed MeritToken contract\r\n\t//\r\n\t// team tokens go into a restricted access vault\r\n\t// reserve tokens go into a reserve vault\r\n\t// any bonus or referral tokens come out of the marketing pool\r\n\t// any base purchased tokens come out of the ICO pool\r\n\t// all percentages are based off of the cap in the passed in token\r\n\t//\r\n\t// anything left over in the marketing or ico pool is burned\r\n\t//\r\n\tfunction MeritICO() public {\r\n\t\t//fundWallet = _fundWallet;\r\n\t\tcurrentStage = Stage.Closed;\r\n\t}\r\n\r\n\tfunction updateToken(address _token) external onlyOwner saleNotDone {\r\n\t\trequire(_token != address(0));\r\n\t\t\r\n\t    token = MeritToken(_token); \r\n\t    \r\n\t    tokenCap = token.cap();\r\n\t    \r\n\t    require(MeritToken(_token).owner() == address(this));\r\n\t}\r\n\r\n\tfunction updateCaps(uint256 _icoPercent, uint256 _marketingPercent, uint256 _teamPercent, uint256 _reservePercent) external onlyOwner saleNotDone {\r\n\t\trequire(_icoPercent + _marketingPercent + _teamPercent + _reservePercent == 100);\r\n\r\n\t\tuint256 max = tokenCap;\r\n        \r\n\t\tmarketingCap = max.mul(_marketingPercent).div(100);\r\n\t\ticoCap = max.mul(_icoPercent).div(100);\r\n\t\tteamCap = max.mul(_teamPercent).div(100);\r\n\t\treserveCap = max.mul(_reservePercent).div(100);\r\n\r\n\t\trequire (marketingCap + icoCap + teamCap + reserveCap == max);\r\n\t}\r\n\r\n\tfunction setStage(Stage _stage) public onlyOwner saleNotDone {\r\n\t\t// don't allow you to set the stage to done unless the tokens have been released\r\n\t\trequire (_stage != Stage.Done || saleAllocated == true);\r\n\t\tcurrentStage = _stage;\r\n\t}\r\n\r\n\tfunction startAllocation() public onlyOwner saleActive {\r\n\t\trequire (!saleAllocated);\r\n\t\tcurrentStage = Stage.Allocating;\r\n\t}\r\n    \r\n\t// set how many tokens per wei, kept with 3 decimals\r\n\tfunction updateExchangeRate(uint _rateTimes1000) public onlyOwner saleNotDone {\r\n\t\texchangeRate = _rateTimes1000;\r\n\t}\r\n\r\n\t// bonus rate percentage (value 0 to 100)\r\n\t// cap is the cumulative cap at this point in time\r\n\tfunction updateICO(uint _bonusRate, uint256 _cap, Stage _stage) external onlyOwner saleNotDone {\r\n\t\trequire (_bonusRate <= 100);\r\n\t\trequire(_cap <= icoCap);\r\n\t\trequire(_stage != Stage.None);\r\n\t\t\r\n\t\tbonusRate = _bonusRate;\r\n\t\tcurrentSaleCap = _cap;\t\r\n\t\tcurrentStage = _stage;\r\n\t}\r\n\t\r\n\tfunction updateVaults(address _reserve, address _restricted) external onlyOwner saleNotDone {\r\n\t\trequire(_reserve != address(0));\r\n\t\trequire(_restricted != address(0));\r\n\t\t\r\n\t\treserveVault = _reserve;\r\n\t\trestrictedVault = _restricted;\r\n\t\t\r\n\t    require(Ownable(_reserve).owner() == address(this));\r\n\t    require(Ownable(_restricted).owner() == address(this));\r\n\t}\r\n\t\r\n\tfunction updateReserveVault(address _reserve) external onlyOwner saleNotDone {\r\n\t\trequire(_reserve != address(0));\r\n\r\n\t\treserveVault = _reserve;\r\n\r\n\t    require(Ownable(_reserve).owner() == address(this));\r\n\t}\r\n\t\r\n\tfunction updateRestrictedVault(address _restricted) external onlyOwner saleNotDone {\r\n\t\trequire(_restricted != address(0));\r\n\t\t\r\n\t\trestrictedVault = _restricted;\r\n\t\t\r\n\t    require(Ownable(_restricted).owner() == address(this));\r\n\t}\r\n\t\r\n\t//function updateFundWallet(address _wallet) external onlyOwner saleNotDone {\r\n\t//\trequire(_wallet != address(0));\r\n\t//\trequire(fundWallet != _wallet);\r\n\t//  fundWallet = _wallet;\r\n\t//}\r\n\r\n\tfunction bookkeep(address _beneficiary, uint256 _base, uint256 _bonus) internal returns(bool) {\r\n\t\tuint256 newBase = baseTokensAllocated.add(_base);\r\n\t\tuint256 newBonus = bonusTokensAllocated.add(_bonus);\r\n\r\n\t\tif (newBase > currentSaleCap || newBonus > marketingCap) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbaseTokensAllocated = newBase;\r\n\t\tbonusTokensAllocated = newBonus;\r\n\r\n\t\tContribution storage c = contributionBalance[_beneficiary];\r\n\t\tc.base = c.base.add(_base);\r\n\t\tc.bonus = c.bonus.add(_bonus);\r\n\r\n\t\treturn true;\r\n\t}\r\n    \r\n\tfunction computeTokens(uint256 _weiAmount, uint _bonusRate) external view returns (uint256 base, uint256 bonus) {\r\n\t\tbase = _weiAmount.mul(exchangeRate).div(1000);\r\n\t\tbonus = base.mul(_bonusRate).div(100);\r\n\t}\r\n    \r\n\t// can only 'buy' tokens while the sale is active. \r\n\tfunction () public payable saleActive stopInEmergency {\r\n\t    revert();\r\n\t    \r\n\t\t//buyTokens(msg.sender);\r\n\t}\r\n\r\n\t//function buyTokens(address _beneficiary) public payable saleActive stopInEmergency {\r\n\t\t//require(msg.value != 0);\r\n\t\t//require(_beneficiary != 0x0);\r\n\t\t//require(blacklist[_beneficiary] == false);\r\n\r\n\t\t//uint256 weiAmount = msg.value;\r\n\t\t//uint256 baseTokens = weiAmount.mul(exchangeRate).div(1000);\r\n\t\t//uint256 bonusTokens = baseTokens.mul(bonusRate).div(100);\r\n\t\t\r\n\t\t//require (bookkeep(_beneficiary, baseTokens, bonusTokens));\r\n\r\n        //uint256 total = baseTokens.add(bonusTokens);\r\n        \r\n\t\t//weiRaised = weiRaised.add(weiAmount);\r\n\r\n        //TokenPurchase(msg.sender, _beneficiary, weiAmount, total);\r\n        \r\n\t\t//fundWallet.transfer(weiAmount);\r\n\t\t//token.mint(_beneficiary, total);\r\n\t//}\r\n\r\n\t// function to purchase tokens for someone, from an external funding source.  This function \r\n\t// assumes that the external source has been verified.  bonus amount is passed in, so we can \r\n\t// handle an edge case where someone externally purchased tokens when the bonus should be different\r\n\t// than it currnetly is set to.\r\n\tfunction buyTokensFor(address _beneficiary, uint256 _baseTokens, uint _bonusTokens) external onlyOwner saleAllocatable {\r\n\t\trequire(_beneficiary != 0x0);\r\n\t\trequire(_baseTokens != 0 || _bonusTokens != 0);\r\n\t\trequire(blacklist[_beneficiary] == false);\r\n\t\t\r\n        require(bookkeep(_beneficiary, _baseTokens, _bonusTokens));\r\n\r\n        uint256 total = _baseTokens.add(_bonusTokens);\r\n\r\n        TokenPurchase(msg.sender, _beneficiary, 0, total);\r\n        \r\n\t\ttoken.mint(_beneficiary, total);\r\n\t}\r\n    \r\n\t// same as above, but strictly for allocating tokens out of the bonus pool\r\n\tfunction giftTokens(address _beneficiary, uint256 _giftAmount) external onlyOwner saleAllocatable {\r\n\t\trequire(_beneficiary != 0x0);\r\n\t\trequire(_giftAmount != 0);\r\n\t\trequire(blacklist[_beneficiary] == false);\r\n\r\n        require(bookkeep(_beneficiary, 0, _giftAmount));\r\n        \r\n        TokenPurchase(msg.sender, _beneficiary, 0, _giftAmount);\r\n        \r\n\t\ttoken.mint(_beneficiary, _giftAmount);\r\n\t}\r\n\tfunction balanceOf(address _beneficiary) public view returns(uint256, uint256) {\r\n\t\trequire(_beneficiary != address(0));\r\n\r\n        Contribution storage c = contributionBalance[_beneficiary];\r\n\t\treturn (c.base, c.bonus);\r\n\t}\r\n\r\n\t\r\n\t// ban/prevent a user from participating in the ICO for violations of TOS, and deallocate any tokens they have allocated\r\n\t// if any refunds are necessary, they are handled offline\r\n\tfunction ban(address _owner) external onlyOwner saleAllocatable returns (uint256 total) {\r\n\t    require(_owner != address(0));\r\n\t    require(!blacklist[_owner]);\r\n\t    \r\n\t    uint256 base;\r\n\t    uint256 bonus;\r\n\t    \r\n\t    (base, bonus) = balanceOf(_owner);\r\n\t    \r\n\t    delete contributionBalance[_owner];\r\n\t    \r\n\t\tbaseTokensAllocated = baseTokensAllocated.sub(base);\r\n\t\tbonusTokensAllocated = bonusTokensAllocated.sub(bonus);\r\n\t\t\r\n\t    blacklist[_owner] = true;\r\n\r\n\t    total = token.revoke(_owner);\r\n\t}\r\n\r\n    // unbans a user that was banned with the above function.  does NOT reallocate their tokens\r\n\tfunction unban(address _beneficiary) external onlyOwner saleAllocatable {\r\n\t    require(_beneficiary != address(0));\r\n\t    require(blacklist[_beneficiary] == true);\r\n\r\n        delete blacklist[_beneficiary];\r\n\t}\r\n\t\r\n\t// release any other tokens needed and mark us as allocated\r\n\tfunction releaseTokens() external onlyOwner saleAllocating {\r\n\t\trequire(reserveVault != address(0));\r\n\t\trequire(restrictedVault != address(0));\r\n\t\trequire(saleAllocated == false);\r\n\r\n\t\tsaleAllocated = true;\r\n\t\t\r\n        // allocate the team and reserve tokens to our vaults\t\t\r\n\t    token.mint(reserveVault, reserveCap); \r\n\t\ttoken.mint(restrictedVault, teamCap); \r\n\t}\r\n\r\n\t\r\n\t// end the ICO, tokens won't show up in anyone's wallets until this function is called.\r\n\t// once this is called, nothing works on the ICO any longer\r\n\tfunction endICO() external onlyOwner saleAllocating {\r\n\t    require(saleAllocated);\r\n\t    \r\n\t    currentStage = Stage.Done;\r\n\t    \r\n        // this will release all allocated tokens to their owners\r\n\t    token.finishMinting();  \r\n\t    \r\n\t    // now transfer all these objects back to our owner, which we know to be a trusted account\r\n\t    token.transferOwnership(owner);\r\n\t    Ownable(reserveVault).transferOwnership(owner);\r\n\t    Ownable(restrictedVault).transferOwnership(owner);\r\n\t}\r\n\t\r\n\tfunction giveBack() public onlyOwner {\r\n\t    if (address(token) != address(0))\r\n\t        token.transferOwnership(owner);\r\n        if (reserveVault != address(0))\r\n\t        Ownable(reserveVault).transferOwnership(owner);\r\n        if (restrictedVault != address(0))\r\n\t        Ownable(restrictedVault).transferOwnership(owner);\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_reserve\",\"type\":\"address\"},{\"name\":\"_restricted\",\"type\":\"address\"}],\"name\":\"updateVaults\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"},{\"name\":\"_bonusRate\",\"type\":\"uint256\"}],\"name\":\"computeTokens\",\"outputs\":[{\"name\":\"base\",\"type\":\"uint256\"},{\"name\":\"bonus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"giveBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSaleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restrictedVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_restricted\",\"type\":\"address\"}],\"name\":\"updateRestrictedVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"updateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reserve\",\"type\":\"address\"}],\"name\":\"updateReserveVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_baseTokens\",\"type\":\"uint256\"},{\"name\":\"_bonusTokens\",\"type\":\"uint256\"}],\"name\":\"buyTokensFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonusRate\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"updateICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ban\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rateTimes1000\",\"type\":\"uint256\"}],\"name\":\"updateExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"unban\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoPercent\",\"type\":\"uint256\"},{\"name\":\"_marketingPercent\",\"type\":\"uint256\"},{\"name\":\"_teamPercent\",\"type\":\"uint256\"},{\"name\":\"_reservePercent\",\"type\":\"uint256\"}],\"name\":\"updateCaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_giftAmount\",\"type\":\"uint256\"}],\"name\":\"giftTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"setStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"MeritICO","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ccad905279ad5a2b993b0601f1158e6aa250bd6489d4dd1297d663aa1d8875bd"}]}