{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\n/*\r\n  https://cryptogs.io\r\n  --Austin Thomas Griffith for ETHDenver\r\n  PizzaParlor -- a new venue for cryptogs games\r\n  less transactions than original Cryptogs.sol assuming some\r\n  centralization and a single commit reveal for randomness\r\n*/\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract PizzaParlor {\r\n\r\n  uint8 public constant FLIPPINESS = 64;\r\n  uint8 public constant FLIPPINESSROUNDBONUS = 16;\r\n  uint8 public constant MAXROUNDS = 12; //must be greater than (255-FLIPPINESS)/FLIPPINESSROUNDBONUS\r\n  uint32 public constant BLOCKTIMEOUT = 40;// a few hours?\r\n\r\n  address public cryptogsAddress;\r\n  function PizzaParlor(address _cryptogsAddress) public {\r\n    cryptogsAddress=_cryptogsAddress;\r\n  }\r\n\r\n  //to make less transactions on-chain, game creation will happen off-chain\r\n  //at this point, two players have agreed upon the ten cryptogs that will\r\n  //be in the game, five from each player\r\n  // the server will generate a secret, reveal, and commit\r\n  // this commit is used as the game id and both players share it\r\n  // the server will pick one user at random to be the game master\r\n  // this player will get the reveal and be in charge of generating the game\r\n  // technically either player can generate the game with the reveal\r\n  // (and either player can drain the stack with the secret)\r\n\r\n    //     commit      ->      player  -> stack hash\r\n  mapping (bytes32 => mapping (address => bytes32)) public commitReceipt;\r\n\r\n    //     commit      ->      player  -> block number\r\n  mapping (bytes32 => mapping (address => uint32)) public commitBlock;\r\n\r\n  mapping (bytes32 => uint8) public stacksTransferred;\r\n\r\n  //tx1&2: players submit to a particular commit hash their stack of pogs (the two txs can happen on the same block, no one is waiting)\r\n  //these go to the Cryptogs contract and it is transferStackAndCall'ed to here\r\n  function onTransferStack(address _sender, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _commit){\r\n\r\n    //make sure this came from the Cryptogs contract\r\n    require(msg.sender == cryptogsAddress);\r\n\r\n    //make sure this commit is unique / doesn't already exist\r\n    require(commitReceipt[_commit][_sender] == 0);\r\n\r\n    //make sure there aren't already two stacks submitted\r\n    require(stacksTransferred[_commit]<2);\r\n    stacksTransferred[_commit]++;\r\n\r\n    //make sure this contract now owns these tokens\r\n    NFT cryptogsContract = NFT(cryptogsAddress);\r\n    require(cryptogsContract.tokenIndexToOwner(_token1)==address(this));\r\n    require(cryptogsContract.tokenIndexToOwner(_token2)==address(this));\r\n    require(cryptogsContract.tokenIndexToOwner(_token3)==address(this));\r\n    require(cryptogsContract.tokenIndexToOwner(_token4)==address(this));\r\n    require(cryptogsContract.tokenIndexToOwner(_token5)==address(this));\r\n\r\n    //generate a receipt for the transfer\r\n    bytes32 receipt = keccak256(_commit,_sender,_token1,_token2,_token3,_token4,_token5);\r\n    commitReceipt[_commit][_sender] = receipt;\r\n    commitBlock[_commit][_sender] = uint32(block.number);\r\n\r\n    //fire an event for the frontend\r\n    TransferStack(_commit,_sender,receipt,now,_token1,_token2,_token3,_token4,_token5);\r\n  }\r\n  event TransferStack(bytes32 indexed _commit,address indexed _sender,bytes32 indexed _receipt,uint _timestamp,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5);\r\n\r\n  //tx3: either player, knowing the reveal, can generate the game\r\n  //this tx calculates random, generates game events, and transfers\r\n  // tokens back to winners\r\n  //in order to make game costs fair, the frontend should randomly select\r\n  // one of the two players and give them the reveal to generate the game\r\n  // in a bit you could give it to the other player too .... then after the\r\n  // timeout, they would get the secret to drain the stack\r\n  function generateGame(bytes32 _commit,bytes32 _reveal,address _opponent,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5,uint _token6, uint _token7, uint _token8, uint _token9, uint _token10){\r\n    //verify that receipts are valid\r\n    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\r\n    require( commitReceipt[_commit][_opponent] == keccak256(_commit,_opponent,_token6,_token7,_token8,_token9,_token10) );\r\n\r\n    //verify we are on a later block so random will work\r\n    require( uint32(block.number) > commitBlock[_commit][msg.sender]);\r\n    require( uint32(block.number) > commitBlock[_commit][_opponent]);\r\n\r\n    //verify that the reveal is correct\r\n    require(_commit == keccak256(_reveal));\r\n\r\n    //make sure there are exactly two stacks submitted\r\n    require(stacksTransferred[_commit]==2);\r\n\r\n    _generateGame(_commit,_reveal,_opponent,[_token1,_token2,_token3,_token4,_token5,_token6,_token7,_token8,_token9,_token10]);\r\n  }\r\n\r\n  function _generateGame(bytes32 _commit,bytes32 _reveal,address _opponent,uint[10] _tokens) internal {\r\n    //create Cryptogs contract for transfers\r\n    NFT cryptogsContract = NFT(cryptogsAddress);\r\n\r\n    //generate the random using commit / reveal and blockhash from future (now past) block\r\n    bytes32[4] memory pseudoRandoms = _generateRandom(_reveal,commitBlock[_commit][msg.sender],commitBlock[_commit][_opponent]);\r\n\r\n    bool whosTurn = uint8(pseudoRandoms[0][0])%2==0;\r\n    CoinFlip(_commit,whosTurn,whosTurn ? msg.sender : _opponent);\r\n    for(uint8 round=1;round<=MAXROUNDS;round++){\r\n      for(uint8 i=1;i<=10;i++){\r\n        //first check and see if this token has flipped yet\r\n        if(_tokens[i-1]>0){\r\n\r\n          //get the random byte between 0-255 from our pseudoRandoms array of bytes32\r\n          uint8 rand = _getRandom(pseudoRandoms,(round-1)*10 + i);\r\n\r\n          uint8 threshold = (FLIPPINESS+round*FLIPPINESSROUNDBONUS);\r\n          if( rand < threshold || round==MAXROUNDS ){\r\n            _flip(_commit,round,cryptogsContract,_tokens,i-1,_opponent,whosTurn);\r\n          }\r\n        }\r\n      }\r\n      whosTurn = !whosTurn;\r\n    }\r\n\r\n\r\n    delete commitReceipt[_commit][msg.sender];\r\n    delete commitReceipt[_commit][_opponent];\r\n\r\n    GenerateGame(_commit,msg.sender);\r\n  }\r\n  event CoinFlip(bytes32 indexed _commit,bool _result,address _winner);\r\n  event GenerateGame(bytes32 indexed _commit,address indexed _sender);\r\n\r\n  function _getRandom(bytes32[4] pseudoRandoms,uint8 randIndex) internal returns (uint8 rand){\r\n    if(randIndex<32){\r\n      rand = uint8(pseudoRandoms[0][randIndex]);\r\n    }else if(randIndex<64){\r\n      rand = uint8(pseudoRandoms[1][randIndex-32]);\r\n    }else if(randIndex<96){\r\n      rand = uint8(pseudoRandoms[1][randIndex-64]);\r\n    }else{\r\n      rand = uint8(pseudoRandoms[1][randIndex-96]);\r\n    }\r\n    return rand;\r\n  }\r\n\r\n  function _generateRandom(bytes32 _reveal, uint32 block1,uint32 block2) internal returns(bytes32[4] pseudoRandoms){\r\n    pseudoRandoms[0] = keccak256(_reveal,block.blockhash(max(block1,block2)));\r\n    pseudoRandoms[1] = keccak256(pseudoRandoms[0]);\r\n    pseudoRandoms[2] = keccak256(pseudoRandoms[1]);\r\n    pseudoRandoms[3] = keccak256(pseudoRandoms[2]);\r\n    return pseudoRandoms;\r\n  }\r\n\r\n  function max(uint32 a, uint32 b) private pure returns (uint32) {\r\n      return a > b ? a : b;\r\n  }\r\n\r\n  function _flip(bytes32 _commit,uint8 round,NFT cryptogsContract,uint[10] _tokens,uint8 tokenIndex,address _opponent,bool whosTurn) internal {\r\n    address flipper;\r\n    if(whosTurn) {\r\n      flipper=msg.sender;\r\n    }else{\r\n      flipper=_opponent;\r\n    }\r\n    cryptogsContract.transfer(flipper,_tokens[tokenIndex]);\r\n    Flip(_commit,round,flipper,_tokens[tokenIndex]);\r\n    _tokens[tokenIndex]=0;\r\n  }\r\n  event Flip(bytes32 indexed _commit,uint8 _round,address indexed _flipper,uint indexed _token);\r\n\r\n  //if the game times out without either player generating the game,\r\n  // (the frontend should have selected one of the players randomly to generate the game)\r\n  //the frontend should give the other player the secret to drain the game\r\n  // secret -> reveal -> commit\r\n  function drainGame(bytes32 _commit,bytes32 _secret,address _opponent,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5,uint _token6, uint _token7, uint _token8, uint _token9, uint _token10){\r\n    //verify that receipts are valid\r\n    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\r\n    require( commitReceipt[_commit][_opponent] == keccak256(_commit,_opponent,_token6,_token7,_token8,_token9,_token10) );\r\n\r\n    //verify we are on a later block so random will work\r\n    require( uint32(block.number) > commitBlock[_commit][msg.sender]+BLOCKTIMEOUT);\r\n    require( uint32(block.number) > commitBlock[_commit][_opponent]+BLOCKTIMEOUT);\r\n\r\n    //make sure the commit is the doublehash of the secret\r\n    require(_commit == keccak256(keccak256(_secret)));\r\n\r\n    //make sure there are exactly two stacks submitted\r\n    require(stacksTransferred[_commit]==2);\r\n\r\n    _drainGame(_commit,_opponent,[_token1,_token2,_token3,_token4,_token5,_token6,_token7,_token8,_token9,_token10]);\r\n  }\r\n\r\n  function _drainGame(bytes32 _commit,address _opponent, uint[10] _tokens) internal {\r\n    //create Cryptogs contract for transfers\r\n    NFT cryptogsContract = NFT(cryptogsAddress);\r\n\r\n    cryptogsContract.transfer(msg.sender,_tokens[0]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[1]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[2]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[3]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[4]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[5]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[6]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[7]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[8]);\r\n    cryptogsContract.transfer(msg.sender,_tokens[9]);\r\n\r\n    Flip(_commit,1,msg.sender,_tokens[0]);\r\n    Flip(_commit,1,msg.sender,_tokens[1]);\r\n    Flip(_commit,1,msg.sender,_tokens[2]);\r\n    Flip(_commit,1,msg.sender,_tokens[3]);\r\n    Flip(_commit,1,msg.sender,_tokens[4]);\r\n    Flip(_commit,1,msg.sender,_tokens[5]);\r\n    Flip(_commit,1,msg.sender,_tokens[6]);\r\n    Flip(_commit,1,msg.sender,_tokens[7]);\r\n    Flip(_commit,1,msg.sender,_tokens[8]);\r\n    Flip(_commit,1,msg.sender,_tokens[9]);\r\n\r\n    delete commitReceipt[_commit][msg.sender];\r\n    delete commitReceipt[_commit][_opponent];\r\n    DrainGame(_commit,msg.sender);\r\n  }\r\n  event DrainGame(bytes32 indexed _commit,address indexed _sender);\r\n\r\n  //if only one player ever ends up submitting a stack, they need to be able\r\n  //to pull thier tokens back\r\n  function revokeStack(bytes32 _commit,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5){\r\n    //verify that receipt is valid\r\n    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\r\n\r\n    //make sure there is exactly one stacks submitted\r\n    require(stacksTransferred[_commit]==1);\r\n\r\n    stacksTransferred[_commit]=0;\r\n\r\n    NFT cryptogsContract = NFT(cryptogsAddress);\r\n\r\n    cryptogsContract.transfer(msg.sender,_token1);\r\n    cryptogsContract.transfer(msg.sender,_token2);\r\n    cryptogsContract.transfer(msg.sender,_token3);\r\n    cryptogsContract.transfer(msg.sender,_token4);\r\n    cryptogsContract.transfer(msg.sender,_token5);\r\n\r\n\r\n    bytes32 previousReceipt = commitReceipt[_commit][msg.sender];\r\n\r\n    delete commitReceipt[_commit][msg.sender];\r\n    //fire an event for the frontend\r\n    RevokeStack(_commit,msg.sender,now,_token1,_token2,_token3,_token4,_token5,previousReceipt);\r\n  }\r\n  event RevokeStack(bytes32 indexed _commit,address indexed _sender,uint _timestamp,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5,bytes32 _receipt);\r\n\r\n}\r\n\r\ncontract NFT {\r\n  function approve(address _to,uint256 _tokenId) public returns (bool) { }\r\n  function transfer(address _to,uint256 _tokenId) external { }\r\n  mapping (uint256 => address) public tokenIndexToOwner;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"FLIPPINESS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"commitBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FLIPPINESSROUNDBONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_token1\",\"type\":\"uint256\"},{\"name\":\"_token2\",\"type\":\"uint256\"},{\"name\":\"_token3\",\"type\":\"uint256\"},{\"name\":\"_token4\",\"type\":\"uint256\"},{\"name\":\"_token5\",\"type\":\"uint256\"},{\"name\":\"_commit\",\"type\":\"bytes32\"}],\"name\":\"onTransferStack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_commit\",\"type\":\"bytes32\"},{\"name\":\"_secret\",\"type\":\"bytes32\"},{\"name\":\"_opponent\",\"type\":\"address\"},{\"name\":\"_token1\",\"type\":\"uint256\"},{\"name\":\"_token2\",\"type\":\"uint256\"},{\"name\":\"_token3\",\"type\":\"uint256\"},{\"name\":\"_token4\",\"type\":\"uint256\"},{\"name\":\"_token5\",\"type\":\"uint256\"},{\"name\":\"_token6\",\"type\":\"uint256\"},{\"name\":\"_token7\",\"type\":\"uint256\"},{\"name\":\"_token8\",\"type\":\"uint256\"},{\"name\":\"_token9\",\"type\":\"uint256\"},{\"name\":\"_token10\",\"type\":\"uint256\"}],\"name\":\"drainGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_commit\",\"type\":\"bytes32\"},{\"name\":\"_token1\",\"type\":\"uint256\"},{\"name\":\"_token2\",\"type\":\"uint256\"},{\"name\":\"_token3\",\"type\":\"uint256\"},{\"name\":\"_token4\",\"type\":\"uint256\"},{\"name\":\"_token5\",\"type\":\"uint256\"}],\"name\":\"revokeStack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXROUNDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"commitReceipt\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_commit\",\"type\":\"bytes32\"},{\"name\":\"_reveal\",\"type\":\"bytes32\"},{\"name\":\"_opponent\",\"type\":\"address\"},{\"name\":\"_token1\",\"type\":\"uint256\"},{\"name\":\"_token2\",\"type\":\"uint256\"},{\"name\":\"_token3\",\"type\":\"uint256\"},{\"name\":\"_token4\",\"type\":\"uint256\"},{\"name\":\"_token5\",\"type\":\"uint256\"},{\"name\":\"_token6\",\"type\":\"uint256\"},{\"name\":\"_token7\",\"type\":\"uint256\"},{\"name\":\"_token8\",\"type\":\"uint256\"},{\"name\":\"_token9\",\"type\":\"uint256\"},{\"name\":\"_token10\",\"type\":\"uint256\"}],\"name\":\"generateGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cryptogsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BLOCKTIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stacksTransferred\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_cryptogsAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_commit\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_receipt\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token4\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token5\",\"type\":\"uint256\"}],\"name\":\"TransferStack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_commit\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_result\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"CoinFlip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_commit\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"GenerateGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_commit\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_round\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"_flipper\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"Flip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_commit\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"DrainGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_commit\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token3\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token4\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token5\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_receipt\",\"type\":\"bytes32\"}],\"name\":\"RevokeStack\",\"type\":\"event\"}]","ContractName":"PizzaParlor","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000efabe332d31c3982b76f8630a306c960169bd5b3","Library":"","SwarmSource":"bzzr://7621401dd7920b67023717738b55148ef05fe83e1f4cf378f026c8b11329be5d"}]}