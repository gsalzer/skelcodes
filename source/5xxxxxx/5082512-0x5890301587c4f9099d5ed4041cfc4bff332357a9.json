{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure  returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Base {\r\n    modifier only(address allowed) {\r\n        require(msg.sender == allowed);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Owned is Base {\r\n\r\n    address public owner;\r\n    address newOwner;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) only(owner) public {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() only(newOwner) public {\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n}\r\n\r\ncontract ERC20 is Owned {\r\n    using SafeMath for uint;\r\n\r\n    bool public isStarted = false;\r\n\r\n    modifier isStartedOnly() {\r\n        require(isStarted);\r\n        _;\r\n    }\r\n\r\n    modifier isNotStartedOnly() {\r\n        require(!isStarted);\r\n        _;\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function transfer(address _to, uint _value) isStartedOnly public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) isStartedOnly public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve_fixed(address _spender, uint _currentValue, uint _value) isStartedOnly public returns (bool success) {\r\n        if(allowed[msg.sender][_spender] == _currentValue){\r\n            allowed[msg.sender][_spender] = _value;\r\n            Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint _value) isStartedOnly public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract Token is ERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n\r\n    function Token(string _name, string _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function start() public only(owner) isNotStartedOnly {\r\n        isStarted = true;\r\n    }\r\n\r\n    //================= Crowdsale Only =================\r\n    function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function multimint(address[] dests, uint[] values) public only(owner) isNotStartedOnly returns (uint) {\r\n        uint i = 0;\r\n        while (i < dests.length) {\r\n           mint(dests[i], values[i]);\r\n           i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n}\r\n\r\ncontract TokenWithoutStart is Owned {\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    uint public totalSupply;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function TokenWithoutStart(string _name, string _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve_fixed(address _spender, uint _currentValue, uint _value) public returns (bool success) {\r\n        if(allowed[msg.sender][_spender] == _currentValue){\r\n            allowed[msg.sender][_spender] = _value;\r\n            Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    function mint(address _to, uint _amount) public only(owner) returns(bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function multimint(address[] dests, uint[] values) public only(owner) returns (uint) {\r\n        uint i = 0;\r\n        while (i < dests.length) {\r\n           mint(dests[i], values[i]);\r\n           i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n\r\n}\r\n\r\ncontract ICOContract {\r\n    \r\n    address public projectWallet; //beneficiary wallet\r\n    address public operator = 0x4C67EB86d70354731f11981aeE91d969e3823c39; //address of the ICO operator — the one who adds milestones and InvestContracts\r\n\r\n    uint public constant waitPeriod = 7 days; //wait period after milestone finish and untile the next one can be started\r\n\r\n    address[] public pendingInvestContracts = [0x0]; //pending InvestContracts not yet accepted by the project\r\n    mapping(address => uint) public pendingInvestContractsIndices;\r\n\r\n    address[] public investContracts = [0x0]; // accepted InvestContracts\r\n    mapping(address => uint) public investContractsIndices;\r\n\r\n    uint public minimalInvestment = 5 ether;\r\n    \r\n    uint public totalEther; // How much Ether is collected =sum of all milestones' etherAmount\r\n    uint public totalToken; // how many tokens are distributed = sum of all milestones' tokenAmount\r\n\r\n    uint public tokenLeft;\r\n    uint public etherLeft;\r\n\r\n    Token public token;\r\n    \r\n    ///ICO caps\r\n    uint public minimumCap; // set in constructor\r\n    uint public maximumCap;  // set in constructor\r\n\r\n    //Structure for milestone\r\n    struct Milestone {\r\n        uint etherAmount; //how many Ether is needed for this milestone\r\n        uint tokenAmount; //how many tokens releases this milestone\r\n        uint startTime; //real time when milestone has started, set upon start\r\n        uint finishTime; //real time when milestone has finished, set upon finish\r\n        uint duration; //assumed duration for milestone implementation, set upon milestone creation\r\n        string description; \r\n        string results;\r\n    }\r\n\r\n    Milestone[] public milestones;\r\n    uint public currentMilestone;\r\n    uint public sealTimestamp; //Until when it's possible to add new and change existing milestones\r\n\r\n    \r\n    modifier only(address _sender) {\r\n        require(msg.sender == _sender);\r\n        _;\r\n    }\r\n\r\n    modifier notSealed() {\r\n        require(now <= sealTimestamp);\r\n        _;\r\n    }\r\n\r\n    modifier sealed() {\r\n        require(now > sealTimestamp);\r\n        _;\r\n    }\r\n\r\n    /// @dev Create an ICOContract.\r\n    /// @param _tokenAddress Address of project token contract\r\n    /// @param _projectWallet Address of project developers wallet\r\n    /// @param _sealTimestamp Until this timestamp it's possible to alter milestones\r\n    /// @param _minimumCap Wei value of minimum cap for responsible ICO\r\n    /// @param _maximumCap Wei value of maximum cap for responsible ICO\r\n    function ICOContract(address _tokenAddress, address _projectWallet, uint _sealTimestamp, uint _minimumCap,\r\n                         uint _maximumCap) public {\r\n        token = Token(_tokenAddress);\r\n        projectWallet = _projectWallet;\r\n        sealTimestamp = _sealTimestamp;\r\n        minimumCap = _minimumCap;\r\n        maximumCap = _maximumCap;\r\n    }\r\n\r\n    //MILESTONES\r\n  \r\n    /// @dev Adds a milestone.\r\n    /// @param _etherAmount amount of Ether needed for the added milestone\r\n    /// @param _tokenAmount amount of tokens which will be released for added milestone\r\n    /// @param _startTime field for start timestamp of added milestone\r\n    /// @param _duration assumed duration of the milestone\r\n    /// @param _description description of added milestone\r\n    /// @param _result result description of added milestone\r\n    function addMilestone(uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description, string _result)        \r\n    notSealed only(operator)\r\n    public returns(uint) {\r\n        totalEther += _etherAmount;\r\n        totalToken += _tokenAmount;\r\n        return milestones.push(Milestone(_etherAmount, _tokenAmount, _startTime, 0, _duration, _description, _result));\r\n    }\r\n\r\n    /// @dev Edits milestone by given id and new parameters.\r\n    /// @param _id id of editing milestone\r\n    /// @param _etherAmount amount of Ether needed for the milestone\r\n    /// @param _tokenAmount amount of tokens which will be released for the milestone\r\n    /// @param _startTime start timestamp of the milestone\r\n    /// @param _duration assumed duration of the milestone\r\n    /// @param _description description of the milestone\r\n    /// @param _results result description of the milestone\r\n    function editMilestone(uint _id, uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description, string _results) \r\n    notSealed only(operator)\r\n    public {\r\n        require(_id < milestones.length);\r\n        totalEther = totalEther - milestones[_id].etherAmount + _etherAmount;\r\n        totalToken = totalToken - milestones[_id].tokenAmount + _tokenAmount;\r\n        milestones[_id].etherAmount = _etherAmount;\r\n        milestones[_id].tokenAmount = _tokenAmount;\r\n        milestones[_id].startTime = _startTime;\r\n        milestones[_id].duration = _duration;\r\n        milestones[_id].description = _description;\r\n        milestones[_id].results = _results;\r\n    }\r\n\r\n    //TODO: add check if ICOContract has tokens\r\n    ///@dev Seals milestone making them no longer changeable. Works by setting changeable timestamp to the current one, //so in future it would be no longer callable.\r\n    function seal() only(operator) notSealed() public { \r\n        assert(milestones.length > 0);\r\n        //assert(token.balanceOf(address(this)) >= totalToken;\r\n        sealTimestamp = now;\r\n        etherLeft = totalEther;\r\n        tokenLeft = totalToken;\r\n    }\r\n\r\n    function finishMilestone(string _results) only(operator) public {\r\n        var milestone = getCurrentMilestone();\r\n        milestones[milestone].finishTime = now;\r\n        milestones[milestone].results = _results;\r\n    }\r\n\r\n    function startNextMilestone() public only(operator) {\r\n        uint milestone = getCurrentMilestone();\r\n        require(milestones[currentMilestone].finishTime == 0);\r\n        currentMilestone +=1;\r\n        milestones[currentMilestone].startTime = now;\r\n        for(uint i=1; i < investContracts.length; i++) {\r\n                InvestContract investContract =  InvestContract(investContracts[i]); \r\n                investContract.milestoneStarted(milestone);\r\n        }\r\n    }\r\n\r\n    ///@dev Returns number of the current milestone. Starts from 1. 0 indicates that project implementation has not started yet.\r\n    function getCurrentMilestone() public constant returns(uint) {\r\n        /*\r\n        for(uint i=0; i < milestones.length; i++) { \r\n            if (milestones[i].startTime <= now && now <= milestones[i].finishTime + waitPeriod) {\r\n                return i+1;\r\n            }\r\n        }\r\n        return 0;\r\n       */\r\n        return currentMilestone;\r\n    }\r\n   \r\n    /// @dev Getter function for length. For testing purposes.\r\n    function milestonesLength() public view returns(uint) {\r\n        return milestones.length;\r\n    }\r\n\r\n    ///InvestContract part\r\n    function createInvestContract(address _investor, uint _etherAmount, uint _tokenAmount) public \r\n        sealed only(operator)\r\n        returns(address)\r\n    {\r\n        require(_etherAmount >= minimalInvestment);\r\n        //require(milestones[0].startTime - now >= 5 days);\r\n        //require(maximumCap >= _etherAmount + investorEther);\r\n        //require(token.balanceOf(address(this)) >= _tokenAmount + investorTokens);\r\n        address investContract = new InvestContract(address(this), _investor, _etherAmount, _tokenAmount);\r\n        pendingInvestContracts.push(investContract);\r\n        pendingInvestContractsIndices[investContract]=(pendingInvestContracts.length-1); //note that indices start from 1\r\n        return(investContract);\r\n    }\r\n\r\n    /// @dev This function is called by InvestContract when it receives Ether. It shold move this InvestContract from pending to the real ones.\r\n    function investContractDeposited() public {\r\n        //require(maximumCap >= investEthAmount + investorEther);\r\n        uint index = pendingInvestContractsIndices[msg.sender];\r\n        assert(index > 0);\r\n        uint len = pendingInvestContracts.length;\r\n        InvestContract investContract = InvestContract(pendingInvestContracts[index]);\r\n        pendingInvestContracts[index] = pendingInvestContracts[len-1];\r\n        pendingInvestContracts.length = len-1;\r\n        investContracts.push(msg.sender);\r\n        investContractsIndices[msg.sender]=investContracts.length-1; //note that indexing starts from 1\r\n\r\n        uint investmentToken = investContract.tokenAmount();\r\n        uint investmentEther = investContract.etherAmount();\r\n\r\n        etherLeft -= investmentEther;\r\n        tokenLeft -= investmentToken;\r\n        assert(token.transfer(msg.sender, investmentToken)); \r\n    }\r\n\r\n    function returnTokens() public only(operator) {\r\n        uint balance = token.balanceOf(address(this));\r\n        token.transfer(projectWallet, balance);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Pullable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public payments;\r\n\r\n  /**\r\n  * @dev withdraw accumulated balance, called by payee.\r\n  */\r\n  function withdrawPayment() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n\r\n    require(payment != 0);\r\n    require(this.balance >= payment);\r\n\r\n    payments[payee] = 0;\r\n\r\n    assert(payee.send(payment));\r\n  }\r\n\r\n  /**\r\n  * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n  * @param _destination The destination address of the funds.\r\n  * @param _amount The amount to transfer.\r\n  */\r\n  function asyncSend(address _destination, uint256 _amount) internal {\r\n    payments[_destination] = payments[_destination].add(_amount);\r\n  }\r\n}\r\n\r\ncontract TokenPullable {\r\n  using SafeMath for uint256;\r\n  Token public token;\r\n\r\n  mapping(address => uint256) public tokenPayments;\r\n\r\n  function TokenPullable(address _ico) public {\r\n      ICOContract icoContract = ICOContract(_ico);\r\n      token = icoContract.token();\r\n  }\r\n\r\n  /**\r\n  * @dev withdraw accumulated balance, called by payee.\r\n  */\r\n  function withdrawTokenPayment() public {\r\n    address tokenPayee = msg.sender;\r\n    uint256 tokenPayment = tokenPayments[tokenPayee];\r\n\r\n    require(tokenPayment != 0);\r\n    require(token.balanceOf(address(this)) >= tokenPayment);\r\n\r\n    tokenPayments[tokenPayee] = 0;\r\n\r\n    assert(token.transfer(tokenPayee, tokenPayment));\r\n  }\r\n\r\n  function asyncTokenSend(address _destination, uint _amount) internal {\r\n    tokenPayments[_destination] = tokenPayments[_destination].add(_amount);\r\n  }\r\n}\r\n\r\ncontract InvestContract is TokenPullable, Pullable {\r\n\r\n    address public projectWallet; // person from ico team\r\n    address public investor; \r\n\r\n    uint public arbiterAcceptCount = 0;\r\n    uint public quorum;\r\n\r\n    ICOContract public icoContract;\r\n    //Token public token;\r\n\r\n    uint[] public etherPartition; //weis \r\n    uint[] public tokenPartition; //tokens\r\n\r\n    //Each arbiter has parameter delay which equals time interval in seconds betwwen dispute open and when the arbiter can vote\r\n    struct ArbiterInfo { \r\n        uint index;\r\n        bool accepted;\r\n        uint voteDelay;\r\n    }\r\n\r\n    mapping(address => ArbiterInfo) public arbiters; //arbiterAddress => ArbiterInfo{acceptance, voteDelay}\r\n    address[] public arbiterList = [0x0]; //it's needed to show complete arbiter list\r\n\r\n\r\n    //this structure can be optimized\r\n    struct Dispute {\r\n        uint timestamp;\r\n        string reason;\r\n        address[5] voters;\r\n        mapping(address => address) votes; \r\n        uint votesProject;\r\n        uint votesInvestor;\r\n    }\r\n\r\n    mapping(uint => Dispute) public disputes;\r\n\r\n    uint public etherAmount; //How much Ether investor wants to invest\r\n    uint public tokenAmount; //How many tokens investor wants to receive\r\n\r\n    bool public disputing=false;\r\n    uint public amountToPay; //investAmount + commissions\r\n    \r\n    //Modifier that restricts function caller\r\n    modifier only(address _sender) {\r\n        require(msg.sender == _sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyArbiter() {\r\n        require(arbiters[msg.sender].voteDelay > 0);\r\n        _;\r\n    }\r\n  \r\n    function InvestContract(address _ICOContractAddress, address _investor,  uint\r\n                           _etherAmount, uint _tokenAmount) TokenPullable(_ICOContractAddress)\r\n    public {\r\n        icoContract = ICOContract(_ICOContractAddress);\r\n        token = icoContract.token();\r\n\t\tetherAmount = _etherAmount;\r\n        tokenAmount = _tokenAmount;\r\n        projectWallet = icoContract.projectWallet();\r\n        investor = _investor;\r\n        amountToPay = etherAmount*101/100; //101% of the agreed amount\r\n        quorum = 3;\r\n        //hardcoded arbiters\r\n        addAcceptedArbiter(0x42efbba0563AE5aa2312BeBce1C18C6722B67857, 1); //Ryan\r\n        addAcceptedArbiter(0x37D5953c24a2efD372C97B06f22416b68e896eaf, 1);// Maxim Telegin\r\n        addAcceptedArbiter(0xd0D2e05Fd34d566612529512F7Af1F8a60EDAb6C, 1);// Vladimir Dyakin\r\n        addAcceptedArbiter(0xB6508aFaCe815e481bf3B3Fa9B4117D46C963Ec3, 1);// Immánuel Fodor\r\n        addAcceptedArbiter(0x73380dc12B629FB7fBD221E05D25E42f5f3FAB11, 1);// Alban\r\n\r\n        arbiterAcceptCount = 5;\r\n\r\n\t\tuint milestoneEtherAmount; //How much Ether does investor send for a milestone\r\n\t\tuint milestoneTokenAmount; //How many Tokens does investor receive for a milestone\r\n\r\n\t\tuint milestoneEtherTarget; //How much TOTAL Ether a milestone needs\r\n\t\tuint milestoneTokenTarget; //How many TOTAL tokens a milestone releases\r\n\r\n\t\tuint totalEtherInvestment; \r\n\t\tuint totalTokenInvestment;\r\n\t\tfor(uint i=0; i<icoContract.milestonesLength(); i++) {\r\n\t\t\t(milestoneEtherTarget, milestoneTokenTarget, , , , , ) = icoContract.milestones(i);\r\n\t\t\tmilestoneEtherAmount = _etherAmount * milestoneEtherTarget / icoContract.totalEther();  \r\n\t\t\tmilestoneTokenAmount = _tokenAmount * milestoneTokenTarget / icoContract.totalToken();\r\n\t\t\ttotalEtherInvestment += milestoneEtherAmount; //used to prevent rounding errors\r\n\t\t\ttotalTokenInvestment += milestoneTokenAmount; //used to prevent rounding errors\r\n\t\t\tetherPartition.push(milestoneEtherAmount);  \r\n\t\t\ttokenPartition.push(milestoneTokenAmount);\r\n\t\t}\r\n\t\tetherPartition[0] += _etherAmount - totalEtherInvestment; //rounding error is added to the first milestone\r\n\t\ttokenPartition[0] += _tokenAmount - totalTokenInvestment; //rounding error is added to the first milestone\r\n    }\r\n\r\n    function() payable public only(investor) { \r\n        require(arbiterAcceptCount >= quorum);\r\n        require(msg.value == amountToPay);\r\n        require(getCurrentMilestone() == 0); //before first\r\n        icoContract.investContractDeposited();\r\n    } \r\n\r\n    //Adding an arbiter which has already accepted his participation in ICO.\r\n    function addAcceptedArbiter(address _arbiter, uint _delay) internal {\r\n        require(token.balanceOf(address(this))==0); //only callable when there are no tokens at this contract\r\n        require(_delay > 0); //to differ from non-existent arbiters\r\n        var index = arbiterList.push(_arbiter);\r\n        arbiters[_arbiter] = ArbiterInfo(index, true, _delay);\r\n    }\r\n\r\n    /* Not used for our own ICO as arbiters are the same and already accepted their participation\r\n    function arbiterAccept() public onlyArbiter {\r\n        require(!arbiters[msg.sender].accepted);\r\n        arbiters[msg.sender].accepted = true;\r\n        arbiterAcceptCount += 1;\r\n    }\r\n\r\n    function addArbiter(address _arbiter, uint _delay) public {\r\n        //only(investor)\r\n        require(token.balanceOf(address(this))==0); //only callable when there are no tokens at this contract\r\n        require(_delay > 0); //to differ from non-existent arbiters\r\n        var index = arbiterList.push(_arbiter);\r\n        arbiters[_arbiter] = ArbiterInfo(index, false, _delay);\r\n    }\r\n\r\n   */\r\n\r\n    function vote(address _voteAddress) public onlyArbiter {   \r\n        require(_voteAddress == investor || _voteAddress == projectWallet);\r\n        require(disputing);\r\n        uint milestone = getCurrentMilestone();\r\n        require(milestone > 0);\r\n        require(disputes[milestone].votes[msg.sender] == 0); \r\n        require(now - disputes[milestone].timestamp >= arbiters[msg.sender].voteDelay); //checking if enough time has passed since dispute had been opened\r\n        disputes[milestone].votes[msg.sender] = _voteAddress;\r\n        disputes[milestone].voters[disputes[milestone].votesProject+disputes[milestone].votesInvestor] = msg.sender;\r\n        if (_voteAddress == projectWallet) {\r\n            disputes[milestone].votesProject += 1;\r\n        } else if (_voteAddress == investor) {\r\n            disputes[milestone].votesInvestor += 1;\r\n        } else { \r\n            revert();\r\n        }\r\n\r\n        if (disputes[milestone].votesProject >= quorum) {\r\n            executeVerdict(true);\r\n        }\r\n        if (disputes[milestone].votesInvestor >= quorum) {\r\n            executeVerdict(false);\r\n        }\r\n    }\r\n\r\n    function executeVerdict(bool _projectWon) internal {\r\n        //uint milestone = getCurrentMilestone();\r\n        disputing = false;\r\n        if (_projectWon) {\r\n            //token.transfer(0x0, token.balanceOf(address(this)));\r\n        } else  {\r\n\t\t//asyncTokenSend(investor, tokensToSend);\r\n\t\t//asyncSend(projectWallet, etherToSend);\r\n            //token.transfer(address(icoContract), token.balanceOf(this)); // send all tokens back\r\n        }\r\n    }\r\n\r\n    function openDispute(string _reason) public only(investor) {\r\n        assert(!disputing);\r\n        var milestone = getCurrentMilestone();\r\n        assert(milestone > 0);\r\n        disputing = true;\r\n        disputes[milestone].timestamp = now;\r\n        disputes[milestone].reason = _reason;\r\n    }\r\n\r\n\tfunction milestoneStarted(uint _milestone) public only(address(icoContract)) {\r\n        require(!disputing);\r\n\t\tvar etherToSend = etherPartition[_milestone];\r\n\t\tvar tokensToSend = tokenPartition[_milestone];\r\n\r\n\t\t//async send\r\n\t\tasyncSend(projectWallet, etherToSend);\r\n\t\tasyncTokenSend(investor, tokensToSend);\r\n\r\n    }\r\n\r\n    function getCurrentMilestone() public constant returns(uint) {\r\n        return icoContract.getCurrentMilestone();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_results\",\"type\":\"string\"}],\"name\":\"finishMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investContractsIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNextMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentMilestone\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"createInvestContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"milestonesLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_result\",\"type\":\"string\"}],\"name\":\"addMilestone\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"seal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"investContractDeposited\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sealTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingInvestContractsIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingInvestContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_results\",\"type\":\"string\"}],\"name\":\"editMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMilestone\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"milestones\",\"outputs\":[{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"finishTime\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"results\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"returnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_projectWallet\",\"type\":\"address\"},{\"name\":\"_sealTimestamp\",\"type\":\"uint256\"},{\"name\":\"_minimumCap\",\"type\":\"uint256\"},{\"name\":\"_maximumCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ICOContract","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000009070e2fdb61887c234d841c95d1709288ebbb9a00000000000000000000000008aab5844d9fde025f581456b900a0fef8fe0913000000000000000000000000000000000000000000000000000000005aaa5447000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000009c4","Library":"","SwarmSource":"bzzr://c186440e9c4fb687b4bc94005d38f2716ac9d68244e5257dc8498fe0a456b475"}]}