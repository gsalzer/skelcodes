{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// Wolf Crypto pooling contract\r\n// written by @iamdefinitelyahuman\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n  function balanceOf(address _owner) external returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface WhiteList {\r\n   function isPaidUntil (address addr) external view returns (uint);\r\n}\r\n\r\n\r\ncontract PresalePool {\r\n\r\n  // SafeMath is a library to ensure that math operations do not have overflow errors\r\n  // https://zeppelin-solidity.readthedocs.io/en/latest/safemath.html\r\n  using SafeMath for uint;\r\n  \r\n  // The contract has 2 stages:\r\n  // 1 - The initial state. The owner is able to add addresses to the whitelist, and any whitelisted addresses can deposit or withdraw eth to the contract.\r\n  // 2 - The eth is sent from the contract to the receiver. Unused eth can be claimed by contributors immediately. Once tokens are sent to the contract,\r\n  //     the owner enables withdrawals and contributors can withdraw their tokens.\r\n  uint8 public contractStage = 1;\r\n  \r\n  // These variables are set at the time of contract creation\r\n  // address that creates the contract\r\n  address public owner;\r\n  uint maxContractBalance;\r\n  // maximum eth amount (in wei) that can be sent by a whitelisted address\r\n  uint contributionCap;\r\n  // the % of tokens kept by the contract owner\r\n  uint public feePct;\r\n  // the address that the pool will be paid out to\r\n  address public receiverAddress;\r\n  \r\n  // These constant variables do not change with each contract deployment\r\n  // minimum eth amount (in wei) that can be sent by a whitelisted address\r\n  uint constant public contributionMin = 100000000000000000;\r\n  // maximum gas price allowed for deposits in stage 1\r\n  uint constant public maxGasPrice = 50000000000;\r\n  // whitelisting contract\r\n  WhiteList constant public whitelistContract = WhiteList(0xf6E386FA4794B58350e7B4Cb32B6f86Fb0F357d4);\r\n  bool whitelistIsActive = true;\r\n  \r\n  // These variables are all initially set to 0 and will be set at some point during the contract\r\n  // epoch time that the next contribution caps become active\r\n  uint public nextCapTime;\r\n  // pending contribution caps\r\n  uint public nextContributionCap;\r\n  // block number of the last change to the receiving address (set if receiving address is changed, stage 1)\r\n  uint public addressChangeBlock;\r\n  // amount of eth (in wei) present in the contract when it was submitted\r\n  uint public finalBalance;\r\n  // array containing eth amounts to be refunded in stage 2\r\n  uint[] public ethRefundAmount;\r\n  // default token contract to be used for withdrawing tokens in stage 2\r\n  address public activeToken;\r\n  \r\n  // data structure for holding the contribution amount, cap, eth refund status, and token withdrawal status for each whitelisted address\r\n  struct Contributor {\r\n    uint ethRefund;\r\n    uint balance;\r\n    uint cap;\r\n    mapping (address => uint) tokensClaimed;\r\n  }\r\n  // mapping that holds the contributor struct for each whitelisted address\r\n  mapping (address => Contributor) whitelist;\r\n  \r\n  // data structure for holding information related to token withdrawals.\r\n  struct TokenAllocation {\r\n    ERC20 token;\r\n    uint[] pct;\r\n    uint balanceRemaining;\r\n  }\r\n  // mapping that holds the token allocation struct for each token address\r\n  mapping (address => TokenAllocation) distributionMap;\r\n  \r\n  \r\n  // modifier for functions that can only be accessed by the contract creator\r\n  modifier onlyOwner () {\r\n    require (msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  // modifier to prevent re-entrancy exploits during contract > contract interaction\r\n  bool locked;\r\n  modifier noReentrancy() {\r\n    require(!locked);\r\n    locked = true;\r\n    _;\r\n    locked = false;\r\n  }\r\n  \r\n  // Events triggered throughout contract execution\r\n  // These can be watched via geth filters to keep up-to-date with the contract\r\n  event ContributorBalanceChanged (address contributor, uint totalBalance);\r\n  event ReceiverAddressSet ( address _addr);\r\n  event PoolSubmitted (address receiver, uint amount);\r\n  event WithdrawalsOpen (address tokenAddr);\r\n  event TokensWithdrawn (address receiver, address token, uint amount);\r\n  event EthRefundReceived (address sender, uint amount);\r\n  event EthRefunded (address receiver, uint amount);\r\n  event ERC223Received (address token, uint value);\r\n   \r\n  // These are internal functions used for calculating fees, eth and token allocations as %\r\n  // returns a value as a % accurate to 20 decimal points\r\n  function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\r\n    return numerator.mul(10 ** 20) / denominator;\r\n  }\r\n  \r\n  // returns % of any number, where % given was generated with toPct\r\n  function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\r\n    return numerator.mul(pct) / (10 ** 20);\r\n  }\r\n  \r\n  // This function is called at the time of contract creation,\r\n  // it sets the initial variables and whitelists the contract owner.\r\n  function PresalePool (address receiverAddr, uint contractCap, uint cap, uint fee) public {\r\n    require (fee < 100);\r\n    require (contractCap >= cap);\r\n    owner = msg.sender;\r\n    receiverAddress = receiverAddr;\r\n    maxContractBalance = contractCap;\r\n    contributionCap = cap;\r\n    feePct = _toPct(fee,100);\r\n  }\r\n  \r\n  // This function is called whenever eth is sent into the contract.\r\n  // The send will fail unless the contract is in stage one and the sender has been whitelisted.\r\n  // The amount sent is added to the balance in the Contributor struct associated with the sending address.\r\n  function () payable public {\r\n    if (contractStage == 1) {\r\n      _ethDeposit();\r\n    } else _ethRefund();\r\n  }\r\n  \r\n  // Internal function for handling eth deposits during contract stage one.\r\n  function _ethDeposit () internal {\r\n    assert (contractStage == 1);\r\n    require (!whitelistIsActive || whitelistContract.isPaidUntil(msg.sender) > now);\r\n    require (tx.gasprice <= maxGasPrice);\r\n    require (this.balance <= maxContractBalance);\r\n    var c = whitelist[msg.sender];\r\n    uint newBalance = c.balance.add(msg.value);\r\n    require (newBalance >= contributionMin);\r\n    if (nextCapTime > 0 && nextCapTime < now) {\r\n      contributionCap = nextContributionCap;\r\n      nextCapTime = 0;\r\n    }\r\n    if (c.cap > 0) require (newBalance <= c.cap);\r\n    else require (newBalance <= contributionCap);\r\n    c.balance = newBalance;\r\n    ContributorBalanceChanged(msg.sender, newBalance);\r\n  }\r\n  \r\n  // Internal function for handling eth refunds during stage two.\r\n  function _ethRefund () internal {\r\n    assert (contractStage == 2);\r\n    require (msg.sender == owner || msg.sender == receiverAddress);\r\n    require (msg.value >= contributionMin);\r\n    ethRefundAmount.push(msg.value);\r\n    EthRefundReceived(msg.sender, msg.value);\r\n  }\r\n  \r\n  // This function is called to withdraw eth or tokens from the contract.\r\n  // It can only be called by addresses that are whitelisted and show a balance greater than 0.\r\n  // If called during stage one, the full eth balance deposited into the contract is returned and the contributor's balance reset to 0.\r\n  // If called during stage two, the contributor's unused eth will be returned, as well as any available tokens.\r\n  // The token address may be provided optionally to withdraw tokens that are not currently the default token (airdrops).\r\n  function withdraw (address tokenAddr) public {\r\n    var c = whitelist[msg.sender];\r\n    require (c.balance > 0);\r\n    if (contractStage == 1) {\r\n      uint amountToTransfer = c.balance;\r\n      c.balance = 0;\r\n      msg.sender.transfer(amountToTransfer);\r\n      ContributorBalanceChanged(msg.sender, 0);\r\n    } else {\r\n      _withdraw(msg.sender,tokenAddr);\r\n    }  \r\n  }\r\n  \r\n  // This function allows the contract owner to force a withdrawal to any contributor.\r\n  function withdrawFor (address contributor, address tokenAddr) public onlyOwner {\r\n    require (contractStage == 2);\r\n    require (whitelist[contributor].balance > 0);\r\n    _withdraw(contributor,tokenAddr);\r\n  }\r\n  \r\n  // This internal function handles withdrawals during stage two.\r\n  // The associated events will fire to notify when a refund or token allocation is claimed.\r\n  function _withdraw (address receiver, address tokenAddr) internal {\r\n    assert (contractStage == 2);\r\n    var c = whitelist[receiver];\r\n    if (tokenAddr == 0x00) {\r\n      tokenAddr = activeToken;\r\n    }\r\n    var d = distributionMap[tokenAddr];\r\n    require ( (ethRefundAmount.length > c.ethRefund) || d.pct.length > c.tokensClaimed[tokenAddr] );\r\n    if (ethRefundAmount.length > c.ethRefund) {\r\n      uint pct = _toPct(c.balance,finalBalance);\r\n      uint ethAmount = 0;\r\n      for (uint i=c.ethRefund; i<ethRefundAmount.length; i++) {\r\n        ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct));\r\n      }\r\n      c.ethRefund = ethRefundAmount.length;\r\n      if (ethAmount > 0) {\r\n        receiver.transfer(ethAmount);\r\n        EthRefunded(receiver,ethAmount);\r\n      }\r\n    }\r\n    if (d.pct.length > c.tokensClaimed[tokenAddr]) {\r\n      uint tokenAmount = 0;\r\n      for (i=c.tokensClaimed[tokenAddr]; i<d.pct.length; i++) {\r\n        tokenAmount = tokenAmount.add(_applyPct(c.balance,d.pct[i]));\r\n      }\r\n      c.tokensClaimed[tokenAddr] = d.pct.length;\r\n      if (tokenAmount > 0) {\r\n        require(d.token.transfer(receiver,tokenAmount));\r\n        d.balanceRemaining = d.balanceRemaining.sub(tokenAmount);\r\n        TokensWithdrawn(receiver,tokenAddr,tokenAmount);\r\n      }  \r\n    }\r\n    \r\n  }\r\n  \r\n  \r\n  // This function is called by the owner to modify the contribution cap of a whitelisted address.\r\n  // If the current contribution balance exceeds the new cap, the excess balance is refunded.\r\n  function modifyIndividualCap (address addr, uint cap) public onlyOwner {\r\n    require (contractStage == 1);\r\n    require (cap <= maxContractBalance);\r\n    var c = whitelist[addr];\r\n    require (cap >= c.balance);\r\n    c.cap = cap;\r\n  }\r\n  \r\n  // This function is called by the owner to modify the cap.\r\n  function modifyCap (uint cap) public onlyOwner {\r\n    require (contractStage == 1);\r\n    require (contributionCap <= cap && maxContractBalance >= cap);\r\n    contributionCap = cap;\r\n    nextCapTime = 0;\r\n  }\r\n  \r\n  // This function is called by the owner to modify the cap at a future time.\r\n  function modifyNextCap (uint time, uint cap) public onlyOwner {\r\n    require (contractStage == 1);\r\n    require (contributionCap <= cap && maxContractBalance >= cap);\r\n    require (time > now);\r\n    nextCapTime = time;\r\n    nextContributionCap = cap;\r\n  }\r\n  \r\n  // This function is called to modify the maximum balance of the contract.\r\n  function modifyMaxContractBalance (uint amount) public onlyOwner {\r\n    require (contractStage == 1);\r\n    require (amount >= contributionMin);\r\n    require (amount >= this.balance);\r\n    maxContractBalance = amount;\r\n    if (amount < contributionCap) contributionCap = amount;\r\n  }\r\n  \r\n  function toggleWhitelist (bool active) public onlyOwner {\r\n    whitelistIsActive = active;\r\n  }\r\n  \r\n  // This callable function returns the total pool cap, current balance and remaining balance to be filled.\r\n  function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) {\r\n    if (contractStage == 1) {\r\n      remaining = maxContractBalance.sub(this.balance);\r\n    } else {\r\n      remaining = 0;\r\n    }\r\n    return (maxContractBalance,this.balance,remaining);\r\n  }\r\n  \r\n  // This callable function returns the balance, contribution cap, and remaining available balance of any contributor.\r\n  function checkContributorBalance (address addr) view public returns (uint balance, uint cap, uint remaining) {\r\n    var c = whitelist[addr];\r\n    if (contractStage == 2) return (c.balance,0,0);\r\n    if (whitelistIsActive && whitelistContract.isPaidUntil(addr) < now) return (c.balance,0,0);\r\n    if (c.cap > 0) cap = c.cap;\r\n    else cap = contributionCap;\r\n    if (cap.sub(c.balance) > maxContractBalance.sub(this.balance)) return (c.balance, cap, maxContractBalance.sub(this.balance));\r\n    return (c.balance, cap, cap.sub(c.balance));\r\n  }\r\n  \r\n  // This callable function returns the token balance that a contributor can currently claim.\r\n  function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) {\r\n    var c = whitelist[addr];\r\n    var d = distributionMap[tokenAddr];\r\n    for (uint i = c.tokensClaimed[tokenAddr]; i < d.pct.length; i++) {\r\n      tokenAmount = tokenAmount.add(_applyPct(c.balance, d.pct[i]));\r\n    }\r\n    return tokenAmount;\r\n  }\r\n   \r\n  // This function sets the receiving address that the contract will send the pooled eth to.\r\n  // It can only be called by the contract owner if the receiver address has not already been set.\r\n  // After making this call, the contract will be unable to send the pooled eth for 6000 blocks.\r\n  // This limitation is so that if the owner acts maliciously in making the change, all whitelisted\r\n  // addresses have ~24 hours to withdraw their eth from the contract.\r\n  function setReceiverAddress (address addr) public onlyOwner {\r\n    require (contractStage == 1);\r\n    receiverAddress = addr;\r\n    addressChangeBlock = block.number;\r\n    ReceiverAddressSet(addr);\r\n  }\r\n\r\n  // This function sends the pooled eth to the receiving address, calculates the % of unused eth to be returned,\r\n  // and advances the contract to stage two. It can only be called by the contract owner during stages one or two.\r\n  // The amount to send (given in wei) must be specified during the call. As this function can only be executed once,\r\n  // it is VERY IMPORTANT not to get the amount wrong.\r\n  function submitPool (uint amountInWei) public onlyOwner noReentrancy {\r\n    require (contractStage == 1);\r\n    require (receiverAddress != 0x00);\r\n    require (block.number >= addressChangeBlock.add(6000));\r\n    if (amountInWei == 0) amountInWei = this.balance;\r\n    require (contributionMin <= amountInWei && amountInWei <= this.balance);\r\n    finalBalance = this.balance;\r\n    require (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());\r\n    if (this.balance > 0) ethRefundAmount.push(this.balance);\r\n    contractStage = 2;\r\n    PoolSubmitted(receiverAddress, amountInWei);\r\n  }\r\n  \r\n  // This function opens the contract up for token withdrawals.\r\n  // It can only be called by the owner during stage two.  The owner specifies the address of an ERC20 token\r\n  // contract that this contract has a balance in, and optionally a bool to prevent this token from being\r\n  // the default withdrawal (in the event of an airdrop, for example).\r\n  function enableTokenWithdrawals (address tokenAddr, bool notDefault) public onlyOwner noReentrancy {\r\n    require (contractStage == 2);\r\n    if (notDefault) {\r\n      require (activeToken != 0x00);\r\n    } else {\r\n      activeToken = tokenAddr;\r\n    }\r\n    var d = distributionMap[tokenAddr];    \r\n    if (d.pct.length==0) d.token = ERC20(tokenAddr);\r\n    uint amount = d.token.balanceOf(this).sub(d.balanceRemaining);\r\n    require (amount > 0);\r\n    if (feePct > 0) {\r\n      require (d.token.transfer(owner,_applyPct(amount,feePct)));\r\n    }\r\n    amount = d.token.balanceOf(this).sub(d.balanceRemaining);\r\n    d.balanceRemaining = d.token.balanceOf(this);\r\n    d.pct.push(_toPct(amount,finalBalance));\r\n  }\r\n  \r\n  // This is a standard function required for ERC223 compatibility.\r\n  function tokenFallback (address from, uint value, bytes data) public {\r\n    ERC223Received (from, value);\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"checkPoolBalance\",\"outputs\":[{\"name\":\"poolCap\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiverAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextContributionCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"modifyNextCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"submitPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"notDefault\",\"type\":\"bool\"}],\"name\":\"enableTokenWithdrawals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethRefundAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"checkAvailableTokens\",\"outputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressChangeBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"modifyCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"toggleWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReceiverAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"modifyMaxContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkContributorBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"modifyIndividualCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextCapTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"receiverAddr\",\"type\":\"address\"},{\"name\":\"contractCap\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"ContributorBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"ReceiverAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"WithdrawalsOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthRefundReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ERC223Received\",\"type\":\"event\"}]","ContractName":"PresalePool","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f23dbc71e0aaa1ec59a494b71c09ec70ed08b6c000000000000000000000000000000000000000000000006c6b935b8bbd4000000000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://dbc674234dad26178ed3a8996c416cf6dacfbbf7627223c1394b954d191b3659"}]}