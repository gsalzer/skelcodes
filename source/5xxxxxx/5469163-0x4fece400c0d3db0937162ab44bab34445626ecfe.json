{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// The contract uses code from zeppelin-solidity library\r\n// licensed under MIT license\r\n// https://github.com/OpenZeppelin/zeppelin-solidity\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n    function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n    function name() public view returns (string _name);\r\n    function symbol() public view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n    /**\r\n     * @dev Magic value to be returned upon successful reception of an NFT\r\n     *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n     *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n     */\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n     *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n     *  than the magic value MUST result in the transaction being reverted.\r\n     *  Note: the contract address is always the message sender.\r\n     * @param _from The sending address\r\n     * @param _tokenId The NFT identifier which is being transfered\r\n     * @param _data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is ERC721Basic {\r\n    using SafeMath for uint256;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) internal tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) internal ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n    /**\r\n    * @dev Guarantees msg.sender is owner of the given token\r\n    * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n    */\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n    * @param _tokenId uint256 ID of the token to validate\r\n    */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        require(isApprovedOrOwner(msg.sender, _tokenId));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address\r\n    * @param _owner address to query the balance of\r\n    * @return uint256 representing the amount owned by the passed address\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownedTokensCount[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the owner of the specified token ID\r\n    * @param _tokenId uint256 ID of the token to query the owner of\r\n    * @return owner address currently marked as the owner of the given token ID\r\n    */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns whether the specified token exists\r\n    * @param _tokenId uint256 ID of the token to query the existance of\r\n    * @return whether the token exists\r\n    */\r\n    function exists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Approves another address to transfer the given token ID\r\n    * @dev The zero address indicates there is no approved address.\r\n    * @dev There can only be one approved address per token at a given time.\r\n    * @dev Can only be called by the token owner or an approved operator.\r\n    * @param _to address to be approved for the given token ID\r\n    * @param _tokenId uint256 ID of the token to be approved\r\n    */\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n            tokenApprovals[_tokenId] = _to;\r\n            emit Approval(owner, _to, _tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * @param _tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for a the given token ID\r\n     */\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev Sets or unsets the approval of a given operator\r\n    * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n    * @param _to operator address to set the approval\r\n    * @param _approved representing the status of the approval to be set\r\n    */\r\n    function setApprovalForAll(address _to, bool _approved) public {\r\n        require(_to != msg.sender);\r\n        operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param _owner owner address which you want to query the approval of\r\n     * @param _operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the ownership of a given token ID to another address\r\n    * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n    *  which is called upon a safe transfer, and return the magic value\r\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n    *  the transfer is reverted.\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n    *  which is called upon a safe transfer, and return the magic value\r\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n    *  the transfer is reverted.\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes data to send along with a safe transfer check\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        transferFrom(_from, _to, _tokenId);\r\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param _spender address of the spender to query\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *  is an operator of the owner, or is the owner of the token\r\n     */\r\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(_tokenId);\r\n        return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to mint a new token\r\n    * @dev Reverts if the given token ID already exists\r\n    * @param _to The address that will own the minted token\r\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n    */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * @dev Reverts if the token does not exist\r\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n    */\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        clearApproval(_owner, _tokenId);\r\n        removeTokenFrom(_owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to clear current approval of a given token ID\r\n    * @dev Reverts if the given address is not indeed the owner of the token\r\n    * @param _owner owner of the token\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n            emit Approval(_owner, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to add a token ID to the list of a given address\r\n    * @param _to address representing the new owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require(tokenOwner[_tokenId] == address(0));\r\n        tokenOwner[_tokenId] = _to;\r\n        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to remove a token ID from the list of a given address\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n    */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _from);\r\n        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n        tokenOwner[_tokenId] = address(0);\r\n    }\r\n\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     *  as the code is not actually created until after the constructor finishes.\r\n     * @param _user address to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function _isContract(address _user) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(_user) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to invoke `onERC721Received` on a target address\r\n    * @dev The call is not executed if the target address is not a contract\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _to target address that will receive the tokens\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes optional data to send along with the call\r\n    * @return whether the call correctly returned the expected magic value\r\n    */\r\n    function checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (!_isContract(_to)) {\r\n            return true;\r\n        }\r\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\r\n        return (retval == ERC721_RECEIVED);\r\n    }\r\n\r\n}\r\n\r\ncontract Owned {\r\n    address owner;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev Contract constructor\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n}\r\n\r\ncontract HeroLogicInterface {\r\n    function isTransferAllowed(address _from, address _to, uint256 _tokenId) public view returns (bool);\r\n}\r\n\r\ncontract ETHero is Owned, ERC721, ERC721BasicToken {\r\n\r\n    struct HeroData {\r\n        uint16 fieldA;\r\n        uint16 fieldB;\r\n        uint32 fieldC;\r\n        uint32 fieldD;\r\n        uint32 fieldE;\r\n        uint64 fieldF;\r\n        uint64 fieldG;\r\n    }\r\n\r\n    // Token name\r\n    string internal name_;\r\n\r\n    // Token symbol\r\n    string internal symbol_;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping (address => uint256[]) internal ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] internal allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n    // Prefix for token URIs\r\n    string public tokenUriPrefix = \"https://eth.town/hero-image/\";\r\n\r\n    // Interchangeable logic contract\r\n    address public logicContract;\r\n\r\n    // Incremental uniqueness index for the genome\r\n    uint32 public uniquenessIndex = 0;\r\n    // Last token ID\r\n    uint256 public lastTokenId = 0;\r\n\r\n    // Users' active heroes\r\n    mapping(address => uint256) public activeHero;\r\n\r\n    // Hero data\r\n    mapping(uint256 => HeroData) public heroData;\r\n\r\n    // Genomes\r\n    mapping(uint256 => uint256) public genome;\r\n\r\n    event ActiveHeroChanged(address indexed _from, uint256 _tokenId);\r\n\r\n    modifier onlyLogicContract {\r\n        require(msg.sender == logicContract || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    function ETHero() public {\r\n        name_ = \"ETH.TOWN Hero\";\r\n        symbol_ = \"HERO\";\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the token's interchangeable logic contract\r\n    */\r\n    function setLogicContract(address _logicContract) external onlyOwner {\r\n        logicContract = _logicContract;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token name\r\n    * @return string representing the token name\r\n    */\r\n    function name() public view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token symbol\r\n    */\r\n    function symbol() public view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to check if transferring a specific token is allowed\r\n    * @param _from transfer from\r\n    * @param _to transfer to\r\n    * @param _tokenId token to transfer\r\n    */\r\n    function _isTransferAllowed(address _from, address _to, uint256 _tokenId) internal view returns (bool) {\r\n        if (logicContract == address(0)) {\r\n            return true;\r\n        }\r\n\r\n        HeroLogicInterface logic = HeroLogicInterface(logicContract);\r\n        return logic.isTransferAllowed(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends uint (in decimal) to a string\r\n    * @param _str The prefix string\r\n    * @param _value The uint to append\r\n    * @return resulting string\r\n    */\r\n    function _appendUintToString(string _str, uint _value) internal pure returns (string) {\r\n        uint maxLength = 100;\r\n        bytes memory reversed = new bytes(maxLength);\r\n        uint i = 0;\r\n        while (_value != 0) {\r\n            uint remainder = _value % 10;\r\n            _value = _value / 10;\r\n            reversed[i++] = byte(48 + remainder);\r\n        }\r\n        i--;\r\n\r\n        bytes memory inStrB = bytes(_str);\r\n        bytes memory s = new bytes(inStrB.length + i + 1);\r\n        uint j;\r\n        for (j = 0; j < inStrB.length; j++) {\r\n            s[j] = inStrB[j];\r\n        }\r\n        for (j = 0; j <= i; j++) {\r\n            s[j + inStrB.length] = reversed[i - j];\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns an URI for a given token ID\r\n    * @dev Throws if the token ID does not exist\r\n    * @param _tokenId uint256 ID of the token to query\r\n    */\r\n    function tokenURI(uint256 _tokenId) public view returns (string) {\r\n        require(exists(_tokenId));\r\n        return _appendUintToString(tokenUriPrefix, genome[_tokenId]);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n    * @param _owner address owning the tokens list to be accessed\r\n    * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n    * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n    */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n        require(_index < balanceOf(_owner));\r\n        return ownedTokens[_owner][_index];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the total amount of tokens stored by the contract\r\n    * @return uint256 representing the total amount of tokens\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of all the tokens in this contract\r\n    * @dev Reverts if the index is greater or equal to the total number of tokens\r\n    * @param _index uint256 representing the index to be accessed of the tokens list\r\n    * @return uint256 token ID at the given index of the tokens list\r\n    */\r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        require(_index < totalSupply());\r\n        return allTokens[_index];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to add a token ID to the list of a given address\r\n    * @param _to address representing the new owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        super.addTokenTo(_to, _tokenId);\r\n        uint256 length = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n        ownedTokensIndex[_tokenId] = length;\r\n\r\n        if (activeHero[_to] == 0) {\r\n            activeHero[_to] = _tokenId;\r\n            emit ActiveHeroChanged(_to, _tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to remove a token ID from the list of a given address\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n    */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        super.removeTokenFrom(_from, _tokenId);\r\n\r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        ownedTokens[_from][lastTokenIndex] = 0;\r\n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n        ownedTokens[_from].length--;\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n\r\n        // If a hero is removed from its owner, it no longer can be their active hero\r\n        if (activeHero[_from] == _tokenId) {\r\n            activeHero[_from] = 0;\r\n            emit ActiveHeroChanged(_from, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to mint a new token\r\n    * @dev Reverts if the given token ID already exists\r\n    * @param _to address the beneficiary that will own the minted token\r\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n    */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n\r\n        allTokensIndex[_tokenId] = allTokens.length;\r\n        allTokens.push(_tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev External function to mint a new token\r\n    * @dev Reverts if the given token ID already exists\r\n    * @param _to address the beneficiary that will own the minted token\r\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n    */\r\n    function mint(address _to, uint256 _tokenId) external onlyLogicContract {\r\n        _mint(_to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * @dev Reverts if the token does not exist\r\n    * @param _owner owner of the token to burn\r\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n    */\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        clearApproval(_owner, _tokenId);\r\n        removeTokenFrom(_owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n\r\n        // Reorg all tokens array\r\n        uint256 tokenIndex = allTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = allTokens.length.sub(1);\r\n        uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n        allTokens[tokenIndex] = lastToken;\r\n        allTokens[lastTokenIndex] = 0;\r\n\r\n        allTokens.length--;\r\n        allTokensIndex[_tokenId] = 0;\r\n        allTokensIndex[lastToken] = tokenIndex;\r\n\r\n        // Clear genome data\r\n        if (genome[_tokenId] != 0) {\r\n            genome[_tokenId] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev External function to burn a specific token\r\n    * @dev Reverts if the token does not exist\r\n    * @param _owner owner of the token to burn\r\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n    */\r\n    function burn(address _owner, uint256 _tokenId) external onlyLogicContract {\r\n        _burn(_owner, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the ownership of a given token ID to another address\r\n    * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\r\n        require(_isTransferAllowed(_from, _to, _tokenId));\r\n        super.transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n    *  which is called upon a safe transfer, and return the magic value\r\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n    *  the transfer is reverted.\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        require(_isTransferAllowed(_from, _to, _tokenId));\r\n        super.safeTransferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n    *  which is called upon a safe transfer, and return the magic value\r\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n    *  the transfer is reverted.\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes data to send along with a safe transfer check\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data)\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        require(_isTransferAllowed(_from, _to, _tokenId));\r\n        super.safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows to transfer a token to another owner\r\n    * @param _to transfer to\r\n    * @param _tokenId token to transfer\r\n    */\r\n    function transfer(address _to, uint256 _tokenId) external onlyOwnerOf(_tokenId) {\r\n        require(_isTransferAllowed(msg.sender, _to, _tokenId));\r\n        require(_to != address(0));\r\n\r\n        clearApproval(msg.sender, _tokenId);\r\n        removeTokenFrom(msg.sender, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the specified token as user's active Hero\r\n    * @param _tokenId the hero token to set as active\r\n    */\r\n    function setActiveHero(uint256 _tokenId) external onlyOwnerOf(_tokenId) {\r\n        activeHero[msg.sender] = _tokenId;\r\n        emit ActiveHeroChanged(msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Queries list of tokens owned by a specific address\r\n    * @param _owner the address to get tokens of\r\n    */\r\n    function tokensOfOwner(address _owner) external view returns (uint256[]) {\r\n        return ownedTokens[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the genome of the active hero\r\n    * @param _owner the address to get hero of\r\n    */\r\n    function activeHeroGenome(address _owner) public view returns (uint256) {\r\n        uint256 tokenId = activeHero[_owner];\r\n        if (tokenId == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return genome[tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev Increments uniqueness index. Overflow intentionally allowed.\r\n    */\r\n    function incrementUniquenessIndex() external onlyLogicContract {\r\n        uniquenessIndex ++;\r\n    }\r\n\r\n    /**\r\n    * @dev Increments lastTokenId\r\n    */\r\n    function incrementLastTokenId() external onlyLogicContract {\r\n        lastTokenId ++;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows (re-)setting the uniqueness index\r\n    * @param _uniquenessIndex new value\r\n    */\r\n    function setUniquenessIndex(uint32 _uniquenessIndex) external onlyOwner {\r\n        uniquenessIndex = _uniquenessIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows (re-)setting lastTokenId\r\n    * @param _lastTokenId new value\r\n    */\r\n    function setLastTokenId(uint256 _lastTokenId) external onlyOwner {\r\n        lastTokenId = _lastTokenId;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows setting hero data for a hero\r\n    * @param _tokenId hero to set data for\r\n    * @param _fieldA data to set\r\n    * @param _fieldB data to set\r\n    * @param _fieldC data to set\r\n    * @param _fieldD data to set\r\n    * @param _fieldE data to set\r\n    * @param _fieldF data to set\r\n    * @param _fieldG data to set\r\n    */\r\n    function setHeroData(\r\n        uint256 _tokenId,\r\n        uint16 _fieldA,\r\n        uint16 _fieldB,\r\n        uint32 _fieldC,\r\n        uint32 _fieldD,\r\n        uint32 _fieldE,\r\n        uint64 _fieldF,\r\n        uint64 _fieldG\r\n    ) external onlyLogicContract {\r\n        heroData[_tokenId] = HeroData(\r\n            _fieldA,\r\n            _fieldB,\r\n            _fieldC,\r\n            _fieldD,\r\n            _fieldE,\r\n            _fieldF,\r\n            _fieldG\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Allows setting hero genome\r\n    * @param _tokenId token to set data for\r\n    * @param _genome genome data to set\r\n    */\r\n    function setGenome(uint256 _tokenId, uint256 _genome) external onlyLogicContract {\r\n        genome[_tokenId] = _genome;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the admin to forcefully transfer a token from one address to another\r\n    * @param _from transfer from\r\n    * @param _to transfer to\r\n    * @param _tokenId token to transfer\r\n    */\r\n    function forceTransfer(address _from, address _to, uint256 _tokenId) external onlyLogicContract {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev External function to set the token URI prefix for all tokens\r\n    * @param _uriPrefix prefix string to assign\r\n    */\r\n    function setTokenUriPrefix(string _uriPrefix) external onlyOwner {\r\n        tokenUriPrefix = _uriPrefix;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"activeHeroGenome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"activeHero\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"incrementUniquenessIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"setActiveHero\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"forceTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uriPrefix\",\"type\":\"string\"}],\"name\":\"setTokenUriPrefix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_logicContract\",\"type\":\"address\"}],\"name\":\"setLogicContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_fieldA\",\"type\":\"uint16\"},{\"name\":\"_fieldB\",\"type\":\"uint16\"},{\"name\":\"_fieldC\",\"type\":\"uint32\"},{\"name\":\"_fieldD\",\"type\":\"uint32\"},{\"name\":\"_fieldE\",\"type\":\"uint32\"},{\"name\":\"_fieldF\",\"type\":\"uint64\"},{\"name\":\"_fieldG\",\"type\":\"uint64\"}],\"name\":\"setHeroData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"heroData\",\"outputs\":[{\"name\":\"fieldA\",\"type\":\"uint16\"},{\"name\":\"fieldB\",\"type\":\"uint16\"},{\"name\":\"fieldC\",\"type\":\"uint32\"},{\"name\":\"fieldD\",\"type\":\"uint32\"},{\"name\":\"fieldE\",\"type\":\"uint32\"},{\"name\":\"fieldF\",\"type\":\"uint64\"},{\"name\":\"fieldG\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uniquenessIndex\",\"type\":\"uint32\"}],\"name\":\"setUniquenessIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"incrementLastTokenId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logicContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"genome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lastTokenId\",\"type\":\"uint256\"}],\"name\":\"setLastTokenId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniquenessIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_genome\",\"type\":\"uint256\"}],\"name\":\"setGenome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenUriPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ActiveHeroChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"ETHero","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://17bfcef20c0dcc7aa0b7d98abedad0970445dcced96cd76799df1f4fc0358e93"}]}