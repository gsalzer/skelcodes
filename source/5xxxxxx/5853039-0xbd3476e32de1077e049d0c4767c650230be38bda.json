{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n/**\r\n * Changes by https://www.docademic.com/\r\n */\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Destroyable is Ownable{\r\n    /**\r\n     * @notice Allows to destroy the contract and return the tokens to the owner.\r\n     */\r\n    function destroy() public onlyOwner{\r\n        selfdestruct(owner);\r\n    }\r\n}\r\n\r\ninterface Token {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function balanceOf(address who) view external returns (uint256);\r\n}\r\n\r\ncontract Airdrop is Ownable, Destroyable {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     *   Structures\r\n     */\r\n    // Holder of tokens\r\n    struct Beneficiary {\r\n        uint256 balance;\r\n        uint256 airdrop;\r\n        bool isBeneficiary;\r\n    }\r\n\r\n    /*\r\n     *  State\r\n     */\r\n    bool public filled;\r\n    bool public airdropped;\r\n    uint256 public airdropLimit;\r\n    uint256 public currentCirculating;\r\n    uint256 public toVault;\r\n    address public vault;\r\n    address[] public addresses;\r\n    Token public token;\r\n    mapping(address => Beneficiary) public beneficiaries;\r\n\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event NewBeneficiary(address _beneficiary);\r\n    event SnapshotTaken(uint256 _totalBalance, uint256 _totalAirdrop, uint256 _toBurn,uint256 _numberOfBeneficiaries, uint256 _numberOfAirdrops);\r\n    event Airdropped(uint256 _totalAirdrop, uint256 _numberOfAirdrops);\r\n    event TokenChanged(address _prevToken, address _token);\r\n    event VaultChanged(address _prevVault, address _vault);\r\n    event AirdropLimitChanged(uint256 _prevLimit, uint256 _airdropLimit);\r\n    event CurrentCirculatingChanged(uint256 _prevCirculating, uint256 _currentCirculating);\r\n    event Cleaned(uint256 _numberOfBeneficiaries);\r\n    event Vaulted(uint256 _tokensBurned);\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier isNotBeneficiary(address _beneficiary) {\r\n        require(!beneficiaries[_beneficiary].isBeneficiary);\r\n        _;\r\n    }\r\n    modifier isBeneficiary(address _beneficiary) {\r\n        require(beneficiaries[_beneficiary].isBeneficiary);\r\n        _;\r\n    }\r\n    modifier isFilled() {\r\n        require(filled);\r\n        _;\r\n    }\r\n    modifier isNotFilled() {\r\n        require(!filled);\r\n        _;\r\n    }\r\n    modifier wasAirdropped() {\r\n        require(airdropped);\r\n        _;\r\n    }\r\n    modifier wasNotAirdropped() {\r\n        require(!airdropped);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Behavior\r\n     */\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _token The token address\r\n     * @param _airdropLimit The token limit by airdrop in wei\r\n     * @param _currentCirculating The current circulating tokens in wei\r\n     * @param _vault The address where tokens will be vaulted\r\n     */\r\n    function Airdrop(address _token, uint256 _airdropLimit, uint256 _currentCirculating, address _vault) public{\r\n        require(_token != address(0));\r\n        token = Token(_token);\r\n        airdropLimit = _airdropLimit;\r\n        currentCirculating = _currentCirculating;\r\n        vault = _vault;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the sender to register itself as a beneficiary for the airdrop.\r\n     */\r\n    function() payable public {\r\n        addBeneficiary(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the sender to register itself as a beneficiary for the airdrop.\r\n     */\r\n    function register() public {\r\n        addBeneficiary(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to register a beneficiary for the airdrop.\r\n     * @param _beneficiary The address of the beneficiary\r\n     */\r\n    function registerBeneficiary(address _beneficiary) public\r\n    onlyOwner {\r\n        addBeneficiary(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to register beneficiaries for the airdrop.\r\n     * @param _beneficiaries The array of addresses\r\n     */\r\n    function registerBeneficiaries(address[] _beneficiaries) public\r\n    onlyOwner {\r\n        for (uint i = 0; i < _beneficiaries.length; i++) {\r\n            addBeneficiary(_beneficiaries[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add a beneficiary for the airdrop.\r\n     * @param _beneficiary The address of the beneficiary\r\n     */\r\n    function addBeneficiary(address _beneficiary) private\r\n    isNotBeneficiary(_beneficiary) {\r\n        require(_beneficiary != address(0));\r\n        beneficiaries[_beneficiary] = Beneficiary({\r\n            balance : 0,\r\n            airdrop : 0,\r\n            isBeneficiary : true\r\n            });\r\n        addresses.push(_beneficiary);\r\n        emit NewBeneficiary(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @dev Take the balance of all the beneficiaries.\r\n     */\r\n    function takeSnapshot() public\r\n    onlyOwner\r\n    isNotFilled\r\n    wasNotAirdropped {\r\n        uint256 totalBalance = 0;\r\n        uint256 totalAirdrop = 0;\r\n        uint256 airdrops = 0;\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            Beneficiary storage beneficiary = beneficiaries[addresses[i]];\r\n            beneficiary.balance = token.balanceOf(addresses[i]);\r\n            totalBalance = totalBalance.add(beneficiary.balance);\r\n            if (beneficiary.balance > 0) {\r\n                beneficiary.airdrop = (beneficiary.balance.mul(airdropLimit).div(currentCirculating));\r\n                totalAirdrop = totalAirdrop.add(beneficiary.airdrop);\r\n                airdrops = airdrops.add(1);\r\n            }\r\n        }\r\n        filled = true;\r\n        toVault = airdropLimit.sub(totalAirdrop);\r\n        emit SnapshotTaken(totalBalance, totalAirdrop, toVault, addresses.length, airdrops);\r\n    }\r\n\r\n    /**\r\n     * @dev Start the airdrop.\r\n     */\r\n    function airdropAndVault() public\r\n    onlyOwner\r\n    isFilled\r\n    wasNotAirdropped {\r\n        uint256 airdrops = 0;\r\n        uint256 totalAirdrop = 0;\r\n        for (uint256 i = 0; i < addresses.length; i++)\r\n        {\r\n            Beneficiary storage beneficiary = beneficiaries[addresses[i]];\r\n            if (beneficiary.airdrop > 0) {\r\n                require(token.transfer(addresses[i], beneficiary.airdrop));\r\n                totalAirdrop = totalAirdrop.add(beneficiary.airdrop);\r\n                airdrops = airdrops.add(1);\r\n            }\r\n        }\r\n        airdropped = true;\r\n        currentCirculating = currentCirculating.add(airdropLimit);\r\n        emit Airdropped(totalAirdrop, airdrops);\r\n\r\n        token.transfer(vault, toVault);\r\n        emit Vaulted(toVault);\r\n    }\r\n\r\n    /**\r\n     * @dev Reset all the balances to 0 and the state to false.\r\n     */\r\n    function clean() public\r\n    onlyOwner {\r\n        for (uint256 i = 0; i < addresses.length; i++)\r\n        {\r\n            Beneficiary storage beneficiary = beneficiaries[addresses[i]];\r\n            beneficiary.balance = 0;\r\n            beneficiary.airdrop = 0;\r\n        }\r\n        filled = false;\r\n        airdropped = false;\r\n        toVault = 0;\r\n        emit Cleaned(addresses.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to change the token address.\r\n     * @param _token New token address.\r\n     */\r\n    function changeToken(address _token) public\r\n    onlyOwner {\r\n        emit TokenChanged(address(token), _token);\r\n        token = Token(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to change the vault address.\r\n     * @param _vault New vault address.\r\n     */\r\n    function changeVault(address _vault) public\r\n    onlyOwner {\r\n        emit VaultChanged(vault, _vault);\r\n        vault = _vault;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to change the token limit by airdrop.\r\n     * @param _airdropLimit The token limit by airdrop in wei.\r\n     */\r\n    function changeAirdropLimit(uint256 _airdropLimit) public\r\n    onlyOwner {\r\n        emit AirdropLimitChanged(airdropLimit, _airdropLimit);\r\n        airdropLimit = _airdropLimit;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to change the token limit by airdrop.\r\n     * @param _currentCirculating The current circulating tokens in wei.\r\n     */\r\n    function changeCurrentCirculating(uint256 _currentCirculating) public\r\n    onlyOwner {\r\n        emit CurrentCirculatingChanged(currentCirculating, _currentCirculating);\r\n        currentCirculating = _currentCirculating;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to flush the eth.\r\n     */\r\n    function flushEth() public onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to flush the tokens of the contract.\r\n     */\r\n    function flushTokens() public onlyOwner {\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the owner to destroy the contract and return the tokens to the owner.\r\n     */\r\n    function destroy() public onlyOwner {\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the token balance of the contract.\r\n     * @return _balance The token balance of this contract\r\n     */\r\n    function tokenBalance() view public returns (uint256 _balance) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the token balance of the beneficiary.\r\n     * @param _beneficiary The address of the beneficiary\r\n     * @return _balance The token balance of the beneficiary\r\n     */\r\n    function getBalanceAtSnapshot(address _beneficiary) view public returns (uint256 _balance) {\r\n        return beneficiaries[_beneficiary].balance / 1 ether;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the airdrop reward of the beneficiary.\r\n     * @param _beneficiary The address of the beneficiary\r\n     * @return _airdrop The token balance of the beneficiary\r\n     */\r\n    function getAirdropAtSnapshot(address _beneficiary) view public returns (uint256 _airdrop) {\r\n        return beneficiaries[_beneficiary].airdrop / 1 ether;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows a beneficiary to verify if he is already registered.\r\n     * @param _beneficiary The address of the beneficiary\r\n     * @return _isBeneficiary The boolean value\r\n     */\r\n    function amIBeneficiary(address _beneficiary) view public returns (bool _isBeneficiary) {\r\n        return beneficiaries[_beneficiary].isBeneficiary;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the number of beneficiaries.\r\n     * @return _length The number of beneficiaries\r\n     */\r\n    function beneficiariesLength() view public returns (uint256 _length) {\r\n        return addresses.length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"airdrop\",\"type\":\"uint256\"},{\"name\":\"isBeneficiary\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"registerBeneficiaries\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"amIBeneficiary\",\"outputs\":[{\"name\":\"_isBeneficiary\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"flushEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCirculating\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"filled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"changeVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_currentCirculating\",\"type\":\"uint256\"}],\"name\":\"changeCurrentCirculating\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"changeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_airdropLimit\",\"type\":\"uint256\"}],\"name\":\"changeAirdropLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takeSnapshot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiariesLength\",\"outputs\":[{\"name\":\"_length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"flushTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"airdropAndVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getBalanceAtSnapshot\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"registerBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getAirdropAtSnapshot\",\"outputs\":[{\"name\":\"_airdrop\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clean\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_airdropLimit\",\"type\":\"uint256\"},{\"name\":\"_currentCirculating\",\"type\":\"uint256\"},{\"name\":\"_vault\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"NewBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_totalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalAirdrop\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_toBurn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_numberOfBeneficiaries\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_numberOfAirdrops\",\"type\":\"uint256\"}],\"name\":\"SnapshotTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_totalAirdrop\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_numberOfAirdrops\",\"type\":\"uint256\"}],\"name\":\"Airdropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"TokenChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevVault\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"VaultChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_airdropLimit\",\"type\":\"uint256\"}],\"name\":\"AirdropLimitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevCirculating\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_currentCirculating\",\"type\":\"uint256\"}],\"name\":\"CurrentCirculatingChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_numberOfBeneficiaries\",\"type\":\"uint256\"}],\"name\":\"Cleaned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokensBurned\",\"type\":\"uint256\"}],\"name\":\"Vaulted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Airdrop","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000905e337c6c8645263d3521205aa37bf4d034e74500000000000000000000000000000000000000000003f11a6984d721e7cc00000000000000000000000000000000000000000000004ac645c1ba59491228000000000000000000000000000087fb4c39f873aefa0889521ef7bcebd02e4311c4","Library":"","SwarmSource":"bzzr://774482b556a0db7022f5a416735d0bca27c5b09a16883af62dd7726c0fec1975"}]}