{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\ncontract Ownable \r\n{\r\n    address public owner;\r\n    address public newOwner;\r\n    \r\n    function Ownable() public \r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() \r\n    {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _owner) onlyOwner public \r\n    {\r\n        require(_owner != 0);\r\n        newOwner = _owner;\r\n    }\r\n    \r\n    function confirmOwner() public \r\n    {\r\n        require(newOwner == msg.sender);\r\n        owner = newOwner;\r\n        delete newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b > 0);\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 \r\n{\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public;\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public;\r\n    function approve(address spender, uint256 value) public;\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    function getDecimals() public constant returns(uint8);\r\n    function getTotalSupply() public constant returns(uint256 supply);\r\n}\r\n\r\n\r\n\r\ncontract IzubrToken is Ownable, ERC20, SafeMath \r\n{\r\n    string  public constant standard    = 'Token 0.1';\r\n    string  public constant name        = 'Izubr';\r\n    string  public constant symbol      = \"IZR\";\r\n    uint8   public constant decimals    = 18;\r\n    uint256 public constant tokenKoef = 1000000000000000000;\r\n\r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    uint       private constant gasPrice = 3000000;\r\n\r\n    uint256    public etherPrice;\r\n    uint256    public minimalSuccessTokens;\r\n    uint256    public collectedTokens;\r\n\r\n    enum    State { Disabled, PreICO, CompletePreICO, Crowdsale, Enabled, Migration }\r\n    event   NewState(State state);\r\n\r\n    State      public state = State.Disabled;\r\n    uint256    public crowdsaleStartTime;\r\n    uint256    public crowdsaleFinishTime;\r\n\r\n    mapping (address => uint256)  public investors;\r\n    mapping (uint256 => address)  public investorsIter;\r\n    uint256                       public numberOfInvestors;\r\n\r\n    modifier onlyTokenHolders \r\n    {\r\n        require(balances[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    // Fix for the ERC20 short address attack\r\n    modifier onlyPayloadSize(uint size) \r\n    {\r\n        require(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    modifier enabledState \r\n    {\r\n        require(state == State.Enabled);\r\n        _;\r\n    }\r\n\r\n    modifier enabledOrMigrationState \r\n    {\r\n        require(state == State.Enabled || state == State.Migration);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    function getDecimals() public constant returns(uint8)\r\n    {\r\n        return decimals;\r\n    }\r\n\r\n    function balanceOf(address who) public constant returns (uint256) \r\n    {\r\n        return balances[who];\r\n    }\r\n\r\n    function investorsCount() public constant returns (uint256) \r\n    {\r\n        return numberOfInvestors;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value)\r\n        public enabledState onlyPayloadSize(2 * 32) \r\n    {\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        balances[msg.sender] = sub( balances[msg.sender], _value );\r\n        balances[_to] = add( balances[_to], _value );\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public enabledState onlyPayloadSize(3 * 32) \r\n    {\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n\r\n        balances[_from] = sub( balances[_from], _value );\r\n        balances[_to] = add( balances[_to], _value );\r\n\r\n        allowed[_from][msg.sender] = sub( allowed[_from][msg.sender], _value );\r\n\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public enabledState \r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant enabledState\r\n        returns (uint256 remaining) \r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    \r\n    function () public payable\r\n    {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now < crowdsaleFinishTime);\r\n\r\n        uint256 valueWei = msg.value;\r\n\r\n        uint256 price = currentPrice();\r\n\r\n        uint256 valueTokens = div( mul( valueWei, price ), 1 ether);\r\n\r\n        if( valueTokens > 33333*tokenKoef ) // 5 BTC\r\n        {\r\n            price = price * 112 / 100;\r\n            valueTokens = mul( valueWei, price );\r\n        }\r\n\r\n        require(valueTokens > 10*tokenKoef);\r\n\r\n\r\n        collectedTokens = add( collectedTokens, valueTokens );\r\n            \r\n        if(msg.data.length == 20) \r\n        {\r\n            address referer = bytesToAddress(bytes(msg.data));\r\n\r\n            require(referer != msg.sender);\r\n\r\n            mintTokensWithReferal(msg.sender, referer, valueTokens);\r\n        }\r\n        else\r\n        {\r\n            mintTokens(msg.sender, valueTokens);\r\n        }\r\n    }\r\n\r\n    function bytesToAddress(bytes source) internal pure returns(address) \r\n    {\r\n        uint result;\r\n        uint mul = 1;\r\n\r\n        for(uint i = 20; i > 0; i--) \r\n        {\r\n            result += uint8(source[i-1])*mul;\r\n            mul = mul*256;\r\n        }\r\n\r\n        return address(result);\r\n    }\r\n\r\n    function getTotalSupply() public constant returns(uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function depositTokens(address _who, uint256 _valueTokens) public onlyOwner \r\n    {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n        require(now < crowdsaleFinishTime);\r\n\r\n        uint256 bonus = currentBonus();\r\n        uint256 tokens = _valueTokens * (100 + bonus) / 100;\r\n\r\n        collectedTokens = add( collectedTokens, tokens );\r\n\r\n        mintTokens(_who, tokens);\r\n    }\r\n\r\n\r\n    function bonusForDate(uint date) public constant returns (uint256) \r\n    {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n\r\n        uint nday = (date - crowdsaleStartTime) / (1 days);\r\n\r\n        uint256 bonus = 0;\r\n\r\n        if (state == State.PreICO) \r\n        {\r\n            if( nday < 7*1 ) bonus = 100;\r\n            else\r\n            if( nday < 7*2 ) bonus = 80;\r\n            else\r\n            if( nday < 7*3 ) bonus = 70;\r\n            else\r\n            if( nday < 7*4 ) bonus = 60;\r\n            else\r\n            if( nday < 7*5 ) bonus = 50;\r\n        }\r\n        else\r\n        if (state == State.Crowdsale) \r\n        {\r\n            if( nday < 1 ) bonus = 20;\r\n            else\r\n            if( nday < 4 ) bonus = 15;\r\n            else\r\n            if( nday < 8 ) bonus = 10;\r\n            else\r\n            if( nday < 12 ) bonus = 5;\r\n        }\r\n\r\n        return bonus;\r\n    }\r\n\r\n    function currentBonus() public constant returns (uint256) \r\n    {\r\n        return bonusForDate(now);\r\n    }\r\n\r\n\r\n    function priceForDate(uint date) public constant returns (uint256) \r\n    {\r\n        uint256 bonus = bonusForDate(date);\r\n\r\n        return etherPrice * (100 + bonus) / 100;\r\n    }\r\n\r\n    function currentPrice() public constant returns (uint256) \r\n    {\r\n        return priceForDate(now);\r\n    }\r\n\r\n\r\n    function mintTokens(address _who, uint256 _tokens) internal \r\n    {\r\n        uint256 inv = investors[_who];\r\n\r\n        if (inv == 0) // new investor\r\n        {\r\n            investorsIter[numberOfInvestors++] = _who;\r\n        }\r\n\r\n        inv = add( inv, _tokens );\r\n        balances[_who] = add( balances[_who], _tokens );\r\n\r\n        Transfer(this, _who, _tokens);\r\n\r\n        totalSupply = add( totalSupply, _tokens );\r\n    }\r\n\r\n\r\n    function mintTokensWithReferal(address _who, address _referal, uint256 _valueTokens) internal \r\n    {\r\n        uint256 refererTokens = _valueTokens * 5 / 100;\r\n\r\n        uint256 valueTokens = _valueTokens * 103 / 100;\r\n\r\n        mintTokens(_referal, refererTokens);\r\n\r\n        mintTokens(_who, valueTokens);\r\n    }\r\n    \r\n    function startTokensSale(\r\n            uint    _crowdsaleStartTime,\r\n            uint    _crowdsaleFinishTime,\r\n            uint256 _minimalSuccessTokens,\r\n            uint256 _etherPrice) public onlyOwner \r\n    {\r\n        require(state == State.Disabled || state == State.CompletePreICO);\r\n\r\n        crowdsaleStartTime  = _crowdsaleStartTime;\r\n        crowdsaleFinishTime = _crowdsaleFinishTime;\r\n\r\n        etherPrice = _etherPrice;\r\n        delete numberOfInvestors;\r\n        delete collectedTokens;\r\n\r\n        minimalSuccessTokens = _minimalSuccessTokens;\r\n\r\n        if (state == State.Disabled) \r\n        {\r\n            state = State.PreICO;\r\n        } \r\n        else \r\n        {\r\n            state = State.Crowdsale;\r\n        }\r\n\r\n        NewState(state);\r\n    }\r\n    \r\n    function timeToFinishTokensSale() public constant returns(uint256 t) \r\n    {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n\r\n        if (now > crowdsaleFinishTime) \r\n        {\r\n            t = 0;\r\n        } \r\n        else \r\n        {\r\n            t = crowdsaleFinishTime - now;\r\n        }\r\n    }\r\n    \r\n    function finishTokensSale(uint256 _investorsToProcess) public \r\n    {\r\n        require(state == State.PreICO || state == State.Crowdsale);\r\n\r\n        require(now >= crowdsaleFinishTime || \r\n            (collectedTokens >= minimalSuccessTokens && msg.sender == owner));\r\n\r\n        if (collectedTokens < minimalSuccessTokens) \r\n        {\r\n            // Investors can get their ether calling withdrawBack() function\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) \r\n            {\r\n                address addr = investorsIter[--numberOfInvestors];\r\n                uint256 inv = investors[addr];\r\n                balances[addr] = sub( balances[addr], inv );\r\n                totalSupply = sub( totalSupply, inv );\r\n                Transfer(addr, this, inv);\r\n\r\n                --_investorsToProcess;\r\n\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n\r\n            if (numberOfInvestors > 0) \r\n            {\r\n                return;\r\n            }\r\n\r\n            if (state == State.PreICO) \r\n            {\r\n                state = State.Disabled;\r\n            } \r\n            else \r\n            {\r\n                state = State.CompletePreICO;\r\n            }\r\n        } \r\n        else \r\n        {\r\n            while (_investorsToProcess > 0 && numberOfInvestors > 0) \r\n            {\r\n                --numberOfInvestors;\r\n                --_investorsToProcess;\r\n\r\n                address i = investorsIter[numberOfInvestors];\r\n\r\n                investors[i] = 0;\r\n\r\n                delete investors[i];\r\n                delete investorsIter[numberOfInvestors];\r\n            }\r\n\r\n            if (numberOfInvestors > 0) \r\n            {\r\n                return;\r\n            }\r\n\r\n            if (state == State.PreICO) \r\n            {\r\n                state = State.CompletePreICO;\r\n            } \r\n            else \r\n            {\r\n                // Create additional tokens for owner (40% of complete totalSupply)\r\n                uint256 tokens = div( mul( 4, totalSupply ) , 6 );\r\n                balances[owner] = tokens;\r\n                totalSupply = add( totalSupply, tokens );\r\n                Transfer(this, owner, tokens);\r\n                state = State.Enabled;\r\n            }\r\n        }\r\n\r\n        NewState(state);\r\n    }\r\n    \r\n    // This function must be called by token holder in case of crowdsale failed\r\n    function withdrawBack() public \r\n    {\r\n        require(state == State.Disabled);\r\n\r\n        uint256 tokens = investors[msg.sender];\r\n        uint256 value = div( tokens, etherPrice );\r\n\r\n        if (value > 0) \r\n        {\r\n            investors[msg.sender] = 0;\r\n            require( msg.sender.call.gas(gasPrice).value(value)() );\r\n\r\n            totalSupply = sub( totalSupply, tokens );\r\n        }\r\n    }\r\n\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorsIter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"priceForDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorsToProcess\",\"type\":\"uint256\"}],\"name\":\"finishTokensSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalSuccessTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_valueTokens\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"bonusForDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeToFinishTokensSale\",\"outputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleFinishTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleStartTime\",\"type\":\"uint256\"},{\"name\":\"_crowdsaleFinishTime\",\"type\":\"uint256\"},{\"name\":\"_minimalSuccessTokens\",\"type\":\"uint256\"},{\"name\":\"_etherPrice\",\"type\":\"uint256\"}],\"name\":\"startTokensSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenKoef\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"NewState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"IzubrToken","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6fc996fca04bd3a8554a8c79e429749b61a6eb33941ca0bdb52c6077643ffa3f"}]}