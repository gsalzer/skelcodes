{"status":"1","message":"OK","result":[{"SourceCode":"interface IYeekFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) external view returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) external view returns (uint256);\r\n}\r\n\r\ninterface ITradeableAsset {\r\n    function totalSupply() external view returns (uint256);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n    function decimals() external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external;\r\n    function balanceOf(address _address) external view returns (uint256);\r\n}\r\n\r\n/* A basic permissions hierarchy (Owner -> Admin -> Everyone else). One owner may appoint and remove any number of admins\r\n   and may transfer ownership to another individual address */\r\ncontract Administered {\r\n    address public creator;\r\n    uint public commission = 1;\r\n    mapping (address => bool) public admins;\r\n    \r\n    constructor()  public {\r\n        creator = msg.sender;\r\n        admins[creator] = true;\r\n    }\r\n\r\n    //Restrict to the current owner. There may be only 1 owner at a time, but \r\n    //ownership can be transferred.\r\n    modifier onlyOwner {\r\n        require(creator == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    //Restrict to any admin. Not sufficient for highly sensitive methods\r\n    //since basic admin can be granted programatically regardless of msg.sender\r\n    modifier onlyAdmin {\r\n        require(admins[msg.sender] || creator == msg.sender);\r\n        _;\r\n    }\r\n\r\n    //Add an admin with basic privileges. Can be done by any superuser (or the owner)\r\n    function grantAdmin(address newAdmin) onlyOwner  public {\r\n        _grantAdmin(newAdmin);\r\n    }\r\n\r\n    function _grantAdmin(address newAdmin) internal\r\n    {\r\n        admins[newAdmin] = true;\r\n    }\r\n\r\n    //Transfer ownership\r\n    function changeOwner(address newOwner) onlyOwner public {\r\n        creator = newOwner;\r\n    }\r\n\r\n    //Remove an admin\r\n    function revokeAdminStatus(address user) onlyOwner public {\r\n        admins[user] = false;\r\n    }\r\n}\r\n\r\n/* A liqudity pool that executes buy and sell orders for an ETH / Token Pair */\r\n/* The owner deploys it and then adds tokens / ethereum in the desired ratio */\r\n\r\ncontract Exchanger is Administered {\r\n    bool public enabled = false;    //Owner can turn off and on\r\n\r\n    //The token which is being bought and sold\r\n    ITradeableAsset public tokenContract;\r\n    //The contract that does the calculations to determine buy and sell pricing\r\n    IYeekFormula public formulaContract;\r\n    //The reserve pct of this exchanger, expressed in ppm\r\n    uint32 public weight;\r\n\r\n    /** \r\n        @dev Deploys an exchanger contract for a given token / Ether pairing\r\n        @param _token An ERC20 token\r\n        @param _weight The reserve fraction of this exchanger, in ppm\r\n        @param _formulaContract The contract with the algorithms to calculate price\r\n     */\r\n\r\n    constructor(address _token, \r\n                uint32 _weight,\r\n                address _formulaContract) {\r\n        require (_weight > 0 && weight <= 1000000);\r\n        \r\n        weight = _weight;\r\n        tokenContract = ITradeableAsset(_token);\r\n        formulaContract = IYeekFormula(_formulaContract);\r\n    }\r\n\r\n    //Events raised on completion of buy and sell orders. \r\n    //The web client can use this info to provide users with their trading history for a given token\r\n    //and also to notify when a trade has completed.\r\n\r\n    event Buy(address indexed purchaser, uint256 amountInWei, uint256 amountInToken);\r\n    event Sell(address indexed seller, uint256 amountInToken, uint256 amountInWei);\r\n\r\n\r\n    // The following methods are for the owner and admins to manage the Exchanger\r\n    \r\n    /**\r\n     @dev Deposit tokens to the reserve.\r\n     */\r\n    function depositTokens(uint amount) onlyOwner public {\r\n        tokenContract.transferFrom(msg.sender, this, amount);\r\n    }\r\n        \r\n    /**\r\n     @dev Deposit ether to the reserve\r\n     */\r\n     function depositEther() onlyOwner public payable {\r\n        //return getQuotePrice(); \r\n     }\r\n\r\n    /**  \r\n     @dev Withdraw tokens from the reserve\r\n     */\r\n    function withdrawTokens(uint amount) onlyOwner public {\r\n        tokenContract.transfer(msg.sender, amount);\r\n    }\r\n\r\n    /**  \r\n     @dev Withdraw ether from the reserve\r\n     */\r\n    function withdrawEther(uint amountInWei) onlyOwner public {\r\n        msg.sender.transfer(amountInWei); //Transfers in wei\r\n    }\r\n\r\n    /**\r\n     @dev Enable trading\r\n     */\r\n     function enable() onlyAdmin public {\r\n         enabled = true;\r\n     }\r\n\r\n     /**\r\n      @dev Disable trading\r\n     */\r\n     function disable() onlyAdmin public {\r\n         enabled = false;\r\n     }\r\n\r\n     /**\r\n      @dev Play central banker and set the fractional reserve ratio, from 1 to 1000000 ppm.\r\n      It is highly disrecommended to do this while trading is enabled! If you don't know what \r\n      a fractional reserve is, please put this contract away and go work for your local government.\r\n     */\r\n     function setReserveWeight(uint32 ppm) onlyAdmin public {\r\n         require (ppm>0 && ppm<=1000000);\r\n         weight = ppm;\r\n     }\r\n\r\n    //These methods return information about the exchanger, and the buy / sell rates offered on the Token / ETH pairing.\r\n    //They can be called without gas from any client.\r\n\r\n    /**  \r\n     @dev Audit the reserve balances, in the base token and in ether\r\n     */\r\n    function getReserveBalances() public view returns (uint256, uint256) {\r\n        return (tokenContract.balanceOf(this), address(this).balance);\r\n    }\r\n\r\n\r\n    /**\r\n     @dev Gets price based on a sample 1 ether BUY order\r\n     */\r\n    function getQuotePrice() public view returns(uint) {\r\n        uint tokensPerEther = \r\n        formulaContract.calculatePurchaseReturn(\r\n            tokenContract.totalSupply(),\r\n            address(this).balance,\r\n            weight,\r\n            1 ether \r\n        ); \r\n\r\n        return tokensPerEther;\r\n    }\r\n\r\n    /**\r\n     @dev Get the BUY price based on the order size. Returned as the number of tokens that the amountInWei will buy.\r\n     */\r\n    function getPurchasePrice(uint256 amountInWei) public view returns(uint) {\r\n        uint tokensPerEther =  formulaContract.calculatePurchaseReturn(\r\n            tokenContract.totalSupply(),\r\n            address(this).balance,\r\n            weight,\r\n            amountInWei \r\n        ); \r\n        \r\n        return tokensPerEther - (tokensPerEther * commission / 100);\r\n    }\r\n\r\n    /**\r\n     @dev Get the SELL price based on the order size. Returned as amount (in wei) that you'll get for your tokens.\r\n     */\r\n    function getSalePrice(uint256 tokensToSell) public view returns(uint) {\r\n        uint weiRaw= formulaContract.calculateSaleReturn(\r\n            tokenContract.totalSupply(),\r\n            address(this).balance,\r\n            weight,\r\n            tokensToSell \r\n        ); \r\n        \r\n        return weiRaw - (weiRaw * commission / 100);\r\n    }\r\n\r\n    //buy and sell execute live trades against the exchanger. For either method, \r\n    //you must specify your minimum return (in total tokens or ether that you expect to receive for your trade)\r\n    //this protects the trader against slippage due to other orders that make it into earlier blocks after they \r\n    //place their order. \r\n    //\r\n    //With buy, send the amount of ether you want to spend on the token - you'll get it back immediately if minPurchaseReturn\r\n    //is not met or if this Exchanger is not in a condition to service your order (usually this happens when there is not a full \r\n    //reserve of tokens to satisfy the stated weight)\r\n    //\r\n    //With sell, first approve the exchanger to spend the number of tokens you want to sell\r\n    //Then call sell with that number and your minSaleReturn. The token transfer will not happen \r\n    //if the minSaleReturn is not met.\r\n    //\r\n    //Sales always go through, as long as there is any ether in the reserve... but those dumping massive quantities of tokens\r\n    //will naturally be given the shittest rates.\r\n\r\n    /**\r\n     @dev Buy tokens with ether. \r\n     @param minPurchaseReturn The minimum number of tokens you will accept.\r\n     */\r\n    function buy(uint minPurchaseReturn) public payable {\r\n        uint amount = formulaContract.calculatePurchaseReturn(\r\n            tokenContract.totalSupply(),\r\n            address(this).balance - msg.value,\r\n            weight,\r\n            msg.value);\r\n        require (enabled);\r\n        require (amount >= minPurchaseReturn);\r\n        require (tokenContract.balanceOf(this) >= amount);\r\n        emit Buy(msg.sender, msg.value, amount);\r\n        tokenContract.transfer(msg.sender, amount);\r\n    }\r\n    /**\r\n     @dev Sell tokens for ether\r\n     @param quantity Number of tokens to sell\r\n     @param minSaleReturn Minimum amount of ether (in wei) you will accept for your tokens\r\n     */\r\n     function sell(uint quantity, uint minSaleReturn) public {\r\n         uint amountInWei = formulaContract.calculateSaleReturn(\r\n             tokenContract.totalSupply(),\r\n             address(this).balance,\r\n             weight,\r\n             quantity\r\n         );\r\n         require (enabled);\r\n         require (amountInWei >= minSaleReturn);\r\n         require (amountInWei <= address(this).balance);\r\n         require (tokenContract.transferFrom(msg.sender, this, quantity));\r\n         emit Sell(msg.sender, quantity, amountInWei);\r\n         msg.sender.transfer(amountInWei); //Always send ether last\r\n     }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"grantAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"formulaContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserveBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"getPurchasePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ppm\",\"type\":\"uint32\"}],\"name\":\"setReserveWeight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"minSaleReturn\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minPurchaseReturn\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQuotePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokensToSell\",\"type\":\"uint256\"}],\"name\":\"getSalePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"revokeAdminStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_weight\",\"type\":\"uint32\"},{\"name\":\"_formulaContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountInToken\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountInToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"}]","ContractName":"Exchanger","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096387e69fac1d3b63e31a3a70ee3a0676188775900000000000000000000000000000000000000000000000000000000000027100000000000000000000000003ae6abeb18dfa61f85faff25aef28c8cd6ddbe6b","Library":"","SwarmSource":"bzzr://9aba07173834e321d3042efb6b8b36137adb44eff161734da988cf714bbb7915"}]}