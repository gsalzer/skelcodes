{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract EIP820ImplementerInterface {\r\n    /// @notice Contracts that implement an interferce in behalf of another contract must return true\r\n    /// @param addr Address that the contract woll implement the interface in behalf of\r\n    /// @param interfaceHash keccak256 of the name of the interface\r\n    /// @return true if the contract can implement the interface represented by\r\n    ///  `Ã¬nterfaceHash` in behalf of `addr`\r\n    function canImplementInterfaceForAddress(address addr, bytes32 interfaceHash) view public returns(bool);\r\n}\r\n\r\ncontract EIP820Registry {\r\n\r\n    mapping (address => mapping(bytes32 => address)) interfaces;\r\n    mapping (address => address) managers;\r\n\r\n    modifier canManage(address addr) {\r\n        require(getManager(addr) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /// @notice Query the hash of an interface given a name\r\n    /// @param interfaceName Name of the interfce\r\n    function interfaceHash(string interfaceName) public pure returns(bytes32) {\r\n        return keccak256(interfaceName);\r\n    }\r\n\r\n    /// @notice GetManager\r\n    function getManager(address addr) public view returns(address) {\r\n        // By default the manager of an address is the same address\r\n        if (managers[addr] == 0) {\r\n            return addr;\r\n        } else {\r\n            return managers[addr];\r\n        }\r\n    }\r\n\r\n    /// @notice Sets an external `manager` that will be able to call `setInterfaceImplementer()`\r\n    ///  on behalf of the address.\r\n    /// @param addr Address that you are defining the manager for.\r\n    /// @param newManager The address of the manager for the `addr` that will replace\r\n    ///  the old one.  Set to 0x0 if you want to remove the manager.\r\n    function setManager(address addr, address newManager) public canManage(addr) {\r\n        managers[addr] = newManager == addr ? 0 : newManager;\r\n        ManagerChanged(addr, newManager);\r\n    }\r\n\r\n    /// @notice Query if an address implements an interface and thru which contract\r\n    /// @param addr Address that is being queried for the implementation of an interface\r\n    /// @param iHash SHA3 of the name of the interface as a string\r\n    ///  Example `web3.utils.sha3('Ierc777`')`\r\n    /// @return The address of the contract that implements a speficic interface\r\n    ///  or 0x0 if `addr` does not implement this interface\r\n    function getInterfaceImplementer(address addr, bytes32 iHash) public constant returns (address) {\r\n        return interfaces[addr][iHash];\r\n    }\r\n\r\n    /// @notice Sets the contract that will handle a specific interface; only\r\n    ///  the address itself or a `manager` defined for that address can set it\r\n    /// @param addr Address that you want to define the interface for\r\n    /// @param iHash SHA3 of the name of the interface as a string\r\n    ///  For example `web3.utils.sha3('Ierc777')` for the Ierc777\r\n    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public canManage(addr)  {\r\n        if ((implementer != 0) && (implementer!=msg.sender)) {\r\n            require(EIP820ImplementerInterface(implementer).canImplementInterfaceForAddress(addr, iHash));\r\n        }\r\n        interfaces[addr][iHash] = implementer;\r\n        InterfaceImplementerSet(addr, iHash, implementer);\r\n    }\r\n\r\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\r\n    event ManagerChanged(address indexed addr, address indexed newManager);\r\n}\r\n\r\ncontract EIP820Implementer {\r\n    EIP820Registry eip820Registry = EIP820Registry(0x9aA513f1294c8f1B254bA1188991B4cc2EFE1D3B);\r\n\r\n    function setInterfaceImplementation(string ifaceLabel, address impl) internal {\r\n        bytes32 ifaceHash = keccak256(ifaceLabel);\r\n        eip820Registry.setInterfaceImplementer(this, ifaceHash, impl);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string ifaceLabel) internal constant returns(address) {\r\n        bytes32 ifaceHash = keccak256(ifaceLabel);\r\n        return eip820Registry.getInterfaceImplementer(addr, ifaceHash);\r\n    }\r\n\r\n    function delegateManagement(address newManager) internal {\r\n        eip820Registry.setManager(this, newManager);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract AssetRegistryStorage {\r\n\r\n  string internal _name;\r\n  string internal _symbol;\r\n  string internal _description;\r\n\r\n  /**\r\n   * Stores the total count of assets managed by this registry\r\n   */\r\n  uint256 internal _count;\r\n\r\n  /**\r\n   * Stores an array of assets owned by a given account\r\n   */\r\n  mapping(address => uint256[]) internal _assetsOf;\r\n\r\n  /**\r\n   * Stores the current holder of an asset\r\n   */\r\n  mapping(uint256 => address) internal _holderOf;\r\n\r\n  /**\r\n   * Stores the index of an asset in the `_assetsOf` array of its holder\r\n   */\r\n  mapping(uint256 => uint256) internal _indexOfAsset;\r\n\r\n  /**\r\n   * Stores the data associated with an asset\r\n   */\r\n  mapping(uint256 => string) internal _assetData;\r\n\r\n  /**\r\n   * For a given account, for a given operator, store whether that operator is\r\n   * allowed to transfer and modify assets on behalf of them.\r\n   */\r\n  mapping(address => mapping(address => bool)) internal _operators;\r\n\r\n  /**\r\n   * Simple reentrancy lock\r\n   */\r\n  bool internal _reentrancy;\r\n\r\n  /**\r\n   * Complex reentrancy lock\r\n   */\r\n  uint256 internal _reentrancyCount;\r\n\r\n  /**\r\n   * Approval array\r\n   */\r\n  mapping(uint256 => address) internal _approval;\r\n}\r\n\r\n\r\ninterface IAssetHolder {\r\n  function onAssetReceived(\r\n    /* address _assetRegistry == msg.sender */\r\n    uint256 _assetId,\r\n    address _previousHolder,\r\n    address _currentHolder,\r\n    bytes   _userData,\r\n    address _operator,\r\n    bytes   _operatorData\r\n  ) public;\r\n}\r\n\r\n\r\ninterface IAssetRegistry {\r\n\r\n  /**\r\n   * Global Registry getter functions\r\n   */\r\n  function name() public view returns (string);\r\n  function symbol() public view returns (string);\r\n  function description() public view returns (string);\r\n  function totalSupply() public view returns (uint256);\r\n  function decimals() public view returns (uint256);\r\n\r\n  function isERC821() public view returns (bool);\r\n\r\n  /**\r\n   * Asset-centric getter functions\r\n   */\r\n  function exists(uint256 assetId) public view returns (bool);\r\n\r\n  function holderOf(uint256 assetId) public view returns (address);\r\n  function ownerOf(uint256 assetId) public view returns (address);\r\n\r\n  function safeHolderOf(uint256 assetId) public view returns (address);\r\n  function safeOwnerOf(uint256 assetId) public view returns (address);\r\n\r\n  function assetData(uint256 assetId) public view returns (string);\r\n  function safeAssetData(uint256 assetId) public view returns (string);\r\n\r\n  /**\r\n   * Holder-centric getter functions\r\n   */\r\n  function assetCount(address holder) public view returns (uint256);\r\n  function balanceOf(address holder) public view returns (uint256);\r\n\r\n  function assetByIndex(address holder, uint256 index) public view returns (uint256);\r\n  function assetsOf(address holder) external view returns (uint256[]);\r\n\r\n  /**\r\n   * Transfer Operations\r\n   */\r\n  function transfer(address to, uint256 assetId) public;\r\n  function transfer(address to, uint256 assetId, bytes userData) public;\r\n  function transfer(address to, uint256 assetId, bytes userData, bytes operatorData) public;\r\n\r\n  /**\r\n   * Authorization operations\r\n   */\r\n  function authorizeOperator(address operator, bool authorized) public;\r\n  function approve(address operator, uint256 assetId) public;\r\n\r\n  /**\r\n   * Authorization getters\r\n   */\r\n  function isOperatorAuthorizedBy(address operator, address assetHolder)\r\n    public view returns (bool);\r\n\r\n  function approvedFor(uint256 assetId)\r\n    public view returns (address);\r\n\r\n  function isApprovedFor(address operator, uint256 assetId)\r\n    public view returns (bool);\r\n\r\n  /**\r\n   * Events\r\n   */\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 indexed assetId,\r\n    address operator,\r\n    bytes userData,\r\n    bytes operatorData\r\n  );\r\n  event Update(\r\n    uint256 indexed assetId,\r\n    address indexed holder,\r\n    address indexed operator,\r\n    string data\r\n  );\r\n  event AuthorizeOperator(\r\n    address indexed operator,\r\n    address indexed holder,\r\n    bool authorized\r\n  );\r\n  event Approve(\r\n    address indexed owner,\r\n    address indexed operator,\r\n    uint256 indexed assetId\r\n  );\r\n}\r\n\r\n\r\ncontract StandardAssetRegistry is AssetRegistryStorage, IAssetRegistry, EIP820Implementer {\r\n  using SafeMath for uint256;\r\n\r\n  //\r\n  // Global Getters\r\n  //\r\n\r\n  function name() public view returns (string) {\r\n    return _name;\r\n  }\r\n\r\n  function symbol() public view returns (string) {\r\n    return _symbol;\r\n  }\r\n\r\n  function description() public view returns (string) {\r\n    return _description;\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return _count;\r\n  }\r\n\r\n  function decimals() public view returns (uint256) {\r\n    return 0;\r\n  }\r\n\r\n  function isERC821() public view returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  //\r\n  // Asset-centric getter functions\r\n  //\r\n\r\n  function exists(uint256 assetId) public view returns (bool) {\r\n    return _holderOf[assetId] != 0;\r\n  }\r\n\r\n  function holderOf(uint256 assetId) public view returns (address) {\r\n    return _holderOf[assetId];\r\n  }\r\n\r\n  function ownerOf(uint256 assetId) public view returns (address) {\r\n    // It's OK to be inefficient here, as this method is for compatibility.\r\n    // Users should call `holderOf`\r\n    return holderOf(assetId);\r\n  }\r\n\r\n  function safeHolderOf(uint256 assetId) public view returns (address) {\r\n    address holder = _holderOf[assetId];\r\n    require(holder != 0);\r\n    return holder;\r\n  }\r\n\r\n  function safeOwnerOf(uint256 assetId) public view returns (address) {\r\n    return safeHolderOf(assetId);\r\n  }\r\n\r\n  function assetData(uint256 assetId) public view returns (string) {\r\n    return _assetData[assetId];\r\n  }\r\n\r\n  function safeAssetData(uint256 assetId) public view returns (string) {\r\n    require(_holderOf[assetId] != 0);\r\n    return _assetData[assetId];\r\n  }\r\n\r\n  //\r\n  // Holder-centric getter functions\r\n  //\r\n\r\n  function assetCount(address holder) public view returns (uint256) {\r\n    return _assetsOf[holder].length;\r\n  }\r\n\r\n  function balanceOf(address holder) public view returns (uint256) {\r\n    return assetCount(holder);\r\n  }\r\n\r\n  function assetByIndex(address holder, uint256 index) public view returns (uint256) {\r\n    require(index < _assetsOf[holder].length);\r\n    require(index < (1<<127));\r\n    return _assetsOf[holder][index];\r\n  }\r\n\r\n  function assetsOf(address holder) external view returns (uint256[]) {\r\n    return _assetsOf[holder];\r\n  }\r\n\r\n  //\r\n  // Authorization getters\r\n  //\r\n\r\n  function isOperatorAuthorizedBy(address operator, address assetHolder)\r\n    public view returns (bool)\r\n  {\r\n    return _operators[assetHolder][operator];\r\n  }\r\n\r\n  function approvedFor(uint256 assetId) public view returns (address) {\r\n    return _approval[assetId];\r\n  }\r\n\r\n  function isApprovedFor(address operator, uint256 assetId)\r\n    public view returns (bool)\r\n  {\r\n    require(operator != 0);\r\n    if (operator == holderOf(assetId)) {\r\n      return true;\r\n    }\r\n    return _approval[assetId] == operator;\r\n  }\r\n\r\n  //\r\n  // Authorization\r\n  //\r\n\r\n  function authorizeOperator(address operator, bool authorized) public {\r\n    if (authorized) {\r\n      require(!isOperatorAuthorizedBy(operator, msg.sender));\r\n      _addAuthorization(operator, msg.sender);\r\n    } else {\r\n      require(isOperatorAuthorizedBy(operator, msg.sender));\r\n      _clearAuthorization(operator, msg.sender);\r\n    }\r\n    AuthorizeOperator(operator, msg.sender, authorized);\r\n  }\r\n\r\n  function approve(address operator, uint256 assetId) public {\r\n    address holder = holderOf(assetId);\r\n    require(operator != holder);\r\n    if (approvedFor(assetId) != operator) {\r\n      _approval[assetId] = operator;\r\n      Approve(holder, operator, assetId);\r\n    }\r\n  }\r\n\r\n  function _addAuthorization(address operator, address holder) private {\r\n    _operators[holder][operator] = true;\r\n  }\r\n\r\n  function _clearAuthorization(address operator, address holder) private {\r\n    _operators[holder][operator] = false;\r\n  }\r\n\r\n  //\r\n  // Internal Operations\r\n  //\r\n\r\n  function _addAssetTo(address to, uint256 assetId) internal {\r\n    _holderOf[assetId] = to;\r\n\r\n    uint256 length = assetCount(to);\r\n\r\n    _assetsOf[to].push(assetId);\r\n\r\n    _indexOfAsset[assetId] = length;\r\n\r\n    _count = _count.add(1);\r\n  }\r\n\r\n  function _addAssetTo(address to, uint256 assetId, string data) internal {\r\n    _addAssetTo(to, assetId);\r\n\r\n    _assetData[assetId] = data;\r\n  }\r\n\r\n  function _removeAssetFrom(address from, uint256 assetId) internal {\r\n    uint256 assetIndex = _indexOfAsset[assetId];\r\n    uint256 lastAssetIndex = assetCount(from).sub(1);\r\n    uint256 lastAssetId = _assetsOf[from][lastAssetIndex];\r\n\r\n    _holderOf[assetId] = 0;\r\n\r\n    // Insert the last asset into the position previously occupied by the asset to be removed\r\n    _assetsOf[from][assetIndex] = lastAssetId;\r\n\r\n    // Resize the array\r\n    _assetsOf[from][lastAssetIndex] = 0;\r\n    _assetsOf[from].length--;\r\n\r\n    // Remove the array if no more assets are owned to prevent pollution\r\n    if (_assetsOf[from].length == 0) {\r\n      delete _assetsOf[from];\r\n    }\r\n\r\n    // Update the index of positions for the asset\r\n    _indexOfAsset[assetId] = 0;\r\n    _indexOfAsset[lastAssetId] = assetIndex;\r\n\r\n    _count = _count.sub(1);\r\n  }\r\n\r\n  function _clearApproval(address holder, uint256 assetId) internal {\r\n    if (holderOf(assetId) == holder && _approval[assetId] != 0) {\r\n      _approval[assetId] = 0;\r\n      Approve(holder, 0, assetId);\r\n    }\r\n  }\r\n\r\n  function _removeAssetData(uint256 assetId) internal {\r\n    _assetData[assetId] = '';\r\n  }\r\n\r\n  //\r\n  // Supply-altering functions\r\n  //\r\n\r\n  function _generate(uint256 assetId, address beneficiary, string data) internal {\r\n    require(_holderOf[assetId] == 0);\r\n\r\n    _addAssetTo(beneficiary, assetId, data);\r\n\r\n    Transfer(0, beneficiary, assetId, msg.sender, bytes(data), '');\r\n  }\r\n\r\n  function _destroy(uint256 assetId) internal {\r\n    address holder = _holderOf[assetId];\r\n    require(holder != 0);\r\n\r\n    _removeAssetFrom(holder, assetId);\r\n    _removeAssetData(assetId);\r\n\r\n    Transfer(holder, 0, assetId, msg.sender, '', '');\r\n  }\r\n\r\n  //\r\n  // Transaction related operations\r\n  //\r\n\r\n  modifier onlyHolder(uint256 assetId) {\r\n    require(_holderOf[assetId] == msg.sender);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOperatorOrHolder(uint256 assetId) {\r\n    require(\r\n      _holderOf[assetId] == msg.sender\r\n      || isOperatorAuthorizedBy(msg.sender, _holderOf[assetId])\r\n      || isApprovedFor(msg.sender, assetId)\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier isDestinataryDefined(address destinatary) {\r\n    require(destinatary != 0);\r\n    _;\r\n  }\r\n\r\n  modifier destinataryIsNotHolder(uint256 assetId, address to) {\r\n    require(_holderOf[assetId] != to);\r\n    _;\r\n  }\r\n\r\n  function transfer(address to, uint256 assetId) public {\r\n    return _doTransfer(to, assetId, '', 0, '');\r\n  }\r\n\r\n  function transfer(address to, uint256 assetId, bytes userData) public {\r\n    return _doTransfer(to, assetId, userData, 0, '');\r\n  }\r\n\r\n  function transfer(address to, uint256 assetId, bytes userData, bytes operatorData) public {\r\n    return _doTransfer(to, assetId, userData, msg.sender, operatorData);\r\n  }\r\n\r\n  function _doTransfer(\r\n    address to, uint256 assetId, bytes userData, address operator, bytes operatorData\r\n  )\r\n    isDestinataryDefined(to)\r\n    destinataryIsNotHolder(assetId, to)\r\n    onlyOperatorOrHolder(assetId)\r\n    internal\r\n  {\r\n    return _doSend(to, assetId, userData, operator, operatorData);\r\n  }\r\n\r\n\r\n  function _doSend(\r\n    address to, uint256 assetId, bytes userData, address operator, bytes operatorData\r\n  )\r\n    internal\r\n  {\r\n    address holder = _holderOf[assetId];\r\n    _removeAssetFrom(holder, assetId);\r\n    _clearApproval(holder, assetId);\r\n    _addAssetTo(to, assetId);\r\n\r\n    if (_isContract(to)) {\r\n      require(!_reentrancy);\r\n      _reentrancy = true;\r\n\r\n      address recipient = interfaceAddr(to, 'IAssetHolder');\r\n      require(recipient != 0);\r\n\r\n      IAssetHolder(recipient).onAssetReceived(assetId, holder, to, userData, operator, operatorData);\r\n\r\n      _reentrancy = false;\r\n    }\r\n\r\n    Transfer(holder, to, assetId, operator, userData, operatorData);\r\n  }\r\n\r\n  //\r\n  // Update related functions\r\n  //\r\n\r\n  function _update(uint256 assetId, string data) internal {\r\n    require(exists(assetId));\r\n    _assetData[assetId] = data;\r\n    Update(assetId, _holderOf[assetId], msg.sender, data);\r\n  }\r\n\r\n  //\r\n  // Utilities\r\n  //\r\n\r\n  function _isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n *      Supports unlimited numbers of roles and addresses.\r\n *      See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n *  for you to write your own implementation of this interface using Enums or similar.\r\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\r\n *  to avoid typos.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * A constant role name for indicating admins.\r\n   */\r\n  string public constant ROLE_ADMIN = \"admin\";\r\n\r\n  /**\r\n   * @dev constructor. Sets msg.sender as admin by default\r\n   */\r\n  function RBAC()\r\n    public\r\n  {\r\n    addRole(msg.sender, ROLE_ADMIN);\r\n  }\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminAddRole(address addr, string roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    addRole(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function adminRemoveRole(address addr, string roleName)\r\n    onlyAdmin\r\n    public\r\n  {\r\n    removeRole(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to admins\r\n   * // reverts\r\n   */\r\n  modifier onlyAdmin()\r\n  {\r\n    checkRole(msg.sender, ROLE_ADMIN);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n\r\ncontract Mintable821 is StandardAssetRegistry, RBAC {\r\n  event Mint(uint256 assetId, address indexed beneficiary, string data);\r\n  event MintFinished();\r\n\r\n  uint256 public nextAssetId = 0;\r\n\r\n  string constant ROLE_MINTER = \"minter\";\r\n  bool public minting;\r\n\r\n  modifier onlyMinter() {\r\n    require(\r\n      hasRole(msg.sender, ROLE_MINTER)\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier canMint() {\r\n    require(minting);\r\n    _;\r\n  }\r\n\r\n  function Mintable821(address minter) public {\r\n    _name = \"Mintable821\";\r\n    _symbol = \"MINT\";\r\n    _description = \"ERC 821 minting contract\";\r\n\r\n    removeRole(msg.sender, ROLE_ADMIN);\r\n    addRole(minter, ROLE_MINTER);\r\n\r\n    minting = true;\r\n  }\r\n\r\n  function isContractProxy(address addr) public view returns (bool) {\r\n    return _isContract(addr);\r\n  }\r\n\r\n  function generate(address beneficiary, string data)\r\n    onlyMinter\r\n    canMint\r\n    public\r\n  {\r\n    uint256 assetId = nextAssetId;\r\n    _generate(assetId, beneficiary, data);\r\n    Mint(assetId, beneficiary, data);\r\n    nextAssetId = nextAssetId + 1;\r\n  }\r\n\r\n  // function update(uint256 assetId, string data)\r\n  //   onlyMinter\r\n  //   public\r\n  // {\r\n  //   _update(assetId, data);\r\n  // }\r\n\r\n  function transferTo(\r\n    address to, uint256 assetId, bytes userData, bytes operatorData\r\n  )\r\n    public\r\n  {\r\n    return transfer(to, assetId, userData, operatorData);\r\n  }\r\n\r\n  function endMinting()\r\n    onlyMinter\r\n    canMint\r\n    public\r\n  {\r\n    minting = false;\r\n    MintFinished();\r\n  }\r\n}\r\n\r\n\r\ncontract OZWorkshop is Mintable821 {\r\n  function OZWorkshop ()\r\n    Mintable821(msg.sender)\r\n    public\r\n  {\r\n    _name = \"OZ Workshop\";\r\n    _symbol = \"OZWS\";\r\n    _description = \"Awarded for completing the OpenZeppelin Workshop at ETHDenver 2018\";\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"approvedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"assetsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"safeHolderOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"isApprovedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"generate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"userData\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"transferTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminRemoveRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextAssetId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"assetHolder\",\"type\":\"address\"}],\"name\":\"isOperatorAuthorizedBy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isERC821\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"assetData\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminAddRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"safeAssetData\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"safeOwnerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"assetCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isContractProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"assetByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"holderOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"userData\",\"type\":\"bytes\"},{\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"string\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"userData\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"string\"}],\"name\":\"Update\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"AuthorizeOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"Approve\",\"type\":\"event\"}]","ContractName":"OZWorkshop","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://33f3c29019484d1cbf774d03568f4ed78eb89558f6b1b0a84ea233f2bb5c354e"}]}