{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract ERC721 {\r\n    \r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\n\r\ncontract GeneScienceInterface {\r\n    \r\n    function isGeneScience() public pure returns (bool);\r\n\r\n    function mixGenes(uint256 genes1, uint256 genes2, uint256 targetBlock) public returns (uint256);\r\n}\r\n\r\n\r\ncontract VariationInterface {\r\n\r\n    function isVariation() public pure returns(bool);\r\n    \r\n    function createVariation(uint256 _gene, uint256 _totalSupply) public returns (uint8);\r\n    \r\n    function registerVariation(uint256 _dogId, address _owner) public;\r\n}\r\n\r\n\r\ncontract LotteryInterface {\r\n    \r\n    function isLottery() public pure returns (bool);\r\n\r\n    function checkLottery(uint256 genes) public pure returns (uint8 lotclass);\r\n    \r\n    function registerLottery(uint256 _dogId) public payable returns (uint8);\r\n\r\n    function getCLottery() \r\n        public \r\n        view \r\n        returns (\r\n            uint8[7]        luckyGenes1,\r\n            uint256         totalAmount1,\r\n            uint256         openBlock1,\r\n            bool            isReward1,\r\n            uint256         term1,\r\n            uint8           currentGenes1,\r\n            uint256         tSupply,\r\n            uint256         sPoolAmount1,\r\n            uint256[]       reward1\r\n        );\r\n}\r\n\r\n\r\ncontract DogAccessControl {\r\n    \r\n    event ContractUpgrade(address newContract);\r\n\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    bool public paused = false;\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(msg.sender == cooAddress || msg.sender == ceoAddress || msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\n\r\ncontract DogBase is DogAccessControl {\r\n\r\n    event Birth(address owner, uint256 dogId, uint256 matronId, uint256 sireId, uint256 genes, uint16 generation, uint8 variation, uint256 gen0, uint256 birthTime, uint256 income, uint16 cooldownIndex);\r\n\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    struct Dog {\r\n        \r\n        uint256 genes;\r\n\r\n        uint256 birthTime;\r\n\r\n        uint64 cooldownEndBlock;\r\n\r\n        uint32 matronId;\r\n\r\n        uint32 sireId;\r\n\r\n        uint32 siringWithId;\r\n\r\n        uint16 cooldownIndex;\r\n\r\n        uint16 generation;\r\n\r\n        uint8  variation;\r\n\r\n        uint256 gen0;\r\n    }\r\n\r\n    uint32[14] public cooldowns = [\r\n        uint32(1 minutes),\r\n        uint32(2 minutes),\r\n        uint32(5 minutes),\r\n        uint32(10 minutes),\r\n        uint32(30 minutes),\r\n        uint32(1 hours),\r\n        uint32(2 hours),\r\n        uint32(4 hours),\r\n        uint32(8 hours),\r\n        uint32(16 hours),\r\n        uint32(24 hours),\r\n        uint32(2 days),\r\n        uint32(3 days),\r\n        uint32(5 days)\r\n    ];\r\n\r\n    uint256 public secondsPerBlock = 15;\r\n\r\n    Dog[] dogs;\r\n\r\n    mapping (uint256 => address) dogIndexToOwner;\r\n\r\n    mapping (address => uint256) ownershipTokenCount;\r\n\r\n    mapping (uint256 => address) public dogIndexToApproved;\r\n\r\n    mapping (uint256 => address) public sireAllowedToAddress;\r\n\r\n    SaleClockAuction public saleAuction;\r\n\r\n    SiringClockAuction public siringAuction;\r\n\r\n    VariationInterface public variation;\r\n\r\n    LotteryInterface public lottery;\r\n\r\n    uint256 public autoBirthFee = 7500 szabo;\r\n\r\n    uint256 public gen0Profit = 500 szabo;\r\n    \r\n    uint256 public creationProfit = 1000 szabo;\r\n\r\n    mapping (address => uint256) public profit;\r\n\r\n    function _sendMoney(address _to, uint256 _money) internal {\r\n        spendMoney += _money;\r\n        require(address(this).balance >= spendMoney);\r\n        profit[_to] += _money;\r\n    }\r\n\r\n    function sendMoney(address _to, uint256 _money) external {\r\n        require(msg.sender == address(lottery) || msg.sender == address(variation));\r\n        _sendMoney(_to, _money);\r\n    }\r\n\r\n    event Withdraw(address _owner, uint256 _value);\r\n\r\n    function withdraw() public {\r\n        uint256 value = profit[msg.sender];\r\n        require(value > 0);\r\n        msg.sender.transfer(value);\r\n        spendMoney -= value;\r\n        delete profit[msg.sender];\r\n\r\n        Withdraw(msg.sender, value);\r\n    }\r\n\r\n    uint256 public spendMoney;\r\n\r\n    function setGen0Profit(uint256 _value) public onlyCEO {        \r\n        uint256 ration = _value * 100 / autoBirthFee;\r\n        require(ration > 0);\r\n        require(_value <= 100);\r\n        gen0Profit = _value;\r\n    }\r\n\r\n    function setCreationProfit(uint256 _value) public onlyCEO {        \r\n        uint256 ration = _value * 100 / autoBirthFee;\r\n        require(ration > 0);\r\n        require(_value <= 100);\r\n        creationProfit = _value;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        ownershipTokenCount[_to]++;\r\n        dogIndexToOwner[_tokenId] = _to;\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n            delete sireAllowedToAddress[_tokenId];\r\n            delete dogIndexToApproved[_tokenId];\r\n        }\r\n\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _createDog(\r\n        uint256 _matronId,\r\n        uint256 _sireId,\r\n        uint256 _generation,\r\n        uint256 _genes,\r\n        address _owner,\r\n        uint8 _variation,\r\n        uint256 _gen0,\r\n        bool _isGen0Siring\r\n    )\r\n        internal\r\n        returns (uint)\r\n    {\r\n        require(_matronId == uint256(uint32(_matronId)));\r\n        require(_sireId == uint256(uint32(_sireId)));\r\n        require(_generation == uint256(uint16(_generation)));\r\n\r\n        uint16 cooldownIndex = uint16(_generation / 2);\r\n        if (cooldownIndex > 13) {\r\n            cooldownIndex = 13;\r\n        }\r\n\r\n        Dog memory _dog = Dog({\r\n            genes: _genes,\r\n            birthTime: block.number,\r\n            cooldownEndBlock: 0,\r\n            matronId: uint32(_matronId),\r\n            sireId: uint32(_sireId),\r\n            siringWithId: 0,\r\n            cooldownIndex: cooldownIndex,\r\n            generation: uint16(_generation),\r\n            variation : uint8(_variation),\r\n            gen0 : _gen0\r\n        });\r\n        uint256 newDogId = dogs.push(_dog) - 1;\r\n\r\n        require(newDogId < 23887872);\r\n\r\n        Birth(\r\n            _owner,\r\n            newDogId,\r\n            uint256(_dog.matronId),\r\n            uint256(_dog.sireId),\r\n            _dog.genes,\r\n            uint16(_generation),\r\n            _variation,\r\n            _gen0,\r\n            block.number,\r\n            _isGen0Siring ? 0 : gen0Profit,\r\n            cooldownIndex\r\n        );\r\n\r\n        _transfer(0, _owner, newDogId);\r\n\r\n        return newDogId;\r\n    }\r\n\r\n    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\r\n        require(secs < cooldowns[0]);\r\n        secondsPerBlock = secs;\r\n    }\r\n}\r\n\r\n\r\ncontract DogOwnership is DogBase, ERC721 {\r\n\r\n    string public constant name = \"HelloDog\";\r\n    string public constant symbol = \"HD\";\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256(\"name()\")) ^\r\n        bytes4(keccak256(\"symbol()\")) ^\r\n        bytes4(keccak256(\"totalSupply()\")) ^\r\n        bytes4(keccak256(\"balanceOf(address)\")) ^\r\n        bytes4(keccak256(\"ownerOf(uint256)\")) ^\r\n        bytes4(keccak256(\"approve(address,uint256)\")) ^\r\n        bytes4(keccak256(\"transfer(address,uint256)\")) ^\r\n    bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return dogIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return dogIndexToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        dogIndexToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_to != address(saleAuction));\r\n        require(_to != address(siringAuction));\r\n\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function approve(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        _approve(_tokenId, _to);\r\n\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n\r\n        require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return dogs.length - 1;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address owner)\r\n    {\r\n        owner = dogIndexToOwner[_tokenId];\r\n\r\n        require(owner != address(0));\r\n    }\r\n}\r\n\r\n\r\ncontract DogBreeding is DogOwnership {\r\n\r\n    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 matronCooldownEndBlock, uint256 sireCooldownEndBlock, uint256 matronCooldownIndex, uint256 sireCooldownIndex);\r\n\r\n    uint256 public pregnantDogs;\r\n\r\n    GeneScienceInterface public geneScience;\r\n\r\n    function setGeneScienceAddress(address _address) external onlyCEO {\r\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\r\n\r\n        require(candidateContract.isGeneScience());\r\n\r\n        geneScience = candidateContract;\r\n    }\r\n\r\n    function _isReadyToBreed(Dog _dog) internal view returns (bool) {\r\n        return (_dog.siringWithId == 0) && (_dog.cooldownEndBlock <= uint64(block.number));\r\n    }\r\n\r\n    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns (bool) {\r\n        address matronOwner = dogIndexToOwner[_matronId];\r\n        address sireOwner = dogIndexToOwner[_sireId];\r\n\r\n        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);\r\n    }\r\n\r\n    function _triggerCooldown(Dog storage _dog) internal {\r\n        _dog.cooldownEndBlock = uint64((cooldowns[_dog.cooldownIndex]/secondsPerBlock) + block.number);\r\n\r\n        if (_dog.cooldownIndex < 13) {\r\n            _dog.cooldownIndex += 1;\r\n        }\r\n    }\r\n\r\n    function approveSiring(address _addr, uint256 _sireId)\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _sireId));\r\n        sireAllowedToAddress[_sireId] = _addr;\r\n    }\r\n\r\n    function setAutoBirthFee(uint256 val) external onlyCEO {\r\n        require(val > 0);\r\n        autoBirthFee = val;\r\n    }\r\n\r\n    function _isReadyToGiveBirth(Dog _matron) private view returns (bool) {\r\n        return (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));\r\n    }\r\n\r\n    function isReadyToBreed(uint256 _dogId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_dogId > 1);\r\n        Dog storage dog = dogs[_dogId];\r\n        return _isReadyToBreed(dog);\r\n    }\r\n\r\n    function isPregnant(uint256 _dogId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return dogs[_dogId].siringWithId != 0;\r\n    }\r\n\r\n    function _isValidMatingPair(\r\n        Dog storage _matron,\r\n        uint256 _matronId,\r\n        Dog storage _sire,\r\n        uint256 _sireId\r\n    )\r\n        private\r\n        view\r\n        returns(bool)\r\n    {\r\n        if (_matronId == _sireId) {\r\n            return false;\r\n        }\r\n\r\n        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {\r\n            return false;\r\n        }\r\n        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {\r\n            return false;\r\n        }\r\n\r\n        if (_sire.matronId == 0 || _matron.matronId == 0) {\r\n            return true;\r\n        }\r\n\r\n        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {\r\n            return false;\r\n        }\r\n        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        Dog storage matron = dogs[_matronId];\r\n        Dog storage sire = dogs[_sireId];\r\n        return _isValidMatingPair(matron, _matronId, sire, _sireId);\r\n    }\r\n    \r\n    function getOwner(uint256 _tokenId) public view returns(address){\r\n        address owner = dogIndexToOwner[_tokenId];\r\n        if(owner == address(saleAuction)){\r\n            return saleAuction.getSeller(_tokenId);\r\n        } else if (owner == address(siringAuction)){\r\n            return siringAuction.getSeller(_tokenId);\r\n        } else if (owner == address(this)){\r\n            return address(0);\r\n        }\r\n        return owner;\r\n    }\r\n\r\n    function _breedWith(uint256 _matronId, uint256 _sireId) internal {\r\n        require(_matronId > 1);\r\n        require(_sireId > 1);\r\n        \r\n        Dog storage sire = dogs[_sireId];\r\n        Dog storage matron = dogs[_matronId];\r\n\r\n        require(sire.variation == 0);\r\n        require(matron.variation == 0);\r\n\r\n        if (matron.generation > 0) {\r\n            var(,,openBlock,,,,,,) = lottery.getCLottery();\r\n            if (matron.birthTime < openBlock) {\r\n                require(lottery.checkLottery(matron.genes) == 100);\r\n            }\r\n        }\r\n\r\n        matron.siringWithId = uint32(_sireId);\r\n\r\n        _triggerCooldown(sire);\r\n        _triggerCooldown(matron);\r\n\r\n        delete sireAllowedToAddress[_matronId];\r\n        delete sireAllowedToAddress[_sireId];\r\n\r\n        pregnantDogs++;\r\n\r\n        cfoAddress.transfer(autoBirthFee);\r\n\r\n        address owner = getOwner(0);\r\n        if(owner != address(0)){\r\n            _sendMoney(owner, creationProfit);\r\n        }\r\n        owner = getOwner(1);\r\n        if(owner != address(0)){\r\n            _sendMoney(owner, creationProfit);\r\n        }\r\n\r\n        if (matron.generation > 0) {\r\n            owner = getOwner(matron.gen0);\r\n            if(owner != address(0)){\r\n                _sendMoney(owner, gen0Profit);\r\n            }\r\n        }\r\n\r\n        Pregnant(dogIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock, sire.cooldownEndBlock, matron.cooldownIndex, sire.cooldownIndex);\r\n    }\r\n\r\n    function breedWithAuto(uint256 _matronId, uint256 _sireId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {        \r\n        uint256 totalFee = autoBirthFee + creationProfit + creationProfit;\r\n        Dog storage matron = dogs[_matronId];\r\n        if (matron.generation > 0) {\r\n            totalFee += gen0Profit;\r\n        }\r\n\r\n        require(msg.value >= totalFee);\r\n\r\n        require(_owns(msg.sender, _matronId));\r\n\r\n        require(_isSiringPermitted(_sireId, _matronId));\r\n\r\n        require(_isReadyToBreed(matron));\r\n\r\n        Dog storage sire = dogs[_sireId];\r\n\r\n        require(_isReadyToBreed(sire));\r\n\r\n        require(_isValidMatingPair(matron, _matronId, sire, _sireId));\r\n\r\n        _breedWith(_matronId, _sireId);\r\n\r\n        uint256 breedExcess = msg.value - totalFee;\r\n        if (breedExcess > 0) {\r\n            msg.sender.transfer(breedExcess);\r\n        }\r\n    }\r\n\r\n    bool public giveBirthByUser = false;\r\n\r\n    function setGiveBirthType(bool _value) public onlyCEO {\r\n        giveBirthByUser = _value;\r\n    }\r\n\r\n    function giveBirth(uint256 _matronId, uint256 genes)\r\n        external\r\n        whenNotPaused\r\n        returns(uint256)\r\n    {\r\n        Dog storage matron = dogs[_matronId];\r\n\r\n        require(matron.birthTime != 0);\r\n\r\n        require(_isReadyToGiveBirth(matron));\r\n\r\n        uint256 sireId = matron.siringWithId;\r\n        Dog storage sire = dogs[sireId];\r\n\r\n        uint16 parentGen = matron.generation;\r\n        if (sire.generation > matron.generation) {\r\n            parentGen = sire.generation;\r\n        }\r\n\r\n        uint256 gen0 = matron.generation == 0 ? _matronId : matron.gen0;\r\n\r\n        uint256 childGenes = genes;\r\n        if(giveBirthByUser){\r\n            require(address(geneScience) != address(0));\r\n            childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);\r\n        } else {\r\n            require(msg.sender == ceoAddress || msg.sender == cooAddress || msg.sender == cfoAddress);\r\n        }\r\n        \r\n        address owner = dogIndexToOwner[_matronId];\r\n\r\n        uint8 _variation = variation.createVariation(childGenes, dogs.length);\r\n\r\n        bool isGen0Siring = matron.generation == 0;\r\n\r\n        uint256 kittenId = _createDog(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner, _variation, gen0, isGen0Siring);\r\n\r\n        delete matron.siringWithId;\r\n\r\n        pregnantDogs--;\r\n       \r\n        if(_variation != 0){              \r\n            variation.registerVariation(kittenId, owner);      \r\n            _transfer(owner, address(variation), kittenId);\r\n        }\r\n\r\n        return kittenId;\r\n    }\r\n}\r\n\r\n\r\ncontract ClockAuctionBase {\r\n\r\n    struct Auction {\r\n        \r\n        address seller;\r\n        \r\n        uint128 startingPrice;\r\n        \r\n        uint128 endingPrice;\r\n        \r\n        uint64 duration;\r\n        \r\n        uint64 startedAt;\r\n    }\r\n\r\n    ERC721 public nonFungibleContract;\r\n\r\n    uint256 public ownerCut;\r\n\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);\r\n    event AuctionCancelled(uint256 tokenId);\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n\r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\r\n        require(_auction.duration >= 1 minutes);\r\n\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        AuctionCreated(\r\n            uint256(_tokenId),\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.duration)\r\n        );\r\n    }\r\n\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        AuctionCancelled(_tokenId);\r\n    }\r\n\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount, address _to)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n        require(_isOnAuction(auction));\r\n\r\n        uint256 price = _currentPrice(auction);\r\n        uint256 auctioneerCut = computeCut(price);\r\n\r\n        uint256 fee = 0;\r\n        if (_tokenId == 0 || _tokenId == 1) {\r\n            fee = price / 5;\r\n        }        \r\n        require((_bidAmount + auctioneerCut + fee) >= price);\r\n\r\n        address seller = auction.seller;\r\n\r\n        _removeAuction(_tokenId);\r\n\r\n        if (price > 0) {\r\n            uint256 sellerProceeds = price - auctioneerCut - fee;\r\n\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        AuctionSuccessful(_tokenId, price, _to);\r\n\r\n        return price;\r\n    }\r\n\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    function _currentPrice(Auction storage _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_secondsPassed >= _duration) {\r\n            return _endingPrice;\r\n        } else {\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    function computeCut(uint256 _price) public view returns (uint256) {\r\n        return _price * ownerCut / 10000;\r\n    }\r\n}\r\n\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner whenNotPaused returns (bool) {\r\n        paused = true;\r\n        Pause();\r\n        return true;\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused returns (bool) {\r\n        paused = false;\r\n        Unpause();\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract ClockAuction is Pausable, ClockAuctionBase {\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256(\"name()\")) ^\r\n        bytes4(keccak256(\"symbol()\")) ^\r\n        bytes4(keccak256(\"totalSupply()\")) ^\r\n        bytes4(keccak256(\"balanceOf(address)\")) ^\r\n        bytes4(keccak256(\"ownerOf(uint256)\")) ^\r\n        bytes4(keccak256(\"approve(address,uint256)\")) ^\r\n        bytes4(keccak256(\"transfer(address,uint256)\")) ^\r\n    bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\r\n\r\n    function ClockAuction(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    function withdrawBalance() external {\r\n        address nftAddress = address(nonFungibleContract);\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == nftAddress\r\n        );\r\n        nftAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function cancelAuction(uint256 _tokenId)\r\n        external\r\n    {\r\n        require(_tokenId > 1);\r\n\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n        whenPaused\r\n        onlyOwner\r\n        external\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n            auction.seller,\r\n            auction.startingPrice,\r\n            auction.endingPrice,\r\n            auction.duration,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    function getSeller(uint256 _tokenId) external view returns(address){\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        if(_isOnAuction(auction)){\r\n            return auction.seller;\r\n        } else {\r\n            return nonFungibleContract.ownerOf(_tokenId);\r\n        }\r\n    }\r\n\r\n    function getCurrentPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SiringClockAuction is ClockAuction {\r\n\r\n    bool public isSiringClockAuction = true;\r\n\r\n    function SiringClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}\r\n\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n    {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    function bid(uint256 _tokenId, address _to)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        _bid(_tokenId, msg.value, _to);\r\n        _transfer(seller, _tokenId);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SaleClockAuction is ClockAuction {\r\n\r\n    bool public isSaleClockAuction = true;\r\n\r\n    uint256 public gen0SaleCount;\r\n\r\n    uint256[5] public lastGen0SalePrices;\r\n\r\n    function SaleClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}\r\n\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        external\r\n    {\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    function bid(uint256 _tokenId, address _to)\r\n        external\r\n        payable\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n\r\n        address seller = tokenIdToAuction[_tokenId].seller;  \r\n\r\n        require(seller != _to);\r\n\r\n        uint256 price = _bid(_tokenId, msg.value, _to);\r\n        \r\n        _transfer(_to, _tokenId);\r\n   \r\n        if (seller == address(nonFungibleContract)) {\r\n            lastGen0SalePrices[gen0SaleCount % 5] = price;\r\n            gen0SaleCount++;\r\n        }\r\n    }\r\n\r\n    function averageGen0SalePrice() external view returns (uint256) {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < 5; i++) {\r\n            sum += lastGen0SalePrices[i];\r\n        }\r\n        return sum / 5;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract DogAuction is DogBreeding {\r\n\r\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\r\n\r\n    function setSaleAuctionAddress(address _address) external onlyCEO {\r\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\r\n\r\n        require(candidateContract.isSaleClockAuction());\r\n\r\n        saleAuction = candidateContract;\r\n    }\r\n\r\n    function setSiringAuctionAddress(address _address) external onlyCEO {\r\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\r\n\r\n        require(candidateContract.isSiringClockAuction());\r\n\r\n        siringAuction = candidateContract;\r\n    }\r\n\r\n    function createSaleAuction(\r\n        uint256 _dogId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _dogId) || _approvedFor(msg.sender, _dogId));\r\n        require(!isPregnant(_dogId));\r\n        _approve(_dogId, saleAuction);\r\n        saleAuction.createAuction(\r\n            _dogId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            dogIndexToOwner[_dogId]\r\n        );\r\n    }\r\n\r\n    function createSiringAuction(\r\n        uint256 _dogId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {    \r\n        Dog storage dog = dogs[_dogId];    \r\n        require(dog.variation == 0);\r\n\r\n        require(_owns(msg.sender, _dogId));\r\n        require(isReadyToBreed(_dogId));\r\n        _approve(_dogId, siringAuction);\r\n        siringAuction.createAuction(\r\n            _dogId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function bidOnSiringAuction(\r\n        uint256 _sireId,\r\n        uint256 _matronId\r\n    )\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _matronId));\r\n        require(isReadyToBreed(_matronId));\r\n        require(_canBreedWithViaAuction(_matronId, _sireId));\r\n\r\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\r\n        \r\n        uint256 totalFee = currentPrice + autoBirthFee + creationProfit + creationProfit;\r\n        Dog storage matron = dogs[_matronId];\r\n        if (matron.generation > 0) {\r\n            totalFee += gen0Profit;\r\n        }        \r\n        require(msg.value >= totalFee);\r\n\r\n        uint256 auctioneerCut = saleAuction.computeCut(currentPrice);\r\n        siringAuction.bid.value(currentPrice - auctioneerCut)(_sireId, msg.sender);\r\n        _breedWith(uint32(_matronId), uint32(_sireId));\r\n\r\n        uint256 bidExcess = msg.value - totalFee;\r\n        if (bidExcess > 0) {\r\n            msg.sender.transfer(bidExcess);\r\n        }\r\n    }\r\n\r\n    function bidOnSaleAuction(\r\n        uint256 _dogId\r\n    )\r\n        external\r\n        payable\r\n        whenNotPaused\r\n    {\r\n        Dog storage dog = dogs[_dogId];\r\n\r\n        if (dog.generation > 0) {\r\n            var(,,openBlock,,,,,,) = lottery.getCLottery();\r\n            if (dog.birthTime < openBlock) {\r\n                require(lottery.checkLottery(dog.genes) == 100);\r\n            }\r\n        }\r\n\r\n        uint256 currentPrice = saleAuction.getCurrentPrice(_dogId);\r\n\r\n        require(msg.value >= currentPrice);\r\n\r\n        bool isCreationKitty = _dogId == 0 || _dogId == 1;\r\n        uint256 fee = 0;\r\n        if (isCreationKitty) {\r\n            fee = uint256(currentPrice / 5);\r\n        }\r\n        uint256 auctioneerCut = saleAuction.computeCut(currentPrice);\r\n        saleAuction.bid.value(currentPrice - (auctioneerCut + fee))(_dogId, msg.sender);\r\n\r\n        if (isCreationKitty) {\r\n            cfoAddress.transfer(fee);\r\n\r\n            uint256 nextPrice = uint256(uint128(2 * currentPrice));\r\n            if (nextPrice < currentPrice) {\r\n                nextPrice = currentPrice;\r\n            }\r\n            _approve(_dogId, saleAuction);\r\n            saleAuction.createAuction(\r\n                _dogId,\r\n                nextPrice,\r\n                nextPrice,                                               \r\n                GEN0_AUCTION_DURATION,\r\n                msg.sender);\r\n        }\r\n\r\n        uint256 bidExcess = msg.value - currentPrice;\r\n        if (bidExcess > 0) {\r\n            msg.sender.transfer(bidExcess);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract DogMinting is DogAuction {\r\n\r\n    uint256 public constant GEN0_CREATION_LIMIT = 40000;\r\n\r\n    uint256 public constant GEN0_STARTING_PRICE = 200 finney;\r\n\r\n    uint256 public gen0CreatedCount;\r\n\r\n    function createGen0Dog(uint256 _genes) external onlyCLevel returns(uint256) {\r\n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\r\n        \r\n        uint256 dogId = _createDog(0, 0, 0, _genes, address(this), 0, 0, false);\r\n        \r\n        _approve(dogId, msg.sender);\r\n\r\n        gen0CreatedCount++;\r\n        return dogId;\r\n    }\r\n\r\n    function computeNextGen0Price() public view returns (uint256) {\r\n        uint256 avePrice = saleAuction.averageGen0SalePrice();\r\n\r\n        require(avePrice == uint256(uint128(avePrice)));\r\n\r\n        uint256 nextPrice = avePrice + (avePrice / 2);\r\n\r\n        if (nextPrice < GEN0_STARTING_PRICE) {\r\n            nextPrice = GEN0_STARTING_PRICE;\r\n        }\r\n\r\n        return nextPrice;\r\n    }\r\n}\r\n\r\n\r\ncontract DogCore is DogMinting {\r\n\r\n    address public newContractAddress;\r\n\r\n    function DogCore() public {\r\n        \r\n        paused = true;\r\n\r\n        ceoAddress = msg.sender;\r\n\r\n        cooAddress = msg.sender;\r\n\r\n        _createDog(0, 0, 0, uint256(0), address(this), 0, 0, false);   \r\n        _approve(0, cooAddress);     \r\n        _createDog(0, 0, 0, uint256(0), address(this), 0, 0, false);   \r\n        _approve(1, cooAddress);\r\n    }\r\n\r\n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\r\n        newContractAddress = _v2Address;\r\n        ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    function() external payable {\r\n        require(\r\n            msg.sender == address(saleAuction) ||\r\n            msg.sender == address(siringAuction) ||\r\n            msg.sender == ceoAddress\r\n        );\r\n    }\r\n\r\n    function getDog(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n        uint256 cooldownIndex,\r\n        uint256 nextActionAt,\r\n        uint256 siringWithId,\r\n        uint256 birthTime,\r\n        uint256 matronId,\r\n        uint256 sireId,\r\n        uint256 generation,\r\n        uint256 genes,\r\n        uint8 variation,\r\n        uint256 gen0\r\n    ) {\r\n        Dog storage dog = dogs[_id];\r\n\r\n        cooldownIndex = uint256(dog.cooldownIndex);\r\n        nextActionAt = uint256(dog.cooldownEndBlock);\r\n        siringWithId = uint256(dog.siringWithId);\r\n        birthTime = uint256(dog.birthTime);\r\n        matronId = uint256(dog.matronId);\r\n        sireId = uint256(dog.sireId);\r\n        generation = uint256(dog.generation);\r\n        genes = uint256(dog.genes);\r\n        variation = uint8(dog.variation);\r\n        gen0 = uint256(dog.gen0);\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n        require(saleAuction != address(0));\r\n        require(siringAuction != address(0));\r\n        require(lottery != address(0));\r\n        require(variation != address(0));\r\n        require(newContractAddress == address(0));\r\n\r\n        super.unpause();\r\n    }\r\n      \r\n    function setLotteryAddress(address _address) external onlyCEO {\r\n        require(address(lottery) == address(0));\r\n\r\n        LotteryInterface candidateContract = LotteryInterface(_address);\r\n\r\n        require(candidateContract.isLottery());\r\n\r\n        lottery = candidateContract;\r\n    }  \r\n      \r\n    function setVariationAddress(address _address) external onlyCEO {\r\n        require(address(variation) == address(0));\r\n\r\n        VariationInterface candidateContract = VariationInterface(_address);\r\n\r\n        require(candidateContract.isVariation());\r\n\r\n        variation = candidateContract;\r\n    }  \r\n\r\n    function registerLottery(uint256 _dogId) external returns (uint8) {\r\n        require(_owns(msg.sender, _dogId));\r\n        require(lottery.registerLottery(_dogId) == 0);    \r\n        _transfer(msg.sender, address(lottery), _dogId);\r\n    }\r\n    \r\n    function getAvailableBlance() external view returns(uint256){\r\n        return address(this).balance - spendMoney;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"computeCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSiringClockAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getSeller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nftAddr\",\"type\":\"address\"},{\"name\":\"_cut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"SiringClockAuction","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009eea7965ee59c304f81d602ae1d9a3d624429d9d0000000000000000000000000000000000000000000000000000000000000177","Library":"","SwarmSource":"bzzr://8f9ed73a1495e40fde5c859a70727aafe2cbe19f02a7a5762fa794f552ac490f"}]}