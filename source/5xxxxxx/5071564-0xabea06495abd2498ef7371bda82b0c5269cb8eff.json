{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/*============================================================================= */\r\n/*=============================ERC721 interface==================================== */\r\n/*============================================================================= */\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Yumin.yang\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    //function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    //function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    //function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    //event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n}\r\n\r\n\r\n/*============================================================================= */\r\n/*=============================Forever Rose==================================== */\r\n/*============================================================================= */\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Yumin.yang\r\ncontract DivisibleForeverRose is ERC721 {\r\n  \r\n    //This contract's owner\r\n    address private contractOwner;\r\n\r\n    \r\n    //Gift token storage.\r\n    mapping(uint => GiftToken) giftStorage;\r\n\r\n    // Total supply of this token. \r\n\tuint public totalSupply = 10; \r\n\r\n    bool public tradable = false;\r\n\r\n    uint foreverRoseId = 1;\r\n\r\n    // Divisibility of ownership over a token  \r\n\tmapping(address => mapping(uint => uint)) ownerToTokenShare;\r\n\r\n\t// How much owners have of a token\r\n\tmapping(uint => mapping(address => uint)) tokenToOwnersHoldings;\r\n\r\n    // If Forever Rose has been created\r\n\tmapping(uint => bool) foreverRoseCreated;\r\n\r\n    string public name;  \r\n    string public symbol;           \r\n    uint8 public decimals = 1;                                 \r\n    string public version = \"1.0\";    \r\n\r\n    //Special gift token\r\n    struct GiftToken {\r\n        uint256 giftId;\r\n    } \r\n\r\n    //@dev Constructor \r\n    function DivisibleForeverRose() public {\r\n        contractOwner = msg.sender;\r\n        name = \"ForeverRose\";\r\n        symbol = \"ROSE\";  \r\n\r\n        // Create Forever rose\r\n        GiftToken memory newGift = GiftToken({\r\n            giftId: foreverRoseId\r\n        });\r\n        giftStorage[foreverRoseId] = newGift;\r\n\r\n        \r\n        foreverRoseCreated[foreverRoseId] = true;\r\n        _addNewOwnerHoldingsToToken(contractOwner, foreverRoseId, totalSupply);\r\n        _addShareToNewOwner(contractOwner, foreverRoseId, totalSupply);\r\n\r\n    }\r\n    \r\n    // Fallback funciton\r\n    function() public {\r\n        revert();\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256 total) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return ownerToTokenShare[_owner][foreverRoseId];\r\n    }\r\n\r\n    // We use parameter '_tokenId' as the divisibility\r\n    function transfer(address _to, uint256 _tokenId) external {\r\n\r\n        // Requiring this contract be tradable\r\n        require(tradable == true);\r\n\r\n        require(_to != address(0));\r\n        require(msg.sender != _to);\r\n\r\n        // Take _tokenId as divisibility\r\n        uint256 _divisibility = _tokenId;\r\n\r\n        // Requiring msg.sender has Holdings of Forever rose\r\n        require(tokenToOwnersHoldings[foreverRoseId][msg.sender] >= _divisibility);\r\n\r\n    \r\n        // Remove divisibilitys from old owner\r\n        _removeShareFromLastOwner(msg.sender, foreverRoseId, _divisibility);\r\n        _removeLastOwnerHoldingsFromToken(msg.sender, foreverRoseId, _divisibility);\r\n\r\n        // Add divisibilitys to new owner\r\n        _addNewOwnerHoldingsToToken(_to, foreverRoseId, _divisibility);\r\n        _addShareToNewOwner(_to, foreverRoseId, _divisibility);\r\n\r\n        // Trigger Ethereum Event\r\n        Transfer(msg.sender, _to, foreverRoseId);\r\n\r\n    }\r\n\r\n    // Transfer gift to a new owner.\r\n    function assignSharedOwnership(address _to, uint256 _divisibility)\r\n                               onlyOwner external returns (bool success) \r\n                               {\r\n\r\n        require(_to != address(0));\r\n        require(msg.sender != _to);\r\n        require(_to != address(this));\r\n        \r\n        // Requiring msg.sender has Holdings of Forever rose\r\n        require(tokenToOwnersHoldings[foreverRoseId][msg.sender] >= _divisibility);\r\n\r\n        //Remove ownership from oldOwner(msg.sender)\r\n        _removeLastOwnerHoldingsFromToken(msg.sender, foreverRoseId, _divisibility);\r\n        _removeShareFromLastOwner(msg.sender, foreverRoseId, _divisibility);\r\n\r\n         //Add ownership to NewOwner(address _to)\r\n        _addShareToNewOwner(_to, foreverRoseId, _divisibility); \r\n        _addNewOwnerHoldingsToToken(_to, foreverRoseId, _divisibility);\r\n\r\n        // Trigger Ethereum Event\r\n        Transfer(msg.sender, _to, foreverRoseId);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getForeverRose() public view returns(uint256 _foreverRoseId) {\r\n        return giftStorage[foreverRoseId].giftId;\r\n    }\r\n\r\n    // Turn on this contract to be tradable, so owners can transfer their token\r\n    function turnOnTradable() public onlyOwner {\r\n        tradable = true;\r\n    }\r\n    \r\n    // ------------------------------ Helper functions (internal functions) ------------------------------\r\n\r\n\t// Add divisibility to new owner\r\n\tfunction _addShareToNewOwner(address _owner, uint _tokenId, uint _units) internal {\r\n\t\townerToTokenShare[_owner][_tokenId] += _units;\r\n\t}\r\n\r\n\t\r\n\t// Add the divisibility to new owner\r\n\tfunction _addNewOwnerHoldingsToToken(address _owner, uint _tokenId, uint _units) internal {\r\n\t\ttokenToOwnersHoldings[_tokenId][_owner] += _units;\r\n\t}\r\n    \r\n    // Remove divisibility from last owner\r\n\tfunction _removeShareFromLastOwner(address _owner, uint _tokenId, uint _units) internal {\r\n\t\townerToTokenShare[_owner][_tokenId] -= _units;\r\n\t}\r\n    \r\n    // Remove divisibility from last owner \r\n\tfunction _removeLastOwnerHoldingsFromToken(address _owner, uint _tokenId, uint _units) internal {\r\n\t\ttokenToOwnersHoldings[_tokenId][_owner] -= _units;\r\n\t}\r\n\r\n    // Withdraw Ether from this contract to Multi sigin wallet\r\n    function withdrawEther() onlyOwner public returns(bool) {\r\n        return contractOwner.send(this.balance);\r\n    }\r\n\r\n    // ------------------------------ Modifier -----------------------------------\r\n\r\n\r\n     modifier onlyExistentToken(uint _tokenId) {\r\n\t    require(foreverRoseCreated[_tokenId] == true);\r\n\t    _;\r\n\t}\r\n\r\n    modifier onlyOwner(){\r\n         require(msg.sender == contractOwner);\r\n         _;\r\n     }\r\n\r\n}\r\n\r\n\r\n/*============================================================================= */\r\n/*=============================MultiSig Wallet================================= */\r\n/*============================================================================= */\r\n\r\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n/// @author Stefan George - <stefan.george@consensys.net>\r\ncontract MultiSigWallet {\r\n\r\n   //Load Gifto and IAMICOIN Contracts to this contract.\r\n    //ERC20 private Gifto = ERC20(0x92e87a5622cf9955d1062822454701198a028a72);\r\n    //ERC20 private IAMIToken = ERC20(0xee10a06b2a0cf7e04115edfbee46242136eb6ae1);\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n    event CoinCreation(address coin);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n    bool flag = true;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this))\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner])\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner])\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner])\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner])\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (   ownerCount > MAX_OWNER_COUNT\r\n            || _required > ownerCount\r\n            || _required == 0\r\n            || ownerCount == 0)\r\n            revert();\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0)\r\n                revert();\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param owner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n\r\n    // Transfer GTO to an outside account\r\n    /*function _withdrawGTO(address _to, uint256 _balance) onlyOwner internal { \r\n        require(Gifto.balanceOf(address(this)) >= _balance);\r\n        Gifto.transfer(_to, _balance); \r\n    }\r\n\r\n    // Transfer IAMI to an outside account\r\n    function _withdrawIAMI(address _to, uint256 _balance) onlyOwner internal { \r\n        require(IAMIToken.balanceOf(address(this)) >= _balance);\r\n        IAMIToken.transfer(_to, _balance); \r\n    }\r\n\r\n    // Change Gifto contract's address or another type of token, like Ether.\r\n    function setIAMITokenAddress(address newAddress) public onlyOwner {\r\n        IAMIToken = ERC20(newAddress);\r\n    }\r\n\r\n    function setGiftoAddress(address newAddress) public onlyOwner {\r\n        Gifto = ERC20(newAddress);\r\n    }*/\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /// @dev Create new forever rose.\r\n    function createForeverRose()\r\n        external\r\n        onlyWallet\r\n    {\r\n        require(flag == true);\r\n        CoinCreation(new DivisibleForeverRose());\r\n        flag = false;\r\n    }\r\n    \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_divisibility\",\"type\":\"uint256\"}],\"name\":\"assignSharedOwnership\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"turnOnTradable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getForeverRose\",\"outputs\":[{\"name\":\"_foreverRoseId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"DivisibleForeverRose","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://77811e630f4e1dfbc50c1b01b5758f237974943ceae9234357417417ab89e2c3"}]}