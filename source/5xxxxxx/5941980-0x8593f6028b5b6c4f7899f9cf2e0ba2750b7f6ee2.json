{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2018 bZeroX, LLC\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// This provides a gatekeeping modifier for functions that can only be used by the bZx contract\r\n// Since it inherits Ownable provides typical ownership functionality with a slight modification to the transferOwnership function\r\n// Setting owner and bZxContractAddress to the same address is not supported.\r\ncontract BZxOwnable is Ownable {\r\n\r\n    address public bZxContractAddress;\r\n\r\n    event BZxOwnershipTransferred(address indexed previousBZxContract, address indexed newBZxContract);\r\n\r\n    // modifier reverts if bZxContractAddress isn't set\r\n    modifier onlyBZx() {\r\n        require(msg.sender == bZxContractAddress, \"only bZx contracts can call this function\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer the bZx contract owner to a new contract address\r\n    * @param newBZxContractAddress The bZx contract address to transfer ownership to.\r\n    */\r\n    function transferBZxOwnership(address newBZxContractAddress) public onlyOwner {\r\n        require(newBZxContractAddress != address(0) && newBZxContractAddress != owner, \"transferBZxOwnership::unauthorized\");\r\n        emit BZxOwnershipTransferred(bZxContractAddress, newBZxContractAddress);\r\n        bZxContractAddress = newBZxContractAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    * This overrides transferOwnership in Ownable to prevent setting the new owner the same as the bZxContract\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0) && newOwner != bZxContractAddress, \"transferOwnership::unauthorized\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract GasRefunder {\r\n    using SafeMath for uint256;\r\n\r\n    // If true, uses the \"transfer\" method, which throws on failure, reverting state.\r\n    // If false, a failed \"send\" won't throw, and fails silently.\r\n    // Note that a throw will prevent a GasRefund event.\r\n    bool public throwOnGasRefundFail = false;\r\n\r\n    struct GasData {\r\n        address payer;\r\n        uint gasUsed;\r\n        bool isPaid;\r\n    }\r\n\r\n    event GasRefund(address payer, uint gasUsed, uint currentGasPrice, uint refundAmount, bool refundSuccess);\r\n\r\n    modifier refundsGas(address payer, uint gasPrice, uint gasUsed, uint percentMultiplier)\r\n    {\r\n        _;\r\n        calculateAndSendRefund(\r\n            payer,\r\n            gasUsed,\r\n            gasPrice,\r\n            percentMultiplier\r\n        );\r\n    }\r\n\r\n    modifier refundsGasAfterCollection(address payer, uint gasPrice, uint percentMultiplier)\r\n    {\r\n        uint startingGas = gasleft();\r\n        _;\r\n        calculateAndSendRefund(\r\n            payer,\r\n            startingGas,\r\n            gasPrice,\r\n            percentMultiplier\r\n        );\r\n    }\r\n\r\n    function calculateAndSendRefund(\r\n        address payer,\r\n        uint gasUsed,\r\n        uint gasPrice,\r\n        uint percentMultiplier)\r\n        internal\r\n    {\r\n\r\n        if (gasUsed == 0 || gasPrice == 0)\r\n            return;\r\n\r\n        gasUsed = gasUsed - gasleft();\r\n\r\n        sendRefund(\r\n            payer,\r\n            gasUsed,\r\n            gasPrice,\r\n            percentMultiplier\r\n        );\r\n    }\r\n\r\n    function sendRefund(\r\n        address payer,\r\n        uint gasUsed,\r\n        uint gasPrice,\r\n        uint percentMultiplier)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (percentMultiplier == 0) // 0 percentMultiplier not allowed\r\n            percentMultiplier = 100;\r\n        \r\n        uint refundAmount = gasUsed.mul(gasPrice).mul(percentMultiplier).div(100);\r\n\r\n        if (throwOnGasRefundFail) {\r\n            payer.transfer(refundAmount);\r\n            emit GasRefund(\r\n                payer,\r\n                gasUsed,\r\n                gasPrice,\r\n                refundAmount,\r\n                true\r\n            );\r\n        } else {\r\n            emit GasRefund(\r\n                payer,\r\n                gasUsed,\r\n                gasPrice,\r\n                refundAmount,\r\n                payer.send(refundAmount)\r\n            );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n// supports a single EMA calculated for the inheriting contract\r\ncontract EMACollector {\r\n\r\n    uint public emaValue; // the last ema calculated\r\n    uint public emaPeriods; // averaging periods for EMA calculation\r\n\r\n    modifier updatesEMA(uint value) {\r\n        _;\r\n        updateEMA(value);\r\n    }\r\n\r\n    function updateEMA(uint value) \r\n        internal {\r\n        /*\r\n            Multiplier: 2 / (emaPeriods + 1)\r\n            EMA: (LastestValue - PreviousEMA) * Multiplier + PreviousEMA \r\n        */\r\n\r\n        require(emaPeriods >= 2, \"emaPeriods < 2\");\r\n\r\n        // calculate new EMA\r\n        emaValue = \r\n            SafeMath.sub(\r\n                SafeMath.add(\r\n                    value / (emaPeriods + 1) * 2,\r\n                    emaValue\r\n                ),\r\n                emaValue / (emaPeriods + 1) * 2\r\n            );\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title EIP20/ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract EIP20 is ERC20 {\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n}\r\n\r\ninterface NonCompliantEIP20 {\r\n    function transfer(address _to, uint _value) external;\r\n    function transferFrom(address _from, address _to, uint _value) external;\r\n    function approve(address _spender, uint _value) external;\r\n}\r\n\r\n/**\r\n * @title EIP20/ERC20 wrapper that will support noncompliant ERC20s\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n * @dev see https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\r\n */\r\ncontract EIP20Wrapper {\r\n\r\n    function eip20Transfer(\r\n        address token,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transfer(to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Transfer failed\");\r\n    }\r\n\r\n    function eip20TransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).transferFrom(from, to, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20TransferFrom failed\");\r\n    }\r\n\r\n    function eip20Approve(\r\n        address token,\r\n        address spender,\r\n        uint256 value)\r\n        internal\r\n        returns (bool result) {\r\n\r\n        NonCompliantEIP20(token).approve(spender, value);\r\n\r\n        assembly {\r\n            switch returndatasize()   \r\n            case 0 {                        // non compliant ERC20\r\n                result := not(0)            // result is true\r\n            }\r\n            case 32 {                       // compliant ERC20\r\n                returndatacopy(0, 0, 32) \r\n                result := mload(0)          // result == returndata of external call\r\n            }\r\n            default {                       // not an not an ERC20 token\r\n                revert(0, 0) \r\n            }\r\n        }\r\n\r\n        require(result, \"eip20Approve failed\");\r\n    }\r\n}\r\n\r\ninterface OracleInterface {\r\n\r\n    /// @dev Called by bZx after a loan order is taken\r\n    /// @param loanOrderHash A unique hash representing the loan order\r\n    /// @param taker The taker of the loan order\r\n    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\r\n    /// @return Successful execution of the function\r\n    function didTakeOrder(\r\n        bytes32 loanOrderHash,\r\n        address taker,\r\n        uint gasUsed)\r\n        external\r\n        returns (bool);\r\n\r\n    /// @dev Called by bZx after a position token is traded\r\n    /// @param loanOrderHash A unique hash representing the loan order\r\n    /// @param trader The trader doing the trade\r\n    /// @param tradeTokenAddress The token that was bought in the trade\r\n    /// @param tradeTokenAmount The amount of token that was bought\r\n    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\r\n    /// @return Successful execution of the function\r\n    function didTradePosition(\r\n        bytes32 loanOrderHash,\r\n        address trader,\r\n        address tradeTokenAddress,\r\n        uint tradeTokenAmount,\r\n        uint gasUsed)\r\n        external\r\n        returns (bool);\r\n\r\n    /// @dev Called by bZx after interest should be paid to a lender\r\n    /// @dev Assume the interest token has already been transfered to\r\n    /// @dev this contract before this function is called.\r\n    /// @param loanOrderHash A unique hash representing the loan order\r\n    /// @param trader The trader\r\n    /// @param lender The lender\r\n    /// @param interestTokenAddress The token that will be paid for interest\r\n    /// @param amountOwed The amount interest to pay\r\n    /// @param convert A boolean indicating if the interest should be converted to Ether\r\n    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\r\n    /// @return Successful execution of the function\r\n    function didPayInterest(\r\n        bytes32 loanOrderHash,\r\n        address trader,\r\n        address lender,\r\n        address interestTokenAddress,\r\n        uint amountOwed,\r\n        bool convert,\r\n        uint gasUsed)\r\n        external\r\n        returns (bool);\r\n\r\n    /// @dev Called by bZx after a borrower has deposited additional collateral\r\n    /// @dev token for an open loan\r\n    /// @param loanOrderHash A unique hash representing the loan order.\r\n    /// @param borrower The borrower\r\n    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\r\n    /// @return Successful execution of the function\r\n    function didDepositCollateral(\r\n        bytes32 loanOrderHash,\r\n        address borrower,\r\n        uint gasUsed)\r\n        external\r\n        returns (bool);\r\n\r\n    /// @dev Called by bZx after a borrower has withdrawn excess collateral\r\n    /// @dev token for an open loan\r\n    /// @param loanOrderHash A unique hash representing the loan order.\r\n    /// @param borrower The borrower\r\n    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\r\n    /// @return Successful execution of the function\r\n    function didWithdrawCollateral(\r\n        bytes32 loanOrderHash,\r\n        address borrower,\r\n        uint gasUsed)\r\n        external\r\n        returns (bool);\r\n\r\n    /// @dev Called by bZx after a borrower has changed the collateral token\r\n    /// @dev used for an open loan\r\n    /// @param loanOrderHash A unique hash representing the loan order\r\n    /// @param borrower The borrower\r\n    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\r\n    /// @return Successful execution of the function\r\n    function didChangeCollateral(\r\n        bytes32 loanOrderHash,\r\n        address borrower,\r\n        uint gasUsed)\r\n        external\r\n        returns (bool);\r\n\r\n    /// @dev Called by bZx after a borrower has withdraw their profits, if any\r\n    /// @dev used for an open loan\r\n    /// @param loanOrderHash A unique hash representing the loan order\r\n    /// @param borrower The borrower\r\n    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\r\n    /// @return Successful execution of the function\r\n    function didWithdrawProfit(\r\n        bytes32 loanOrderHash,\r\n        address borrower,\r\n        uint profitOrLoss,\r\n        uint gasUsed)\r\n        external\r\n        returns (bool);\r\n\r\n    /// @dev Called by bZx after a loan is closed\r\n    /// @param loanOrderHash A unique hash representing the loan order.\r\n    /// @param loanCloser The user that closed the loan\r\n    /// @param isLiquidation A boolean indicating if the loan was closed due to liquidation\r\n    /// @param gasUsed The initial used gas, collected in a modifier in bZx, for optional gas refunds\r\n    /// @return Successful execution of the function\r\n    function didCloseLoan(\r\n        bytes32 loanOrderHash,\r\n        address loanCloser,\r\n        bool isLiquidation,\r\n        uint gasUsed)\r\n        external\r\n        returns (bool);\r\n\r\n    /// @dev Places a manual on-chain trade with a liquidity provider\r\n    /// @param sourceTokenAddress The token being sold\r\n    /// @param destTokenAddress The token being bought\r\n    /// @param sourceTokenAmount The amount of token being sold\r\n    /// @return The amount of destToken bought\r\n    function doManualTrade(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint sourceTokenAmount)\r\n        external\r\n        returns (uint);\r\n\r\n    /// @dev Places an automatic on-chain trade with a liquidity provider\r\n    /// @param sourceTokenAddress The token being sold\r\n    /// @param destTokenAddress The token being bought\r\n    /// @param sourceTokenAmount The amount of token being sold\r\n    /// @return The amount of destToken bought\r\n    function doTrade(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint sourceTokenAmount)\r\n        external\r\n        returns (uint);\r\n\r\n    /// @dev Verifies a position has fallen below margin maintenance\r\n    /// @dev then liquidates the position on-chain\r\n    /// @param loanTokenAddress The token that was loaned\r\n    /// @param positionTokenAddress The token in the current position (could also be the loanToken)\r\n    /// @param collateralTokenAddress The token used for collateral\r\n    /// @param loanTokenAmount The amount of loan token\r\n    /// @param positionTokenAmount The amount of position token\r\n    /// @param collateralTokenAmount The amount of collateral token\r\n    /// @param maintenanceMarginAmount The maintenance margin amount from the loan\r\n    /// @return The amount of destToken bought\r\n    function verifyAndLiquidate(\r\n        address loanTokenAddress,\r\n        address positionTokenAddress,\r\n        address collateralTokenAddress,\r\n        uint loanTokenAmount,\r\n        uint positionTokenAmount,\r\n        uint collateralTokenAmount,\r\n        uint maintenanceMarginAmount)\r\n        external\r\n        returns (uint);\r\n\r\n    /// @dev Liquidates collateral to cover loan losses\r\n    /// @param collateralTokenAddress The collateral token\r\n    /// @param loanTokenAddress The loan token\r\n    /// @param collateralTokenAmountUsable The total amount of collateral usable to cover losses\r\n    /// @param loanTokenAmountNeeded The amount of loan token needed to cover losses\r\n    /// @param initialMarginAmount The initial margin amount set for the loan\r\n    /// @param maintenanceMarginAmount The maintenance margin amount set for the loan\r\n    /// @return The amount of destToken bought\r\n    function doTradeofCollateral(\r\n        address collateralTokenAddress,\r\n        address loanTokenAddress,\r\n        uint collateralTokenAmountUsable,\r\n        uint loanTokenAmountNeeded,\r\n        uint initialMarginAmount,\r\n        uint maintenanceMarginAmount)\r\n        external\r\n        returns (uint, uint);\r\n\r\n    /// @dev Checks if a position has fallen below margin\r\n    /// @dev maintenance and should be liquidated\r\n    /// @param loanOrderHash A unique hash representing the loan order\r\n    /// @param trader The address of the trader\r\n    /// @param loanTokenAddress The token that was loaned\r\n    /// @param positionTokenAddress The token in the current position (could also be the loanToken)\r\n    /// @param collateralTokenAddress The token used for collateral\r\n    /// @param loanTokenAmount The amount of loan token\r\n    /// @param positionTokenAmount The amount of position token\r\n    /// @param collateralTokenAmount The amount of collateral token\r\n    /// @param maintenanceMarginAmount The maintenance margin amount from the loan\r\n    /// @return Returns True if the trade should be liquidated immediately\r\n    function shouldLiquidate(\r\n        bytes32 loanOrderHash,\r\n        address trader,\r\n        address loanTokenAddress,\r\n        address positionTokenAddress,\r\n        address collateralTokenAddress,\r\n        uint loanTokenAmount,\r\n        uint positionTokenAmount,\r\n        uint collateralTokenAmount,\r\n        uint maintenanceMarginAmount)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Gets the trade price of the ERC-20 token pair\r\n    /// @param sourceTokenAddress Token being sold\r\n    /// @param destTokenAddress Token being bought\r\n    /// @return The trade rate\r\n    function getTradeRate(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress)\r\n        external\r\n        view \r\n        returns (uint);\r\n\r\n    /// @dev Returns the profit/loss data for the current position\r\n    /// @param positionTokenAddress The token in the current position (could also be the loanToken)\r\n    /// @param loanTokenAddress The token that was loaned\r\n    /// @param positionTokenAmount The amount of position token\r\n    /// @param loanTokenAmount The amount of loan token\r\n    /// @return isProfit, profitOrLoss (denominated in positionToken)\r\n    function getProfitOrLoss(\r\n        address positionTokenAddress,\r\n        address loanTokenAddress,\r\n        uint positionTokenAmount,\r\n        uint loanTokenAmount)\r\n        external\r\n        view\r\n        returns (bool isProfit, uint profitOrLoss);\r\n\r\n    /// @dev Returns the current margin level for this particular loan/position\r\n    /// @param loanTokenAddress The token that was loaned\r\n    /// @param positionTokenAddress The token in the current position (could also be the loanToken)\r\n    /// @param collateralTokenAddress The token used for collateral\r\n    /// @param loanTokenAmount The amount of loan token\r\n    /// @param positionTokenAmount The amount of position token\r\n    /// @param collateralTokenAmount The amount of collateral token\r\n    /// @return The current margin amount (a percentage -> i.e. 54350000000000000000 == 54.35%)\r\n    function getCurrentMarginAmount(\r\n        address loanTokenAddress,\r\n        address positionTokenAddress,\r\n        address collateralTokenAddress,\r\n        uint loanTokenAmount,\r\n        uint positionTokenAmount,\r\n        uint collateralTokenAmount)\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev Checks if the ERC20 token pair is supported by the oracle\r\n    /// @param sourceTokenAddress Token being sold\r\n    /// @param destTokenAddress Token being bought\r\n    /// @param sourceTokenAmount Amount of token being sold\r\n    /// @return True if price discovery and trading is supported\r\n    function isTradeSupported(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint sourceTokenAmount)\r\n        external\r\n        view \r\n        returns (bool);\r\n}\r\n\r\ninterface WETH_Interface {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\ninterface KyberNetwork_Interface {\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @return amount of actual dest tokens\r\n    function trade(\r\n        address src,\r\n        uint srcAmount,\r\n        address dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        external\r\n        payable\r\n        returns(uint);\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    function getExpectedRate(\r\n        address src,\r\n        address dest,\r\n        uint srcQty) \r\n        external \r\n        view \r\n        returns (uint expectedRate, uint slippageRate);\r\n}\r\n\r\ncontract BZxOracle is OracleInterface, EIP20Wrapper, EMACollector, GasRefunder, BZxOwnable {\r\n    using SafeMath for uint256;\r\n\r\n    // this is the value the Kyber portal uses when setting a very high maximum number\r\n    uint internal constant MAX_FOR_KYBER = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n\r\n    address internal constant KYBER_ETH_TOKEN_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n\r\n    // Percentage of interest retained as fee\r\n    // This will always be between 0 and 100\r\n    uint public interestFeePercent = 10;\r\n\r\n    // Percentage of liquidation level that will trigger a liquidation of positions\r\n    // This can never be less than 100\r\n    uint public liquidationThresholdPercent = 105;\r\n\r\n    // Percentage of gas refund paid to non-bounty hunters\r\n    uint public gasRewardPercent = 10;\r\n\r\n    // Percentage of gas refund paid to bounty hunters after successfully liquidating a position\r\n    uint public bountyRewardPercent = 110;\r\n\r\n    // A threshold of minimum initial margin for loan to be insured by the guarantee fund\r\n    // A value of 0 indicates that no threshold exists for this parameter.\r\n    uint public minInitialMarginAmount = 0;\r\n\r\n    // A threshold of minimum maintenance margin for loan to be insured by the guarantee fund\r\n    // A value of 0 indicates that no threshold exists for this parameter.\r\n    uint public minMaintenanceMarginAmount = 25;\r\n\r\n    bool public isManualTradingAllowed = true;\r\n\r\n    address public vaultContract;\r\n    address public kyberContract;\r\n    address public wethContract;\r\n    address public bZRxTokenContract;\r\n\r\n    mapping (bytes32 => GasData[]) public gasRefunds; // mapping of loanOrderHash to array of GasData\r\n\r\n    constructor(\r\n        address _vaultContract,\r\n        address _kyberContract,\r\n        address _wethContract,\r\n        address _bZRxTokenContract)\r\n        public\r\n        payable\r\n    {\r\n        vaultContract = _vaultContract;\r\n        kyberContract = _kyberContract;\r\n        wethContract = _wethContract;\r\n        bZRxTokenContract = _bZRxTokenContract;\r\n\r\n        // settings for EMACollector\r\n        emaValue = 20 * 10**9 wei; // set an initial price average for gas (20 gwei)\r\n        emaPeriods = 10; // set periods to use for EMA calculation\r\n    }\r\n\r\n    // The contract needs to be able to receive Ether from Kyber trades\r\n    function() public payable {}\r\n\r\n    // standard functions\r\n    function didTakeOrder(\r\n        bytes32 loanOrderHash,\r\n        address taker,\r\n        uint gasUsed)\r\n        public\r\n        onlyBZx\r\n        updatesEMA(tx.gasprice)\r\n        returns (bool)\r\n    {\r\n        gasRefunds[loanOrderHash].push(GasData({\r\n            payer: taker,\r\n            gasUsed: gasUsed.sub(gasleft()),\r\n            isPaid: false\r\n        }));\r\n\r\n        return true;\r\n    }\r\n\r\n    function didTradePosition(\r\n        bytes32 /* loanOrderHash */,\r\n        address /* trader */,\r\n        address /* tradeTokenAddress */,\r\n        uint /* tradeTokenAmount */,\r\n        uint /* gasUsed */)\r\n        public\r\n        onlyBZx\r\n        updatesEMA(tx.gasprice)\r\n        returns (bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function didPayInterest(\r\n        bytes32 /* loanOrderHash */,\r\n        address /* trader */,\r\n        address lender,\r\n        address interestTokenAddress,\r\n        uint amountOwed,\r\n        bool convert,\r\n        uint /* gasUsed */)\r\n        public\r\n        onlyBZx\r\n        updatesEMA(tx.gasprice)\r\n        returns (bool)\r\n    {\r\n        uint interestFee = amountOwed.mul(interestFeePercent).div(100);\r\n\r\n        // Transfers the interest to the lender, less the interest fee.\r\n        // The fee is retained by the oracle.\r\n        if (!_transferToken(\r\n            interestTokenAddress,\r\n            lender,\r\n            amountOwed.sub(interestFee))) {\r\n            revert(\"BZxOracle::didPayInterest: _transferToken failed\");\r\n        }\r\n\r\n        if (interestTokenAddress == wethContract) {\r\n            // interest paid in WETH is withdrawn to Ether\r\n            WETH_Interface(wethContract).withdraw(interestFee);\r\n        } else if (convert && interestTokenAddress != bZRxTokenContract) {\r\n            // interest paid in BZRX is retained as is, other tokens are sold for Ether\r\n            _doTradeForEth(\r\n                interestTokenAddress,\r\n                interestFee,\r\n                this // BZxOracle receives the Ether proceeds\r\n            );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function didDepositCollateral(\r\n        bytes32 /* loanOrderHash */,\r\n        address /* borrower */,\r\n        uint /* gasUsed */)\r\n        public\r\n        onlyBZx\r\n        updatesEMA(tx.gasprice)\r\n        returns (bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function didWithdrawCollateral(\r\n        bytes32 /* loanOrderHash */,\r\n        address /* borrower */,\r\n        uint /* gasUsed */)\r\n        public\r\n        onlyBZx\r\n        updatesEMA(tx.gasprice)\r\n        returns (bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function didChangeCollateral(\r\n        bytes32 /* loanOrderHash */,\r\n        address /* borrower */,\r\n        uint /* gasUsed */)\r\n        public\r\n        onlyBZx\r\n        updatesEMA(tx.gasprice)\r\n        returns (bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function didWithdrawProfit(\r\n        bytes32 /* loanOrderHash */,\r\n        address /* borrower */,\r\n        uint /* profitOrLoss */,\r\n        uint /* gasUsed */)\r\n        public\r\n        onlyBZx\r\n        updatesEMA(tx.gasprice)\r\n        returns (bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function didCloseLoan(\r\n        bytes32 loanOrderHash,\r\n        address loanCloser,\r\n        bool isLiquidation,\r\n        uint gasUsed)\r\n        public\r\n        onlyBZx\r\n        //refundsGas(taker, emaValue, gasUsed, 0) // refunds based on collected gas price EMA\r\n        updatesEMA(tx.gasprice)\r\n        returns (bool)\r\n    {\r\n        // sends gas refunds owed from earlier transactions\r\n        for (uint i=0; i < gasRefunds[loanOrderHash].length; i++) {\r\n            GasData storage gasData = gasRefunds[loanOrderHash][i];\r\n            if (!gasData.isPaid) {\r\n                if (sendRefund(\r\n                    gasData.payer,\r\n                    gasData.gasUsed,\r\n                    emaValue,\r\n                    gasRewardPercent))               \r\n                        gasData.isPaid = true;\r\n            }\r\n        }\r\n\r\n        // sends gas and bounty reward to bounty hunter\r\n        if (isLiquidation) {\r\n            calculateAndSendRefund(\r\n                loanCloser,\r\n                gasUsed,\r\n                emaValue,\r\n                bountyRewardPercent);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    function doManualTrade(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint sourceTokenAmount)\r\n        public\r\n        onlyBZx\r\n        returns (uint destTokenAmount)\r\n    {\r\n        if (isManualTradingAllowed) {\r\n            destTokenAmount = _doTrade(\r\n                sourceTokenAddress,\r\n                destTokenAddress,\r\n                sourceTokenAmount,\r\n                MAX_FOR_KYBER); // no limit on the dest amount\r\n        }\r\n        else {\r\n            revert(\"Manual trading is disabled.\");\r\n        }\r\n    }\r\n\r\n    function doTrade(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint sourceTokenAmount)\r\n        public\r\n        onlyBZx\r\n        returns (uint destTokenAmount)\r\n    {\r\n        destTokenAmount = _doTrade(\r\n            sourceTokenAddress,\r\n            destTokenAddress,\r\n            sourceTokenAmount,\r\n            MAX_FOR_KYBER); // no limit on the dest amount\r\n    }\r\n\r\n    function verifyAndLiquidate(\r\n        address loanTokenAddress,\r\n        address positionTokenAddress,\r\n        address collateralTokenAddress,\r\n        uint loanTokenAmount,\r\n        uint positionTokenAmount,\r\n        uint collateralTokenAmount,\r\n        uint maintenanceMarginAmount)\r\n        public\r\n        onlyBZx\r\n        returns (uint destTokenAmount)\r\n    {\r\n        if (!shouldLiquidate(\r\n            0x0,\r\n            0x0,\r\n            loanTokenAddress,\r\n            positionTokenAddress,\r\n            collateralTokenAddress,\r\n            loanTokenAmount,\r\n            positionTokenAmount,\r\n            collateralTokenAmount,\r\n            maintenanceMarginAmount)) {\r\n            return 0;\r\n        }\r\n        \r\n        destTokenAmount = _doTrade(\r\n            positionTokenAddress,\r\n            loanTokenAddress,\r\n            positionTokenAmount,\r\n            MAX_FOR_KYBER); // no limit on the dest amount\r\n    }\r\n\r\n    function doTradeofCollateral(\r\n        address collateralTokenAddress,\r\n        address loanTokenAddress,\r\n        uint collateralTokenAmountUsable,\r\n        uint loanTokenAmountNeeded,\r\n        uint initialMarginAmount,\r\n        uint maintenanceMarginAmount)\r\n        public\r\n        onlyBZx\r\n        returns (uint loanTokenAmountCovered, uint collateralTokenAmountUsed)\r\n    {\r\n        uint collateralTokenBalance = EIP20(collateralTokenAddress).balanceOf.gas(4999)(this); // Changes to state require at least 5000 gas\r\n        if (collateralTokenBalance < collateralTokenAmountUsable) { // sanity check\r\n            revert(\"BZxOracle::doTradeofCollateral: collateralTokenBalance < collateralTokenAmountUsable\");\r\n        }\r\n\r\n        loanTokenAmountCovered = _doTrade(\r\n            collateralTokenAddress,\r\n            loanTokenAddress,\r\n            collateralTokenAmountUsable,\r\n            loanTokenAmountNeeded);\r\n\r\n        collateralTokenAmountUsed = collateralTokenBalance.sub(EIP20(collateralTokenAddress).balanceOf.gas(4999)(this)); // Changes to state require at least 5000 gas\r\n        \r\n        if (collateralTokenAmountUsed < collateralTokenAmountUsable) {\r\n            // send unused collateral token back to the vault\r\n            if (!_transferToken(\r\n                collateralTokenAddress,\r\n                vaultContract,\r\n                collateralTokenAmountUsable.sub(collateralTokenAmountUsed))) {\r\n                revert(\"BZxOracle::doTradeofCollateral: _transferToken failed\");\r\n            }\r\n        }\r\n\r\n        if (loanTokenAmountCovered < loanTokenAmountNeeded) {\r\n            // cover losses with insurance if applicable\r\n            if ((minInitialMarginAmount == 0 || initialMarginAmount >= minInitialMarginAmount) &&\r\n                (minMaintenanceMarginAmount == 0 || maintenanceMarginAmount >= minMaintenanceMarginAmount)) {\r\n                \r\n                loanTokenAmountCovered = loanTokenAmountCovered.add(\r\n                    _doTradeWithEth(\r\n                        loanTokenAddress,\r\n                        loanTokenAmountNeeded.sub(loanTokenAmountCovered),\r\n                        vaultContract\r\n                ));\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n    * Public View functions\r\n    */\r\n\r\n    function shouldLiquidate(\r\n        bytes32 /* loanOrderHash */,\r\n        address /* trader */,\r\n        address loanTokenAddress,\r\n        address positionTokenAddress,\r\n        address collateralTokenAddress,\r\n        uint loanTokenAmount,\r\n        uint positionTokenAmount,\r\n        uint collateralTokenAmount,\r\n        uint maintenanceMarginAmount)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            getCurrentMarginAmount(\r\n                loanTokenAddress,\r\n                positionTokenAddress,\r\n                collateralTokenAddress,\r\n                loanTokenAmount,\r\n                positionTokenAmount,\r\n                collateralTokenAmount).div(maintenanceMarginAmount).div(10**16) <= (liquidationThresholdPercent)\r\n            );\r\n    } \r\n\r\n    function isTradeSupported(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint sourceTokenAmount)\r\n        public\r\n        view \r\n        returns (bool)\r\n    {\r\n        (uint rate, uint slippage) = _getExpectedRate(\r\n            sourceTokenAddress,\r\n            destTokenAddress,\r\n            sourceTokenAmount);\r\n        \r\n        if (rate > 0 && (sourceTokenAmount == 0 || slippage > 0))\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    function getTradeRate(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress)\r\n        public\r\n        view \r\n        returns (uint rate)\r\n    {\r\n        (rate,) = _getExpectedRate(\r\n            sourceTokenAddress,\r\n            destTokenAddress,\r\n            0);\r\n    }\r\n\r\n    // returns bool isProfit, uint profitOrLoss\r\n    // the position's profit/loss denominated in positionToken\r\n    function getProfitOrLoss(\r\n        address positionTokenAddress,\r\n        address loanTokenAddress,\r\n        uint positionTokenAmount,\r\n        uint loanTokenAmount)\r\n        public\r\n        view\r\n        returns (bool isProfit, uint profitOrLoss)\r\n    {\r\n        uint loanToPositionAmount;\r\n        if (positionTokenAddress == loanTokenAddress) {\r\n            loanToPositionAmount = loanTokenAmount;\r\n        } else {\r\n            (uint positionToLoanRate,) = _getExpectedRate(\r\n                positionTokenAddress,\r\n                loanTokenAddress,\r\n                0);\r\n            if (positionToLoanRate == 0) {\r\n                return;\r\n            }\r\n            loanToPositionAmount = loanTokenAmount.mul(10**18).div(positionToLoanRate);\r\n        }\r\n\r\n        if (positionTokenAmount > loanToPositionAmount) {\r\n            isProfit = true;\r\n            profitOrLoss = positionTokenAmount - loanToPositionAmount;\r\n        } else {\r\n            isProfit = false;\r\n            profitOrLoss = loanToPositionAmount - positionTokenAmount;\r\n        }\r\n    }\r\n\r\n    /// @return The current margin amount (a percentage -> i.e. 54350000000000000000 == 54.35%)\r\n    function getCurrentMarginAmount(\r\n        address loanTokenAddress,\r\n        address positionTokenAddress,\r\n        address collateralTokenAddress,\r\n        uint loanTokenAmount,\r\n        uint positionTokenAmount,\r\n        uint collateralTokenAmount)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint collateralToLoanAmount;\r\n        if (collateralTokenAddress == loanTokenAddress) {\r\n            collateralToLoanAmount = collateralTokenAmount;\r\n        } else {\r\n            (uint collateralToLoanRate,) = _getExpectedRate(\r\n                collateralTokenAddress,\r\n                loanTokenAddress,\r\n                0);\r\n            if (collateralToLoanRate == 0) {\r\n                return 0;\r\n            }\r\n            collateralToLoanAmount = collateralTokenAmount.mul(collateralToLoanRate).div(10**18);\r\n        }\r\n\r\n        uint positionToLoanAmount;\r\n        if (positionTokenAddress == loanTokenAddress) {\r\n            positionToLoanAmount = positionTokenAmount;\r\n        } else {\r\n            (uint positionToLoanRate,) = _getExpectedRate(\r\n                positionTokenAddress,\r\n                loanTokenAddress,\r\n                0);\r\n            if (positionToLoanRate == 0) {\r\n                return 0;\r\n            }\r\n            positionToLoanAmount = positionTokenAmount.mul(positionToLoanRate).div(10**18);\r\n        }\r\n\r\n        return collateralToLoanAmount.add(positionToLoanAmount).sub(loanTokenAmount).mul(10**20).div(loanTokenAmount);\r\n    }\r\n\r\n    /*\r\n    * Owner functions\r\n    */\r\n\r\n    function setInterestFeePercent(\r\n        uint newRate) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newRate != interestFeePercent && newRate >= 0 && newRate <= 100);\r\n        interestFeePercent = newRate;\r\n    }\r\n\r\n    function setLiquidationThresholdPercent(\r\n        uint newValue) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newValue != liquidationThresholdPercent && liquidationThresholdPercent >= 100);\r\n        liquidationThresholdPercent = newValue;\r\n    }\r\n\r\n    function setGasRewardPercent(\r\n        uint newValue) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newValue != gasRewardPercent);\r\n        gasRewardPercent = newValue;\r\n    }\r\n\r\n    function setBountyRewardPercent(\r\n        uint newValue) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newValue != bountyRewardPercent);\r\n        bountyRewardPercent = newValue;\r\n    }\r\n\r\n    function setMarginThresholds(\r\n        uint newInitialMargin,\r\n        uint newMaintenanceMargin) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newInitialMargin >= newMaintenanceMargin);\r\n        minInitialMarginAmount = newInitialMargin;\r\n        minMaintenanceMarginAmount = newMaintenanceMargin;\r\n    }\r\n\r\n    function setManualTradingAllowed (\r\n        bool _isManualTradingAllowed)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (isManualTradingAllowed != _isManualTradingAllowed)\r\n            isManualTradingAllowed = _isManualTradingAllowed;\r\n    }\r\n\r\n    function setVaultContractAddress(\r\n        address newAddress) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newAddress != vaultContract && newAddress != address(0));\r\n        vaultContract = newAddress;\r\n    }\r\n\r\n    function setKyberContractAddress(\r\n        address newAddress) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newAddress != kyberContract && newAddress != address(0));\r\n        kyberContract = newAddress;\r\n    }\r\n\r\n    function setWethContractAddress(\r\n        address newAddress) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newAddress != wethContract && newAddress != address(0));\r\n        wethContract = newAddress;\r\n    }\r\n\r\n    function setBZRxTokenContractAddress(\r\n        address newAddress) \r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newAddress != bZRxTokenContract && newAddress != address(0));\r\n        bZRxTokenContract = newAddress;\r\n    }\r\n\r\n    function setEMAPeriods (\r\n        uint _newEMAPeriods)\r\n        public\r\n        onlyOwner {\r\n        require(_newEMAPeriods > 1 && _newEMAPeriods != emaPeriods);\r\n        emaPeriods = _newEMAPeriods;\r\n    }\r\n\r\n    function transferEther(\r\n        address to,\r\n        uint value)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        uint amount = value;\r\n        if (amount > address(this).balance) {\r\n            amount = address(this).balance;\r\n        }\r\n\r\n        return (to.send(amount));\r\n    }\r\n\r\n    function transferToken(\r\n        address tokenAddress,\r\n        address to,\r\n        uint value)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        return (_transferToken(\r\n            tokenAddress,\r\n            to,\r\n            value\r\n        ));\r\n    }\r\n\r\n    /*\r\n    * Internal functions\r\n    */\r\n\r\n    // ref: https://github.com/KyberNetwork/smart-contracts/blob/master/integration.md#rate-query\r\n    function _getExpectedRate(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint sourceTokenAmount)\r\n        internal\r\n        view \r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        if (sourceTokenAddress == destTokenAddress) {\r\n            expectedRate = 10**18;\r\n            slippageRate = 0;\r\n        } else {\r\n            if (sourceTokenAddress == wethContract) {\r\n                (expectedRate, slippageRate) = KyberNetwork_Interface(kyberContract).getExpectedRate(\r\n                    KYBER_ETH_TOKEN_ADDRESS,\r\n                    destTokenAddress, \r\n                    sourceTokenAmount\r\n                );\r\n            } else if (destTokenAddress == wethContract) {\r\n                (expectedRate, slippageRate) = KyberNetwork_Interface(kyberContract).getExpectedRate(\r\n                    sourceTokenAddress,\r\n                    KYBER_ETH_TOKEN_ADDRESS,\r\n                    sourceTokenAmount\r\n                );\r\n            } else {\r\n                (uint sourceToEther, uint sourceToEtherSlippage) = KyberNetwork_Interface(kyberContract).getExpectedRate(\r\n                    sourceTokenAddress,\r\n                    KYBER_ETH_TOKEN_ADDRESS,\r\n                    sourceTokenAmount\r\n                );\r\n                if (sourceTokenAmount > 0) {\r\n                    sourceTokenAmount = sourceTokenAmount.mul(sourceToEther).div(10**18);\r\n                }\r\n\r\n                (uint etherToDest, uint etherToDestSlippage) = KyberNetwork_Interface(kyberContract).getExpectedRate(\r\n                    KYBER_ETH_TOKEN_ADDRESS,\r\n                    destTokenAddress,\r\n                    sourceTokenAmount\r\n                );\r\n\r\n                expectedRate = sourceToEther.mul(etherToDest).div(10**18);\r\n                slippageRate = sourceToEtherSlippage.mul(etherToDestSlippage).div(10**18);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doTrade(\r\n        address sourceTokenAddress,\r\n        address destTokenAddress,\r\n        uint sourceTokenAmount,\r\n        uint maxDestTokenAmount)\r\n        internal\r\n        returns (uint destTokenAmount)\r\n    {\r\n        if (sourceTokenAddress == destTokenAddress) {\r\n            if (maxDestTokenAmount < MAX_FOR_KYBER) {\r\n                destTokenAmount = maxDestTokenAmount;\r\n            } else {\r\n                destTokenAmount = sourceTokenAmount;\r\n            }\r\n        } else {\r\n            if (sourceTokenAddress == wethContract) {\r\n                WETH_Interface(wethContract).withdraw(sourceTokenAmount);\r\n\r\n                destTokenAmount = KyberNetwork_Interface(kyberContract).trade\r\n                    .value(sourceTokenAmount)( // send Ether along \r\n                    KYBER_ETH_TOKEN_ADDRESS,\r\n                    sourceTokenAmount,\r\n                    destTokenAddress,\r\n                    vaultContract, // bZxVault recieves the destToken\r\n                    maxDestTokenAmount,\r\n                    0, // no min coversation rate\r\n                    address(0)\r\n                );\r\n            } else if (destTokenAddress == wethContract) {\r\n                // re-up the Kyber spend approval if needed\r\n                if (EIP20(sourceTokenAddress).allowance.gas(4999)(this, kyberContract) < \r\n                    MAX_FOR_KYBER) {\r\n                    \r\n                    eip20Approve(\r\n                        sourceTokenAddress,\r\n                        kyberContract,\r\n                        MAX_FOR_KYBER);\r\n                }\r\n\r\n                destTokenAmount = KyberNetwork_Interface(kyberContract).trade(\r\n                    sourceTokenAddress,\r\n                    sourceTokenAmount,\r\n                    KYBER_ETH_TOKEN_ADDRESS,\r\n                    this, // BZxOracle receives the Ether proceeds\r\n                    maxDestTokenAmount,\r\n                    0, // no min coversation rate\r\n                    address(0)\r\n                );\r\n\r\n                WETH_Interface(wethContract).deposit.value(destTokenAmount)();\r\n\r\n                if (!_transferToken(\r\n                    destTokenAddress,\r\n                    vaultContract,\r\n                    destTokenAmount)) {\r\n                    revert(\"BZxOracle::_doTrade: _transferToken failed\");\r\n                }\r\n            } else {\r\n                // re-up the Kyber spend approval if needed\r\n                if (EIP20(sourceTokenAddress).allowance.gas(4999)(this, kyberContract) < \r\n                    MAX_FOR_KYBER) {\r\n                    \r\n                    eip20Approve(\r\n                        sourceTokenAddress,\r\n                        kyberContract,\r\n                        MAX_FOR_KYBER);\r\n                }\r\n                \r\n                uint maxDestEtherAmount = maxDestTokenAmount;\r\n                if (maxDestTokenAmount < MAX_FOR_KYBER) {\r\n                    uint etherToDest;\r\n                    (etherToDest,) = KyberNetwork_Interface(kyberContract).getExpectedRate(\r\n                        KYBER_ETH_TOKEN_ADDRESS,\r\n                        destTokenAddress, \r\n                        0\r\n                    );\r\n                    maxDestEtherAmount = maxDestTokenAmount.mul(10**18).div(etherToDest);\r\n                }\r\n\r\n                uint destEtherAmount = KyberNetwork_Interface(kyberContract).trade(\r\n                    sourceTokenAddress,\r\n                    sourceTokenAmount,\r\n                    KYBER_ETH_TOKEN_ADDRESS,\r\n                    this, // BZxOracle receives the Ether proceeds\r\n                    maxDestEtherAmount,\r\n                    0, // no min coversation rate\r\n                    address(0)\r\n                );\r\n\r\n                destTokenAmount = KyberNetwork_Interface(kyberContract).trade\r\n                    .value(destEtherAmount)( // send Ether along \r\n                    KYBER_ETH_TOKEN_ADDRESS,\r\n                    destEtherAmount,\r\n                    destTokenAddress,\r\n                    vaultContract, // bZxVault recieves the destToken\r\n                    maxDestTokenAmount,\r\n                    0, // no min coversation rate\r\n                    address(0)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doTradeForEth(\r\n        address sourceTokenAddress,\r\n        uint sourceTokenAmount,\r\n        address receiver)\r\n        internal\r\n        returns (uint)\r\n    {\r\n        // re-up the Kyber spend approval if needed\r\n        if (EIP20(sourceTokenAddress).allowance.gas(4999)(this, kyberContract) < \r\n            MAX_FOR_KYBER) {\r\n\r\n            eip20Approve(\r\n                sourceTokenAddress,\r\n                kyberContract,\r\n                MAX_FOR_KYBER);\r\n        }\r\n        \r\n        // bytes4(keccak256(\"trade(address,uint256,address,address,uint256,uint256,address)\")) = 0xcb3c28c7\r\n        bool result = kyberContract.call\r\n            .gas(gasleft())(\r\n            0xcb3c28c7,\r\n            sourceTokenAddress,\r\n            sourceTokenAmount,\r\n            KYBER_ETH_TOKEN_ADDRESS,\r\n            receiver,\r\n            MAX_FOR_KYBER, // no limit on the dest amount\r\n            0, // no min coversation rate\r\n            address(0)\r\n        );\r\n\r\n        assembly {\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            switch result\r\n            case 0 { return(0, 0x20) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n\r\n    function _doTradeWithEth(\r\n        address destTokenAddress,\r\n        uint destTokenAmountNeeded,\r\n        address receiver)\r\n        internal\r\n        returns (uint)\r\n    {\r\n        uint etherToDest;\r\n        (etherToDest,) = KyberNetwork_Interface(kyberContract).getExpectedRate(\r\n            KYBER_ETH_TOKEN_ADDRESS,\r\n            destTokenAddress, \r\n            0\r\n        );\r\n\r\n        // calculate amount of ETH to use with a 5% buffer (unused ETH is returned by Kyber)\r\n        uint ethToSend = destTokenAmountNeeded.mul(10**18).div(etherToDest).mul(105).div(100);\r\n        if (ethToSend > address(this).balance) {\r\n            ethToSend = address(this).balance;\r\n        }\r\n\r\n        // bytes4(keccak256(\"trade(address,uint256,address,address,uint256,uint256,address)\")) = 0xcb3c28c7\r\n        bool result = kyberContract.call\r\n            .gas(gasleft())\r\n            .value(ethToSend)( // send Ether along \r\n            0xcb3c28c7,\r\n            KYBER_ETH_TOKEN_ADDRESS,\r\n            ethToSend,\r\n            destTokenAddress,\r\n            receiver,\r\n            destTokenAmountNeeded,\r\n            0, // no min coversation rate\r\n            address(0)\r\n        );\r\n\r\n        assembly {\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            switch result\r\n            case 0 { return(0, 0x20) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n\r\n    function _transferToken(\r\n        address tokenAddress,\r\n        address to,\r\n        uint value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        eip20Transfer(\r\n            tokenAddress,\r\n            to,\r\n            value);\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"loanTokenAddress\",\"type\":\"address\"},{\"name\":\"positionTokenAddress\",\"type\":\"address\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"loanTokenAmount\",\"type\":\"uint256\"},{\"name\":\"positionTokenAmount\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAmount\",\"type\":\"uint256\"}],\"name\":\"getCurrentMarginAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setLiquidationThresholdPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"didWithdrawProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vaultContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInitialMarginAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kyberContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"loanTokenAddress\",\"type\":\"address\"},{\"name\":\"collateralTokenAmountUsable\",\"type\":\"uint256\"},{\"name\":\"loanTokenAmountNeeded\",\"type\":\"uint256\"},{\"name\":\"initialMarginAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"}],\"name\":\"doTradeofCollateral\",\"outputs\":[{\"name\":\"loanTokenAmountCovered\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAmountUsed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emaPeriods\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationThresholdPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"didTradePosition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"name\":\"didTakeOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setBZRxTokenContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"loanOrderHash\",\"type\":\"bytes32\"},{\"name\":\"loanCloser\",\"type\":\"address\"},{\"name\":\"isLiquidation\",\"type\":\"bool\"},{\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"name\":\"didCloseLoan\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wethContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasRewardPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"positionTokenAddress\",\"type\":\"address\"},{\"name\":\"loanTokenAddress\",\"type\":\"address\"},{\"name\":\"positionTokenAmount\",\"type\":\"uint256\"},{\"name\":\"loanTokenAmount\",\"type\":\"uint256\"}],\"name\":\"getProfitOrLoss\",\"outputs\":[{\"name\":\"isProfit\",\"type\":\"bool\"},{\"name\":\"profitOrLoss\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gasRefunds\",\"outputs\":[{\"name\":\"payer\",\"type\":\"address\"},{\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"name\":\"isPaid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sourceTokenAddress\",\"type\":\"address\"},{\"name\":\"destTokenAddress\",\"type\":\"address\"},{\"name\":\"sourceTokenAmount\",\"type\":\"uint256\"}],\"name\":\"isTradeSupported\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isManualTradingAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyRewardPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBZxContractAddress\",\"type\":\"address\"}],\"name\":\"transferBZxOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"throwOnGasRefundFail\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sourceTokenAddress\",\"type\":\"address\"},{\"name\":\"destTokenAddress\",\"type\":\"address\"}],\"name\":\"getTradeRate\",\"outputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"didDepositCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZRxTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sourceTokenAddress\",\"type\":\"address\"},{\"name\":\"destTokenAddress\",\"type\":\"address\"},{\"name\":\"sourceTokenAmount\",\"type\":\"uint256\"}],\"name\":\"doManualTrade\",\"outputs\":[{\"name\":\"destTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"interestTokenAddress\",\"type\":\"address\"},{\"name\":\"amountOwed\",\"type\":\"uint256\"},{\"name\":\"convert\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"didPayInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newInitialMargin\",\"type\":\"uint256\"},{\"name\":\"newMaintenanceMargin\",\"type\":\"uint256\"}],\"name\":\"setMarginThresholds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setVaultContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setInterestFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setGasRewardPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emaValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"loanTokenAddress\",\"type\":\"address\"},{\"name\":\"positionTokenAddress\",\"type\":\"address\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"loanTokenAmount\",\"type\":\"uint256\"},{\"name\":\"positionTokenAmount\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"}],\"name\":\"verifyAndLiquidate\",\"outputs\":[{\"name\":\"destTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minMaintenanceMarginAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setBountyRewardPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"loanTokenAddress\",\"type\":\"address\"},{\"name\":\"positionTokenAddress\",\"type\":\"address\"},{\"name\":\"collateralTokenAddress\",\"type\":\"address\"},{\"name\":\"loanTokenAmount\",\"type\":\"uint256\"},{\"name\":\"positionTokenAmount\",\"type\":\"uint256\"},{\"name\":\"collateralTokenAmount\",\"type\":\"uint256\"},{\"name\":\"maintenanceMarginAmount\",\"type\":\"uint256\"}],\"name\":\"shouldLiquidate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"didChangeCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isManualTradingAllowed\",\"type\":\"bool\"}],\"name\":\"setManualTradingAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sourceTokenAddress\",\"type\":\"address\"},{\"name\":\"destTokenAddress\",\"type\":\"address\"},{\"name\":\"sourceTokenAmount\",\"type\":\"uint256\"}],\"name\":\"doTrade\",\"outputs\":[{\"name\":\"destTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEMAPeriods\",\"type\":\"uint256\"}],\"name\":\"setEMAPeriods\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setKyberContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bZxContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setWethContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"didWithdrawCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"interestFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_vaultContract\",\"type\":\"address\"},{\"name\":\"_kyberContract\",\"type\":\"address\"},{\"name\":\"_wethContract\",\"type\":\"address\"},{\"name\":\"_bZRxTokenContract\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousBZxContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newBZxContract\",\"type\":\"address\"}],\"name\":\"BZxOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refundSuccess\",\"type\":\"bool\"}],\"name\":\"GasRefund\",\"type\":\"event\"}]","ContractName":"BZxOracle","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009ecea0edc56f307cc343b2c8e3acb454d1faffda000000000000000000000000818e6fecd516ecc3849daf6845e3ec868087b755000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000013939ac9f1e0f99872fa873b6e00de9248ac95a0","Library":"","SwarmSource":"bzzr://cff556e80be57453c6f33955f8fa76d184259aa96c7e452f2fd0ad1bdd16e908"}]}