{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  using SafeMath for uint256;\r\n  mapping(address => uint256) balances; \r\n\r\n \r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is ERC20, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n  bool public mintingFinished = false;\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner public returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropiate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // How many token units a buyer gets per wei\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per wei\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n  function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(\r\n      msg.sender,\r\n      _beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(_beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n    token.transfer(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n    _deliverTokens(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n    return _weiAmount.mul(rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title MintedCrowdsale\r\n * @dev Extension of Crowdsale contract whose tokens are minted in each purchase.\r\n * Token ownership should be transferred to MintedCrowdsale for minting. \r\n */\r\ncontract MintedCrowdsale is Crowdsale {\r\n\r\n  /**\r\n   * @dev Overrides delivery by minting tokens upon purchase.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _tokenAmount Number of tokens to be minted\r\n   */\r\n  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n    require(MintableToken(token).mint(_beneficiary, _tokenAmount));\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title EscrowAccountCrowdsale.\r\n */\r\ncontract EscrowAccountCrowdsale is TimedCrowdsale, Ownable {\r\n  using SafeMath for uint256;\r\n  EscrowVault public vault;\r\n  /**\r\n   * @dev Constructor, creates EscrowAccountCrowdsale.\r\n   */\r\n   function EscrowAccountCrowdsale() public {\r\n    vault = new EscrowVault(wallet);\r\n  }\r\n  /**\r\n   * @dev Investors can claim refunds here if whitelisted is unsuccessful\r\n   */\r\n  function returnInvestoramount(address _beneficiary, uint256 _percentage) internal onlyOwner {\r\n    vault.refund(_beneficiary,_percentage);\r\n  }\r\n\r\n  function afterWhtelisted(address _beneficiary) internal onlyOwner{\r\n      vault.closeAfterWhitelisted(_beneficiary);\r\n  }\r\n  /**\r\n   * @dev Overrides Crowdsale fund forwarding, sending funds to vault.\r\n   */\r\n  function _forwardFunds() internal {\r\n    vault.deposit.value(msg.value)(msg.sender);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title EscrowVault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if whitelist fails,\r\n * and forwarding it if whitelist is successful.\r\n */\r\ncontract EscrowVault is Ownable {\r\n  using SafeMath for uint256;\r\n  mapping (address => uint256) public deposited;\r\n  address public wallet;\r\n  event Closed();\r\n  event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n  /**\r\n   * @param _wallet Vault address\r\n   */\r\n  function EscrowVault(address _wallet) public {\r\n    require(_wallet != address(0));\r\n    wallet = _wallet;\r\n   \r\n  }\r\n  /**\r\n   * @param investor Investor address\r\n   */\r\n  function deposit(address investor) onlyOwner  payable {\r\n    deposited[investor] = deposited[investor].add(msg.value);\r\n  }\r\n   function closeAfterWhitelisted(address _beneficiary) onlyOwner public {\r\n   \r\n    uint256 depositedValue = deposited[_beneficiary];\r\n    deposited[_beneficiary] = 0;\r\n    wallet.transfer(depositedValue);\r\n  }\r\n   \r\n\r\n  /**\r\n   * @param investor Investor address\r\n   */\r\n  function refund(address investor, uint256 _percentage)onlyOwner  {\r\n    uint256 depositedValue = deposited[investor];\r\n    depositedValue=depositedValue.sub(_percentage);\r\n   \r\n    investor.transfer(depositedValue);\r\n    wallet.transfer(_percentage);\r\n    emit Refunded(investor, depositedValue);\r\n     deposited[investor] = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * @title PostDeliveryCrowdsale\r\n * @dev Crowdsale that locks tokens from withdrawal until it whitelisted and crowdsale ends.\r\n */\r\ncontract PostDeliveryCrowdsale is TimedCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public balances;\r\n\r\n  /**\r\n   * @dev Withdraw tokens only after whitelisted ends and after crowdsale ends.\r\n   */\r\n   \r\n  \r\n  function withdrawTokens() public {\r\n   require(hasClosed());\r\n    uint256 amount = balances[msg.sender];\r\n    require(amount > 0);\r\n    balances[msg.sender] = 0;\r\n    _deliverTokens(msg.sender, amount);\r\n  }\r\n  \r\n  \r\n   function failedWhitelist(address _beneficiary) internal  {\r\n    require(_beneficiary != address(0));\r\n    uint256 amount = balances[_beneficiary];\r\n    balances[_beneficiary] = 0;\r\n  }\r\n  function getInvestorDepositAmount(address _investor) public constant returns(uint256 paid){\r\n     \r\n     return balances[_investor];\r\n }\r\n\r\n  /**\r\n   * @dev Overrides parent by storing balances instead of issuing tokens right away.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _tokenAmount Amount of tokens purchased\r\n   */\r\n  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract CryptoAssetCrowdsale is TimedCrowdsale, MintedCrowdsale,EscrowAccountCrowdsale,PostDeliveryCrowdsale {\r\n\r\n enum Stage {PROCESS1_FAILED, PROCESS1_SUCCESS,PROCESS2_FAILED, PROCESS2_SUCCESS,PROCESS3_FAILED, PROCESS3_SUCCESS} \t\r\n \t//stage Phase1 or Phase2 or Phase\r\n\tenum Phase {PHASE1, PHASE2,PHASE3}\r\n\t//stage ICO\r\n\tPhase public phase;\r\n \r\n  struct whitelisted{\r\n       Stage  stage;\r\n }\r\n  uint256 public adminCharge_p1=0.010 ether;\r\n  uint256 public adminCharge_p2=0.13 ether;\r\n  uint256 public adminCharge_p3=0.14 ether;\r\n  uint256 public cap=750 ether;// softcap is 750 ether\r\n  uint256 public goal=4500 ether;// hardcap is 4500 ether\r\n  uint256 public minContribAmount = 0.1 ether; // min invesment\r\n  mapping(address => whitelisted) public whitelist;\r\n  // How much ETH each address has invested to this crowdsale\r\n  mapping (address => uint256) public investedAmountOf;\r\n    // How many distinct addresses have invested\r\n  uint256 public investorCount;\r\n    // decimalFactor\r\n  uint256 public constant DECIMALFACTOR = 10**uint256(18);\r\n  event updateRate(uint256 tokenRate, uint256 time);\r\n  \r\n   /**\r\n \t* @dev CryptoAssetCrowdsale is a base contract for managing a token crowdsale.\r\n \t* CryptoAssetCrowdsale have a start and end timestamps, where investors can make\r\n \t* token purchases and the crowdsale will assign them tokens based\r\n \t* on a token per ETH rate. Funds collected are forwarded to a wallet\r\n \t* as they arrive.\r\n \t*/\r\n  \r\n function CryptoAssetCrowdsale(uint256 _starttime, uint256 _endTime, uint256 _rate, address _wallet,ERC20 _token)\r\n  TimedCrowdsale(_starttime,_endTime)Crowdsale(_rate, _wallet,_token)\r\n  {\r\n      phase = Phase.PHASE1;\r\n  }\r\n    \r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n  \r\n  function buyTokens(address _beneficiary) public payable onlyWhileOpen{\r\n    require(_beneficiary != address(0));\r\n    require(validPurchase());\r\n  \r\n    uint256 weiAmount = msg.value;\r\n    // calculate token amount to be created\r\n    uint256 tokens = weiAmount.mul(rate);\r\n    uint256 volumebasedBonus=0;\r\n    if(phase == Phase.PHASE1){\r\n    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase1(tokens)).div(100);\r\n\r\n    }else if(phase == Phase.PHASE2){\r\n    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase2(tokens)).div(100);\r\n\r\n    }else{\r\n    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase3(tokens)).div(100);\r\n\r\n    }\r\n\r\n    tokens=tokens.add(volumebasedBonus);\r\n    _preValidatePurchase( _beneficiary,  weiAmount);\r\n    weiRaised = weiRaised.add(weiAmount);\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n    _forwardFunds();\r\n    if(investedAmountOf[msg.sender] == 0) {\r\n           // A new investor\r\n           investorCount++;\r\n        }\r\n        // Update investor\r\n        investedAmountOf[msg.sender] = investedAmountOf[msg.sender].add(weiAmount);\r\n  }\r\n    function tokensaleToOtherCoinUser(address beneficiary, uint256 weiAmount) public onlyOwner onlyWhileOpen {\r\n    require(beneficiary != address(0) && weiAmount > 0);\r\n    uint256 tokens = weiAmount.mul(rate);\r\n    uint256 volumebasedBonus=0;\r\n    if(phase == Phase.PHASE1){\r\n    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase1(tokens)).div(100);\r\n\r\n    }else if(phase == Phase.PHASE2){\r\n    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase2(tokens)).div(100);\r\n\r\n    }else{\r\n    volumebasedBonus = tokens.mul(getTokenVolumebasedBonusRateForPhase3(tokens)).div(100);\r\n\r\n    }\r\n\r\n    tokens=tokens.add(volumebasedBonus);\r\n    weiRaised = weiRaised.add(weiAmount);\r\n    _processPurchase(beneficiary, tokens);\r\n    emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\r\n    }\r\n    \r\n    function validPurchase() internal constant returns (bool) {\r\n    bool minContribution = minContribAmount <= msg.value;\r\n    return  minContribution;\r\n  }\r\n  \r\n  \r\n  function getTokenVolumebasedBonusRateForPhase1(uint256 value) internal constant returns (uint256) {\r\n        uint256 bonusRate = 0;\r\n        uint256 valume = value.div(DECIMALFACTOR);\r\n\r\n        if (valume <= 50000 && valume >= 149999) {\r\n            bonusRate = 30;\r\n        } else if (valume <= 150000 && valume >= 299999) {\r\n            bonusRate = 35;\r\n        } else if (valume <= 300000 && valume >= 500000) {\r\n            bonusRate = 40;\r\n        } else{\r\n            bonusRate = 25;\r\n        }\r\n\r\n        return bonusRate;\r\n    }\r\n  \r\n   function getTokenVolumebasedBonusRateForPhase2(uint256 value) internal constant returns (uint256) {\r\n        uint256 bonusRate = 0;\r\n        uint valume = value.div(DECIMALFACTOR);\r\n\r\n        if (valume <= 50000 && valume >= 149999) {\r\n            bonusRate = 25;\r\n        } else if (valume <= 150000 && valume >= 299999) {\r\n            bonusRate = 30;\r\n        } else if (valume <= 300000 && valume >= 500000) {\r\n            bonusRate = 35;\r\n        } else{\r\n            bonusRate = 20;\r\n        }\r\n\r\n        return bonusRate;\r\n    }\r\n    \r\n     function getTokenVolumebasedBonusRateForPhase3(uint256 value) internal constant returns (uint256) {\r\n        uint256 bonusRate = 0;\r\n        uint valume = value.div(DECIMALFACTOR);\r\n\r\n        if (valume <= 50000 && valume >= 149999) {\r\n            bonusRate = 20;\r\n        } else if (valume <= 150000 && valume >= 299999) {\r\n            bonusRate = 25;\r\n        } else if (valume <= 300000 && valume >= 500000) {\r\n            bonusRate = 30;\r\n        } else{\r\n            bonusRate = 15;\r\n        }\r\n\r\n        return bonusRate;\r\n    }\r\n  \r\n  /**\r\n \t* @dev change the Phase from phase1 to phase2 \r\n \t*/\r\n  \tfunction startPhase2(uint256 _startTime) public onlyOwner {\r\n      \trequire(_startTime>0);\r\n      \tphase = Phase.PHASE2;\r\n      \topeningTime=_startTime;\r\n      \r\n   }\r\n   \r\n     /**\r\n \t* @dev change the Phase from phase2 to phase3 sale\r\n \t*/\r\n  \tfunction startPhase3(uint256 _startTime) public onlyOwner {\r\n      \trequire(0> _startTime);\r\n      \tphase = Phase.PHASE3;\r\n        openingTime=_startTime;\r\n\r\n   }\r\n\r\n /**\r\n   * @dev Reverts if beneficiary is not whitelisted. Can be used when extending this contract.\r\n   */\r\n  modifier isWhitelisted(address _beneficiary) {\r\n    require(whitelist[_beneficiary].stage==Stage.PROCESS3_SUCCESS);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds single address to whitelist.\r\n   * @param _beneficiary Address to be added to the whitelist\r\n   */\r\n  function addToWhitelist(address _beneficiary,uint256 _stage) external onlyOwner {\r\n      require(_beneficiary != address(0));\r\n      require(_stage>0);  \r\n if(_stage==1){\r\n     whitelist[_beneficiary].stage=Stage.PROCESS1_FAILED;\r\n     returnInvestoramount(_beneficiary,adminCharge_p1);\r\n     failedWhitelist(_beneficiary);\r\n     investedAmountOf[_beneficiary]=0;\r\n }else if(_stage==2){\r\n     whitelist[_beneficiary].stage=Stage.PROCESS1_SUCCESS;\r\n }else if(_stage==3){\r\n     whitelist[_beneficiary].stage=Stage.PROCESS2_FAILED;\r\n     returnInvestoramount(_beneficiary,adminCharge_p2);\r\n     failedWhitelist(_beneficiary);\r\n          investedAmountOf[_beneficiary]=0;\r\n }else if(_stage==4){\r\n     whitelist[_beneficiary].stage=Stage.PROCESS2_SUCCESS;\r\n }else if(_stage==5){\r\n     whitelist[_beneficiary].stage=Stage.PROCESS3_FAILED;\r\n     returnInvestoramount(_beneficiary,adminCharge_p3);\r\n     failedWhitelist(_beneficiary);\r\n          investedAmountOf[_beneficiary]=0;\r\n     }else if(_stage==6){\r\n     whitelist[_beneficiary].stage=Stage.PROCESS3_SUCCESS;\r\n     afterWhtelisted( _beneficiary);\r\n }\r\n \r\n }\r\n \r\n  /**\r\n   * @dev Withdraw tokens only after Investors added into whitelist .\r\n   */\r\n  function withdrawTokens() public isWhitelisted(msg.sender)  {\r\n    require(hasClosed());\r\n    uint256 amount = balances[msg.sender];\r\n    require(amount > 0);\r\n    balances[msg.sender] = 0;\r\n    _deliverTokens(msg.sender, amount);\r\n   \r\n  }\r\n  \r\n /**\r\n * @dev Change crowdsale ClosingTime\r\n * @param  _endTime is End time in Seconds\r\n */\r\n  function changeEndtime(uint256 _endTime) public onlyOwner {\r\n    require(_endTime > 0); \r\n    closingTime = _endTime;\r\n    }\r\n\r\n /**\r\n * @dev Change Token rate per ETH\r\n * @param  _rate is set the current rate of AND Token\r\n */\r\n  function changeRate(uint256 _rate) public onlyOwner {\r\n    require(_rate > 0); \r\n    rate = _rate;\r\n    emit updateRate(_rate,block.timestamp);\r\n    }\r\n  /**\r\n * @dev Change admin chargers\r\n * @param  _p1 for first Kyc Failed-$5\r\n * @param  _p2 for second AML Failed-$7\r\n * @param  _p3 for third AI Failed-$57\r\n */\r\n  function changeAdminCharges(uint256 _p1,uint256 _p2,uint256 _p3) public onlyOwner {\r\n    require(_p1 > 0);\r\n    require(_p2 > 0); \r\n    require(_p3 > 0); \r\n    adminCharge_p1=_p1;\r\n    adminCharge_p2=_p2;\r\n    adminCharge_p3=_p3;\r\n    \r\n    }\r\n    \r\n /**\r\n   * @dev Change minContribution amountAmount.\r\n   * @param _minInvestment for minimum contribution ETH amount\r\n   */\r\n  function changeMinInvestment(uint256 _minInvestment) public onlyOwner {\r\n     require(_minInvestment > 0);\r\n     minContribAmount=_minInvestment;\r\n  }\r\n  /**\r\n   * @dev Checks whether the cap has been reached.\r\n   * @return Whether the cap was reached\r\n   */\r\n  function capReached() public view returns (bool) {\r\n    return weiRaised >= cap;\r\n  }\r\n  /**\r\n   * @dev Checks whether the goal has been reached.\r\n   * @return Whether the goal was reached\r\n   */\r\n  function goalReached() public view returns (bool) {\r\n    return weiRaised >= goal;\r\n  }\r\n  \r\n  \t/**\r\n \t* @param _to is beneficiary address\r\n \t* @param _value  Amount if tokens\r\n \t* @dev  tokens distribution\r\n \t*/\r\n\tfunction tokenDistribution(address _to, uint256 _value)public onlyOwner {\r\n        require (\r\n           _to != 0x0 && _value > 0);\r\n        _processPurchase(_to, _value);\r\n        whitelist[_to].stage=Stage.PROCESS3_SUCCESS;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"adminCharge_p2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minInvestment\",\"type\":\"uint256\"}],\"name\":\"changeMinInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_stage\",\"type\":\"uint256\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"startPhase3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminCharge_p3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContribAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminCharge_p1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"changeEndtime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"changeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"stage\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_p1\",\"type\":\"uint256\"},{\"name\":\"_p2\",\"type\":\"uint256\"},{\"name\":\"_p3\",\"type\":\"uint256\"}],\"name\":\"changeAdminCharges\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getInvestorDepositAmount\",\"outputs\":[{\"name\":\"paid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALFACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"startPhase2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"tokensaleToOtherCoinUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"tokenDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_starttime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"updateRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"CryptoAssetCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005b1ca27c000000000000000000000000000000000000000000000000000000005bda7a040000000000000000000000000000000000000000000000000000000000000b78000000000000000000000000580e254ca2cb1627d95ae71d3d27c593b9526247000000000000000000000000ee4e77b6e782557653d00d1cbe9135d4cf117393","Library":"","SwarmSource":"bzzr://4c25f79c8f4fb9b4b923caa70720cc4a32766e3f3e2d4362f4ba885cae5a558c"}]}