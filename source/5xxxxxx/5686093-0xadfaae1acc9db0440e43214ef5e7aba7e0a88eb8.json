{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n/*\r\n\r\nAuthor : RNDM (Discord RNDM#3033)\r\nWrite me if you need coding service\r\nMy Ethereum address : 0x13373FEdb7f8dF156E5718303897Fae2d363Cc96\r\n\r\nDescription tl;dr :\r\nSimple trustless lottery with entries\r\nAfter the contract reaches a certain amount of ethereum or when the owner calls \"payWinnerManually()\"\r\na winner gets calculated/drawed and paid out (100%, no Dev or Owner fee).\r\n\r\n*/\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\ncontract Lottery is Ownable {\r\n\r\n    // The tokens can never be stolen\r\n    modifier secCheck(address aContract) {\r\n        require(aContract != address(contractCall));\r\n        _;\r\n    }\r\n\r\n    // When this is active no one is able to participate\r\n    modifier restriction() {\r\n        require(!_restriction);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * Events\r\n    */\r\n\r\n    event BoughtTicket(uint256 amount, address customer, uint yourEntry);\r\n    event WinnerPaid(uint256 amount, address winner);\r\n\r\n\r\n    /**\r\n    * Data\r\n    */\r\n\r\n    _Contract contractCall;  // a reference to the contract\r\n    address[] public entries; // array with entries\r\n    uint256 entryCounter; // counter for the entries\r\n    uint256 public automaticThreshold; // automatic Threshold to close the lottery and pay the winner\r\n    uint256 public ticketPrice = 10 finney; // the price per lottery ticket (0.01 eth)\r\n    bool public _restriction; // check restriction modifier\r\n    \r\n\r\n\r\n\r\n\r\n    constructor() public {\r\n        contractCall = _Contract(0x05215FCE25902366480696F38C3093e31DBCE69A);\r\n        _restriction = true;\r\n        automaticThreshold = 100; // 100 tickets\r\n        ticketPrice = 10 finney; // 10 finney = 0.01 eth\r\n        entryCounter = 0;\r\n    }\r\n\r\n    // If you send money directly to the contract its like a donation\r\n    function() payable public {\r\n    }\r\n\r\n\r\n    function buyTickets() restriction() payable public {\r\n        //You have to send at least ticketPrice to get one entry\r\n        require(msg.value >= ticketPrice);\r\n\r\n        address customerAddress = msg.sender;\r\n        //Use deposit to purchase _Contract tokens\r\n        contractCall.buy.value(msg.value)(customerAddress);\r\n        // add customer to the entry list\r\n        if (entryCounter == (entries.length)) {\r\n            entries.push(customerAddress);\r\n            }\r\n        else {\r\n            entries[entryCounter] = customerAddress;\r\n        }\r\n        // increment the entry counter\r\n        entryCounter++;\r\n        //fire event\r\n        emit BoughtTicket(msg.value, msg.sender, entryCounter);\r\n\r\n         //Automatic Treshhold, checks if the always incremented entryCounter reached the threshold\r\n        if(entryCounter >= automaticThreshold) {\r\n            // withdraw + sell all tokens.\r\n            contractCall.exit();\r\n\r\n            //payout winner & start from beginning\r\n            payWinner();\r\n        }\r\n    }\r\n\r\n    // Other functions\r\n    function PRNG() internal view returns (uint256) {\r\n        uint256 initialize1 = block.timestamp;\r\n        uint256 initialize2 = uint256(block.coinbase);\r\n        uint256 initialize3 = uint256(blockhash(entryCounter));\r\n        uint256 initialize4 = block.number;\r\n        uint256 initialize5 = block.gaslimit;\r\n        uint256 initialize6 = block.difficulty;\r\n\r\n        uint256 calc1 = uint256(keccak256(abi.encodePacked((initialize1 * 5),initialize5,initialize6)));\r\n        uint256 calc2 = 1-calc1;\r\n        int256 ov = int8(calc2);\r\n        uint256 calc3 = uint256(sha256(abi.encodePacked(initialize1,ov,initialize3,initialize4)));\r\n        uint256 PRN = uint256(keccak256(abi.encodePacked(initialize1,calc1,initialize2,initialize3,calc3)))%(entryCounter);\r\n        return PRN;\r\n    }\r\n    \r\n\r\n    // Choose a winner and pay him\r\n    function payWinner() internal returns (address) {\r\n        uint256 balance = address(this).balance;\r\n        uint256 number = PRNG(); // generates a pseudorandom number\r\n        address winner = entries[number]; // choose the winner with the pseudorandom number\r\n        winner.transfer(balance); // payout winner\r\n        entryCounter = 0; // Zero entries again => Lottery resetted\r\n\r\n        emit WinnerPaid(balance, winner);\r\n        return winner;\r\n    }\r\n\r\n    /*\r\n        If you plan to use this contract for your projects\r\n        be a man of honor and do not change or delete this function\r\n    */\r\n    function donateToDev() payable public {\r\n        address developer = 0x13373FEdb7f8dF156E5718303897Fae2d363Cc96;\r\n        developer.transfer(msg.value);\r\n    }\r\n\r\n    //Number of tokens currently in the Lottery pool\r\n    function myTokens() public view returns(uint256) {\r\n        return contractCall.myTokens();\r\n    }\r\n\r\n    //Amount of dividends currently in the Lottery pool\r\n    function myDividends() public view returns(uint256) {\r\n        return contractCall.myDividends(true);\r\n    }\r\n\r\n\r\n    /**\r\n    * Administrator functions\r\n    */\r\n\r\n    //Disable the buy restriction\r\n    function disableRestriction() onlyOwner() public {\r\n        _restriction = false;\r\n    }\r\n\r\n    // change the Threshold\r\n    function changeThreshold(uint newThreshold) onlyOwner() public {\r\n        // Owner is only able to change the threshold when no one bought (otherwise it would be unfair)\r\n        require(entryCounter == 0);\r\n        automaticThreshold = newThreshold;\r\n    }\r\n\r\n    function changeTicketPrice(uint newticketPrice) onlyOwner() public {\r\n        // Owner is only able to change the ticket price when no one bought (otherwise it would be unfair)\r\n        require(entryCounter == 0);\r\n        ticketPrice = newticketPrice;\r\n    }\r\n\r\n    // Admin can call the payWinner (ends lottery round & starts a new one) if it takes too long to reach the threshold\r\n    function payWinnerManually() public onlyOwner() returns (address) {\r\n        address winner = payWinner();\r\n        return winner;\r\n    }\r\n\r\n    // check special functions\r\n    function imAlive() public onlyOwner() {\r\n        inactivity = 1;\r\n    }\r\n    /**\r\n    * Special functions\r\n    */\r\n\r\n    /* \r\n    *   In case the threshold is way too high and the owner/admin disappeared (inactive for 30days)\r\n    *   Everyone can call this function then the timestamp gets saved\r\n    *   after 30 days of owner-inactivity someone can call the function again and calls payWinner with it\r\n    */\r\n    uint inactivity = 1;\r\n    function adminIsDead() public {\r\n        if (inactivity == 1) {\r\n            inactivity == block.timestamp;\r\n        }\r\n        else {\r\n            uint256 inactivityThreshold = (block.timestamp - (30 days));\r\n            assert(inactivityThreshold < block.timestamp);\r\n            if (inactivity < inactivityThreshold) {\r\n                inactivity = 1;\r\n                payWinnerManually2();\r\n            }\r\n        }\r\n    }\r\n\r\n    function payWinnerManually2() internal {\r\n        payWinner();\r\n    }\r\n\r\n\r\n     /* A trap door for when someone sends tokens other than the intended ones so the overseers\r\n      can decide where to send them. (credit: Doublr Contract) */\r\n    function returnAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) public onlyOwner() secCheck(tokenAddress) returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n//Need to ensure this contract can send tokens to people\r\ncontract ERC20Interface\r\n{\r\n    function transfer(address to, uint256 tokens) public returns (bool success);\r\n}\r\n\r\n// Interface to actually call contract functions of e.g. REV1\r\ncontract _Contract\r\n{\r\n    function buy(address) public payable returns(uint256);\r\n    function exit() public;\r\n    function myTokens() public view returns(uint256);\r\n    function myDividends(bool) public view returns(uint256);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_restriction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"adminIsDead\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"imAlive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newticketPrice\",\"type\":\"uint256\"}],\"name\":\"changeTicketPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"changeThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"automaticThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"returnAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entries\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payWinnerManually\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateToDev\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"customer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"yourEntry\",\"type\":\"uint256\"}],\"name\":\"BoughtTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"WinnerPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7238292731f6895ca64cb34eadaca8324f12b8abd392db9d5d20562e4729da8b"}]}