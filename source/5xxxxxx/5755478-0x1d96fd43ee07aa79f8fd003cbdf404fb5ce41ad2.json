{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\ninterface IERC20 {\\n    function totalSupply() view returns (uint256 totalSupply);\\n    function balanceOf(address _owner) public view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) public returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\\n    function approve(address _spender, uint256 _value) public returns (bool success);\\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    \\n}\"},\"qwlaToken.sol\":{\"content\":\"pragma solidity ^0.4.11;\\n\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract qwlaToken is IERC20 {\\n\\n\\tusing SafeMath for uint256;\\n\\n\\tuint public constant  _totalSupply = 100000000 * 10**uint(decimals);\\n\\n\\tstring public constant symbol = \\\"QWLA\\\";\\n\\tstring public constant name = \\\"Qawalla Token\\\";\\n\\tuint8 public constant decimals = 18; \\n\\n\\n\\tmapping(address =\\u003e uint256) balances;\\n\\tmapping(address =\\u003e mapping(address =\\u003e uint256)) allowed;\\n\\t\\n\\tfunction qwlaToken(){\\n\\t\\t\\tbalances[msg.sender] = _totalSupply;\\n\\t}\\n\\n\\tfunction totalSupply() constant returns (uint256 totalSupply) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\n\\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\\n\\t\\t\\treturn balances[_owner];\\n\\t\\t\\t\\n\\t}\\n\\n\\tfunction transfer(address _to, uint256 _value) returns (bool success) {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tbalances[msg.sender] \\u003e= _value\\n\\t\\t\\t\\t\\u0026\\u0026 _value \\u003e 0\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tbalances[msg.sender] = balances[msg.sender].sub( _value);\\n\\t\\t\\t\\tbalances[_to] = balances[_to].add(_value);\\n\\t\\t\\t\\tTransfer(msg.sender, _to, _value);\\n\\t\\t\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tallowed[_from][msg.sender] \\u003e= _value\\n\\t\\t\\t\\t\\u0026\\u0026 balances[_from] \\u003e= _value\\n\\t\\t\\t\\t\\u0026\\u0026 _value \\u003e 0\\n\\n\\t\\t\\t);\\n\\t\\t\\tbalances[_from] = balances[_from].sub(_value);\\n\\t\\t\\tbalances[_to] = balances[_to].add(_value);\\n\\t\\t\\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n\\t\\t\\tTransfer(_from, _to, _value);\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t}\\n\\n\\tfunction approve(address _spender, uint256 _value) returns (bool success) {\\n\\t\\t\\tallowed[msg.sender][_spender] = _value;\\n\\t\\t\\tApproval(msg.sender, _spender, _value);\\n\\t\\t\\treturn true;\\n\\t}\\n\\n\\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\\n\\t\\t\\treturn allowed[_owner][_spender];\\n\\t}\\n\\n\\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\\n\\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n}\\n\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\"}}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"qwlaToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c93f96028df0a635fc0693710886658e750a0779ac74fe443e47871773ba0629"}]}