{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/MigrationTarget.sol\r\n\r\n//\r\n// Migration target\r\n// @dev Implement this interface to make migration target\r\n//\r\ncontract MigrationTarget {\r\n  function migrateFrom(address _from, uint256 _amount, uint256 _rewards, uint256 _trueBuy, bool _devStatus) public;\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  // Event\r\n  event OwnershipChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n  // Modifier\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipChanged(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/ERC20.sol\r\n\r\ncontract ERC20 {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address _owner) view public returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) view public returns (uint256 remaining);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/StandardToken.sol\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is ERC20 {\r\n  /**\r\n   * Internal transfer, only can be called by this contract\r\n   */\r\n  function _transfer(address _from, address _to, uint _value) internal returns (bool success) {\r\n    // Prevent transfer to 0x0 address. Use burn() instead\r\n    require(_to != address(0));\r\n    // Check if the sender has enough\r\n    require(balances[_from] >= _value);\r\n    // Check for overflows\r\n    require(balances[_to] + _value > balances[_to]);\r\n    // Save this for an assertion in the future\r\n    uint256 previousBalances = balances[_from] + balances[_to];\r\n    // Subtract from the sender\r\n    balances[_from] -= _value;\r\n    // Add the same to the recipient\r\n    balances[_to] += _value;\r\n    emit Transfer(_from, _to, _value);\r\n    // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n    assert(balances[_from] + balances[_to] == previousBalances);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Transfer tokens\r\n   *\r\n   * Send `_value` tokens to `_to` from your account\r\n   *\r\n   * @param _to The address of the recipient\r\n   * @param _value the amount to send\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {\r\n    return _transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n   * Transfer tokens from other address\r\n   *\r\n   * Send `_value` tokens to `_to` in behalf of `_from`\r\n   *\r\n   * @param _from The address of the sender\r\n   * @param _to The address of the recipient\r\n   * @param _value the amount to send\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n    require(_value <= allowed[_from][msg.sender]);     // Check allowance\r\n    allowed[_from][msg.sender] -= _value;\r\n    return _transfer(_from, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) view public returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /**\r\n   * Set allowance for other address\r\n   *\r\n   * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n   *\r\n   * @param _spender The address authorized to spend\r\n   * @param _value the max amount they can spend\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  mapping (address => uint256) public balances;\r\n  mapping (address => mapping (address => uint256)) public allowed;\r\n}\r\n\r\n// File: contracts/RoyaltyToken.sol\r\n\r\n/*  Royalty token */\r\ncontract RoyaltyToken is StandardToken {\r\n  using SafeMath for uint256;\r\n  // restricted addresses\t\r\n  mapping(address => bool) public restrictedAddresses;\r\n  \r\n  event RestrictedStatusChanged(address indexed _address, bool status);\r\n\r\n  struct Account {\r\n    uint256 balance;\r\n    uint256 lastRoyaltyPoint;\r\n  }\r\n\r\n  mapping(address => Account) public accounts;\r\n  uint256 public totalRoyalty;\r\n  uint256 public unclaimedRoyalty;\r\n\r\n  /**\r\n   * Get Royalty amount for given account\r\n   *\r\n   * @param account The address for Royalty account\r\n   */\r\n  function RoyaltysOwing(address account) public view returns (uint256) {\r\n    uint256 newRoyalty = totalRoyalty.sub(accounts[account].lastRoyaltyPoint);\r\n    return balances[account].mul(newRoyalty).div(totalSupply);\r\n  }\r\n\r\n  /**\r\n   * @dev Update account for Royalty\r\n   * @param account The address of owner\r\n   */\r\n  function updateAccount(address account) internal {\r\n    uint256 owing = RoyaltysOwing(account);\r\n    accounts[account].lastRoyaltyPoint = totalRoyalty;\r\n    if (owing > 0) {\r\n      unclaimedRoyalty = unclaimedRoyalty.sub(owing);\r\n      accounts[account].balance = accounts[account].balance.add(owing);\r\n    }\r\n  }\r\n\r\n  function disburse() public payable {\r\n    require(totalSupply > 0);\r\n    require(msg.value > 0);\r\n\r\n    uint256 newRoyalty = msg.value;\r\n    totalRoyalty = totalRoyalty.add(newRoyalty);\r\n    unclaimedRoyalty = unclaimedRoyalty.add(newRoyalty);\r\n  }\r\n\r\n  /**\r\n   * @dev Send `_value` tokens to `_to` from your account\r\n   *\r\n   * @param _to The address of the recipient\r\n   * @param _value the amount to send\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {\r\n    // Require that the sender is not restricted\r\n    require(restrictedAddresses[msg.sender] == false);\r\n    updateAccount(_to);\r\n    updateAccount(msg.sender);\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from other address. Send `_value` tokens to `_to` in behalf of `_from`\r\n   *\r\n   * @param _from The address of the sender\r\n   * @param _to The address of the recipient\r\n   * @param _value the amount to send\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  ) public returns (bool success) {\r\n    updateAccount(_to);\r\n    updateAccount(_from);\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function withdrawRoyalty() public {\r\n    updateAccount(msg.sender);\r\n\r\n    // retrieve Royalty amount\r\n    uint256 RoyaltyAmount = accounts[msg.sender].balance;\r\n    require(RoyaltyAmount > 0);\r\n    accounts[msg.sender].balance = 0;\r\n\r\n    // transfer Royalty amount\r\n    msg.sender.transfer(RoyaltyAmount);\r\n  }\r\n}\r\n\r\n// File: contracts/Q2.sol\r\n\r\ncontract Q2 is Ownable, RoyaltyToken {\r\n  using SafeMath for uint256;\r\n\r\n  string public name = \"Q2\";\r\n  string public symbol = \"Q2\";\r\n  uint8 public decimals = 18;\r\n\r\n  bool public whitelist = true;\r\n\r\n  // whitelist addresses\r\n  mapping(address => bool) public whitelistedAddresses;\r\n\r\n  // token creation cap\r\n  uint256 public creationCap = 15000000 * (10 ** 18); // 15M\r\n  uint256 public reservedFund = 10000000 * (10 ** 18); // 10M\r\n\r\n  // stage info\r\n  struct Stage {\r\n    uint8 number;\r\n    uint256 exchangeRate;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 cap;\r\n  }\r\n\r\n  // events\r\n  event MintTokens(address indexed _to, uint256 _value);\r\n  event StageStarted(uint8 _stage, uint256 _totalSupply, uint256 _balance);\r\n  event StageEnded(uint8 _stage, uint256 _totalSupply, uint256 _balance);\r\n  event WhitelistStatusChanged(address indexed _address, bool status);\r\n  event WhitelistChanged(bool status);\r\n\r\n  // eth wallet\r\n  address public ethWallet;\r\n  mapping (uint8 => Stage) stages;\r\n\r\n  // current state info\r\n  uint8 public currentStage;\r\n\r\n  function Q2(address _ethWallet) public {\r\n    ethWallet = _ethWallet;\r\n\r\n    // reserved tokens\r\n    mintTokens(ethWallet, reservedFund);\r\n  }\r\n\r\n  function mintTokens(address to, uint256 value) internal {\r\n    require(value > 0);\r\n    balances[to] = balances[to].add(value);\r\n    totalSupply = totalSupply.add(value);\r\n    require(totalSupply <= creationCap);\r\n\r\n    // broadcast event\r\n    emit MintTokens(to, value);\r\n  }\r\n\r\n  function () public payable {\r\n    buyTokens();\r\n  }\r\n\r\n  function buyTokens() public payable {\r\n    require(whitelist==false || whitelistedAddresses[msg.sender] == true);\r\n    require(msg.value > 0);\r\n\r\n    Stage memory stage = stages[currentStage];\r\n    require(block.number >= stage.startBlock && block.number <= stage.endBlock);\r\n\r\n    uint256 tokens = msg.value * stage.exchangeRate;\r\n    require(totalSupply.add(tokens) <= stage.cap);\r\n\r\n    mintTokens(msg.sender, tokens);\r\n  }\r\n\r\n  function startStage(\r\n    uint256 _exchangeRate,\r\n    uint256 _cap,\r\n    uint256 _startBlock,\r\n    uint256 _endBlock\r\n  ) public onlyOwner {\r\n    require(_exchangeRate > 0 && _cap > 0);\r\n    require(_startBlock > block.number);\r\n    require(_startBlock < _endBlock);\r\n\r\n    // stop current stage if it's running\r\n    Stage memory currentObj = stages[currentStage];\r\n    if (currentObj.endBlock > 0) {\r\n      // broadcast stage end event\r\n      emit StageEnded(currentStage, totalSupply, address(this).balance);\r\n    }\r\n\r\n    // increment current stage\r\n    currentStage = currentStage + 1;\r\n\r\n    // create new stage object\r\n    Stage memory s = Stage({\r\n      number: currentStage,\r\n      startBlock: _startBlock,\r\n      endBlock: _endBlock,\r\n      exchangeRate: _exchangeRate,\r\n      cap: _cap + totalSupply\r\n    });\r\n    stages[currentStage] = s;\r\n\r\n    // broadcast stage started event\r\n    emit StageStarted(currentStage, totalSupply, address(this).balance);\r\n  }\r\n\r\n  function withdraw() public onlyOwner {\r\n    ethWallet.transfer(address(this).balance);\r\n  }\r\n\r\n  function getCurrentStage() view public returns (\r\n    uint8 number,\r\n    uint256 exchangeRate,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    uint256 cap\r\n  ) {\r\n    Stage memory currentObj = stages[currentStage];\r\n    number = currentObj.number;\r\n    exchangeRate = currentObj.exchangeRate;\r\n    startBlock = currentObj.startBlock;\r\n    endBlock = currentObj.endBlock;\r\n    cap = currentObj.cap;\r\n  }\r\n\r\n  function changeWhitelistStatus(address _address, bool status) public onlyOwner {\r\n    whitelistedAddresses[_address] = status;\r\n    emit WhitelistStatusChanged(_address, status);\r\n  }\r\n\r\n  function changeRestrictedtStatus(address _address, bool status) public onlyOwner {\r\n    restrictedAddresses[_address] = status;\r\n    emit RestrictedStatusChanged(_address, status);\r\n  }\r\n  \r\n  function changeWhitelist(bool status) public onlyOwner {\r\n     whitelist = status;\r\n     emit WhitelistChanged(status);\r\n  }\r\n}\r\n\r\n// File: contracts/Quarters.sol\r\n\r\ninterface TokenRecipient {\r\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\r\n}\r\n\r\ncontract Quarters is Ownable, StandardToken {\r\n  // Public variables of the token\r\n  string public name = \"Quarters\";\r\n  string public symbol = \"Q\";\r\n  uint8 public decimals = 0; // no decimals, only integer quarters\r\n\r\n  uint16 public ethRate = 4000; // Quarters/ETH\r\n  uint256 public tranche = 40000; // Number of Quarters in initial tranche\r\n\r\n  // List of developers\r\n  // address -> status\r\n  mapping (address => bool) public developers;\r\n\r\n  uint256 public outstandingQuarters;\r\n  address public q2;\r\n\r\n  // number of Quarters for next tranche\r\n  uint8 public trancheNumerator = 2;\r\n  uint8 public trancheDenominator = 1;\r\n\r\n  // initial multiples, rates (as percentages) for tiers of developers\r\n  uint32 public mega = 20;\r\n  uint32 public megaRate = 115;\r\n  uint32 public large = 100;\r\n  uint32 public largeRate = 90;\r\n  uint32 public medium = 2000;\r\n  uint32 public mediumRate = 75;\r\n  uint32 public small = 50000;\r\n  uint32 public smallRate = 50;\r\n  uint32 public microRate = 25;\r\n\r\n  // rewards related storage\r\n  mapping (address => uint256) public rewards;    // rewards earned, but not yet collected\r\n  mapping (address => uint256) public trueBuy;    // tranche rewards are set based on *actual* purchases of Quarters\r\n\r\n  uint256 public rewardAmount = 40;\r\n\r\n  uint8 public rewardNumerator = 1;\r\n  uint8 public rewardDenominator = 4;\r\n\r\n  // reserve ETH from Q2 to fund rewards\r\n  uint256 public reserveETH=0;\r\n\r\n  // ETH rate changed\r\n  event EthRateChanged(uint16 currentRate, uint16 newRate);\r\n\r\n  // This notifies clients about the amount burnt\r\n  event Burn(address indexed from, uint256 value);\r\n\r\n  event QuartersOrdered(address indexed sender, uint256 ethValue, uint256 tokens);\r\n  event DeveloperStatusChanged(address indexed developer, bool status);\r\n  event TrancheIncreased(uint256 _tranche, uint256 _etherPool, uint256 _outstandingQuarters);\r\n  event MegaEarnings(address indexed developer, uint256 value, uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool);\r\n  event Withdraw(address indexed developer, uint256 value, uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool);\r\n  event BaseRateChanged(uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool,  uint256 _totalSupply);\r\n  event Reward(address indexed _address, uint256 value, uint256 _outstandingQuarters, uint256 _totalSupply);\r\n\r\n  /**\r\n   * developer modifier\r\n   */\r\n  modifier onlyActiveDeveloper() {\r\n    require(developers[msg.sender] == true);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Constructor function\r\n   *\r\n   * Initializes contract with initial supply tokens to the owner of the contract\r\n   */\r\n  function Quarters(\r\n    address _q2,\r\n    uint256 firstTranche\r\n  ) public {\r\n    q2 = _q2;\r\n    tranche = firstTranche; // number of Quarters to be sold before increasing price\r\n  }\r\n\r\n  function setEthRate (uint16 rate) onlyOwner public {\r\n    // Ether price is set in Wei\r\n    require(rate > 0);\r\n    ethRate = rate;\r\n    emit EthRateChanged(ethRate, rate);\r\n  }\r\n\r\n  /**\r\n   * Adjust reward amount\r\n   */\r\n  function adjustReward (uint256 reward) onlyOwner public {\r\n    rewardAmount = reward; // may be zero, no need to check value to 0\r\n  }\r\n\r\n  function adjustWithdrawRate(uint32 mega2, uint32 megaRate2, uint32 large2, uint32 largeRate2, uint32 medium2, uint32 mediumRate2, uint32 small2, uint32 smallRate2, uint32 microRate2) onlyOwner public {\r\n    // the values (mega, large, medium, small) are multiples, e.g., 20x, 100x, 10000x\r\n    // the rates (megaRate, etc.) are percentage points, e.g., 150 is 150% of the remaining etherPool\r\n    if (mega2 > 0 && megaRate2 > 0) {\r\n      mega = mega2;\r\n      megaRate = megaRate2;\r\n    }\r\n\r\n    if (large2 > 0 && largeRate2 > 0) {\r\n      large = large2;\r\n      largeRate = largeRate2;\r\n    }\r\n\r\n    if (medium2 > 0 && mediumRate2 > 0) {\r\n      medium = medium2;\r\n      mediumRate = mediumRate2;\r\n    }\r\n\r\n    if (small2 > 0 && smallRate2 > 0){\r\n      small = small2;\r\n      smallRate = smallRate2;\r\n    }\r\n\r\n    if (microRate2 > 0) {\r\n      microRate = microRate2;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * adjust tranche for next cycle\r\n   */\r\n  function adjustNextTranche (uint8 numerator, uint8 denominator) onlyOwner public {\r\n    require(numerator > 0 && denominator > 0);\r\n    trancheNumerator = numerator;\r\n    trancheDenominator = denominator;\r\n  }\r\n\r\n  function adjustTranche(uint256 tranche2) onlyOwner public {\r\n    require(tranche2 > 0);\r\n    tranche = tranche2;\r\n  }\r\n\r\n  /**\r\n   * Adjust rewards for `_address`\r\n   */\r\n  function updatePlayerRewards(address _address) internal {\r\n    require(_address != address(0));\r\n\r\n    uint256 _reward = 0;\r\n    if (rewards[_address] == 0) {\r\n      _reward = rewardAmount;\r\n    } else if (rewards[_address] < tranche) {\r\n      _reward = trueBuy[_address] * rewardNumerator / rewardDenominator;\r\n    }\r\n\r\n    if (_reward > 0) {\r\n      // update rewards record\r\n      rewards[_address] = tranche;\r\n\r\n      balances[_address] += _reward;\r\n      allowed[_address][msg.sender] += _reward; // set allowance\r\n\r\n      totalSupply += _reward;\r\n      outstandingQuarters += _reward;\r\n\r\n      uint256 spentETH = (_reward * (10 ** 18)) / ethRate;\r\n      if (reserveETH >= spentETH) {\r\n          reserveETH -= spentETH;\r\n        } else {\r\n          reserveETH = 0;\r\n        }\r\n\r\n      // tranche size change\r\n      _changeTrancheIfNeeded();\r\n\r\n      emit Approval(_address, msg.sender, _reward);\r\n      emit Reward(_address, _reward, outstandingQuarters, totalSupply);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Developer status\r\n   */\r\n  function setDeveloperStatus (address _address, bool status) onlyOwner public {\r\n    developers[_address] = status;\r\n    emit DeveloperStatusChanged(_address, status);\r\n  }\r\n\r\n  /**\r\n   * Set allowance for other address and notify\r\n   *\r\n   * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n   *\r\n   * @param _spender The address authorized to spend\r\n   * @param _value the max amount they can spend\r\n   * @param _extraData some extra information to send to the approved contract\r\n   */\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n  public\r\n  returns (bool success) {\r\n    TokenRecipient spender = TokenRecipient(_spender);\r\n    if (approve(_spender, _value)) {\r\n      spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Destroy tokens\r\n   *\r\n   * Remove `_value` tokens from the system irreversibly\r\n   *\r\n   * @param _value the amount of money to burn\r\n   */\r\n  function burn(uint256 _value) public returns (bool success) {\r\n    require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n    balances[msg.sender] -= _value;            // Subtract from the sender\r\n    totalSupply -= _value;                     // Updates totalSupply\r\n    outstandingQuarters -= _value;              // Update outstanding quarters\r\n    emit Burn(msg.sender, _value);\r\n\r\n    // log rate change\r\n    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Destroy tokens from other account\r\n   *\r\n   * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n   *\r\n   * @param _from the address of the sender\r\n   * @param _value the amount of money to burn\r\n   */\r\n  function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n    require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n    require(_value <= allowed[_from][msg.sender]);     // Check allowance\r\n    balances[_from] -= _value;                         // Subtract from the targeted balance\r\n    allowed[_from][msg.sender] -= _value;              // Subtract from the sender's allowance\r\n    totalSupply -= _value;                      // Update totalSupply\r\n    outstandingQuarters -= _value;              // Update outstanding quarters\r\n    emit Burn(_from, _value);\r\n\r\n    // log rate change\r\n    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Buy quarters by sending ethers to contract address (no data required)\r\n   */\r\n  function () payable public {\r\n    _buy(msg.sender);\r\n  }\r\n\r\n\r\n  function buy() payable public {\r\n    _buy(msg.sender);\r\n  }\r\n\r\n  function buyFor(address buyer) payable public {\r\n    uint256 _value =  _buy(buyer);\r\n\r\n    // allow donor (msg.sender) to spend buyer's tokens\r\n    allowed[buyer][msg.sender] += _value;\r\n    emit Approval(buyer, msg.sender, _value);\r\n  }\r\n\r\n  function _changeTrancheIfNeeded() internal {\r\n    if (totalSupply >= tranche) {\r\n      // change tranche size for next cycle\r\n      tranche = (tranche * trancheNumerator) / trancheDenominator;\r\n\r\n      // fire event for tranche change\r\n      emit TrancheIncreased(tranche, address(this).balance, outstandingQuarters);\r\n    }\r\n  }\r\n\r\n  // returns number of quarters buyer got\r\n  function _buy(address buyer) internal returns (uint256) {\r\n    require(buyer != address(0));\r\n\r\n    uint256 nq = (msg.value * ethRate) / (10 ** 18);\r\n    require(nq != 0);\r\n    if (nq > tranche) {\r\n      nq = tranche;\r\n    }\r\n\r\n    totalSupply += nq;\r\n    balances[buyer] += nq;\r\n    trueBuy[buyer] += nq;\r\n    outstandingQuarters += nq;\r\n\r\n    // change tranche size\r\n    _changeTrancheIfNeeded();\r\n\r\n    // event for quarters order (invoice)\r\n    emit QuartersOrdered(buyer, msg.value, nq);\r\n\r\n    // log rate change\r\n    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\r\n\r\n    // transfer owner's cut\r\n    Q2(q2).disburse.value(msg.value * 15 / 100)();\r\n\r\n    // return nq\r\n    return nq;\r\n  }\r\n\r\n  /**\r\n   * Transfer allowance from other address's allowance\r\n   *\r\n   * Send `_value` tokens to `_to` in behalf of `_from`\r\n   *\r\n   * @param _from The address of the sender\r\n   * @param _to The address of the recipient\r\n   * @param _value the amount to send\r\n   */\r\n  function transferAllowance(address _from, address _to, uint256 _value) public returns (bool success) {\r\n    updatePlayerRewards(_from);\r\n    require(_value <= allowed[_from][msg.sender]);     // Check allowance\r\n    allowed[_from][msg.sender] -= _value;\r\n\r\n    if (_transfer(_from, _to, _value)) {\r\n      // allow msg.sender to spend _to's tokens\r\n      allowed[_to][msg.sender] += _value;\r\n      emit Approval(_to, msg.sender, _value);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function withdraw(uint256 value) onlyActiveDeveloper public {\r\n    require(balances[msg.sender] >= value);\r\n\r\n    uint256 baseRate = getBaseRate();\r\n    require(baseRate > 0); // check if base rate > 0\r\n\r\n    uint256 earnings = value * baseRate;\r\n    uint256 rate = getRate(value); // get rate from value and tranche\r\n    uint256 earningsWithBonus = (rate * earnings) / 100;\r\n    if (earningsWithBonus > address(this).balance) {\r\n      earnings = address(this).balance;\r\n    } else {\r\n      earnings = earningsWithBonus;\r\n    }\r\n\r\n    balances[msg.sender] -= value;\r\n    outstandingQuarters -= value; // update the outstanding Quarters\r\n\r\n    uint256 etherPool = address(this).balance - earnings;\r\n    if (rate == megaRate) {\r\n      emit MegaEarnings(msg.sender, earnings, baseRate, tranche, outstandingQuarters, etherPool); // with current base rate\r\n    }\r\n\r\n    // event for withdraw\r\n    emit Withdraw(msg.sender, earnings, baseRate, tranche, outstandingQuarters, etherPool);  // with current base rate\r\n\r\n    // log rate change\r\n    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\r\n\r\n    // earning for developers\r\n    msg.sender.transfer(earnings);  \r\n}\r\n\r\n  function disburse() public payable {\r\n    reserveETH += msg.value;\r\n  }\r\n\r\n  function getBaseRate () view public returns (uint256) {\r\n    if (outstandingQuarters > 0) {\r\n      return (address(this).balance - reserveETH) / outstandingQuarters;\r\n    }\r\n\r\n    return (address(this).balance - reserveETH);\r\n  }\r\n\r\n  function getRate (uint256 value) view public returns (uint32) {\r\n    if (value * mega > tranche) {  // size & rate for mega developer\r\n      return megaRate;\r\n    } else if (value * large > tranche) {   // size & rate for large developer\r\n      return largeRate;\r\n    } else if (value * medium > tranche) {  // size and rate for medium developer\r\n      return mediumRate;\r\n    } else if (value * small > tranche){  // size and rate for small developer\r\n      return smallRate;\r\n    }\r\n\r\n    return microRate; // rate for micro developer\r\n  }\r\n\r\n\r\n  //\r\n  // Migrations\r\n  //\r\n\r\n  // Target contract\r\n  address public migrationTarget;\r\n  bool public migrating = false;\r\n\r\n  // Migrate event\r\n  event Migrate(address indexed _from, uint256 _value);\r\n\r\n  //\r\n  // Migrate tokens to the new token contract.\r\n  //\r\n  function migrate() public {\r\n    require(migrationTarget != address(0));\r\n    uint256 _amount = balances[msg.sender];\r\n    require(_amount > 0);\r\n    balances[msg.sender] = 0;\r\n\r\n    totalSupply = totalSupply - _amount;\r\n    outstandingQuarters = outstandingQuarters - _amount;\r\n\r\n    rewards[msg.sender] = 0;\r\n    trueBuy[msg.sender] = 0;\r\n    developers[msg.sender] = false;\r\n\r\n    emit Migrate(msg.sender, _amount);\r\n    MigrationTarget(migrationTarget).migrateFrom(msg.sender, _amount, rewards[msg.sender], trueBuy[msg.sender], developers[msg.sender]);\r\n  }\r\n\r\n  //\r\n  // Set address of migration target contract\r\n  // @param _target The address of the MigrationTarget contract\r\n  //\r\n  function setMigrationTarget(address _target) onlyOwner public {\r\n    migrationTarget = _target;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"changeRestrictedtStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"restrictedAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRoyalty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"lastRoyaltyPoint\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"changeWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disburse\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RoyaltysOwing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRate\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"startStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStage\",\"outputs\":[{\"name\":\"number\",\"type\":\"uint8\"},{\"name\":\"exchangeRate\",\"type\":\"uint256\"},{\"name\":\"startBlock\",\"type\":\"uint256\"},{\"name\":\"endBlock\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRoyalty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"changeWhitelistStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unclaimedRoyalty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ethWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"MintTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_stage\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"StageStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_stage\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"StageEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"WhitelistStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"WhitelistChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"RestrictedStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"}]","ContractName":"Q2","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000a3ff2d120da04202a94f61098ce956089b660d5","Library":"","SwarmSource":"bzzr://a95b7603d896a6fe687ffdc46bc00451c34fe91ebad83272c0476d66a2ef1927"}]}