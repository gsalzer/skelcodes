{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract EOSBetGameInterface {\r\n\tuint256 public DEVELOPERSFUND;\r\n\tuint256 public LIABILITIES;\r\n\tfunction payDevelopersFund(address developer) public;\r\n\tfunction receivePaymentForOraclize() payable public;\r\n\tfunction getMaxWin() public view returns(uint256);\r\n}\r\n\r\ncontract EOSBetBankrollInterface {\r\n\tfunction payEtherToWinner(uint256 amtEther, address winner) public;\r\n\tfunction receiveEtherFromGameAddress() payable public;\r\n\tfunction payOraclize(uint256 amountToPay) public;\r\n\tfunction getBankroll() public view returns(uint256);\r\n}\r\n\r\ncontract ERC20 {\r\n\tfunction totalSupply() constant public returns (uint supply);\r\n\tfunction balanceOf(address _owner) constant public returns (uint balance);\r\n\tfunction transfer(address _to, uint _value) public returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\tfunction approve(address _spender, uint _value) public returns (bool success);\r\n\tfunction allowance(address _owner, address _spender) constant public returns (uint remaining);\r\n\tevent Transfer(address indexed _from, address indexed _to, uint _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract EOSBetBankroll is ERC20, EOSBetBankrollInterface {\r\n\r\n\tusing SafeMath for *;\r\n\r\n\t// constants for EOSBet Bankroll\r\n\r\n\taddress public OWNER;\r\n\tuint256 public MAXIMUMINVESTMENTSALLOWED;\r\n\tuint256 public WAITTIMEUNTILWITHDRAWORTRANSFER;\r\n\tuint256 public DEVELOPERSFUND;\r\n\r\n\t// this will be initialized as the trusted game addresses which will forward their ether\r\n\t// to the bankroll contract, and when players win, they will request the bankroll contract \r\n\t// to send these players their winnings.\r\n\t// Feel free to audit these contracts on etherscan...\r\n\tmapping(address => bool) public TRUSTEDADDRESSES;\r\n\r\n\taddress public DICE;\r\n\taddress public SLOTS;\r\n\r\n\t// mapping to log the last time a user contributed to the bankroll \r\n\tmapping(address => uint256) contributionTime;\r\n\r\n\t// constants for ERC20 standard\r\n\tstring public constant name = \"EOSBet Stake Tokens\";\r\n\tstring public constant symbol = \"EOSBETST\";\r\n\tuint8 public constant decimals = 18;\r\n\t// variable total supply\r\n\tuint256 public totalSupply;\r\n\r\n\t// mapping to store tokens\r\n\tmapping(address => uint256) public balances;\r\n\tmapping(address => mapping(address => uint256)) public allowed;\r\n\r\n\t// events\r\n\tevent FundBankroll(address contributor, uint256 etherContributed, uint256 tokensReceived);\r\n\tevent CashOut(address contributor, uint256 etherWithdrawn, uint256 tokensCashedIn);\r\n\tevent FailedSend(address sendTo, uint256 amt);\r\n\r\n\t// checks that an address is a \"trusted address of a legitimate EOSBet game\"\r\n\tmodifier addressInTrustedAddresses(address thisAddress){\r\n\r\n\t\trequire(TRUSTEDADDRESSES[thisAddress]);\r\n\t\t_;\r\n\t}\r\n\r\n\t// initialization function \r\n\tfunction EOSBetBankroll(address dice, address slots) public payable {\r\n\t\t// function is payable, owner of contract MUST \"seed\" contract with some ether, \r\n\t\t// so that the ratios are correct when tokens are being minted\r\n\t\trequire (msg.value > 0);\r\n\r\n\t\tOWNER = msg.sender;\r\n\r\n\t\t// 100 tokens/ether is the inital seed amount, so:\r\n\t\tuint256 initialTokens = msg.value * 100;\r\n\t\tbalances[msg.sender] = initialTokens;\r\n\t\ttotalSupply = initialTokens;\r\n\r\n\t\t// log a mint tokens event\r\n\t\temit Transfer(0x0, msg.sender, initialTokens);\r\n\r\n\t\t// insert given game addresses into the TRUSTEDADDRESSES mapping, and save the addresses as global variables\r\n\t\tTRUSTEDADDRESSES[dice] = true;\r\n\t\tTRUSTEDADDRESSES[slots] = true;\r\n\r\n\t\tDICE = dice;\r\n\t\tSLOTS = slots;\r\n\r\n\t\tWAITTIMEUNTILWITHDRAWORTRANSFER = 6 hours;\r\n\t\tMAXIMUMINVESTMENTSALLOWED = 500 ether;\r\n\t}\r\n\r\n\t///////////////////////////////////////////////\r\n\t// VIEW FUNCTIONS\r\n\t/////////////////////////////////////////////// \r\n\r\n\tfunction checkWhenContributorCanTransferOrWithdraw(address bankrollerAddress) view public returns(uint256){\r\n\t\treturn contributionTime[bankrollerAddress];\r\n\t}\r\n\r\n\tfunction getBankroll() view public returns(uint256){\r\n\t\t// returns the total balance minus the developers fund, as the amount of active bankroll\r\n\t\treturn SafeMath.sub(address(this).balance, DEVELOPERSFUND);\r\n\t}\r\n\r\n\t///////////////////////////////////////////////\r\n\t// BANKROLL CONTRACT <-> GAME CONTRACTS functions\r\n\t/////////////////////////////////////////////// \r\n\r\n\tfunction payEtherToWinner(uint256 amtEther, address winner) public addressInTrustedAddresses(msg.sender){\r\n\t\t// this function will get called by a game contract when someone wins a game\r\n\t\t// try to send, if it fails, then send the amount to the owner\r\n\t\t// note, this will only happen if someone is calling the betting functions with\r\n\t\t// a contract. They are clearly up to no good, so they can contact us to retreive \r\n\t\t// their ether\r\n\t\t// if the ether cannot be sent to us, the OWNER, that means we are up to no good, \r\n\t\t// and the ether will just be given to the bankrollers as if the player/owner lost \r\n\r\n\t\tif (! winner.send(amtEther)){\r\n\r\n\t\t\temit FailedSend(winner, amtEther);\r\n\r\n\t\t\tif (! OWNER.send(amtEther)){\r\n\r\n\t\t\t\temit FailedSend(OWNER, amtEther);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction receiveEtherFromGameAddress() payable public addressInTrustedAddresses(msg.sender){\r\n\t\t// this function will get called from the game contracts when someone starts a game.\r\n\t}\r\n\r\n\tfunction payOraclize(uint256 amountToPay) public addressInTrustedAddresses(msg.sender){\r\n\t\t// this function will get called when a game contract must pay payOraclize\r\n\t\tEOSBetGameInterface(msg.sender).receivePaymentForOraclize.value(amountToPay)();\r\n\t}\r\n\r\n\t///////////////////////////////////////////////\r\n\t// BANKROLL CONTRACT MAIN FUNCTIONS\r\n\t///////////////////////////////////////////////\r\n\r\n\r\n\t// this function ADDS to the bankroll of EOSBet, and credits the bankroller a proportional\r\n\t// amount of tokens so they may withdraw their tokens later\r\n\t// also if there is only a limited amount of space left in the bankroll, a user can just send as much \r\n\t// ether as they want, because they will be able to contribute up to the maximum, and then get refunded the rest.\r\n\tfunction () public payable {\r\n\r\n\t\t// save in memory for cheap access.\r\n\t\t// this represents the total bankroll balance before the function was called.\r\n\t\tuint256 currentTotalBankroll = SafeMath.sub(getBankroll(), msg.value);\r\n\t\tuint256 maxInvestmentsAllowed = MAXIMUMINVESTMENTSALLOWED;\r\n\r\n\t\trequire(currentTotalBankroll < maxInvestmentsAllowed && msg.value != 0);\r\n\r\n\t\tuint256 currentSupplyOfTokens = totalSupply;\r\n\t\tuint256 contributedEther;\r\n\r\n\t\tbool contributionTakesBankrollOverLimit;\r\n\t\tuint256 ifContributionTakesBankrollOverLimit_Refund;\r\n\r\n\t\tuint256 creditedTokens;\r\n\r\n\t\tif (SafeMath.add(currentTotalBankroll, msg.value) > maxInvestmentsAllowed){\r\n\t\t\t// allow the bankroller to contribute up to the allowed amount of ether, and refund the rest.\r\n\t\t\tcontributionTakesBankrollOverLimit = true;\r\n\t\t\t// set contributed ether as (MAXIMUMINVESTMENTSALLOWED - BANKROLL)\r\n\t\t\tcontributedEther = SafeMath.sub(maxInvestmentsAllowed, currentTotalBankroll);\r\n\t\t\t// refund the rest of the ether, which is (original amount sent - (maximum amount allowed - bankroll))\r\n\t\t\tifContributionTakesBankrollOverLimit_Refund = SafeMath.sub(msg.value, contributedEther);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcontributedEther = msg.value;\r\n\t\t}\r\n        \r\n\t\tif (currentSupplyOfTokens != 0){\r\n\t\t\t// determine the ratio of contribution versus total BANKROLL.\r\n\t\t\tcreditedTokens = SafeMath.mul(contributedEther, currentSupplyOfTokens) / currentTotalBankroll;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// edge case where ALL money was cashed out from bankroll\r\n\t\t\t// so currentSupplyOfTokens == 0\r\n\t\t\t// currentTotalBankroll can == 0 or not, if someone mines/selfdestruct's to the contract\r\n\t\t\t// but either way, give all the bankroll to person who deposits ether\r\n\t\t\tcreditedTokens = SafeMath.mul(contributedEther, 100);\r\n\t\t}\r\n\t\t\r\n\t\t// now update the total supply of tokens and bankroll amount\r\n\t\ttotalSupply = SafeMath.add(currentSupplyOfTokens, creditedTokens);\r\n\r\n\t\t// now credit the user with his amount of contributed tokens \r\n\t\tbalances[msg.sender] = SafeMath.add(balances[msg.sender], creditedTokens);\r\n\r\n\t\t// update his contribution time for stake time locking\r\n\t\tcontributionTime[msg.sender] = block.timestamp;\r\n\r\n\t\t// now look if the attempted contribution would have taken the BANKROLL over the limit, \r\n\t\t// and if true, refund the excess ether.\r\n\t\tif (contributionTakesBankrollOverLimit){\r\n\t\t\tmsg.sender.transfer(ifContributionTakesBankrollOverLimit_Refund);\r\n\t\t}\r\n\r\n\t\t// log an event about funding bankroll\r\n\t\temit FundBankroll(msg.sender, contributedEther, creditedTokens);\r\n\r\n\t\t// log a mint tokens event\r\n\t\temit Transfer(0x0, msg.sender, creditedTokens);\r\n\t}\r\n\r\n\tfunction cashoutEOSBetStakeTokens(uint256 _amountTokens) public {\r\n\t\t// In effect, this function is the OPPOSITE of the un-named payable function above^^^\r\n\t\t// this allows bankrollers to \"cash out\" at any time, and receive the ether that they contributed, PLUS\r\n\t\t// a proportion of any ether that was earned by the smart contact when their ether was \"staking\", However\r\n\t\t// this works in reverse as well. Any net losses of the smart contract will be absorbed by the player in like manner.\r\n\t\t// Of course, due to the constant house edge, a bankroller that leaves their ether in the contract long enough\r\n\t\t// is effectively guaranteed to withdraw more ether than they originally \"staked\"\r\n\r\n\t\t// save in memory for cheap access.\r\n\t\tuint256 tokenBalance = balances[msg.sender];\r\n\t\t// verify that the contributor has enough tokens to cash out this many, and has waited the required time.\r\n\t\trequire(_amountTokens <= tokenBalance \r\n\t\t\t&& contributionTime[msg.sender] + WAITTIMEUNTILWITHDRAWORTRANSFER <= block.timestamp\r\n\t\t\t&& _amountTokens > 0);\r\n\r\n\t\t// save in memory for cheap access.\r\n\t\t// again, represents the total balance of the contract before the function was called.\r\n\t\tuint256 currentTotalBankroll = getBankroll();\r\n\t\tuint256 currentSupplyOfTokens = totalSupply;\r\n\r\n\t\t// calculate the token withdraw ratio based on current supply \r\n\t\tuint256 withdrawEther = SafeMath.mul(_amountTokens, currentTotalBankroll) / currentSupplyOfTokens;\r\n\r\n\t\t// developers take 1% of withdrawls \r\n\t\tuint256 developersCut = withdrawEther / 100;\r\n\t\tuint256 contributorAmount = SafeMath.sub(withdrawEther, developersCut);\r\n\r\n\t\t// now update the total supply of tokens by subtracting the tokens that are being \"cashed in\"\r\n\t\ttotalSupply = SafeMath.sub(currentSupplyOfTokens, _amountTokens);\r\n\r\n\t\t// and update the users supply of tokens \r\n\t\tbalances[msg.sender] = SafeMath.sub(tokenBalance, _amountTokens);\r\n\r\n\t\t// update the developers fund based on this calculated amount \r\n\t\tDEVELOPERSFUND = SafeMath.add(DEVELOPERSFUND, developersCut);\r\n\r\n\t\t// lastly, transfer the ether back to the bankroller. Thanks for your contribution!\r\n\t\tmsg.sender.transfer(contributorAmount);\r\n\r\n\t\t// log an event about cashout\r\n\t\temit CashOut(msg.sender, contributorAmount, _amountTokens);\r\n\r\n\t\t// log a destroy tokens event\r\n\t\temit Transfer(msg.sender, 0x0, _amountTokens);\r\n\t}\r\n\r\n\t// TO CALL THIS FUNCTION EASILY, SEND A 0 ETHER TRANSACTION TO THIS CONTRACT WITH EXTRA DATA: 0x7a09588b\r\n\tfunction cashoutEOSBetStakeTokens_ALL() public {\r\n\r\n\t\t// just forward to cashoutEOSBetStakeTokens with input as the senders entire balance\r\n\t\tcashoutEOSBetStakeTokens(balances[msg.sender]);\r\n\t}\r\n\r\n\t////////////////////\r\n\t// OWNER FUNCTIONS:\r\n\t////////////////////\r\n\t// Please, be aware that the owner ONLY can change:\r\n\t\t// 1. The owner can increase or decrease the target amount for a game. They can then call the updater function to give/receive the ether from the game.\r\n\t\t// 1. The wait time until a user can withdraw or transfer their tokens after purchase through the default function above ^^^\r\n\t\t// 2. The owner can change the maximum amount of investments allowed. This allows for early contributors to guarantee\r\n\t\t// \t\ta certain percentage of the bankroll so that their stake cannot be diluted immediately. However, be aware that the \r\n\t\t//\t\tmaximum amount of investments allowed will be raised over time. This will allow for higher bets by gamblers, resulting\r\n\t\t// \t\tin higher dividends for the bankrollers\r\n\t\t// 3. The owner can freeze payouts to bettors. This will be used in case of an emergency, and the contract will reject all\r\n\t\t//\t\tnew bets as well. This does not mean that bettors will lose their money without recompense. They will be allowed to call the \r\n\t\t// \t\t\"refund\" function in the respective game smart contract once payouts are un-frozen.\r\n\t\t// 4. Finally, the owner can modify and withdraw the developers reward, which will fund future development, including new games, a sexier frontend,\r\n\t\t// \t\tand TRUE DAO governance so that onlyOwner functions don't have to exist anymore ;) and in order to effectively react to changes \r\n\t\t// \t\tin the market (lower the percentage because of increased competition in the blockchain casino space, etc.)\r\n\r\n\tfunction transferOwnership(address newOwner) public {\r\n\t\trequire(msg.sender == OWNER);\r\n\r\n\t\tOWNER = newOwner;\r\n\t}\r\n\r\n\tfunction changeWaitTimeUntilWithdrawOrTransfer(uint256 waitTime) public {\r\n\t\t// waitTime MUST be less than or equal to 10 weeks\r\n\t\trequire (msg.sender == OWNER && waitTime <= 6048000);\r\n\r\n\t\tWAITTIMEUNTILWITHDRAWORTRANSFER = waitTime;\r\n\t}\r\n\r\n\tfunction changeMaximumInvestmentsAllowed(uint256 maxAmount) public {\r\n\t\trequire(msg.sender == OWNER);\r\n\r\n\t\tMAXIMUMINVESTMENTSALLOWED = maxAmount;\r\n\t}\r\n\r\n\r\n\tfunction withdrawDevelopersFund(address receiver) public {\r\n\t\trequire(msg.sender == OWNER);\r\n\r\n\t\t// first get developers fund from each game \r\n        EOSBetGameInterface(DICE).payDevelopersFund(receiver);\r\n\t\tEOSBetGameInterface(SLOTS).payDevelopersFund(receiver);\r\n\r\n\t\t// now send the developers fund from the main contract.\r\n\t\tuint256 developersFund = DEVELOPERSFUND;\r\n\r\n\t\t// set developers fund to zero\r\n\t\tDEVELOPERSFUND = 0;\r\n\r\n\t\t// transfer this amount to the owner!\r\n\t\treceiver.transfer(developersFund);\r\n\t}\r\n\r\n\t// rescue tokens inadvertently sent to the contract address \r\n\tfunction ERC20Rescue(address tokenAddress, uint256 amtTokens) public {\r\n\t\trequire (msg.sender == OWNER);\r\n\r\n\t\tERC20(tokenAddress).transfer(msg.sender, amtTokens);\r\n\t}\r\n\r\n\t///////////////////////////////\r\n\t// BASIC ERC20 TOKEN OPERATIONS\r\n\t///////////////////////////////\r\n\r\n\tfunction totalSupply() constant public returns(uint){\r\n\t\treturn totalSupply;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) constant public returns(uint){\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\t// don't allow transfers before the required wait-time\r\n\t// and don't allow transfers to this contract addr, it'll just kill tokens\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success){\r\n\t\trequire(balances[msg.sender] >= _value \r\n\t\t\t&& contributionTime[msg.sender] + WAITTIMEUNTILWITHDRAWORTRANSFER <= block.timestamp\r\n\t\t\t&& _to != address(this)\r\n\t\t\t&& _to != address(0));\r\n\r\n\t\t// safely subtract\r\n\t\tbalances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\r\n\t\tbalances[_to] = SafeMath.add(balances[_to], _value);\r\n\r\n\t\t// log event \r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// don't allow transfers before the required wait-time\r\n\t// and don't allow transfers to the contract addr, it'll just kill tokens\r\n\tfunction transferFrom(address _from, address _to, uint _value) public returns(bool){\r\n\t\trequire(allowed[_from][msg.sender] >= _value \r\n\t\t\t&& balances[_from] >= _value \r\n\t\t\t&& contributionTime[_from] + WAITTIMEUNTILWITHDRAWORTRANSFER <= block.timestamp\r\n\t\t\t&& _to != address(this)\r\n\t\t\t&& _to != address(0));\r\n\r\n\t\t// safely add to _to and subtract from _from, and subtract from allowed balances.\r\n\t\tbalances[_to] = SafeMath.add(balances[_to], _value);\r\n   \t\tbalances[_from] = SafeMath.sub(balances[_from], _value);\r\n  \t\tallowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\r\n\r\n  \t\t// log event\r\n\t\temit Transfer(_from, _to, _value);\r\n\t\treturn true;\r\n   \t\t\r\n\t}\r\n\t\r\n\tfunction approve(address _spender, uint _value) public returns(bool){\r\n\r\n\t\tallowed[msg.sender][_spender] = _value;\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\t// log event\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction allowance(address _owner, address _spender) constant public returns(uint){\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"TRUSTEDADDRESSES\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEVELOPERSFUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawDevelopersFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WAITTIMEUNTILWITHDRAWORTRANSFER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountToPay\",\"type\":\"uint256\"}],\"name\":\"payOraclize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashoutEOSBetStakeTokens_ALL\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"changeMaximumInvestmentsAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bankrollerAddress\",\"type\":\"address\"}],\"name\":\"checkWhenContributorCanTransferOrWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DICE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SLOTS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"waitTime\",\"type\":\"uint256\"}],\"name\":\"changeWaitTimeUntilWithdrawOrTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amtEther\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"payEtherToWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountTokens\",\"type\":\"uint256\"}],\"name\":\"cashoutEOSBetStakeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amtTokens\",\"type\":\"uint256\"}],\"name\":\"ERC20Rescue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUMINVESTMENTSALLOWED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveEtherFromGameAddress\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"dice\",\"type\":\"address\"},{\"name\":\"slots\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherContributed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensReceived\",\"type\":\"uint256\"}],\"name\":\"FundBankroll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensCashedIn\",\"type\":\"uint256\"}],\"name\":\"CashOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"FailedSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EOSBetBankroll","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b533ff572f5e33d04d02b149e7dcfe980e424c630000000000000000000000004a3e0c60f7fa67e8b65c401ddbbf7c17fea5fe40","Library":"","SwarmSource":"bzzr://86c35cc9e9bc7a4131efc4f9be6dcfc90eaf294488fc8ce8f9ac0e5396bf7899"}]}