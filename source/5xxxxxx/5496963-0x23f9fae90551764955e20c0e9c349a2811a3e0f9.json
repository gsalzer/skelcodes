{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ninterface ForceToken {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address _owner) external view returns (uint);\r\n    function serviceTransfer(address _from, address _to, uint _value) external returns (bool);\r\n    function transfer(address _to, uint _value) external returns (bool);\r\n    function approve(address _spender, uint _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\r\n    function holders(uint _id) external view returns (address);\r\n    function holdersCount() external view returns (uint);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public DAO; // DAO contract\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _owner) public onlyMasters {\r\n        owner = _owner;\r\n    }\r\n\r\n    function setDAO(address newDAO) public onlyMasters {\r\n        DAO = newDAO;\r\n    }\r\n\r\n    modifier onlyMasters() {\r\n        require(msg.sender == owner || msg.sender == DAO);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ForceSeller is Ownable {\r\n    using SafeMath for uint;\r\n    ForceToken public forceToken;\r\n\r\n    uint public currentRound;\r\n    uint public tokensOnSale;// current tokens amount on sale\r\n    uint public reservedTokens;\r\n    uint public reservedFunds;\r\n    uint public minSalePrice = 1000000000000000;\r\n    uint public recallPercent = 80;\r\n\r\n    string public information; // info\r\n\r\n    struct Participant {\r\n        uint index;\r\n        uint amount;\r\n        uint value;\r\n        uint change;\r\n        bool needReward;\r\n        bool needCalc;\r\n    }\r\n\r\n    struct ICO {\r\n        uint startTime;\r\n        uint finishTime;\r\n        uint weiRaised;\r\n        uint change;\r\n        uint finalPrice;\r\n        uint rewardedParticipants;\r\n        uint calcedParticipants;\r\n        uint tokensDistributed;\r\n        uint tokensOnSale;\r\n        uint reservedTokens;\r\n        mapping(address => Participant) participants;\r\n        mapping(uint => address) participantsList;\r\n        uint totalParticipants;\r\n        bool active;\r\n    }\r\n\r\n    mapping(uint => ICO) public ICORounds; // past ICOs\r\n\r\n    event ICOStarted(uint round);\r\n    event ICOFinished(uint round);\r\n    event Withdrawal(uint value);\r\n    event Deposit(address indexed participant, uint value, uint round);\r\n    event Recall(address indexed participant, uint value, uint round);\r\n\r\n    modifier whenActive(uint _round) {\r\n        ICO storage ico = ICORounds[_round];\r\n        require(ico.active);\r\n        _;\r\n    }\r\n    modifier whenNotActive(uint _round) {\r\n        ICO storage ico = ICORounds[_round];\r\n        require(!ico.active);\r\n        _;\r\n    }\r\n    modifier duringRound(uint _round) {\r\n        ICO storage ico = ICORounds[_round];\r\n        require(now >= ico.startTime && now <= ico.finishTime);\r\n        _;\r\n    }\r\n\r\n    function ForceSeller(address _forceTokenAddress) public {\r\n        forceToken = ForceToken(_forceTokenAddress);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev set public information\r\n    */\r\n    function setInformation(string _information) external onlyMasters {\r\n        information = _information;\r\n    }\r\n\r\n    /**\r\n    * @dev set 4TH token address\r\n    */\r\n    function setForceContract(address _forceTokenAddress) external onlyMasters {\r\n        forceToken = ForceToken(_forceTokenAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev set recall percent for participants\r\n    */\r\n    function setRecallPercent(uint _recallPercent) external onlyMasters {\r\n        recallPercent = _recallPercent;\r\n    }\r\n\r\n    /**\r\n    * @dev set minimal token sale price\r\n    */\r\n    function setMinSalePrice(uint _minSalePrice) external onlyMasters {\r\n        minSalePrice = _minSalePrice;\r\n    }\r\n    // start new ico, duration in seconds\r\n    function startICO(uint _startTime, uint _duration, uint _amount) external whenNotActive(currentRound) onlyMasters {\r\n        currentRound++;\r\n        // first ICO - round = 1\r\n        ICO storage ico = ICORounds[currentRound];\r\n\r\n        ico.startTime = _startTime;\r\n        ico.finishTime = _startTime.add(_duration);\r\n        ico.active = true;\r\n\r\n        tokensOnSale = forceToken.balanceOf(address(this)).sub(reservedTokens);\r\n        //check if tokens on balance not enough, make a transfer\r\n        if (_amount > tokensOnSale) {\r\n            //TODO ? maybe better make before transfer from owner (DAO)\r\n            // be sure needed amount exists at token contract\r\n            require(forceToken.serviceTransfer(address(forceToken), address(this), _amount.sub(tokensOnSale)));\r\n            tokensOnSale = _amount;\r\n        }\r\n        // reserving tokens\r\n        ico.tokensOnSale = tokensOnSale;\r\n        reservedTokens = reservedTokens.add(tokensOnSale);\r\n        emit ICOStarted(currentRound);\r\n    }\r\n\r\n    function() external payable whenActive(currentRound) duringRound(currentRound) {\r\n        require(msg.value >= currentPrice());\r\n        ICO storage ico = ICORounds[currentRound];\r\n        Participant storage p = ico.participants[msg.sender];\r\n        uint value = msg.value;\r\n\r\n        // is it new participant?\r\n        if (p.index == 0) {\r\n            p.index = ++ico.totalParticipants;\r\n            ico.participantsList[ico.totalParticipants] = msg.sender;\r\n            p.needReward = true;\r\n            p.needCalc = true;\r\n        }\r\n        p.value = p.value.add(value);\r\n        ico.weiRaised = ico.weiRaised.add(value);\r\n        reservedFunds = reservedFunds.add(value);\r\n        emit Deposit(msg.sender, value, currentRound);\r\n    }\r\n\r\n    // refunds participant if he recall their funds\r\n    function recall() external whenActive(currentRound) duringRound(currentRound) {\r\n        ICO storage ico = ICORounds[currentRound];\r\n        Participant storage p = ico.participants[msg.sender];\r\n        uint value = p.value;\r\n        require(value > 0);\r\n        //deleting participant from list\r\n        ico.participants[ico.participantsList[ico.totalParticipants]].index = p.index;\r\n        ico.participantsList[p.index] = ico.participantsList[ico.totalParticipants];\r\n        delete ico.participantsList[ico.totalParticipants--];\r\n        delete ico.participants[msg.sender];\r\n        //reduce weiRaised\r\n        ico.weiRaised = ico.weiRaised.sub(value);\r\n        reservedFunds = reservedFunds.sub(value);\r\n        msg.sender.transfer(valueFromPercent(value, recallPercent));\r\n        emit Recall(msg.sender, value, currentRound);\r\n    }\r\n\r\n    //get current token price\r\n    function currentPrice() public view returns (uint) {\r\n        ICO storage ico = ICORounds[currentRound];\r\n        uint salePrice = tokensOnSale > 0 ? ico.weiRaised.div(tokensOnSale) : 0;\r\n        return salePrice > minSalePrice ? salePrice : minSalePrice;\r\n    }\r\n\r\n    // allows to participants reward their tokens from the current round\r\n    function reward() external {\r\n        rewardRound(currentRound);\r\n    }\r\n\r\n    // allows to participants reward their tokens from the specified round\r\n    function rewardRound(uint _round) public whenNotActive(_round) {\r\n        ICO storage ico = ICORounds[_round];\r\n        Participant storage p = ico.participants[msg.sender];\r\n\r\n        require(p.needReward);\r\n        p.needReward = false;\r\n        ico.rewardedParticipants++;\r\n        if (p.needCalc) {\r\n            p.needCalc = false;\r\n            ico.calcedParticipants++;\r\n            p.amount = p.value.div(ico.finalPrice);\r\n            p.change = p.value % ico.finalPrice;\r\n            reservedFunds = reservedFunds.sub(p.value);\r\n            if (p.change > 0) {\r\n                ico.weiRaised = ico.weiRaised.sub(p.change);\r\n                ico.change = ico.change.add(p.change);\r\n            }\r\n        } else {\r\n            //assuming participant was already calced in calcICO\r\n            ico.reservedTokens = ico.reservedTokens.sub(p.amount);\r\n            if (p.change > 0) {\r\n                reservedFunds = reservedFunds.sub(p.change);\r\n            }\r\n        }\r\n\r\n        ico.tokensDistributed = ico.tokensDistributed.add(p.amount);\r\n        ico.tokensOnSale = ico.tokensOnSale.sub(p.amount);\r\n        reservedTokens = reservedTokens.sub(p.amount);\r\n\r\n        if (ico.rewardedParticipants == ico.totalParticipants) {\r\n            reservedTokens = reservedTokens.sub(ico.tokensOnSale);\r\n            ico.tokensOnSale = 0;\r\n        }\r\n\r\n        //token transfer\r\n        require(forceToken.transfer(msg.sender, p.amount));\r\n\r\n        if (p.change > 0) {\r\n            //transfer change\r\n            msg.sender.transfer(p.change);\r\n        }\r\n    }\r\n\r\n    // finish current round\r\n    function finishICO() external whenActive(currentRound) onlyMasters {\r\n        ICO storage ico = ICORounds[currentRound];\r\n        //avoid mistake with date in a far future\r\n        //require(now > ico.finishTime);\r\n        ico.finalPrice = currentPrice();\r\n        tokensOnSale = 0;\r\n        ico.active = false;\r\n        if (ico.totalParticipants == 0) {\r\n            reservedTokens = reservedTokens.sub(ico.tokensOnSale);\r\n            ico.tokensOnSale = 0;\r\n\r\n        }\r\n        emit ICOFinished(currentRound);\r\n    }\r\n\r\n    // calculate participants in ico round\r\n    function calcICO(uint _fromIndex, uint _toIndex, uint _round) public whenNotActive(_round == 0 ? currentRound : _round) onlyMasters {\r\n        ICO storage ico = ICORounds[_round == 0 ? currentRound : _round];\r\n        require(ico.totalParticipants > ico.calcedParticipants);\r\n        require(_toIndex <= ico.totalParticipants);\r\n        require(_fromIndex > 0 && _fromIndex <= _toIndex);\r\n\r\n        for(uint i = _fromIndex; i <= _toIndex; i++) {\r\n            address _p = ico.participantsList[i];\r\n            Participant storage p = ico.participants[_p];\r\n            if (p.needCalc) {\r\n                p.needCalc = false;\r\n                p.amount = p.value.div(ico.finalPrice);\r\n                p.change = p.value % ico.finalPrice;\r\n                reservedFunds = reservedFunds.sub(p.value);\r\n                if (p.change > 0) {\r\n                    ico.weiRaised = ico.weiRaised.sub(p.change);\r\n                    ico.change = ico.change.add(p.change);\r\n                    //reserving\r\n                    reservedFunds = reservedFunds.add(p.change);\r\n                }\r\n                ico.reservedTokens = ico.reservedTokens.add(p.amount);\r\n                ico.calcedParticipants++;\r\n            }\r\n        }\r\n        //if last, free all unselled tokens\r\n        if (ico.calcedParticipants == ico.totalParticipants) {\r\n            reservedTokens = reservedTokens.sub(ico.tokensOnSale.sub(ico.reservedTokens));\r\n            ico.tokensOnSale = ico.reservedTokens;\r\n        }\r\n    }\r\n\r\n    // get value percent\r\n    function valueFromPercent(uint _value, uint _percent) internal pure returns (uint amount) {\r\n        uint _amount = _value.mul(_percent).div(100);\r\n        return (_amount);\r\n    }\r\n\r\n    // available funds to withdraw\r\n    function availableFunds() external view returns (uint amount) {\r\n        return address(this).balance.sub(reservedFunds);\r\n    }\r\n\r\n    //get ether amount payed by participant in specified round\r\n    function participantRoundValue(address _address, uint _round) external view returns (uint) {\r\n        ICO storage ico = ICORounds[_round == 0 ? currentRound : _round];\r\n        Participant storage p = ico.participants[_address];\r\n        return p.value;\r\n    }\r\n\r\n    //get token amount rewarded to participant in specified round\r\n    function participantRoundAmount(address _address, uint _round) external view returns (uint) {\r\n        ICO storage ico = ICORounds[_round == 0 ? currentRound : _round];\r\n        Participant storage p = ico.participants[_address];\r\n        return p.amount;\r\n    }\r\n\r\n    //is participant rewarded in specified round\r\n    function participantRoundRewarded(address _address, uint _round) external view returns (bool) {\r\n        ICO storage ico = ICORounds[_round == 0 ? currentRound : _round];\r\n        Participant storage p = ico.participants[_address];\r\n        return !p.needReward;\r\n    }\r\n\r\n    //is participant calculated in specified round\r\n    function participantRoundCalced(address _address, uint _round) external view returns (bool) {\r\n        ICO storage ico = ICORounds[_round == 0 ? currentRound : _round];\r\n        Participant storage p = ico.participants[_address];\r\n        return !p.needCalc;\r\n    }\r\n\r\n    //get participant's change in specified round\r\n    function participantRoundChange(address _address, uint _round) external view returns (uint) {\r\n        ICO storage ico = ICORounds[_round == 0 ? currentRound : _round];\r\n        Participant storage p = ico.participants[_address];\r\n        return p.change;\r\n    }\r\n\r\n    // withdraw available funds from contract\r\n    function withdrawFunds(address _to, uint _value) external onlyMasters {\r\n        require(address(this).balance.sub(reservedFunds) >= _value);\r\n        _to.transfer(_value);\r\n        emit Withdrawal(_value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"reservedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minSalePrice\",\"type\":\"uint256\"}],\"name\":\"setMinSalePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"rewardRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableFunds\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"participantRoundCalced\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensOnSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recallPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forceToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minSalePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"startICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ICORounds\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"finishTime\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"},{\"name\":\"change\",\"type\":\"uint256\"},{\"name\":\"finalPrice\",\"type\":\"uint256\"},{\"name\":\"rewardedParticipants\",\"type\":\"uint256\"},{\"name\":\"calcedParticipants\",\"type\":\"uint256\"},{\"name\":\"tokensDistributed\",\"type\":\"uint256\"},{\"name\":\"tokensOnSale\",\"type\":\"uint256\"},{\"name\":\"reservedTokens\",\"type\":\"uint256\"},{\"name\":\"totalParticipants\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAO\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"participantRoundChange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recallPercent\",\"type\":\"uint256\"}],\"name\":\"setRecallPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"name\":\"_toIndex\",\"type\":\"uint256\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"calcICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"participantRoundAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_information\",\"type\":\"string\"}],\"name\":\"setInformation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_forceTokenAddress\",\"type\":\"address\"}],\"name\":\"setForceContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"setDAO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"participantRoundValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"information\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"participantRoundRewarded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_forceTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"ICOStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"ICOFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"Recall\",\"type\":\"event\"}]","ContractName":"ForceSeller","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000437604cbefc7b83c58e6ba96d299259b74b2124a","Library":"","SwarmSource":"bzzr://be658cbd39f977f7ee81fcbd380d6ecf5600321c2cc238da44122d1375825b25"}]}