{"status":"1","message":"OK","result":[{"SourceCode":"contract BCFBaseCompetition {\r\n    address public owner;\r\n    address public referee;\r\n\r\n    bool public paused = false;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyReferee() {\r\n        require(msg.sender == referee);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setReferee(address newReferee) public onlyOwner {\r\n        require(newReferee != address(0));\r\n        referee = newReferee;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n    \r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n    \r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n    }\r\n    \r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract BCFMain {\r\n    function isOwnerOfAllPlayerCards(uint256[], address) public pure returns (bool) {}\r\n    function implementsERC721() public pure returns (bool) {}\r\n    function getPlayerForCard(uint) \r\n        external\r\n        pure\r\n        returns (\r\n        uint8,\r\n        uint8,\r\n        uint8,\r\n        uint8,\r\n        uint8,\r\n        uint8,\r\n        uint8,\r\n        uint8,\r\n        bytes,\r\n        string,\r\n        uint8\r\n    ) {}\r\n}\r\n\r\n// TODO: Validate that the user has sent the correct ENTRY_FEE and refund them if more, revert if less\r\n// TODO: Validate formation type\r\n// TODO: Validate that there's at least 1 goalkeeper?\r\n// TODO: Validate the team name is under a certain number of characters?\r\n// TODO: Do we need to copy these values across to the contract storage?\r\n// TODO: Should the frontend do the sorting and league tables? We still need the business logic to determine final positions, \r\n//       but we don't need to calculate this every round, not doing so would reduce gas consumption\r\n// TODO: Need to work out whether it's more gas effecient to read player info every round or store it once and have it?\r\ncontract BCFLeague is BCFBaseCompetition {\r\n    \r\n    struct Team {\r\n        address manager;\r\n        bytes name;\r\n        uint[] cardIds;\r\n        uint gkCardId;\r\n        uint8 wins;\r\n        uint8 losses;\r\n        uint8 draws;\r\n        uint16 goalsFor;\r\n        uint16 goalsAgainst;\r\n    }\r\n\r\n    struct Match {\r\n        uint8 homeTeamId;\r\n        uint8 awayTeamId;\r\n        uint[] homeScorerIds;\r\n        uint[] awayScorerIds;\r\n        bool isFinished;\r\n    }\r\n\r\n    // Configuration - this will be set in the constructor, hence not being constants\r\n    uint public TEAMS_TOTAL;\r\n    uint public ENTRY_FEE;\r\n    uint public SQUAD_SIZE;\r\n    uint public TOTAL_ROUNDS;\r\n    uint public MATCHES_PER_ROUND;\r\n    uint public SECONDS_BETWEEN_ROUNDS;\r\n\r\n    // Status\r\n    enum CompetitionStatuses { Upcoming, OpenForEntry, PendingStart, Started, Finished, Settled }\r\n    CompetitionStatuses public competitionStatus;\r\n    uint public startedAt;\r\n    uint public nextRoundStartsAt;\r\n    int public currentRoundId = -1; // As we may have a round 0 so we don't want to default there\r\n\r\n    // Local Data Lookups\r\n    Team[] public teams;\r\n    mapping(address => uint) internal managerToTeamId;\r\n    mapping(uint => bool) internal cardIdToEntryStatus;\r\n    mapping(uint => Match[]) internal roundIdToMatches;\r\n\r\n    // Data Source\r\n    BCFMain public mainContract;\r\n\r\n    // Prize Pool\r\n    uint public constant PRIZE_POT_PERCENTAGE_MAX = 10000; // 10,000 = 100% so we get 2 digits of precision, 375 = 3.75%\r\n    uint public prizePool; // Holds the total prize pool\r\n    uint[] public prizeBreakdown; // Max 10,000 across all indexes. Holds breakdown by index, e.g. [0] 5000 = 50%, [1] 3500 = 35%, [2] 1500 = 15%\r\n    address[] public winners; // Corresponding array of winners for the prize pot, [0] = first placed winner\r\n\r\n    function BCFLeague(address dataStoreAddress, uint teamsTotal, uint entryFee, uint squadSize, uint roundTimeSecs) public {\r\n        require(teamsTotal % 2 == 0); // We only allow an even number of teams, this reduces complexity\r\n        require(teamsTotal > 0);\r\n        require(roundTimeSecs > 30 seconds && roundTimeSecs < 60 minutes);\r\n        require(entryFee >= 0);\r\n        require(squadSize > 0);\r\n        \r\n        // Initial state\r\n        owner = msg.sender;\r\n        referee = msg.sender;\r\n        \r\n        // League configuration\r\n        TEAMS_TOTAL = teamsTotal;\r\n        ENTRY_FEE = entryFee;\r\n        SQUAD_SIZE = squadSize;\r\n        TOTAL_ROUNDS = TEAMS_TOTAL - 1;\r\n        MATCHES_PER_ROUND = TEAMS_TOTAL / 2;\r\n        SECONDS_BETWEEN_ROUNDS = roundTimeSecs;\r\n\r\n        // Always start it as an upcoming league\r\n        competitionStatus = CompetitionStatuses.Upcoming;\r\n\r\n        // Set the data source\r\n        BCFMain candidateDataStoreContract = BCFMain(dataStoreAddress);\r\n        require(candidateDataStoreContract.implementsERC721());\r\n        mainContract = candidateDataStoreContract;\r\n    }\r\n\r\n    // **Gas guzzler**\r\n    // CURRENT GAS CONSUMPTION: 6339356\r\n    function generateFixtures() external onlyOwner {\r\n        require(competitionStatus == CompetitionStatuses.Upcoming);\r\n\r\n        // Generate the fixtures using a cycling algorithm:\r\n        for (uint round = 0; round < TOTAL_ROUNDS; round++) {\r\n            for (uint matchIndex = 0; matchIndex < MATCHES_PER_ROUND; matchIndex++) {\r\n                uint home = (round + matchIndex) % (TEAMS_TOTAL - 1);\r\n                uint away = (TEAMS_TOTAL - 1 - matchIndex + round) % (TEAMS_TOTAL - 1);\r\n\r\n                if (matchIndex == 0) {\r\n                    away = TEAMS_TOTAL - 1;\r\n                }\r\n\r\n                 Match memory _match;\r\n                 _match.homeTeamId = uint8(home);\r\n                 _match.awayTeamId = uint8(away);\r\n\r\n                roundIdToMatches[round].push(_match);\r\n            }\r\n        }\r\n    }\r\n\r\n    function createPrizePool(uint[] prizeStructure) external payable onlyOwner {\r\n        require(competitionStatus == CompetitionStatuses.Upcoming);\r\n        require(msg.value > 0 && msg.value <= 2 ether); // Set some sensible top and bottom values\r\n        require(prizeStructure.length > 0); // Can't create a prize pool with no breakdown structure\r\n\r\n        uint allocationTotal = 0;\r\n        for (uint i = 0; i < prizeStructure.length; i++) {\r\n            allocationTotal += prizeStructure[i];\r\n        }\r\n\r\n        require(allocationTotal > 0 && allocationTotal <= PRIZE_POT_PERCENTAGE_MAX); // Make sure we don't allocate more than 100% of the prize pool or 0%\r\n        prizePool += msg.value;\r\n        prizeBreakdown = prizeStructure;\r\n    }\r\n\r\n    function openCompetition() external onlyOwner whenNotPaused {\r\n        competitionStatus = CompetitionStatuses.OpenForEntry;\r\n    }\r\n\r\n    function startCompetition() external onlyReferee whenNotPaused {\r\n        require(competitionStatus == CompetitionStatuses.PendingStart);\r\n\r\n        // Move the status into Started\r\n        competitionStatus = CompetitionStatuses.Started;\r\n        \r\n        // Mark the startedAt to now\r\n        startedAt = now;\r\n        nextRoundStartsAt = now + 60 seconds;\r\n    }\r\n\r\n    function calculateMatchOutcomesForRoundId(int roundId) external onlyReferee whenNotPaused {\r\n        require(competitionStatus == CompetitionStatuses.Started);\r\n        require(nextRoundStartsAt > 0);\r\n        require(roundId == currentRoundId + 1); // We're only allowed to process the next round, we can't skip ahead\r\n        require(now > nextRoundStartsAt);\r\n\r\n        // Increment the round counter\r\n        // We complete the below first as during the calculateScorersForTeamIds we go off to another contract to fetch the \r\n        // current player attributes so to avoid re-entrancy we bump this first \r\n        currentRoundId++;\r\n\r\n        // As the total rounds aren't index based we need to compare it to the index+1\r\n        // this should never overrun as the gas cost of generating a league with more 20 teams makes this impossible\r\n        if (TOTAL_ROUNDS == uint(currentRoundId + 1)) {\r\n            competitionStatus = CompetitionStatuses.Finished;\r\n        } else {\r\n            nextRoundStartsAt = now + SECONDS_BETWEEN_ROUNDS;\r\n        }\r\n\r\n        // Actually calculate some of the outcomes \r\n        Match[] memory matches = roundIdToMatches[uint(roundId)];\r\n        for (uint i = 0; i < matches.length; i++) {\r\n            Match memory _match = matches[i];\r\n            var (homeScorers, awayScorers) = calculateScorersForTeamIds(_match.homeTeamId, _match.awayTeamId);\r\n\r\n            // Adjust the table values\r\n            updateTeamsTableAttributes(_match.homeTeamId, homeScorers.length, _match.awayTeamId, awayScorers.length);\r\n\r\n            // Save the goal scorers for this match and mark as finished\r\n            roundIdToMatches[uint(roundId)][i].isFinished = true;\r\n            roundIdToMatches[uint(roundId)][i].homeScorerIds = homeScorers;\r\n            roundIdToMatches[uint(roundId)][i].awayScorerIds = awayScorers;\r\n        }\r\n    }\r\n\r\n    function updateTeamsTableAttributes(uint homeTeamId, uint homeGoals, uint awayTeamId, uint awayGoals) internal {\r\n\r\n        // GOALS FOR\r\n        teams[homeTeamId].goalsFor += uint16(homeGoals);\r\n        teams[awayTeamId].goalsFor += uint16(awayGoals);\r\n\r\n        // GOALS AGAINST\r\n        teams[homeTeamId].goalsAgainst += uint16(awayGoals);\r\n        teams[awayTeamId].goalsAgainst += uint16(homeGoals);\r\n\r\n        // WINS / LOSSES / DRAWS\r\n        if (homeGoals == awayGoals) {            \r\n            teams[homeTeamId].draws++;\r\n            teams[awayTeamId].draws++;\r\n        } else if (homeGoals > awayGoals) {\r\n            teams[homeTeamId].wins++;\r\n            teams[awayTeamId].losses++;\r\n        } else {\r\n            teams[awayTeamId].wins++;\r\n            teams[homeTeamId].losses++;\r\n        }\r\n    }\r\n\r\n    function getAllMatchesForRoundId(uint roundId) public view returns (uint[], uint[], bool[]) {\r\n        Match[] memory matches = roundIdToMatches[roundId];\r\n        \r\n        uint[] memory _homeTeamIds = new uint[](matches.length);\r\n        uint[] memory _awayTeamIds = new uint[](matches.length);\r\n        bool[] memory matchStates = new bool[](matches.length);\r\n\r\n        for (uint i = 0; i < matches.length; i++) {\r\n            _homeTeamIds[i] = matches[i].homeTeamId;\r\n            _awayTeamIds[i] = matches[i].awayTeamId;\r\n            matchStates[i] = matches[i].isFinished;\r\n        }\r\n\r\n        return (_homeTeamIds, _awayTeamIds, matchStates);\r\n    }\r\n\r\n    function getMatchAtRoundIdAtIndex(uint roundId, uint index) public view returns (uint, uint, uint[], uint[], bool) {\r\n        Match[] memory matches = roundIdToMatches[roundId];\r\n        Match memory _match = matches[index];\r\n        return (_match.homeTeamId, _match.awayTeamId, _match.homeScorerIds, _match.awayScorerIds, _match.isFinished);\r\n    }\r\n\r\n    function getPlayerCardIdsForTeam(uint teamId) public view returns (uint[]) {\r\n        Team memory _team = teams[teamId];\r\n        return _team.cardIds;\r\n    }\r\n\r\n    function enterLeague(uint[] cardIds, uint gkCardId, bytes teamName) public payable whenNotPaused {\r\n        require(mainContract != address(0)); // Must have a valid data store to check card ownership\r\n        require(competitionStatus == CompetitionStatuses.OpenForEntry); // Competition must be open for entry\r\n        require(cardIds.length == SQUAD_SIZE); // Require a valid number of players\r\n        require(teamName.length > 3 && teamName.length < 18); // Require a valid team name\r\n        require(!hasEntered(msg.sender)); // Make sure the address hasn't already entered\r\n        require(!hasPreviouslyEnteredCardIds(cardIds)); // Require that none of the players have previously entered, avoiding managers swapping players between accounts\r\n        require(mainContract.isOwnerOfAllPlayerCards(cardIds, msg.sender)); // User must actually own these cards\r\n        require(teams.length < TEAMS_TOTAL); // We shouldn't ever hit this as the state should be managed, but just as a fallback\r\n        require(msg.value >= ENTRY_FEE); // User must have paid a valid entry fee\r\n\r\n        // Create a team and hold the teamId\r\n        Team memory _team;\r\n        _team.name = teamName;\r\n        _team.manager = msg.sender;\r\n        _team.cardIds = cardIds;\r\n        _team.gkCardId = gkCardId;\r\n        uint teamId = teams.push(_team) - 1;\r\n\r\n        // Keep track of who the manager is managing\r\n        managerToTeamId[msg.sender] = teamId;\r\n\r\n        // Track which team each card plays for\r\n        for (uint i = 0; i < cardIds.length; i++) {\r\n            cardIdToEntryStatus[cardIds[i]] = true;\r\n        }\r\n\r\n        // If we've hit the team limit we can move the contract into the PendingStart status\r\n        if (teams.length == TEAMS_TOTAL) {\r\n            competitionStatus = CompetitionStatuses.PendingStart;\r\n        }\r\n    }\r\n\r\n    function hasPreviouslyEnteredCardIds(uint[] cardIds) view internal returns (bool) {\r\n        if (teams.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        // This should only ever be a maximum of 5 iterations or 11\r\n        for (uint i = 0; i < cardIds.length; i++) {\r\n            uint cardId = cardIds[i];\r\n            bool hasEnteredCardPreviously = cardIdToEntryStatus[cardId];\r\n            if (hasEnteredCardPreviously) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function hasEntered(address manager) view internal returns (bool) {\r\n        if (teams.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        // We have to lookup the team AND check the fields because of some of the workings of solidity\r\n        // 1. We could have a team at index 0, so we CAN'T just check the index is > 0\r\n        // 2. Solidity intializes with an empty set of struct values, so we need to do equality on the manager field\r\n        uint teamIndex = managerToTeamId[manager];\r\n        Team memory team = teams[teamIndex];\r\n        if (team.manager == manager) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function setMainContract(address _address) external onlyOwner {\r\n        BCFMain candidateContract = BCFMain(_address);\r\n        require(candidateContract.implementsERC721());\r\n        mainContract = candidateContract;\r\n    }\r\n\r\n    // ** Match Simulator **\r\n    function calculateScorersForTeamIds(uint homeTeamId, uint awayTeamId) internal view returns (uint[], uint[]) {\r\n        \r\n        var (homeTotals, homeCardsShootingAttributes) = calculateAttributeTotals(homeTeamId);\r\n        var (awayTotals, awayCardsShootingAttributes) = calculateAttributeTotals(awayTeamId); \r\n        \r\n        uint startSeed = now;\r\n        var (homeGoals, awayGoals) = calculateGoalsFromAttributeTotals(homeTeamId, awayTeamId, homeTotals, awayTotals, startSeed);\r\n\r\n        uint[] memory homeScorers = new uint[](homeGoals);\r\n        uint[] memory awayScorers = new uint[](awayGoals);\r\n\r\n        // Home Scorers\r\n        for (uint i = 0; i < homeScorers.length; i++) {\r\n            homeScorers[i] = determineGoalScoringCardIds(teams[homeTeamId].cardIds, homeCardsShootingAttributes, i);\r\n        }\r\n\r\n        // Away Scorers\r\n        for (i = 0; i < awayScorers.length; i++) {\r\n            awayScorers[i] = determineGoalScoringCardIds(teams[awayTeamId].cardIds, awayCardsShootingAttributes, i);\r\n        }\r\n\r\n        return (homeScorers, awayScorers);\r\n    }\r\n\r\n    function calculateGoalsFromAttributeTotals(uint homeTeamId, uint awayTeamId, uint[] homeTotals, uint[] awayTotals, uint startSeed) internal view returns (uint _homeGoals, uint _awayGoals) {\r\n\r\n        uint[] memory atkAttributes = new uint[](3); // 0 = possession, 1 = chance, 2 = shooting\r\n        uint[] memory defAttributes = new uint[](3); // 0 = regain posession, 1 = prevent chance, 3 = save shot\r\n\r\n        uint attackingTeamId = 0;\r\n        uint defendingTeamId = 0;\r\n        uint outcome = 0;\r\n        uint seed = startSeed * homeTotals[0] * awayTotals[0];\r\n\r\n        for (uint i = 0; i < 45; i++) {\r\n            \r\n            attackingTeamId = determineAttackingOrDefendingOutcomeForAttributes(homeTeamId, awayTeamId, homeTotals[0], awayTotals[0], seed+now);\r\n            seed++;\r\n\r\n            if (attackingTeamId == homeTeamId) {\r\n                defendingTeamId = awayTeamId;\r\n                atkAttributes[0] = homeTotals[3]; // Passing\r\n                atkAttributes[1] = homeTotals[4]; // Dribbling\r\n                atkAttributes[2] = homeTotals[2]; // Shooting\r\n                defAttributes[0] = awayTotals[1]; // Pace\r\n                defAttributes[1] = awayTotals[6]; // Physical\r\n                defAttributes[2] = awayTotals[5]; // Defending\r\n            } else {\r\n                defendingTeamId = homeTeamId;\r\n                atkAttributes[0] = awayTotals[3]; // Passing\r\n                atkAttributes[1] = awayTotals[4]; // Dribbling\r\n                atkAttributes[2] = awayTotals[2]; // Shooting\r\n                defAttributes[0] = homeTotals[1]; // Pace\r\n                defAttributes[1] = homeTotals[6]; // Physical\r\n                defAttributes[2] = homeTotals[5]; // Defending\r\n            }\r\n\r\n            outcome = determineAttackingOrDefendingOutcomeForAttributes(attackingTeamId, defendingTeamId, atkAttributes[0], defAttributes[0], seed);\r\n\t\t\tif (outcome == defendingTeamId) {\r\n                // Attack broken up\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n            seed++;\r\n\r\n            outcome = determineAttackingOrDefendingOutcomeForAttributes(attackingTeamId, defendingTeamId, atkAttributes[1], defAttributes[1], seed);\r\n\t\t\tif (outcome == defendingTeamId) {\r\n                // Chance prevented\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n            seed++;\r\n\r\n            outcome = determineAttackingOrDefendingOutcomeForAttributes(attackingTeamId, defendingTeamId, atkAttributes[2], defAttributes[2], seed);\r\n\t\t\tif (outcome == defendingTeamId) {\r\n                // Shot saved\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n            // GOAL - determine whether it was the home team who scored or the away team\r\n            if (attackingTeamId == homeTeamId) {\r\n                // Home goal\r\n                _homeGoals += 1;\r\n            } else {\r\n                // Away goal\r\n                _awayGoals += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateAttributeTotals(uint teamId) internal view returns (uint[], uint[]) {\r\n        \r\n        // NOTE: We store these in an array because of stack too deep errors from Solidity, \r\n        // We could seperate these out but in the end it will end up being uniweildly\r\n        // this is the case in subsquent arrays too, while not perfect does give us a bit more flexibility\r\n        uint[] memory totals = new uint[](7);\r\n        uint[] memory cardsShootingAttributes = new uint[](SQUAD_SIZE);\r\n        Team memory _team = teams[teamId];\r\n        \r\n        for (uint i = 0; i < SQUAD_SIZE; i++) {\r\n            var (overall,pace,shooting,passing,dribbling,defending,physical,,,,) = mainContract.getPlayerForCard(_team.cardIds[i]);\r\n\r\n            // If it's a goalie we forego attack for increased shot stopping avbility\r\n            if (_team.cardIds[i] == _team.gkCardId && _team.gkCardId > 0) {\r\n                totals[5] += (overall * 5);\r\n                totals[6] += overall;\r\n                cardsShootingAttributes[i] = 1; // Almost no chance for the GK to score\r\n            } else {\r\n                totals[0] += overall;\r\n                totals[1] += pace;\r\n                totals[2] += shooting;\r\n                totals[3] += passing;\r\n                totals[4] += dribbling;\r\n                totals[5] += defending;\r\n                totals[6] += physical;\r\n\r\n                cardsShootingAttributes[i] = shooting + dribbling; // Chance to score by combining shooting and dribbling\r\n            }\r\n        }\r\n\r\n        return (totals, cardsShootingAttributes);\r\n    }\r\n\r\n    function determineAttackingOrDefendingOutcomeForAttributes(uint attackingTeamId, uint defendingTeamId, uint atkAttributeTotal, uint defAttributeTotal, uint seed) internal view returns (uint) {\r\n        \r\n        uint max = atkAttributeTotal + defAttributeTotal;\r\n        uint randValue = uint(keccak256(block.blockhash(block.number-1), seed))%max;\r\n\r\n        if (randValue <= atkAttributeTotal) {\r\n\t\t    return attackingTeamId;\r\n\t    }\r\n\r\n\t    return defendingTeamId;\r\n    }\r\n\r\n    function determineGoalScoringCardIds(uint[] cardIds, uint[] shootingAttributes, uint seed) internal view returns(uint) {\r\n\r\n        uint max = 0;\r\n        uint min = 0;\r\n        for (uint i = 0; i < shootingAttributes.length; i++) {\r\n            max += shootingAttributes[i];\r\n        }\r\n\r\n        bytes32 randHash = keccak256(seed, now, block.blockhash(block.number - 1));\r\n        uint randValue = uint(randHash) % max + min;\r\n\r\n        for (i = 0; i < cardIds.length; i++) {\r\n            uint cardId = cardIds[i];\r\n            randValue -= shootingAttributes[i];\r\n\r\n            // We do the more than to handle wrap arounds on uint\r\n            if (randValue <= 0 || randValue >= max) {\r\n                return cardId;\r\n            }\r\n        }\r\n\r\n        return cardIds[0];\r\n    }\r\n\r\n    // ** Settlement **\r\n    function calculateWinningEntries() external onlyReferee {\r\n        require(competitionStatus == CompetitionStatuses.Finished);\r\n\r\n        address[] memory winningAddresses = new address[](prizeBreakdown.length);\r\n        uint[] memory winningTeamIds = new uint[](prizeBreakdown.length);\r\n        uint[] memory winningTeamPoints = new uint[](prizeBreakdown.length);\r\n\r\n        // League table position priority\r\n        // 1. Most Points\r\n        // 2. Biggest Goal Difference\r\n        // 3. Most Goals Scored\r\n        // 4. Number of Wins\r\n        // 5. First to Enter\r\n\r\n        // 1. Loop over all teams\r\n        bool isReplacementWinner = false;\r\n        for (uint i = 0; i < teams.length; i++) {\r\n            Team memory _team = teams[i];\r\n\r\n            // 2. Grab their current points\r\n            uint currPoints = (_team.wins * 3) + _team.draws;\r\n\r\n            // 3. Compare the points to each team in the winning team points array\r\n            for (uint x = 0; x < winningTeamPoints.length; x++) {\r\n                \r\n                // 4. Check if the current entry is more\r\n                isReplacementWinner = false;\r\n                if (currPoints > winningTeamPoints[x]) {\r\n                    isReplacementWinner = true;\r\n                // 5. We need to handle tie-break rules if 2 teams have the same number of points\r\n                } else if (currPoints == winningTeamPoints[x]) {\r\n                    \r\n                    // 5a. Unfortunately in this scenario we need to refetch the team we're comparing\r\n                    Team memory _comparisonTeam = teams[winningTeamIds[x]];\r\n\r\n                    int gdTeam = _team.goalsFor - _team.goalsAgainst;\r\n                    int gdComparedTeam = _comparisonTeam.goalsFor - _comparisonTeam.goalsAgainst;\r\n\r\n                    // 5b. GOAL DIFFERENCE\r\n                    if (gdTeam > gdComparedTeam) {\r\n                        isReplacementWinner = true;\r\n                    } else if (gdTeam == gdComparedTeam) {\r\n\r\n                        // 5c. MOST GOALS\r\n                        if (_team.goalsFor > _comparisonTeam.goalsFor) {\r\n                            isReplacementWinner = true;\r\n                        } else if (_team.goalsFor == _comparisonTeam.goalsFor) {\r\n\r\n                            // 5d. NUMBER OF WINS\r\n                            if (_team.wins > _comparisonTeam.wins) {\r\n                                isReplacementWinner = true;\r\n                            } else if (_team.wins == _comparisonTeam.wins) {\r\n\r\n                                // 5e. FIRST TO ENTER (LOWER INDEX)\r\n                                if (i < winningTeamIds[x]) {\r\n                                    isReplacementWinner = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // 6. Now we need to shift all elements down for the \"paid places\" for winning entries\r\n                if (isReplacementWinner) {\r\n                    \r\n                    // 7. We need to start by copying the current index into next one down, assuming it exists\r\n                    for (uint y = winningAddresses.length - 1; y > x; y--) {\r\n                        winningAddresses[y] = winningAddresses[y-1];\r\n                        winningTeamPoints[y] = winningTeamPoints[y-1];\r\n                        winningTeamIds[y] = winningTeamIds[y-1];\r\n                    }\r\n                    \r\n                    // 8. Set the current team and points as a replacemenet for the current entry\r\n                    winningAddresses[x] = _team.manager;\r\n                    winningTeamPoints[x] = currPoints;\r\n                    winningTeamIds[x] = i;\r\n                    break; // We don't need to compare values further down the chain\r\n                }\r\n            }\r\n        }\r\n\r\n        // Set the winning entries\r\n        winners = winningAddresses;\r\n    }\r\n\r\n    function settleLeague() external onlyOwner {\r\n        require(competitionStatus == CompetitionStatuses.Finished);\r\n        require(winners.length > 0);\r\n        require(prizeBreakdown.length == winners.length);\r\n        require(prizePool >= this.balance);\r\n\r\n        // Mark the contest as settled\r\n        competitionStatus = CompetitionStatuses.Settled;\r\n        \r\n        // Payout each winner\r\n        for (uint i = 0; i < winners.length; i++) {\r\n            address winner = winners[i];\r\n            uint percentageCut = prizeBreakdown[i]; // We can assume this index exists as we've checked the lengths in the require\r\n\r\n            uint winningAmount = calculateWinnerCut(prizePool, percentageCut);\r\n            winner.transfer(winningAmount);\r\n        }\r\n    }\r\n\r\n    function calculateWinnerCut(uint totalPot, uint cut) internal pure returns (uint256) {\r\n        // PRIZE_POT_PERCENTAGE_MAX = 10,000 = 100%, required'd <= PRIZE_POT_PERCENTAGE_MAX in the constructor so no requirement to validate here\r\n        uint finalCut = totalPot * cut / PRIZE_POT_PERCENTAGE_MAX;\r\n        return finalCut;\r\n    }  \r\n\r\n    function withdrawBalance() external onlyOwner {\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    // Utils\r\n    function hasStarted() external view returns (bool) {\r\n        if (competitionStatus == CompetitionStatuses.Upcoming || competitionStatus == CompetitionStatuses.OpenForEntry || competitionStatus == CompetitionStatuses.PendingStart) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function winningTeamId() external view returns (uint) {\r\n        require(competitionStatus == CompetitionStatuses.Finished || competitionStatus == CompetitionStatuses.Settled);\r\n\r\n        uint winningTeamId = 0;\r\n        for (uint i = 0; i < teams.length; i++) {\r\n            if (teams[i].manager == winners[0]) {\r\n                winningTeamId = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return winningTeamId;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getAllMatchesForRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SQUAD_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prizeBreakdown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"competitionStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardIds\",\"type\":\"uint256[]\"},{\"name\":\"gkCardId\",\"type\":\"uint256\"},{\"name\":\"teamName\",\"type\":\"bytes\"}],\"name\":\"enterLeague\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextRoundStartsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referee\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMainContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teams\",\"outputs\":[{\"name\":\"manager\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes\"},{\"name\":\"gkCardId\",\"type\":\"uint256\"},{\"name\":\"wins\",\"type\":\"uint8\"},{\"name\":\"losses\",\"type\":\"uint8\"},{\"name\":\"draws\",\"type\":\"uint8\"},{\"name\":\"goalsFor\",\"type\":\"uint16\"},{\"name\":\"goalsAgainst\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SECONDS_BETWEEN_ROUNDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"getPlayerCardIdsForTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAMS_TOTAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settleLeague\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRIZE_POT_PERCENTAGE_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calculateWinningEntries\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roundId\",\"type\":\"int256\"}],\"name\":\"calculateMatchOutcomesForRoundId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prizeStructure\",\"type\":\"uint256[]\"}],\"name\":\"createPrizePool\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openCompetition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newReferee\",\"type\":\"address\"}],\"name\":\"setReferee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_ROUNDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCompetition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningTeamId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getMatchAtRoundIdAtIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ENTRY_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MATCHES_PER_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"generateFixtures\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"dataStoreAddress\",\"type\":\"address\"},{\"name\":\"teamsTotal\",\"type\":\"uint256\"},{\"name\":\"entryFee\",\"type\":\"uint256\"},{\"name\":\"squadSize\",\"type\":\"uint256\"},{\"name\":\"roundTimeSecs\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"BCFLeague","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006abf810730a342add1374e11f3e97500ee774d1f00000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000004b0","Library":"","SwarmSource":"bzzr://74210e2a379715eb94b5b5dc00794e0695a9585a0738a33026b79691b459f10f"}]}