{"status":"1","message":"OK","result":[{"SourceCode":"// hevm: flattened sources of src/LightPoolWrapper.sol\r\npragma solidity ^0.4.21;\r\n\r\n////// lib/ds-roles/lib/ds-auth/src/auth.sol\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/lightpool-contracts/src/interfaces/ERC20.sol\r\n/* pragma solidity ^0.4.21; */\r\n\r\ncontract ERC20Events {\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n}\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function decimals() public view returns (uint);\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address guy) public view returns (uint);\r\n    function allowance(address src, address guy) public view returns (uint);\r\n\r\n    function approve(address guy, uint wad) public returns (bool);\r\n    function transfer(address dst, uint wad) public returns (bool);\r\n    function transferFrom(address src, address dst, uint wad) public returns (bool);\r\n}\r\n\r\n////// lib/lightpool-contracts/src/interfaces/PriceSanityInterface.sol\r\n/* pragma solidity ^0.4.21; */\r\n\r\ncontract PriceSanityInterface {\r\n    function checkPrice(address base, address quote, bool buy, uint256 baseAmount, uint256 quoteAmount) external view returns (bool result);\r\n}\r\n\r\n////// lib/lightpool-contracts/src/interfaces/WETHInterface.sol\r\n/* pragma solidity ^0.4.21; */\r\n\r\n/* import \"./ERC20.sol\"; */\r\n\r\ncontract WETHInterface is ERC20 {\r\n  function() external payable;\r\n  function deposit() external payable;\r\n  function withdraw(uint wad) external;\r\n}\r\n\r\n////// lib/lightpool-contracts/src/LightPool.sol\r\n/* pragma solidity ^0.4.21; */\r\n\r\n/* import \"./interfaces/WETHInterface.sol\"; */\r\n/* import \"./interfaces/PriceSanityInterface.sol\"; */\r\n/* import \"./interfaces/ERC20.sol\"; */\r\n\r\ncontract LightPool {\r\n    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\r\n\r\n    struct TokenData {\r\n        address walletAddress;\r\n        PriceSanityInterface priceSanityContract;\r\n    }\r\n\r\n    // key = keccak256(token, base, walletAddress)\r\n    mapping(bytes32 => TokenData)       public markets;\r\n    mapping(address => bool)            public traders;\r\n    address                             public owner;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWalletAddress(address base, address quote) {\r\n        bytes32 key = keccak256(base, quote, msg.sender);\r\n        require(markets[key].walletAddress == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTrader() {\r\n        require(traders[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function LightPool() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setTrader(address trader, bool enabled) onlyOwner external {\r\n        traders[trader] = enabled;\r\n    }\r\n\r\n    function setOwner(address _owner) onlyOwner external {\r\n        require(_owner != address(0));\r\n        owner = _owner;\r\n    }\r\n\r\n    event AddMarket(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\r\n    function addMarket(ERC20 base, ERC20 quote, PriceSanityInterface priceSanityContract) external {\r\n        require(base != address(0));\r\n        require(quote != address(0));\r\n\r\n        // Make sure there's no such configured token\r\n        bytes32 tokenHash = keccak256(base, quote, msg.sender);\r\n        require(markets[tokenHash].walletAddress == address(0));\r\n\r\n        // Initialize token pool data\r\n        markets[tokenHash] = TokenData(msg.sender, priceSanityContract);\r\n        emit AddMarket(base, quote, msg.sender, priceSanityContract);\r\n    }\r\n\r\n    event RemoveMarket(address indexed base, address indexed quote, address indexed walletAddress);\r\n    function removeMarket(ERC20 base, ERC20 quote) onlyWalletAddress(base, quote) external {\r\n        bytes32 tokenHash = keccak256(base, quote, msg.sender);\r\n        TokenData storage tokenData = markets[tokenHash];\r\n\r\n        emit RemoveMarket(base, quote, tokenData.walletAddress);\r\n        delete markets[tokenHash];\r\n    }\r\n\r\n    event ChangePriceSanityContract(address indexed base, address indexed quote, address indexed walletAddress, address priceSanityContract);\r\n    function changePriceSanityContract(ERC20 base, ERC20 quote, PriceSanityInterface _priceSanityContract) onlyWalletAddress(base, quote) external {\r\n        bytes32 tokenHash = keccak256(base, quote, msg.sender);\r\n        TokenData storage tokenData = markets[tokenHash];\r\n        tokenData.priceSanityContract = _priceSanityContract;\r\n        emit ChangePriceSanityContract(base, quote, msg.sender, _priceSanityContract);\r\n    }\r\n\r\n    event Trade(address indexed trader, address indexed baseToken, address indexed quoteToken, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount);\r\n    function trade(ERC20 base, ERC20 quote, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount) onlyTrader external {\r\n        bytes32 tokenHash = keccak256(base, quote, walletAddress);\r\n        TokenData storage tokenData = markets[tokenHash];\r\n        require(tokenData.walletAddress != address(0));\r\n        if (tokenData.priceSanityContract != address(0)) {\r\n            require(tokenData.priceSanityContract.checkPrice.gas(EXTERNAL_QUERY_GAS_LIMIT)(base, quote, buy, baseAmount, quoteAmount)); // Limit gas to prevent reentrancy\r\n        }\r\n        ERC20 takenToken;\r\n        ERC20 givenToken;\r\n        uint256 takenTokenAmount;\r\n        uint256 givenTokenAmount;\r\n        if (buy) {\r\n            takenToken = quote;\r\n            givenToken = base;\r\n            takenTokenAmount = quoteAmount;\r\n            givenTokenAmount = baseAmount;\r\n        } else {\r\n            takenToken = base;\r\n            givenToken = quote;\r\n            takenTokenAmount = baseAmount;\r\n            givenTokenAmount = quoteAmount;\r\n        }\r\n        require(takenTokenAmount != 0 && givenTokenAmount != 0);\r\n\r\n        // Swap!\r\n        require(takenToken.transferFrom(msg.sender, tokenData.walletAddress, takenTokenAmount));\r\n        require(givenToken.transferFrom(tokenData.walletAddress, msg.sender, givenTokenAmount));\r\n        emit Trade(msg.sender, base, quote, walletAddress, buy, baseAmount, quoteAmount);\r\n    }\r\n}\r\n\r\n////// lib/lpc/lib/ds-token/lib/ds-math/src/math.sol\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n////// lib/lpc/lib/ds-token/lib/ds-stop/lib/ds-note/src/note.sol\r\n/// note.sol -- the `note' modifier, for logging calls as events\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n////// lib/lpc/lib/ds-value/lib/ds-thing/src/thing.sol\r\n// thing.sol - `auth` with handy mixins. your things should be DSThings\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity ^0.4.13; */\r\n\r\n/* import 'ds-auth/auth.sol'; */\r\n/* import 'ds-note/note.sol'; */\r\n/* import 'ds-math/math.sol'; */\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(s));\r\n    }\r\n\r\n}\r\n\r\n////// src/LightPoolWrapper.sol\r\n/* pragma solidity ^0.4.21; */\r\n\r\n/* import \"ds-thing/thing.sol\"; */\r\n/* import \"lightpool-contracts/LightPool.sol\"; */\r\n\r\ncontract WETH is WETHInterface { }\r\n\r\ncontract LightPoolWrapper is DSThing {\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n\r\n    address public reserve;\r\n    LightPool public lightpool;\r\n    mapping(address => bool) public whitelistedWallets;\r\n\r\n    function LightPoolWrapper(address reserve_, LightPool lightpool_) public {\r\n        assert(address(reserve_) != 0);\r\n        assert(address(lightpool_) != 0);\r\n\r\n        reserve = reserve_;\r\n        lightpool = lightpool_;\r\n    }\r\n\r\n    function switchLightPool(LightPool lightpool_) public note auth {\r\n        assert(address(lightpool_) != 0);\r\n        lightpool = lightpool_;\r\n    }\r\n\r\n    function switchReserve(address reserve_) public note auth {\r\n        assert(address(reserve_) != 0);\r\n        reserve = reserve_;\r\n    }\r\n\r\n    function approveToken(ERC20 token, address spender, uint amount) public note auth {\r\n        require(token.approve(spender, amount));\r\n    }\r\n\r\n    function setWhitelistedWallet(address walletAddress_, bool whitelisted) public note auth {\r\n        whitelistedWallets[walletAddress_] = whitelisted;\r\n    }\r\n\r\n    event Trade(\r\n        address indexed origin,\r\n        address indexed srcToken,\r\n        uint srcAmount,\r\n        address indexed destToken,\r\n        uint destAmount,\r\n        address destAddress\r\n    );\r\n\r\n    function trade(ERC20 base, ERC20 quote, address walletAddress, bool buy, uint256 baseAmount, uint256 quoteAmount) public auth {\r\n        require(whitelistedWallets[walletAddress]);\r\n\r\n        ERC20 takenToken;\r\n        uint takenAmount;\r\n        ERC20 givenToken;\r\n        uint givenAmount;\r\n\r\n        if (buy) {\r\n            takenToken = base;\r\n            takenAmount = baseAmount;\r\n            givenToken = quote;\r\n            givenAmount = quoteAmount;\r\n        } else {\r\n            takenToken = quote;\r\n            takenAmount = quoteAmount;\r\n            givenToken = base;\r\n            givenAmount = baseAmount;\r\n        }\r\n\r\n        require(givenToken.transferFrom(reserve, this, givenAmount));\r\n        lightpool.trade(base, quote, walletAddress, buy, baseAmount, quoteAmount);\r\n        require(takenToken.transfer(reserve, takenAmount));\r\n\r\n        emit Trade(reserve, givenToken, givenAmount, takenToken, takenAmount, walletAddress);\r\n    }\r\n\r\n    function withdraw(ERC20 token, uint amount, address destination) public note auth {\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(token.transfer(destination, amount));\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lightpool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reserve_\",\"type\":\"address\"}],\"name\":\"switchReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"walletAddress_\",\"type\":\"address\"},{\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"setWhitelistedWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"base\",\"type\":\"address\"},{\"name\":\"quote\",\"type\":\"address\"},{\"name\":\"walletAddress\",\"type\":\"address\"},{\"name\":\"buy\",\"type\":\"bool\"},{\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"name\":\"quoteAmount\",\"type\":\"uint256\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lightpool_\",\"type\":\"address\"}],\"name\":\"switchLightPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"reserve_\",\"type\":\"address\"},{\"name\":\"lightpool_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"destAddress\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"LightPoolWrapper","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006924a03bb710eaf199ab6ac9f2bb148215ae9b5d00000000000000000000000051982b5b159ae4ce54ba40f1c7f8cf2091903c10","Library":"","SwarmSource":"bzzr://3ee1fe1e0915e08da0456218342a4470cea92b1def19b7fd04c9f321c5da9c19"}]}