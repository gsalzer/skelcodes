{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic token) external onlyOwner {\r\n    uint256 balance = token.balanceOf(this);\r\n    token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n\r\n/// @dev Implements access control to the DWorld contract.\r\ncontract BurnupGameAccessControl is Claimable, Pausable, CanReclaimToken {\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n    \r\n    function BurnupGameAccessControl() public {\r\n        // The creator of the contract is the initial CFO.\r\n        cfoAddress = msg.sender;\r\n    \r\n        // The creator of the contract is the initial COO.\r\n        cooAddress = msg.sender;\r\n    }\r\n    \r\n    /// @dev Access modifier for CFO-only functionality.\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n    \r\n    /// @dev Access modifier for COO-only functionality.\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current contract owner.\r\n    /// @param _newCFO The address of the new CFO.\r\n    function setCFO(address _newCFO) external onlyOwner {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n    \r\n    /// @dev Assigns a new address to act as the COO. Only available to the current contract owner.\r\n    /// @param _newCOO The address of the new COO.\r\n    function setCOO(address _newCOO) external onlyOwner {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n}\r\n\r\n\r\n/// @dev Defines base data structures for DWorld.\r\ncontract BurnupGameBase is BurnupGameAccessControl {\r\n    using SafeMath for uint256;\r\n    \r\n    event NextGame(uint256 rows, uint256 cols, uint256 activityTimer, uint256 unclaimedTilePrice, uint256 buyoutReferralBonusPercentage, uint256 buyoutPrizePoolPercentage, uint256 buyoutDividendPercentage, uint256 buyoutFeePercentage);\r\n    event Start(uint256 indexed gameIndex, address indexed starter, uint256 timestamp, uint256 prizePool, uint256 rows, uint256 cols, uint256 activityTimer, uint256 unclaimedTilePrice, uint256 buyoutReferralBonusPercentage, uint256 buyoutPrizePoolPercentage, uint256 buyoutDividendPercentage, uint256 buyoutFeePercentage);\r\n    event End(uint256 indexed gameIndex, address indexed winner, uint256 indexed identifier, uint256 x, uint256 y, uint256 timestamp, uint256 prize);\r\n    event Buyout(uint256 indexed gameIndex, address indexed player, uint256 indexed identifier, uint256 x, uint256 y, uint256 timestamp, uint256 timeoutTimestamp, uint256 newPrice, uint256 newPrizePool);\r\n    event SpiceUpPrizePool(uint256 indexed gameIndex, address indexed spicer, uint256 spiceAdded, string message, uint256 newPrizePool);\r\n    \r\n    /// @dev Struct to hold game settings.\r\n    struct GameSettings {\r\n        uint256 rows; // 5\r\n        uint256 cols; // 8\r\n        \r\n        /// @dev Time after last trade after which tiles become inactive.\r\n        uint256 activityTimer; // 3600\r\n        \r\n        /// @dev Base price for unclaimed tiles.\r\n        uint256 unclaimedTilePrice; // 0.01 ether\r\n        \r\n        /// @dev Percentage of the buyout price that goes towards the referral\r\n        /// bonus. In 1/1000th of a percentage.\r\n        uint256 buyoutReferralBonusPercentage; // 750\r\n        \r\n        /// @dev Percentage of the buyout price that goes towards the prize\r\n        /// pool. In 1/1000th of a percentage.\r\n        uint256 buyoutPrizePoolPercentage; // 10000\r\n    \r\n        /// @dev Percentage of the buyout price that goes towards dividends\r\n        /// surrounding the tile that is bought out. In in 1/1000th of\r\n        /// a percentage.\r\n        uint256 buyoutDividendPercentage; // 5000\r\n    \r\n        /// @dev Buyout fee in 1/1000th of a percentage.\r\n        uint256 buyoutFeePercentage; // 2500\r\n    }\r\n    \r\n    /// @dev Struct to hold game state.\r\n    struct GameState {\r\n        /// @dev Boolean indicating whether the game is live.\r\n        bool gameStarted;\r\n    \r\n        /// @dev Time at which the game started.\r\n        uint256 gameStartTimestamp;\r\n    \r\n        /// @dev Keep track of tile ownership.\r\n        mapping (uint256 => address) identifierToOwner;\r\n        \r\n        /// @dev Keep track of the timestamp at which a tile was flipped last.\r\n        mapping (uint256 => uint256) identifierToBuyoutTimestamp;\r\n        \r\n        /// @dev Current tile price.\r\n        mapping (uint256 => uint256) identifierToBuyoutPrice;\r\n        \r\n        /// @dev Keep track of the tile that was flipped last.\r\n        uint256 lastFlippedTile;\r\n        \r\n        /// @dev The prize pool.\r\n        uint256 prizePool;\r\n    }\r\n    \r\n    /// @notice Mapping from game indices to game settings.\r\n    mapping (uint256 => GameSettings) public gameSettings;\r\n    \r\n    /// @notice Mapping from game indices to game states.\r\n    mapping (uint256 => GameState) public gameStates;\r\n    \r\n    /// @notice The index of the current game.\r\n    uint256 public gameIndex = 0;\r\n    \r\n    /// @dev Settings for the next game\r\n    GameSettings public nextGameSettings;\r\n    \r\n    function BurnupGameBase() public {\r\n        // Initial settings.\r\n        setNextGameSettings(\r\n            4, // rows\r\n            5, // cols\r\n            3600, // activityTimer\r\n            0.01 ether, // unclaimedTilePrice\r\n            750, // buyoutReferralBonusPercentage\r\n            10000, // buyoutPrizePoolPercentage\r\n            5000, // buyoutDividendPercentage\r\n            2500 // buyoutFeePercentage\r\n        );\r\n    }\r\n    \r\n    /// @dev Test whether the coordinate is valid.\r\n    /// @param x The x-part of the coordinate to test.\r\n    /// @param y The y-part of the coordinate to test.\r\n    function validCoordinate(uint256 x, uint256 y) public view returns(bool) {\r\n        return x < gameSettings[gameIndex].cols && y < gameSettings[gameIndex].rows;\r\n    }\r\n    \r\n    /// @dev Represent a 2D coordinate as a single uint.\r\n    /// @param x The x-coordinate.\r\n    /// @param y The y-coordinate.\r\n    function coordinateToIdentifier(uint256 x, uint256 y) public view returns(uint256) {\r\n        require(validCoordinate(x, y));\r\n        \r\n        return (y * gameSettings[gameIndex].cols) + x;\r\n    }\r\n    \r\n    /// @dev Turn a single uint representation of a coordinate into its x and y parts.\r\n    /// @param identifier The uint representation of a coordinate.\r\n    /// Assumes the identifier is valid.\r\n    function identifierToCoordinate(uint256 identifier) public view returns(uint256 x, uint256 y) {\r\n        y = identifier / gameSettings[gameIndex].cols;\r\n        x = identifier - (y * gameSettings[gameIndex].cols);\r\n    }\r\n    \r\n    /// @notice Sets the settings for the next game.\r\n    function setNextGameSettings(\r\n        uint256 rows,\r\n        uint256 cols,\r\n        uint256 activityTimer,\r\n        uint256 unclaimedTilePrice,\r\n        uint256 buyoutReferralBonusPercentage,\r\n        uint256 buyoutPrizePoolPercentage,\r\n        uint256 buyoutDividendPercentage,\r\n        uint256 buyoutFeePercentage\r\n    )\r\n        public\r\n        onlyCFO\r\n    {\r\n        // Buyout dividend must be 2% at the least.\r\n        // Buyout dividend percentage may be 12.5% at the most.\r\n        require(2000 <= buyoutDividendPercentage && buyoutDividendPercentage <= 12500);\r\n        \r\n        // Buyout fee may be 5% at the most.\r\n        require(buyoutFeePercentage <= 5000);\r\n        \r\n        nextGameSettings = GameSettings({\r\n            rows: rows,\r\n            cols: cols,\r\n            activityTimer: activityTimer,\r\n            unclaimedTilePrice: unclaimedTilePrice,\r\n            buyoutReferralBonusPercentage: buyoutReferralBonusPercentage,\r\n            buyoutPrizePoolPercentage: buyoutPrizePoolPercentage,\r\n            buyoutDividendPercentage: buyoutDividendPercentage,\r\n            buyoutFeePercentage: buyoutFeePercentage\r\n        });\r\n        \r\n        NextGame(rows, cols, activityTimer, unclaimedTilePrice, buyoutReferralBonusPercentage, buyoutPrizePoolPercentage, buyoutDividendPercentage, buyoutFeePercentage);\r\n    }\r\n}\r\n\r\n\r\n/// @dev Holds ownership functionality such as transferring.\r\ncontract BurnupGameOwnership is BurnupGameBase {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 indexed deedId);\r\n    \r\n    /// @notice Name of the collection of deeds (non-fungible token), as defined in ERC721Metadata.\r\n    function name() public pure returns (string _deedName) {\r\n        _deedName = \"Burnup Tiles\";\r\n    }\r\n    \r\n    /// @notice Symbol of the collection of deeds (non-fungible token), as defined in ERC721Metadata.\r\n    function symbol() public pure returns (string _deedSymbol) {\r\n        _deedSymbol = \"BURN\";\r\n    }\r\n    \r\n    /// @dev Checks if a given address owns a particular tile.\r\n    /// @param _owner The address of the owner to check for.\r\n    /// @param _identifier The tile identifier to check for.\r\n    function _owns(address _owner, uint256 _identifier) internal view returns (bool) {\r\n        return gameStates[gameIndex].identifierToOwner[_identifier] == _owner;\r\n    }\r\n    \r\n    /// @dev Assigns ownership of a specific deed to an address.\r\n    /// @param _from The address to transfer the deed from.\r\n    /// @param _to The address to transfer the deed to.\r\n    /// @param _identifier The identifier of the deed to transfer.\r\n    function _transfer(address _from, address _to, uint256 _identifier) internal {\r\n        // Transfer ownership.\r\n        gameStates[gameIndex].identifierToOwner[_identifier] = _to;\r\n        \r\n        // Emit the transfer event.\r\n        Transfer(_from, _to, _identifier);\r\n    }\r\n    \r\n    /// @notice Returns the address currently assigned ownership of a given deed.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function ownerOf(uint256 _identifier) external view returns (address _owner) {\r\n        _owner = gameStates[gameIndex].identifierToOwner[_identifier];\r\n\r\n        require(_owner != address(0));\r\n    }\r\n    \r\n    /// @notice Transfer a deed to another address. If transferring to a smart\r\n    /// contract be VERY CAREFUL to ensure that it is aware of ERC-721, or your\r\n    /// deed may be lost forever.\r\n    /// @param _to The address of the recipient, can be a user or contract.\r\n    /// @param _identifier The identifier of the deed to transfer.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transfer(address _to, uint256 _identifier) external whenNotPaused {\r\n        // One can only transfer their own deeds.\r\n        require(_owns(msg.sender, _identifier));\r\n        \r\n        // Transfer ownership\r\n        _transfer(msg.sender, _to, _identifier);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments. Inherit from this\r\n * contract and use asyncSend instead of send.\r\n */\r\ncontract PullPayment {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public payments;\r\n  uint256 public totalPayments;\r\n\r\n  /**\r\n  * @dev withdraw accumulated balance, called by payee.\r\n  */\r\n  function withdrawPayments() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n\r\n    require(payment != 0);\r\n    require(this.balance >= payment);\r\n\r\n    totalPayments = totalPayments.sub(payment);\r\n    payments[payee] = 0;\r\n\r\n    assert(payee.send(payment));\r\n  }\r\n\r\n  /**\r\n  * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n  * @param dest The destination address of the funds.\r\n  * @param amount The amount to transfer.\r\n  */\r\n  function asyncSend(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n    totalPayments = totalPayments.add(amount);\r\n  }\r\n}\r\n\r\n\r\n/// @dev Implements access control to the BurnUp wallet.\r\ncontract BurnupHoldingAccessControl is Claimable, Pausable, CanReclaimToken {\r\n    address public cfoAddress;\r\n    \r\n    /// Boolean indicating whether an address is a BurnUp Game contract.\r\n    mapping (address => bool) burnupGame;\r\n\r\n    function BurnupHoldingAccessControl() public {\r\n        // The creator of the contract is the initial CFO.\r\n        cfoAddress = msg.sender;\r\n    }\r\n    \r\n    /// @dev Access modifier for CFO-only functionality.\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n    \r\n    /// @dev Access modifier for functionality that may only be called by a BurnUp game.\r\n    modifier onlyBurnupGame() {\r\n        // The sender must be a recognized BurnUp game address.\r\n        require(burnupGame[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current contract owner.\r\n    /// @param _newCFO The address of the new CFO.\r\n    function setCFO(address _newCFO) external onlyOwner {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n    \r\n    /// @dev Add a Burnup game contract address.\r\n    /// @param addr The address of the Burnup game contract.\r\n    function addBurnupGame(address addr) external onlyOwner {\r\n        burnupGame[addr] = true;\r\n    }\r\n    \r\n    /// @dev Remove a Burnup game contract address.\r\n    /// @param addr The address of the Burnup game contract.\r\n    function removeBurnupGame(address addr) external onlyOwner {\r\n        delete burnupGame[addr];\r\n    }\r\n}\r\n\r\n\r\n/// @dev Implements the BurnUp wallet.\r\ncontract BurnupHoldingReferral is BurnupHoldingAccessControl {\r\n\r\n    event SetReferrer(address indexed referral, address indexed referrer);\r\n\r\n    /// Referrer of player.\r\n    mapping (address => address) addressToReferrerAddress;\r\n    \r\n    /// Get the referrer of a player.\r\n    /// @param player The address of the player to get the referrer of.\r\n    function referrerOf(address player) public view returns (address) {\r\n        return addressToReferrerAddress[player];\r\n    }\r\n    \r\n    /// Set the referrer for a player.\r\n    /// @param playerAddr The address of the player to set the referrer for.\r\n    /// @param referrerAddr The address of the referrer to set.\r\n    function _setReferrer(address playerAddr, address referrerAddr) internal {\r\n        addressToReferrerAddress[playerAddr] = referrerAddr;\r\n        \r\n        // Emit event.\r\n        SetReferrer(playerAddr, referrerAddr);\r\n    }\r\n}\r\n\r\n\r\n/// @dev Implements the BurnUp wallet.\r\ncontract BurnupHoldingCore is BurnupHoldingReferral, PullPayment {\r\n    using SafeMath for uint256;\r\n    \r\n    address public beneficiary1;\r\n    address public beneficiary2;\r\n    \r\n    function BurnupHoldingCore(address _beneficiary1, address _beneficiary2) public {\r\n        // The creator of the contract is the initial CFO.\r\n        cfoAddress = msg.sender;\r\n        \r\n        // Set the two beneficiaries.\r\n        beneficiary1 = _beneficiary1;\r\n        beneficiary2 = _beneficiary2;\r\n    }\r\n    \r\n    /// Pay the two beneficiaries. Sends both beneficiaries\r\n    /// a halve of the payment.\r\n    function payBeneficiaries() external payable {\r\n        uint256 paymentHalve = msg.value.div(2);\r\n        \r\n        // We do not want a single wei to get stuck.\r\n        uint256 otherPaymentHalve = msg.value.sub(paymentHalve);\r\n        \r\n        // Send payment for manual withdrawal.\r\n        asyncSend(beneficiary1, paymentHalve);\r\n        asyncSend(beneficiary2, otherPaymentHalve);\r\n    }\r\n    \r\n    /// Sets a new address for Beneficiary one.\r\n    /// @param addr The new address.\r\n    function setBeneficiary1(address addr) external onlyCFO {\r\n        beneficiary1 = addr;\r\n    }\r\n    \r\n    /// Sets a new address for Beneficiary two.\r\n    /// @param addr The new address.\r\n    function setBeneficiary2(address addr) external onlyCFO {\r\n        beneficiary2 = addr;\r\n    }\r\n    \r\n    /// Set a referrer.\r\n    /// @param playerAddr The address to set the referrer for.\r\n    /// @param referrerAddr The address of the referrer to set.\r\n    function setReferrer(address playerAddr, address referrerAddr) external onlyBurnupGame whenNotPaused returns(bool) {\r\n        if (referrerOf(playerAddr) == address(0x0) && playerAddr != referrerAddr) {\r\n            // Set the referrer, if no referrer has been set yet, and the player\r\n            // and referrer are not the same address.\r\n            _setReferrer(playerAddr, referrerAddr);\r\n            \r\n            // Indicate success.\r\n            return true;\r\n        }\r\n        \r\n        // Indicate failure.\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n/// @dev Holds functionality for finance related to tiles.\r\ncontract BurnupGameFinance is BurnupGameOwnership, PullPayment {\r\n    /// Address of Burnup wallet\r\n    BurnupHoldingCore burnupHolding;\r\n    \r\n    function BurnupGameFinance(address burnupHoldingAddress) public {\r\n        burnupHolding = BurnupHoldingCore(burnupHoldingAddress);\r\n    }\r\n    \r\n    /// @dev Find the _claimed_ tiles surrounding a tile.\r\n    /// @param _deedId The identifier of the tile to get the surrounding tiles for.\r\n    function _claimedSurroundingTiles(uint256 _deedId) internal view returns (uint256[] memory) {\r\n        var (x, y) = identifierToCoordinate(_deedId);\r\n        \r\n        // Find all claimed surrounding tiles.\r\n        uint256 claimed = 0;\r\n        \r\n        // Create memory buffer capable of holding all tiles.\r\n        uint256[] memory _tiles = new uint256[](8);\r\n        \r\n        // Loop through all neighbors.\r\n        for (int256 dx = -1; dx <= 1; dx++) {\r\n            for (int256 dy = -1; dy <= 1; dy++) {\r\n                if (dx == 0 && dy == 0) {\r\n                    // Skip the center (i.e., the tile itself).\r\n                    continue;\r\n                }\r\n                \r\n                uint256 nx = uint256(int256(x) + dx);\r\n                uint256 ny = uint256(int256(y) + dy);\r\n                \r\n                if (nx >= gameSettings[gameIndex].cols || ny >= gameSettings[gameIndex].rows) {\r\n                    // This coordinate is outside the game bounds.\r\n                    continue;\r\n                }\r\n                \r\n                // Get the coordinates of this neighboring identifier.\r\n                uint256 neighborIdentifier = coordinateToIdentifier(\r\n                    nx,\r\n                    ny\r\n                );\r\n                \r\n                if (gameStates[gameIndex].identifierToOwner[neighborIdentifier] != address(0x0)) {\r\n                    _tiles[claimed] = neighborIdentifier;\r\n                    claimed++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Memory arrays cannot be resized, so copy all\r\n        // tiles from the buffer to the tile array.\r\n        uint256[] memory tiles = new uint256[](claimed);\r\n        \r\n        for (uint256 i = 0; i < claimed; i++) {\r\n            tiles[i] = _tiles[i];\r\n        }\r\n        \r\n        return tiles;\r\n    }\r\n    \r\n    /// @dev Calculate the next buyout price given the current total buyout cost.\r\n    /// @param price The current buyout price.\r\n    function nextBuyoutPrice(uint256 price) public pure returns (uint256) {\r\n        if (price < 0.02 ether) {\r\n            return price.mul(200).div(100); // * 2.0\r\n        } else {\r\n            return price.mul(150).div(100); // * 1.5\r\n        }\r\n    }\r\n    \r\n    /// @dev Assign the proceeds of the buyout.\r\n    function _assignBuyoutProceeds(\r\n        address currentOwner,\r\n        uint256[] memory claimedSurroundingTiles,\r\n        uint256 fee,\r\n        uint256 currentOwnerWinnings,\r\n        uint256 totalDividendPerBeneficiary,\r\n        uint256 referralBonus,\r\n        uint256 prizePoolFunds\r\n    )\r\n        internal\r\n    {\r\n    \r\n        if (currentOwner != 0x0) {\r\n            // Send the current owner's winnings.\r\n            _sendFunds(currentOwner, currentOwnerWinnings);\r\n        } else {\r\n            // There is no current owner.\r\n            fee = fee.add(currentOwnerWinnings);\r\n        }\r\n        \r\n        // Assign dividends to owners of surrounding tiles.\r\n        for (uint256 i = 0; i < claimedSurroundingTiles.length; i++) {\r\n            address beneficiary = gameStates[gameIndex].identifierToOwner[claimedSurroundingTiles[i]];\r\n            _sendFunds(beneficiary, totalDividendPerBeneficiary);\r\n        }\r\n        \r\n        /// Distribute the referral bonuses (if any) for an address.\r\n        address referrer1 = burnupHolding.referrerOf(msg.sender);\r\n        if (referrer1 != 0x0) {\r\n            _sendFunds(referrer1, referralBonus);\r\n        \r\n            address referrer2 = burnupHolding.referrerOf(referrer1);\r\n            if (referrer2 != 0x0) {\r\n                _sendFunds(referrer2, referralBonus);\r\n            } else {\r\n                // There is no second-level referrer.\r\n                fee = fee.add(referralBonus);\r\n            }\r\n        } else {\r\n            // There are no first and second-level referrers.\r\n            fee = fee.add(referralBonus.mul(2));\r\n        }\r\n        \r\n        // Send the fee to the holding contract.\r\n        burnupHolding.payBeneficiaries.value(fee)();\r\n        \r\n        // Increase the prize pool.\r\n        gameStates[gameIndex].prizePool = gameStates[gameIndex].prizePool.add(prizePoolFunds);\r\n    }\r\n    \r\n    /// @dev Calculate and assign the proceeds from the buyout.\r\n    /// @param currentOwner The current owner of the tile that is being bought out.\r\n    /// @param _deedId The identifier of the tile that is being bought out.\r\n    /// @param claimedSurroundingTiles The surrounding tiles that have been claimed.\r\n    function _calculateAndAssignBuyoutProceeds(address currentOwner, uint256 _deedId, uint256[] memory claimedSurroundingTiles)\r\n        internal \r\n        returns (uint256 price)\r\n    {\r\n        // The current price.\r\n        \r\n        if (currentOwner == 0x0) {\r\n            price = gameSettings[gameIndex].unclaimedTilePrice;\r\n        } else {\r\n            price = gameStates[gameIndex].identifierToBuyoutPrice[_deedId];\r\n        }\r\n        \r\n        // Calculate the variable dividends based on the buyout price\r\n        // (only to be paid if there are surrounding tiles).\r\n        uint256 variableDividends = price.mul(gameSettings[gameIndex].buyoutDividendPercentage).div(100000);\r\n        \r\n        // Calculate fees, referral bonus, and prize pool funds.\r\n        uint256 fee            = price.mul(gameSettings[gameIndex].buyoutFeePercentage).div(100000);\r\n        uint256 referralBonus  = price.mul(gameSettings[gameIndex].buyoutReferralBonusPercentage).div(100000);\r\n        uint256 prizePoolFunds = price.mul(gameSettings[gameIndex].buyoutPrizePoolPercentage).div(100000);\r\n        \r\n        // Calculate and assign buyout proceeds.\r\n        uint256 currentOwnerWinnings = price.sub(fee).sub(referralBonus.mul(2)).sub(prizePoolFunds);\r\n        \r\n        uint256 totalDividendPerBeneficiary;\r\n        if (claimedSurroundingTiles.length > 0) {\r\n            // If there are surrounding tiles, variable dividend is to be paid\r\n            // based on the buyout price.\r\n            // Calculate the dividend per surrounding tile.\r\n            totalDividendPerBeneficiary = variableDividends / claimedSurroundingTiles.length;\r\n            \r\n            currentOwnerWinnings = currentOwnerWinnings.sub(variableDividends);\r\n            // currentOwnerWinnings = currentOwnerWinnings.sub(totalDividendPerBeneficiary * claimedSurroundingTiles.length);\r\n        }\r\n        \r\n        _assignBuyoutProceeds(\r\n            currentOwner,\r\n            claimedSurroundingTiles,\r\n            fee,\r\n            currentOwnerWinnings,\r\n            totalDividendPerBeneficiary,\r\n            referralBonus,\r\n            prizePoolFunds\r\n        );\r\n    }\r\n    \r\n    /// @dev Send funds to a beneficiary. If sending fails, assign\r\n    /// funds to the beneficiary's balance for manual withdrawal.\r\n    /// @param beneficiary The beneficiary's address to send funds to\r\n    /// @param amount The amount to send.\r\n    function _sendFunds(address beneficiary, uint256 amount) internal {\r\n        if (!beneficiary.send(amount)) {\r\n            // Failed to send funds. This can happen due to a failure in\r\n            // fallback code of the beneficiary, or because of callstack\r\n            // depth.\r\n            // Send funds asynchronously for manual withdrawal by the\r\n            // beneficiary.\r\n            asyncSend(beneficiary, amount);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @dev Holds core game functionality.\r\ncontract BurnupGameCore is BurnupGameFinance {\r\n    \r\n    function BurnupGameCore(address burnupHoldingAddress) public BurnupGameFinance(burnupHoldingAddress) {}\r\n    \r\n    /// @notice Buy the current owner out of the tile.\r\n    /// @param _gameIndex The index of the game to play on.\r\n    /// @param startNewGameIfIdle Start a new game if the current game is idle.\r\n    /// @param x The x-coordinate of the tile to buy.\r\n    /// @param y The y-coordinate of the tile to buy.\r\n    function buyout(uint256 _gameIndex, bool startNewGameIfIdle, uint256 x, uint256 y) public payable {\r\n        // Check to see if the game should end. Process payment.\r\n        _processGameEnd();\r\n        \r\n        if (!gameStates[gameIndex].gameStarted) {\r\n            // If the game is not started, the contract must not be paused.\r\n            require(!paused);\r\n            \r\n            // If the game is not started, the player must be willing to start\r\n            // a new game.\r\n            require(startNewGameIfIdle);\r\n            \r\n            // Set the price and timeout.\r\n            gameSettings[gameIndex] = nextGameSettings;\r\n            \r\n            // Start the game.\r\n            gameStates[gameIndex].gameStarted = true;\r\n            \r\n            // Set game started timestamp.\r\n            gameStates[gameIndex].gameStartTimestamp = block.timestamp;\r\n            \r\n            // Emit start event.\r\n            Start(gameIndex, msg.sender, block.timestamp, gameStates[gameIndex].prizePool, gameSettings[gameIndex].rows, gameSettings[gameIndex].cols, gameSettings[gameIndex].activityTimer, gameSettings[gameIndex].unclaimedTilePrice, gameSettings[gameIndex].buyoutReferralBonusPercentage, gameSettings[gameIndex].buyoutPrizePoolPercentage, gameSettings[gameIndex].buyoutDividendPercentage, gameSettings[gameIndex].buyoutFeePercentage);\r\n        }\r\n    \r\n        // Check the game index.\r\n        if (startNewGameIfIdle) {\r\n            // The given game index must be the current game index, or the previous\r\n            // game index.\r\n            require(_gameIndex == gameIndex || _gameIndex.add(1) == gameIndex);\r\n        } else {\r\n            // Only play on the game indicated by the player.\r\n            require(_gameIndex == gameIndex);\r\n        }\r\n        \r\n        uint256 identifier = coordinateToIdentifier(x, y);\r\n        \r\n        address currentOwner = gameStates[gameIndex].identifierToOwner[identifier];\r\n        \r\n        // Tile must be unowned, or active.\r\n        if (currentOwner == address(0x0)) {\r\n            // Tile must still be flippable.\r\n            require(gameStates[gameIndex].gameStartTimestamp.add(gameSettings[gameIndex].activityTimer) >= block.timestamp);\r\n        } else {\r\n            // Tile must be active.\r\n            require(gameStates[gameIndex].identifierToBuyoutTimestamp[identifier].add(gameSettings[gameIndex].activityTimer) >= block.timestamp);\r\n        }\r\n        \r\n        // Get existing surrounding tiles.\r\n        uint256[] memory claimedSurroundingTiles = _claimedSurroundingTiles(identifier);\r\n        \r\n        // Assign the buyout proceeds and retrieve the total cost.\r\n        uint256 price = _calculateAndAssignBuyoutProceeds(currentOwner, identifier, claimedSurroundingTiles);\r\n        \r\n        // Enough Ether must be supplied.\r\n        require(msg.value >= price);\r\n        \r\n        // Transfer the tile.\r\n        _transfer(currentOwner, msg.sender, identifier);\r\n        \r\n        // Set this tile to be the most recently bought out.\r\n        gameStates[gameIndex].lastFlippedTile = identifier;\r\n        \r\n        // Calculate and set the new tile price.\r\n        gameStates[gameIndex].identifierToBuyoutPrice[identifier] = nextBuyoutPrice(price);\r\n        \r\n        // Set the buyout timestamp.\r\n        gameStates[gameIndex].identifierToBuyoutTimestamp[identifier] = block.timestamp;\r\n        \r\n        // Emit event\r\n        Buyout(gameIndex, msg.sender, identifier, x, y, block.timestamp, block.timestamp + gameSettings[gameIndex].activityTimer, gameStates[gameIndex].identifierToBuyoutPrice[identifier], gameStates[gameIndex].prizePool);\r\n        \r\n        // Calculate the excess Ether sent.\r\n        // msg.value is greater than or equal to price,\r\n        // so this cannot underflow.\r\n        uint256 excess = msg.value - price;\r\n        \r\n        if (excess > 0) {\r\n            // Refund any excess Ether (not susceptible to re-entry attack, as\r\n            // the owner is assigned before the transfer takes place).\r\n            msg.sender.transfer(excess);\r\n        }\r\n    }\r\n    \r\n    /// @notice Buy the current owner out of the tile. Set the player's referrer.\r\n    /// @param _gameIndex The index of the game to play on.\r\n    /// @param startNewGameIfIdle Start a new game if the current game is idle.\r\n    /// @param x The x-coordinate of the tile to buy.\r\n    /// @param y The y-coordinate of the tile to buy.\r\n    function buyoutAndSetReferrer(uint256 _gameIndex, bool startNewGameIfIdle, uint256 x, uint256 y, address referrerAddress) external payable {\r\n        // Set the referrer.\r\n        burnupHolding.setReferrer(msg.sender, referrerAddress);\r\n    \r\n        // Play.\r\n        buyout(_gameIndex, startNewGameIfIdle, x, y);\r\n    }\r\n    \r\n    /// @notice Spice up the prize pool.\r\n    /// @param _gameIndex The index of the game to add spice to.\r\n    /// @param message An optional message to be sent along with the spice.\r\n    function spiceUp(uint256 _gameIndex, string message) external payable {\r\n        // Check to see if the game should end. Process payment.\r\n        _processGameEnd();\r\n        \r\n        // Check the game index.\r\n        require(_gameIndex == gameIndex);\r\n    \r\n        // Game must be live or unpaused.\r\n        require(gameStates[gameIndex].gameStarted || !paused);\r\n        \r\n        // Funds must be sent.\r\n        require(msg.value > 0);\r\n        \r\n        // Add funds to the prize pool.\r\n        gameStates[gameIndex].prizePool = gameStates[gameIndex].prizePool.add(msg.value);\r\n        \r\n        // Emit event.\r\n        SpiceUpPrizePool(gameIndex, msg.sender, msg.value, message, gameStates[gameIndex].prizePool);\r\n    }\r\n    \r\n    /// @notice End the game. Pay prize.\r\n    function endGame() external {\r\n        require(_processGameEnd());\r\n    }\r\n    \r\n    /// @dev End the game. Pay prize.\r\n    function _processGameEnd() internal returns(bool) {\r\n        address currentOwner = gameStates[gameIndex].identifierToOwner[gameStates[gameIndex].lastFlippedTile];\r\n    \r\n        // The game must be started.\r\n        if (!gameStates[gameIndex].gameStarted) {\r\n            return false;\r\n        }\r\n    \r\n        // The last flipped tile must be owned (i.e. there has been at\r\n        // least one flip).\r\n        if (currentOwner == address(0x0)) {\r\n            return false;\r\n        }\r\n        \r\n        // The last flipped tile must have become inactive.\r\n        if (gameStates[gameIndex].identifierToBuyoutTimestamp[gameStates[gameIndex].lastFlippedTile].add(gameSettings[gameIndex].activityTimer) >= block.timestamp) {\r\n            return false;\r\n        }\r\n        \r\n        // Assign prize pool to the owner of the last-flipped tile.\r\n        if (gameStates[gameIndex].prizePool > 0) {\r\n            _sendFunds(currentOwner, gameStates[gameIndex].prizePool);\r\n        }\r\n        \r\n        // Get coordinates of last flipped tile.\r\n        var (x, y) = identifierToCoordinate(gameStates[gameIndex].lastFlippedTile);\r\n        \r\n        // Emit event.\r\n        End(gameIndex, currentOwner, gameStates[gameIndex].lastFlippedTile, x, y, gameStates[gameIndex].identifierToBuyoutTimestamp[gameStates[gameIndex].lastFlippedTile].add(gameSettings[gameIndex].activityTimer), gameStates[gameIndex].prizePool);\r\n        \r\n        // Increment the game index. This won't overflow before the heat death of the universe.\r\n        gameIndex++;\r\n        \r\n        // Indicate ending the game was successful.\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameSettings\",\"outputs\":[{\"name\":\"rows\",\"type\":\"uint256\"},{\"name\":\"cols\",\"type\":\"uint256\"},{\"name\":\"activityTimer\",\"type\":\"uint256\"},{\"name\":\"unclaimedTilePrice\",\"type\":\"uint256\"},{\"name\":\"buyoutReferralBonusPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutPrizePoolPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutDividendPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutFeePercentage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_deedName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"coordinateToIdentifier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextGameSettings\",\"outputs\":[{\"name\":\"rows\",\"type\":\"uint256\"},{\"name\":\"cols\",\"type\":\"uint256\"},{\"name\":\"activityTimer\",\"type\":\"uint256\"},{\"name\":\"unclaimedTilePrice\",\"type\":\"uint256\"},{\"name\":\"buyoutReferralBonusPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutPrizePoolPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutDividendPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutFeePercentage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"nextBuyoutPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"identifier\",\"type\":\"uint256\"}],\"name\":\"identifierToCoordinate\",\"outputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"name\":\"startNewGameIfIdle\",\"type\":\"bool\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"buyoutAndSetReferrer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"name\":\"startNewGameIfIdle\",\"type\":\"bool\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"buyout\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_deedSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameStates\",\"outputs\":[{\"name\":\"gameStarted\",\"type\":\"bool\"},{\"name\":\"gameStartTimestamp\",\"type\":\"uint256\"},{\"name\":\"lastFlippedTile\",\"type\":\"uint256\"},{\"name\":\"prizePool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"validCoordinate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_identifier\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rows\",\"type\":\"uint256\"},{\"name\":\"cols\",\"type\":\"uint256\"},{\"name\":\"activityTimer\",\"type\":\"uint256\"},{\"name\":\"unclaimedTilePrice\",\"type\":\"uint256\"},{\"name\":\"buyoutReferralBonusPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutPrizePoolPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutDividendPercentage\",\"type\":\"uint256\"},{\"name\":\"buyoutFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setNextGameSettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"spiceUp\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"burnupHoldingAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"deedId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rows\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cols\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"activityTimer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unclaimedTilePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyoutReferralBonusPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyoutPrizePoolPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyoutDividendPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyoutFeePercentage\",\"type\":\"uint256\"}],\"name\":\"NextGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"starter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prizePool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rows\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cols\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"activityTimer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unclaimedTilePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyoutReferralBonusPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyoutPrizePoolPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyoutDividendPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyoutFeePercentage\",\"type\":\"uint256\"}],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"identifier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"x\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"y\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"End\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"identifier\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"x\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"y\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeoutTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrizePool\",\"type\":\"uint256\"}],\"name\":\"Buyout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"spicer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"spiceAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newPrizePool\",\"type\":\"uint256\"}],\"name\":\"SpiceUpPrizePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BurnupGameCore","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000e3d496adfdd94aecad610c391991b9961f5e369","Library":"","SwarmSource":"bzzr://cad5aab23419cb8f69dcf22530b11178cdef35f5ed548d6ac5153d5ac38c226a"}]}