{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    require(_value <= balances[msg.sender]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    address burner = msg.sender;\r\n    balances[burner] = balances[burner].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    Burn(burner, _value);\r\n    Transfer(burner, address(0), _value);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract AMOCoin is StandardToken, BurnableToken, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant symbol = \"AMO\";\r\n    string public constant name = \"AMO Coin\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY = 20000000000 * (10 ** uint256(decimals));\r\n    uint256 public constant TOKEN_SALE_ALLOWANCE = 10000000000 * (10 ** uint256(decimals));\r\n    uint256 public constant ADMIN_ALLOWANCE = INITIAL_SUPPLY - TOKEN_SALE_ALLOWANCE;\r\n\r\n    // Address of token administrator\r\n    address public adminAddr;\r\n\r\n    // Address of token sale contract\r\n    address public tokenSaleAddr;\r\n\r\n    // Enable transfer after token sale is completed\r\n    bool public transferEnabled = false;\r\n\r\n    // Accounts to be locked for certain period\r\n    mapping(address => uint256) private lockedAccounts;\r\n\r\n    /*\r\n     *\r\n     * Permissions when transferEnabled is false :\r\n     *              ContractOwner    Admin    SaleContract    Others\r\n     * transfer            x           v            v           x\r\n     * transferFrom        x           v            v           x\r\n     *\r\n     * Permissions when transferEnabled is true :\r\n     *              ContractOwner    Admin    SaleContract    Others\r\n     * transfer            v           v            v           v\r\n     * transferFrom        v           v            v           v\r\n     *\r\n     */\r\n\r\n    /*\r\n     * Check if token transfer is allowed\r\n     * Permission table above is result of this modifier\r\n     */\r\n    modifier onlyWhenTransferAllowed() {\r\n        require(transferEnabled == true\r\n            || msg.sender == adminAddr\r\n            || msg.sender == tokenSaleAddr);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Check if token sale address is not set\r\n     */\r\n    modifier onlyWhenTokenSaleAddrNotSet() {\r\n        require(tokenSaleAddr == address(0x0));\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Check if token transfer destination is valid\r\n     */\r\n    modifier onlyValidDestination(address to) {\r\n        require(to != address(0x0)\r\n            && to != address(this)\r\n            && to != owner\r\n            && to != adminAddr\r\n            && to != tokenSaleAddr);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowedAmount(address from, uint256 amount) {\r\n        require(balances[from].sub(amount) >= lockedAccounts[from]);\r\n        _;\r\n    }\r\n    /*\r\n     * The constructor of AMOCoin contract\r\n     *\r\n     * @param _adminAddr: Address of token administrator\r\n     */\r\n    function AMOCoin(address _adminAddr) public {\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n\r\n        balances[msg.sender] = totalSupply_;\r\n        Transfer(address(0x0), msg.sender, totalSupply_);\r\n\r\n        adminAddr = _adminAddr;\r\n        approve(adminAddr, ADMIN_ALLOWANCE);\r\n    }\r\n\r\n    /*\r\n     * Set amount of token sale to approve allowance for sale contract\r\n     *\r\n     * @param _tokenSaleAddr: Address of sale contract\r\n     * @param _amountForSale: Amount of token for sale\r\n     */\r\n    function setTokenSaleAmount(address _tokenSaleAddr, uint256 amountForSale)\r\n        external\r\n        onlyOwner\r\n        onlyWhenTokenSaleAddrNotSet\r\n    {\r\n        require(!transferEnabled);\r\n\r\n        uint256 amount = (amountForSale == 0) ? TOKEN_SALE_ALLOWANCE : amountForSale;\r\n        require(amount <= TOKEN_SALE_ALLOWANCE);\r\n\r\n        approve(_tokenSaleAddr, amount);\r\n        tokenSaleAddr = _tokenSaleAddr;\r\n    }\r\n\r\n    /*\r\n     * Set transferEnabled variable to true\r\n     */\r\n    function enableTransfer() external onlyOwner {\r\n        transferEnabled = true;\r\n        approve(tokenSaleAddr, 0);\r\n    }\r\n\r\n    /*\r\n     * Set transferEnabled variable to false\r\n     */\r\n    function disableTransfer() external onlyOwner {\r\n        transferEnabled = false;\r\n    }\r\n\r\n    /*\r\n     * Transfer token from message sender to another\r\n     *\r\n     * @param to: Destination address\r\n     * @param value: Amount of AMO token to transfer\r\n     */\r\n    function transfer(address to, uint256 value)\r\n        public\r\n        onlyWhenTransferAllowed\r\n        onlyValidDestination(to)\r\n        onlyAllowedAmount(msg.sender, value)\r\n        returns (bool)\r\n    {\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    /*\r\n     * Transfer token from 'from' address to 'to' addreess\r\n     *\r\n     * @param from: Origin address\r\n     * @param to: Destination address\r\n     * @param value: Amount of AMO Coin to transfer\r\n     */\r\n    function transferFrom(address from, address to, uint256 value)\r\n        public\r\n        onlyWhenTransferAllowed\r\n        onlyValidDestination(to)\r\n        onlyAllowedAmount(from, value)\r\n        returns (bool)\r\n    {\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    /*\r\n     * Burn token, only owner is allowed\r\n     *\r\n     * @param value: Amount of AMO Coin to burn\r\n     */\r\n    function burn(uint256 value) public onlyOwner {\r\n        require(transferEnabled);\r\n        super.burn(value);\r\n    }\r\n\r\n    /*\r\n     * Disable transfering tokens more than allowed amount from certain account\r\n     *\r\n     * @param addr: Account to set allowed amount\r\n     * @param amount: Amount of tokens to allow\r\n     */\r\n    function lockAccount(address addr, uint256 amount)\r\n        external\r\n        onlyOwner\r\n        onlyValidDestination(addr)\r\n    {\r\n        require(amount > 0);\r\n        lockedAccounts[addr] = amount;\r\n    }\r\n\r\n    /*\r\n     * Enable transfering tokens of locked account\r\n     *\r\n     * @param addr: Account to unlock\r\n     */\r\n\r\n    function unlockAccount(address addr)\r\n        external\r\n        onlyOwner\r\n        onlyValidDestination(addr)\r\n    {\r\n        lockedAccounts[addr] = 0;\r\n    }\r\n}\r\n\r\n\r\ncontract AMOCoinSale is Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    // Start time of sale\r\n    uint256 public startTime;\r\n    // End time of sale\r\n    uint256 public endTime;\r\n    // Address to collect fund\r\n    address private fundAddr;\r\n    // Token contract instance\r\n    AMOCoin public token;\r\n    // Amount of raised in Wei (1 ether)\r\n    uint256 public totalWeiRaised;\r\n    // Base hard cap for each round in ether\r\n    uint256 public constant BASE_HARD_CAP_PER_ROUND = 12000 * 1 ether;\r\n\r\n    uint256 public constant UINT256_MAX = ~uint256(0);\r\n    // Base AMO to Ether rate\r\n    uint256 public constant BASE_AMO_TO_ETH_RATE = 200000;\r\n    // Base minimum contribution\r\n    uint256 public constant BASE_MIN_CONTRIBUTION = 0.1 * 1 ether;\r\n    // Whitelisted addresses\r\n    mapping(address => bool) public whitelist;\r\n    // Whitelisted users' contributions per round\r\n    mapping(address => mapping(uint8 => uint256)) public contPerRound;\r\n\r\n    // For each round, there are three stages.\r\n    enum Stages {\r\n        SetUp,\r\n        Started,\r\n        Ended\r\n    }\r\n    // The current stage of the sale\r\n    Stages public stage;\r\n\r\n    // There are three rounds in sale\r\n    enum SaleRounds {\r\n        EarlyInvestment,\r\n        PreSale,\r\n        CrowdSale\r\n    }\r\n    // The current round of the sale\r\n    SaleRounds public round;\r\n\r\n    // Each round has different information\r\n    struct RoundInfo {\r\n        uint256 minContribution;\r\n        uint256 maxContribution;\r\n        uint256 hardCap;\r\n        uint256 rate;\r\n        uint256 weiRaised;\r\n    }\r\n\r\n    // SaleRounds(key) : RoundInfo(value) map\r\n    // Since solidity does not support enum as key of map, converted enum to uint8\r\n    mapping(uint8 => RoundInfo) public roundInfos;\r\n\r\n    struct AllocationInfo {\r\n        bool isAllowed;\r\n        uint256 allowedAmount;\r\n    }\r\n\r\n    // List of users who will be allocated tokens and their allowed amount\r\n    mapping(address => AllocationInfo) private allocationList;\r\n\r\n    /*\r\n     * Event for sale start logging\r\n     *\r\n     * @param startTime: Start date of sale\r\n     * @param endTime: End date of sale\r\n     * @param round: Round of sale started\r\n     */\r\n    event SaleStarted(uint256 startTime, uint256 endTime, SaleRounds round);\r\n\r\n    /*\r\n     * Event for sale end logging\r\n     *\r\n     * @param endTime: End date of sale\r\n     * @param totalWeiRaised: Total amount of raised in Wei after sale ended\r\n     * @param round: Round of sale ended\r\n     */\r\n    event SaleEnded(uint256 endTime, uint256 totalWeiRaised, SaleRounds round);\r\n\r\n    /*\r\n     * Event for token purchase\r\n     *\r\n     * @param purchaser: Who paid for the tokens\r\n     * @param value: Amount in Wei paid for purchase\r\n     * @param amount: Amount of tokens purchased\r\n     */\r\n    event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\r\n\r\n    /*\r\n     * Modifier to check current stage is same as expected stage\r\n     *\r\n     * @param expectedStage: Expected current stage\r\n     */\r\n    modifier atStage(Stages expectedStage) {\r\n        require(stage == expectedStage);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Modifier to check current round is sane as expected round\r\n     *\r\n     * @param expectedRound: Expected current round\r\n     */\r\n    modifier atRound(SaleRounds expectedRound) {\r\n        require(round == expectedRound);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Modifier to check purchase is valid\r\n     *\r\n     * 1. Current round must be smaller than CrowdSale\r\n     * 2. Current time must be within sale period\r\n     * 3. Purchaser must be enrolled to whitelist\r\n     * 4. Purchaser address must be correct\r\n     * 5. Contribution must be bigger than minimum contribution for current round\r\n     * 6. Sum of contributions must be smaller than max contribution for current round\r\n     * 7. Total funds raised in current round must be smaller than hard cap for current round\r\n     */\r\n    modifier onlyValidPurchase() {\r\n        require(round <= SaleRounds.CrowdSale);\r\n        require(now >= startTime && now <= endTime);\r\n\r\n        uint256 contributionInWei = msg.value;\r\n        address purchaser = msg.sender;\r\n\r\n        require(whitelist[purchaser]);\r\n        require(purchaser != address(0));\r\n        require(contributionInWei >= roundInfos[uint8(round)].minContribution);\r\n        require(\r\n            contPerRound[purchaser][uint8(round)].add(contributionInWei)\r\n            <= roundInfos[uint8(round)].maxContribution\r\n        );\r\n        require(\r\n            roundInfos[uint8(round)].weiRaised.add(contributionInWei)\r\n            <= roundInfos[uint8(round)].hardCap\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Constructor for AMOCoinSale contract\r\n     *\r\n     * @param AMOToEtherRate: Number of AMO tokens per Ether\r\n     * @param fundAddress: Address where funds are collected\r\n     * @param tokenAddress: Address of AMO Token Contract\r\n     */\r\n    function AMOCoinSale(\r\n        address fundAddress,\r\n        address tokenAddress\r\n    )\r\n        public\r\n    {\r\n        require(fundAddress != address(0));\r\n        require(tokenAddress != address(0));\r\n\r\n        token = AMOCoin(tokenAddress);\r\n        fundAddr = fundAddress;\r\n        stage = Stages.Ended;\r\n        round = SaleRounds.EarlyInvestment;\r\n        uint8 roundIndex = uint8(round);\r\n\r\n        roundInfos[roundIndex].minContribution = BASE_MIN_CONTRIBUTION;\r\n        roundInfos[roundIndex].maxContribution = UINT256_MAX;\r\n        roundInfos[roundIndex].hardCap = BASE_HARD_CAP_PER_ROUND;\r\n        roundInfos[roundIndex].weiRaised = 0;\r\n        roundInfos[roundIndex].rate = BASE_AMO_TO_ETH_RATE;\r\n    }\r\n\r\n    /*\r\n     * Fallback function to buy AMO tokens\r\n     */\r\n    function () public payable {\r\n        buy();\r\n    }\r\n\r\n    /*\r\n     * Withdraw ethers to fund address\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        fundAddr.transfer(this.balance);\r\n    }\r\n\r\n    /*\r\n     * Add users to whitelist\r\n     * Whitelisted users are accumulated on each round\r\n     *\r\n     * @param users: Addresses of users who passed KYC\r\n     */\r\n    function addManyToWhitelist(address[] users) external onlyOwner {\r\n        for (uint32 i = 0; i < users.length; i++) {\r\n            addToWhitelist(users[i]);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Add one user to whitelist\r\n     *\r\n     * @param user: Address of user who passed KYC\r\n     */\r\n    function addToWhitelist(address user) public onlyOwner {\r\n        whitelist[user] = true;\r\n    }\r\n\r\n    /*\r\n     * Remove users from whitelist\r\n     *\r\n     * @param users: Addresses of users who should not belong to whitelist\r\n     */\r\n    function removeManyFromWhitelist(address[] users) external onlyOwner {\r\n        for (uint32 i = 0; i < users.length; i++) {\r\n            removeFromWhitelist(users[i]);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Remove users from whitelist\r\n     *\r\n     * @param users: Addresses of users who should not belong to whitelist\r\n     */\r\n    function removeFromWhitelist(address user) public onlyOwner {\r\n        whitelist[user] = false;\r\n    }\r\n\r\n    /*\r\n     * Set minimum contribution for round\r\n     * User have to send more ether than minimum contribution\r\n     *\r\n     * @param _round: Round to set\r\n     * @param _minContribution: Minimum contribution in wei\r\n     */\r\n    function setMinContributionForRound(\r\n        SaleRounds _round,\r\n        uint256 _minContribution\r\n    )\r\n        public\r\n        onlyOwner\r\n        atStage(Stages.SetUp)\r\n    {\r\n        require(round <= _round);\r\n        roundInfos[uint8(_round)].minContribution =\r\n            (_minContribution == 0) ? BASE_MIN_CONTRIBUTION : _minContribution;\r\n    }\r\n\r\n    /*\r\n     * Set max contribution for round\r\n     * User can't send more ether than the max contributions in round\r\n     *\r\n     * @param _round: Round to set\r\n     * @param _maxContribution: Max contribution in wei\r\n     */\r\n    function setMaxContributionForRound(\r\n        SaleRounds _round,\r\n        uint256 _maxContribution\r\n    )\r\n        public\r\n        onlyOwner\r\n        atStage(Stages.SetUp)\r\n    {\r\n        require(round <= _round);\r\n        roundInfos[uint8(_round)].maxContribution =\r\n            (_maxContribution == 0) ? UINT256_MAX : _maxContribution;\r\n    }\r\n\r\n    /*\r\n     * Set hard cap for round\r\n     * Total wei raised in round should be smaller than hard cap\r\n     *\r\n     * @param _round: Round to set\r\n     * @param _hardCap: Hard cap in wei\r\n     */\r\n    function setHardCapForRound(\r\n        SaleRounds _round,\r\n        uint256 _hardCap\r\n    )\r\n        public\r\n        onlyOwner\r\n        atStage(Stages.SetUp)\r\n    {\r\n        require(round <= _round);\r\n        roundInfos[uint8(_round)].hardCap =\r\n            (_hardCap == 0) ? BASE_HARD_CAP_PER_ROUND : _hardCap;\r\n    }\r\n\r\n    /*\r\n     * Set AMO to Ether rate for round\r\n     *\r\n     * @param _round: Round to set\r\n     * @param _rate: AMO to Ether _rate\r\n     */\r\n    function setRateForRound(\r\n        SaleRounds _round,\r\n        uint256 _rate\r\n    )\r\n        public\r\n        onlyOwner\r\n        atStage(Stages.SetUp)\r\n    {\r\n        require(round <= _round);\r\n        roundInfos[uint8(_round)].rate =\r\n            (_rate == 0) ? BASE_AMO_TO_ETH_RATE : _rate;\r\n    }\r\n\r\n    /*\r\n     * Set up several information for next round\r\n     * Only owner can call this method\r\n     */\r\n    function setUpSale(\r\n        SaleRounds _round,\r\n        uint256 _minContribution,\r\n        uint256 _maxContribution,\r\n        uint256 _hardCap,\r\n        uint256 _rate\r\n    )\r\n        external\r\n        onlyOwner\r\n        atStage(Stages.Ended)\r\n    {\r\n        require(round <= _round);\r\n        stage = Stages.SetUp;\r\n        round = _round;\r\n        setMinContributionForRound(_round, _minContribution);\r\n        setMaxContributionForRound(_round, _maxContribution);\r\n        setHardCapForRound(_round, _hardCap);\r\n        setRateForRound(_round, _rate);\r\n    }\r\n\r\n    /*\r\n     * Start sale in current round\r\n     */\r\n    function startSale(uint256 durationInSeconds)\r\n        external\r\n        onlyOwner\r\n        atStage(Stages.SetUp)\r\n    {\r\n        require(roundInfos[uint8(round)].minContribution > 0\r\n            && roundInfos[uint8(round)].hardCap > 0);\r\n        stage = Stages.Started;\r\n        startTime = now;\r\n        endTime = startTime.add(durationInSeconds);\r\n        SaleStarted(startTime, endTime, round);\r\n    }\r\n\r\n    /*\r\n     * End sale in crrent round\r\n     */\r\n    function endSale() external onlyOwner atStage(Stages.Started) {\r\n        endTime = now;\r\n        stage = Stages.Ended;\r\n\r\n        SaleEnded(endTime, totalWeiRaised, round);\r\n    }\r\n\r\n    function buy()\r\n        public\r\n        payable\r\n        whenNotPaused\r\n        atStage(Stages.Started)\r\n        onlyValidPurchase()\r\n        returns (bool)\r\n    {\r\n        address purchaser = msg.sender;\r\n        uint256 contributionInWei = msg.value;\r\n        uint256 tokenAmount = contributionInWei.mul(roundInfos[uint8(round)].rate);\r\n\r\n        if (!token.transferFrom(token.owner(), purchaser, tokenAmount)) {\r\n            revert();\r\n        }\r\n\r\n        totalWeiRaised = totalWeiRaised.add(contributionInWei);\r\n        roundInfos[uint8(round)].weiRaised =\r\n            roundInfos[uint8(round)].weiRaised.add(contributionInWei);\r\n\r\n        contPerRound[purchaser][uint8(round)] =\r\n            contPerRound[purchaser][uint8(round)].add(contributionInWei);\r\n\r\n        // Transfer contributions to fund address\r\n        fundAddr.transfer(contributionInWei);\r\n        TokenPurchase(msg.sender, contributionInWei, tokenAmount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Add user and his allowed amount to allocation list\r\n     *\r\n     * @param user: Address of user to be allocated tokens\r\n     * @param amount: Allowed allocation amount of user\r\n     */\r\n    function addToAllocationList(address user, uint256 amount)\r\n        public\r\n        onlyOwner\r\n        atRound(SaleRounds.EarlyInvestment)\r\n    {\r\n        allocationList[user].isAllowed = true;\r\n        allocationList[user].allowedAmount = amount;\r\n    }\r\n\r\n    /*\r\n     * Add users and their allowed amount to allocation list\r\n     *\r\n     * @param users: List of Address to be allocated tokens\r\n     * @param amount: List of allowed allocation amount of each user\r\n     */\r\n    function addManyToAllocationList(address[] users, uint256[] amounts)\r\n        external\r\n        onlyOwner\r\n        atRound(SaleRounds.EarlyInvestment)\r\n    {\r\n        require(users.length == amounts.length);\r\n\r\n        for (uint32 i = 0; i < users.length; i++) {\r\n            addToAllocationList(users[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Remove user from allocation list\r\n     *\r\n     * @param user: Address of user to be removed\r\n     */\r\n    function removeFromAllocationList(address user)\r\n        public\r\n        onlyOwner\r\n        atRound(SaleRounds.EarlyInvestment)\r\n    {\r\n        allocationList[user].isAllowed = false;\r\n    }\r\n\r\n    /*\r\n     * Remove users from allocation list\r\n     *\r\n     * @param user: Address list of users to be removed\r\n     */\r\n    function removeManyFromAllocationList(address[] users)\r\n        external\r\n        onlyOwner\r\n        atRound(SaleRounds.EarlyInvestment)\r\n    {\r\n        for (uint32 i = 0; i < users.length; i++) {\r\n            removeFromAllocationList(users[i]);\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Allocate  tokens to user\r\n     * Only avaliable on early investment\r\n     *\r\n     * @param to: Address of user to be allocated tokens\r\n     * @param tokenAmount: Amount of tokens to be allocated\r\n     */\r\n    function allocateTokens(address to, uint256 tokenAmount)\r\n        public\r\n        onlyOwner\r\n        atRound(SaleRounds.EarlyInvestment)\r\n        returns (bool)\r\n    {\r\n        require(allocationList[to].isAllowed\r\n            && tokenAmount <= allocationList[to].allowedAmount);\r\n\r\n        if (!token.transferFrom(token.owner(), to, tokenAmount)) {\r\n            revert();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Allocate  tokens to user\r\n     * Only avaliable on early investment\r\n     *\r\n     * @param toList: List of addresses to be allocated tokens\r\n     * @param tokenAmountList: List of token amount to be allocated to each address\r\n     */\r\n    function allocateTokensToMany(address[] toList, uint256[] tokenAmountList)\r\n        external\r\n        onlyOwner\r\n        atRound(SaleRounds.EarlyInvestment)\r\n        returns (bool)\r\n    {\r\n        require(toList.length == tokenAmountList.length);\r\n\r\n        for (uint32 i = 0; i < toList.length; i++) {\r\n            allocateTokens(toList[i], tokenAmountList[i]);\r\n        }\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"BASE_MIN_CONTRIBUTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint8\"},{\"name\":\"_maxContribution\",\"type\":\"uint256\"}],\"name\":\"setMaxContributionForRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"durationInSeconds\",\"type\":\"uint256\"}],\"name\":\"startSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeFromAllocationList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE_AMO_TO_ETH_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint8\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRateForRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"removeManyFromAllocationList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint8\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"}],\"name\":\"setHardCapForRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"roundInfos\",\"outputs\":[{\"name\":\"minContribution\",\"type\":\"uint256\"},{\"name\":\"maxContribution\",\"type\":\"uint256\"},{\"name\":\"hardCap\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"weiRaised\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toList\",\"type\":\"address[]\"},{\"name\":\"tokenAmountList\",\"type\":\"uint256[]\"}],\"name\":\"allocateTokensToMany\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"addManyToAllocationList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint8\"},{\"name\":\"_minContribution\",\"type\":\"uint256\"},{\"name\":\"_maxContribution\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setUpSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"allocateTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"addManyToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addToAllocationList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE_HARD_CAP_PER_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT256_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint8\"},{\"name\":\"_minContribution\",\"type\":\"uint256\"}],\"name\":\"setMinContributionForRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"removeManyFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"contPerRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"fundAddress\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"SaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalWeiRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"SaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AMOCoinSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000010815c33d08936307c386f56ed00fda1cf92602800000000000000000000000038c87aa89b2b8cd9b95b736e1fa7b612ea972169","Library":"","SwarmSource":"bzzr://06f6367326434cb1cc19984f021bc1a63d32c9c5d2c89df5ba415d5ea5fe1452"}]}