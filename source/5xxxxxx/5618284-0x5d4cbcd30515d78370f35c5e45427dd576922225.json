{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n}\r\n\r\nlibrary GeometricSequence\r\n{\r\n    using SafeMath for uint256;\r\n    function sumOfNGeom(uint256 basePrice, uint256 owned, uint256 count) internal pure returns (uint256 price)\r\n    {\r\n        require(count > 0);\r\n        \r\n        uint256 multiplier = 5;\r\n        \r\n        uint256 basePower = owned / multiplier;\r\n        uint256 endPower = (owned + count) / multiplier;\r\n        \r\n        price = (basePrice * (2**basePower) * multiplier).mul((2**((endPower-basePower)+1))-1);\r\n        \r\n        price = price.sub((basePrice * 2**basePower) * (owned % multiplier));\r\n        price = price.sub((basePrice * 2**endPower) * (multiplier - ((owned + count) % multiplier)));\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n//-----------------------------------------------------------------------\r\ncontract RigIdle is ERC20 {\r\n    using GeometricSequence for uint;\r\n    using SafeMath for uint;\r\n\r\n    struct MinerData \r\n    {\r\n        // rigs and their upgrades\r\n        mapping(uint256=>uint256)  rigCount;\r\n        mapping(int256=>uint256)   rigPctBonus;\r\n        mapping(int256=>uint256)   rigFlatBonus;\r\n        \r\n        uint256 money;\r\n        uint256 lastUpdateTime;\r\n        uint256 unclaimedPot;\r\n        uint256 lastPotClaimIndex;\r\n        uint256 prestigeLevel; \r\n        uint256 prestigeBonusPct;\r\n    }\r\n  \r\n    struct BoostData\r\n    {\r\n        int256  rigIndex;\r\n        uint256 flatBonus;\r\n        uint256 percentBonus;\r\n        \r\n        uint256 priceInWEI;\r\n        uint256 priceIncreasePct;\r\n        uint256 totalCount;\r\n        uint256 currentIndex;\r\n        address[] boostHolders;\r\n    }\r\n    \r\n    struct RigData\r\n    {\r\n        uint256 basePrice;\r\n        uint256 baseOutput;\r\n        uint256 unlockMultiplier;\r\n    }\r\n    \r\n    struct PrestigeData\r\n    {\r\n        uint256 price;\r\n        uint256 productionBonusPct;\r\n    }\r\n    \r\n    mapping(uint256=>RigData) private rigData;\r\n    uint256 private numberOfRigs;\r\n\r\n    // honey pot variables\r\n    uint256 private honeyPotAmount;\r\n    uint256 private devFund;\r\n    uint256 private nextPotDistributionTime;\r\n    mapping(address => mapping(uint256 => uint256)) private minerICOPerCycle;\r\n    uint256[] private honeyPotPerCycle;\r\n    uint256[] private globalICOPerCycle;\r\n    uint256 private cycleCount;\r\n    \r\n    //booster info\r\n    uint256 private numberOfBoosts;\r\n    mapping(uint256=>BoostData) private boostData;\r\n\r\n    //prestige info\r\n    uint256 private maxPrestige;\r\n    mapping(uint256=>PrestigeData) prestigeData;\r\n    \r\n    // miner info\r\n    mapping(address => MinerData) private miners;\r\n    mapping(uint256 => address)   private indexes;\r\n    uint256 private topindex;\r\n    \r\n    address private owner;\r\n    \r\n    // ERC20 functionality\r\n    mapping(address => mapping(address => uint256)) private allowed;\r\n    string public constant name  = \"RigWarsIdle\";\r\n    string public constant symbol = \"RIG\";\r\n    uint8 public constant decimals = 8;\r\n    uint256 private estimatedSupply;\r\n    \r\n    // referral\r\n    mapping(address=>address) referrals;\r\n    \r\n    // Data Store Management\r\n    mapping(uint256=>uint256) private prestigeFinalizeTime;\r\n    mapping(uint256=>uint256) private rigFinalizeTime;\r\n    mapping(uint256=>uint256) private boostFinalizeTime;\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function RigIdle() public {\r\n        owner = msg.sender;\r\n        \r\n        //                   price,           prod.     unlockMultiplier\r\n        rigData[0] = RigData(32,              1,        1);\r\n        rigData[1] = RigData(256,             4,        1); \r\n        rigData[2] = RigData(25600,           64,       2); \r\n        rigData[3] = RigData(512000,          512,      1); \r\n        rigData[4] = RigData(10240000,        8192,     4); \r\n        rigData[5] = RigData(3000000000,      50000,    8); \r\n        rigData[6] = RigData(75000000000,     250000,   10); \r\n        rigData[7] = RigData(2500000000000,   1500000,  1);\r\n\r\n        numberOfRigs = 8;\r\n        \r\n        topindex = 0;\r\n        honeyPotAmount = 0;\r\n        devFund = 0;\r\n        nextPotDistributionTime = block.timestamp;\r\n        \r\n        miners[msg.sender].lastUpdateTime = block.timestamp;\r\n        miners[msg.sender].rigCount[0] = 1;\r\n      \r\n        indexes[topindex] = msg.sender;\r\n        ++topindex;\r\n        \r\n        boostData[0] = BoostData(-1, 0, 100, 0.1 ether, 5, 5, 0, new address[](5));\r\n        boostData[0].boostHolders[0] = 0xe57A18783640c9fA3c5e8E4d4b4443E2024A7ff9;\r\n        boostData[0].boostHolders[1] = 0xf0333B94F895eb5aAb3822Da376F9CbcfcE8A19C;\r\n        boostData[0].boostHolders[2] = 0x85abE8E3bed0d4891ba201Af1e212FE50bb65a26;\r\n        boostData[0].boostHolders[3] = 0x11e52c75998fe2E7928B191bfc5B25937Ca16741;\r\n        boostData[0].boostHolders[4] = 0x522273122b20212FE255875a4737b6F50cc72006;\r\n        \r\n        numberOfBoosts = 1;\r\n        \r\n        prestigeData[0] = PrestigeData(25000, 100);       // before lvl 3\r\n        prestigeData[1] = PrestigeData(25000000, 200);    // befroe lvl 5 ~30min with 30k prod\r\n        prestigeData[2] = PrestigeData(20000000000, 400); // befroe lvl 7 ~6h with 25-30 lvl6 rig\r\n        \r\n        maxPrestige = 3;\r\n        \r\n        honeyPotPerCycle.push(0);\r\n        globalICOPerCycle.push(1);\r\n        cycleCount = 0;\r\n        \r\n        estimatedSupply = 1000000000000000000000000000;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // Data access functions\r\n    //--------------------------------------------------------------------------\r\n    function GetTotalMinerCount() public constant returns (uint256 count)\r\n    {\r\n        count = topindex;\r\n    }\r\n    \r\n    function GetMinerAt(uint256 idx) public constant returns (address minerAddr)\r\n    {\r\n        require(idx < topindex);\r\n        minerAddr = indexes[idx];\r\n    }\r\n    \r\n    function GetProductionPerSecond(address minerAddr) public constant returns (uint256 personalProduction)\r\n    {\r\n        MinerData storage m = miners[minerAddr];\r\n        \r\n        personalProduction = 0;\r\n        uint256 productionSpeedFlat = m.rigFlatBonus[-1];\r\n        \r\n        for(uint8 j = 0; j < numberOfRigs; ++j)\r\n        {\r\n            if(m.rigCount[j] > 0)\r\n                personalProduction += (rigData[j].baseOutput + productionSpeedFlat + m.rigFlatBonus[j]) * m.rigCount[j] * (100 + m.rigPctBonus[j]);\r\n            else\r\n                break;\r\n        }\r\n        \r\n        personalProduction = (personalProduction * ((100 + m.prestigeBonusPct) * (100 + m.rigPctBonus[-1]))) / 1000000;\r\n    }\r\n    \r\n    function GetMinerData(address minerAddr) public constant returns \r\n        (uint256 money, uint256 lastupdate, uint256 prodPerSec, \r\n         uint256 unclaimedPot, uint256 globalFlat, uint256 globalPct, uint256 prestigeLevel)\r\n    {\r\n        money = miners[minerAddr].money;\r\n        lastupdate = miners[minerAddr].lastUpdateTime;\r\n        prodPerSec = GetProductionPerSecond(minerAddr);\r\n     \r\n        unclaimedPot = miners[minerAddr].unclaimedPot;\r\n        \r\n        globalFlat = miners[minerAddr].rigFlatBonus[-1];\r\n        globalPct  = miners[minerAddr].rigPctBonus[-1];\r\n        \r\n        prestigeLevel = miners[minerAddr].prestigeLevel;\r\n    }\r\n    \r\n    function GetMinerRigsCount(address minerAddr, uint256 startIdx) public constant returns (uint256[10] rigs, uint256[10] totalProduction)\r\n    {\r\n        uint256 i = startIdx;\r\n        MinerData storage m = miners[minerAddr];\r\n        \r\n        for(i = startIdx; i < (startIdx+10) && i < numberOfRigs; ++i)\r\n        {\r\n            rigs[i]      = miners[minerAddr].rigCount[i];\r\n            totalProduction[i] = (rigData[i].baseOutput + m.rigFlatBonus[-1] + m.rigFlatBonus[int256(i)]) * ((100 + m.rigPctBonus[int256(i)]) *\r\n              (100 + m.prestigeBonusPct) * (100 + m.rigPctBonus[-1])) / 1000000;\r\n        }\r\n    }\r\n    \r\n    function GetTotalRigCount() public constant returns (uint256)\r\n    {\r\n        return numberOfRigs;\r\n    }\r\n    \r\n    function GetRigData(uint256 idx) public constant returns (uint256 _basePrice, uint256 _baseOutput, uint256 _unlockMultiplier, uint256 _lockTime)\r\n    {\r\n        require(idx < numberOfRigs);\r\n        \r\n        _basePrice  = rigData[idx].basePrice;\r\n        _baseOutput = rigData[idx].baseOutput;\r\n        _unlockMultiplier  = rigData[idx].unlockMultiplier;\r\n        _lockTime = rigFinalizeTime[idx];\r\n    }\r\n    \r\n    function CalculatePriceofRigs(uint256 idx, uint256 owned, uint256 count) public constant returns (uint256)\r\n    {\r\n        if(idx >= numberOfRigs)\r\n            return 0;\r\n            \r\n        if(owned == 0)\r\n            return (rigData[idx].basePrice * rigData[idx].unlockMultiplier);\r\n            \r\n        return GeometricSequence.sumOfNGeom(rigData[idx].basePrice, owned, count); \r\n    }\r\n    \r\n    function GetMaxPrestigeLevel() public constant returns (uint256)\r\n    {\r\n        return maxPrestige;\r\n    }\r\n    \r\n    function GetPrestigeInfo(uint256 idx) public constant returns (uint256 price, uint256 bonusPct, uint256 _lockTime)\r\n    {\r\n        require(idx < maxPrestige);\r\n        \r\n        price = prestigeData[idx].price;\r\n        bonusPct = prestigeData[idx].productionBonusPct;\r\n        _lockTime = prestigeFinalizeTime[idx];\r\n    }\r\n  \r\n    function GetPotInfo() public constant returns (uint256 _honeyPotAmount, uint256 _devFunds, uint256 _nextDistributionTime)\r\n    {\r\n        _honeyPotAmount = honeyPotAmount;\r\n        _devFunds = devFund;\r\n        _nextDistributionTime = nextPotDistributionTime;\r\n    }\r\n    \r\n    function GetGlobalProduction() public constant returns (uint256 globalMoney, uint256 globalHashRate)\r\n    {\r\n        globalMoney = 0;\r\n        globalHashRate = 0;\r\n        uint i = 0;\r\n        for(i = 0; i < topindex; ++i)\r\n        {\r\n            MinerData storage m = miners[indexes[i]];\r\n            globalMoney += m.money;\r\n            globalHashRate += GetProductionPerSecond(indexes[i]);\r\n        }\r\n    }\r\n    \r\n    function GetBoosterCount() public constant returns (uint256)\r\n    {\r\n        return numberOfBoosts;\r\n    }\r\n  \r\n    function GetBoosterData(uint256 idx) public constant returns (int256 rigIdx, uint256 flatBonus, uint256 ptcBonus, \r\n        uint256 currentPrice, uint256 increasePct, uint256 maxNumber, uint256 _lockTime)\r\n    {\r\n        require(idx < numberOfBoosts);\r\n        \r\n        rigIdx       = boostData[idx].rigIndex;\r\n        flatBonus    = boostData[idx].flatBonus;\r\n        ptcBonus     = boostData[idx].percentBonus;\r\n        currentPrice = boostData[idx].priceInWEI;\r\n        increasePct  = boostData[idx].priceIncreasePct;\r\n        maxNumber    = boostData[idx].totalCount;\r\n        _lockTime    = boostFinalizeTime[idx];\r\n    }\r\n    \r\n    function HasBooster(address addr, uint256 startIdx) public constant returns (uint8[10] hasBoost)\r\n    { \r\n        require(startIdx < numberOfBoosts);\r\n        \r\n        uint j = 0;\r\n        \r\n        for( ;j < 10 && (j + startIdx) < numberOfBoosts; ++j)\r\n        {\r\n            BoostData storage b = boostData[j + startIdx];\r\n            hasBoost[j] = 0;\r\n            for(uint i = 0; i < b.totalCount; ++i)\r\n            {\r\n               if(b.boostHolders[i] == addr)\r\n                    hasBoost[j] = 1;\r\n            }\r\n        }\r\n        for( ;j < 10; ++j)\r\n        {\r\n            hasBoost[j] = 0;\r\n        }\r\n    }\r\n    \r\n    function GetCurrentICOCycle() public constant returns (uint256)\r\n    {\r\n        return cycleCount;\r\n    }\r\n    \r\n    function GetICOData(uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOPot)\r\n    {\r\n        require(idx <= cycleCount);\r\n        ICOFund = globalICOPerCycle[idx];\r\n        if(idx < cycleCount)\r\n        {\r\n            ICOPot = honeyPotPerCycle[idx];\r\n        } else\r\n        {\r\n            ICOPot =  honeyPotAmount / 5; // actual day estimate\r\n        }\r\n    }\r\n    \r\n    function GetMinerICOData(address miner, uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOShare, uint256 lastClaimIndex)\r\n    {\r\n        require(idx <= cycleCount);\r\n        ICOFund = minerICOPerCycle[miner][idx];\r\n        if(idx < cycleCount)\r\n        {\r\n            ICOShare = (honeyPotPerCycle[idx] * minerICOPerCycle[miner][idx]) / globalICOPerCycle[idx];\r\n        } else \r\n        {\r\n            ICOShare = (honeyPotAmount / 5) * minerICOPerCycle[miner][idx] / globalICOPerCycle[idx];\r\n        }\r\n        lastClaimIndex = miners[miner].lastPotClaimIndex;\r\n    }\r\n    \r\n    function GetMinerUnclaimedICOShare(address miner) public constant returns (uint256 unclaimedPot)\r\n    {\r\n        MinerData storage m = miners[miner];\r\n        \r\n        require(m.lastUpdateTime != 0);\r\n        require(m.lastPotClaimIndex <= cycleCount);\r\n        \r\n        uint256 i = m.lastPotClaimIndex;\r\n        uint256 limit = cycleCount;\r\n        \r\n        if((limit - i) > 30) // more than 30 iterations(days) afk\r\n            limit = i + 30;\r\n        \r\n        unclaimedPot = 0;\r\n        for(; i < cycleCount; ++i)\r\n        {\r\n            if(minerICOPerCycle[msg.sender][i] > 0)\r\n                unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[msg.sender][i]) / globalICOPerCycle[i];\r\n        }\r\n    }\r\n    \r\n    // -------------------------------------------------------------------------\r\n    // RigWars game handler functions\r\n    // -------------------------------------------------------------------------\r\n    function StartNewMiner(address referral) external\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime == 0);\r\n        require(referral != msg.sender);\r\n        \r\n        miners[msg.sender].lastUpdateTime = block.timestamp;\r\n        miners[msg.sender].lastPotClaimIndex = cycleCount;\r\n        \r\n        miners[msg.sender].rigCount[0] = 1;\r\n        \r\n        indexes[topindex] = msg.sender;\r\n        ++topindex;\r\n        \r\n        if(referral != owner && referral != 0 && miners[referral].lastUpdateTime != 0)\r\n        {\r\n            referrals[msg.sender] = referral;\r\n            miners[msg.sender].rigCount[0] += 9;\r\n        }\r\n    }\r\n    \r\n    function UpgradeRig(uint8 rigIdx, uint256 count) external\r\n    {\r\n        require(rigIdx < numberOfRigs);\r\n        require(count > 0);\r\n        require(count <= 512);\r\n        require(rigFinalizeTime[rigIdx] < block.timestamp);\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        \r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        require(m.rigCount[rigIdx] > 0);\r\n        require(512 >= (m.rigCount[rigIdx] + count));\r\n        \r\n        UpdateMoney(msg.sender);\r\n     \r\n        // the base of geometrical sequence\r\n        uint256 price = GeometricSequence.sumOfNGeom(rigData[rigIdx].basePrice, m.rigCount[rigIdx], count); \r\n       \r\n        require(m.money >= price);\r\n        \r\n        m.rigCount[rigIdx] = m.rigCount[rigIdx] + count;\r\n        \r\n        m.money -= price;\r\n    }\r\n    \r\n    function UnlockRig(uint8 rigIdx) external\r\n    {\r\n        require(rigIdx < numberOfRigs);\r\n        require(rigIdx > 0);\r\n        require(rigFinalizeTime[rigIdx] < block.timestamp);\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        \r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        require(m.rigCount[rigIdx] == 0);\r\n        require(m.rigCount[rigIdx-1] > 0);\r\n        \r\n        UpdateMoney(msg.sender);\r\n        \r\n        uint256 price = rigData[rigIdx].basePrice * rigData[rigIdx].unlockMultiplier;\r\n        \r\n        require(m.money >= price);\r\n        \r\n        m.rigCount[rigIdx] = 1;\r\n        m.money -= price;\r\n    }\r\n    \r\n    function PrestigeUp() external\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(prestigeFinalizeTime[m.prestigeLevel] < block.timestamp);\r\n        \r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        require(m.prestigeLevel < maxPrestige);\r\n        \r\n        UpdateMoney(msg.sender);\r\n        \r\n        require(m.money >= prestigeData[m.prestigeLevel].price);\r\n        \r\n        if(referrals[msg.sender] != 0)\r\n        {\r\n            miners[referrals[msg.sender]].money += prestigeData[m.prestigeLevel].price / 2;\r\n        }\r\n        \r\n        for(uint256 i = 0; i < numberOfRigs; ++i)\r\n        {\r\n            if(m.rigCount[i] > 1)\r\n                m.rigCount[i] = m.rigCount[i] / 2; \r\n        }\r\n        \r\n        m.money = 0;\r\n        m.prestigeBonusPct += prestigeData[m.prestigeLevel].productionBonusPct;\r\n        m.prestigeLevel += 1;\r\n    }\r\n \r\n    function UpdateMoney(address addr) private\r\n    {\r\n        require(block.timestamp > miners[addr].lastUpdateTime);\r\n        \r\n        if(miners[addr].lastUpdateTime != 0)\r\n        {\r\n            MinerData storage m = miners[addr];\r\n            uint256 diff = block.timestamp - m.lastUpdateTime;\r\n            uint256 revenue = GetProductionPerSecond(addr);\r\n       \r\n            m.lastUpdateTime = block.timestamp;\r\n            if(revenue > 0)\r\n            {\r\n                revenue *= diff;\r\n                \r\n                m.money += revenue;\r\n            }\r\n        }\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // BOOSTER handlers\r\n    //--------------------------------------------------------------------------\r\n    function BuyBooster(uint256 idx) external payable \r\n    {\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(idx < numberOfBoosts);\r\n        require(boostFinalizeTime[idx] < block.timestamp);\r\n        \r\n        BoostData storage b = boostData[idx];\r\n        \r\n        require(msg.value >= b.priceInWEI);\r\n        \r\n        for(uint i = 0; i < b.totalCount; ++i)\r\n            if(b.boostHolders[i] == msg.sender)\r\n                revert();\r\n                \r\n        address beneficiary = b.boostHolders[b.currentIndex];\r\n        \r\n        MinerData storage m = miners[beneficiary];\r\n        MinerData storage m2 = miners[msg.sender];\r\n        \r\n        // distribute the ETH\r\n        m.unclaimedPot += (msg.value * 9) / 10;\r\n        honeyPotAmount += msg.value / 20;\r\n        devFund += msg.value / 20;\r\n        \r\n        // increase price by X%\r\n        b.priceInWEI += (b.priceInWEI * b.priceIncreasePct) / 100;\r\n        \r\n        UpdateMoney(msg.sender);\r\n        UpdateMoney(beneficiary);\r\n        \r\n        // transfer ownership    \r\n        b.boostHolders[b.currentIndex] = msg.sender;\r\n        \r\n        // handle booster bonuses\r\n        if(m.rigFlatBonus[b.rigIndex] >= b.flatBonus){\r\n            m.rigFlatBonus[b.rigIndex] -= b.flatBonus;\r\n        } else {\r\n            m.rigFlatBonus[b.rigIndex] = 0;\r\n        }\r\n        \r\n        if(m.rigPctBonus[b.rigIndex] >= b.percentBonus) {\r\n            m.rigPctBonus[b.rigIndex] -= b.percentBonus;\r\n        } else {\r\n            m.rigPctBonus[b.rigIndex] = 0;\r\n        }\r\n        \r\n        m2.rigFlatBonus[b.rigIndex] += b.flatBonus;\r\n        m2.rigPctBonus[b.rigIndex] += b.percentBonus;\r\n        \r\n        // increase booster index\r\n        b.currentIndex += 1;\r\n        if(b.currentIndex >= b.totalCount)\r\n            b.currentIndex = 0;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // ICO/Pot share functions\r\n    //--------------------------------------------------------------------------\r\n    function ReleaseICO() external\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(nextPotDistributionTime <= block.timestamp);\r\n        require(honeyPotAmount > 0);\r\n        require(globalICOPerCycle[cycleCount] > 0);\r\n\r\n        nextPotDistributionTime = block.timestamp + 86400;\r\n\r\n        honeyPotPerCycle[cycleCount] = honeyPotAmount / 4; // 25% of the pot\r\n        \r\n        honeyPotAmount -= honeyPotAmount / 4;\r\n\r\n        honeyPotPerCycle.push(0);\r\n        globalICOPerCycle.push(0);\r\n        cycleCount = cycleCount + 1;\r\n    }\r\n    \r\n    function FundICO(uint amount) external\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(amount > 0);\r\n        \r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        UpdateMoney(msg.sender);\r\n        \r\n        require(m.money >= amount);\r\n        \r\n        m.money = (m.money).sub(amount);\r\n        \r\n        globalICOPerCycle[cycleCount] = globalICOPerCycle[cycleCount].add(uint(amount));\r\n        minerICOPerCycle[msg.sender][cycleCount] = minerICOPerCycle[msg.sender][cycleCount].add(uint(amount));\r\n    }\r\n    \r\n    function WithdrawICOEarnings() external\r\n    {\r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(miners[msg.sender].lastPotClaimIndex < cycleCount);\r\n        \r\n        uint256 i = m.lastPotClaimIndex;\r\n        uint256 limit = cycleCount;\r\n        \r\n        if((limit - i) > 30) // more than 30 iterations(days) afk\r\n            limit = i + 30;\r\n        \r\n        m.lastPotClaimIndex = limit;\r\n        for(; i < cycleCount; ++i)\r\n        {\r\n            if(minerICOPerCycle[msg.sender][i] > 0)\r\n                m.unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[msg.sender][i]) / globalICOPerCycle[i];\r\n        }\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // Data Storage Management\r\n    //--------------------------------------------------------------------------\r\n     function AddNewBooster(uint256 idx, int256 _rigType, uint256 _flatBonus, uint256 _pctBonus, \r\n      uint256 _ETHPrice, uint256 _priceIncreasePct, uint256 _totalCount) external\r\n    {\r\n        require(msg.sender == owner);\r\n        require(idx <= numberOfBoosts);\r\n        \r\n        if(idx < numberOfBoosts)\r\n            require(boostFinalizeTime[idx] > block.timestamp); \r\n            \r\n        boostFinalizeTime[idx] = block.timestamp + 7200;\r\n        \r\n        boostData[idx].rigIndex = _rigType;\r\n        boostData[idx].flatBonus = _flatBonus;\r\n        boostData[idx].percentBonus = _pctBonus;\r\n        \r\n        boostData[idx].priceInWEI = _ETHPrice;\r\n        boostData[idx].priceIncreasePct = _priceIncreasePct;\r\n        boostData[idx].totalCount = _totalCount;\r\n        boostData[idx].currentIndex = 0;\r\n        \r\n        boostData[idx].boostHolders = new address[](_totalCount);\r\n        \r\n        for(uint256 i = 0; i < _totalCount; ++i)\r\n            boostData[idx].boostHolders[i] = owner;\r\n        \r\n        if(idx == numberOfBoosts)    \r\n            numberOfBoosts += 1;\r\n    }\r\n    \r\n    function AddorModifyRig(uint256 idx, uint256 _basePrice, uint256 _baseOutput, uint256 _unlockMultiplier) external\r\n    {\r\n        require(msg.sender == owner);\r\n        require(idx <= numberOfRigs);\r\n        \r\n        if(idx < numberOfRigs)\r\n            require(rigFinalizeTime[idx] > block.timestamp); \r\n            \r\n        rigFinalizeTime[idx] = block.timestamp + 7200;\r\n        \r\n        rigData[idx].basePrice     = _basePrice;\r\n        rigData[idx].baseOutput    = _baseOutput;\r\n        rigData[idx].unlockMultiplier = _unlockMultiplier;\r\n        \r\n        if(idx == numberOfRigs)\r\n            numberOfRigs += 1;\r\n    }\r\n    \r\n    function AddNewPrestige(uint256 idx, uint256 _price, uint256 _bonusPct) public\r\n    {\r\n        require(msg.sender == owner);\r\n        require(idx <= maxPrestige);\r\n        \r\n        if(idx < maxPrestige)\r\n            require(prestigeFinalizeTime[idx] > block.timestamp); \r\n            \r\n        prestigeFinalizeTime[idx] = block.timestamp + 7200;\r\n        \r\n        prestigeData[idx].price = _price;\r\n        prestigeData[idx].productionBonusPct = _bonusPct;\r\n        \r\n        if(idx == maxPrestige)\r\n            maxPrestige += 1;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // ETH handler functions\r\n    //--------------------------------------------------------------------------\r\n    function WithdrawPotShare() public\r\n    {\r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        require(m.unclaimedPot > 0);\r\n        require(m.lastUpdateTime != 0);\r\n        \r\n        uint256 amntToSend = m.unclaimedPot;\r\n        m.unclaimedPot = 0;\r\n        \r\n        if(msg.sender.send(amntToSend))\r\n        {\r\n            m.unclaimedPot = 0;\r\n        }\r\n    }\r\n    \r\n    function WithdrawDevFunds() public\r\n    {\r\n        require(msg.sender == owner);\r\n\r\n        if(owner.send(devFund))\r\n        {\r\n            devFund = 0;\r\n        }\r\n    }\r\n    \r\n    // fallback payment to pot\r\n    function() public payable {\r\n         devFund += msg.value;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // ERC20 support\r\n    //--------------------------------------------------------------------------\r\n    function totalSupply() public constant returns(uint256) {\r\n        return estimatedSupply;\r\n    }\r\n    \r\n    function balanceOf(address miner) public constant returns(uint256) {\r\n        return miners[miner].money;\r\n    }\r\n    \r\n     function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        require(amount <= miners[msg.sender].money);\r\n        \r\n        miners[msg.sender].money = (miners[msg.sender].money).sub(amount);\r\n        miners[recipient].money  = (miners[recipient].money).add(amount);\r\n        \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address miner, address recipient, uint256 amount) public returns (bool) {\r\n        require(amount <= allowed[miner][msg.sender] && amount <= balanceOf(miner));\r\n        \r\n        miners[miner].money        = (miners[miner].money).sub(amount);\r\n        miners[recipient].money    = (miners[recipient].money).add(amount);\r\n        allowed[miner][msg.sender] = (allowed[miner][msg.sender]).sub(amount);\r\n        \r\n        emit Transfer(miner, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address approvee, uint256 amount) public returns (bool){\r\n        require(amount <= miners[msg.sender].money);\r\n        \r\n        allowed[msg.sender][approvee] = amount;\r\n        emit Approval(msg.sender, approvee, amount);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address miner, address approvee) public constant returns(uint256){\r\n        return allowed[miner][approvee];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"owned\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"CalculatePriceofRigs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"name\":\"GetProductionPerSecond\",\"outputs\":[{\"name\":\"personalProduction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvee\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"startIdx\",\"type\":\"uint256\"}],\"name\":\"HasBooster\",\"outputs\":[{\"name\":\"hasBoost\",\"type\":\"uint8[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetRigData\",\"outputs\":[{\"name\":\"_basePrice\",\"type\":\"uint256\"},{\"name\":\"_baseOutput\",\"type\":\"uint256\"},{\"name\":\"_unlockMultiplier\",\"type\":\"uint256\"},{\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"StartNewMiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawPotShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetTotalRigCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"GetMinerUnclaimedICOShare\",\"outputs\":[{\"name\":\"unclaimedPot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetMaxPrestigeLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"BuyBooster\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rigIdx\",\"type\":\"uint8\"}],\"name\":\"UnlockRig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetGlobalProduction\",\"outputs\":[{\"name\":\"globalMoney\",\"type\":\"uint256\"},{\"name\":\"globalHashRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_bonusPct\",\"type\":\"uint256\"}],\"name\":\"AddNewPrestige\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"_basePrice\",\"type\":\"uint256\"},{\"name\":\"_baseOutput\",\"type\":\"uint256\"},{\"name\":\"_unlockMultiplier\",\"type\":\"uint256\"}],\"name\":\"AddorModifyRig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetPotInfo\",\"outputs\":[{\"name\":\"_honeyPotAmount\",\"type\":\"uint256\"},{\"name\":\"_devFunds\",\"type\":\"uint256\"},{\"name\":\"_nextDistributionTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rigIdx\",\"type\":\"uint8\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"UpgradeRig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetBoosterCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawDevFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"},{\"name\":\"startIdx\",\"type\":\"uint256\"}],\"name\":\"GetMinerRigsCount\",\"outputs\":[{\"name\":\"rigs\",\"type\":\"uint256[10]\"},{\"name\":\"totalProduction\",\"type\":\"uint256[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetTotalMinerCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetCurrentICOCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"},{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetMinerICOData\",\"outputs\":[{\"name\":\"ICOFund\",\"type\":\"uint256\"},{\"name\":\"ICOShare\",\"type\":\"uint256\"},{\"name\":\"lastClaimIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetPrestigeInfo\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"bonusPct\",\"type\":\"uint256\"},{\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetICOData\",\"outputs\":[{\"name\":\"ICOFund\",\"type\":\"uint256\"},{\"name\":\"ICOPot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"name\":\"GetMinerData\",\"outputs\":[{\"name\":\"money\",\"type\":\"uint256\"},{\"name\":\"lastupdate\",\"type\":\"uint256\"},{\"name\":\"prodPerSec\",\"type\":\"uint256\"},{\"name\":\"unclaimedPot\",\"type\":\"uint256\"},{\"name\":\"globalFlat\",\"type\":\"uint256\"},{\"name\":\"globalPct\",\"type\":\"uint256\"},{\"name\":\"prestigeLevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetMinerAt\",\"outputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawICOEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"},{\"name\":\"approvee\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ReleaseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetBoosterData\",\"outputs\":[{\"name\":\"rigIdx\",\"type\":\"int256\"},{\"name\":\"flatBonus\",\"type\":\"uint256\"},{\"name\":\"ptcBonus\",\"type\":\"uint256\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"increasePct\",\"type\":\"uint256\"},{\"name\":\"maxNumber\",\"type\":\"uint256\"},{\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"PrestigeUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"_rigType\",\"type\":\"int256\"},{\"name\":\"_flatBonus\",\"type\":\"uint256\"},{\"name\":\"_pctBonus\",\"type\":\"uint256\"},{\"name\":\"_ETHPrice\",\"type\":\"uint256\"},{\"name\":\"_priceIncreasePct\",\"type\":\"uint256\"},{\"name\":\"_totalCount\",\"type\":\"uint256\"}],\"name\":\"AddNewBooster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RigIdle","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7f6a35d5ef5379372c64b75150305b56a5aada85c7fff4a7d87cca404c5eea01"}]}