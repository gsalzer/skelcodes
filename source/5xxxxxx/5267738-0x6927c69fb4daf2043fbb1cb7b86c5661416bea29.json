{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/// @title SafeMath contract - Math operations with safety checks.\r\n/// @author OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\ncontract SafeMath {\r\n    function mulsm(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function divsm(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function subsm(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function addsm(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function powsm(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint c = a ** b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    event NewOwner(address old, address current);\r\n    event NewPotentialOwner(address old, address potential);\r\n\r\n    address public owner = msg.sender;\r\n    address public potentialOwner;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPotentialOwner {\r\n        require(msg.sender == potentialOwner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _new) public onlyOwner {\r\n        emit NewPotentialOwner(owner, _new);\r\n        potentialOwner = _new;\r\n    }\r\n\r\n    function confirmOwnership() public onlyPotentialOwner {\r\n        emit NewOwner(owner, potentialOwner);\r\n        owner = potentialOwner;\r\n        potentialOwner = 0;\r\n    }\r\n}\r\n\r\ncontract Managed is Owned {\r\n\r\n    event NewManager(address owner, address manager);\r\n\r\n    mapping (address => bool) public manager;\r\n\r\n    modifier onlyManager() {\r\n        require(manager[msg.sender] == true || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setManager(address _manager) public onlyOwner {\r\n        emit NewManager(owner, _manager);\r\n        manager[_manager] = true;\r\n    }\r\n\r\n    function superManager(address _manager) internal {\r\n        emit NewManager(owner, _manager);\r\n        manager[_manager] = true;\r\n    }\r\n\r\n    function delManager(address _manager) public onlyOwner {\r\n        emit NewManager(owner, _manager);\r\n        manager[_manager] = false;\r\n    }\r\n}\r\n\r\n/// @title Abstract Token, ERC20 token interface\r\ncontract ERC20 {\r\n\r\n    function name() constant public returns (string);\r\n    function symbol() constant public returns (string);\r\n    function decimals() constant public returns (uint8);\r\n    function totalSupply() constant public returns (uint256);\r\n    function balanceOf(address owner) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// Full complete implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\r\ncontract StandardToken is SafeMath, ERC20  {\r\n\r\n    string  public name;\r\n    string  public symbol;\r\n    uint8   public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /// @dev Returns number of tokens owned by given address.\r\n    function name() public view returns (string) {\r\n        return name;\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address.\r\n    function symbol() public view returns (string) {\r\n        return symbol;\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address.\r\n    function decimals() public view returns (uint8) {\r\n        return decimals;\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by given address.\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n\r\n    /// @dev Returns number of tokens owned by given address.\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @dev Transfers sender's tokens to a given address. Returns success.\r\n    /// @param _to Address of token receiver.\r\n    /// @param _value Number of tokens to transfer.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(this)); //prevent direct send to contract\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n/**\r\n   @title ERC827 interface, an extension of ERC20 token standard\r\n\r\n   Interface of a ERC827 token, following the ERC20 standard with extra\r\n   methods to transfer value and data and execute calls in transfers and\r\n   approvals.\r\n */\r\ncontract ERC827 {\r\n\r\n  function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\r\n  function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\r\n  function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\r\n\r\n}\r\n\r\n/**\r\n   @title ERC827, an extension of ERC20 token standard\r\n\r\n   Implementation the ERC827, following the ERC20 standard with extra\r\n   methods to transfer value and data and execute calls in transfers and\r\n   approvals.\r\n   Uses OpenZeppelin StandardToken.\r\n */\r\ncontract ERC827Token is ERC827, StandardToken {\r\n\r\n  /**\r\n     @dev Addition to ERC20 token methods. It allows to\r\n     approve the transfer of value and execute a call with the sent data.\r\n\r\n     Beware that changing an allowance with this method brings the risk that\r\n     someone may use both the old and the new allowance by unfortunate\r\n     transaction ordering. One possible solution to mitigate this race condition\r\n     is to first reduce the spender's allowance to 0 and set the desired value\r\n     afterwards:\r\n     https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\r\n     @param _spender The address that will spend the funds.\r\n     @param _value The amount of tokens to be spent.\r\n     @param _data ABI-encoded contract call to call `_to` address.\r\n\r\n     @return true if the call function was executed successfully\r\n   */\r\n  function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\r\n    require(_spender != address(this));\r\n\r\n    super.approve(_spender, _value);\r\n\r\n    require(_spender.call(_data));\r\n\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\r\n    require(_to != address(this));\r\n\r\n    super.transfer(_to, _value);\r\n\r\n    require(_to.call(_data));\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\r\n    require(_to != address(this));\r\n\r\n    super.transferFrom(_from, _to, _value);\r\n\r\n    require(_to.call(_data));\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract MintableToken is ERC827Token {\r\n\r\n        uint256 constant maxSupply = 1e30; // max amount of tokens 1 trillion\r\n        bool internal mintable = true;\r\n\r\n        modifier isMintable() {\r\n            require(mintable);\r\n            _;\r\n        }\r\n\r\n        function stopMint() internal {\r\n            mintable = false;\r\n        }\r\n\r\n        // triggered when the total supply is increased\r\n        event Issuance(uint256 _amount);\r\n        // triggered when the total supply is decreased\r\n        event Destruction(uint256 _amount);\r\n\r\n        /**\r\n            @dev increases the token supply and sends the new tokens to an account\r\n            can only be called by the contract owner\r\n            @param _to         account to receive the new amount\r\n            @param _amount     amount to increase the supply by\r\n        */\r\n        function issue(address _to, uint256 _amount) internal {\r\n            assert(totalSupply + _amount <= maxSupply); // prevent overflows\r\n            totalSupply +=  _amount;\r\n            balances[_to] += _amount;\r\n            emit Issuance(_amount);\r\n            emit Transfer(this, _to, _amount);\r\n        }\r\n\r\n        /**\r\n            @dev removes tokens from an account and decreases the token supply\r\n            can only be called by the contract owner\r\n            (if robbers detected, if will be consensus about token amount)\r\n\r\n            @param _from       account to remove the amount from\r\n            @param _amount     amount to decrease the supply by\r\n        */\r\n        /* function destroy(address _from, uint256 _amount) public onlyOwner {\r\n            balances[_from] -= _amount;\r\n            _totalSupply -= _amount;\r\n            Transfer(_from, this, _amount);\r\n            Destruction(_amount);\r\n        } */\r\n}\r\n\r\ncontract PaymentManager is MintableToken, Owned {\r\n\r\n    uint256 public receivedWais;\r\n    uint256 internal _price;\r\n    bool internal paused = false;\r\n\r\n    modifier isSuspended() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n   function setPrice(uint256 _value) public onlyOwner returns (bool) {\r\n        _price = _value;\r\n        return true;\r\n    }\r\n\r\n    function watchPrice() public view returns (uint256 price) {\r\n        return _price;\r\n    }\r\n\r\n    function rateSystem(address _to, uint256 _value) internal returns (bool) {\r\n        uint256 _amount;\r\n        if(_value >= (1 ether / 1000) && _value <= 1 ether) {\r\n            _amount = _value * _price;\r\n        } else\r\n        if(_value >= 1 ether) {\r\n             _amount = divsm(powsm(_value, 2), 1 ether) * _price;\r\n        }\r\n        issue(_to, _amount);\r\n        if(paused == false) {\r\n            if(totalSupply > 1 * 10e9 * 1 * 1 ether) paused = true; // if more then 10 billions stop sell\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /** @dev transfer ethereum from contract */\r\n    function transferEther(address _to, uint256 _value) public onlyOwner {\r\n        _to.transfer(_value);\r\n    }\r\n}\r\n\r\ncontract InvestBox is PaymentManager, Managed {\r\n\r\n    // triggered when the amount of reaward are changed\r\n    event BonusChanged(uint256 _amount);\r\n    // triggered when making invest\r\n    event Invested(address _from, uint256 _value);\r\n    // triggered when invest closed or updated\r\n    event InvestClosed(address _who, uint256 _value);\r\n    // triggered when counted\r\n    event Counted(address _sender, uint256 _intervals);\r\n\r\n    uint256 constant _day = 24 * 60 * 60 * 1 seconds;\r\n\r\n    bytes5 internal _td = bytes5(\"day\");\r\n    bytes5 internal _tw = bytes5(\"week\");\r\n    bytes5 internal _tm = bytes5(\"month\");\r\n    bytes5 internal _ty = bytes5(\"year\");\r\n\r\n    uint256 internal _creation;\r\n    uint256 internal _1sty;\r\n    uint256 internal _2ndy;\r\n\r\n    uint256 internal min_invest;\r\n    uint256 internal max_invest;\r\n\r\n    struct invest {\r\n        bool exists;\r\n        uint256 balance;\r\n        uint256 created; // creation time\r\n        uint256 closed;  // closing time\r\n    }\r\n\r\n    mapping (address => mapping (bytes5 => invest)) public investInfo;\r\n\r\n    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    /** @dev return in interface string encoded to bytes (max len 5 bytes) */\r\n    function stringToBytes5(string _data) public pure returns (bytes5) {\r\n        return bytes5(stringToBytes32(_data));\r\n    }\r\n\r\n    struct intervalBytecodes {\r\n        string day;\r\n        string week;\r\n        string month;\r\n        string year;\r\n    }\r\n\r\n    intervalBytecodes public IntervalBytecodes;\r\n\r\n    /** @dev setter min max params for investition */\r\n    function setMinMaxInvestValue(uint256 _min, uint256 _max) public onlyOwner {\r\n        min_invest = _min * 10 ** uint256(decimals);\r\n        max_invest = _max * 10 ** uint256(decimals);\r\n    }\r\n\r\n    /** @dev number of complete cycles d/m/w/y */\r\n    function countPeriod(address _investor, bytes5 _t) internal view returns (uint256) {\r\n        uint256 _period;\r\n        uint256 _now = now; // blocking timestamp\r\n        if (_t == _td) _period = 1 * _day;\r\n        if (_t == _tw) _period = 7 * _day;\r\n        if (_t == _tm) _period = 31 * _day;\r\n        if (_t == _ty) _period = 365 * _day;\r\n        invest storage inv = investInfo[_investor][_t];\r\n        if (_now - inv.created < _period) return 0;\r\n        return (_now - inv.created)/_period; // get full days\r\n    }\r\n\r\n    /** @dev loop 'for' wrapper, where 100,000%, 10^3 decimal */\r\n    function loopFor(uint256 _condition, uint256 _data, uint256 _bonus) internal pure returns (uint256 r) {\r\n        assembly {\r\n            for { let i := 0 } lt(i, _condition) { i := add(i, 1) } {\r\n              let m := mul(_data, _bonus)\r\n              let d := div(m, 100000)\r\n              _data := add(_data, d)\r\n            }\r\n            r := _data\r\n        }\r\n    }\r\n\r\n    /** @dev invest box controller */\r\n    function rewardController(address _investor, bytes5 _type) internal view returns (uint256) {\r\n\r\n        uint256 _period;\r\n        uint256 _balance;\r\n        uint256 _created;\r\n\r\n        invest storage inv = investInfo[msg.sender][_type];\r\n\r\n        _period = countPeriod(_investor, _type);\r\n        _balance = inv.balance;\r\n        _created = inv.created;\r\n\r\n        uint256 full_steps;\r\n        uint256 last_step;\r\n        uint256 _d;\r\n\r\n        if(_type == _td) _d = 365;\r\n        if(_type == _tw) _d = 54;\r\n        if(_type == _tm) _d = 12;\r\n        if(_type == _ty) _d = 1;\r\n\r\n        full_steps = _period/_d;\r\n        last_step = _period - (full_steps * _d);\r\n\r\n        for(uint256 i=0; i<full_steps; i++) { // not executed if zero\r\n            _balance = compaundIntrest(_d, _type, _balance, _created);\r\n            _created += 1 years;\r\n        }\r\n\r\n        if(last_step > 0) _balance = compaundIntrest(last_step, _type, _balance, _created);\r\n\r\n        return _balance;\r\n    }\r\n\r\n    /**\r\n        @dev Compaund Intrest realization, return balance + Intrest\r\n        @param _period - time interval dependent from invest time\r\n    */\r\n    function compaundIntrest(uint256 _period, bytes5 _type, uint256 _balance, uint256 _created) internal view returns (uint256) {\r\n        uint256 full_steps;\r\n        uint256 last_step;\r\n        uint256 _d = 100; // safe divider\r\n        uint256 _bonus = bonusSystem(_type, _created);\r\n\r\n        if (_period>_d) {\r\n            full_steps = _period/_d;\r\n            last_step = _period - (full_steps * _d);\r\n            for(uint256 i=0; i<full_steps; i++) {\r\n                _balance = loopFor(_d, _balance, _bonus);\r\n            }\r\n            if(last_step > 0) _balance = loopFor(last_step, _balance, _bonus);\r\n        } else\r\n        if (_period<=_d) {\r\n            _balance = loopFor(_period, _balance, _bonus);\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    /** @dev Bonus program */\r\n    function bonusSystem(bytes5 _t, uint256 _now) internal view returns (uint256) {\r\n        uint256 _b;\r\n        if (_t == _td) {\r\n            if (_now < _1sty) {\r\n                _b = 600; // 0.6 %/day  // 100.6 % by day => 887.69 % by year\r\n            } else\r\n            if (_now >= _1sty && _now < _2ndy) {\r\n                _b = 300; // 0.3 %/day\r\n            } else\r\n            if (_now >= _2ndy) {\r\n                _b = 30; // 0.03 %/day\r\n            }\r\n        }\r\n        if (_t == _tw) {\r\n            if (_now < _1sty) {\r\n                _b = 5370; // 0.75 %/day => 5.37 % by week => 1529.13 % by year\r\n            } else\r\n            if (_now >= _1sty && _now < _2ndy) {\r\n                _b = 2650; // 0.375 %/day\r\n            } else\r\n            if (_now >= _2ndy) {\r\n                _b = 270; // 0.038 %/day\r\n            }\r\n        }\r\n        if (_t == _tm) {\r\n            if (_now < _1sty) {\r\n                _b = 30000; // 0.85 %/day // 130 % by month => 2196.36 % by year\r\n            } else\r\n            if (_now >= _1sty && _now < _2ndy) {\r\n\r\n                _b = 14050; // 0.425 %/day\r\n            } else\r\n            if (_now >= _2ndy) {\r\n                _b = 1340; // 0.043 %/day\r\n            }\r\n        }\r\n        if (_t == _ty) {\r\n            if (_now < _1sty) {\r\n                _b = 3678000; // 1 %/day // 3678.34 * 1000 = 3678340 = 3678% by year\r\n            } else\r\n            if (_now >= _1sty && _now < _2ndy) {\r\n                _b = 517470; // 0.5 %/day\r\n            } else\r\n            if (_now >= _2ndy) {\r\n                _b = 20020; // 0.05 %/day\r\n            }\r\n        }\r\n        return _b;\r\n    }\r\n\r\n    /** @dev make invest */\r\n    function makeInvest(uint256 _value, bytes5 _interval) internal isMintable {\r\n        require(min_invest <= _value && _value <= max_invest); // min max condition\r\n        assert(balances[msg.sender] >= _value && balances[this] + _value > balances[this]);\r\n        balances[msg.sender] -= _value;\r\n        balances[this] += _value;\r\n        invest storage inv = investInfo[msg.sender][_interval];\r\n        if (inv.exists == false) { // if invest no exists\r\n            inv.balance = _value;\r\n            inv.created = now;\r\n            inv.closed = 0;\r\n            emit Transfer(msg.sender, this, _value);\r\n        } else\r\n        if (inv.exists == true) {\r\n            uint256 rew = rewardController(msg.sender, _interval);\r\n            inv.balance = _value + rew;\r\n            inv.closed = 0;\r\n            emit Transfer(0x0, this, rew); // fix rise total supply\r\n        }\r\n        inv.exists = true;\r\n        emit Invested(msg.sender, _value);\r\n        if(totalSupply > maxSupply) stopMint(); // stop invest\r\n    }\r\n\r\n    function makeDailyInvest(uint256 _value) public {\r\n        makeInvest(_value * 10 ** uint256(decimals), _td);\r\n    }\r\n\r\n    function makeWeeklyInvest(uint256 _value) public {\r\n        makeInvest(_value * 10 ** uint256(decimals), _tw);\r\n    }\r\n\r\n    function makeMonthlyInvest(uint256 _value) public {\r\n        makeInvest(_value * 10 ** uint256(decimals), _tm);\r\n    }\r\n\r\n    function makeAnnualInvest(uint256 _value) public {\r\n        makeInvest(_value * 10 ** uint256(decimals), _ty);\r\n    }\r\n\r\n    /** @dev close invest */\r\n    function closeInvest(bytes5 _interval) internal {\r\n        uint256 _intrest;\r\n        address _to = msg.sender;\r\n        uint256 _period = countPeriod(_to, _interval);\r\n        invest storage inv = investInfo[_to][_interval];\r\n        uint256 _value = inv.balance;\r\n        if (_period == 0) {\r\n            balances[this] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(this, _to, _value); // tx of begining balance\r\n            emit InvestClosed(_to, _value);\r\n        } else\r\n        if (_period > 0) {\r\n            // Destruction init\r\n            balances[this] -= _value;\r\n            totalSupply -= _value;\r\n            emit Transfer(this, 0x0, _value);\r\n            emit Destruction(_value);\r\n            // Issue init\r\n            _intrest = rewardController(_to, _interval);\r\n            if(manager[msg.sender]) {\r\n                _intrest = mulsm(divsm(_intrest, 100), 105); // addition 5% bonus for manager\r\n            }\r\n            issue(_to, _intrest); // tx of %\r\n            emit InvestClosed(_to, _intrest);\r\n        }\r\n        inv.exists = false; // invest inv clear\r\n        inv.balance = 0;\r\n        inv.closed = now;\r\n    }\r\n\r\n    function closeDailyInvest() public {\r\n        closeInvest(_td);\r\n    }\r\n\r\n    function closeWeeklyInvest() public {\r\n        closeInvest(_tw);\r\n    }\r\n\r\n    function closeMonthlyInvest() public {\r\n        closeInvest(_tm);\r\n    }\r\n\r\n    function closeAnnualInvest() public {\r\n        closeInvest(_ty);\r\n    }\r\n\r\n    /** @dev safe closing invest, checking for complete by date. */\r\n    function isFullInvest(address _ms, bytes5 _t) internal returns (uint256) {\r\n        uint256 res = countPeriod(_ms, _t);\r\n        emit Counted(msg.sender, res);\r\n        return res;\r\n    }\r\n\r\n    function countDays() public returns (uint256) {\r\n        return isFullInvest(msg.sender, _td);\r\n    }\r\n\r\n    function countWeeks() public returns (uint256) {\r\n        return isFullInvest(msg.sender, _tw);\r\n    }\r\n\r\n    function countMonths() public returns (uint256) {\r\n        return isFullInvest(msg.sender, _tm);\r\n    }\r\n\r\n    function countYears() public returns (uint256) {\r\n        return isFullInvest(msg.sender, _ty);\r\n    }\r\n}\r\n\r\ncontract EthereumRisen is InvestBox {\r\n\r\n    // devs addresess, pay for code\r\n    address public devWallet = address(0x00FBB38c017843DFa86a97c31fECaCFF0a092F6F);\r\n    uint256 constant public devReward = 100000 * 1e18; // 100K\r\n\r\n    // fondation for pay by promotion this project\r\n    address public bountyWallet = address(0x00Ed07D0170B1c5F3EeDe1fC7261719e04b15ecD);\r\n    uint256 constant public bountyReward = 50000 * 1e18; // 50K\r\n\r\n    // will be send for first 10k rischest wallets, if it is enough to pay the commission\r\n    address public airdropWallet = address(0x000DdB5A903d15b2F7f7300f672d2EB9bF882143);\r\n    uint256 constant public airdropReward = 99900 * 1e18; // 99.9K\r\n\r\n    bool internal _airdrop_status = false;\r\n    uint256 internal _paySize;\r\n\r\n    /** init airdrop program if cap will reach сost price */\r\n    function startAirdrop() public onlyOwner {\r\n        if(address(this).balance < 5 ether && _airdrop_status == true) revert();\r\n        issue(airdropWallet, airdropReward);\r\n        _paySize = 999 * 1e16; // 9.99 tokens\r\n        _airdrop_status = true;\r\n    }\r\n\r\n    /**\r\n        @dev notify owners about their balances was in promo action.\r\n        @param _holders addresses of the owners to be notified [\"address_1\", \"address_2\", ..]\r\n     */\r\n    function airdropper(address [] _holders, uint256 _pay_size) public onlyManager {\r\n        if(_pay_size == 0) _pay_size = _paySize; // if empty set default\r\n        if(_pay_size < 1 * 1e18) revert(); // limit no less then 1 token\r\n        uint256 count = _holders.length;\r\n        require(count <= 200);\r\n        assert(_pay_size * count <= balanceOf(msg.sender));\r\n        for (uint256 i = 0; i < count; i++) {\r\n            transfer(_holders [i], _pay_size);\r\n        }\r\n    }\r\n\r\n    function EthereumRisen() public {\r\n\r\n        name = \"Ethereum Risen\";\r\n        symbol = \"ETR\";\r\n        decimals = 18;\r\n        totalSupply = 0;\r\n        _creation = now;\r\n        _1sty = now + 365 * 1 days;\r\n        _2ndy = now + 2 * 365 * 1 days;\r\n\r\n        PaymentManager.setPrice(10000);\r\n        Managed.setManager(bountyWallet);\r\n        InvestBox.IntervalBytecodes = intervalBytecodes(\r\n            \"0x6461790000\",\r\n            \"0x7765656b00\",\r\n            \"0x6d6f6e7468\",\r\n            \"0x7965617200\"\r\n        );\r\n        InvestBox.setMinMaxInvestValue(1000,100000000);\r\n        issue(bountyWallet, bountyReward);\r\n        issue(devWallet, devReward);\r\n    }\r\n\r\n    function() public payable isSuspended {\r\n        require(msg.value >= (1 ether / 100));\r\n        if(msg.value >= 5 ether) superManager(msg.sender); // you can make airdrop from this contract\r\n        rateSystem(msg.sender, msg.value);\r\n        receivedWais = addsm(receivedWais, msg.value); // count ether which was spent to contract\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"countMonths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"makeWeeklyInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"makeMonthlyInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"string\"}],\"name\":\"stringToBytes5\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes5\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"watchPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holders\",\"type\":\"address[]\"},{\"name\":\"_pay_size\",\"type\":\"uint256\"}],\"name\":\"airdropper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes5\"}],\"name\":\"investInfo\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"created\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receivedWais\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"makeDailyInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"countYears\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potentialOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeMonthlyInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_min\",\"type\":\"uint256\"},{\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setMinMaxInvestValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airdropWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"delManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeWeeklyInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeDailyInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"makeAnnualInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"countDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IntervalBytecodes\",\"outputs\":[{\"name\":\"day\",\"type\":\"string\"},{\"name\":\"week\",\"type\":\"string\"},{\"name\":\"month\",\"type\":\"string\"},{\"name\":\"year\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"countWeeks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeAnnualInvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BonusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"InvestClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_intervals\",\"type\":\"uint256\"}],\"name\":\"Counted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"NewManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"current\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"potential\",\"type\":\"address\"}],\"name\":\"NewPotentialOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EthereumRisen","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a9bb3a4bca625068b1ab4a117baa05a028be717191c88bbae4964715118b45ad"}]}