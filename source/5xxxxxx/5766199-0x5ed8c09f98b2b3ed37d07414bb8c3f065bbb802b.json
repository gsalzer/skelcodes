{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n/*\r\n    Contract Features interface\r\n*/\r\ncontract IContractFeatures {\r\n    function isSupported(address _contract, uint256 _features) public view returns (bool);\r\n    function enableFeatures(uint256 _features, bool _enable) public;\r\n}\r\n\r\n/*\r\n    Whitelist interface\r\n*/\r\ncontract IWhitelist {\r\n    function isWhitelisted(address _address) public view returns (bool);\r\n}\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ncontract IBancorFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256);\r\n    function calculateCrossConnectorReturn(uint256 _fromConnectorBalance, uint32 _fromConnectorWeight, uint256 _toConnectorBalance, uint32 _toConnectorWeight, uint256 _amount) public view returns (uint256);\r\n}\r\n\r\n/*\r\n    Bancor Converter interface\r\n*/\r\ncontract IBancorConverter {\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    function conversionWhitelist() public view returns (IWhitelist) {}\r\n    // deprecated, backward compatibility\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n}\r\n\r\n/*\r\n    Bancor Converter Factory interface\r\n*/\r\ncontract IBancorConverterFactory {\r\n    function createConverter(\r\n        ISmartToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee,\r\n        IERC20Token _connectorToken,\r\n        uint32 _connectorWeight\r\n    )\r\n    public returns (address);\r\n}\r\n\r\n/*\r\n    Bancor Network interface\r\n*/\r\ncontract IBancorNetwork {\r\n    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\r\n    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256);\r\n    function convertForPrioritized2(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _block,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s)\r\n        public payable returns (uint256);\r\n\r\n    // deprecated, backward compatibility\r\n    function convertForPrioritized(\r\n        IERC20Token[] _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        uint256 _block,\r\n        uint256 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s)\r\n        public payable returns (uint256);\r\n}\r\n\r\n/*\r\n    Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    /**\r\n        constructor\r\n    */\r\n    function Utils() public {\r\n    }\r\n\r\n    // verifies that an amount is greater than zero\r\n    modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    // Overflow protected math functions\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still needs to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract management\r\n    Note that a managed contract must also have an owner\r\n*/\r\ncontract Managed is Owned {\r\n    address public manager;\r\n    address public newManager;\r\n\r\n    event ManagerUpdate(address indexed _prevManager, address indexed _newManager);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Managed() public {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    // allows execution by the manager only\r\n    modifier managerOnly {\r\n        assert(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    // allows execution by either the owner or the manager only\r\n    modifier ownerOrManagerOnly {\r\n        require(msg.sender == owner || msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract management\r\n        the new manager still needs to accept the transfer\r\n        can only be called by the contract manager\r\n\r\n        @param _newManager    new contract manager\r\n    */\r\n    function transferManagement(address _newManager) public ownerOrManagerOnly {\r\n        require(_newManager != manager);\r\n        newManager = _newManager;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new manager to accept a management transfer\r\n    */\r\n    function acceptManagement() public {\r\n        require(msg.sender == newManager);\r\n        emit ManagerUpdate(manager, newManager);\r\n        manager = newManager;\r\n        newManager = address(0);\r\n    }\r\n}\r\n\r\n/**\r\n    Id definitions for bancor contracts\r\n\r\n    Can be used in conjunction with the contract registry to get contract addresses\r\n*/\r\ncontract ContractIds {\r\n    // generic\r\n    bytes32 public constant CONTRACT_FEATURES = \"ContractFeatures\";\r\n\r\n    // bancor logic\r\n    bytes32 public constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 public constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 public constant BANCOR_GAS_PRICE_LIMIT = \"BancorGasPriceLimit\";\r\n\r\n    bytes32 public constant BANCOR_CONVERTER_FACTORY = \"BancorConverterFactory\";\r\n    bytes32 public constant BANCOR_CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n\r\n    // tokens\r\n    bytes32 public constant BNT_TOKEN = \"BNTToken\";\r\n}\r\n\r\n/**\r\n    Id definitions for bancor contract features\r\n\r\n    Can be used to query the ContractFeatures contract to check whether a certain feature is supported by a contract\r\n*/\r\ncontract FeatureIds {\r\n    // converter features\r\n    uint256 public constant CONVERTER_CONVERSION_WHITELIST = 1 << 0;\r\n}\r\n\r\n/*\r\n    We consider every contract to be a 'token holder' since it's currently not possible\r\n    for a contract to deny receiving tokens.\r\n\r\n    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n    the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n*/\r\ncontract TokenHolder is ITokenHolder, Owned, Utils {\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function TokenHolder() public {\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the contract and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }\r\n}\r\n\r\n/*\r\n    The smart token controller is an upgradable part of the smart token that allows\r\n    more functionality as well as fixes for bugs/exploits.\r\n    Once it accepts ownership of the token, it becomes the token's sole controller\r\n    that can execute any of its functions.\r\n\r\n    To upgrade the controller, ownership must be transferred to a new controller, along with\r\n    any relevant data.\r\n\r\n    The smart token must be set on construction and cannot be changed afterwards.\r\n    Wrappers are provided (as opposed to a single 'execute' function) for each of the token's functions, for easier access.\r\n\r\n    Note that the controller can transfer token ownership to a new controller that\r\n    doesn't allow executing any function on the token, for a trustless solution.\r\n    Doing that will also remove the owner's ability to upgrade the controller.\r\n*/\r\ncontract SmartTokenController is TokenHolder {\r\n    ISmartToken public token;   // smart token\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function SmartTokenController(ISmartToken _token)\r\n        public\r\n        validAddress(_token)\r\n    {\r\n        token = _token;\r\n    }\r\n\r\n    // ensures that the controller is the token's owner\r\n    modifier active() {\r\n        assert(token.owner() == address(this));\r\n        _;\r\n    }\r\n\r\n    // ensures that the controller is not the token's owner\r\n    modifier inactive() {\r\n        assert(token.owner() != address(this));\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the token ownership\r\n        the new owner still need to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new token owner\r\n    */\r\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\r\n        token.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept a token ownership transfer\r\n        can only be called by the contract owner\r\n    */\r\n    function acceptTokenOwnership() public ownerOnly {\r\n        token.acceptOwnership();\r\n    }\r\n\r\n    /**\r\n        @dev disables/enables token transfers\r\n        can only be called by the contract owner\r\n\r\n        @param _disable    true to disable transfers, false to enable them\r\n    */\r\n    function disableTokenTransfers(bool _disable) public ownerOnly {\r\n        token.disableTransfers(_disable);\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the controller and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawFromToken(\r\n        IERC20Token _token, \r\n        address _to, \r\n        uint256 _amount\r\n    ) \r\n        public\r\n        ownerOnly\r\n    {\r\n        ITokenHolder(token).withdrawTokens(_token, _to, _amount);\r\n    }\r\n}\r\n\r\n/*\r\n    Bancor Converter v0.9\r\n\r\n    The Bancor version of the token converter, allows conversion between a smart token and other ERC20 tokens and between different ERC20 tokens and themselves.\r\n\r\n    ERC20 connector balance can be virtual, meaning that the calculations are based on the virtual balance instead of relying on\r\n    the actual connector balance. This is a security mechanism that prevents the need to keep a very large (and valuable) balance in a single contract.\r\n\r\n    The converter is upgradable (just like any SmartTokenController).\r\n\r\n    WARNING: It is NOT RECOMMENDED to use the converter with Smart Tokens that have less than 8 decimal digits\r\n             or with very small numbers because of precision loss\r\n\r\n    Open issues:\r\n    - Front-running attacks are currently mitigated by the following mechanisms:\r\n        - minimum return argument for each conversion provides a way to define a minimum/maximum price for the transaction\r\n        - gas price limit prevents users from having control over the order of execution\r\n        - gas price limit check can be skipped if the transaction comes from a trusted, whitelisted signer\r\n      Other potential solutions might include a commit/reveal based schemes\r\n    - Possibly add getters for the connector fields so that the client won't need to rely on the order in the struct\r\n*/\r\ncontract BancorConverter is IBancorConverter, SmartTokenController, Managed, ContractIds, FeatureIds {\r\n    uint32 private constant MAX_WEIGHT = 1000000;\r\n    uint64 private constant MAX_CONVERSION_FEE = 1000000;\r\n\r\n    struct Connector {\r\n        uint256 virtualBalance;         // connector virtual balance\r\n        uint32 weight;                  // connector weight, represented in ppm, 1-1000000\r\n        bool isVirtualBalanceEnabled;   // true if virtual balance is enabled, false if not\r\n        bool isPurchaseEnabled;         // is purchase of the smart token enabled with the connector, can be set by the owner\r\n        bool isSet;                     // used to tell if the mapping element is defined\r\n    }\r\n\r\n    string public version = '0.9';\r\n    string public converterType = 'bancor';\r\n\r\n    IContractRegistry public registry;                  // contract registry contract\r\n    IWhitelist public conversionWhitelist;              // whitelist contract with list of addresses that are allowed to use the converter\r\n    IERC20Token[] public connectorTokens;               // ERC20 standard token addresses\r\n    IERC20Token[] public quickBuyPath;                  // conversion path that's used in order to buy the token with ETH\r\n    mapping (address => Connector) public connectors;   // connector token addresses -> connector data\r\n    uint32 private totalConnectorWeight = 0;            // used to efficiently prevent increasing the total connector weight above 100%\r\n    uint32 public maxConversionFee = 0;                 // maximum conversion fee for the lifetime of the contract,\r\n                                                        // represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\r\n    uint32 public conversionFee = 0;                    // current conversion fee, represented in ppm, 0...maxConversionFee\r\n    bool public conversionsEnabled = true;              // true if token conversions is enabled, false if not\r\n    IERC20Token[] private convertPath;\r\n\r\n    // triggered when a conversion between two tokens occurs\r\n    event Conversion(\r\n        address indexed _fromToken,\r\n        address indexed _toToken,\r\n        address indexed _trader,\r\n        uint256 _amount,\r\n        uint256 _return,\r\n        int256 _conversionFee\r\n    );\r\n    // triggered after a conversion with new price data\r\n    event PriceDataUpdate(\r\n        address indexed _connectorToken,\r\n        uint256 _tokenSupply,\r\n        uint256 _connectorBalance,\r\n        uint32 _connectorWeight\r\n    );\r\n    // triggered when the conversion fee is updated\r\n    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\r\n\r\n    /**\r\n        @dev constructor\r\n\r\n        @param  _token              smart token governed by the converter\r\n        @param  _registry           address of a contract registry contract\r\n        @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n        @param  _connectorToken     optional, initial connector, allows defining the first connector at deployment time\r\n        @param  _connectorWeight    optional, weight for the initial connector\r\n    */\r\n    function BancorConverter(\r\n        ISmartToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee,\r\n        IERC20Token _connectorToken,\r\n        uint32 _connectorWeight\r\n    )\r\n        public\r\n        SmartTokenController(_token)\r\n        validAddress(_registry)\r\n        validMaxConversionFee(_maxConversionFee)\r\n    {\r\n        registry = _registry;\r\n        IContractFeatures features = IContractFeatures(registry.getAddress(ContractIds.CONTRACT_FEATURES));\r\n\r\n        // initialize supported features\r\n        if (features != address(0))\r\n            features.enableFeatures(FeatureIds.CONVERTER_CONVERSION_WHITELIST, true);\r\n\r\n        maxConversionFee = _maxConversionFee;\r\n\r\n        if (_connectorToken != address(0))\r\n            addConnector(_connectorToken, _connectorWeight, false);\r\n    }\r\n\r\n    // validates a connector token address - verifies that the address belongs to one of the connector tokens\r\n    modifier validConnector(IERC20Token _address) {\r\n        require(connectors[_address].isSet);\r\n        _;\r\n    }\r\n\r\n    // validates a token address - verifies that the address belongs to one of the convertible tokens\r\n    modifier validToken(IERC20Token _address) {\r\n        require(_address == token || connectors[_address].isSet);\r\n        _;\r\n    }\r\n\r\n    // validates maximum conversion fee\r\n    modifier validMaxConversionFee(uint32 _conversionFee) {\r\n        require(_conversionFee >= 0 && _conversionFee <= MAX_CONVERSION_FEE);\r\n        _;\r\n    }\r\n\r\n    // validates conversion fee\r\n    modifier validConversionFee(uint32 _conversionFee) {\r\n        require(_conversionFee >= 0 && _conversionFee <= maxConversionFee);\r\n        _;\r\n    }\r\n\r\n    // validates connector weight range\r\n    modifier validConnectorWeight(uint32 _weight) {\r\n        require(_weight > 0 && _weight <= MAX_WEIGHT);\r\n        _;\r\n    }\r\n\r\n    // validates a conversion path - verifies that the number of elements is odd and that maximum number of 'hops' is 10\r\n    modifier validConversionPath(IERC20Token[] _path) {\r\n        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\r\n        _;\r\n    }\r\n\r\n    // allows execution only when conversions aren't disabled\r\n    modifier conversionsAllowed {\r\n        assert(conversionsEnabled);\r\n        _;\r\n    }\r\n\r\n    // allows execution by the BancorNetwork contract only\r\n    modifier bancorNetworkOnly {\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(registry.getAddress(ContractIds.BANCOR_NETWORK));\r\n        require(msg.sender == address(bancorNetwork));\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev returns the number of connector tokens defined\r\n\r\n        @return number of connector tokens\r\n    */\r\n    function connectorTokenCount() public view returns (uint16) {\r\n        return uint16(connectorTokens.length);\r\n    }\r\n\r\n    /*\r\n        @dev allows the owner to update the registry contract address\r\n\r\n        @param _registry    address of a bancor converter registry contract\r\n    */\r\n    function setRegistry(IContractRegistry _registry)\r\n        public\r\n        ownerOnly\r\n        validAddress(_registry)\r\n        notThis(_registry)\r\n    {\r\n        registry = _registry;\r\n    }\r\n\r\n    /*\r\n        @dev allows the owner to update & enable the conversion whitelist contract address\r\n        when set, only addresses that are whitelisted are actually allowed to use the converter\r\n        note that the whitelist check is actually done by the BancorNetwork contract\r\n\r\n        @param _whitelist    address of a whitelist contract\r\n    */\r\n    function setConversionWhitelist(IWhitelist _whitelist)\r\n        public\r\n        ownerOnly\r\n        notThis(_whitelist)\r\n    {\r\n        conversionWhitelist = _whitelist;\r\n    }\r\n\r\n    /*\r\n        @dev allows the manager to update the quick buy path\r\n\r\n        @param _path    new quick buy path, see conversion path format in the bancorNetwork contract\r\n    */\r\n    function setQuickBuyPath(IERC20Token[] _path)\r\n        public\r\n        ownerOnly\r\n        validConversionPath(_path)\r\n    {\r\n        quickBuyPath = _path;\r\n    }\r\n\r\n    /*\r\n        @dev allows the manager to clear the quick buy path\r\n    */\r\n    function clearQuickBuyPath() public ownerOnly {\r\n        quickBuyPath.length = 0;\r\n    }\r\n\r\n    /**\r\n        @dev returns the length of the quick buy path array\r\n\r\n        @return quick buy path length\r\n    */\r\n    function getQuickBuyPathLength() public view returns (uint256) {\r\n        return quickBuyPath.length;\r\n    }\r\n\r\n    /**\r\n        @dev disables the entire conversion functionality\r\n        this is a safety mechanism in case of a emergency\r\n        can only be called by the manager\r\n\r\n        @param _disable true to disable conversions, false to re-enable them\r\n    */\r\n    function disableConversions(bool _disable) public ownerOrManagerOnly {\r\n        conversionsEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n        @dev updates the current conversion fee\r\n        can only be called by the manager\r\n\r\n        @param _conversionFee new conversion fee, represented in ppm\r\n    */\r\n    function setConversionFee(uint32 _conversionFee)\r\n        public\r\n        ownerOrManagerOnly\r\n        validConversionFee(_conversionFee)\r\n    {\r\n        emit ConversionFeeUpdate(conversionFee, _conversionFee);\r\n        conversionFee = _conversionFee;\r\n    }\r\n\r\n    /*\r\n        @dev given a return amount, returns the amount minus the conversion fee\r\n\r\n        @param _amount      return amount\r\n        @param _magnitude   1 for standard conversion, 2 for cross connector conversion\r\n\r\n        @return return amount minus conversion fee\r\n    */\r\n    function getFinalAmount(uint256 _amount, uint8 _magnitude) public view returns (uint256) {\r\n        return safeMul(_amount, (MAX_CONVERSION_FEE - conversionFee) ** _magnitude) / MAX_CONVERSION_FEE ** _magnitude;\r\n    }\r\n\r\n    /**\r\n        @dev defines a new connector for the token\r\n        can only be called by the owner while the converter is inactive\r\n\r\n        @param _token                  address of the connector token\r\n        @param _weight                 constant connector weight, represented in ppm, 1-1000000\r\n        @param _enableVirtualBalance   true to enable virtual balance for the connector, false to disable it\r\n    */\r\n    function addConnector(IERC20Token _token, uint32 _weight, bool _enableVirtualBalance)\r\n        public\r\n        ownerOnly\r\n        inactive\r\n        validAddress(_token)\r\n        notThis(_token)\r\n        validConnectorWeight(_weight)\r\n    {\r\n        require(_token != token && !connectors[_token].isSet && totalConnectorWeight + _weight <= MAX_WEIGHT); // validate input\r\n\r\n        connectors[_token].virtualBalance = 0;\r\n        connectors[_token].weight = _weight;\r\n        connectors[_token].isVirtualBalanceEnabled = _enableVirtualBalance;\r\n        connectors[_token].isPurchaseEnabled = true;\r\n        connectors[_token].isSet = true;\r\n        connectorTokens.push(_token);\r\n        totalConnectorWeight += _weight;\r\n    }\r\n\r\n    /**\r\n        @dev updates one of the token connectors\r\n        can only be called by the owner\r\n\r\n        @param _connectorToken         address of the connector token\r\n        @param _weight                 constant connector weight, represented in ppm, 1-1000000\r\n        @param _enableVirtualBalance   true to enable virtual balance for the connector, false to disable it\r\n        @param _virtualBalance         new connector's virtual balance\r\n    */\r\n    function updateConnector(IERC20Token _connectorToken, uint32 _weight, bool _enableVirtualBalance, uint256 _virtualBalance)\r\n        public\r\n        ownerOnly\r\n        validConnector(_connectorToken)\r\n        validConnectorWeight(_weight)\r\n    {\r\n        Connector storage connector = connectors[_connectorToken];\r\n        require(totalConnectorWeight - connector.weight + _weight <= MAX_WEIGHT); // validate input\r\n\r\n        totalConnectorWeight = totalConnectorWeight - connector.weight + _weight;\r\n        connector.weight = _weight;\r\n        connector.isVirtualBalanceEnabled = _enableVirtualBalance;\r\n        connector.virtualBalance = _virtualBalance;\r\n    }\r\n\r\n    /**\r\n        @dev disables purchasing with the given connector token in case the connector token got compromised\r\n        can only be called by the owner\r\n        note that selling is still enabled regardless of this flag and it cannot be disabled by the owner\r\n\r\n        @param _connectorToken  connector token contract address\r\n        @param _disable         true to disable the token, false to re-enable it\r\n    */\r\n    function disableConnectorPurchases(IERC20Token _connectorToken, bool _disable)\r\n        public\r\n        ownerOnly\r\n        validConnector(_connectorToken)\r\n    {\r\n        connectors[_connectorToken].isPurchaseEnabled = !_disable;\r\n    }\r\n\r\n    /**\r\n        @dev returns the connector's virtual balance if one is defined, otherwise returns the actual balance\r\n\r\n        @param _connectorToken  connector token contract address\r\n\r\n        @return connector balance\r\n    */\r\n    function getConnectorBalance(IERC20Token _connectorToken)\r\n        public\r\n        view\r\n        validConnector(_connectorToken)\r\n        returns (uint256)\r\n    {\r\n        Connector storage connector = connectors[_connectorToken];\r\n        return connector.isVirtualBalanceEnabled ? connector.virtualBalance : _connectorToken.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n        @dev returns the expected return for converting a specific amount of _fromToken to _toToken\r\n\r\n        @param _fromToken  ERC20 token to convert from\r\n        @param _toToken    ERC20 token to convert to\r\n        @param _amount     amount to convert, in fromToken\r\n\r\n        @return expected conversion return amount\r\n    */\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256) {\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // conversion between the token and one of its connectors\r\n        if (_toToken == token)\r\n            return getPurchaseReturn(_fromToken, _amount);\r\n        else if (_fromToken == token)\r\n            return getSaleReturn(_toToken, _amount);\r\n\r\n        // conversion between 2 connectors\r\n        return getCrossConnectorReturn(_fromToken, _toToken, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev returns the expected return for buying the token for a connector token\r\n\r\n        @param _connectorToken  connector token contract address\r\n        @param _depositAmount   amount to deposit (in the connector token)\r\n\r\n        @return expected purchase return amount\r\n    */\r\n    function getPurchaseReturn(IERC20Token _connectorToken, uint256 _depositAmount)\r\n        public\r\n        view\r\n        active\r\n        validConnector(_connectorToken)\r\n        returns (uint256)\r\n    {\r\n        Connector storage connector = connectors[_connectorToken];\r\n        require(connector.isPurchaseEnabled); // validate input\r\n\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 connectorBalance = getConnectorBalance(_connectorToken);\r\n        IBancorFormula formula = IBancorFormula(registry.getAddress(ContractIds.BANCOR_FORMULA));\r\n        uint256 amount = formula.calculatePurchaseReturn(tokenSupply, connectorBalance, connector.weight, _depositAmount);\r\n\r\n        // return the amount minus the conversion fee\r\n        return getFinalAmount(amount, 1);\r\n    }\r\n\r\n    /**\r\n        @dev returns the expected return for selling the token for one of its connector tokens\r\n\r\n        @param _connectorToken  connector token contract address\r\n        @param _sellAmount      amount to sell (in the smart token)\r\n\r\n        @return expected sale return amount\r\n    */\r\n    function getSaleReturn(IERC20Token _connectorToken, uint256 _sellAmount)\r\n        public\r\n        view\r\n        active\r\n        validConnector(_connectorToken)\r\n        returns (uint256)\r\n    {\r\n        Connector storage connector = connectors[_connectorToken];\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 connectorBalance = getConnectorBalance(_connectorToken);\r\n        IBancorFormula formula = IBancorFormula(registry.getAddress(ContractIds.BANCOR_FORMULA));\r\n        uint256 amount = formula.calculateSaleReturn(tokenSupply, connectorBalance, connector.weight, _sellAmount);\r\n\r\n        // return the amount minus the conversion fee\r\n        return getFinalAmount(amount, 1);\r\n    }\r\n\r\n    /**\r\n        @dev returns the expected return for selling one of the connector tokens for another connector token\r\n\r\n        @param _fromConnectorToken  contract address of the connector token to convert from\r\n        @param _toConnectorToken    contract address of the connector token to convert to\r\n        @param _sellAmount          amount to sell (in the from connector token)\r\n\r\n        @return expected sale return amount (in the to connector token)\r\n    */\r\n    function getCrossConnectorReturn(IERC20Token _fromConnectorToken, IERC20Token _toConnectorToken, uint256 _sellAmount)\r\n        public\r\n        view\r\n        active\r\n        validConnector(_fromConnectorToken)\r\n        validConnector(_toConnectorToken)\r\n        returns (uint256)\r\n    {\r\n        Connector storage fromConnector = connectors[_fromConnectorToken];\r\n        Connector storage toConnector = connectors[_toConnectorToken];\r\n        require(toConnector.isPurchaseEnabled); // validate input\r\n\r\n        uint256 fromConnectorBalance = getConnectorBalance(_fromConnectorToken);\r\n        uint256 toConnectorBalance = getConnectorBalance(_toConnectorToken);\r\n\r\n        IBancorFormula formula = IBancorFormula(registry.getAddress(ContractIds.BANCOR_FORMULA));\r\n        uint256 amount = formula.calculateCrossConnectorReturn(fromConnectorBalance, fromConnector.weight, toConnectorBalance, toConnector.weight, _sellAmount);\r\n\r\n        // return the amount minus the conversion fee\r\n        // the fee is higher (magnitude = 2) since cross connector conversion equals 2 conversions (from / to the smart token)\r\n        return getFinalAmount(amount, 2);\r\n    }\r\n\r\n    /**\r\n        @dev converts a specific amount of _fromToken to _toToken\r\n\r\n        @param _fromToken  ERC20 token to convert from\r\n        @param _toToken    ERC20 token to convert to\r\n        @param _amount     amount to convert, in fromToken\r\n        @param _minReturn  if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return conversion return amount\r\n    */\r\n    function convertInternal(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        bancorNetworkOnly\r\n        conversionsAllowed\r\n        greaterThanZero(_minReturn)\r\n        returns (uint256)\r\n    {\r\n        require(_fromToken != _toToken); // validate input\r\n\r\n        // conversion between the token and one of its connectors\r\n        if (_toToken == token)\r\n            return buy(_fromToken, _amount, _minReturn);\r\n        else if (_fromToken == token)\r\n            return sell(_toToken, _amount, _minReturn);\r\n\r\n        // conversion between 2 connectors\r\n        uint256 amount = getCrossConnectorReturn(_fromToken, _toToken, _amount);\r\n        // ensure the trade gives something in return and meets the minimum requested amount\r\n        require(amount != 0 && amount >= _minReturn);\r\n\r\n        // update the source token virtual balance if relevant\r\n        Connector storage fromConnector = connectors[_fromToken];\r\n        if (fromConnector.isVirtualBalanceEnabled)\r\n            fromConnector.virtualBalance = safeAdd(fromConnector.virtualBalance, _amount);\r\n\r\n        // update the target token virtual balance if relevant\r\n        Connector storage toConnector = connectors[_toToken];\r\n        if (toConnector.isVirtualBalanceEnabled)\r\n            toConnector.virtualBalance = safeSub(toConnector.virtualBalance, amount);\r\n\r\n        // ensure that the trade won't deplete the connector balance\r\n        uint256 toConnectorBalance = getConnectorBalance(_toToken);\r\n        assert(amount < toConnectorBalance);\r\n\r\n        // transfer funds from the caller in the from connector token\r\n        assert(_fromToken.transferFrom(msg.sender, this, _amount));\r\n        // transfer funds to the caller in the to connector token\r\n        // the transfer might fail if the actual connector balance is smaller than the virtual balance\r\n        assert(_toToken.transfer(msg.sender, amount));\r\n\r\n        // calculate conversion fee and dispatch the conversion event\r\n        // the fee is higher (magnitude = 2) since cross connector conversion equals 2 conversions (from / to the smart token)\r\n        uint256 feeAmount = safeSub(amount, getFinalAmount(amount, 2));\r\n        dispatchConversionEvent(_fromToken, _toToken, _amount, amount, feeAmount);\r\n\r\n        // dispatch price data updates for the smart token / both connectors\r\n        emit PriceDataUpdate(_fromToken, token.totalSupply(), getConnectorBalance(_fromToken), fromConnector.weight);\r\n        emit PriceDataUpdate(_toToken, token.totalSupply(), getConnectorBalance(_toToken), toConnector.weight);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n        @dev converts a specific amount of _fromToken to _toToken\r\n\r\n        @param _fromToken  ERC20 token to convert from\r\n        @param _toToken    ERC20 token to convert to\r\n        @param _amount     amount to convert, in fromToken\r\n        @param _minReturn  if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return conversion return amount\r\n    */\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256) {\r\n        convertPath = [_fromToken, token, _toToken];\r\n        return quickConvert(convertPath, _amount, _minReturn);\r\n    }\r\n\r\n    /**\r\n        @dev buys the token by depositing one of its connector tokens\r\n\r\n        @param _connectorToken  connector token contract address\r\n        @param _depositAmount   amount to deposit (in the connector token)\r\n        @param _minReturn       if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return buy return amount\r\n    */\r\n    function buy(IERC20Token _connectorToken, uint256 _depositAmount, uint256 _minReturn) internal returns (uint256) {\r\n        uint256 amount = getPurchaseReturn(_connectorToken, _depositAmount);\r\n        // ensure the trade gives something in return and meets the minimum requested amount\r\n        require(amount != 0 && amount >= _minReturn);\r\n\r\n        // update virtual balance if relevant\r\n        Connector storage connector = connectors[_connectorToken];\r\n        if (connector.isVirtualBalanceEnabled)\r\n            connector.virtualBalance = safeAdd(connector.virtualBalance, _depositAmount);\r\n\r\n        // transfer funds from the caller in the connector token\r\n        assert(_connectorToken.transferFrom(msg.sender, this, _depositAmount));\r\n        // issue new funds to the caller in the smart token\r\n        token.issue(msg.sender, amount);\r\n\r\n        // calculate conversion fee and dispatch the conversion event\r\n        uint256 feeAmount = safeSub(amount, getFinalAmount(amount, 1));\r\n        dispatchConversionEvent(_connectorToken, token, _depositAmount, amount, feeAmount);\r\n\r\n        // dispatch price data update for the smart token/connector\r\n        emit PriceDataUpdate(_connectorToken, token.totalSupply(), getConnectorBalance(_connectorToken), connector.weight);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n        @dev sells the token by withdrawing from one of its connector tokens\r\n\r\n        @param _connectorToken  connector token contract address\r\n        @param _sellAmount      amount to sell (in the smart token)\r\n        @param _minReturn       if the conversion results in an amount smaller the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return sell return amount\r\n    */\r\n    function sell(IERC20Token _connectorToken, uint256 _sellAmount, uint256 _minReturn) internal returns (uint256) {\r\n        require(_sellAmount <= token.balanceOf(msg.sender)); // validate input\r\n\r\n        uint256 amount = getSaleReturn(_connectorToken, _sellAmount);\r\n        // ensure the trade gives something in return and meets the minimum requested amount\r\n        require(amount != 0 && amount >= _minReturn);\r\n\r\n        // ensure that the trade will only deplete the connector balance if the total supply is depleted as well\r\n        uint256 tokenSupply = token.totalSupply();\r\n        uint256 connectorBalance = getConnectorBalance(_connectorToken);\r\n        assert(amount < connectorBalance || (amount == connectorBalance && _sellAmount == tokenSupply));\r\n\r\n        // update virtual balance if relevant\r\n        Connector storage connector = connectors[_connectorToken];\r\n        if (connector.isVirtualBalanceEnabled)\r\n            connector.virtualBalance = safeSub(connector.virtualBalance, amount);\r\n\r\n        // destroy _sellAmount from the caller's balance in the smart token\r\n        token.destroy(msg.sender, _sellAmount);\r\n        // transfer funds to the caller in the connector token\r\n        // the transfer might fail if the actual connector balance is smaller than the virtual balance\r\n        assert(_connectorToken.transfer(msg.sender, amount));\r\n\r\n        // calculate conversion fee and dispatch the conversion event\r\n        uint256 feeAmount = safeSub(amount, getFinalAmount(amount, 1));\r\n        dispatchConversionEvent(token, _connectorToken, _sellAmount, amount, feeAmount);\r\n\r\n        // dispatch price data update for the smart token/connector\r\n        emit PriceDataUpdate(_connectorToken, token.totalSupply(), getConnectorBalance(_connectorToken), connector.weight);\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n        @dev converts the token to any other token in the bancor network by following a predefined conversion path\r\n        note that when converting from an ERC20 token (as opposed to a smart token), allowance must be set beforehand\r\n\r\n        @param _path        conversion path, see conversion path format in the BancorNetwork contract\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function quickConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn)\r\n        public\r\n        payable\r\n        validConversionPath(_path)\r\n        returns (uint256)\r\n    {\r\n        return quickConvertPrioritized(_path, _amount, _minReturn, 0x0, 0x0, 0x0, 0x0);\r\n    }\r\n\r\n    /**\r\n        @dev converts the token to any other token in the bancor network by following a predefined conversion path\r\n        note that when converting from an ERC20 token (as opposed to a smart token), allowance must be set beforehand\r\n\r\n        @param _path        conversion path, see conversion path format in the BancorNetwork contract\r\n        @param _amount      amount to convert from (in the initial source token)\r\n        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\r\n        @param _block       if the current block exceeded the given parameter - it is cancelled\r\n        @param _v           (signature[128:130]) associated with the signer address and helps validating if the signature is legit\r\n        @param _r           (signature[0:64]) associated with the signer address and helps validating if the signature is legit\r\n        @param _s           (signature[64:128]) associated with the signer address and helps validating if the signature is legit\r\n\r\n        @return tokens issued in return\r\n    */\r\n    function quickConvertPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, uint256 _block, uint8 _v, bytes32 _r, bytes32 _s)\r\n        public\r\n        payable\r\n        validConversionPath(_path)\r\n        returns (uint256)\r\n    {\r\n        IERC20Token fromToken = _path[0];\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(registry.getAddress(ContractIds.BANCOR_NETWORK));\r\n\r\n        // we need to transfer the source tokens from the caller to the BancorNetwork contract,\r\n        // so it can execute the conversion on behalf of the caller\r\n        if (msg.value == 0) {\r\n            // not ETH, send the source tokens to the BancorNetwork contract\r\n            // if the token is the smart token, no allowance is required - destroy the tokens\r\n            // from the caller and issue them to the BancorNetwork contract\r\n            if (fromToken == token) {\r\n                token.destroy(msg.sender, _amount); // destroy _amount tokens from the caller's balance in the smart token\r\n                token.issue(bancorNetwork, _amount); // issue _amount new tokens to the BancorNetwork contract\r\n            } else {\r\n                // otherwise, we assume we already have allowance, transfer the tokens directly to the BancorNetwork contract\r\n                assert(fromToken.transferFrom(msg.sender, bancorNetwork, _amount));\r\n            }\r\n        }\r\n\r\n        // execute the conversion and pass on the ETH with the call\r\n        return bancorNetwork.convertForPrioritized2.value(msg.value)(_path, _amount, _minReturn, msg.sender, _block, _v, _r, _s);\r\n    }\r\n\r\n    // deprecated, backward compatibility\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256) {\r\n        return convertInternal(_fromToken, _toToken, _amount, _minReturn);\r\n    }\r\n\r\n    /**\r\n        @dev helper, dispatches the Conversion event\r\n\r\n        @param _fromToken       ERC20 token to convert from\r\n        @param _toToken         ERC20 token to convert to\r\n        @param _amount          amount purchased/sold (in the source token)\r\n        @param _returnAmount    amount returned (in the target token)\r\n    */\r\n    function dispatchConversionEvent(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _returnAmount, uint256 _feeAmount) private {\r\n        // fee amount is converted to 255 bits -\r\n        // negative amount means the fee is taken from the source token, positive amount means its taken from the target token\r\n        // currently the fee is always taken from the target token\r\n        // since we convert it to a signed number, we first ensure that it's capped at 255 bits to prevent overflow\r\n        assert(_feeAmount <= 2 ** 255);\r\n        emit Conversion(_fromToken, _toToken, msg.sender, _amount, _returnAmount, int256(_feeAmount));\r\n    }\r\n\r\n    /**\r\n        @dev fallback, buys the smart token with ETH\r\n        note that the purchase will use the price at the time of the purchase\r\n    */\r\n    function() payable public {\r\n        quickConvert(quickBuyPath, msg.value, 1);\r\n    }\r\n}\r\n\r\n/*\r\n    Bancor Converter Factory\r\n*/\r\ncontract BancorConverterFactory is IBancorConverterFactory {\r\n    // triggered when a new converter is created\r\n    event NewConverter(address indexed _converter, address indexed _owner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function BancorConverterFactory() public {\r\n    }\r\n\r\n    /**\r\n        @dev creates a new converter with the given arguments and transfers\r\n        the ownership and management to the sender.\r\n\r\n        @param  _token              smart token governed by the converter\r\n        @param  _registry           address of a contract registry contract\r\n        @param  _maxConversionFee   maximum conversion fee, represented in ppm\r\n        @param  _connectorToken     optional, initial connector, allows defining the first connector at deployment time\r\n        @param  _connectorWeight    optional, weight for the initial connector\r\n\r\n        @return a new converter\r\n    */\r\n    function createConverter(\r\n        ISmartToken _token,\r\n        IContractRegistry _registry,\r\n        uint32 _maxConversionFee,\r\n        IERC20Token _connectorToken,\r\n        uint32 _connectorWeight\r\n    ) public returns(address converterAddress) {\r\n        BancorConverter converter = new BancorConverter(\r\n            _token,\r\n            _registry,\r\n            _maxConversionFee,\r\n            _connectorToken,\r\n            _connectorWeight\r\n        );\r\n\r\n        converter.transferOwnership(msg.sender);\r\n        converter.transferManagement(msg.sender);\r\n\r\n        address _converterAddress = address(converter);\r\n        emit NewConverter(_converterAddress, msg.sender);\r\n        return _converterAddress;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_maxConversionFee\",\"type\":\"uint32\"},{\"name\":\"_connectorToken\",\"type\":\"address\"},{\"name\":\"_connectorWeight\",\"type\":\"uint32\"}],\"name\":\"createConverter\",\"outputs\":[{\"name\":\"converterAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"NewConverter\",\"type\":\"event\"}]","ContractName":"BancorConverterFactory","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5b9ab1c5dfd6f764816bb88451f45361fcb5e6e8f307c988c6d3ef89f168d0fc"}]}