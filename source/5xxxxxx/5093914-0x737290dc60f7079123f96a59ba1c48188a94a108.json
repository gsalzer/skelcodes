{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n  \r\n\r\n\r\n\r\ncontract Exchange is Ownable {\r\n\r\n    \r\n    //between 0-10000\r\n    //Default 0\r\n    uint256 public transFeeCut =  0;\r\n\r\n    enum Errors {\r\n        ORDER_EXPIRED,\r\n        ORDER_FILLED,\r\n        ORDER_CACELD,\r\n        INSUFFICIENT_BALANCE_OR_ALLOWANCE\r\n    }\r\n\r\n\r\n    struct Order {\r\n        address maker; //买方\r\n        address taker;//卖方\r\n        address contractAddr; //买房商品合约地址\r\n        uint256 nftTokenId;//买房商品ID\r\n        uint256 tokenAmount;//价格\r\n        uint expirationTimestampInSec; //到期时间\r\n        bytes32 orderHash;\r\n    }\r\n\r\n    event LogFill(\r\n        address indexed maker,\r\n        address taker,\r\n        address contractAddr,\r\n        uint256 nftTokenId,\r\n        uint tokenAmount,\r\n        bytes32 indexed tokens, // keccak256(makerToken, takerToken), allows subscribing to a token pair\r\n        bytes32 orderHash\r\n    );\r\n\r\n    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\r\n\r\n    function getOrderHash(address[3] orderAddresses, uint[4] orderValues)\r\n        public\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            address(this),\r\n            orderAddresses[0], // maker\r\n            orderAddresses[1], // taker\r\n            orderAddresses[2], // contractAddr\r\n            orderValues[0],    // nftTokenId\r\n            orderValues[1],    // tokenAmount\r\n            orderValues[2],    // expirationTimestampInSec\r\n            orderValues[3]    // salt\r\n        );\r\n    }\r\n\r\n\r\n\r\n    function isValidSignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return signer == ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n\r\n\r\n    function fillOrder(\r\n          address[3] orderAddresses,\r\n          uint[4] orderValues,\r\n          uint8 v,\r\n          bytes32 r,\r\n          bytes32 s)\r\n          public\r\n          payable\r\n    {\r\n\r\n        Order memory order = Order({\r\n            maker: orderAddresses[0],\r\n            taker: orderAddresses[1],\r\n            contractAddr: orderAddresses[2],\r\n            nftTokenId: orderValues[0],\r\n            tokenAmount : orderValues[1],\r\n            expirationTimestampInSec: orderValues[2],\r\n            orderHash: getOrderHash(orderAddresses, orderValues)\r\n        });\r\n\r\n\r\n        if (msg.value < order.tokenAmount) {\r\n            LogError(uint8(Errors.INSUFFICIENT_BALANCE_OR_ALLOWANCE), order.orderHash);\r\n            return ;\r\n        }\r\n\r\n\r\n        require(msg.value >= order.tokenAmount);\r\n        require(order.taker == address(0) || order.taker == msg.sender);\r\n\r\n\r\n        require(order.tokenAmount > 0 );\r\n        require(isValidSignature(\r\n            order.maker,\r\n            order.orderHash,\r\n            v,\r\n            r,\r\n            s\r\n        ));\r\n\r\n        if (block.timestamp >= order.expirationTimestampInSec) {\r\n            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\r\n            return ;\r\n        }\r\n\r\n\r\n        require( transferViaProxy ( order.contractAddr , order.maker,msg.sender , order.nftTokenId )  );\r\n\r\n        uint256 transCut = _computeCut(order.tokenAmount);\r\n        order.maker.transfer(order.tokenAmount - transCut);\r\n        uint256 bidExcess = msg.value - order.tokenAmount;\r\n        //return\r\n        msg.sender.transfer(bidExcess);\r\n        LogFill(order.maker,msg.sender,order.contractAddr,order.nftTokenId,order.tokenAmount, keccak256(order.contractAddr),order.orderHash );\r\n    }\r\n\r\n\r\n    function transferViaProxy( address nftAddr, address maker ,address taker , uint256 nftId ) internal returns(bool) \r\n    {\r\n    \r\n       ERC721(nftAddr).transferFrom( maker, taker , nftId ) ;\r\n       return true;\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner{\r\n        uint256 balance = this.balance;\r\n        owner.transfer(balance);\r\n    }\r\n\r\n    function setTransFeeCut(uint256 val) external onlyOwner {\r\n        require(val <= 10000);\r\n        transFeeCut = val;\r\n    }\r\n\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        return _price * transFeeCut / 10000;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setTransFeeCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transFeeCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signer\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderAddresses\",\"type\":\"address[3]\"},{\"name\":\"orderValues\",\"type\":\"uint256[4]\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderAddresses\",\"type\":\"address[3]\"},{\"name\":\"orderValues\",\"type\":\"uint256[4]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"fillOrder\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"contractAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokens\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"LogFill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"errorId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Exchange","CompilerVersion":"v0.4.21-nightly.2018.2.14+commit.bb3b327c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://57e4fb70ef82ad8a189c9cfd6b5e63aeda960a2feeceadec2840e98c71c1421c"}]}