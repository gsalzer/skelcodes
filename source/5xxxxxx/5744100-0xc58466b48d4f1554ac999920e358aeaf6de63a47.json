{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary StringUtils {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string self) internal pure returns (slice) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice self) internal pure returns (slice) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice self) internal pure returns (string) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n    * Lower\r\n    *\r\n    * Converts all the values of a string to their corresponding lower case\r\n    * value.\r\n    *\r\n    * @param _base When being used for a data type this is the extended object\r\n    *              otherwise this is the string base to convert to lower case\r\n    * @return string\r\n    */\r\n    function lower(string _base) internal pure returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            _baseBytes[i] = _lower(_baseBytes[i]);\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n    * Lower\r\n    *\r\n    * Convert an alphabetic character to lower case and return the original\r\n    * value when not alphabetic\r\n    *\r\n    * @param _b1 The byte to be converted to lower case\r\n    * @return bytes1 The converted value if the passed value was alphabetic\r\n    *                and in a upper case otherwise returns the original value\r\n    */\r\n    function _lower(bytes1 _b1) internal pure returns (bytes1) {\r\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\r\n            return bytes1(uint8(_b1) + 32);\r\n        }\r\n        return _b1;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Withdrawable is Ownable {\r\n    // Allows owner to withdraw ether from the contract\r\n    function withdrawEther(address to) public onlyOwner {\r\n        to.transfer(address(this).balance);\r\n    }\r\n\r\n    // Allows owner to withdraw ERC20 tokens from the contract\r\n    function withdrawERC20Token(address tokenAddress, address to) public onlyOwner {\r\n        ERC20Basic token = ERC20Basic(tokenAddress);\r\n        token.transfer(to, token.balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract ClientRaindrop is Withdrawable {\r\n    // attach the StringUtils library\r\n    using StringUtils for string;\r\n    using StringUtils for StringUtils.slice;\r\n    // Events for when a user signs up for Raindrop Client and when their account is deleted\r\n    event UserSignUp(string casedUserName, address userAddress);\r\n    event UserDeleted(string casedUserName);\r\n\r\n    // Variables allowing this contract to interact with the Hydro token\r\n    address public hydroTokenAddress;\r\n    uint public minimumHydroStakeUser;\r\n    uint public minimumHydroStakeDelegatedUser;\r\n\r\n    // User account template\r\n    struct User {\r\n        string casedUserName;\r\n        address userAddress;\r\n    }\r\n\r\n    // Mapping from hashed uncased names to users (primary User directory)\r\n    mapping (bytes32 => User) internal userDirectory;\r\n    // Mapping from addresses to hashed uncased names (secondary directory for account recovery based on address)\r\n    mapping (address => bytes32) internal addressDirectory;\r\n\r\n    // Requires an address to have a minimum number of Hydro\r\n    modifier requireStake(address _address, uint stake) {\r\n        ERC20Basic hydro = ERC20Basic(hydroTokenAddress);\r\n        require(hydro.balanceOf(_address) >= stake, \"Insufficient HYDRO balance.\");\r\n        _;\r\n    }\r\n\r\n    // Allows applications to sign up users on their behalf iff users signed their permission\r\n    function signUpDelegatedUser(string casedUserName, address userAddress, uint8 v, bytes32 r, bytes32 s)\r\n        public\r\n        requireStake(msg.sender, minimumHydroStakeDelegatedUser)\r\n    {\r\n        require(\r\n            isSigned(userAddress, keccak256(abi.encodePacked(\"Create RaindropClient Hydro Account\")), v, r, s),\r\n            \"Permission denied.\"\r\n        );\r\n        _userSignUp(casedUserName, userAddress);\r\n    }\r\n\r\n    // Allows users to sign up with their own address\r\n    function signUpUser(string casedUserName) public requireStake(msg.sender, minimumHydroStakeUser) {\r\n        return _userSignUp(casedUserName, msg.sender);\r\n    }\r\n\r\n    // Allows users to delete their accounts\r\n    function deleteUser() public {\r\n        bytes32 uncasedUserNameHash = addressDirectory[msg.sender];\r\n        require(initialized(uncasedUserNameHash), \"No user associated with the sender address.\");\r\n\r\n        string memory casedUserName = userDirectory[uncasedUserNameHash].casedUserName;\r\n\r\n        delete addressDirectory[msg.sender];\r\n        delete userDirectory[uncasedUserNameHash];\r\n\r\n        emit UserDeleted(casedUserName);\r\n    }\r\n\r\n    // Allows the Hydro API to link to the Hydro token\r\n    function setHydroTokenAddress(address _hydroTokenAddress) public onlyOwner {\r\n        hydroTokenAddress = _hydroTokenAddress;\r\n    }\r\n\r\n    // Allows the Hydro API to set minimum hydro balances required for sign ups\r\n    function setMinimumHydroStakes(uint newMinimumHydroStakeUser, uint newMinimumHydroStakeDelegatedUser)\r\n        public onlyOwner\r\n    {\r\n        ERC20Basic hydro = ERC20Basic(hydroTokenAddress);\r\n        // <= the airdrop amount\r\n        require(newMinimumHydroStakeUser <= (222222 * 10**18), \"Stake is too high.\");\r\n        // <= 1% of total supply\r\n        require(newMinimumHydroStakeDelegatedUser <= (hydro.totalSupply() / 100), \"Stake is too high.\");\r\n        minimumHydroStakeUser = newMinimumHydroStakeUser;\r\n        minimumHydroStakeDelegatedUser = newMinimumHydroStakeDelegatedUser;\r\n    }\r\n\r\n    // Returns a bool indicating whether a given userName has been claimed (either exactly or as any case-variant)\r\n    function userNameTaken(string userName) public view returns (bool taken) {\r\n        bytes32 uncasedUserNameHash = keccak256(abi.encodePacked(userName.lower()));\r\n        return initialized(uncasedUserNameHash);\r\n    }\r\n\r\n    // Returns user details (including cased username) by any cased/uncased user name that maps to a particular user\r\n    function getUserByName(string userName) public view returns (string casedUserName, address userAddress) {\r\n        bytes32 uncasedUserNameHash = keccak256(abi.encodePacked(userName.lower()));\r\n        require(initialized(uncasedUserNameHash), \"User does not exist.\");\r\n\r\n        return (userDirectory[uncasedUserNameHash].casedUserName, userDirectory[uncasedUserNameHash].userAddress);\r\n    }\r\n\r\n    // Returns user details by user address\r\n    function getUserByAddress(address _address) public view returns (string casedUserName) {\r\n        bytes32 uncasedUserNameHash = addressDirectory[_address];\r\n        require(initialized(uncasedUserNameHash), \"User does not exist.\");\r\n\r\n        return userDirectory[uncasedUserNameHash].casedUserName;\r\n    }\r\n\r\n    // Checks whether the provided (v, r, s) signature was created by the private key associated with _address\r\n    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {\r\n        return (_isSigned(_address, messageHash, v, r, s) || _isSignedPrefixed(_address, messageHash, v, r, s));\r\n    }\r\n\r\n    // Checks unprefixed signatures\r\n    function _isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return ecrecover(messageHash, v, r, s) == _address;\r\n    }\r\n\r\n    // Checks prefixed signatures (e.g. those created with web3.eth.sign)\r\n    function _isSignedPrefixed(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedMessageHash = keccak256(abi.encodePacked(prefix, messageHash));\r\n\r\n        return ecrecover(prefixedMessageHash, v, r, s) == _address;\r\n    }\r\n\r\n    // Common internal logic for all user signups\r\n    function _userSignUp(string casedUserName, address userAddress) internal {\r\n        require(!initialized(addressDirectory[userAddress]), \"Address already registered.\");\r\n\r\n        require(bytes(casedUserName).length < 31, \"Username too long.\");\r\n        require(bytes(casedUserName).length > 3, \"Username too short.\");\r\n\r\n        bytes32 uncasedUserNameHash = keccak256(abi.encodePacked(casedUserName.toSlice().copy().toString().lower()));\r\n        require(!initialized(uncasedUserNameHash), \"Username taken.\");\r\n\r\n        userDirectory[uncasedUserNameHash] = User(casedUserName, userAddress);\r\n        addressDirectory[userAddress] = uncasedUserNameHash;\r\n\r\n        emit UserSignUp(casedUserName, userAddress);\r\n    }\r\n\r\n    function initialized(bytes32 uncasedUserNameHash) internal view returns (bool) {\r\n        return userDirectory[uncasedUserNameHash].userAddress != 0x0; // a sufficient initialization check\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"deleteUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumHydroStakeUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"casedUserName\",\"type\":\"string\"},{\"name\":\"userAddress\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"signUpDelegatedUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"casedUserName\",\"type\":\"string\"}],\"name\":\"signUpUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userName\",\"type\":\"string\"}],\"name\":\"getUserByName\",\"outputs\":[{\"name\":\"casedUserName\",\"type\":\"string\"},{\"name\":\"userAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserByAddress\",\"outputs\":[{\"name\":\"casedUserName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hydroTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumHydroStakeUser\",\"type\":\"uint256\"},{\"name\":\"newMinimumHydroStakeDelegatedUser\",\"type\":\"uint256\"}],\"name\":\"setMinimumHydroStakes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"isSigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumHydroStakeDelegatedUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hydroTokenAddress\",\"type\":\"address\"}],\"name\":\"setHydroTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userName\",\"type\":\"string\"}],\"name\":\"userNameTaken\",\"outputs\":[{\"name\":\"taken\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawERC20Token\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"casedUserName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"UserSignUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"casedUserName\",\"type\":\"string\"}],\"name\":\"UserDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ClientRaindrop","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8dc85eaf12914db10a33ed27b0fbe4802ea578bcf1542d3f3b1a80e7d7fa5d47"}]}