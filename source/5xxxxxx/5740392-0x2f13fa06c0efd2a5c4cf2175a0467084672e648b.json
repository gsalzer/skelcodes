{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// File: contracts/IToken.sol\r\n\r\n/**\r\n * @title Token\r\n * @dev Token interface necessary for working with tokens within the exchange contract.\r\n */\r\ncontract IToken {\r\n  /// @return total amount of tokens\r\n  function totalSupply() public constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\n// File: contracts/LSafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary LSafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/MarketPlace.sol\r\n\r\n/**\r\n * @title Z\r\n * @dev This is the main contract for the MarketPlace exchange.\r\n */\r\ncontract MarketPlace {\r\n\r\n  using LSafeMath for uint;\r\n\r\n  /// Variables\r\n  address public admin; // the admin address\r\n  address public feeAccount; // the account that will receive fees\r\n  uint public feeTake; // percentage times (1 ether)\r\n  uint public freeUntilDate; // date in UNIX timestamp that trades will be free until\r\n  bool private depositingTokenFlag; // True when Token.transferFrom is being called from depositToken\r\n  mapping (address => mapping (address => uint)) public tokens; // mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; // mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n  address public predecessor; // Address of the previous version of this contract. If address(0), this is the first version\r\n  address public successor; // Address of the next version of this contract. If address(0), this is the most up to date version.\r\n  uint16 public version; // This is the version # of the contract\r\n\r\n  /// Logging Events\r\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\r\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n  event FundsMigrated(address user, address newContract);\r\n\r\n  /// This is a modifier for functions to check if the sending user address is the same as the admin user address.\r\n  modifier isAdmin() {\r\n      require(msg.sender == admin);\r\n      _;\r\n  }\r\n\r\n  /// Constructor function. This is only called on contract creation.\r\n  function MarketPlace(address admin_, address feeAccount_, uint feeTake_, uint freeUntilDate_, address predecessor_) public {\r\n    admin = admin_;\r\n    feeAccount = feeAccount_;\r\n    feeTake = feeTake_;\r\n    freeUntilDate = freeUntilDate_;\r\n    depositingTokenFlag = false;\r\n    predecessor = predecessor_;\r\n\r\n    if (predecessor != address(0)) {\r\n      version = MarketPlace(predecessor).version() + 1;\r\n    } else {\r\n      version = 1;\r\n    }\r\n  }\r\n\r\n  /// The fallback function. Ether transfered into the contract is not accepted.\r\n  function() public {\r\n    revert();\r\n  }\r\n\r\n  /// Changes the official admin user address. Accepts Ethereum address.\r\n  function changeAdmin(address admin_) public isAdmin {\r\n    require(admin_ != address(0));\r\n    admin = admin_;\r\n  }\r\n\r\n  /// Changes the account address that receives trading fees. Accepts Ethereum address.\r\n  function changeFeeAccount(address feeAccount_) public isAdmin {\r\n    feeAccount = feeAccount_;\r\n  }\r\n\r\n  /// Changes the fee on takes. Can only be changed to a value less than it is currently set at.\r\n  function changeFeeTake(uint feeTake_) public isAdmin {\r\n    require(feeTake_ <= feeTake);\r\n    feeTake = feeTake_;\r\n  }\r\n\r\n  /// Changes the date that trades are free until. Accepts UNIX timestamp.\r\n  function changeFreeUntilDate(uint freeUntilDate_) public isAdmin {\r\n    freeUntilDate = freeUntilDate_;\r\n  }\r\n\r\n  /// Changes the successor. Used in updating the contract.\r\n  function setSuccessor(address successor_) public isAdmin {\r\n    require(successor_ != address(0));\r\n    successor = successor_;\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Deposits, Withdrawals, Balances\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n  * This function handles deposits of Ether into the contract.\r\n  * Emits a Deposit event.\r\n  * Note: With the payable modifier, this function accepts Ether.\r\n  */\r\n  function deposit() public payable {\r\n    tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * This function handles withdrawals of Ether from the contract.\r\n  * Verifies that the user has enough funds to cover the withdrawal.\r\n  * Emits a Withdraw event.\r\n  * @param amount uint of the amount of Ether the user wishes to withdraw\r\n  */\r\n  function withdraw(uint amount) public {\r\n    require(tokens[0][msg.sender] >= amount);\r\n    tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\r\n    msg.sender.transfer(amount);\r\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * This function handles deposits of Ethereum based tokens to the contract.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Emits a Deposit event.\r\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param amount uint of the amount of the token the user wishes to deposit\r\n  */\r\n  function depositToken(address token, uint amount) public {\r\n    require(token != 0);\r\n    depositingTokenFlag = true;\r\n    require(IToken(token).transferFrom(msg.sender, this, amount));\r\n    depositingTokenFlag = false;\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n }\r\n\r\n  /**\r\n  * This function provides a fallback solution as outlined in ERC223.\r\n  * If tokens are deposited through depositToken(), the transaction will continue.\r\n  * If tokens are sent directly to this contract, the transaction is reverted.\r\n  * @param sender Ethereum address of the sender of the token\r\n  * @param amount amount of the incoming tokens\r\n  * @param data attached data similar to msg.data of Ether transactions\r\n  */\r\n  function tokenFallback( address sender, uint amount, bytes data) public returns (bool ok) {\r\n      if (depositingTokenFlag) {\r\n        // Transfer was initiated from depositToken(). User token balance will be updated there.\r\n        return true;\r\n      } else {\r\n        // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent\r\n        // with direct transfers of ECR20 and ETH.\r\n        revert();\r\n      }\r\n  }\r\n\r\n  /**\r\n  * This function handles withdrawals of Ethereum based tokens from the contract.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Emits a Withdraw event.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param amount uint of the amount of the token the user wishes to withdraw\r\n  */\r\n  function withdrawToken(address token, uint amount) public {\r\n    require(token != 0);\r\n    require(tokens[token][msg.sender] >= amount);\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n    require(IToken(token).transfer(msg.sender, amount));\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  /**\r\n  * Retrieves the balance of a token based on a user address and token address.\r\n  * @param token Ethereum contract address of the token or 0 for Ether\r\n  * @param user Ethereum address of the user\r\n  * @return the amount of tokens on the exchange for a given user address\r\n  */\r\n  function balanceOf(address token, address user) public constant returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Trading\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n  * Stores the active order inside of the contract.\r\n  * Emits an Order event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  */\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    orders[msg.sender][hash] = true;\r\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\r\n  }\r\n\r\n  /**\r\n  * Facilitates a trade from one user to another.\r\n  * Requires that the transaction is signed properly, the trade isn't past its expiration, and all funds are present to fill the trade.\r\n  * Calls tradeBalances().\r\n  * Updates orderFills with the amount traded.\r\n  * Emits a Trade event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  */\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    require((\r\n      (orders[user][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) &&\r\n      block.number <= expires &&\r\n      orderFills[user][hash].add(amount) <= amountGet\r\n    ));\r\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\r\n    orderFills[user][hash] = orderFills[user][hash].add(amount);\r\n    Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender);\r\n  }\r\n\r\n  /**\r\n  * This is a private function and is only being called from trade().\r\n  * Handles the movement of funds when a trade occurs.\r\n  * Takes fees.\r\n  * Updates token balances for both buyer and seller.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  */\r\n  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\r\n\r\n    uint feeTakeXfer = 0;\r\n\r\n    if (now >= freeUntilDate) {\r\n      feeTakeXfer = amount.mul(feeTake).div(1 ether);\r\n    }\r\n\r\n    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount.add(feeTakeXfer));\r\n    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount);\r\n    tokens[tokenGet][feeAccount] = tokens[tokenGet][feeAccount].add(feeTakeXfer);\r\n    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\r\n    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\r\n  }\r\n\r\n  /**\r\n  * This function is to test if a trade would go through.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * Note: amount is in amountGet / tokenGet terms.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\r\n  * @param sender Ethereum address of the user taking the order\r\n  * @return bool: true if the trade would be successful, false otherwise\r\n  */\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\r\n    if (!(\r\n      tokens[tokenGet][sender] >= amount &&\r\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\r\n      )) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This function checks the available volume for a given order.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\r\n  */\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    if (!(\r\n      (orders[user][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) &&\r\n      block.number <= expires\r\n      )) {\r\n      return 0;\r\n    }\r\n    uint[2] memory available;\r\n    available[0] = amountGet.sub(orderFills[user][hash]);\r\n    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;\r\n    if (available[0] < available[1]) {\r\n      return available[0];\r\n    } else {\r\n      return available[1];\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This function checks the amount of an order that has already been filled.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param user Ethereum address of the user who placed the order\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n  */\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    return orderFills[user][hash];\r\n  }\r\n\r\n  /**\r\n  * This function cancels a given order by editing its fill data to the full amount.\r\n  * Requires that the transaction is signed properly.\r\n  * Updates orderFills to the full amountGet\r\n  * Emits a Cancel event.\r\n  * Note: tokenGet & tokenGive can be the Ethereum contract address.\r\n  * @param tokenGet Ethereum contract address of the token to receive\r\n  * @param amountGet uint amount of tokens being received\r\n  * @param tokenGive Ethereum contract address of the token to give\r\n  * @param amountGive uint amount of tokens being given\r\n  * @param expires uint of block number when this order should expire\r\n  * @param nonce arbitrary random number\r\n  * @param v part of signature for the order hash as signed by user\r\n  * @param r part of signature for the order hash as signed by user\r\n  * @param s part of signature for the order hash as signed by user\r\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\r\n  */\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\r\n    require ((orders[msg.sender][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == msg.sender));\r\n    orderFills[msg.sender][hash] = amountGet;\r\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\r\n  }\r\n\r\n\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  // Contract Versioning / Migration\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n  * User triggered function to migrate funds into a new contract to ease updates.\r\n  * Emits a FundsMigrated event.\r\n  * @param newContract Contract address of the new contract we are migrating funds to\r\n  * @param tokens_ Array of token addresses that we will be migrating to the new contract\r\n  */\r\n  function migrateFunds(address newContract, address[] tokens_) public {\r\n\r\n    require(newContract != address(0));\r\n\r\n    MarketPlace newExchange = MarketPlace(newContract);\r\n\r\n    // Move Ether into new exchange.\r\n    uint etherAmount = tokens[0][msg.sender];\r\n    if (etherAmount > 0) {\r\n      tokens[0][msg.sender] = 0;\r\n      newExchange.depositForUser.value(etherAmount)(msg.sender);\r\n    }\r\n\r\n    // Move Tokens into new exchange.\r\n    for (uint16 n = 0; n < tokens_.length; n++) {\r\n      address token = tokens_[n];\r\n      require(token != address(0)); // Ether is handled above.\r\n      uint tokenAmount = tokens[token][msg.sender];\r\n\r\n      if (tokenAmount != 0) {\r\n      \trequire(IToken(token).approve(newExchange, tokenAmount));\r\n      \ttokens[token][msg.sender] = 0;\r\n      \tnewExchange.depositTokenForUser(token, tokenAmount, msg.sender);\r\n      }\r\n    }\r\n\r\n    FundsMigrated(msg.sender, newContract);\r\n  }\r\n\r\n  /**\r\n  * This function handles deposits of Ether into the contract, but allows specification of a user.\r\n  * Note: This is generally used in migration of funds.\r\n  * Note: With the payable modifier, this function accepts Ether.\r\n  */\r\n  function depositForUser(address user) public payable {\r\n    require(user != address(0));\r\n    require(msg.value > 0);\r\n    tokens[0][user] = tokens[0][user].add(msg.value);\r\n  }\r\n\r\n  /**\r\n  * This function handles deposits of Ethereum based tokens into the contract, but allows specification of a user.\r\n  * Does not allow Ether.\r\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\r\n  * Note: This is generally used in migration of funds.\r\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n  * @param token Ethereum contract address of the token\r\n  * @param amount uint of the amount of the token the user wishes to deposit\r\n  */\r\n  function depositTokenForUser(address token, uint amount, address user) public {\r\n    require(token != address(0));\r\n    require(user != address(0));\r\n    require(amount > 0);\r\n    depositingTokenFlag = true;\r\n    require(IToken(token).transferFrom(msg.sender, this, amount));\r\n    depositingTokenFlag = false;\r\n    tokens[token][user] = tokens[token][user].add(amount);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"order\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"successor_\",\"type\":\"address\"}],\"name\":\"setSuccessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositTokenForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"amountFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContract\",\"type\":\"address\"},{\"name\":\"tokens_\",\"type\":\"address[]\"}],\"name\":\"migrateFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositForUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"testTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"successor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feeTake_\",\"type\":\"uint256\"}],\"name\":\"changeFeeTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"freeUntilDate_\",\"type\":\"uint256\"}],\"name\":\"changeFreeUntilDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"predecessor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freeUntilDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenGet\",\"type\":\"address\"},{\"name\":\"amountGet\",\"type\":\"uint256\"},{\"name\":\"tokenGive\",\"type\":\"address\"},{\"name\":\"amountGive\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"availableVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"},{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"feeTake_\",\"type\":\"uint256\"},{\"name\":\"freeUntilDate_\",\"type\":\"uint256\"},{\"name\":\"predecessor_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"get\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"give\",\"type\":\"address\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"FundsMigrated\",\"type\":\"event\"}]","ContractName":"MarketPlace","CompilerVersion":"v0.4.25-nightly.2018.6.4+commit.a074d84","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000718b6aca52548416e27ab38699cbc4c0ed304b950000000000000000000000003ab32782b310b559b79aa086e0e844719a3f42ae000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://508649986d3f975438835043b4800faa39f33663524495c67ce69b58e77414de"}]}