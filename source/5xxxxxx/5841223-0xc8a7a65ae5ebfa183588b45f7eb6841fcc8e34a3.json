{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Interface {\r\n     function totalSupply() public constant returns (uint);\r\n     function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n     function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n     function transfer(address to, uint tokens) public returns (bool success);\r\n     function approve(address spender, uint tokens) public returns (bool success);\r\n     function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n     function mint(address from, address to, uint tokens) public;\r\n     event Transfer(address indexed from, address indexed to, uint tokens);\r\n     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract MusicContract {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    struct Music {\r\n      address musician;\r\n      uint musicId;\r\n      string musicLink;\r\n      bool marketType;    //false for sponsor, true for votes\r\n      uint totalAmountForUnlock;\r\n      uint totalEarning;\r\n      uint amountLeftForUnlock;\r\n      uint amountToBePaid;\r\n      bool isUnlocked;  \r\n    }    \r\n    \r\n    struct Voter {\r\n      address publicKey;\r\n      uint amountEarned;  \r\n    }\r\n    \r\n    struct Sponsor {\r\n      address publicKey;\r\n      uint amountEarned;\r\n      uint amountPaid;\r\n    }\r\n    \r\n    struct VoteMusicPayoutScheme {\r\n      uint musicianPercentage; //57\r\n      uint voterPercentage;// 35\r\n      uint systemPercentage;// 8  \r\n    }\r\n    \r\n    struct SponsorPayoutScheme {\r\n      uint sponsorPercentage;// 45\r\n      uint musicianPercentage;// 37\r\n      uint voterPercentage; // 10\r\n      uint systemPercentage; // 8\r\n    }\r\n    \r\n    // The token that would be sold using this contract \r\n    ERC20Interface public token;\r\n    //Objects for use within program\r\n    VoteMusicPayoutScheme voteMusicPayoutSchemeObj;\r\n    SponsorPayoutScheme sponsorPayoutSchemeObj;\r\n    Music music;\r\n    Sponsor sponsor;\r\n    Voter voter;\r\n    uint counter = 0;\r\n    address public wallet;\r\n    \r\n    mapping (uint=>Voter[]) musicVoterList;\r\n    mapping (uint=>Sponsor[]) musicSponsorList;\r\n   \r\n    mapping (uint=>Music) musicList;\r\n    uint localIntAsPerNeed;\r\n    address localAddressAsPerNeed;\r\n    Voter[] voters;\r\n    Sponsor[] sponsors;\r\n   \r\n    constructor(address _wallet,address _tokenAddress) public {\r\n      wallet = _wallet;\r\n      token = ERC20Interface(_tokenAddress);\r\n      setup();\r\n    }\r\n        \r\n    // fallback function can be used to buy tokens\r\n    function () public payable {\r\n        revert();\r\n    }\r\n    \r\n    function setup() internal {\r\n        voteMusicPayoutSchemeObj = VoteMusicPayoutScheme({musicianPercentage:57, voterPercentage:35, systemPercentage:8});\r\n        sponsorPayoutSchemeObj = SponsorPayoutScheme({sponsorPercentage:45, musicianPercentage: 37, voterPercentage:10, systemPercentage:8});\r\n    }\r\n    \r\n    function UploadMusic(uint muId, string lnk, address muPublicKey,bool unlocktype,uint amount, uint uploadTokenAmount) public\r\n    {\r\n        require(msg.sender == wallet);\r\n        token.mint(muPublicKey,wallet,uploadTokenAmount*10**18);    //tokens deducted from advertiser's wallet\r\n        \r\n        require(musicList[muId].musicId == 0);\r\n      //Add to music struct\r\n      music = Music ({\r\n          musician : muPublicKey,\r\n          musicId : muId,\r\n          musicLink : lnk,\r\n          marketType : unlocktype,\r\n          totalEarning : 0,\r\n          totalAmountForUnlock : amount * 10 ** 18,\r\n          amountLeftForUnlock : amount * 10 ** 18,\r\n          amountToBePaid : uploadTokenAmount * 10 **18,\r\n          isUnlocked : false\r\n      });\r\n      musicList[muId] = music;\r\n    }\r\n\r\n   function DownloadMusic(uint musId, address senderId, uint tokenAmount) public returns (bool goAhead)\r\n    {\r\n        require(msg.sender == wallet);\r\n        require(musicList[musId].musicId == musId);\r\n        require(musicList[musId].isUnlocked == true);\r\n        token.mint(senderId,wallet,tokenAmount*10**18);\r\n       \r\n        musicList[musId].totalEarning = musicList[musId].totalEarning.add(tokenAmount);\r\n        musicList[musId].amountToBePaid = musicList[musId].amountToBePaid.add(tokenAmount);\r\n        goAhead = true;\r\n    }\r\n    \r\n    function DoSponsorPayout(Music musicObj) private\r\n    {\r\n        \r\n        //sponsor   \r\n        localIntAsPerNeed = musicObj.musicId;\r\n        sponsors = musicSponsorList[localIntAsPerNeed];\r\n                    \r\n        //calculating sponsor payout\r\n        localIntAsPerNeed = sponsorPayoutSchemeObj.sponsorPercentage;\r\n        uint sponsorPayout = musicObj.amountToBePaid.mul(localIntAsPerNeed);\r\n        sponsorPayout = sponsorPayout.div(100);\r\n        \r\n        //calculating voter payout\r\n        voters = musicVoterList[musicObj.musicId];\r\n        localIntAsPerNeed = sponsorPayoutSchemeObj.voterPercentage;\r\n        uint voterPayout = musicObj.amountToBePaid.mul(localIntAsPerNeed);\r\n        voterPayout = voterPayout.div(100);\r\n        \r\n        //calculating musician payout\r\n        localIntAsPerNeed = sponsorPayoutSchemeObj.musicianPercentage;\r\n        uint musicianPayout = musicObj.amountToBePaid.mul(localIntAsPerNeed);\r\n        musicianPayout = musicianPayout.div(100);\r\n        \r\n        //calculating system payout\r\n        localIntAsPerNeed = sponsorPayoutSchemeObj.systemPercentage;\r\n        uint systemPayout = musicObj.amountToBePaid.mul(localIntAsPerNeed);\r\n        systemPayout = systemPayout.div(100);\r\n        \r\n        \r\n        //doing sponsor payout            \r\n        for (counter=0;counter<sponsors.length;counter++)\r\n        {\r\n            //Find the percentage\r\n            localIntAsPerNeed = sponsors[counter].amountPaid.mul(100);\r\n            localIntAsPerNeed = localIntAsPerNeed.div(musicObj.totalAmountForUnlock);\r\n            uint amtToSend = sponsorPayout.mul(localIntAsPerNeed);\r\n            amtToSend = amtToSend.div(100);\r\n            token.mint(wallet, sponsors[counter].publicKey, amtToSend);\r\n            sponsors[counter].amountEarned = sponsors[counter].amountEarned.add(amtToSend);\r\n            musicObj.amountToBePaid = musicObj.amountToBePaid.sub(amtToSend);\r\n        }     \r\n        \r\n        \r\n        //doing voter payout\r\n        if (voters.length>0)\r\n        {\r\n            uint perVoterPayout = voterPayout.div(voters.length);\r\n               \r\n            for (counter=0;counter<voters.length;counter++)\r\n            {\r\n                token.mint(wallet, voters[counter].publicKey, perVoterPayout);\r\n                voters[counter].amountEarned = voters[counter].amountEarned.add(perVoterPayout);\r\n                musicObj.amountToBePaid = musicObj.amountToBePaid.sub(perVoterPayout);\r\n            }\r\n        }\r\n        else\r\n        {\r\n             musicObj.amountToBePaid = musicObj.amountToBePaid.sub(voterPayout);\r\n        }\r\n        \r\n        \r\n        //doing musician payout\r\n        localAddressAsPerNeed = musicObj.musician;\r\n        token.mint(wallet,localAddressAsPerNeed,musicianPayout);\r\n        musicObj.amountToBePaid = musicObj.amountToBePaid.sub(musicianPayout);\r\n                \r\n        //catering for system payout - no token transfers as the tokens are already in the owner wallet\r\n        musicObj.amountToBePaid = musicObj.amountToBePaid.sub(systemPayout);\r\n        \r\n        require(musicObj.amountToBePaid == 0);\r\n    }\r\n    function DoVoterPayout(Music musicObj) private\r\n    {\r\n        uint j = 0;\r\n        //sponsor   \r\n        \r\n        //calculating voter payout\r\n        voters = musicVoterList[musicObj.musicId];\r\n        localIntAsPerNeed = voteMusicPayoutSchemeObj.voterPercentage;\r\n        uint voterPayout = musicObj.amountToBePaid.mul(localIntAsPerNeed);\r\n        voterPayout = voterPayout.div(100);\r\n        uint perVoterPayout = voterPayout.div(voters.length);\r\n        \r\n        //calculating musician payout\r\n        localIntAsPerNeed = voteMusicPayoutSchemeObj.musicianPercentage;\r\n        uint musicianPayout = musicObj.amountToBePaid.mul(localIntAsPerNeed);\r\n        musicianPayout = musicianPayout.div(100);\r\n        \r\n        //calculating system payout\r\n        localIntAsPerNeed = voteMusicPayoutSchemeObj.systemPercentage;\r\n        uint systemPayout = musicObj.amountToBePaid.mul(localIntAsPerNeed);\r\n        systemPayout = systemPayout.div(100);\r\n        \r\n        //doing voter payout     \r\n        for (j=0;j<voters.length;j++)\r\n        {\r\n            token.mint(wallet,voters[j].publicKey, perVoterPayout);\r\n            voters[j].amountEarned = voters[j].amountEarned.add(perVoterPayout);\r\n            musicObj.amountToBePaid = musicObj.amountToBePaid.sub(perVoterPayout);\r\n        }\r\n        \r\n        //doing musician payout\r\n        token.mint(wallet,musicObj.musician,musicianPayout);\r\n        musicObj.amountToBePaid = musicObj.amountToBePaid.sub(musicianPayout);\r\n        //logString(\"musician payout done\");\r\n        \r\n        //catering for system payout - not doing manual transfer as all the tokens are already in the wallet\r\n        musicObj.amountToBePaid = musicObj.amountToBePaid.sub(systemPayout);\r\n        \r\n        require(musicObj.amountToBePaid == 0);            \r\n    }\r\n    function DoMusicPayout (uint musId) public\r\n    {\r\n        require(msg.sender == wallet);\r\n        require(musicList[musId].musicId == musId);\r\n        require(musicList[musId].isUnlocked == true);\r\n        require(musicList[musId].amountToBePaid > 0);\r\n        require(token.balanceOf(wallet)>=musicList[musId].amountToBePaid);\r\n        bool unlock = musicList[musId].marketType;\r\n        if (unlock == false)\r\n        {\r\n            //unlock type is sponsor\r\n            DoSponsorPayout(musicList[musId]);\r\n            musicList[musId].amountToBePaid = 0;\r\n        }\r\n        else\r\n        {\r\n            //unlock type is voter\r\n            DoVoterPayout(musicList[musId]);\r\n            musicList[musId].amountToBePaid = 0;\r\n        }\r\n    }\r\n    function SponsorMusic(uint musId, uint sponsorAmount, address sponsorAddress) public\r\n    {\r\n        //msg.sender is the sponsor\r\n        sponsorAmount = sponsorAmount * 10 ** 18;\r\n        require(token.balanceOf(sponsorAddress) > sponsorAmount);   \r\n        require (musicList[musId].musicId == musId);\r\n        require  (musicList[musId].isUnlocked == false);\r\n        require(musicList[musId].marketType == false);\r\n        require (musicList[musId].amountLeftForUnlock>=sponsorAmount);\r\n        token.mint(sponsorAddress,wallet,sponsorAmount);\r\n        \r\n        musicList[musId].amountLeftForUnlock = musicList[musId].amountLeftForUnlock.sub(sponsorAmount);\r\n        musicList[musId].amountToBePaid = musicList[musId].amountToBePaid.add(sponsorAmount);\r\n        sponsor = Sponsor({\r\n            publicKey : msg.sender,\r\n            amountEarned : 0,\r\n            amountPaid : sponsorAmount\r\n        });\r\n                  \r\n        musicSponsorList[musId].push(sponsor);\r\n        if (musicList[musId].amountLeftForUnlock == 0)\r\n        {\r\n            musicList[musId].isUnlocked = true;\r\n        }\r\n    }\r\n    \r\n    function VoteMusic(uint musId, address voterPublicKey) public \r\n    {\r\n        require(musicList[musId].musicId == musId);\r\n        require(musicList[musId].isUnlocked == false);\r\n        //logString(\"music found\");\r\n        voter = Voter({publicKey: voterPublicKey, amountEarned : 0});\r\n        musicVoterList[musId].push(voter);\r\n        //logString(\"voter added\");\r\n    }\r\n    function unlockVoterMusic(uint musId) public\r\n    {\r\n        require(msg.sender == wallet);\r\n        require(musicList[musId].musicId == musId);\r\n        musicList[musId].isUnlocked = true;\r\n    }\r\n    function getTokenBalance() public constant returns (uint) {\r\n        return token.balanceOf(msg.sender);\r\n    }\r\n    \r\n    function changeWalletAddress(address newWallet) public  \r\n    {\r\n        require(msg.sender == wallet);\r\n        wallet = newWallet;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"muId\",\"type\":\"uint256\"},{\"name\":\"lnk\",\"type\":\"string\"},{\"name\":\"muPublicKey\",\"type\":\"address\"},{\"name\":\"unlocktype\",\"type\":\"bool\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"uploadTokenAmount\",\"type\":\"uint256\"}],\"name\":\"UploadMusic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"musId\",\"type\":\"uint256\"},{\"name\":\"senderId\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"DownloadMusic\",\"outputs\":[{\"name\":\"goAhead\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"musId\",\"type\":\"uint256\"}],\"name\":\"DoMusicPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"musId\",\"type\":\"uint256\"},{\"name\":\"voterPublicKey\",\"type\":\"address\"}],\"name\":\"VoteMusic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"musId\",\"type\":\"uint256\"},{\"name\":\"sponsorAmount\",\"type\":\"uint256\"},{\"name\":\"sponsorAddress\",\"type\":\"address\"}],\"name\":\"SponsorMusic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"changeWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"musId\",\"type\":\"uint256\"}],\"name\":\"unlockVoterMusic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"MusicContract","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000310ec7780d07ae2caafc01545e5b824275167b54000000000000000000000000395a200ab37e622ad721f6c0d2fa913b522c84cf","Library":"","SwarmSource":"bzzr://dcdd6b09e58544dc8d6b1065e3e4f8e014e5264de39bd4e6d73170e1762a6481"}]}