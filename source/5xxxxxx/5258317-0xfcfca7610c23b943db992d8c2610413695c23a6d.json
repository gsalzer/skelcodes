{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/flavours/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/commons/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/flavours/Lockable.sol\r\n\r\n/**\r\n * @title Lockable\r\n * @dev Base contract which allows children to\r\n *      implement main operations locking mechanism.\r\n */\r\ncontract Lockable is Ownable {\r\n    event Lock();\r\n    event Unlock();\r\n\r\n    bool public locked = false;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable\r\n    *       only when the contract is not locked.\r\n     */\r\n    modifier whenNotLocked() {\r\n        require(!locked);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable\r\n     *      only when the contract is locked.\r\n     */\r\n    modifier whenLocked() {\r\n        require(locked);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to locke, triggers locked state\r\n     */\r\n    function lock() public onlyOwner whenNotLocked {\r\n        locked = true;\r\n        Lock();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner\r\n     *      to unlock, returns to unlocked state\r\n     */\r\n    function unlock() public onlyOwner whenLocked {\r\n        locked = false;\r\n        Unlock();\r\n    }\r\n}\r\n\r\n// File: contracts/base/BaseFixedERC20Token.sol\r\n\r\ncontract BaseFixedERC20Token is Lockable {\r\n    using SafeMath for uint;\r\n\r\n    /// @dev ERC20 Total supply\r\n    uint public totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n\r\n    mapping(address => mapping(address => uint)) private allowed;\r\n\r\n    /// @dev Fired if Token transfered accourding to ERC20\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    /// @dev Fired if Token withdraw is approved accourding to ERC20\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner_ The address to query the the balance of.\r\n     * @return An uint representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner_) public view returns (uint balance) {\r\n        return balances[owner_];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param to_ The address to transfer to.\r\n     * @param value_ The amount to be transferred.\r\n     */\r\n    function transfer(address to_, uint value_) public whenNotLocked returns (bool) {\r\n        require(to_ != address(0) && value_ <= balances[msg.sender]);\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(value_);\r\n        balances[to_] = balances[to_].add(value_);\r\n        Transfer(msg.sender, to_, value_);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param from_ address The address which you want to send tokens from\r\n     * @param to_ address The address which you want to transfer to\r\n     * @param value_ uint the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from_, address to_, uint value_) public whenNotLocked returns (bool) {\r\n        require(to_ != address(0) && value_ <= balances[from_] && value_ <= allowed[from_][msg.sender]);\r\n        balances[from_] = balances[from_].sub(value_);\r\n        balances[to_] = balances[to_].add(value_);\r\n        allowed[from_][msg.sender] = allowed[from_][msg.sender].sub(value_);\r\n        Transfer(from_, to_, value_);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering.\r\n     *\r\n     * To change the approve amount you first have to reduce the addresses\r\n     * allowance to zero by calling `approve(spender_, 0)` if it is not\r\n     * already 0 to mitigate the race condition described in:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * @param spender_ The address which will spend the funds.\r\n     * @param value_ The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender_, uint value_) public whenNotLocked returns (bool) {\r\n        if (value_ != 0 && allowed[msg.sender][spender_] != 0) {\r\n            revert();\r\n        }\r\n        allowed[msg.sender][spender_] = value_;\r\n        Approval(msg.sender, spender_, value_);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner_ address The address which owns the funds.\r\n     * @param spender_ address The address which will spend the funds.\r\n     * @return A uint specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner_, address spender_) public view returns (uint) {\r\n        return allowed[owner_][spender_];\r\n    }\r\n}\r\n\r\n// File: contracts/base/BaseICOToken.sol\r\n\r\n/**\r\n * @dev Not mintable, ERC20 compilant token, distributed by ICO/Pre-ICO.\r\n */\r\ncontract BaseICOToken is BaseFixedERC20Token {\r\n\r\n    /// @dev Available supply of tokens\r\n    uint public availableSupply;\r\n\r\n    /// @dev ICO/Pre-ICO smart contract allowed to distribute public funds for this\r\n    address public ico;\r\n\r\n    /// @dev Fired if investment for `amount` of tokens performed by `to` address\r\n    event ICOTokensInvested(address indexed to, uint amount);\r\n\r\n    /// @dev ICO contract changed for this token\r\n    event ICOChanged(address indexed icoContract);\r\n\r\n    modifier onlyICO() {\r\n        require(msg.sender == ico);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Not mintable, ERC20 compilant token, distributed by ICO/Pre-ICO.\r\n     * @param totalSupply_ Total tokens supply.\r\n     */\r\n    function BaseICOToken(uint totalSupply_) public {\r\n        locked = true;\r\n        totalSupply = totalSupply_;\r\n        availableSupply = totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * @dev Set address of ICO smart-contract which controls token\r\n     * initial token distribution.\r\n     * @param ico_ ICO contract address.\r\n     */\r\n    function changeICO(address ico_) public onlyOwner {\r\n        ico = ico_;\r\n        ICOChanged(ico);\r\n    }\r\n\r\n    /**\r\n     * @dev Assign `amount_` of tokens to investor identified by `to_` address.\r\n     * @param to_ Investor address.\r\n     * @param amount_ Number of tokens distributed.\r\n     */\r\n    function icoInvestment(address to_, uint amount_) public onlyICO returns (uint) {\r\n        require(isValidICOInvestment(to_, amount_));\r\n        availableSupply = availableSupply.sub(amount_);\r\n        balances[to_] = balances[to_].add(amount_);\r\n        ICOTokensInvested(to_, amount_);\r\n        return amount_;\r\n    }\r\n\r\n    function isValidICOInvestment(address to_, uint amount_) internal view returns (bool) {\r\n        return to_ != address(0) && amount_ <= availableSupply;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/base/BaseICO.sol\r\n\r\n/**\r\n * @dev Base abstract smart contract for any ICO\r\n */\r\ncontract BaseICO is Ownable {\r\n\r\n    /// @dev ICO state\r\n    enum State {\r\n        // ICO is not active and not started\r\n        Inactive,\r\n        // ICO is active, tokens can be distributed among investors.\r\n        // ICO parameters (end date, hard/low caps) cannot be changed.\r\n        Active,\r\n        // ICO is suspended, tokens cannot be distributed among investors.\r\n        // ICO can be resumed to `Active state`.\r\n        // ICO parameters (end date, hard/low caps) may changed.\r\n        Suspended,\r\n        // ICO is termnated by owner, ICO cannot be resumed.\r\n        Terminated,\r\n        // ICO goals are not reached,\r\n        // ICO terminated and cannot be resumed.\r\n        NotCompleted,\r\n        // ICO completed, ICO goals reached successfully,\r\n        // ICO terminated and cannot be resumed.\r\n        Completed\r\n    }\r\n\r\n    /// @dev Token which controlled by this ICO\r\n    BaseICOToken public token;\r\n\r\n    /// @dev Current ICO state.\r\n    State public state;\r\n\r\n    /// @dev ICO start date seconds since epoch.\r\n    uint public startAt;\r\n\r\n    /// @dev ICO end date seconds since epoch.\r\n    uint public endAt;\r\n\r\n    /// @dev Minimal amount of investments in wei needed for successful ICO\r\n    uint public lowCapWei;\r\n\r\n    /// @dev Maximal amount of investments in wei for this ICO.\r\n    /// If reached ICO will be in `Completed` state.\r\n    uint public hardCapWei;\r\n\r\n    /// @dev Minimal amount of investments in wei per investor.\r\n    uint public lowCapTxWei;\r\n\r\n    /// @dev Maximal amount of investments in wei per investor.\r\n    uint public hardCapTxWei;\r\n\r\n    /// @dev Number of investments collected by this ICO\r\n    uint public collectedWei;\r\n\r\n    /// @dev Number of sold tokens by this ICO\r\n    uint public tokensSold;\r\n\r\n    /// @dev Team wallet used to collect funds\r\n    address public teamWallet;\r\n\r\n    // ICO state transition events\r\n    event ICOStarted(uint indexed endAt, uint lowCapWei, uint hardCapWei, uint lowCapTxWei, uint hardCapTxWei);\r\n    event ICOResumed(uint indexed endAt, uint lowCapWei, uint hardCapWei, uint lowCapTxWei, uint hardCapTxWei);\r\n    event ICOSuspended();\r\n    event ICOTerminated();\r\n    event ICONotCompleted();\r\n    event ICOCompleted(uint collectedWei);\r\n    event ICOInvestment(address indexed from, uint investedWei, uint tokens, uint8 bonusPct);\r\n\r\n    function BaseICO(address icoToken_,\r\n                     address teamWallet_,\r\n                     uint lowCapWei_,\r\n                     uint hardCapWei_,\r\n                     uint lowCapTxWei_,\r\n                     uint hardCapTxWei_) public {\r\n        require(icoToken_ != address(0) && teamWallet_ != address(0));\r\n        token = BaseICOToken(icoToken_);\r\n        teamWallet = teamWallet_;\r\n        state = State.Inactive;\r\n        lowCapWei = lowCapWei_;\r\n        hardCapWei = hardCapWei_;\r\n        lowCapTxWei = lowCapTxWei_;\r\n        hardCapTxWei = hardCapTxWei_;\r\n    }\r\n\r\n    modifier isSuspended() {\r\n        require(state == State.Suspended);\r\n        _;\r\n    }\r\n\r\n    modifier isActive() {\r\n        require(state == State.Active);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Trigger start of ICO.\r\n     * @param endAt_ ICO end date, seconds since epoch.\r\n     */\r\n    function start(uint endAt_) public onlyOwner {\r\n        require(endAt_ > block.timestamp && state == State.Inactive);\r\n        endAt = endAt_;\r\n        startAt = block.timestamp;\r\n        state = State.Active;\r\n        ICOStarted(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);\r\n    }\r\n\r\n    /**\r\n     * @dev Suspend this ICO.\r\n     * ICO can be activated later by calling `resume()` function.\r\n     * In suspend state, ICO owner can change basic ICO paraneter using `tune()` function,\r\n     * tokens cannot be distributed among investors.\r\n     */\r\n    function suspend() public onlyOwner isActive {\r\n        state = State.Suspended;\r\n        ICOSuspended();\r\n    }\r\n\r\n    /**\r\n     * @dev Terminate the ICO.\r\n     * ICO goals are not reached, ICO terminated and cannot be resumed.\r\n     */\r\n    function terminate() public onlyOwner {\r\n        require(state != State.Terminated &&\r\n        state != State.NotCompleted &&\r\n        state != State.Completed);\r\n        state = State.Terminated;\r\n        ICOTerminated();\r\n    }\r\n\r\n    /**\r\n     * @dev Change basic ICO parameters. Can be done only during `Suspended` state.\r\n     * Any provided parameter is used only if it is not zero.\r\n     * @param endAt_ ICO end date seconds since epoch. Used if it is not zero.\r\n     * @param lowCapWei_ ICO low capacity. Used if it is not zero.\r\n     * @param hardCapWei_ ICO hard capacity. Used if it is not zero.\r\n     * @param lowCapTxWei_ Min limit for ICO per transaction\r\n     * @param hardCapTxWei_ Hard limit for ICO per transaction\r\n     */\r\n    function tune(uint endAt_, uint lowCapWei_, uint hardCapWei_, uint lowCapTxWei_, uint hardCapTxWei_) public onlyOwner isSuspended {\r\n        if (endAt_ > block.timestamp) {\r\n            endAt = endAt_;\r\n        }\r\n        if (lowCapWei_ > 0) {\r\n            lowCapWei = lowCapWei_;\r\n        }\r\n        if (hardCapWei_ > 0) {\r\n            hardCapWei = hardCapWei_;\r\n        }\r\n        if (lowCapTxWei_ > 0) {\r\n            lowCapTxWei = lowCapTxWei_;\r\n        }\r\n        if (hardCapTxWei_ > 0) {\r\n            hardCapTxWei = hardCapTxWei_;\r\n        }\r\n        require(lowCapWei <= hardCapWei && lowCapTxWei <= hardCapTxWei);\r\n        touch();\r\n    }\r\n\r\n    /**\r\n     * @dev Resume a previously suspended ICO.\r\n     */\r\n    function resume() public onlyOwner isSuspended {\r\n        state = State.Active;\r\n        ICOResumed(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);\r\n        touch();\r\n    }\r\n\r\n    /**\r\n     * @dev Recalculate ICO state based on current block time.\r\n     * Should be called periodically by ICO owner.\r\n     */\r\n    function touch() public;\r\n\r\n    /**\r\n     * @dev Buy tokens\r\n     */\r\n    function buyTokens() public payable;\r\n\r\n    /**\r\n     * @dev Send ether to the fund collection wallet\r\n     */\r\n    function forwardFunds() internal {\r\n        teamWallet.transfer(msg.value);\r\n    }\r\n}\r\n\r\n// File: contracts/flavours/Whitelisted.sol\r\n\r\ncontract Whitelisted is Ownable {\r\n\r\n    /// @dev True if whitelist enabled\r\n    bool public whitelistEnabled = true;\r\n\r\n    /// @dev ICO whitelist\r\n    mapping(address => bool) public whitelist;\r\n\r\n    event ICOWhitelisted(address indexed addr);\r\n    event ICOBlacklisted(address indexed addr);\r\n\r\n    modifier onlyWhitelisted {\r\n        require(!whitelistEnabled || whitelist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * Add address to ICO whitelist\r\n    * @param address_ Investor address\r\n    */\r\n    function whitelist(address address_) external onlyOwner {\r\n        whitelist[address_] = true;\r\n        ICOWhitelisted(address_);\r\n    }\r\n\r\n    /**\r\n     * Remove address from ICO whitelist\r\n     * @param address_ Investor address\r\n     */\r\n    function blacklist(address address_) external onlyOwner {\r\n        delete whitelist[address_];\r\n        ICOBlacklisted(address_);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if given address in ICO whitelist\r\n     */\r\n    function whitelisted(address address_) public view returns (bool) {\r\n        if (whitelistEnabled) {\r\n            return whitelist[address_];\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Enable whitelisting\r\n     */\r\n    function enableWhitelist() public onlyOwner {\r\n        whitelistEnabled = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Disable whitelisting\r\n     */\r\n    function disableWhitelist() public onlyOwner {\r\n        whitelistEnabled = false;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/DWBTPreICO.sol\r\n\r\n/**\r\n * @title DWBT tokens Pre-ICO contract.\r\n */\r\ncontract DWBTPreICO is BaseICO, Whitelisted {\r\n    using SafeMath for uint;\r\n\r\n    /// @dev 18 decimals for token\r\n    uint internal constant ONE_TOKEN = 1e18;\r\n\r\n    /// @dev 1e18 WEI == 1ETH == 10000 tokens\r\n    uint public constant ETH_TOKEN_EXCHANGE_RATIO = 10000;\r\n\r\n    /// @dev 50% bonus for pre-ICO\r\n    uint8 internal constant BONUS = 50; // 50%\r\n\r\n    /// @dev investors count\r\n    uint public investorCount;\r\n\r\n    // @dev investments distribution\r\n    mapping (address => uint) public investments;\r\n\r\n    function DWBTPreICO(address icoToken_,\r\n                       address teamWallet_,\r\n                       uint lowCapWei_,\r\n                       uint hardCapWei_,\r\n                       uint lowCapTxWei_,\r\n                       uint hardCapTxWei_) public BaseICO(icoToken_, teamWallet_, lowCapWei_, hardCapWei_, lowCapTxWei_, hardCapTxWei_) {\r\n    }\r\n\r\n    /**\r\n     * @dev Recalculate ICO state based on current block time.\r\n     * Should be called periodically by ICO owner.\r\n     */\r\n    function touch() public {\r\n        if (state != State.Active && state != State.Suspended) {\r\n            return;\r\n        }\r\n        if (collectedWei >= hardCapWei) {\r\n            state = State.Completed;\r\n            endAt = block.timestamp;\r\n            ICOCompleted(collectedWei);\r\n        } else if (block.timestamp >= endAt) {\r\n            if (collectedWei < lowCapWei) {\r\n                state = State.NotCompleted;\r\n                ICONotCompleted();\r\n            } else {\r\n                state = State.Completed;\r\n                ICOCompleted(collectedWei);\r\n            }\r\n        }\r\n    }\r\n\r\n    function buyTokens() public onlyWhitelisted payable {\r\n        require(state == State.Active &&\r\n                block.timestamp <= endAt &&\r\n                msg.value >= lowCapTxWei &&\r\n                msg.value <= hardCapTxWei &&\r\n                collectedWei + msg.value <= hardCapWei);\r\n        uint amountWei = msg.value;\r\n        uint iwei = amountWei.mul(100 + BONUS).div(100);\r\n        uint itokens = iwei * ETH_TOKEN_EXCHANGE_RATIO;\r\n        // Transfer tokens to investor\r\n        token.icoInvestment(msg.sender, itokens);\r\n        collectedWei = collectedWei.add(amountWei);\r\n        tokensSold = tokensSold.add(itokens);\r\n\r\n        if (investments[msg.sender] == 0) {\r\n            // new investor\r\n            investorCount++;\r\n\r\n        }\r\n        investments[msg.sender] = investments[msg.sender].add(amountWei);\r\n\r\n        ICOInvestment(msg.sender, amountWei, itokens, BONUS);\r\n\r\n        forwardFunds();\r\n        touch();\r\n    }\r\n\r\n    function getInvestments(address investor) public view returns (uint) {\r\n        return investments[investor];\r\n    }\r\n\r\n    function getCurrentBonus() public pure returns (uint8) {\r\n        return BONUS;\r\n    }\r\n\r\n    /**\r\n     * Accept direct payments\r\n     */\r\n    function() external payable {\r\n        buyTokens();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_TOKEN_EXCHANGE_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapTxWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowCapTxWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endAt_\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"touch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endAt_\",\"type\":\"uint256\"},{\"name\":\"lowCapWei_\",\"type\":\"uint256\"},{\"name\":\"hardCapWei_\",\"type\":\"uint256\"},{\"name\":\"lowCapTxWei_\",\"type\":\"uint256\"},{\"name\":\"hardCapTxWei_\",\"type\":\"uint256\"}],\"name\":\"tune\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"suspend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowCapWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"icoToken_\",\"type\":\"address\"},{\"name\":\"teamWallet_\",\"type\":\"address\"},{\"name\":\"lowCapWei_\",\"type\":\"uint256\"},{\"name\":\"hardCapWei_\",\"type\":\"uint256\"},{\"name\":\"lowCapTxWei_\",\"type\":\"uint256\"},{\"name\":\"hardCapTxWei_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ICOWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ICOBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"endAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lowCapWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lowCapTxWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapTxWei\",\"type\":\"uint256\"}],\"name\":\"ICOStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"endAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lowCapWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lowCapTxWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapTxWei\",\"type\":\"uint256\"}],\"name\":\"ICOResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICOSuspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICOTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICONotCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"collectedWei\",\"type\":\"uint256\"}],\"name\":\"ICOCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"investedWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusPct\",\"type\":\"uint8\"}],\"name\":\"ICOInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DWBTPreICO","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"00000000000000000000000051c7706ca1088af318a88ed493bf48b540c5c03b00000000000000000000000077522902be6b28d6cc201584b6f37ad9882f8775000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065a4da25d3016c00000000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000065a4da25d3016c00000","Library":"","SwarmSource":"bzzr://bf9bd031c2e15225c7adbb854087bbbfb31a522c5adcfb9169f1d67e58df2f7f"}]}