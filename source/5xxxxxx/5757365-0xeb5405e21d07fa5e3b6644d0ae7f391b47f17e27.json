{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() public view returns (string _name);\r\n  function symbol() public view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is ERC721Basic {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) internal tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner to number of owned token\r\n  mapping (address => uint256) internal ownedTokensCount;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  /**\r\n   * @dev Guarantees msg.sender is owner of the given token\r\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n   */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n   * @param _tokenId uint256 ID of the token to validate\r\n   */\r\n  modifier canTransfer(uint256 _tokenId) {\r\n    require(isApprovedOrOwner(msg.sender, _tokenId));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokensCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param _tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param _tokenId uint256 ID of the token to query the existance of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address owner = tokenOwner[_tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * @dev The zero address indicates there is no approved address.\r\n   * @dev There can only be one approved address per token at a given time.\r\n   * @dev Can only be called by the token owner or an approved operator.\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      emit Approval(owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for a the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param _to operator address to set the approval\r\n   * @param _approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address _to, bool _approved) public {\r\n    require(_to != msg.sender);\r\n    operatorApprovals[msg.sender][_to] = _approved;\r\n    emit ApprovalForAll(msg.sender, _to, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeTokenFrom(_from, _tokenId);\r\n    addTokenTo(_to, _tokenId);\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes data to send along with a safe transfer check\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the given spender can transfer a given token ID\r\n   * @param _spender address of the spender to query\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @return bool whether the msg.sender is approved for the given token ID,\r\n   *  is an operator of the owner, or is the owner of the token\r\n   */\r\n  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n    address owner = ownerOf(_tokenId);\r\n    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to The address that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addTokenTo(_to, _tokenId);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    clearApproval(_owner, _tokenId);\r\n    removeTokenFrom(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to clear current approval of a given token ID\r\n   * @dev Reverts if the given address is not indeed the owner of the token\r\n   * @param _owner owner of the token\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    if (tokenApprovals[_tokenId] != address(0)) {\r\n      tokenApprovals[_tokenId] = address(0);\r\n      emit Approval(_owner, address(0), _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _from);\r\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n    tokenOwner[_tokenId] = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * @dev The call is not executed if the target address is not a contract\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _to target address that will receive the tokens\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\r\n    return (retval == ERC721_RECEIVED);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Token is ERC721, ERC721BasicToken {\r\n  // Token name\r\n  string internal name_;\r\n\r\n  // Token symbol\r\n  string internal symbol_;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping (address => uint256[]) internal ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n  // Array with all token ids, used for enumeration\r\n  uint256[] internal allTokens;\r\n\r\n  // Mapping from token id to position in the allTokens array\r\n  mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n  // Optional mapping for token URIs\r\n  mapping(uint256 => string) internal tokenURIs;\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  function ERC721Token(string _name, string _symbol) public {\r\n    name_ = _name;\r\n    symbol_ = _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token name\r\n   * @return string representing the token name\r\n   */\r\n  function name() public view returns (string) {\r\n    return name_;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token symbol\r\n   * @return string representing the token symbol\r\n   */\r\n  function symbol() public view returns (string) {\r\n    return symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an URI for a given token ID\r\n   * @dev Throws if the token ID does not exist. May return an empty string.\r\n   * @param _tokenId uint256 ID of the token to query\r\n   */\r\n  function tokenURI(uint256 _tokenId) public view returns (string) {\r\n    require(exists(_tokenId));\r\n    return tokenURIs[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n   * @param _owner address owning the tokens list to be accessed\r\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n   */\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n    require(_index < balanceOf(_owner));\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total amount of tokens stored by the contract\r\n   * @return uint256 representing the total amount of tokens\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of all the tokens in this contract\r\n   * @dev Reverts if the index is greater or equal to the total number of tokens\r\n   * @param _index uint256 representing the index to be accessed of the tokens list\r\n   * @return uint256 token ID at the given index of the tokens list\r\n   */\r\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n    require(_index < totalSupply());\r\n    return allTokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to set the token URI for a given token\r\n   * @dev Reverts if the token ID does not exist\r\n   * @param _tokenId uint256 ID of the token to set its URI\r\n   * @param _uri string URI to assign\r\n   */\r\n  function _setTokenURI(uint256 _tokenId, string _uri) internal {\r\n    require(exists(_tokenId));\r\n    tokenURIs[_tokenId] = _uri;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    super.addTokenTo(_to, _tokenId);\r\n    uint256 length = ownedTokens[_to].length;\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    super.removeTokenFrom(_from, _tokenId);\r\n\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to address the beneficiary that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    super._mint(_to, _tokenId);\r\n\r\n    allTokensIndex[_tokenId] = allTokens.length;\r\n    allTokens.push(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _owner owner of the token to burn\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    super._burn(_owner, _tokenId);\r\n\r\n    // Clear metadata (if any)\r\n    if (bytes(tokenURIs[_tokenId]).length != 0) {\r\n      delete tokenURIs[_tokenId];\r\n    }\r\n\r\n    // Reorg all tokens array\r\n    uint256 tokenIndex = allTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = allTokens.length.sub(1);\r\n    uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n    allTokens[tokenIndex] = lastToken;\r\n    allTokens[lastTokenIndex] = 0;\r\n\r\n    allTokens.length--;\r\n    allTokensIndex[_tokenId] = 0;\r\n    allTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title The contract that manages all the players that appear in our game.\r\n/// @author The CryptoStrikers Team\r\ncontract StrikersPlayerList is Ownable {\r\n  // We only use playerIds in StrikersChecklist.sol (to\r\n  // indicate which player features on instances of a\r\n  // given ChecklistItem), and nowhere else in the app.\r\n  // While it's not explictly necessary for any of our\r\n  // contracts to know that playerId 0 corresponds to\r\n  // Lionel Messi, we think that it's nice to have\r\n  // a canonical source of truth for who the playerIds\r\n  // actually refer to. Storing strings (player names)\r\n  // is expensive, so we just use Events to prove that,\r\n  // at some point, we said a playerId represents a given person.\r\n\r\n  /// @dev The event we fire when we add a player.\r\n  event PlayerAdded(uint8 indexed id, string name);\r\n\r\n  /// @dev How many players we've added so far\r\n  ///   (max 255, though we don't plan on getting close)\r\n  uint8 public playerCount;\r\n\r\n  /// @dev Here we add the players we are launching with on Day 1.\r\n  ///   Players are loosely ranked by things like FIFA ratings,\r\n  ///   number of Instagram followers, and opinions of CryptoStrikers\r\n  ///   team members. Feel free to yell at us on Twitter.\r\n  constructor() public {\r\n    addPlayer(\"Lionel Messi\"); // 0\r\n    addPlayer(\"Cristiano Ronaldo\"); // 1\r\n    addPlayer(\"Neymar\"); // 2\r\n    addPlayer(\"Mohamed Salah\"); // 3\r\n    addPlayer(\"Robert Lewandowski\"); // 4\r\n    addPlayer(\"Kevin De Bruyne\"); // 5\r\n    addPlayer(\"Luka Modrić\"); // 6\r\n    addPlayer(\"Eden Hazard\"); // 7\r\n    addPlayer(\"Sergio Ramos\"); // 8\r\n    addPlayer(\"Toni Kroos\"); // 9\r\n    addPlayer(\"Luis Suárez\"); // 10\r\n    addPlayer(\"Harry Kane\"); // 11\r\n    addPlayer(\"Sergio Agüero\"); // 12\r\n    addPlayer(\"Kylian Mbappé\"); // 13\r\n    addPlayer(\"Gonzalo Higuaín\"); // 14\r\n    addPlayer(\"David de Gea\"); // 15\r\n    addPlayer(\"Antoine Griezmann\"); // 16\r\n    addPlayer(\"N'Golo Kanté\"); // 17\r\n    addPlayer(\"Edinson Cavani\"); // 18\r\n    addPlayer(\"Paul Pogba\"); // 19\r\n    addPlayer(\"Isco\"); // 20\r\n    addPlayer(\"Marcelo\"); // 21\r\n    addPlayer(\"Manuel Neuer\"); // 22\r\n    addPlayer(\"Dries Mertens\"); // 23\r\n    addPlayer(\"James Rodríguez\"); // 24\r\n    addPlayer(\"Paulo Dybala\"); // 25\r\n    addPlayer(\"Christian Eriksen\"); // 26\r\n    addPlayer(\"David Silva\"); // 27\r\n    addPlayer(\"Gabriel Jesus\"); // 28\r\n    addPlayer(\"Thiago\"); // 29\r\n    addPlayer(\"Thibaut Courtois\"); // 30\r\n    addPlayer(\"Philippe Coutinho\"); // 31\r\n    addPlayer(\"Andrés Iniesta\"); // 32\r\n    addPlayer(\"Casemiro\"); // 33\r\n    addPlayer(\"Romelu Lukaku\"); // 34\r\n    addPlayer(\"Gerard Piqué\"); // 35\r\n    addPlayer(\"Mats Hummels\"); // 36\r\n    addPlayer(\"Diego Godín\"); // 37\r\n    addPlayer(\"Mesut Özil\"); // 38\r\n    addPlayer(\"Son Heung-min\"); // 39\r\n    addPlayer(\"Raheem Sterling\"); // 40\r\n    addPlayer(\"Hugo Lloris\"); // 41\r\n    addPlayer(\"Radamel Falcao\"); // 42\r\n    addPlayer(\"Ivan Rakitić\"); // 43\r\n    addPlayer(\"Leroy Sané\"); // 44\r\n    addPlayer(\"Roberto Firmino\"); // 45\r\n    addPlayer(\"Sadio Mané\"); // 46\r\n    addPlayer(\"Thomas Müller\"); // 47\r\n    addPlayer(\"Dele Alli\"); // 48\r\n    addPlayer(\"Keylor Navas\"); // 49\r\n    addPlayer(\"Thiago Silva\"); // 50\r\n    addPlayer(\"Raphaël Varane\"); // 51\r\n    addPlayer(\"Ángel Di María\"); // 52\r\n    addPlayer(\"Jordi Alba\"); // 53\r\n    addPlayer(\"Medhi Benatia\"); // 54\r\n    addPlayer(\"Timo Werner\"); // 55\r\n    addPlayer(\"Gylfi Sigurðsson\"); // 56\r\n    addPlayer(\"Nemanja Matić\"); // 57\r\n    addPlayer(\"Kalidou Koulibaly\"); // 58\r\n    addPlayer(\"Bernardo Silva\"); // 59\r\n    addPlayer(\"Vincent Kompany\"); // 60\r\n    addPlayer(\"João Moutinho\"); // 61\r\n    addPlayer(\"Toby Alderweireld\"); // 62\r\n    addPlayer(\"Emil Forsberg\"); // 63\r\n    addPlayer(\"Mario Mandžukić\"); // 64\r\n    addPlayer(\"Sergej Milinković-Savić\"); // 65\r\n    addPlayer(\"Shinji Kagawa\"); // 66\r\n    addPlayer(\"Granit Xhaka\"); // 67\r\n    addPlayer(\"Andreas Christensen\"); // 68\r\n    addPlayer(\"Piotr Zieliński\"); // 69\r\n    addPlayer(\"Fyodor Smolov\"); // 70\r\n    addPlayer(\"Xherdan Shaqiri\"); // 71\r\n    addPlayer(\"Marcus Rashford\"); // 72\r\n    addPlayer(\"Javier Hernández\"); // 73\r\n    addPlayer(\"Hirving Lozano\"); // 74\r\n    addPlayer(\"Hakim Ziyech\"); // 75\r\n    addPlayer(\"Victor Moses\"); // 76\r\n    addPlayer(\"Jefferson Farfán\"); // 77\r\n    addPlayer(\"Mohamed Elneny\"); // 78\r\n    addPlayer(\"Marcus Berg\"); // 79\r\n    addPlayer(\"Guillermo Ochoa\"); // 80\r\n    addPlayer(\"Igor Akinfeev\"); // 81\r\n    addPlayer(\"Sardar Azmoun\"); // 82\r\n    addPlayer(\"Christian Cueva\"); // 83\r\n    addPlayer(\"Wahbi Khazri\"); // 84\r\n    addPlayer(\"Keisuke Honda\"); // 85\r\n    addPlayer(\"Tim Cahill\"); // 86\r\n    addPlayer(\"John Obi Mikel\"); // 87\r\n    addPlayer(\"Ki Sung-yueng\"); // 88\r\n    addPlayer(\"Bryan Ruiz\"); // 89\r\n    addPlayer(\"Maya Yoshida\"); // 90\r\n    addPlayer(\"Nawaf Al Abed\"); // 91\r\n    addPlayer(\"Lee Chung-yong\"); // 92\r\n    addPlayer(\"Gabriel Gómez\"); // 93\r\n    addPlayer(\"Naïm Sliti\"); // 94\r\n    addPlayer(\"Reza Ghoochannejhad\"); // 95\r\n    addPlayer(\"Mile Jedinak\"); // 96\r\n    addPlayer(\"Mohammad Al-Sahlawi\"); // 97\r\n    addPlayer(\"Aron Gunnarsson\"); // 98\r\n    addPlayer(\"Blas Pérez\"); // 99\r\n    addPlayer(\"Dani Alves\"); // 100\r\n    addPlayer(\"Zlatan Ibrahimović\"); // 101\r\n  }\r\n\r\n  /// @dev Fires an event, proving that we said a player corresponds to a given ID.\r\n  /// @param _name The name of the player we are adding.\r\n  function addPlayer(string _name) public onlyOwner {\r\n    require(playerCount < 255, \"You've already added the maximum amount of players.\");\r\n    emit PlayerAdded(playerCount, _name);\r\n    playerCount++;\r\n  }\r\n}\r\n\r\n\r\n/// @title The contract that manages checklist items, sets, and rarity tiers.\r\n/// @author The CryptoStrikers Team\r\ncontract StrikersChecklist is StrikersPlayerList {\r\n  // High level overview of everything going on in this contract:\r\n  //\r\n  // ChecklistItem is the parent class to Card and has 3 properties:\r\n  //  - uint8 checklistId (000 to 255)\r\n  //  - uint8 playerId (see StrikersPlayerList.sol)\r\n  //  - RarityTier tier (more info below)\r\n  //\r\n  // Two things to note: the checklistId is not explicitly stored\r\n  // on the checklistItem struct, and it's composed of two parts.\r\n  // (For the following, assume it is left padded with zeros to reach\r\n  // three digits, such that checklistId 0 becomes 000)\r\n  //  - the first digit represents the setId\r\n  //      * 0 = Originals Set\r\n  //      * 1 = Iconics Set\r\n  //      * 2 = Unreleased Set\r\n  //  - the last two digits represent its index in the appropriate set arary\r\n  //\r\n  //  For example, checklist ID 100 would represent fhe first checklist item\r\n  //  in the iconicChecklistItems array (first digit = 1 = Iconics Set, last two\r\n  //  digits = 00 = first index of array)\r\n  //\r\n  // Because checklistId is represented as a uint8 throughout the app, the highest\r\n  // value it can take is 255, which means we can't add more than 56 items to our\r\n  // Unreleased Set's unreleasedChecklistItems array (setId 2). Also, once we've initialized\r\n  // this contract, it's impossible for us to add more checklist items to the Originals\r\n  // and Iconics set -- what you see here is what you get.\r\n  //\r\n  // Simple enough right?\r\n\r\n  /// @dev We initialize this contract with so much data that we have\r\n  ///   to stage it in 4 different steps, ~33 checklist items at a time.\r\n  enum DeployStep {\r\n    WaitingForStepOne,\r\n    WaitingForStepTwo,\r\n    WaitingForStepThree,\r\n    WaitingForStepFour,\r\n    DoneInitialDeploy\r\n  }\r\n\r\n  /// @dev Enum containing all our rarity tiers, just because\r\n  ///   it's cleaner dealing with these values than with uint8s.\r\n  enum RarityTier {\r\n    IconicReferral,\r\n    IconicInsert,\r\n    Diamond,\r\n    Gold,\r\n    Silver,\r\n    Bronze\r\n  }\r\n\r\n  /// @dev A lookup table indicating how limited the cards\r\n  ///   in each tier are. If this value is 0, it means\r\n  ///   that cards of this rarity tier are unlimited,\r\n  ///   which is only the case for the 8 Iconics cards\r\n  ///   we give away as part of our referral program.\r\n  uint16[] public tierLimits = [\r\n    0,    // Iconic - Referral Bonus (uncapped)\r\n    100,  // Iconic Inserts (\"Card of the Day\")\r\n    1000, // Diamond\r\n    1664, // Gold\r\n    3328, // Silver\r\n    4352  // Bronze\r\n  ];\r\n\r\n  /// @dev ChecklistItem is essentially the parent class to Card.\r\n  ///   It represents a given superclass of cards (eg Originals Messi),\r\n  ///   and then each Card is an instance of this ChecklistItem, with\r\n  ///   its own serial number, mint date, etc.\r\n  struct ChecklistItem {\r\n    uint8 playerId;\r\n    RarityTier tier;\r\n  }\r\n\r\n  /// @dev The deploy step we're at. Defaults to WaitingForStepOne.\r\n  DeployStep public deployStep;\r\n\r\n  /// @dev Array containing all the Originals checklist items (000 - 099)\r\n  ChecklistItem[] public originalChecklistItems;\r\n\r\n  /// @dev Array containing all the Iconics checklist items (100 - 131)\r\n  ChecklistItem[] public iconicChecklistItems;\r\n\r\n  /// @dev Array containing all the unreleased checklist items (200 - 255 max)\r\n  ChecklistItem[] public unreleasedChecklistItems;\r\n\r\n  /// @dev Internal function to add a checklist item to the Originals set.\r\n  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\r\n  /// @param _tier This checklist item's rarity tier. (see Rarity Tier enum and corresponding tierLimits)\r\n  function _addOriginalChecklistItem(uint8 _playerId, RarityTier _tier) internal {\r\n    originalChecklistItems.push(ChecklistItem({\r\n      playerId: _playerId,\r\n      tier: _tier\r\n    }));\r\n  }\r\n\r\n  /// @dev Internal function to add a checklist item to the Iconics set.\r\n  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\r\n  /// @param _tier This checklist item's rarity tier. (see Rarity Tier enum and corresponding tierLimits)\r\n  function _addIconicChecklistItem(uint8 _playerId, RarityTier _tier) internal {\r\n    iconicChecklistItems.push(ChecklistItem({\r\n      playerId: _playerId,\r\n      tier: _tier\r\n    }));\r\n  }\r\n\r\n  /// @dev External function to add a checklist item to our mystery set.\r\n  ///   Must have completed initial deploy, and can't add more than 56 items (because checklistId is a uint8).\r\n  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\r\n  /// @param _tier This checklist item's rarity tier. (see Rarity Tier enum and corresponding tierLimits)\r\n  function addUnreleasedChecklistItem(uint8 _playerId, RarityTier _tier) external onlyOwner {\r\n    require(deployStep == DeployStep.DoneInitialDeploy, \"Finish deploying the Originals and Iconics sets first.\");\r\n    require(unreleasedCount() < 56, \"You can't add any more checklist items.\");\r\n    require(_playerId < playerCount, \"This player doesn't exist in our player list.\");\r\n    unreleasedChecklistItems.push(ChecklistItem({\r\n      playerId: _playerId,\r\n      tier: _tier\r\n    }));\r\n  }\r\n\r\n  /// @dev Returns how many Original checklist items we've added.\r\n  function originalsCount() external view returns (uint256) {\r\n    return originalChecklistItems.length;\r\n  }\r\n\r\n  /// @dev Returns how many Iconic checklist items we've added.\r\n  function iconicsCount() public view returns (uint256) {\r\n    return iconicChecklistItems.length;\r\n  }\r\n\r\n  /// @dev Returns how many Unreleased checklist items we've added.\r\n  function unreleasedCount() public view returns (uint256) {\r\n    return unreleasedChecklistItems.length;\r\n  }\r\n\r\n  // In the next four functions, we initialize this contract with our\r\n  // 132 initial checklist items (100 Originals, 32 Iconics). Because\r\n  // of how much data we need to store, it has to be broken up into\r\n  // four different function calls, which need to be called in sequence.\r\n  // The ordering of the checklist items we add determines their\r\n  // checklist ID, which is left-padded in our frontend to be a\r\n  // 3-digit identifier where the first digit is the setId and the last\r\n  // 2 digits represents the checklist items index in the appropriate ___ChecklistItems array.\r\n  // For example, Originals Messi is the first item for set ID 0, and this\r\n  // is displayed as #000 throughout the app. Our Card struct declare its\r\n  // checklistId property as uint8, so we have\r\n  // to be mindful that we can only have 256 total checklist items.\r\n\r\n  /// @dev Deploys Originals #000 through #032.\r\n  function deployStepOne() external onlyOwner {\r\n    require(deployStep == DeployStep.WaitingForStepOne, \"You're not following the steps in order...\");\r\n\r\n    /* ORIGINALS - DIAMOND */\r\n    _addOriginalChecklistItem(0, RarityTier.Diamond); // 000 Messi\r\n    _addOriginalChecklistItem(1, RarityTier.Diamond); // 001 Ronaldo\r\n    _addOriginalChecklistItem(2, RarityTier.Diamond); // 002 Neymar\r\n    _addOriginalChecklistItem(3, RarityTier.Diamond); // 003 Salah\r\n\r\n    /* ORIGINALS - GOLD */\r\n    _addOriginalChecklistItem(4, RarityTier.Gold); // 004 Lewandowski\r\n    _addOriginalChecklistItem(5, RarityTier.Gold); // 005 De Bruyne\r\n    _addOriginalChecklistItem(6, RarityTier.Gold); // 006 Modrić\r\n    _addOriginalChecklistItem(7, RarityTier.Gold); // 007 Hazard\r\n    _addOriginalChecklistItem(8, RarityTier.Gold); // 008 Ramos\r\n    _addOriginalChecklistItem(9, RarityTier.Gold); // 009 Kroos\r\n    _addOriginalChecklistItem(10, RarityTier.Gold); // 010 Suárez\r\n    _addOriginalChecklistItem(11, RarityTier.Gold); // 011 Kane\r\n    _addOriginalChecklistItem(12, RarityTier.Gold); // 012 Agüero\r\n    _addOriginalChecklistItem(13, RarityTier.Gold); // 013 Mbappé\r\n    _addOriginalChecklistItem(14, RarityTier.Gold); // 014 Higuaín\r\n    _addOriginalChecklistItem(15, RarityTier.Gold); // 015 de Gea\r\n    _addOriginalChecklistItem(16, RarityTier.Gold); // 016 Griezmann\r\n    _addOriginalChecklistItem(17, RarityTier.Gold); // 017 Kanté\r\n    _addOriginalChecklistItem(18, RarityTier.Gold); // 018 Cavani\r\n    _addOriginalChecklistItem(19, RarityTier.Gold); // 019 Pogba\r\n\r\n    /* ORIGINALS - SILVER (020 to 032) */\r\n    _addOriginalChecklistItem(20, RarityTier.Silver); // 020 Isco\r\n    _addOriginalChecklistItem(21, RarityTier.Silver); // 021 Marcelo\r\n    _addOriginalChecklistItem(22, RarityTier.Silver); // 022 Neuer\r\n    _addOriginalChecklistItem(23, RarityTier.Silver); // 023 Mertens\r\n    _addOriginalChecklistItem(24, RarityTier.Silver); // 024 James\r\n    _addOriginalChecklistItem(25, RarityTier.Silver); // 025 Dybala\r\n    _addOriginalChecklistItem(26, RarityTier.Silver); // 026 Eriksen\r\n    _addOriginalChecklistItem(27, RarityTier.Silver); // 027 David Silva\r\n    _addOriginalChecklistItem(28, RarityTier.Silver); // 028 Gabriel Jesus\r\n    _addOriginalChecklistItem(29, RarityTier.Silver); // 029 Thiago\r\n    _addOriginalChecklistItem(30, RarityTier.Silver); // 030 Courtois\r\n    _addOriginalChecklistItem(31, RarityTier.Silver); // 031 Coutinho\r\n    _addOriginalChecklistItem(32, RarityTier.Silver); // 032 Iniesta\r\n\r\n    // Move to the next deploy step.\r\n    deployStep = DeployStep.WaitingForStepTwo;\r\n  }\r\n\r\n  /// @dev Deploys Originals #033 through #065.\r\n  function deployStepTwo() external onlyOwner {\r\n    require(deployStep == DeployStep.WaitingForStepTwo, \"You're not following the steps in order...\");\r\n\r\n    /* ORIGINALS - SILVER (033 to 049) */\r\n    _addOriginalChecklistItem(33, RarityTier.Silver); // 033 Casemiro\r\n    _addOriginalChecklistItem(34, RarityTier.Silver); // 034 Lukaku\r\n    _addOriginalChecklistItem(35, RarityTier.Silver); // 035 Piqué\r\n    _addOriginalChecklistItem(36, RarityTier.Silver); // 036 Hummels\r\n    _addOriginalChecklistItem(37, RarityTier.Silver); // 037 Godín\r\n    _addOriginalChecklistItem(38, RarityTier.Silver); // 038 Özil\r\n    _addOriginalChecklistItem(39, RarityTier.Silver); // 039 Son\r\n    _addOriginalChecklistItem(40, RarityTier.Silver); // 040 Sterling\r\n    _addOriginalChecklistItem(41, RarityTier.Silver); // 041 Lloris\r\n    _addOriginalChecklistItem(42, RarityTier.Silver); // 042 Falcao\r\n    _addOriginalChecklistItem(43, RarityTier.Silver); // 043 Rakitić\r\n    _addOriginalChecklistItem(44, RarityTier.Silver); // 044 Sané\r\n    _addOriginalChecklistItem(45, RarityTier.Silver); // 045 Firmino\r\n    _addOriginalChecklistItem(46, RarityTier.Silver); // 046 Mané\r\n    _addOriginalChecklistItem(47, RarityTier.Silver); // 047 Müller\r\n    _addOriginalChecklistItem(48, RarityTier.Silver); // 048 Alli\r\n    _addOriginalChecklistItem(49, RarityTier.Silver); // 049 Navas\r\n\r\n    /* ORIGINALS - BRONZE (050 to 065) */\r\n    _addOriginalChecklistItem(50, RarityTier.Bronze); // 050 Thiago Silva\r\n    _addOriginalChecklistItem(51, RarityTier.Bronze); // 051 Varane\r\n    _addOriginalChecklistItem(52, RarityTier.Bronze); // 052 Di María\r\n    _addOriginalChecklistItem(53, RarityTier.Bronze); // 053 Alba\r\n    _addOriginalChecklistItem(54, RarityTier.Bronze); // 054 Benatia\r\n    _addOriginalChecklistItem(55, RarityTier.Bronze); // 055 Werner\r\n    _addOriginalChecklistItem(56, RarityTier.Bronze); // 056 Sigurðsson\r\n    _addOriginalChecklistItem(57, RarityTier.Bronze); // 057 Matić\r\n    _addOriginalChecklistItem(58, RarityTier.Bronze); // 058 Koulibaly\r\n    _addOriginalChecklistItem(59, RarityTier.Bronze); // 059 Bernardo Silva\r\n    _addOriginalChecklistItem(60, RarityTier.Bronze); // 060 Kompany\r\n    _addOriginalChecklistItem(61, RarityTier.Bronze); // 061 Moutinho\r\n    _addOriginalChecklistItem(62, RarityTier.Bronze); // 062 Alderweireld\r\n    _addOriginalChecklistItem(63, RarityTier.Bronze); // 063 Forsberg\r\n    _addOriginalChecklistItem(64, RarityTier.Bronze); // 064 Mandžukić\r\n    _addOriginalChecklistItem(65, RarityTier.Bronze); // 065 Milinković-Savić\r\n\r\n    // Move to the next deploy step.\r\n    deployStep = DeployStep.WaitingForStepThree;\r\n  }\r\n\r\n  /// @dev Deploys Originals #066 through #099.\r\n  function deployStepThree() external onlyOwner {\r\n    require(deployStep == DeployStep.WaitingForStepThree, \"You're not following the steps in order...\");\r\n\r\n    /* ORIGINALS - BRONZE (066 to 099) */\r\n    _addOriginalChecklistItem(66, RarityTier.Bronze); // 066 Kagawa\r\n    _addOriginalChecklistItem(67, RarityTier.Bronze); // 067 Xhaka\r\n    _addOriginalChecklistItem(68, RarityTier.Bronze); // 068 Christensen\r\n    _addOriginalChecklistItem(69, RarityTier.Bronze); // 069 Zieliński\r\n    _addOriginalChecklistItem(70, RarityTier.Bronze); // 070 Smolov\r\n    _addOriginalChecklistItem(71, RarityTier.Bronze); // 071 Shaqiri\r\n    _addOriginalChecklistItem(72, RarityTier.Bronze); // 072 Rashford\r\n    _addOriginalChecklistItem(73, RarityTier.Bronze); // 073 Hernández\r\n    _addOriginalChecklistItem(74, RarityTier.Bronze); // 074 Lozano\r\n    _addOriginalChecklistItem(75, RarityTier.Bronze); // 075 Ziyech\r\n    _addOriginalChecklistItem(76, RarityTier.Bronze); // 076 Moses\r\n    _addOriginalChecklistItem(77, RarityTier.Bronze); // 077 Farfán\r\n    _addOriginalChecklistItem(78, RarityTier.Bronze); // 078 Elneny\r\n    _addOriginalChecklistItem(79, RarityTier.Bronze); // 079 Berg\r\n    _addOriginalChecklistItem(80, RarityTier.Bronze); // 080 Ochoa\r\n    _addOriginalChecklistItem(81, RarityTier.Bronze); // 081 Akinfeev\r\n    _addOriginalChecklistItem(82, RarityTier.Bronze); // 082 Azmoun\r\n    _addOriginalChecklistItem(83, RarityTier.Bronze); // 083 Cueva\r\n    _addOriginalChecklistItem(84, RarityTier.Bronze); // 084 Khazri\r\n    _addOriginalChecklistItem(85, RarityTier.Bronze); // 085 Honda\r\n    _addOriginalChecklistItem(86, RarityTier.Bronze); // 086 Cahill\r\n    _addOriginalChecklistItem(87, RarityTier.Bronze); // 087 Mikel\r\n    _addOriginalChecklistItem(88, RarityTier.Bronze); // 088 Sung-yueng\r\n    _addOriginalChecklistItem(89, RarityTier.Bronze); // 089 Ruiz\r\n    _addOriginalChecklistItem(90, RarityTier.Bronze); // 090 Yoshida\r\n    _addOriginalChecklistItem(91, RarityTier.Bronze); // 091 Al Abed\r\n    _addOriginalChecklistItem(92, RarityTier.Bronze); // 092 Chung-yong\r\n    _addOriginalChecklistItem(93, RarityTier.Bronze); // 093 Gómez\r\n    _addOriginalChecklistItem(94, RarityTier.Bronze); // 094 Sliti\r\n    _addOriginalChecklistItem(95, RarityTier.Bronze); // 095 Ghoochannejhad\r\n    _addOriginalChecklistItem(96, RarityTier.Bronze); // 096 Jedinak\r\n    _addOriginalChecklistItem(97, RarityTier.Bronze); // 097 Al-Sahlawi\r\n    _addOriginalChecklistItem(98, RarityTier.Bronze); // 098 Gunnarsson\r\n    _addOriginalChecklistItem(99, RarityTier.Bronze); // 099 Pérez\r\n\r\n    // Move to the next deploy step.\r\n    deployStep = DeployStep.WaitingForStepFour;\r\n  }\r\n\r\n  /// @dev Deploys all Iconics and marks the deploy as complete!\r\n  function deployStepFour() external onlyOwner {\r\n    require(deployStep == DeployStep.WaitingForStepFour, \"You're not following the steps in order...\");\r\n\r\n    /* ICONICS */\r\n    _addIconicChecklistItem(0, RarityTier.IconicInsert); // 100 Messi\r\n    _addIconicChecklistItem(1, RarityTier.IconicInsert); // 101 Ronaldo\r\n    _addIconicChecklistItem(2, RarityTier.IconicInsert); // 102 Neymar\r\n    _addIconicChecklistItem(3, RarityTier.IconicInsert); // 103 Salah\r\n    _addIconicChecklistItem(4, RarityTier.IconicInsert); // 104 Lewandowski\r\n    _addIconicChecklistItem(5, RarityTier.IconicInsert); // 105 De Bruyne\r\n    _addIconicChecklistItem(6, RarityTier.IconicInsert); // 106 Modrić\r\n    _addIconicChecklistItem(7, RarityTier.IconicInsert); // 107 Hazard\r\n    _addIconicChecklistItem(8, RarityTier.IconicInsert); // 108 Ramos\r\n    _addIconicChecklistItem(9, RarityTier.IconicInsert); // 109 Kroos\r\n    _addIconicChecklistItem(10, RarityTier.IconicInsert); // 110 Suárez\r\n    _addIconicChecklistItem(11, RarityTier.IconicInsert); // 111 Kane\r\n    _addIconicChecklistItem(12, RarityTier.IconicInsert); // 112 Agüero\r\n    _addIconicChecklistItem(15, RarityTier.IconicInsert); // 113 de Gea\r\n    _addIconicChecklistItem(16, RarityTier.IconicInsert); // 114 Griezmann\r\n    _addIconicChecklistItem(17, RarityTier.IconicReferral); // 115 Kanté\r\n    _addIconicChecklistItem(18, RarityTier.IconicReferral); // 116 Cavani\r\n    _addIconicChecklistItem(19, RarityTier.IconicInsert); // 117 Pogba\r\n    _addIconicChecklistItem(21, RarityTier.IconicInsert); // 118 Marcelo\r\n    _addIconicChecklistItem(24, RarityTier.IconicInsert); // 119 James\r\n    _addIconicChecklistItem(26, RarityTier.IconicInsert); // 120 Eriksen\r\n    _addIconicChecklistItem(29, RarityTier.IconicReferral); // 121 Thiago\r\n    _addIconicChecklistItem(36, RarityTier.IconicReferral); // 122 Hummels\r\n    _addIconicChecklistItem(38, RarityTier.IconicReferral); // 123 Özil\r\n    _addIconicChecklistItem(39, RarityTier.IconicInsert); // 124 Son\r\n    _addIconicChecklistItem(46, RarityTier.IconicInsert); // 125 Mané\r\n    _addIconicChecklistItem(48, RarityTier.IconicInsert); // 126 Alli\r\n    _addIconicChecklistItem(49, RarityTier.IconicReferral); // 127 Navas\r\n    _addIconicChecklistItem(73, RarityTier.IconicInsert); // 128 Hernández\r\n    _addIconicChecklistItem(85, RarityTier.IconicInsert); // 129 Honda\r\n    _addIconicChecklistItem(100, RarityTier.IconicReferral); // 130 Alves\r\n    _addIconicChecklistItem(101, RarityTier.IconicReferral); // 131 Zlatan\r\n\r\n    // Mark the initial deploy as complete.\r\n    deployStep = DeployStep.DoneInitialDeploy;\r\n  }\r\n\r\n  /// @dev Returns the mint limit for a given checklist item, based on its tier.\r\n  /// @param _checklistId Which checklist item we need to get the limit for.\r\n  /// @return How much of this checklist item we are allowed to mint.\r\n  function limitForChecklistId(uint8 _checklistId) external view returns (uint16) {\r\n    RarityTier rarityTier;\r\n    uint8 index;\r\n    if (_checklistId < 100) { // Originals = #000 to #099\r\n      rarityTier = originalChecklistItems[_checklistId].tier;\r\n    } else if (_checklistId < 200) { // Iconics = #100 to #131\r\n      index = _checklistId - 100;\r\n      require(index < iconicsCount(), \"This Iconics checklist item doesn't exist.\");\r\n      rarityTier = iconicChecklistItems[index].tier;\r\n    } else { // Unreleased = #200 to max #255\r\n      index = _checklistId - 200;\r\n      require(index < unreleasedCount(), \"This Unreleased checklist item doesn't exist.\");\r\n      rarityTier = unreleasedChecklistItems[index].tier;\r\n    }\r\n    return tierLimits[uint8(rarityTier)];\r\n  }\r\n}\r\n\r\n\r\n/// @title Base contract for CryptoStrikers. Defines what a card is and how to mint one.\r\n/// @author The CryptoStrikers Team\r\ncontract StrikersBase is ERC721Token(\"CryptoStrikers\", \"STRK\") {\r\n\r\n  /// @dev Emit this event whenever we mint a new card (see _mintCard below)\r\n  event CardMinted(uint256 cardId);\r\n\r\n  /// @dev The struct representing the game's main object, a sports trading card.\r\n  struct Card {\r\n    // The timestamp at which this card was minted.\r\n    // With uint32 we are good until 2106, by which point we will have not minted\r\n    // a card in like, 88 years.\r\n    uint32 mintTime;\r\n\r\n    // The checklist item represented by this card. See StrikersChecklist.sol for more info.\r\n    uint8 checklistId;\r\n\r\n    // Cards for a given player have a serial number, which gets\r\n    // incremented in sequence. For example, if we mint 1000 of a card,\r\n    // the third one to be minted has serialNumber = 3 (out of 1000).\r\n    uint16 serialNumber;\r\n  }\r\n\r\n  /*** STORAGE ***/\r\n\r\n  /// @dev All the cards that have been minted, indexed by cardId.\r\n  Card[] public cards;\r\n\r\n  /// @dev Keeps track of how many cards we have minted for a given checklist item\r\n  ///   to make sure we don't go over the limit for it.\r\n  ///   NB: uint16 has a capacity of 65,535, but we are not minting more than\r\n  ///   4,352 of any given checklist item.\r\n  mapping (uint8 => uint16) public mintedCountForChecklistId;\r\n\r\n  /// @dev A reference to our checklist contract, which contains all the minting limits.\r\n  StrikersChecklist public strikersChecklist;\r\n\r\n  /*** FUNCTIONS ***/\r\n\r\n  /// @dev For a given owner, returns two arrays. The first contains the IDs of every card owned\r\n  ///   by this address. The second returns the corresponding checklist ID for each of these cards.\r\n  ///   There are a few places we need this info in the web app and short of being able to return an\r\n  ///   actual array of Cards, this is the best solution we could come up with...\r\n  function cardAndChecklistIdsForOwner(address _owner) external view returns (uint256[], uint8[]) {\r\n    uint256[] memory cardIds = ownedTokens[_owner];\r\n    uint256 cardCount = cardIds.length;\r\n    uint8[] memory checklistIds = new uint8[](cardCount);\r\n\r\n    for (uint256 i = 0; i < cardCount; i++) {\r\n      uint256 cardId = cardIds[i];\r\n      checklistIds[i] = cards[cardId].checklistId;\r\n    }\r\n\r\n    return (cardIds, checklistIds);\r\n  }\r\n\r\n  /// @dev An internal method that creates a new card and stores it.\r\n  ///  Emits both a CardMinted and a Transfer event.\r\n  /// @param _checklistId The ID of the checklistItem represented by the card (see Checklist.sol)\r\n  /// @param _owner The card's first owner!\r\n  function _mintCard(\r\n    uint8 _checklistId,\r\n    address _owner\r\n  )\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    uint16 mintLimit = strikersChecklist.limitForChecklistId(_checklistId);\r\n    require(mintLimit == 0 || mintedCountForChecklistId[_checklistId] < mintLimit, \"Can't mint any more of this card!\");\r\n    uint16 serialNumber = ++mintedCountForChecklistId[_checklistId];\r\n    Card memory newCard = Card({\r\n      mintTime: uint32(now),\r\n      checklistId: _checklistId,\r\n      serialNumber: serialNumber\r\n    });\r\n    uint256 newCardId = cards.push(newCard) - 1;\r\n    emit CardMinted(newCardId);\r\n    _mint(_owner, newCardId);\r\n    return newCardId;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n/// @title The contract that exposes minting functions to the outside world and limits who can call them.\r\n/// @author The CryptoStrikers Team\r\ncontract StrikersMinting is StrikersBase, Pausable {\r\n\r\n  /// @dev Emit this when we decide to no longer mint a given checklist ID.\r\n  event PulledFromCirculation(uint8 checklistId);\r\n\r\n  /// @dev If the value for a checklistId is true, we can no longer mint it.\r\n  mapping (uint8 => bool) public outOfCirculation;\r\n\r\n  /// @dev The address of the contract that manages the pack sale.\r\n  address public packSaleAddress;\r\n\r\n  /// @dev Only the owner can update the address of the pack sale contract.\r\n  /// @param _address The address of the new StrikersPackSale contract.\r\n  function setPackSaleAddress(address _address) external onlyOwner {\r\n    packSaleAddress = _address;\r\n  }\r\n\r\n  /// @dev Allows the contract at packSaleAddress to mint cards.\r\n  /// @param _checklistId The checklist item represented by this new card.\r\n  /// @param _owner The card's first owner!\r\n  /// @return The new card's ID.\r\n  function mintPackSaleCard(uint8 _checklistId, address _owner) external returns (uint256) {\r\n    require(msg.sender == packSaleAddress, \"Only the pack sale contract can mint here.\");\r\n    require(!outOfCirculation[_checklistId], \"Can't mint any more of this checklist item...\");\r\n    return _mintCard(_checklistId, _owner);\r\n  }\r\n\r\n  /// @dev Allows the owner to mint cards from our Unreleased Set.\r\n  /// @param _checklistId The checklist item represented by this new card. Must be >= 200.\r\n  /// @param _owner The card's first owner!\r\n  function mintUnreleasedCard(uint8 _checklistId, address _owner) external onlyOwner {\r\n    require(_checklistId >= 200, \"You can only use this to mint unreleased cards.\");\r\n    require(!outOfCirculation[_checklistId], \"Can't mint any more of this checklist item...\");\r\n    _mintCard(_checklistId, _owner);\r\n  }\r\n\r\n  /// @dev Allows the owner or the pack sale contract to prevent an Iconic or Unreleased card from ever being minted again.\r\n  /// @param _checklistId The Iconic or Unreleased card we want to remove from circulation.\r\n  function pullFromCirculation(uint8 _checklistId) external {\r\n    bool ownerOrPackSale = (msg.sender == owner) || (msg.sender == packSaleAddress);\r\n    require(ownerOrPackSale, \"Only the owner or pack sale can take checklist items out of circulation.\");\r\n    require(_checklistId >= 100, \"This function is reserved for Iconics and Unreleased sets.\");\r\n    outOfCirculation[_checklistId] = true;\r\n    emit PulledFromCirculation(_checklistId);\r\n  }\r\n}\r\n\r\n\r\n\r\n/// @title Contract where we create Standard and Premium sales and load them with the packs to sell.\r\n/// @author The CryptoStrikersTeam\r\ncontract StrikersPackFactory is Pausable {\r\n\r\n  /*** IMPORTANT ***/\r\n  // Given the imperfect nature of on-chain \"randomness\", we have found that, for this game, the best tradeoff\r\n  // is to generate the PACKS (each containing 4 random CARDS) off-chain and push them to a SALE in the smart\r\n  // contract. Users can then buy a pack, which will be drawn pseudorandomly from the packs we have pre-loaded.\r\n  // It's obviously not perfect, but we think it's a fair tradeoff and tough enough to game, as the packs array is\r\n  // constantly getting re-shuffled as other users buy packs.\r\n  //\r\n  // To save on storage, we use uint32 to represent a pack, with each of the 4 groups of 8 bits representing a checklistId (see Checklist contract).\r\n  // Given that right now we only have 132 checklist items (with the plan to maybe add a few more during the tournament),\r\n  // uint8 is fine (max uint8 is 255...)\r\n  //\r\n  // For example:\r\n  // Pack = 00011000000001100000001000010010\r\n  // Card 1 = 00011000 = checklistId 24\r\n  // Card 2 = 00000110 = checklistId 6\r\n  // Card 3 = 00000010 = checklistId 2\r\n  // Card 4 = 00010010 = checklistId 18\r\n  //\r\n  // Then, when a user buys a pack, he actually mints 4 NFTs, each corresponding to one of those checklistIds (see StrikersPackSale contract).\r\n  //\r\n  // In testing, we were only able to load ~500 packs (recall: each a uint32) per transaction before hititng the block gas limit,\r\n  // which may be less than we need for any given sale, so we load packs in batches. The Standard Sale runs all tournament long, and we\r\n  // will constantly be adding packs to it, up to the limit defined by MAX_STANDARD_SALE_PACKS. As for Premium Sales, we switch over\r\n  // to a new one every day, so while the current one is ongoing, we are able to start prepping the next one using the nextPremiumSale\r\n  // property. We can then load the 500 packs required to start this premium sale in as many transactions as we want, before pushing it\r\n  // live.\r\n\r\n  /*** EVENTS ***/\r\n\r\n  /// @dev Emit this event each time we load packs for a given sale.\r\n  event PacksLoaded(uint8 indexed saleId, uint32[] packs);\r\n\r\n  /// @dev Emit this event when the owner starts a sale.\r\n  event SaleStarted(uint8 saleId, uint256 packPrice, uint8 featuredChecklistItem);\r\n\r\n  /// @dev Emit this event when the owner changes the standard sale's packPrice.\r\n  event StandardPackPriceChanged(uint256 packPrice);\r\n\r\n  /*** CONSTANTS ***/\r\n\r\n  /// @dev Our Standard sale runs all tournament long but has a hard cap of 75,616 packs.\r\n  uint32 public constant MAX_STANDARD_SALE_PACKS = 75616;\r\n\r\n  /// @dev Each Premium sale will contain exactly 500 packs.\r\n  uint16 public constant PREMIUM_SALE_PACK_COUNT = 500;\r\n\r\n  /// @dev We can only run a total of 24 Premium sales.\r\n  uint8 public constant MAX_NUMBER_OF_PREMIUM_SALES = 24;\r\n\r\n  /*** DATA TYPES ***/\r\n\r\n  /// @dev The struct representing a PackSale from which packs are dispensed.\r\n  struct PackSale {\r\n    // A unique identifier for this sale. Based on saleCount at the time of this sale's creation.\r\n    uint8 id;\r\n\r\n    // The card of the day, if it's a Premium sale. Once that sale ends, we can never mint this card again.\r\n    uint8 featuredChecklistItem;\r\n\r\n    // The price, in wei, for 1 pack of cards. The only case where this is 0 is when the struct is null, so\r\n    // we use it as a null check.\r\n    uint256 packPrice;\r\n\r\n    // All the packs we have loaded for this sale. Max 500 for each Premium sale, and 75,616 for the Standard sale.\r\n    uint32[] packs;\r\n\r\n    // The number of packs loaded so far in this sale. Because people will be buying from the Standard sale as\r\n    // we keep loading packs in, we need this counter to make sure we don't go over MAX_STANDARD_SALE_PACKS.\r\n    uint32 packsLoaded;\r\n\r\n    // The number of packs sold so far in this sale.\r\n    uint32 packsSold;\r\n  }\r\n\r\n  /*** STORAGE ***/\r\n\r\n  /// @dev A reference to the core contract, where the cards are actually minted.\r\n  StrikersMinting public mintingContract;\r\n\r\n  /// @dev Our one and only Standard sale, which runs all tournament long.\r\n  PackSale public standardSale;\r\n\r\n  /// @dev The Premium sale that users are currently able to buy from.\r\n  PackSale public currentPremiumSale;\r\n\r\n  /// @dev We stage the next Premium sale here before we push it live with startNextPremiumSale().\r\n  PackSale public nextPremiumSale;\r\n\r\n  /// @dev How many sales we've ran so far. Max is 25 (1 Standard + 24 Premium).\r\n  uint8 public saleCount;\r\n\r\n  /*** MODIFIERS  ***/\r\n\r\n  modifier nonZeroPackPrice(uint256 _packPrice) {\r\n    require(_packPrice > 0, \"Free packs are only available through the whitelist.\");\r\n    _;\r\n  }\r\n\r\n  /*** CONSTRUCTOR ***/\r\n\r\n  constructor(uint256 _packPrice) public {\r\n    // Start contract in paused state so we have can go and load some packs in.\r\n    paused = true;\r\n    // Init Standard sale. (all properties default to 0, except packPrice, which we set here)\r\n    setStandardPackPrice(_packPrice);\r\n    saleCount++;\r\n  }\r\n\r\n  /*** SHARED FUNCTIONS (STANDARD & PREMIUM) ***/\r\n\r\n  /// @dev Internal function to push a bunch of packs to a PackSale's packs array.\r\n  /// @param _newPacks An array of 32 bit integers, each representing a shuffled pack.\r\n  /// @param _sale The PackSale we are pushing to.\r\n  function _addPacksToSale(uint32[] _newPacks, PackSale storage _sale) internal {\r\n    for (uint256 i = 0; i < _newPacks.length; i++) {\r\n      _sale.packs.push(_newPacks[i]);\r\n    }\r\n    _sale.packsLoaded += uint32(_newPacks.length);\r\n    emit PacksLoaded(_sale.id, _newPacks);\r\n  }\r\n\r\n  /*** STANDARD SALE FUNCTIONS ***/\r\n\r\n  /// @dev Load some shuffled packs into the Standard sale.\r\n  /// @param _newPacks The new packs to load.\r\n  function addPacksToStandardSale(uint32[] _newPacks) external onlyOwner {\r\n    bool tooManyPacks = standardSale.packsLoaded + _newPacks.length > MAX_STANDARD_SALE_PACKS;\r\n    require(!tooManyPacks, \"You can't add more than 75,616 packs to the Standard sale.\");\r\n    _addPacksToSale(_newPacks, standardSale);\r\n  }\r\n\r\n  /// @dev After seeding the Standard sale with a few loads of packs, kick off the sale here.\r\n  function startStandardSale() external onlyOwner {\r\n    require(standardSale.packsLoaded > 0, \"You must first load some packs into the Standard sale.\");\r\n    unpause();\r\n    emit SaleStarted(standardSale.id, standardSale.packPrice, standardSale.featuredChecklistItem);\r\n  }\r\n\r\n  /// @dev Allows us to change the Standard sale pack price while the sale is ongoing, to deal with ETH\r\n  ///   price fluctuations. Premium sale packPrice is set daily (i.e. every time we create a new Premium sale)\r\n  /// @param _packPrice The new Standard pack price, in wei.\r\n  function setStandardPackPrice(uint256 _packPrice) public onlyOwner nonZeroPackPrice(_packPrice) {\r\n    standardSale.packPrice = _packPrice;\r\n    emit StandardPackPriceChanged(_packPrice);\r\n  }\r\n\r\n  /*** PREMIUM SALE FUNCTIONS ***/\r\n\r\n  /// @dev If nextPremiumSale is null, allows us to create and start setting up the next one.\r\n  /// @param _featuredChecklistItem The card of the day, which we will take out of circulation once the sale ends.\r\n  /// @param _packPrice The price of packs for this sale, in wei. Must be greater than zero.\r\n  function createNextPremiumSale(uint8 _featuredChecklistItem, uint256 _packPrice) external onlyOwner nonZeroPackPrice(_packPrice) {\r\n    require(nextPremiumSale.packPrice == 0, \"Next Premium Sale already exists.\");\r\n    require(_featuredChecklistItem >= 100, \"You can't have an Originals as a featured checklist item.\");\r\n    require(saleCount <= MAX_NUMBER_OF_PREMIUM_SALES, \"You can only run 24 total Premium sales.\");\r\n    nextPremiumSale.id = saleCount;\r\n    nextPremiumSale.featuredChecklistItem = _featuredChecklistItem;\r\n    nextPremiumSale.packPrice = _packPrice;\r\n    saleCount++;\r\n  }\r\n\r\n  /// @dev Load some shuffled packs into the next Premium sale that we created.\r\n  /// @param _newPacks The new packs to load.\r\n  function addPacksToNextPremiumSale(uint32[] _newPacks) external onlyOwner {\r\n    require(nextPremiumSale.packPrice > 0, \"You must first create a nextPremiumSale.\");\r\n    require(nextPremiumSale.packsLoaded + _newPacks.length <= PREMIUM_SALE_PACK_COUNT, \"You can't add more than 500 packs to a Premium sale.\");\r\n    _addPacksToSale(_newPacks, nextPremiumSale);\r\n  }\r\n\r\n  /// @dev Moves the sale we staged in nextPremiumSale over to the currentPremiumSale variable, and clears nextPremiumSale.\r\n  ///   Also removes currentPremiumSale's featuredChecklistItem from circulation.\r\n  function startNextPremiumSale() external onlyOwner {\r\n    require(nextPremiumSale.packsLoaded == PREMIUM_SALE_PACK_COUNT, \"You must add exactly 500 packs before starting this Premium sale.\");\r\n    if (currentPremiumSale.featuredChecklistItem >= 100) {\r\n      mintingContract.pullFromCirculation(currentPremiumSale.featuredChecklistItem);\r\n    }\r\n    currentPremiumSale = nextPremiumSale;\r\n    delete nextPremiumSale;\r\n  }\r\n\r\n  /// @dev Allows the owner to make last second changes to the staged Premium sale before pushing it live.\r\n  /// @param _featuredChecklistItem The card of the day, which we will take out of circulation once the sale ends.\r\n  /// @param _packPrice The price of packs for this sale, in wei. Must be greater than zero.\r\n  function modifyNextPremiumSale(uint8 _featuredChecklistItem, uint256 _packPrice) external onlyOwner nonZeroPackPrice(_packPrice) {\r\n    require(nextPremiumSale.packPrice > 0, \"You must first create a nextPremiumSale.\");\r\n    nextPremiumSale.featuredChecklistItem = _featuredChecklistItem;\r\n    nextPremiumSale.packPrice = _packPrice;\r\n  }\r\n}\r\n\r\n\r\n/// @title All the internal functions that govern the act of turning a uint32 pack into 4 NFTs.\r\n/// @author The CryptoStrikers Team\r\ncontract StrikersPackSaleInternal is StrikersPackFactory {\r\n\r\n  /// @dev Emit this every time we sell a pack.\r\n  event PackBought(address indexed buyer, uint256[] pack);\r\n\r\n  /// @dev The number of cards in a pack.\r\n  uint8 public constant PACK_SIZE = 4;\r\n\r\n  /// @dev We increment this nonce when grabbing a random pack in _removeRandomPack().\r\n  uint256 internal randNonce;\r\n\r\n  /// @dev Function shared by all 3 ways of buying a pack (ETH, kitty burn, whitelist).\r\n  /// @param _sale The sale we are buying from.\r\n  function _buyPack(PackSale storage _sale) internal whenNotPaused {\r\n    require(msg.sender == tx.origin, \"Only EOAs are allowed to buy from the pack sale.\");\r\n    require(_sale.packs.length > 0, \"The sale has no packs available for sale.\");\r\n    uint32 pack = _removeRandomPack(_sale.packs);\r\n    uint256[] memory cards = _mintCards(pack);\r\n    _sale.packsSold++;\r\n    emit PackBought(msg.sender, cards);\r\n  }\r\n\r\n  /// @dev Iterates over a uint32 pack 8 bits at a time and turns each group of 8 bits into a token!\r\n  /// @param _pack 32 bit integer where each group of 8 bits represents a checklist ID.\r\n  /// @return An array of 4 token IDs, representing the cards we minted.\r\n  function _mintCards(uint32 _pack) internal returns (uint256[]) {\r\n    uint8 mask = 255;\r\n    uint256[] memory newCards = new uint256[](PACK_SIZE);\r\n\r\n    for (uint8 i = 1; i <= PACK_SIZE; i++) {\r\n      // Can't underflow because PACK_SIZE is 4.\r\n      uint8 shift = 32 - (i * 8);\r\n      uint8 checklistId = uint8((_pack >> shift) & mask);\r\n      uint256 cardId = mintingContract.mintPackSaleCard(checklistId, msg.sender);\r\n      newCards[i-1] = cardId;\r\n    }\r\n\r\n    return newCards;\r\n  }\r\n\r\n  /// @dev Given an array of packs (uint32s), removes one from a random index.\r\n  /// @param _packs The array of uint32s we will be mutating.\r\n  /// @return The random uint32 we removed.\r\n  function _removeRandomPack(uint32[] storage _packs) internal returns (uint32) {\r\n    randNonce++;\r\n    bytes memory packed = abi.encodePacked(now, msg.sender, randNonce);\r\n    uint256 randomIndex = uint256(keccak256(packed)) % _packs.length;\r\n    return _removePackAtIndex(randomIndex, _packs);\r\n  }\r\n\r\n  /// @dev Given an array of uint32s, remove the one at a given index and replace it with the last element of the array.\r\n  /// @param _index The index of the pack we want to remove from the array.\r\n  /// @param _packs The array of uint32s we will be mutating.\r\n  /// @return The uint32 we removed from position _index.\r\n  function _removePackAtIndex(uint256 _index, uint32[] storage _packs) internal returns (uint32) {\r\n    // Can't underflow because we do require(_sale.packs.length > 0) in _buyPack().\r\n    uint256 lastIndex = _packs.length - 1;\r\n    require(_index <= lastIndex);\r\n    uint32 pack = _packs[_index];\r\n    _packs[_index] = _packs[lastIndex];\r\n    _packs.length--;\r\n    return pack;\r\n  }\r\n}\r\n\r\n\r\n/// @title A contract that manages the whitelist we use for free pack giveaways.\r\n/// @author The CryptoStrikers Team\r\ncontract StrikersWhitelist is StrikersPackSaleInternal {\r\n\r\n  /// @dev Emit this when the contract owner increases a user's whitelist allocation.\r\n  event WhitelistAllocationIncreased(address indexed user, uint16 amount, bool premium);\r\n\r\n  /// @dev Emit this whenever someone gets a pack using their whitelist allocation.\r\n  event WhitelistAllocationUsed(address indexed user, bool premium);\r\n\r\n  /// @dev We can only give away a maximum of 1000 Standard packs, and 500 Premium packs.\r\n  uint16[2] public whitelistLimits = [\r\n    1000, // Standard\r\n    500 // Premium\r\n  ];\r\n\r\n  /// @dev Keep track of the allocation for each whitelist so we don't go over the limit.\r\n  uint16[2] public currentWhitelistCounts;\r\n\r\n  /// @dev Index 0 is the Standard whitelist, index 1 is the Premium whitelist. Maps addresses to free pack allocation.\r\n  mapping (address => uint8)[2] public whitelists;\r\n\r\n  /// @dev Allows the owner to allocate free packs (either Standard or Premium) to a given address.\r\n  /// @param _premium True for Premium whitelist, false for Standard whitelist.\r\n  /// @param _addr Address of the user who is getting the free packs.\r\n  /// @param _additionalPacks How many packs we are adding to this user's allocation.\r\n  function addToWhitelistAllocation(bool _premium, address _addr, uint8 _additionalPacks) public onlyOwner {\r\n    uint8 listIndex = _premium ? 1 : 0;\r\n    require(currentWhitelistCounts[listIndex] + _additionalPacks <= whitelistLimits[listIndex]);\r\n    currentWhitelistCounts[listIndex] += _additionalPacks;\r\n    whitelists[listIndex][_addr] += _additionalPacks;\r\n    emit WhitelistAllocationIncreased(_addr, _additionalPacks, _premium);\r\n  }\r\n\r\n  /// @dev A way to call addToWhitelistAllocation in bulk. Adds 1 pack to each address.\r\n  /// @param _premium True for Premium whitelist, false for Standard whitelist.\r\n  /// @param _addrs Addresses of the users who are getting the free packs.\r\n  function addAddressesToWhitelist(bool _premium, address[] _addrs) external onlyOwner {\r\n    for (uint256 i = 0; i < _addrs.length; i++) {\r\n      addToWhitelistAllocation(_premium, _addrs[i], 1);\r\n    }\r\n  }\r\n\r\n  /// @dev If msg.sender has whitelist allocation for a given pack type, decrement it and give them a free pack.\r\n  /// @param _premium True for the Premium sale, false for the Standard sale.\r\n  function claimWhitelistPack(bool _premium) external {\r\n    uint8 listIndex = _premium ? 1 : 0;\r\n    require(whitelists[listIndex][msg.sender] > 0, \"You have no whitelist allocation.\");\r\n    // Can't underflow because of require() check above.\r\n    whitelists[listIndex][msg.sender]--;\r\n    PackSale storage sale = _premium ? currentPremiumSale : standardSale;\r\n    _buyPack(sale);\r\n    emit WhitelistAllocationUsed(msg.sender, _premium);\r\n  }\r\n}\r\n\r\n\r\n/// @title The contract that manages our referral program -- invite your friends and get rewarded!\r\n/// @author The CryptoStrikers Team\r\ncontract StrikersReferral is StrikersWhitelist {\r\n\r\n  /// @dev A cap for how many free referral packs we are giving away.\r\n  uint16 public constant MAX_FREE_REFERRAL_PACKS = 5000;\r\n\r\n  /// @dev The percentage of each sale that gets paid out to the referrer as commission.\r\n  uint256 public constant PERCENT_COMMISSION = 10;\r\n\r\n  /// @dev The 8 bonus cards that you get for your first 8 referrals, in order.\r\n  uint8[] public bonusCards = [\r\n    115, // Kanté\r\n    127, // Navas\r\n    122, // Hummels\r\n    130, // Alves\r\n    116, // Cavani\r\n    123, // Özil\r\n    121, // Thiago\r\n    131 // Zlatan\r\n  ];\r\n\r\n  /// @dev Emit this event when a sale gets attributed, so the referrer can see a log of all his referrals.\r\n  event SaleAttributed(address indexed referrer, address buyer, uint256 amount);\r\n\r\n  /// @dev How much many of the 8 bonus cards this referrer has claimed.\r\n  mapping (address => uint8) public bonusCardsClaimed;\r\n\r\n  /// @dev Use this to track whether or not a user has bought at least one pack, to avoid people gaming our referral program.\r\n  mapping (address => uint16) public packsBought;\r\n\r\n  /// @dev Keep track of this to make sure we don't go over MAX_FREE_REFERRAL_PACKS.\r\n  uint16 public freeReferralPacksClaimed;\r\n\r\n  /// @dev Tracks whether or not a user has already claimed their free referral pack.\r\n  mapping (address => bool) public hasClaimedFreeReferralPack;\r\n\r\n  /// @dev How much referral income a given referrer has claimed.\r\n  mapping (address => uint256) public referralCommissionClaimed;\r\n\r\n  /// @dev How much referral income a given referrer has earned.\r\n  mapping (address => uint256) public referralCommissionEarned;\r\n\r\n  /// @dev Tracks how many sales have been attributed to a given referrer.\r\n  mapping (address => uint16) public referralSaleCount;\r\n\r\n  /// @dev A mapping to keep track of who referred a given user.\r\n  mapping (address => address) public referrers;\r\n\r\n  /// @dev How much ETH is owed to referrers, so we don't touch it when we withdraw our take from the contract.\r\n  uint256 public totalCommissionOwed;\r\n\r\n  /// @dev After a pack is bought with ETH, we call this to attribute the sale to the buyer's referrer.\r\n  /// @param _buyer The user who bought the pack.\r\n  /// @param _amount The price of the pack bought, in wei.\r\n  function _attributeSale(address _buyer, uint256 _amount) internal {\r\n    address referrer = referrers[_buyer];\r\n\r\n    // Can only attribute a sale to a valid referrer.\r\n    // Referral commissions only accrue if the referrer has bought a pack.\r\n    if (referrer == address(0) || packsBought[referrer] == 0) {\r\n      return;\r\n    }\r\n\r\n    referralSaleCount[referrer]++;\r\n\r\n    // The first 8 referral sales each unlock a bonus card.\r\n    // Any sales past the first 8 generate referral commission.\r\n    if (referralSaleCount[referrer] > bonusCards.length) {\r\n      uint256 commission = _amount * PERCENT_COMMISSION / 100;\r\n      totalCommissionOwed += commission;\r\n      referralCommissionEarned[referrer] += commission;\r\n    }\r\n\r\n    emit SaleAttributed(referrer, _buyer, _amount);\r\n  }\r\n\r\n  /// @dev A referrer calls this to claim the next of the 8 bonus cards he is owed.\r\n  function claimBonusCard() external {\r\n    uint16 attributedSales = referralSaleCount[msg.sender];\r\n    uint8 cardsClaimed = bonusCardsClaimed[msg.sender];\r\n    require(attributedSales > cardsClaimed, \"You have no unclaimed bonus cards.\");\r\n    require(cardsClaimed < bonusCards.length, \"You have claimed all the bonus cards.\");\r\n    bonusCardsClaimed[msg.sender]++;\r\n    uint8 bonusCardChecklistId = bonusCards[cardsClaimed];\r\n    mintingContract.mintPackSaleCard(bonusCardChecklistId, msg.sender);\r\n  }\r\n\r\n  /// @dev A user who was referred to CryptoStrikers can call this once to claim their free pack (must have bought a pack first).\r\n  function claimFreeReferralPack() external {\r\n    require(isOwedFreeReferralPack(msg.sender), \"You are not eligible for a free referral pack.\");\r\n    require(freeReferralPacksClaimed < MAX_FREE_REFERRAL_PACKS, \"We've already given away all the free referral packs...\");\r\n    freeReferralPacksClaimed++;\r\n    hasClaimedFreeReferralPack[msg.sender] = true;\r\n    _buyPack(standardSale);\r\n  }\r\n\r\n  /// @dev Checks whether or not a given user is eligible for a free referral pack.\r\n  /// @param _addr The address of the user we are inquiring about.\r\n  /// @return True if user can call claimFreeReferralPack(), false otherwise.\r\n  function isOwedFreeReferralPack(address _addr) public view returns (bool) {\r\n    // _addr will only have a referrer if they've already bought a pack (see buyFirstPackFromReferral())\r\n    address referrer = referrers[_addr];\r\n\r\n    // To prevent abuse, require that the referrer has bought at least one pack.\r\n    // Guaranteed to evaluate to false if referrer is address(0), so don't even check for that.\r\n    bool referrerHasBoughtPack = packsBought[referrer] > 0;\r\n\r\n    // Lastly, check to make sure _addr hasn't already claimed a free pack.\r\n    return referrerHasBoughtPack && !hasClaimedFreeReferralPack[_addr];\r\n  }\r\n\r\n  /// @dev Allows the contract owner to manually set the referrer for a given user, in case this wasn't properly attributed.\r\n  /// @param _for The user we want to set the referrer for.\r\n  /// @param _referrer The user who will now get credit for _for's future purchases.\r\n  function setReferrer(address _for, address _referrer) external onlyOwner {\r\n    referrers[_for] = _referrer;\r\n  }\r\n\r\n  /// @dev Allows a user to withdraw the referral commission they are owed.\r\n  function withdrawCommission() external {\r\n    uint256 commission = referralCommissionEarned[msg.sender] - referralCommissionClaimed[msg.sender];\r\n    require(commission > 0, \"You are not owed any referral commission.\");\r\n    totalCommissionOwed -= commission;\r\n    referralCommissionClaimed[msg.sender] += commission;\r\n    msg.sender.transfer(commission);\r\n  }\r\n}\r\n\r\n\r\n\r\n/// @title The main sale contract, allowing users to purchase packs of CryptoStrikers cards.\r\n/// @author The CryptoStrikers Team\r\ncontract StrikersPackSale is StrikersReferral {\r\n\r\n  /// @dev The max number of kitties we are allowed to burn.\r\n  uint16 public constant KITTY_BURN_LIMIT = 1000;\r\n\r\n  /// @dev Emit this whenever someone sacrifices a cat for a free pack of cards.\r\n  event KittyBurned(address user, uint256 kittyId);\r\n\r\n  /// @dev Users are only allowed to burn 1 cat each, so keep track of that here.\r\n  mapping (address => bool) public hasBurnedKitty;\r\n\r\n  /// @dev A reference to the CryptoKitties contract so we can transfer cats\r\n  ERC721Basic public kittiesContract;\r\n\r\n  /// @dev How many kitties we have burned so far. Think of the cats, make sure we don't go over KITTY_BURN_LIMIT!\r\n  uint16 public totalKittiesBurned;\r\n\r\n  /// @dev Keeps track of our sale volume, in wei.\r\n  uint256 public totalWeiRaised;\r\n\r\n  /// @dev Constructor. Can't change minting and kitties contracts once they've been initialized.\r\n  constructor(\r\n    uint256 _standardPackPrice,\r\n    address _kittiesContractAddress,\r\n    address _mintingContractAddress\r\n  )\r\n  StrikersPackFactory(_standardPackPrice)\r\n  public\r\n  {\r\n    kittiesContract = ERC721Basic(_kittiesContractAddress);\r\n    mintingContract = StrikersMinting(_mintingContractAddress);\r\n  }\r\n\r\n  /// @dev For a user who was referred, use this function to buy your first back so we can attribute the referral.\r\n  /// @param _referrer The user who invited msg.sender to CryptoStrikers.\r\n  /// @param _premium True if we're buying from Premium sale, false if we're buying from Standard sale.\r\n  function buyFirstPackFromReferral(address _referrer, bool _premium) external payable {\r\n    require(packsBought[msg.sender] == 0, \"Only assign a referrer on a user's first purchase.\");\r\n    referrers[msg.sender] = _referrer;\r\n    buyPackWithETH(_premium);\r\n  }\r\n\r\n  /// @dev Allows a user to buy a pack of cards with enough ETH to cover the packPrice.\r\n  /// @param _premium True if we're buying from Premium sale, false if we're buying from Standard sale.\r\n  function buyPackWithETH(bool _premium) public payable {\r\n    PackSale storage sale = _premium ? currentPremiumSale : standardSale;\r\n    uint256 packPrice = sale.packPrice;\r\n    require(msg.value >= packPrice, \"Insufficient ETH sent to buy this pack.\");\r\n    _buyPack(sale);\r\n    packsBought[msg.sender]++;\r\n    totalWeiRaised += packPrice;\r\n    // Refund excess funds\r\n    msg.sender.transfer(msg.value - packPrice);\r\n    _attributeSale(msg.sender, packPrice);\r\n  }\r\n\r\n  /// @notice Magically transform a CryptoKitty into a free pack of cards!\r\n  /// @param _kittyId The cat we are giving up.\r\n  /// @dev Note that the user must first give this contract approval by\r\n  ///   calling approve(address(this), _kittyId) on the CK contract.\r\n  ///   Otherwise, buyPackWithKitty() throws on transferFrom().\r\n  function buyPackWithKitty(uint256 _kittyId) external {\r\n    require(totalKittiesBurned < KITTY_BURN_LIMIT, \"Stop! Think of the cats!\");\r\n    require(!hasBurnedKitty[msg.sender], \"You've already burned a kitty.\");\r\n    totalKittiesBurned++;\r\n    hasBurnedKitty[msg.sender] = true;\r\n    // Will throw/revert if this contract hasn't been given approval first.\r\n    // Also, with no way of retrieving kitties from this contract,\r\n    // transferring to \"this\" burns the cat! (desired behaviour)\r\n    kittiesContract.transferFrom(msg.sender, this, _kittyId);\r\n    _buyPack(standardSale);\r\n    emit KittyBurned(msg.sender, _kittyId);\r\n  }\r\n\r\n  /// @dev Allows the contract owner to withdraw the ETH raised from selling packs.\r\n  function withdrawBalance() external onlyOwner {\r\n    uint256 totalBalance = address(this).balance;\r\n    require(totalBalance > totalCommissionOwed, \"There is no ETH for the owner to claim.\");\r\n    owner.transfer(totalBalance - totalCommissionOwed);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_premium\",\"type\":\"bool\"},{\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimBonusCard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasBurnedKitty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentWhitelistCounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_premium\",\"type\":\"bool\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_additionalPacks\",\"type\":\"uint8\"}],\"name\":\"addToWhitelistAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_featuredChecklistItem\",\"type\":\"uint8\"},{\"name\":\"_packPrice\",\"type\":\"uint256\"}],\"name\":\"modifyNextPremiumSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENT_COMMISSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kittiesContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimFreeReferralPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PACK_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freeReferralPacksClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KITTY_BURN_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_premium\",\"type\":\"bool\"}],\"name\":\"claimWhitelistPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusCardsClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPremiumSale\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"featuredChecklistItem\",\"type\":\"uint8\"},{\"name\":\"packPrice\",\"type\":\"uint256\"},{\"name\":\"packsLoaded\",\"type\":\"uint32\"},{\"name\":\"packsSold\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistLimits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_packPrice\",\"type\":\"uint256\"}],\"name\":\"setStandardPackPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_NUMBER_OF_PREMIUM_SALES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCommissionClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCommissionOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"packsBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isOwedFreeReferralPack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPacks\",\"type\":\"uint32[]\"}],\"name\":\"addPacksToNextPremiumSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPremiumSale\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"featuredChecklistItem\",\"type\":\"uint8\"},{\"name\":\"packPrice\",\"type\":\"uint256\"},{\"name\":\"packsLoaded\",\"type\":\"uint32\"},{\"name\":\"packsSold\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_STANDARD_SALE_PACKS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PREMIUM_SALE_PACK_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startStandardSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"setReferrer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelists\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_premium\",\"type\":\"bool\"}],\"name\":\"buyPackWithETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_featuredChecklistItem\",\"type\":\"uint8\"},{\"name\":\"_packPrice\",\"type\":\"uint256\"}],\"name\":\"createNextPremiumSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralCommissionEarned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standardSale\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"featuredChecklistItem\",\"type\":\"uint8\"},{\"name\":\"packPrice\",\"type\":\"uint256\"},{\"name\":\"packsLoaded\",\"type\":\"uint32\"},{\"name\":\"packsSold\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"},{\"name\":\"_premium\",\"type\":\"bool\"}],\"name\":\"buyFirstPackFromReferral\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimedFreeReferralPack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNextPremiumSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPacks\",\"type\":\"uint32[]\"}],\"name\":\"addPacksToStandardSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalKittiesBurned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint256\"}],\"name\":\"buyPackWithKitty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_FREE_REFERRAL_PACKS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_standardPackPrice\",\"type\":\"uint256\"},{\"name\":\"_kittiesContractAddress\",\"type\":\"address\"},{\"name\":\"_mintingContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"kittyId\",\"type\":\"uint256\"}],\"name\":\"KittyBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SaleAttributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"premium\",\"type\":\"bool\"}],\"name\":\"WhitelistAllocationIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"premium\",\"type\":\"bool\"}],\"name\":\"WhitelistAllocationUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pack\",\"type\":\"uint256[]\"}],\"name\":\"PackBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"saleId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"packs\",\"type\":\"uint32[]\"}],\"name\":\"PacksLoaded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"saleId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"packPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"featuredChecklistItem\",\"type\":\"uint8\"}],\"name\":\"SaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"packPrice\",\"type\":\"uint256\"}],\"name\":\"StandardPackPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"StrikersPackSale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000058d15e1762800000000000000000000000000006012c8cf97bead5deae237070f9587f8e7a266d000000000000000000000000dcaad9fd9a74144d226dbf94ce6162ca9f09ed7e","Library":"","SwarmSource":"bzzr://296f4da94211394eeccaa9831584faadded171922dfa95af7ef971853866ca65"}]}