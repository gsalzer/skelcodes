{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n\r\n}\r\n\r\n\r\n/// @dev Interface to the Core Contract of Ether Dungeon.\r\ncontract EDCoreInterface {\r\n\r\n    /// @dev The external function to get all the game settings in one call.\r\n    function getGameSettings() external view returns (\r\n        uint _recruitHeroFee,\r\n        uint _transportationFeeMultiplier,\r\n        uint _noviceDungeonId,\r\n        uint _consolationRewardsRequiredFaith,\r\n        uint _challengeFeeMultiplier,\r\n        uint _dungeonPreparationTime,\r\n        uint _trainingFeeMultiplier,\r\n        uint _equipmentTrainingFeeMultiplier,\r\n        uint _preparationPeriodTrainingFeeMultiplier,\r\n        uint _preparationPeriodEquipmentTrainingFeeMultiplier\r\n    );\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific player by its address.\r\n     * @param _address The address of the player.\r\n     */\r\n    function getPlayerDetails(address _address) external view returns (\r\n        uint dungeonId,\r\n        uint payment,\r\n        uint dungeonCount,\r\n        uint heroCount,\r\n        uint faith,\r\n        bool firstHeroRecruited\r\n    );\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific dungeon by its ID.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonDetails(uint _id) external view returns (\r\n        uint creationTime,\r\n        uint status,\r\n        uint difficulty,\r\n        uint capacity,\r\n        address owner,\r\n        bool isReady,\r\n        uint playerCount\r\n    );\r\n\r\n    /**\r\n     * @dev Split floor related details out of getDungeonDetails, just to avoid Stack Too Deep error.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonFloorDetails(uint _id) external view returns (\r\n        uint floorNumber,\r\n        uint floorCreationTime,\r\n        uint rewards,\r\n        uint seedGenes,\r\n        uint floorGenes\r\n    );\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific hero by its ID.\r\n     * @param _id The ID of the hero.\r\n     */\r\n    function getHeroDetails(uint _id) external view returns (\r\n        uint creationTime,\r\n        uint cooldownStartTime,\r\n        uint cooldownIndex,\r\n        uint genes,\r\n        address owner,\r\n        bool isReady,\r\n        uint cooldownRemainingTime\r\n    );\r\n\r\n    /// @dev Get the attributes (equipments + stats) of a hero from its gene.\r\n    function getHeroAttributes(uint _genes) public pure returns (uint[]);\r\n\r\n    /// @dev Calculate the power of a hero from its gene, it calculates the equipment power, stats power, and super hero boost.\r\n    function getHeroPower(uint _genes, uint _dungeonDifficulty) public pure returns (\r\n        uint totalPower,\r\n        uint equipmentPower,\r\n        uint statsPower,\r\n        bool isSuper,\r\n        uint superRank,\r\n        uint superBoost\r\n    );\r\n\r\n    /// @dev Calculate the power of a dungeon floor.\r\n    function getDungeonPower(uint _genes) public pure returns (uint);\r\n\r\n    /**\r\n     * @dev Calculate the sum of top 5 heroes power a player owns.\r\n     *  The gas usage increased with the number of heroes a player owned, roughly 500 x hero count.\r\n     *  This is used in transport function only to calculate the required tranport fee.\r\n     */\r\n    function calculateTop5HeroesPower(address _address, uint _dungeonId) public view returns (uint);\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Core Contract of \"Dungeon Run\" event game of the ED (Ether Dungeon) Platform.\r\n * @dev Dungeon Run is a single-player game mode added to the Ether Dungeon platform.\r\n *  The objective of Dungeon Run is to defeat as many monsters as possible.\r\n */\r\ncontract DungeonRunBeta is Pausable, Destructible {\r\n\r\n    /*=================================\r\n    =             STRUCTS             =\r\n    =================================*/\r\n\r\n    struct Monster {\r\n        uint64 creationTime;\r\n        uint8 level;\r\n        uint16 initialHealth;\r\n        uint16 health;\r\n    }\r\n\r\n\r\n    /*=================================\r\n    =            CONTRACTS            =\r\n    =================================*/\r\n\r\n    /// @dev The address of the EtherDungeonCore contract.\r\n    EDCoreInterface public edCoreContract = EDCoreInterface(0xf7eD56c1AC4d038e367a987258b86FC883b960a1);\r\n\r\n\r\n    /*=================================\r\n    =            CONSTANTS            =\r\n    =================================*/\r\n\r\n    /// @dev By defeating the checkPointLevel, half of the entranceFee is refunded.\r\n    uint8 public constant checkpointLevel = 4;\r\n\r\n    /// @dev By defeating the breakevenLevel, another half of the entranceFee is refunded.\r\n    uint8 public constant breakevenLevel = 8;\r\n\r\n    /// @dev By defeating the jackpotLevel, the player win the entire jackpot.\r\n    uint8 public constant jackpotLevel = 12;\r\n\r\n    /// @dev Dungeon difficulty to be used when calculating super hero power boost, 3 is 64 power boost.\r\n    uint public constant dungeonDifficulty = 3;\r\n\r\n    /// @dev The health of a monster is level * monsterHealth;\r\n    uint16 public monsterHealth = 10;\r\n\r\n    /// @dev When a monster flees, the hero health is reduced by monster level + monsterStrength.\r\n    uint public monsterStrength = 4;\r\n\r\n    /// @dev After a certain period of time, the monster will attack the hero and flee.\r\n    uint64 public monsterFleeTime = 8 minutes;\r\n\r\n\r\n    /*=================================\r\n    =            SETTINGS             =\r\n    =================================*/\r\n\r\n    /// @dev To start a run, a player need to pay an entrance fee.\r\n    uint public entranceFee = 0.04 ether;\r\n\r\n    /// @dev 0.1 ether is provided as the initial jackpot.\r\n    uint public jackpot = 0.1 ether;\r\n\r\n    /**\r\n     * @dev The dungeon run entrance fee will first be deposited to a pool first, when the hero is\r\n     *  defeated by a monster, then the fee will be added to the jackpot.\r\n     */\r\n    uint public entranceFeePool;\r\n\r\n    /// @dev Private seed for the PRNG used for calculating damage amount.\r\n    uint _seed;\r\n\r\n\r\n    /*=================================\r\n    =         STATE VARIABLES         =\r\n    =================================*/\r\n\r\n    /// @dev A mapping from hero ID to the current run monster, a 0 value indicates no current run.\r\n    mapping(uint => Monster) public heroIdToMonster;\r\n\r\n    /// @dev A mapping from hero ID to its current health.\r\n    mapping(uint => uint) public heroIdToHealth;\r\n\r\n    /// @dev A mapping from hero ID to the refunded fee.\r\n    mapping(uint => uint) public heroIdToRefundedFee;\r\n\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n    /// @dev The LogAttack event is fired whenever a hero attack a monster.\r\n    event LogAttack(uint timestamp, address indexed player, uint indexed heroId, uint indexed monsterLevel, uint damageByHero, uint damageByMonster, bool isMonsterDefeated, uint rewards);\r\n\r\n    function DungeonRunAlpha() public payable {}\r\n\r\n    /*=======================================\r\n    =       PUBLIC/EXTERNAL FUNCTIONS       =\r\n    =======================================*/\r\n\r\n    /// @dev The external function to get all the game settings in one call.\r\n    function getGameSettings() external view returns (\r\n        uint _checkpointLevel,\r\n        uint _breakevenLevel,\r\n        uint _jackpotLevel,\r\n        uint _dungeonDifficulty,\r\n        uint _monsterHealth,\r\n        uint _monsterStrength,\r\n        uint _monsterFleeTime,\r\n        uint _entranceFee\r\n    ) {\r\n        _checkpointLevel = checkpointLevel;\r\n        _breakevenLevel = breakevenLevel;\r\n        _jackpotLevel = jackpotLevel;\r\n        _dungeonDifficulty = dungeonDifficulty;\r\n        _monsterHealth = monsterHealth;\r\n        _monsterStrength = monsterStrength;\r\n        _monsterFleeTime = monsterFleeTime;\r\n        _entranceFee = entranceFee;\r\n    }\r\n\r\n    /// @dev The external function to get the dungeon run details in one call.\r\n    function getRunDetails(uint _heroId) external view returns (\r\n        uint _heroPower,\r\n        uint _heroStrength,\r\n        uint _heroInitialHealth,\r\n        uint _heroHealth,\r\n        uint _monsterCreationTime,\r\n        uint _monsterLevel,\r\n        uint _monsterInitialHealth,\r\n        uint _monsterHealth,\r\n        uint _gameState // 0: NotStarted | 1: NewMonster | 2: Active | 3: RunEnded\r\n    ) {\r\n        uint genes;\r\n        address owner;\r\n        (,,, genes, owner,,) = edCoreContract.getHeroDetails(_heroId);\r\n        (_heroPower,,,,) = edCoreContract.getHeroPower(genes, dungeonDifficulty);\r\n        _heroStrength = (genes / (32 ** 8)) % 32 + 1;\r\n        _heroInitialHealth = (genes / (32 ** 12)) % 32 + 1;\r\n        _heroHealth = heroIdToHealth[_heroId];\r\n\r\n        Monster memory monster = heroIdToMonster[_heroId];\r\n        _monsterCreationTime = monster.creationTime;\r\n\r\n        // Dungeon run is ended if either hero is defeated (health exhausted),\r\n        // or hero failed to damage a monster before it flee.\r\n        bool _dungeonRunEnded = monster.level > 0 && (\r\n            _heroHealth == 0 ||\r\n            now > _monsterCreationTime + monsterFleeTime * 2 ||\r\n            (monster.health == monster.initialHealth && now > monster.creationTime + monsterFleeTime)\r\n        );\r\n\r\n        // Calculate hero and monster stats based on different game state.\r\n        if (monster.level == 0) {\r\n            // Dungeon run not started yet.\r\n            _heroHealth = _heroInitialHealth;\r\n            _monsterLevel = 1;\r\n            _monsterInitialHealth = monsterHealth;\r\n            _monsterHealth = _monsterInitialHealth;\r\n            _gameState = 0;\r\n        } else if (_dungeonRunEnded) {\r\n            // Dungeon run ended.\r\n            _monsterLevel = monster.level;\r\n            _monsterInitialHealth = monster.initialHealth;\r\n            _monsterHealth = monster.health;\r\n            _gameState = 3;\r\n        } else if (now > _monsterCreationTime + monsterFleeTime) {\r\n            // Previous monster just fled, new monster awaiting.\r\n            if (monster.level + monsterStrength > _heroHealth) {\r\n                _heroHealth = 0;\r\n                _monsterLevel = monster.level;\r\n                _monsterInitialHealth = monster.initialHealth;\r\n                _monsterHealth = monster.health;\r\n                _gameState = 2;\r\n            } else {\r\n                _heroHealth -= monster.level + monsterStrength;\r\n                _monsterCreationTime += monsterFleeTime;\r\n                _monsterLevel = monster.level + 1;\r\n                _monsterInitialHealth = _monsterLevel * monsterHealth;\r\n                _monsterHealth = _monsterInitialHealth;\r\n                _gameState = 1;\r\n            }\r\n        } else {\r\n            // Active monster.\r\n            _monsterLevel = monster.level;\r\n            _monsterInitialHealth = monster.initialHealth;\r\n            _monsterHealth = monster.health;\r\n            _gameState = 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev To start a dungeon run, player need to call the attack function with an entranceFee.\r\n     *  Future attcks required no fee, player just need to send a free transaction\r\n     *  to the contract, before the monster flee. The lower the gas price, the larger the damage.\r\n     *  This function is prevented from being called by a contract, using the onlyHumanAddress modifier.\r\n     *  Note that each hero can only perform one dungeon run.\r\n     */\r\n    function attack(uint _heroId) whenNotPaused onlyHumanAddress external payable {\r\n        uint genes;\r\n        address owner;\r\n        (,,, genes, owner,,) = edCoreContract.getHeroDetails(_heroId);\r\n\r\n        // Throws if the hero is not owned by the player.\r\n        require(msg.sender == owner);\r\n\r\n        // Get the health and strength of the hero.\r\n        uint heroInitialHealth = (genes / (32 ** 12)) % 32 + 1;\r\n        uint heroStrength = (genes / (32 ** 8)) % 32 + 1;\r\n\r\n        // Get the current monster and hero current health.\r\n        Monster memory monster = heroIdToMonster[_heroId];\r\n        uint currentLevel = monster.level;\r\n        uint heroCurrentHealth = heroIdToHealth[_heroId];\r\n\r\n        // A flag determine whether the dungeon run has ended.\r\n        bool dungeonRunEnded;\r\n\r\n        // To start a run, the player need to pay an entrance fee.\r\n        if (currentLevel == 0) {\r\n            // Throws if not enough fee, and any exceeding fee will be transferred back to the player.\r\n            require(msg.value >= entranceFee);\r\n            entranceFeePool += entranceFee;\r\n\r\n            // Create level 1 monster, initial health is 1 * monsterHealth.\r\n            heroIdToMonster[_heroId] = Monster(uint64(now), 1, monsterHealth, monsterHealth);\r\n            monster = heroIdToMonster[_heroId];\r\n\r\n            // Set the hero initial health to storage.\r\n            heroIdToHealth[_heroId] = heroInitialHealth;\r\n            heroCurrentHealth = heroInitialHealth;\r\n\r\n            // Refund exceeding fee.\r\n            if (msg.value > entranceFee) {\r\n                msg.sender.transfer(msg.value - entranceFee);\r\n            }\r\n        } else {\r\n            // If the hero health is 0, the dungeon run has ends.\r\n            require(heroCurrentHealth > 0);\r\n\r\n            // If a hero failed to damage a monster before it flee, the dungeon run ends,\r\n            // regardless of the remaining hero health.\r\n            dungeonRunEnded = now > monster.creationTime + monsterFleeTime * 2 ||\r\n                (monster.health == monster.initialHealth && now > monster.creationTime + monsterFleeTime);\r\n\r\n            if (dungeonRunEnded) {\r\n                // Add the non-refunded fee to jackpot.\r\n                uint addToJackpot = entranceFee - heroIdToRefundedFee[_heroId];\r\n                jackpot += addToJackpot;\r\n                entranceFeePool -= addToJackpot;\r\n\r\n                // Sanity check.\r\n                assert(addToJackpot <= entranceFee);\r\n            }\r\n\r\n            // Future attack do not require any fee, so refund all ether sent with the transaction.\r\n            msg.sender.transfer(msg.value);\r\n        }\r\n\r\n        if (!dungeonRunEnded) {\r\n            // All pre-conditions passed, call the internal attack function.\r\n            _attack(_heroId, genes, heroStrength, heroCurrentHealth);\r\n        }\r\n    }\r\n\r\n\r\n    /*=======================================\r\n    =           SETTER FUNCTIONS            =\r\n    =======================================*/\r\n\r\n    function setEdCoreContract(address _newEdCoreContract) onlyOwner external {\r\n        edCoreContract = EDCoreInterface(_newEdCoreContract);\r\n    }\r\n\r\n    function setEntranceFee(uint _newEntranceFee) onlyOwner external {\r\n        entranceFee = _newEntranceFee;\r\n    }\r\n\r\n\r\n    /*=======================================\r\n    =      INTERNAL/PRIVATE FUNCTIONS       =\r\n    =======================================*/\r\n\r\n    /// @dev Internal function of attack, assume all parameter checking is done.\r\n    function _attack(uint _heroId, uint _genes, uint _heroStrength, uint _heroCurrentHealth) internal {\r\n        Monster storage monster = heroIdToMonster[_heroId];\r\n        uint8 currentLevel = monster.level;\r\n\r\n        // Get the hero power.\r\n        uint heroPower;\r\n        (heroPower,,,,) = edCoreContract.getHeroPower(_genes, dungeonDifficulty);\r\n\r\n        // Calculate the damage by monster.\r\n        uint damageByMonster;\r\n\r\n        // Determine if the monster has fled due to hero failed to attack within flee period.\r\n        if (now > monster.creationTime + monsterFleeTime) {\r\n            // When a monster flees, the monster will attack the hero and flee.\r\n            // The damage is calculated by monster level + monsterStrength.\r\n            damageByMonster = currentLevel + monsterStrength;\r\n        } else {\r\n            // When a monster attack back the hero, the damage will be less than monster level / 2.\r\n            if (currentLevel >= 2) {\r\n                damageByMonster = _getRandomNumber(currentLevel / 2);\r\n            }\r\n        }\r\n\r\n        // Check if hero is defeated.\r\n        if (damageByMonster >= _heroCurrentHealth) {\r\n            // Hero is defeated, the dungeon run ends.\r\n            heroIdToHealth[_heroId] = 0;\r\n\r\n            // Added the non-refunded fee to jackpot.\r\n            uint addToJackpot = entranceFee - heroIdToRefundedFee[_heroId];\r\n            jackpot += addToJackpot;\r\n            entranceFeePool -= addToJackpot;\r\n\r\n            // Sanity check.\r\n            assert(addToJackpot <= entranceFee);\r\n        } else {\r\n            // Hero is damanged but didn't defeated, game continues with a new monster.\r\n            heroIdToHealth[_heroId] -= damageByMonster;\r\n\r\n            // Create next level monster, the health of a monster is level * monsterHealth.\r\n            currentLevel++;\r\n            heroIdToMonster[_heroId] = Monster(uint64(monster.creationTime + monsterFleeTime),\r\n                currentLevel, currentLevel * monsterHealth, currentLevel * monsterHealth);\r\n            monster = heroIdToMonster[_heroId];\r\n        }\r\n\r\n        // The damage formula is [[strength / gas + power / (10 * rand)]],\r\n        // where rand is a random integer from 1 to 5.\r\n        uint damageByHero = (_heroStrength + heroPower / (10 * (1 + _getRandomNumber(5)))) / tx.gasprice / 1e9;\r\n        bool isMonsterDefeated = damageByHero >= monster.health;\r\n        uint rewards;\r\n\r\n        if (isMonsterDefeated) {\r\n            // Monster is defeated, game continues with a new monster.\r\n            // Create next level monster, the health of a monster is level * monsterHealth.\r\n            uint8 newLevel = currentLevel + 1;\r\n            heroIdToMonster[_heroId] = Monster(uint64(now), newLevel, newLevel * monsterHealth, newLevel * monsterHealth);\r\n            monster = heroIdToMonster[_heroId];\r\n\r\n            // Determine the rewards based on current level.\r\n            if (currentLevel == checkpointLevel) {\r\n                // By defeating the checkPointLevel, half of the entranceFee is refunded.\r\n                rewards = entranceFee / 2;\r\n                heroIdToRefundedFee[_heroId] += rewards;\r\n                entranceFeePool -= rewards;\r\n            } else if (currentLevel == breakevenLevel) {\r\n                // By defeating the breakevenLevel, another half of the entranceFee is refunded.\r\n                rewards = entranceFee / 2;\r\n                heroIdToRefundedFee[_heroId] += rewards;\r\n                entranceFeePool -= rewards;\r\n            } else if (currentLevel == jackpotLevel) {\r\n                // By defeating the jackpotLevel, the player win the entire jackpot.\r\n                rewards = jackpot / 2;\r\n                jackpot -= rewards;\r\n            }\r\n\r\n            msg.sender.transfer(rewards);\r\n        } else {\r\n            // Monster is damanged but not defeated, hurry up!\r\n            monster.health -= uint8(damageByHero);\r\n        }\r\n\r\n        // Emit LogAttack event.\r\n        LogAttack(now, msg.sender, _heroId, currentLevel, damageByHero, damageByMonster, isMonsterDefeated, rewards);\r\n    }\r\n\r\n    /// @dev Return a pseudo random uint smaller than _upper bounds.\r\n    function _getRandomNumber(uint _upper) private returns (uint) {\r\n        _seed = uint(keccak256(\r\n            _seed,\r\n            block.blockhash(block.number - 1),\r\n            block.coinbase,\r\n            block.difficulty\r\n        ));\r\n\r\n        return _seed % _upper;\r\n    }\r\n\r\n\r\n    /*==============================\r\n    =           MODIFIERS          =\r\n    ==============================*/\r\n\r\n    /// @dev Throws if the caller address is a contract.\r\n    modifier onlyHumanAddress() {\r\n        address addr = msg.sender;\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size == 0);\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"monsterFleeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkpointLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dungeonDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"heroIdToHealth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"edCoreContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"monsterHealth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameSettings\",\"outputs\":[{\"name\":\"_checkpointLevel\",\"type\":\"uint256\"},{\"name\":\"_breakevenLevel\",\"type\":\"uint256\"},{\"name\":\"_jackpotLevel\",\"type\":\"uint256\"},{\"name\":\"_dungeonDifficulty\",\"type\":\"uint256\"},{\"name\":\"_monsterHealth\",\"type\":\"uint256\"},{\"name\":\"_monsterStrength\",\"type\":\"uint256\"},{\"name\":\"_monsterFleeTime\",\"type\":\"uint256\"},{\"name\":\"_entranceFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entranceFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"attack\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"heroIdToRefundedFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entranceFeePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"breakevenLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"DungeonRunAlpha\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"heroIdToMonster\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint64\"},{\"name\":\"level\",\"type\":\"uint8\"},{\"name\":\"initialHealth\",\"type\":\"uint16\"},{\"name\":\"health\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEdCoreContract\",\"type\":\"address\"}],\"name\":\"setEdCoreContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"monsterStrength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"getRunDetails\",\"outputs\":[{\"name\":\"_heroPower\",\"type\":\"uint256\"},{\"name\":\"_heroStrength\",\"type\":\"uint256\"},{\"name\":\"_heroInitialHealth\",\"type\":\"uint256\"},{\"name\":\"_heroHealth\",\"type\":\"uint256\"},{\"name\":\"_monsterCreationTime\",\"type\":\"uint256\"},{\"name\":\"_monsterLevel\",\"type\":\"uint256\"},{\"name\":\"_monsterInitialHealth\",\"type\":\"uint256\"},{\"name\":\"_monsterHealth\",\"type\":\"uint256\"},{\"name\":\"_gameState\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEntranceFee\",\"type\":\"uint256\"}],\"name\":\"setEntranceFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"monsterLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"damageByHero\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"damageByMonster\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isMonsterDefeated\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"LogAttack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DungeonRunBeta","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ce9273c620ae59bad474bb7168bc24157d7497577d8847aa6aad4a20a49dec97"}]}