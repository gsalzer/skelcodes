{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/interfaces/BurnableTokenInterface.sol\r\n\r\n/**\r\n * @title Burnable Token Interface\r\n * @author Bram Hoven\r\n * @notice Interface for communicating with the burnable token\r\n */\r\ninterface BurnableTokenInterface {\r\n  /**\r\n   * @notice Triggered when tokens are burned\r\n   * @param _triggerer Address which triggered the burning\r\n   * @param _from Address from which the tokens are burned\r\n   * @param _tokens Amount of tokens burned\r\n   */\r\n  event TokensBurned(address indexed _triggerer, address indexed _from, uint256 _tokens);\r\n\r\n  /**\r\n   * @notice Called when tokens have to be burned\r\n   * @param _tokens Amount of tokens to be burned\r\n   */\r\n  function burnTokens(uint256 _tokens) external;\r\n}\r\n\r\n// File: contracts/interfaces/ContractManagerInterface.sol\r\n\r\n/**\r\n * @title Contract Manager Interface\r\n * @author Bram Hoven\r\n * @notice Interface for communicating with the contract manager\r\n */\r\ninterface ContractManagerInterface {\r\n  /**\r\n   * @notice Triggered when contract is added\r\n   * @param _address Address of the new contract\r\n   * @param _contractName Name of the new contract\r\n   */\r\n  event ContractAdded(address indexed _address, string _contractName);\r\n\r\n  /**\r\n   * @notice Triggered when contract is removed\r\n   * @param _contractName Name of the contract that is removed\r\n   */\r\n  event ContractRemoved(string _contractName);\r\n\r\n  /**\r\n   * @notice Triggered when contract is updated\r\n   * @param _oldAddress Address where the contract used to be\r\n   * @param _newAddress Address where the new contract is deployed\r\n   * @param _contractName Name of the contract that has been updated\r\n   */\r\n  event ContractUpdated(address indexed _oldAddress, address indexed _newAddress, string _contractName);\r\n\r\n  /**\r\n   * @notice Triggered when authorization status changed\r\n   * @param _address Address who will gain or lose authorization to _contractName\r\n   * @param _authorized Boolean whether or not the address is authorized\r\n   * @param _contractName Name of the contract\r\n   */\r\n  event AuthorizationChanged(address indexed _address, bool _authorized, string _contractName);\r\n\r\n  /**\r\n   * @notice Check whether the accessor is authorized to access that contract\r\n   * @param _contractName Name of the contract that is being accessed\r\n   * @param _accessor Address who wants to access that contract\r\n   */\r\n  function authorize(string _contractName, address _accessor) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Add a new contract to the manager\r\n   * @param _contractName Name of the new contract\r\n   * @param _address Address of the new contract\r\n   */\r\n  function addContract(string _contractName, address _address) external;\r\n\r\n  /**\r\n   * @notice Get a contract by its name\r\n   * @param _contractName Name of the contract\r\n   */\r\n  function getContract(string _contractName) external view returns (address _contractAddress);\r\n\r\n  /**\r\n   * @notice Remove an existing contract\r\n   * @param _contractName Name of the contract that will be removed\r\n   */\r\n  function removeContract(string _contractName) external;\r\n\r\n  /**\r\n   * @notice Update an existing contract (changing the address)\r\n   * @param _contractName Name of the existing contract\r\n   * @param _newAddress Address where the new contract is deployed\r\n   */\r\n  function updateContract(string _contractName, address _newAddress) external;\r\n\r\n  /**\r\n   * @notice Change whether an address is authorized to use a specific contract or not\r\n   * @param _contractName Name of the contract to which the accessor will gain authorization or not\r\n   * @param _authorizedAddress Address which will have its authorisation status changed\r\n   * @param _authorized Boolean whether the address will have access or not\r\n   */\r\n  function setAuthorizedContract(string _contractName, address _authorizedAddress, bool _authorized) external;\r\n}\r\n\r\n// File: contracts/interfaces/MintableTokenInterface.sol\r\n\r\n/**\r\n * @title Mintable Token Interface\r\n * @author Bram Hoven\r\n * @notice Interface for communicating with the mintable token\r\n */\r\ninterface MintableTokenInterface {\r\n  /**\r\n   * @notice Triggered when tokens are minted\r\n   * @param _from Address which triggered the minting\r\n   * @param _to Address on which the tokens are deposited\r\n   * @param _tokens Amount of tokens minted\r\n   */\r\n  event TokensMinted(address indexed _from, address indexed _to, uint256 _tokens);\r\n\r\n  /**\r\n   * @notice Triggered when the deposit address changes\r\n   * @param _old Old deposit address\r\n   * @param _new New deposit address\r\n   */\r\n  event DepositAddressChanged(address indexed _old, address indexed _new);\r\n\r\n  /**\r\n   * @notice Called when new tokens are needed in circulation\r\n   * @param _tokens Amount of tokens to be created\r\n   */\r\n  function mintTokens(uint256 _tokens) external;\r\n\r\n  /**\r\n   * @notice Called when tokens are bought in token sale\r\n   * @param _beneficiary Address on which tokens are deposited\r\n   * @param _tokens Amount of tokens to be created\r\n   */\r\n  function sendBoughtTokens(address _beneficiary, uint256 _tokens) external;\r\n\r\n  /**\r\n   * @notice Called when deposit address needs to change\r\n   * @param _depositAddress Address on which minted tokens are deposited\r\n   */\r\n  function changeDepositAddress(address _depositAddress) external;\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/token/BasicToken.sol\r\n\r\ncontract BasicToken is ERC20Basic, ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  bool public locked = true;\r\n\r\n  event TokensUnlocked();\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(!locked);\r\n    \r\n    _transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address internally\r\n  * @param _from The address to transfer from.\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(!locked);\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    require(!locked);\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    require(!locked);\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    require(!locked);\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    require(!locked);\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  } \r\n\r\n  /**\r\n   * @notice Called to unlock tokens after sale has ended\r\n   */\r\n  function unlockTokens() public {\r\n    require(locked);\r\n\r\n    locked = false;\r\n\r\n    emit TokensUnlocked();\r\n  }\r\n}\r\n\r\n// File: contracts/token/MintableToken.sol\r\n\r\n/**\r\n * @title Mintable Token\r\n * @author Bram Hoven\r\n * @notice Contract for a token which can be minted during the sale or after\r\n */\r\ncontract MintableToken is MintableTokenInterface, BasicToken {\r\n  // Address on which minted coins will be deposited (and burned if needed)\r\n  address public depositAddress;\r\n  // Name of this contract\r\n  string public contractName;\r\n  // Contract Manager\r\n  ContractManagerInterface internal contractManager;\r\n\r\n  /**\r\n   * @notice Constructor for creating mintable token\r\n   * @param _depositAddress Address on which minted coins will be deposited\r\n   * @param _contractName Name of this contract for lookup in contract manager\r\n   * @param _contractManager Address where the contract manager is located\r\n   */\r\n  constructor(address _depositAddress, string _contractName, address _contractManager) public {\r\n    depositAddress = _depositAddress;\r\n    contractName = _contractName;\r\n    contractManager = ContractManagerInterface(_contractManager);\r\n  }\r\n\r\n  /**\r\n   * @notice Called when new tokens are needed in circulation\r\n   * @param _tokens Amount for tokens to be created\r\n   */\r\n  function mintTokens(uint256 _tokens) external {\r\n    require(!locked);\r\n    require(contractManager.authorize(contractName, msg.sender));\r\n    require(_tokens != 0);\r\n\r\n    totalSupply_ = totalSupply_.add(_tokens);\r\n    balances[depositAddress] = balances[depositAddress].add(_tokens);\r\n\r\n    emit TokensMinted(msg.sender, depositAddress, _tokens);\r\n  }\r\n  \r\n  /**\r\n   * @notice Called when tokens are bought in token sale\r\n   * @param _beneficiary Address on which tokens are deposited\r\n   * @param _tokens Amount of tokens to be created\r\n   */\r\n  function sendBoughtTokens(address _beneficiary, uint256 _tokens) external {\r\n    require(locked);\r\n    require(contractManager.authorize(contractName, msg.sender));\r\n    require(_beneficiary != address(0));\r\n    require(_tokens != 0);\r\n\r\n    totalSupply_ = totalSupply_.add(_tokens);\r\n    balances[depositAddress] = balances[depositAddress].add(_tokens);\r\n\r\n    emit TokensMinted(msg.sender, depositAddress, _tokens);\r\n\r\n    _transfer(depositAddress, _beneficiary, _tokens);\r\n  }\r\n\r\n  /**\r\n   * @notice Called when deposit address needs to change\r\n   * @param _depositAddress Address on which minted tokens are deposited\r\n   */\r\n  function changeDepositAddress(address _depositAddress) external {\r\n    require(contractManager.authorize(contractName, msg.sender));\r\n    require(_depositAddress != address(0));\r\n    require(_depositAddress != depositAddress);\r\n\r\n    address oldDepositAddress = depositAddress;\r\n    depositAddress = _depositAddress;\r\n\r\n    emit DepositAddressChanged(oldDepositAddress, _depositAddress);\r\n  }\r\n}\r\n\r\n// File: contracts/token/BurnableToken.sol\r\n\r\n/**\r\n * @title Burnable Token\r\n * @author Bram Hoven\r\n * @notice Contract for a token which can be burned during the sale or after\r\n */\r\ncontract BurnableToken is BurnableTokenInterface, MintableToken {\r\n\r\n  /**\r\n   * @notice Constructor for creating burnable token\r\n   * @param _depositAddress Address on which minted coins will be deposited\r\n   * @param _contractName Name of this contract for lookup in contract manager\r\n   * @param _contractManager Address where the contract manager is located\r\n   */\r\n  constructor(address _depositAddress, string _contractName, address _contractManager) public MintableToken(_depositAddress, _contractName, _contractManager) {\r\n  }\r\n\r\n  /**\r\n   * @notice Called when tokens have to be burned (only after sale)\r\n   * @param _tokens Amount of tokens to be burned\r\n   */\r\n  function burnTokens(uint256 _tokens) external {\r\n    require(!locked);\r\n    require(contractManager.authorize(contractName, msg.sender));\r\n\r\n    require(depositAddress != address(0));\r\n    require(_tokens != 0);\r\n    require(_tokens <= balances[depositAddress]);\r\n\r\n    balances[depositAddress] = balances[depositAddress].sub(_tokens);\r\n    totalSupply_ = totalSupply_.sub(_tokens);\r\n\r\n    emit TokensBurned(msg.sender, depositAddress, _tokens);\r\n  }\r\n}\r\n\r\n// File: contracts/token/FidaToken.sol\r\n\r\n/**\r\n * @title Fida Token\r\n * @author Bram Hoven\r\n * @notice Token contract for the fida token\r\n */\r\ncontract FidaToken is BurnableToken {\r\n  string public name = \"fida\";\r\n  string public symbol = \"fida\";\r\n  uint8 public decimals = 18;\r\n  \r\n  /**\r\n   * @notice Constructor which creates the fida token\r\n   * @param _depositAddress Address on which minted tokens are deposited\r\n   * @param _contractName Name of this contract for lookup in contract manager\r\n   * @param _contractManager Address where the contract manager is located\r\n   */\r\n  constructor(address _depositAddress, string _contractName, address _contractManager) public BurnableToken(_depositAddress, _contractName, _contractManager) {}\r\n\r\n  /**\r\n   * @notice Unlock tokens, hereafter they will be tradable\r\n   */\r\n  function unlockTokens() public {\r\n    require(contractManager.authorize(contractName, msg.sender));\r\n\r\n    BasicToken.unlockTokens();\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depositAddress\",\"type\":\"address\"}],\"name\":\"changeDepositAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"sendBoughtTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_depositAddress\",\"type\":\"address\"},{\"name\":\"_contractName\",\"type\":\"string\"},{\"name\":\"_contractManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokensUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"TokensMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"DepositAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_triggerer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"TokensBurned\",\"type\":\"event\"}]","ContractName":"FidaToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f36b122dad013c455061bd07e6dfc820f6a1f42a000000000000000000000000000000000000000000000000000000000000006000000000000000000000000087986d21a28fc185a16f15c7e0d480505f28c934000000000000000000000000000000000000000000000000000000000000000946696461546f6b656e0000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://7a73b2d41665f3294db086053cfcaa6993d0c9d0000d0bed841efa17cbf8cc9c"}]}