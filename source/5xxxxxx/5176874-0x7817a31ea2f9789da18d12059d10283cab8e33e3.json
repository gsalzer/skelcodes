{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19; // solhint-disable-line\r\n\r\nlibrary FifoLib {\r\n\r\n    uint constant HEAD = 0;\r\n    \r\n    struct LinkedList {\r\n        mapping (uint => uint) list;\r\n        uint tail;\r\n        uint size;\r\n    }\r\n\r\n    function size(LinkedList storage self)\r\n        internal view returns (uint r) {\r\n        return self.size;\r\n    }\r\n\r\n    function next(LinkedList storage self, uint n)\r\n        internal view returns (uint) {\r\n        return self.list[n];\r\n    }\r\n\r\n    // insert n after prev\r\n    function insert(LinkedList storage self, uint prev, uint n) internal returns (uint) {\r\n        require(n != HEAD && self.list[n] == HEAD && n != self.tail);\r\n        self.list[n] = self.list[prev];\r\n        self.list[prev] = n;\r\n        self.size++;\r\n        if (self.tail == prev) {\r\n            self.tail = n;\r\n        }\r\n        return n;\r\n    }\r\n    \r\n    // Remove node n preceded by prev\r\n    function remove(LinkedList storage self, uint prev, uint n) internal returns (uint) {\r\n        require(n != HEAD && self.list[prev] == n);\r\n        self.list[prev] = self.list[n];\r\n        delete self.list[n];\r\n        self.size--;\r\n        if (self.tail == n) {\r\n            self.tail = prev;\r\n        }\r\n        return n;\r\n    }\r\n\r\n    function pushTail(LinkedList storage self, uint n) internal returns (uint) {\r\n        return insert(self, self.tail, n);\r\n    }\r\n    \r\n    function popHead(LinkedList storage self) internal returns (uint) {\r\n        require(self.size > 0);\r\n        return remove(self, HEAD, self.list[HEAD]);\r\n    }\r\n}\r\n\r\ncontract CompanyToken {\r\n    event Founded(uint256 tokenId, string name, address owner, uint256 price);\r\n    event SharesSold(uint256 tokenId, uint256 shares, uint256 price, address prevOwner, address newOnwer, string name);\r\n    event Transfer(address from, address to, uint256 tokenId, uint256 shares);\r\n\r\n    string public constant NAME = \"CryptoCompanies\"; // solhint-disable-line\r\n    string public constant SYMBOL = \"CompanyToken\"; // solhint-disable-line\r\n\r\n    uint256 private constant HEAD = 0;\r\n\r\n    uint256 private startingPrice = 0.001 ether;\r\n    uint256 private constant PROMO_CREATION_LIMIT = 5000;\r\n    uint256 private firstStepLimit =  0.05 ether;\r\n    uint256 private secondStepLimit = 0.5 ether;\r\n\r\n    uint256 public commissionPoints = 5;\r\n\r\n    // @dev max number of shares per company\r\n    uint256 private constant TOTAL_SHARES = 100;\r\n\r\n    // @dev companyIndex => (ownerAddress => numberOfShares)\r\n    mapping (uint256 => mapping (address => uint256)) public companyIndexToOwners;\r\n\r\n    struct Holding {\r\n        address owner;\r\n        uint256 shares;\r\n    }\r\n\r\n    // tokenId => holding fifo\r\n    mapping (uint256 => FifoLib.LinkedList) private fifo;\r\n    // tokenId => map(fifoIndex => holding)\r\n    mapping (uint256 => mapping (uint256 => Holding)) private fifoStorage;\r\n\r\n    mapping (uint256 => uint256) private fifoStorageKey;\r\n\r\n    // number of shares traded\r\n    // tokenId => circulatationCount\r\n    mapping (uint256 => uint256) private circulationCounters;\r\n\r\n    // @dev A mapping from CompanyIDs to the price of the token.\r\n    mapping (uint256 => uint256) private companyIndexToPrice;\r\n\r\n    // @dev Owner who has most shares \r\n    mapping (uint256 => address) private companyIndexToChairman;\r\n\r\n    // @dev Whether buying shares is allowed. if false, only whole purchase is allowed.\r\n    mapping (uint256 => bool) private shareTradingEnabled;\r\n\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public ceoAddress;\r\n    address public cooAddress;\r\n\r\n    uint256 public promoCreatedCount;\r\n\r\n    struct Company {\r\n        string name;\r\n    }\r\n\r\n    Company[] private companies;\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cooAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    function CompanyToken() public {\r\n        ceoAddress = msg.sender;\r\n        cooAddress = msg.sender;\r\n    }\r\n\r\n    function createPromoCompany(address _owner, string _name, uint256 _price) public onlyCOO {\r\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\r\n\r\n        address companyOwner = _owner;\r\n        if (companyOwner == address(0)) {\r\n            companyOwner = cooAddress;\r\n        }\r\n\r\n        if (_price <= 0) {\r\n            _price = startingPrice;\r\n        }\r\n\r\n        promoCreatedCount++;\r\n        _createCompany(_name, companyOwner, _price);\r\n    }\r\n\r\n    function createContractCompany(string _name) public onlyCOO {\r\n        _createCompany(_name, address(this), startingPrice);\r\n    }\r\n\r\n    function setShareTradingEnabled(uint256 _tokenId, bool _enabled) public onlyCOO {\r\n        shareTradingEnabled[_tokenId] = _enabled;\r\n    }\r\n\r\n    function setCommissionPoints(uint256 _point) public onlyCOO {\r\n        require(_point >= 0 && _point <= 10);\r\n        commissionPoints = _point;\r\n    }\r\n\r\n    function getCompany(uint256 _tokenId) public view returns (\r\n        string companyName,\r\n        bool isShareTradingEnabled,\r\n        uint256 price,\r\n        uint256 _nextPrice,\r\n        address chairman,\r\n        uint256 circulations\r\n    ) {\r\n        Company storage company = companies[_tokenId];\r\n        companyName = company.name;\r\n        isShareTradingEnabled = shareTradingEnabled[_tokenId];\r\n        price = companyIndexToPrice[_tokenId];\r\n        _nextPrice = nextPrice(_tokenId, price);\r\n        chairman = companyIndexToChairman[_tokenId];\r\n        circulations = circulationCounters[_tokenId];\r\n    }\r\n\r\n    function name() public pure returns (string) {\r\n        return NAME;\r\n    }\r\n\r\n    function shareHoldersOf(uint256 _tokenId) public view returns (address[] memory addrs, uint256[] memory shares) {\r\n        addrs = new address[](fifo[_tokenId].size);\r\n        shares = new uint256[](fifo[_tokenId].size);\r\n\r\n        uint256 fifoKey = FifoLib.next(fifo[_tokenId], HEAD);\r\n        uint256 i;\r\n        while (fifoKey != HEAD) {\r\n            addrs[i] = fifoStorage[_tokenId][fifoKey].owner;\r\n            shares[i] = fifoStorage[_tokenId][fifoKey].shares;\r\n            fifoKey = FifoLib.next(fifo[_tokenId], fifoKey);\r\n            i++;\r\n        }\r\n        return (addrs, shares);\r\n    }\r\n\r\n    function chairmanOf(uint256 _tokenId)\r\n        public\r\n        view\r\n        returns (address chairman)\r\n    {\r\n        chairman = companyIndexToChairman[_tokenId];\r\n        require(chairman != address(0));\r\n    }\r\n\r\n    function sharesOwned(address _owner, uint256 _tokenId) public view returns (uint256 shares) {\r\n        return companyIndexToOwners[_tokenId][_owner];\r\n    }\r\n\r\n    function payout(address _to) public onlyCLevel {\r\n        _payout(_to);\r\n    }\r\n\r\n    function priceOf(uint256 _tokenId) public view returns (uint256 price) {\r\n        return companyIndexToPrice[_tokenId];\r\n    }\r\n\r\n    function setCEO(address _newCEO) public onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCOO(address _newCOO) public onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    function symbol() public pure returns (string) {\r\n        return SYMBOL;\r\n    }\r\n\r\n    function totalCompanies() public view returns (uint256 total) {\r\n        return companies.length;\r\n    }\r\n\r\n\r\n    function _addressNotNull(address _to) private pure returns (bool) {\r\n        return _to != address(0);\r\n    }\r\n\r\n    /// For creating Company\r\n    function _createCompany(string _name, address _owner, uint256 _price) private {\r\n        require(_price % 100 == 0);\r\n\r\n        Company memory _company = Company({\r\n            name: _name\r\n        });\r\n        uint256 newCompanyId = companies.push(_company) - 1;\r\n\r\n        // It's probably never going to happen, 4 billion tokens are A LOT, but\r\n        // let's just be 100% sure we never let this happen.\r\n        require(newCompanyId == uint256(uint32(newCompanyId)));\r\n\r\n        Founded(newCompanyId, _name, _owner, _price);\r\n\r\n        companyIndexToPrice[newCompanyId] = _price;\r\n\r\n        _transfer(address(0), _owner, newCompanyId, TOTAL_SHARES);\r\n    }\r\n\r\n    /// Check for token ownership\r\n    function _owns(address claimant, uint256 _tokenId, uint256 _shares) private view returns (bool) {\r\n        return companyIndexToOwners[_tokenId][claimant] >= _shares;\r\n    }\r\n\r\n    /// For paying out balance on contract\r\n    function _payout(address _to) private {\r\n        if (_to == address(0)) {\r\n            ceoAddress.transfer(this.balance);\r\n        } else {\r\n            _to.transfer(this.balance);\r\n        }\r\n    }\r\n\r\n    function _purchaseProcessFifoItem(uint256 _tokenId, Holding storage _holding, uint256 _sharesToFulfill)\r\n        private\r\n        returns (uint256 sharesFulfilled, uint256 payment) {\r\n\r\n        sharesFulfilled = Math.min(_holding.shares, _sharesToFulfill);\r\n\r\n        // underflow is not possible because decution is the minimun of the two\r\n        _holding.shares -= sharesFulfilled;\r\n\r\n        companyIndexToOwners[_tokenId][_holding.owner] = SafeMath.sub(companyIndexToOwners[_tokenId][_holding.owner], sharesFulfilled);\r\n\r\n        uint256 currentTierLeft = SafeMath.sub(TOTAL_SHARES, circulationCounters[_tokenId] % TOTAL_SHARES);\r\n        uint256 currentPriceShares = Math.min(currentTierLeft, sharesFulfilled);\r\n        payment = SafeMath.div(SafeMath.mul(companyIndexToPrice[_tokenId], currentPriceShares), TOTAL_SHARES);\r\n\r\n        SharesSold(_tokenId, currentPriceShares, companyIndexToPrice[_tokenId], _holding.owner, msg.sender, companies[_tokenId].name);\r\n\r\n        if (sharesFulfilled >= currentTierLeft) {\r\n            uint256 newPrice = nextPrice(_tokenId, companyIndexToPrice[_tokenId]);\r\n            companyIndexToPrice[_tokenId] = newPrice;\r\n\r\n            if (sharesFulfilled > currentTierLeft) {\r\n                uint256 newPriceShares = sharesFulfilled - currentTierLeft;\r\n                payment += SafeMath.div(SafeMath.mul(newPrice, newPriceShares), TOTAL_SHARES);\r\n                SharesSold(_tokenId, newPriceShares, newPrice, _holding.owner, msg.sender, companies[_tokenId].name);\r\n            }\r\n        }\r\n\r\n        circulationCounters[_tokenId] = SafeMath.add(circulationCounters[_tokenId], sharesFulfilled);\r\n\r\n        // no need to transfer if seller is the contract\r\n        if (_holding.owner != address(this)) {\r\n            _holding.owner.transfer(SafeMath.div(SafeMath.mul(payment, 100 - commissionPoints), 100));\r\n        }\r\n\r\n        Transfer(_holding.owner, msg.sender, _tokenId, sharesFulfilled);\r\n    }\r\n\r\n    function _purchaseLoopFifo(uint256 _tokenId, uint256 _sharesToFulfill)\r\n        private\r\n        returns (uint256 sharesFulfilled, uint256 totalPayment) {\r\n        uint256 prevFifoKey = HEAD;\r\n        uint256 fifoKey = FifoLib.next(fifo[_tokenId], HEAD);\r\n        while (fifoKey != HEAD) {\r\n            Holding storage holding = fifoStorage[_tokenId][fifoKey];\r\n\r\n            assert(holding.shares > 0);\r\n\r\n            if (holding.owner != msg.sender) {\r\n                uint256 itemSharesFulfilled;\r\n                uint256 itemPayment;\r\n                (itemSharesFulfilled, itemPayment) = _purchaseProcessFifoItem(_tokenId, holding, SafeMath.sub(_sharesToFulfill, sharesFulfilled));\r\n\r\n                sharesFulfilled += itemSharesFulfilled;\r\n                totalPayment += itemPayment;\r\n\r\n                if (holding.shares == 0) {\r\n                    // delete the record from fifo\r\n                    FifoLib.remove(fifo[_tokenId], prevFifoKey, fifoKey);\r\n                    fifoKey = prevFifoKey;\r\n                }\r\n            }\r\n\r\n            if (sharesFulfilled == _sharesToFulfill) break;\r\n\r\n            prevFifoKey = fifoKey;\r\n            fifoKey = FifoLib.next(fifo[_tokenId], fifoKey);\r\n        }  \r\n    }\r\n\r\n    function purchase(uint256 _tokenId, uint256 _shares) public payable {\r\n        require(_sharesValid(_tokenId, _shares));\r\n        require(companyIndexToOwners[_tokenId][msg.sender] + _shares <= TOTAL_SHARES);\r\n\r\n        uint256 estimatedPayment = estimatePurchasePayment(_tokenId, _shares);\r\n\r\n        require(msg.value >= estimatedPayment);\r\n\r\n        uint256 sharesFulfilled;\r\n        uint256 totalPayment;\r\n        (sharesFulfilled, totalPayment) = _purchaseLoopFifo(_tokenId, _shares);\r\n\r\n        assert(sharesFulfilled == _shares);\r\n        assert(totalPayment == estimatedPayment);\r\n\r\n        uint256 purchaseExess = SafeMath.sub(msg.value, totalPayment);\r\n        assert(purchaseExess >= 0);\r\n\r\n        if (purchaseExess > 0) {\r\n            msg.sender.transfer(purchaseExess);\r\n        }\r\n\r\n        fifoStorage[_tokenId][FifoLib.pushTail(fifo[_tokenId], _nextFifoStorageKey(_tokenId))] = Holding({owner: msg.sender, shares: _shares});\r\n\r\n        companyIndexToOwners[_tokenId][msg.sender] += _shares;\r\n\r\n        if (companyIndexToOwners[_tokenId][msg.sender] > companyIndexToOwners[_tokenId][companyIndexToChairman[_tokenId]]) {\r\n            companyIndexToChairman[_tokenId] = msg.sender;\r\n        }\r\n    }\r\n\r\n    function estimatePurchasePayment(uint256 _tokenId, uint256 _shares) public view returns (uint256) {\r\n        require(_shares <= TOTAL_SHARES);\r\n\r\n        uint256 currentPrice = companyIndexToPrice[_tokenId];\r\n\r\n        uint256 currentPriceShares = Math.min(_shares, TOTAL_SHARES - circulationCounters[_tokenId] % TOTAL_SHARES);\r\n        return SafeMath.add(\r\n            SafeMath.div(SafeMath.mul(currentPrice, currentPriceShares), TOTAL_SHARES),\r\n            SafeMath.div(SafeMath.mul(nextPrice(_tokenId, currentPrice), _shares - currentPriceShares), TOTAL_SHARES)\r\n        );\r\n    }\r\n\r\n    function nextPrice(uint256 _tokenId, uint256 _currentPrice) public view returns (uint256) {\r\n        uint256 price;\r\n        if (_currentPrice < firstStepLimit) {\r\n          // first stage\r\n          price = SafeMath.div(SafeMath.mul(_currentPrice, 200), 100);\r\n        } else if (_currentPrice < secondStepLimit) {\r\n          // second stage\r\n          price = SafeMath.div(SafeMath.mul(_currentPrice, 120), 100);\r\n        } else {\r\n          // third stage\r\n          price = SafeMath.div(SafeMath.mul(_currentPrice, 115), 100);\r\n        }\r\n\r\n        return price - price % 100;\r\n    }\r\n\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        uint256 _shares\r\n    ) public {\r\n        require(_addressNotNull(_to));\r\n        require(_sharesValid(_tokenId, _shares));\r\n        require(_owns(msg.sender, _tokenId, _shares));\r\n\r\n        _transfer(msg.sender, _to, _tokenId, _shares);\r\n    }\r\n\r\n    function transferFromContract(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        uint256 _shares\r\n    ) public onlyCOO {\r\n        address from = address(this);\r\n        require(_addressNotNull(_to));\r\n        require(_sharesValid(_tokenId, _shares));\r\n        require(_owns(from, _tokenId, _shares));\r\n\r\n        _transfer(from, _to, _tokenId, _shares);\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId, uint256 _shares) private {\r\n        if (_from != address(0)) {\r\n            uint256 sharesToFulfill = _shares;\r\n\r\n            uint256 fifoKey = FifoLib.next(fifo[_tokenId], HEAD);\r\n            while (fifoKey != HEAD) {\r\n                Holding storage holding = fifoStorage[_tokenId][fifoKey];\r\n\r\n                assert(holding.shares > 0);\r\n\r\n                if (holding.owner == _from) {\r\n                    uint256 fulfilled = Math.min(holding.shares, sharesToFulfill);\r\n\r\n                    if (holding.shares == fulfilled) {\r\n                        // if all shares are taken, just modify the owner address in place\r\n                        holding.owner = _to;\r\n                    } else {\r\n                        // underflow is not possible because deduction is the minimun of the two\r\n                        holding.shares -= fulfilled;\r\n\r\n                        // insert a new holding record\r\n                        fifoStorage[_tokenId][FifoLib.insert(fifo[_tokenId], fifoKey, _nextFifoStorageKey(_tokenId))] = Holding({owner: _to, shares: fulfilled});\r\n\r\n                        fifoKey = FifoLib.next(fifo[_tokenId], fifoKey);\r\n                        // now fifoKey points to the newly inserted one \r\n                    }\r\n\r\n                    // underflow is not possible because deduction is the minimun of the two\r\n                    sharesToFulfill -= fulfilled;\r\n                }\r\n\r\n                if (sharesToFulfill == 0) break;\r\n\r\n                fifoKey = FifoLib.next(fifo[_tokenId], fifoKey);\r\n            }\r\n\r\n            require(sharesToFulfill == 0);\r\n\r\n            companyIndexToOwners[_tokenId][_from] -= _shares;\r\n        } else {\r\n            // genesis transfer\r\n            fifoStorage[_tokenId][FifoLib.pushTail(fifo[_tokenId], _nextFifoStorageKey(_tokenId))] = Holding({owner: _to, shares: _shares});\r\n        }\r\n\r\n        companyIndexToOwners[_tokenId][_to] += _shares;\r\n\r\n        if (companyIndexToOwners[_tokenId][_to] > companyIndexToOwners[_tokenId][companyIndexToChairman[_tokenId]]) {\r\n            companyIndexToChairman[_tokenId] = _to;\r\n        }\r\n\r\n        // Emit the transfer event.\r\n        Transfer(_from, _to, _tokenId, _shares);\r\n    }\r\n\r\n    function _sharesValid(uint256 _tokenId, uint256 _shares) private view returns (bool) {\r\n        return (_shares > 0 && _shares <= TOTAL_SHARES) &&\r\n            (shareTradingEnabled[_tokenId] || _shares == TOTAL_SHARES);\r\n    }\r\n\r\n    function _nextFifoStorageKey(uint256 _tokenId) private returns (uint256) {\r\n        return ++fifoStorageKey[_tokenId];\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a > b) return a;\r\n        else return b;\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) return a;\r\n        else return b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"promoCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"shareHoldersOf\",\"outputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"shares\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setShareTradingEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCompanies\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"estimatePurchasePayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCompany\",\"outputs\":[{\"name\":\"companyName\",\"type\":\"string\"},{\"name\":\"isShareTradingEnabled\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"_nextPrice\",\"type\":\"uint256\"},{\"name\":\"chairman\",\"type\":\"address\"},{\"name\":\"circulations\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"transferFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_currentPrice\",\"type\":\"uint256\"}],\"name\":\"nextPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"createPromoCompany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"sharesOwned\",\"outputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"chairmanOf\",\"outputs\":[{\"name\":\"chairman\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"priceOf\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"companyIndexToOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_point\",\"type\":\"uint256\"}],\"name\":\"setCommissionPoints\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"createContractCompany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Founded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOnwer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"SharesSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CompanyToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3443e8b131d96fc670eca2934e8ed4d82a264841da4dce8e44cd1f1ba7a87b66"}]}