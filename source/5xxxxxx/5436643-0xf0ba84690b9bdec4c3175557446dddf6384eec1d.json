{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract ERC721Abstract\r\n{\r\n\tfunction implementsERC721() public pure returns (bool);\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 _tokenId) public view returns (address owner);\r\n\tfunction approve(address _to, uint256 _tokenId) public;\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\tfunction transfer(address _to, uint256 _tokenId) public;\r\n \r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n\t// Optional\r\n\t// function totalSupply() public view returns (uint256 total);\r\n\t// function name() public view returns (string name);\r\n\t// function symbol() public view returns (string symbol);\r\n\t// function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\r\n\t// function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\r\n}\r\ncontract ERC721 is ERC721Abstract\r\n{\r\n\tstring constant public   name = \"NBA ONLINE\";\r\n\tstring constant public symbol = \"Ticket\";\r\n\r\n\tuint256 public totalSupply;\r\n\tstruct Token\r\n\t{\r\n\t\tuint256 price;\t\t\t//  value of stake\r\n\t\tuint256\toption;\t\t\t//  [payout]96[idLottery]64[combination]32[dateBuy]0\r\n\t}\r\n\tmapping (uint256 => Token) tokens;\r\n\t\r\n\t// A mapping from tokens IDs to the address that owns them. All tokens have some valid owner address\r\n\tmapping (uint256 => address) public tokenIndexToOwner;\r\n\t\r\n\t// A mapping from owner address to count of tokens that address owns.\t\r\n\tmapping (address => uint256) ownershipTokenCount; \r\n\r\n\t// A mapping from tokenIDs to an address that has been approved to call transferFrom().\r\n\t// Each token can only have one approved address for transfer at any time.\r\n\t// A zero value means no approval is outstanding.\r\n\tmapping (uint256 => address) public tokenIndexToApproved;\r\n\t\r\n\tfunction implementsERC721() public pure returns (bool)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) public view returns (uint256 count) \r\n\t{\r\n\t\treturn ownershipTokenCount[_owner];\r\n\t}\r\n\t\r\n\tfunction ownerOf(uint256 _tokenId) public view returns (address owner)\r\n\t{\r\n\t\towner = tokenIndexToOwner[_tokenId];\r\n\t\trequire(owner != address(0));\r\n\t}\r\n\t\r\n\t// Marks an address as being approved for transferFrom(), overwriting any previous approval. \r\n\t// Setting _approved to address(0) clears all transfer approval.\r\n\tfunction _approve(uint256 _tokenId, address _approved) internal \r\n\t{\r\n\t\ttokenIndexToApproved[_tokenId] = _approved;\r\n\t}\r\n\t\r\n\t// Checks if a given address currently has transferApproval for a particular token.\r\n\t// param _claimant the address we are confirming token is approved for.\r\n\t// param _tokenId token id, only valid when > 0\r\n\tfunction _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n\t\treturn tokenIndexToApproved[_tokenId] == _claimant;\r\n\t}\r\n\t\r\n\tfunction approve( address _to, uint256 _tokenId ) public\r\n\t{\r\n\t\t// Only an owner can grant transfer approval.\r\n\t\trequire(_owns(msg.sender, _tokenId));\r\n\r\n\t\t// Register the approval (replacing any previous approval).\r\n\t\t_approve(_tokenId, _to);\r\n\r\n\t\t// Emit approval event.\r\n\t\temit Approval(msg.sender, _to, _tokenId);\r\n\t}\r\n\t\r\n\tfunction transferFrom( address _from, address _to, uint256 _tokenId ) public\r\n\t{\r\n\t\t// Check for approval and valid ownership\r\n\t\trequire(_approvedFor(msg.sender, _tokenId));\r\n\t\trequire(_owns(_from, _tokenId));\r\n\r\n\t\t// Reassign ownership (also clears pending approvals and emits Transfer event).\r\n\t\t_transfer(_from, _to, _tokenId);\r\n\t}\r\n\t\r\n\tfunction _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n\t\treturn tokenIndexToOwner[_tokenId] == _claimant;\r\n\t}\r\n\t\r\n\tfunction _transfer(address _from, address _to, uint256 _tokenId) internal \r\n\t{\r\n\t\townershipTokenCount[_to]++;\r\n\t\ttokenIndexToOwner[_tokenId] = _to;\r\n\r\n\t\tif (_from != address(0)) \r\n\t\t{\r\n\t\t\temit Transfer(_from, _to, _tokenId);\r\n\t\t\townershipTokenCount[_from]--;\r\n\t\t\t// clear any previously approved ownership exchange\r\n\t\t\tdelete tokenIndexToApproved[_tokenId];\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction transfer(address _to, uint256 _tokenId) public\r\n\t{\r\n\t\trequire(_to != address(0));\r\n\t\trequire(_owns(msg.sender, _tokenId));\r\n\t\t_transfer(msg.sender, _to, _tokenId);\r\n\t}\r\n\r\n}\r\ncontract Owned \r\n{\r\n    address private candidate;\r\n\taddress public owner;\r\n\r\n\tmapping(address => bool) public admins;\r\n\t\r\n    function Owned() public \r\n\t{\r\n        owner = msg.sender;\r\n        admins[owner] = true;\r\n    }\r\n\r\n    function changeOwner(address newOwner) public \r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n        candidate = newOwner;\r\n    }\r\n\t\r\n\tfunction confirmOwner() public \r\n\t{\r\n        require(candidate == msg.sender); // run by name=candidate\r\n\t\towner = candidate;\r\n    }\r\n\t\r\n    function addAdmin(address addr) external \r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n        admins[addr] = true;\r\n    }\r\n\r\n    function removeAdmin(address addr) external\r\n\t{\r\n\t\trequire(msg.sender == owner);\r\n        admins[addr] = false;\r\n    }\r\n}\r\ncontract Functional\r\n{\r\n\t// parseInt(parseFloat*10^_b)\r\n\tfunction parseInt(string _a, uint _b) internal pure returns (uint) \r\n\t{\r\n\t\tbytes memory bresult = bytes(_a);\r\n\t\tuint mint = 0;\r\n\t\tbool decimals = false;\r\n\t\tfor (uint i=0; i<bresult.length; i++){\r\n\t\t\tif ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n\t\t\t\tif (decimals){\r\n\t\t\t\t   if (_b == 0) break;\r\n\t\t\t\t\telse _b--;\r\n\t\t\t\t}\r\n\t\t\t\tmint *= 10;\r\n\t\t\t\tmint += uint(bresult[i]) - 48;\r\n\t\t\t} else if (bresult[i] == 46) decimals = true;\r\n\t\t}\r\n\t\tif (_b > 0) mint *= 10**_b;\r\n\t\treturn mint;\r\n\t}\r\n\t\r\n\tfunction uint2str(uint i) internal pure returns (string)\r\n\t{\r\n\t\tif (i == 0) return \"0\";\r\n\t\tuint j = i;\r\n\t\tuint len;\r\n\t\twhile (j != 0){\r\n\t\t\tlen++;\r\n\t\t\tj /= 10;\r\n\t\t}\r\n\t\tbytes memory bstr = new bytes(len);\r\n\t\tuint k = len - 1;\r\n\t\twhile (i != 0){\r\n\t\t\tbstr[k--] = byte(48 + i % 10);\r\n\t\t\ti /= 10;\r\n\t\t}\r\n\t\treturn string(bstr);\r\n\t}\r\n\t\r\n\tfunction strConcat(string _a, string _b, string _c) internal pure returns (string)\r\n\t{\r\n\t\tbytes memory _ba = bytes(_a);\r\n\t\tbytes memory _bb = bytes(_b);\r\n\t\tbytes memory _bc = bytes(_c);\r\n\t\tstring memory abc;\r\n\t\tuint k = 0;\r\n\t\tuint i;\r\n\t\tbytes memory babc;\r\n\t\tif (_ba.length==0)\r\n\t\t{\r\n\t\t\tabc = new string(_bc.length);\r\n\t\t\tbabc = bytes(abc);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tabc = new string(_ba.length + _bb.length+ _bc.length);\r\n\t\t\tbabc = bytes(abc);\r\n\t\t\tfor (i = 0; i < _ba.length; i++) babc[k++] = _ba[i];\r\n\t\t\tfor (i = 0; i < _bb.length; i++) babc[k++] = _bb[i];\r\n\t\t}\r\n        for (i = 0; i < _bc.length; i++) babc[k++] = _bc[i];\r\n\t\treturn string(babc);\r\n\t}\r\n\t\r\n\tfunction timenow() public view returns(uint32) { return uint32(block.timestamp); }\r\n}\r\ncontract NBAONLINE is Functional,Owned,ERC721{\r\n    using SafeMath for uint256;\r\n    \r\n    enum STATUS {\r\n\t\tNOTFOUND,\t\t//0 game not created\r\n\t\tPLAYING,\t\t//1 buying tickets for players\r\n\t\tPROCESSING,\t\t//2 waiting for result\r\n\t\tPAYING,\t \t\t//3 redeeming\r\n\t\tREFUNDING\t\t//4 canceling the game\r\n\t}\r\n    struct Game{\r\n        string name;                                //GameName\r\n        uint256 id;                                 //Game ID\r\n        uint256 totalPot;                           //Total Deposit \r\n        uint256 totalWinnersDeposit;                //Total Winner Deposit\r\n        uint256 dateStopBuy;                        //Deadline of buying tickets of the game\r\n        STATUS status;                              //Game Status \r\n        mapping(uint8=>uint256)potDetail;           //The amount of each player in a Game\r\n        mapping(uint8=>uint8)result;                //The results of 30 players in a game 0:Lose 1: Win\r\n    }\r\n    mapping(uint256=>Game)private games;            //id find game\r\n    uint256[] private gameIdList;\r\n    \r\n    uint256 private constant min_amount = 0.005 ether;\r\n    uint256 private constant max_amount = 1000 ether;\r\n    \r\n    function NBAONLINE () public {\r\n    }\r\n\r\n    /* Modifiers */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n    modifier onlyAdmin {\r\n        require(msg.sender == owner || admins[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function addOneGame(string _name,uint256 _deadline)onlyAdmin() external{\r\n        uint256 _id = gameIdList.length;\r\n        require(games[_id].status == STATUS.NOTFOUND);\r\n        require( _deadline > timenow() );\r\n        games[_id] = Game(_name,_id,0,0,_deadline,STATUS.PLAYING);\r\n        gameIdList.push(_id);\r\n    }\r\n    function getGamesLength()public view returns(uint256 length){\r\n        return gameIdList.length;\r\n    }\r\n    function calculateDevCut (uint256 _price) public pure returns (uint256 _devCut) {\r\n        return _price.mul(5).div(100); // 5%\r\n    }\r\n    function generateTicketData(uint256 idLottery, uint8 combination,uint8 status) public view returns(uint256 packed){\r\n        packed = (uint256(status) << 12*8) + ( uint256(idLottery) << 8*8 ) + ( uint256(combination) << 4*8 ) + uint256(block.timestamp);\r\n    }\r\n    \r\n    function parseTicket(uint256\tpacked)public pure returns(uint8 payout,uint256 idLottery,uint256 combination,uint256 dateBuy){\r\n\t\tpayout = uint8((packed >> (12*8)) & 0xFF);\r\n\t\tidLottery   = uint256((packed >> (8*8)) & 0xFFFFFFFF);\r\n\t\tcombination = uint256((packed >> (4*8)) & 0xFFFFFFFF);\r\n\t\tdateBuy     = uint256(packed & 0xFFFFFFFF);\r\n    }\r\n    \r\n    function updateTicketStatus(uint256\tpacked,uint8 newStatus)public pure returns(uint256 npacked){\r\n\t\tuint8 payout = uint8((packed >> (12*8)) & 0xFF);\r\n\t\tnpacked = packed + (uint256(newStatus-payout)<< 12*8);\r\n    }\r\n    function buyTicket(uint256 _id, uint8 _choose)payable external{\r\n        Game storage curGame = games[_id];\r\n        require(curGame.status == STATUS.PLAYING);\r\n        require( timenow() < curGame.dateStopBuy );\r\n        require(msg.value >= min_amount);\r\n        require(msg.value <= max_amount);\r\n        require(_choose < 30&&_choose >= 0);\r\n        uint256 dev = calculateDevCut(msg.value);\r\n        uint256 deposit = msg.value.sub(dev);\r\n        curGame.totalPot = curGame.totalPot.add(deposit);\r\n        curGame.potDetail[_choose] = curGame.potDetail[_choose].add(deposit);\r\n\r\n\t\tToken memory _token = Token({\r\n\t\t\tprice: deposit,\r\n\t\t\toption : generateTicketData(_id,_choose,0)\r\n\t\t});\r\n\r\n\t\tuint256 newTokenId = totalSupply++;\r\n\t\ttokens[newTokenId] = _token;\r\n\t\t_transfer(0, msg.sender, newTokenId);\r\n\r\n        if(dev > 0){\r\n            owner.transfer(dev);\r\n        }\r\n    }\r\n    function cancelTicket(uint256 _tid)payable external{\r\n        //confirm ownership\r\n        require(tokenIndexToOwner[_tid] == msg.sender);\r\n        Token storage _token = tokens[_tid];\r\n        uint256 gameId   = uint256((_token.option >> (8*8)) & 0xFFFFFFFF);\r\n        Game storage curGame = games[gameId];\r\n        //confirm game status\r\n        require(curGame.status == STATUS.PLAYING);\r\n        //confirm game time \r\n        require( timenow() < curGame.dateStopBuy );\r\n        uint8 ticketStatus = uint8((_token.option >> (12*8)) & 0xFF);\r\n        //confirm ticket status\r\n        require(ticketStatus == 0);\r\n        uint256 refundFee = _token.price;\r\n        //confirm ticket price\r\n        require(refundFee > 0);\r\n        uint8 _choose = uint8((_token.option >> (4*8)) & 0xFFFFFFFF);\r\n        curGame.totalPot = curGame.totalPot.sub(refundFee);\r\n        curGame.potDetail[_choose] = curGame.potDetail[_choose].sub(refundFee);\r\n        _token.option = updateTicketStatus(_token.option,3);\r\n        msg.sender.transfer(refundFee);\r\n    }\r\n    function openResult(uint256 _id,uint8[] _result)onlyAdmin() external{\r\n        Game storage curGame = games[_id];\r\n        require(curGame.status == STATUS.PLAYING);\r\n        require(timenow() > curGame.dateStopBuy + 2*60*60);\r\n        \r\n        uint256 _totalWinnersDeposit = 0;\r\n        for(uint256 i=0; i< _result.length; i++){\r\n            require(_result[i]<30&&_result[i]>=0);\r\n            curGame.result[_result[i]] = 1;\r\n            _totalWinnersDeposit = _totalWinnersDeposit.add(curGame.potDetail[_result[i]]);\r\n        }\r\n        if(_totalWinnersDeposit > 0){\r\n            curGame.status = STATUS.PAYING;\r\n            curGame.totalWinnersDeposit = _totalWinnersDeposit;\r\n        }else{\r\n            curGame.status = STATUS.REFUNDING;\r\n        }\r\n    }\r\n\r\n    \r\n    function getWinningPrize(uint256 _tid)payable external{\r\n        require(tokenIndexToOwner[_tid] == msg.sender);\r\n        Token storage _token = tokens[_tid];\r\n        uint8 _choose = uint8((_token.option >> (4*8)) & 0xFFFFFFFF);\r\n        uint256 gameId   = uint256((_token.option >> (8*8)) & 0xFFFFFFFF);\r\n        Game storage curGame = games[gameId];\r\n        //confirm game status\r\n        require(curGame.status == STATUS.PAYING);\r\n        require(curGame.result[_choose] == 1);\r\n        require(curGame.totalWinnersDeposit > 0);\r\n        require(curGame.totalPot > 0);\r\n        uint8 ticketStatus = uint8((_token.option >> (12*8)) & 0xFF);\r\n        //confirm ticket status\r\n        require(ticketStatus == 0);\r\n        uint256 paybase = _token.price;\r\n        //confirm ticket price\r\n        require(paybase > 0);\r\n        uint256 winningPrize = 0;\r\n        if(curGame.totalWinnersDeposit > 0){\r\n            winningPrize = (paybase.mul(curGame.totalPot)).div(curGame.totalWinnersDeposit);\r\n        }\r\n        if(winningPrize > 0){\r\n            _token.option = updateTicketStatus(_token.option,1);\r\n            msg.sender.transfer(winningPrize);\r\n        }\r\n    }\r\n    function getRefund(uint256 _tid)payable external{\r\n        //confirm ownership\r\n        require(tokenIndexToOwner[_tid] == msg.sender);\r\n        Token storage _token = tokens[_tid];\r\n        uint256 gameId   = uint256((_token.option >> (8*8)) & 0xFFFFFFFF);\r\n        Game storage curGame = games[gameId];\r\n        //confirm game status\r\n        require(curGame.status == STATUS.REFUNDING);\r\n        require(curGame.totalWinnersDeposit == 0);\r\n        require(curGame.totalPot > 0);\r\n        uint8 ticketStatus = uint8((_token.option >> (12*8)) & 0xFF);\r\n        //confirm ticket status\r\n        require(ticketStatus == 0);\r\n        uint256 refundFee = _token.price;\r\n        //confirm ticket price\r\n        require(refundFee > 0);\r\n  \r\n        _token.option = updateTicketStatus(_token.option,2);\r\n        msg.sender.transfer(refundFee);\r\n    }\r\n    function getGameInfoById(uint256 _id)public view returns(\r\n    uint256 _totalPot,\r\n    uint256 _totalWinnersDeposit,\r\n    uint256 _dateStopBuy,\r\n    uint8 _gameStatus,\r\n    string _potDetail, \r\n    string _results,\r\n    string _name\r\n    )\r\n    {\r\n        Game storage curGame = games[_id];\r\n        _potDetail = \"\";\r\n        _results = \"\";\r\n        for(uint8 i=0;i<30;i++){\r\n            _potDetail = strConcat(_potDetail,\",\",uint2str(curGame.potDetail[i]));\r\n            _results = strConcat(_results,\",\",uint2str(curGame.result[i]));\r\n        }\r\n        _totalPot = curGame.totalPot;\r\n        _totalWinnersDeposit = curGame.totalWinnersDeposit;\r\n        _dateStopBuy = curGame.dateStopBuy;\r\n        _name = curGame.name;\r\n        _gameStatus = uint8(curGame.status);\r\n        if ( curGame.status == STATUS.PLAYING && timenow() > _dateStopBuy ) _gameStatus = uint8(STATUS.PROCESSING);\r\n    }\r\n    function getAllGames(bool onlyPlaying,uint256 from, uint256 to)public view returns(string gameInfoList){\r\n        gameInfoList = \"\";\r\n        uint256 counter = 0;\r\n        for(uint256 i=0; i<gameIdList.length; i++){\r\n            if(counter < from){\r\n                counter++;\r\n                continue;\r\n            }\r\n            if(counter > to){\r\n                break;\r\n            }\r\n            if((onlyPlaying&&games[gameIdList[i]].status == STATUS.PLAYING && timenow() < games[gameIdList[i]].dateStopBuy)||onlyPlaying==false){\r\n                gameInfoList = strConcat(gameInfoList,\"|\",uint2str(games[gameIdList[i]].id));\r\n                gameInfoList = strConcat(gameInfoList,\",\",games[gameIdList[i]].name);\r\n                gameInfoList = strConcat(gameInfoList,\",\",uint2str(games[gameIdList[i]].totalPot));\r\n                gameInfoList = strConcat(gameInfoList,\",\",uint2str(games[gameIdList[i]].dateStopBuy));\r\n                if(games[gameIdList[i]].status == STATUS.PLAYING && timenow() > games[gameIdList[i]].dateStopBuy){\r\n                    gameInfoList = strConcat(gameInfoList,\",\",uint2str(uint(STATUS.PROCESSING)));\r\n                }else{\r\n                    gameInfoList = strConcat(gameInfoList,\",\",uint2str(uint(games[gameIdList[i]].status)));\r\n                }\r\n                counter++;\r\n            }\r\n        }\r\n    }\r\n        \r\n    function getMyTicketList(bool active,uint256 from, uint256 to)public view returns(string info){\r\n        info = \"\";\r\n        uint256 counter = 0;\r\n        if(ownershipTokenCount[msg.sender] > 0){\r\n            for(uint256 i=0; i<totalSupply; i++){\r\n                if(tokenIndexToOwner[i] == msg.sender){\r\n                    if(counter < from){\r\n                        counter++;\r\n                        continue;\r\n                    }\r\n                    if(counter > to){\r\n                        break;\r\n                    }\r\n                    \r\n                    Token memory _token = tokens[i];\r\n                    uint256 gameId = uint256((_token.option >> (8*8)) & 0xFFFFFFFF);\r\n                    uint256 tStatus = uint256((_token.option >> (12*8)) & 0xFF);\r\n                    uint256 dateBuy = uint256(_token.option & 0xFFFFFFFF);\r\n                    uint256 _choose = uint256((_token.option >> (4*8)) & 0xFFFFFFFF);\r\n                    uint256 otherpick = getNumbersOfPick(gameId,uint8(_choose));\r\n                    Game storage curGame = games[gameId];\r\n                    if((active&&(tStatus == 0&&(curGame.status == STATUS.PLAYING||(curGame.result[uint8(_choose)] == 1&&curGame.status == STATUS.PAYING)||curGame.status == STATUS.REFUNDING)))||active == false){\r\n                        info = strConcat(info,\"|\",uint2str(i));\r\n                        info = strConcat(info,\",\",uint2str(gameId));\r\n                        info = strConcat(info,\",\",uint2str(_token.price));\r\n                        info = strConcat(info,\",\",uint2str(dateBuy));\r\n                        info = strConcat(info,\",\",uint2str(_choose));\r\n                        info = strConcat(info,\",\",uint2str(otherpick));\r\n                        info = strConcat(info,\",\",uint2str(tStatus));\r\n                        if(curGame.status == STATUS.PLAYING && timenow() > curGame.dateStopBuy){\r\n                            info = strConcat(info,\",\",uint2str(uint(STATUS.PROCESSING)));\r\n                        }else{\r\n                            info = strConcat(info,\",\",uint2str(uint(curGame.status)));\r\n                        }\r\n                        if(tStatus == 3||curGame.potDetail[uint8(_choose)]==0){\r\n                            info = strConcat(info,\",\",uint2str(0));//Canceled ticket\r\n                        }else{\r\n                            if(curGame.totalWinnersDeposit > 0){\r\n                                if(curGame.result[uint8(_choose)]==1){\r\n                                    //Win ticket\r\n                                    info = strConcat(info,\",\",uint2str(_token.price.mul(curGame.totalPot).div(curGame.totalWinnersDeposit)));\r\n                                }else{\r\n                                    //Lose ticket\r\n                                    info = strConcat(info,\",\",uint2str(_token.price.mul(curGame.totalPot).div(curGame.potDetail[uint8(_choose)])));\r\n                                }\r\n                            }else{\r\n                                //Pending or Processing\r\n                                info = strConcat(info,\",\",uint2str(_token.price.mul(curGame.totalPot).div(curGame.potDetail[uint8(_choose)])));\r\n                            }\r\n                        }\r\n                        if(curGame.status == STATUS.PAYING&&curGame.result[uint8(_choose)] == 1){\r\n                            info = strConcat(info,\",\",uint2str(1));\r\n                        }else {\r\n                            info = strConcat(info,\",\",uint2str(0));\r\n                        }\r\n                        info = strConcat(info,\",\",uint2str(curGame.totalPot));\r\n                    }\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getNumbersOfPick(uint256 _gid, uint8 _pick)public view returns(uint256 num){\r\n        require(_pick < 30&&_pick >= 0);\r\n        Game storage curGame = games[_gid];\r\n        num = 0;\r\n        for(uint256 i=0; i<totalSupply; i++){\r\n            uint256 data = tokens[i].option;\r\n            uint256 _gameId = uint256((data >> (8*8)) & 0xFFFFFFFF);\r\n            if(curGame.id == _gameId){\r\n                uint8 _choose = uint8((data >> (4*8)) & 0xFFFFFFFF);\r\n                uint8 tStatus = uint8((data >> (12*8)) & 0xFF);\r\n                if(_pick == _choose&&tStatus!=3){\r\n                    num++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_result\",\"type\":\"uint8[]\"}],\"name\":\"openResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"onlyPlaying\",\"type\":\"bool\"},{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"getAllGames\",\"outputs\":[{\"name\":\"gameInfoList\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idLottery\",\"type\":\"uint256\"},{\"name\":\"combination\",\"type\":\"uint8\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"generateTicketData\",\"outputs\":[{\"name\":\"packed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"packed\",\"type\":\"uint256\"}],\"name\":\"parseTicket\",\"outputs\":[{\"name\":\"payout\",\"type\":\"uint8\"},{\"name\":\"idLottery\",\"type\":\"uint256\"},{\"name\":\"combination\",\"type\":\"uint256\"},{\"name\":\"dateBuy\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timenow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gid\",\"type\":\"uint256\"},{\"name\":\"_pick\",\"type\":\"uint8\"}],\"name\":\"getNumbersOfPick\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"calculateDevCut\",\"outputs\":[{\"name\":\"_devCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGamesLength\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"packed\",\"type\":\"uint256\"},{\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"updateTicketStatus\",\"outputs\":[{\"name\":\"npacked\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"addOneGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"getMyTicketList\",\"outputs\":[{\"name\":\"info\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"getRefund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getGameInfoById\",\"outputs\":[{\"name\":\"_totalPot\",\"type\":\"uint256\"},{\"name\":\"_totalWinnersDeposit\",\"type\":\"uint256\"},{\"name\":\"_dateStopBuy\",\"type\":\"uint256\"},{\"name\":\"_gameStatus\",\"type\":\"uint8\"},{\"name\":\"_potDetail\",\"type\":\"string\"},{\"name\":\"_results\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"getWinningPrize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_choose\",\"type\":\"uint8\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"cancelTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"NBAONLINE","CompilerVersion":"v0.4.21-nightly.2018.3.7+commit.bd7bc7c4","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bfce57bf6a4f91f9da68adbb47572f6644e17ebbeea1059357a1aada19ce9e06"}]}