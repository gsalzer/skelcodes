{"status":"1","message":"OK","result":[{"SourceCode":"/* LeewayHertz - AIG - Investment v0.79 - Pre-Prod\r\n*  Developed and Deployed by LeewayHertz Blockchain Team C - Dhruv Govila, Rajat Singla, Jayesh Chaudhari, Deepak Shokeen, Raghav Gulati, Rohit Tandon\r\n*  Global Repo Name: CA-LHTAIGLenderPlatform\r\n*/\r\n\r\ncontract AIGInvestment {\r\n    uint constant LONG_PHASE = 4;               \r\n    uint constant SHORT_PHASE = 5;              \r\n    uint constant HOUSE_EDGE = 2;               \r\n    uint constant SAFEGUARD_THRESHOLD = 36000;  \r\n    uint constant ARCHIVE_SIZE = 100;           \r\n\r\n    uint public minWager = 500 finney;\r\n    uint public maxNumInterests = 25;\r\n    uint public bankroll = 0;\r\n    int public profit = 0;\r\n\r\n    address public investor;\r\n    uint public investorBankroll = 0;\r\n    int public investorProfit = 0;\r\n    bool public isInvestorLocked = false;\r\n\r\n    struct Interest {\r\n        uint id;\r\n        address borrower;\r\n        uint8 pick;\r\n        bool isMirrored;\r\n        uint wager;\r\n        uint payout;\r\n        uint8 die;\r\n        uint timestamp;\r\n        address lender;\r\n    }\r\n\r\n    struct Generation {\r\n        bytes32 seedHashA;\r\n        bytes32 seedHashB;\r\n        bytes32 seedA;\r\n        bytes32 seedB;\r\n        uint minWager;\r\n        uint maxPayout;\r\n        uint ofage;\r\n        uint death;\r\n        uint beneficiary;\r\n        Interest[] interests;\r\n        bool hasAction;\r\n        Action action;\r\n        int payoutId;\r\n    }\r\n\r\n    uint public oldestGen = 0;\r\n    uint public nextGen = 0;\r\n    mapping (uint => Generation) generations;\r\n\r\n    address public owner;\r\n    address public seedSourceA;\r\n    address public seedSourceB;\r\n\r\n    bytes32 public nextSeedHashA;\r\n    bytes32 public nextSeedHashB;\r\n    bool public hasNextSeedHashA;\r\n    bool public hasNextSeedHashB;\r\n\r\n    uint public outstandingPayouts;\r\n    uint public totalInterests;\r\n\r\n    struct Suitability {\r\n        bool isSuitable;\r\n        uint gen;\r\n    }\r\n\r\n    struct ParserResult {\r\n        bool hasResult;\r\n        uint8 pick;\r\n        bool isMirrored;\r\n        uint8 die;\r\n    }\r\n\r\n    enum ActionType { Withdrawal, InvestorDeposit, InvestorWithdrawal }\r\n\r\n    struct Action {\r\n        ActionType actionType;\r\n        address sender;\r\n        uint amount;\r\n    }\r\n\r\n    modifier onlyowner { if (msg.sender == owner) _; }\r\n    modifier onlyseedsources { if (msg.sender == seedSourceA ||\r\n                                   msg.sender == seedSourceB) _; }\r\n\r\n    event InterestResolved(uint indexed id, uint8 contractDie, bool lenderPrincipals);\r\n\r\n    function AIGInvestment() {\r\n        \r\n    }\r\n\r\n    function numberOfHealthyGenerations() returns (uint n) {\r\n        n = 0;\r\n        for (uint i = oldestGen; i < nextGen; i++) {\r\n            if (generations[i].death == 0) {\r\n                n++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function needsBirth() constant returns (bool needed) {\r\n        return numberOfHealthyGenerations() < 3;\r\n    }\r\n\r\n    function roomForBirth() constant returns (bool hasRoom) {\r\n        return numberOfHealthyGenerations() < 4;\r\n    }\r\n\r\n    function birth(bytes32 freshSeedHash) onlyseedsources {\r\n        if (msg.sender == seedSourceA) {\r\n            nextSeedHashA = freshSeedHash;\r\n            hasNextSeedHashA = true;\r\n        } else {\r\n            nextSeedHashB = freshSeedHash;\r\n            hasNextSeedHashB = true;\r\n        }\r\n\r\n        if (!hasNextSeedHashA || !hasNextSeedHashB || !roomForBirth()) {\r\n            return;\r\n        }\r\n\r\n        \r\n        generations[nextGen].seedHashA = nextSeedHashA;\r\n        generations[nextGen].seedHashB = nextSeedHashB;\r\n        generations[nextGen].minWager = minWager;\r\n        generations[nextGen].maxPayout = (bankroll + investorBankroll) / 100;\r\n        generations[nextGen].ofage = block.number + SHORT_PHASE;\r\n        nextGen += 1;\r\n\r\n        hasNextSeedHashA = false;\r\n        hasNextSeedHashB = false;\r\n    }\r\n\r\n    function parseMsgData(bytes data) internal constant returns (ParserResult) {\r\n        ParserResult memory result;\r\n\r\n        if (data.length != 8) {\r\n            result.hasResult = false;\r\n            return result;\r\n        }\r\n\r\n        \r\n        uint8 start = (uint8(data[0]) - 48) * 10 + (uint8(data[1]) - 48);\r\n        uint8 end = (uint8(data[3]) - 48) * 10 + (uint8(data[4]) - 48);\r\n        uint8 die = (uint8(data[6]) - 48) * 10 + (uint8(data[7]) - 48);\r\n\r\n        if (start == 1) {\r\n            result.hasResult = true;\r\n            result.pick = end + 1;\r\n            result.isMirrored = false;\r\n            result.die = die;\r\n        } else if (end == 20) {\r\n            result.hasResult = true;\r\n            result.pick = start;\r\n            result.isMirrored = true;\r\n            result.die = die;\r\n        } else {\r\n            result.hasResult = false;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function _parseMsgData(bytes data) constant returns (bool hasResult,\r\n                                                         uint8 pick,\r\n                                                         bool isMirrored,\r\n                                                         uint8 die) {\r\n        ParserResult memory result = parseMsgData(data);\r\n\r\n        hasResult = result.hasResult;\r\n        pick = result.pick;\r\n        isMirrored = result.isMirrored;\r\n        die = result.die;\r\n    }\r\n\r\n    function () {\r\n        ParserResult memory result = parseMsgData(msg.data);\r\n\r\n        if (result.hasResult) {\r\n            interest(result.pick, result.isMirrored, result.die);\r\n        } else {\r\n            interest(11, true,\r\n                toDie(sha3(block.blockhash(block.number - 1), totalInterests)));\r\n        }\r\n    }\r\n\r\n    function interest(uint8 pick, bool isMirrored, uint8 die) returns (int) {\r\n        if (pick < 2 || pick > 20) {\r\n            msg.sender.send(msg.value);\r\n            return -1;\r\n        }\r\n\r\n        if (die < 1 || die > 20) {\r\n            msg.sender.send(msg.value);\r\n            return -1;\r\n        }\r\n\r\n        Suitability memory suitability = findSuitableGen();\r\n        uint suitableGen = suitability.gen;\r\n\r\n        if (!suitability.isSuitable) {\r\n            msg.sender.send(msg.value);\r\n            return -1;\r\n        }\r\n\r\n        if (msg.value < generations[suitableGen].minWager) {\r\n            msg.sender.send(msg.value);\r\n            return -1;\r\n        }\r\n\r\n        uint payout = calculatePayout(pick, isMirrored, msg.value);\r\n        if (payout > generations[suitableGen].maxPayout) {\r\n            msg.sender.send(msg.value);\r\n            return -1;\r\n        }\r\n\r\n        if (outstandingPayouts + payout > bankroll + investorBankroll) {\r\n            msg.sender.send(msg.value);\r\n            return -1;\r\n        }\r\n\r\n        uint idx = generations[suitableGen].interests.length;\r\n        generations[suitableGen].interests.length += 1;\r\n        generations[suitableGen].interests[idx].id = totalInterests;\r\n        generations[suitableGen].interests[idx].lender = msg.sender;\r\n        generations[suitableGen].interests[idx].pick = pick;\r\n        generations[suitableGen].interests[idx].isMirrored = isMirrored;\r\n        generations[suitableGen].interests[idx].wager = msg.value;\r\n        generations[suitableGen].interests[idx].payout = payout;\r\n        generations[suitableGen].interests[idx].die = die;\r\n        generations[suitableGen].interests[idx].timestamp = now;\r\n\r\n        totalInterests += 1;\r\n        outstandingPayouts += payout;\r\n        becomeMortal(suitableGen);\r\n\r\n        return int(totalInterests - 1);  \r\n    }\r\n\r\n    function calculatePayout(uint8 pick, bool isMirrored,\r\n                             uint value) constant returns (uint) {\r\n        \r\n        \r\n        \r\n        uint numPrincipalningOutcomes;\r\n        if (isMirrored) {\r\n            numPrincipalningOutcomes = 21 - pick;\r\n        } else {\r\n            numPrincipalningOutcomes = pick - 1;\r\n        }\r\n        uint payoutFactor = (100 - HOUSE_EDGE) * (20000 / numPrincipalningOutcomes);\r\n        uint payout = (value * payoutFactor) / 100000;\r\n        return payout;\r\n    }\r\n\r\n    function becomeMortal(uint gen) internal {\r\n        if (generations[gen].death != 0) {\r\n            return;\r\n        }\r\n\r\n        generations[gen].death = block.number + SHORT_PHASE;\r\n    }\r\n\r\n    function isSuitableGen(uint gen, uint offset) constant returns (bool) {\r\n        return block.number + offset >= generations[gen].ofage\r\n               && (generations[gen].death == 0\r\n                   || block.number + offset < generations[gen].death)\r\n               && generations[gen].interests.length < maxNumInterests;\r\n    }\r\n\r\n    function findSuitableGen() internal constant returns (Suitability\r\n                                                          suitability) {\r\n        suitability.isSuitable = false;\r\n        for (uint i = oldestGen; i < nextGen; i++) {\r\n            if (isSuitableGen(i, 0)) {\r\n                suitability.gen = i;\r\n                suitability.isSuitable = true;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    function needsbeneficiary(uint offset) constant returns (bool needed) {\r\n        if (oldestGen >= nextGen) {\r\n            return false;\r\n        }\r\n\r\n        return generations[oldestGen].death != 0 &&\r\n               generations[oldestGen].death + LONG_PHASE <= block.number + offset;\r\n    }\r\n\r\n    function beneficiary(bytes32 seed, int payoutId) onlyseedsources {\r\n        if (!needsbeneficiary(0)) {\r\n            return;\r\n        }\r\n\r\n        uint gen = oldestGen;\r\n        if (msg.sender == seedSourceA\r\n                && sha3(seed) == generations[gen].seedHashA) {\r\n            generations[gen].seedA = seed;\r\n        } else if (msg.sender == seedSourceB\r\n                        && sha3(seed) == generations[gen].seedHashB) {\r\n            generations[gen].seedB = seed;\r\n        }\r\n\r\n        if (sha3(generations[gen].seedA) != generations[gen].seedHashA\r\n                || sha3(generations[gen].seedB) != generations[gen].seedHashB) {\r\n            return;\r\n        }\r\n\r\n        \r\n        for (uint i = 0; i < generations[gen].interests.length; i++) {\r\n            uint8 contractDie = toContractDie(generations[gen].seedA,\r\n                                              generations[gen].seedB,\r\n                                              generations[gen].interests[i].id);\r\n            uint8 pick = generations[gen].interests[i].pick;\r\n            bool isMirrored = generations[gen].interests[i].isMirrored;\r\n            uint payout = generations[gen].interests[i].payout;\r\n\r\n            bool lenderPrincipals = interestResolution(contractDie,\r\n                                            generations[gen].interests[i].die,\r\n                                            pick, isMirrored);\r\n            if (lenderPrincipals) {\r\n                generations[gen].interests[i].lender.send(payout);\r\n            }\r\n\r\n            InterestResolved(generations[gen].interests[i].id, contractDie, lenderPrincipals);\r\n            outstandingPayouts -= payout;\r\n\r\n            \r\n            if (investorBankroll >= bankroll) {\r\n                \r\n                uint investorShare = generations[gen].interests[i].wager / 2;\r\n                uint ownerShare = generations[gen].interests[i].wager - investorShare;\r\n\r\n                investorBankroll += investorShare;\r\n                investorProfit += int(investorShare);\r\n                bankroll += ownerShare;\r\n                profit += int(ownerShare);\r\n\r\n                if (lenderPrincipals) {\r\n                    investorShare = payout / 2;\r\n                    ownerShare = payout - investorShare;\r\n                    if (ownerShare > bankroll) {\r\n                        ownerShare = bankroll;\r\n                        investorShare = payout - ownerShare;\r\n                    } else if (investorShare > investorBankroll) {\r\n                        investorShare = investorBankroll;\r\n                        ownerShare = payout - investorShare;\r\n                    }\r\n\r\n                    investorBankroll -= investorShare;\r\n                    investorProfit -= int(investorShare);\r\n                    bankroll -= ownerShare;\r\n                    profit -= int(ownerShare);\r\n                }\r\n            } else {\r\n                bankroll += generations[gen].interests[i].wager;\r\n                profit += int(generations[gen].interests[i].wager);\r\n\r\n                if (lenderPrincipals) {\r\n                    bankroll -= payout;\r\n                    profit -= int(payout);\r\n                }\r\n            }\r\n        }\r\n        performAction(gen);\r\n\r\n        \r\n        generations[gen].beneficiary = block.number;\r\n        generations[gen].payoutId = payoutId;\r\n\r\n        \r\n        oldestGen += 1;\r\n        if (oldestGen >= ARCHIVE_SIZE) {\r\n            delete generations[oldestGen - ARCHIVE_SIZE];\r\n        }\r\n    }\r\n\r\n    function performAction(uint gen) internal {\r\n        if (!generations[gen].hasAction) {\r\n            return;\r\n        }\r\n\r\n        uint amount = generations[gen].action.amount;\r\n        uint maxWithdrawal;\r\n        if (generations[gen].action.actionType == ActionType.Withdrawal) {\r\n            maxWithdrawal = (bankroll + investorBankroll) - outstandingPayouts;\r\n\r\n            if (amount <= maxWithdrawal && amount <= bankroll) {\r\n                owner.send(amount);\r\n                bankroll -= amount;\r\n            }\r\n        } else if (generations[gen].action.actionType ==\r\n                   ActionType.InvestorDeposit) {\r\n            if (investor == 0) {\r\n                investor = generations[gen].action.sender;\r\n                investorBankroll = generations[gen].action.amount;\r\n            } else if (investor == generations[gen].action.sender) {\r\n                investorBankroll += generations[gen].action.amount;\r\n            } else {\r\n                uint investorLoss = 0;\r\n                if (investorProfit < 0) {\r\n                    investorLoss = uint(investorProfit * -1);\r\n                }\r\n\r\n                if (amount > investorBankroll + investorLoss) {\r\n                    \r\n                    \r\n                    investor.send(investorBankroll + investorLoss);\r\n                    investor = generations[gen].action.sender;\r\n                    investorBankroll = amount - investorLoss;\r\n                    investorProfit = 0;\r\n                } else {\r\n                    \r\n                    generations[gen].action.sender.send(amount);\r\n                }\r\n            }\r\n        } else if (generations[gen].action.actionType ==\r\n                   ActionType.InvestorWithdrawal) {\r\n            maxWithdrawal = (bankroll + investorBankroll) - outstandingPayouts;\r\n\r\n            if (amount <= maxWithdrawal && amount <= investorBankroll\r\n                    && investor == generations[gen].action.sender) {\r\n                investor.send(amount);\r\n                investorBankroll -= amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function emergencybeneficiary() {\r\n        if (generations[oldestGen].death == 0 ||\r\n                block.number - generations[oldestGen].death < SAFEGUARD_THRESHOLD) {\r\n            return;\r\n        }\r\n\r\n        \r\n        for (uint i = 0; i < generations[oldestGen].interests.length; i++) {\r\n            uint wager = generations[oldestGen].interests[i].wager;\r\n            uint payout = generations[oldestGen].interests[i].payout;\r\n\r\n            generations[oldestGen].interests[i].lender.send(wager);\r\n            outstandingPayouts -= payout;\r\n        }\r\n        performAction(oldestGen);\r\n\r\n        generations[oldestGen].beneficiary = block.number;\r\n        generations[oldestGen].payoutId = -1;\r\n\r\n        oldestGen += 1;\r\n        if (oldestGen >= ARCHIVE_SIZE) {\r\n            delete generations[oldestGen - ARCHIVE_SIZE];\r\n        }\r\n    }\r\n\r\n    function beneficiaryAndBirth(bytes32 seed, int payoutId,\r\n                             bytes32 freshSeedHash) onlyseedsources {\r\n        \r\n        beneficiary(seed, payoutId);\r\n        birth(freshSeedHash);\r\n    }\r\n\r\n    function lookupGeneration(uint gen) constant returns (bytes32 seedHashA,\r\n                                                          bytes32 seedHashB,\r\n                                                          bytes32 seedA,\r\n                                                          bytes32 seedB,\r\n                                                          uint minWager,\r\n                                                          uint maxPayout,\r\n                                                          uint ofage,\r\n                                                          uint death,\r\n                                                          uint beneficiary,\r\n                                                          uint numInterests,\r\n                                                          bool hasAction,\r\n                                                          int payoutId) {\r\n        seedHashA = generations[gen].seedHashA;\r\n        seedHashB = generations[gen].seedHashB;\r\n        seedA = generations[gen].seedA;\r\n        seedB = generations[gen].seedB;\r\n        minWager = generations[gen].minWager;\r\n        maxPayout = generations[gen].maxPayout;\r\n        ofage = generations[gen].ofage;\r\n        death = generations[gen].death;\r\n        beneficiary = generations[gen].beneficiary;\r\n        numInterests = generations[gen].interests.length;\r\n        hasAction = generations[gen].hasAction;\r\n        payoutId = generations[gen].payoutId;\r\n    }\r\n\r\n    function lookupInterest(uint gen, uint interest) constant returns (uint id,\r\n                                                             address lender,\r\n                                                             uint8 pick,\r\n                                                             bool isMirrored,\r\n                                                             uint wager,\r\n                                                             uint payout,\r\n                                                             uint8 die,\r\n                                                             uint timestamp) {\r\n        id = generations[gen].interests[interest].id;\r\n        lender = generations[gen].interests[interest].lender;\r\n        pick = generations[gen].interests[interest].pick;\r\n        isMirrored = generations[gen].interests[interest].isMirrored;\r\n        wager = generations[gen].interests[interest].wager;\r\n        payout = generations[gen].interests[interest].payout;\r\n        die = generations[gen].interests[interest].die;\r\n        timestamp = generations[gen].interests[interest].timestamp;\r\n    }\r\n\r\n    function findRecentInterest(address lender) constant returns (int id, uint gen,\r\n                                                             uint interest) {\r\n        for (uint i = nextGen - 1; i >= oldestGen; i--) {\r\n            for (uint j = generations[i].interests.length - 1; j >= 0; j--) {\r\n                if (generations[i].interests[j].lender == lender) {\r\n                    id = int(generations[i].interests[j].id);\r\n                    gen = i;\r\n                    interest = j;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        id = -1;\r\n        return;\r\n    }\r\n\r\n    function toDie(bytes32 data) constant returns (uint8 die) {\r\n        \r\n        \r\n        \r\n        \r\n        \r\n        uint256 FACTOR = 5789604461865809771178549250434395392663499233282028201972879200395656481997;\r\n        return uint8(uint256(data) / FACTOR) + 1;\r\n    }\r\n\r\n    function toContractDie(bytes32 seedA, bytes32 seedB,\r\n                           uint nonce) constant returns (uint8 die) {\r\n        return toDie(sha3(seedA, seedB, nonce));\r\n    }\r\n\r\n    function hash(bytes32 data) constant returns (bytes32 hash) {\r\n        return sha3(data);\r\n    }\r\n\r\n    function combineInterest(uint8 dieA, uint8 dieB) constant returns (uint8 die) {\r\n        die = dieA + dieB;\r\n        if (die > 20) {\r\n            die -= 20;\r\n        }\r\n    }\r\n\r\n    function interestResolution(uint8 contractDie, uint8 lenderDie,\r\n                           uint8 pick, bool isMirrored) constant returns (bool) {\r\n        uint8 die = combineInterest(contractDie, lenderDie);\r\n        return (isMirrored && die >= pick) || (!isMirrored && die < pick);\r\n    }\r\n\r\n    function lowerMinWager(uint _minWager) onlyowner {\r\n        if (_minWager < minWager) {\r\n            minWager = _minWager;\r\n        }\r\n    }\r\n\r\n    function raiseMaxNumInterests(uint _maxNumInterests) onlyowner {\r\n        if (_maxNumInterests > maxNumInterests) {\r\n            maxNumInterests = _maxNumInterests;\r\n        }\r\n    }\r\n\r\n    function setOwner(address _owner) onlyowner {\r\n        owner = _owner;\r\n    }\r\n\r\n    function deposit() onlyowner {\r\n        bankroll += msg.value;\r\n    }\r\n\r\n    function withdraw(uint amount) onlyowner {\r\n        Suitability memory suitability = findSuitableGen();\r\n        uint suitableGen = suitability.gen;\r\n\r\n        if (!suitability.isSuitable) {\r\n            return;\r\n        }\r\n\r\n        if (generations[suitableGen].hasAction) {\r\n            return;\r\n        }\r\n\r\n        generations[suitableGen].action.actionType = ActionType.Withdrawal;\r\n        generations[suitableGen].action.amount = amount;\r\n        generations[suitableGen].hasAction = true;\r\n        becomeMortal(suitableGen);\r\n    }\r\n\r\n    function investorDeposit() {\r\n        if (isInvestorLocked && msg.sender != investor) {\r\n            return;\r\n        }\r\n\r\n        Suitability memory suitability = findSuitableGen();\r\n        uint suitableGen = suitability.gen;\r\n\r\n        if (!suitability.isSuitable) {\r\n            return;\r\n        }\r\n\r\n        if (generations[suitableGen].hasAction) {\r\n            return;\r\n        }\r\n\r\n        generations[suitableGen].action.actionType = ActionType.InvestorDeposit;\r\n        generations[suitableGen].action.sender = msg.sender;\r\n        generations[suitableGen].action.amount = msg.value;\r\n        generations[suitableGen].hasAction = true;\r\n        becomeMortal(suitableGen);\r\n    }\r\n\r\n    function investorWithdraw(uint amount) {\r\n        Suitability memory suitability = findSuitableGen();\r\n        uint suitableGen = suitability.gen;\r\n\r\n        if (!suitability.isSuitable) {\r\n            return;\r\n        }\r\n\r\n        if (generations[suitableGen].hasAction) {\r\n            return;\r\n        }\r\n\r\n        generations[suitableGen].action.actionType = ActionType.InvestorWithdrawal;\r\n        generations[suitableGen].action.sender = msg.sender;\r\n        generations[suitableGen].action.amount = amount;\r\n        generations[suitableGen].hasAction = true;\r\n        becomeMortal(suitableGen);\r\n    }\r\n\r\n    function setInvestorLock(bool _isInvestorLocked) onlyowner {\r\n        isInvestorLocked = _isInvestorLocked;\r\n    }\r\n\r\n    function setSeedSourceA(address _seedSourceA) {\r\n        if (msg.sender == seedSourceA || seedSourceA == 0) {\r\n            seedSourceA = _seedSourceA;\r\n        }\r\n    }\r\n\r\n    function setSeedSourceB(address _seedSourceB) {\r\n        if (msg.sender == seedSourceB || seedSourceB == 0) {\r\n            seedSourceB = _seedSourceB;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"contractDie\",\"type\":\"uint8\"},{\"name\":\"lenderDie\",\"type\":\"uint8\"},{\"name\":\"pick\",\"type\":\"uint8\"},{\"name\":\"isMirrored\",\"type\":\"bool\"}],\"name\":\"interestResolution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seedSourceB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seedSourceA\",\"type\":\"address\"}],\"name\":\"setSeedSourceA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seedSourceA\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"toDie\",\"outputs\":[{\"name\":\"die\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pick\",\"type\":\"uint8\"},{\"name\":\"isMirrored\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calculatePayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pick\",\"type\":\"uint8\"},{\"name\":\"isMirrored\",\"type\":\"bool\"},{\"name\":\"die\",\"type\":\"uint8\"}],\"name\":\"interest\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"interest\",\"type\":\"uint256\"}],\"name\":\"lookupInterest\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"lender\",\"type\":\"address\"},{\"name\":\"pick\",\"type\":\"uint8\"},{\"name\":\"isMirrored\",\"type\":\"bool\"},{\"name\":\"wager\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint256\"},{\"name\":\"die\",\"type\":\"uint8\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dieA\",\"type\":\"uint8\"},{\"name\":\"dieB\",\"type\":\"uint8\"}],\"name\":\"combineInterest\",\"outputs\":[{\"name\":\"die\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasNextSeedHashA\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gen\",\"type\":\"uint256\"}],\"name\":\"lookupGeneration\",\"outputs\":[{\"name\":\"seedHashA\",\"type\":\"bytes32\"},{\"name\":\"seedHashB\",\"type\":\"bytes32\"},{\"name\":\"seedA\",\"type\":\"bytes32\"},{\"name\":\"seedB\",\"type\":\"bytes32\"},{\"name\":\"minWager\",\"type\":\"uint256\"},{\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"name\":\"ofage\",\"type\":\"uint256\"},{\"name\":\"death\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"uint256\"},{\"name\":\"numInterests\",\"type\":\"uint256\"},{\"name\":\"hasAction\",\"type\":\"bool\"},{\"name\":\"payoutId\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorBankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextGen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencybeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seedSourceB\",\"type\":\"address\"}],\"name\":\"setSeedSourceB\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minWager\",\"type\":\"uint256\"}],\"name\":\"lowerMinWager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumInterests\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_parseMsgData\",\"outputs\":[{\"name\":\"hasResult\",\"type\":\"bool\"},{\"name\":\"pick\",\"type\":\"uint8\"},{\"name\":\"isMirrored\",\"type\":\"bool\"},{\"name\":\"die\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"numberOfHealthyGenerations\",\"outputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSeedHashA\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInvestorLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"needsBirth\",\"outputs\":[{\"name\":\"needed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roomForBirth\",\"outputs\":[{\"name\":\"hasRoom\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seedA\",\"type\":\"bytes32\"},{\"name\":\"seedB\",\"type\":\"bytes32\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"toContractDie\",\"outputs\":[{\"name\":\"die\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSeedHashB\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInterests\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minWager\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"payoutId\",\"type\":\"int256\"},{\"name\":\"freshSeedHash\",\"type\":\"bytes32\"}],\"name\":\"beneficiaryAndBirth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldestGen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seed\",\"type\":\"bytes32\"},{\"name\":\"payoutId\",\"type\":\"int256\"}],\"name\":\"beneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"outstandingPayouts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"freshSeedHash\",\"type\":\"bytes32\"}],\"name\":\"birth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isInvestorLocked\",\"type\":\"bool\"}],\"name\":\"setInvestorLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"hash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lender\",\"type\":\"address\"}],\"name\":\"findRecentInterest\",\"outputs\":[{\"name\":\"id\",\"type\":\"int256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"interest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"needsbeneficiary\",\"outputs\":[{\"name\":\"needed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"investorWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"investorDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"isSuitableGen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxNumInterests\",\"type\":\"uint256\"}],\"name\":\"raiseMaxNumInterests\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasNextSeedHashB\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractDie\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"lenderPrincipals\",\"type\":\"bool\"}],\"name\":\"InterestResolved\",\"type\":\"event\"}]","ContractName":"AIGInvestment","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2dc2298e3bfd5d8d65caba32461fffcd3f550f2ab5e55c8cb0dd501ea4b151db"}]}