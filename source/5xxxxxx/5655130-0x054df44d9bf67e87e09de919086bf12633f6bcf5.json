{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\ncontract DataSourceInterface {\r\n\r\n    function isDataSource() public pure returns (bool);\r\n\r\n    function getGroupResult(uint matchId) external;\r\n    function getRoundOfSixteenTeams(uint index) external;\r\n    function getRoundOfSixteenResult(uint matchId) external;\r\n    function getQuarterResult(uint matchId) external;\r\n    function getSemiResult(uint matchId) external;\r\n    function getFinalTeams() external;\r\n    function getYellowCards() external;\r\n    function getRedCards() external;\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title DataLayer.\r\n* @author CryptoCup Team (https://cryptocup.io/about)\r\n*/\r\ncontract DataLayer{\r\n\r\n    \r\n    uint256 constant WCCTOKEN_CREATION_LIMIT = 5000000;\r\n    uint256 constant STARTING_PRICE = 45 finney;\r\n    \r\n    /// Epoch times based on when the prices change.\r\n    uint256 constant FIRST_PHASE  = 1527476400;\r\n    uint256 constant SECOND_PHASE = 1528081200;\r\n    uint256 constant THIRD_PHASE  = 1528686000;\r\n    uint256 constant WORLD_CUP_START = 1528945200;\r\n\r\n    DataSourceInterface public dataSource;\r\n    address public dataSourceAddress;\r\n\r\n    address public adminAddress;\r\n    uint256 public deploymentTime = 0;\r\n    uint256 public gameFinishedTime = 0; //set this to now when oraclize was called.\r\n    uint32 public lastCalculatedToken = 0;\r\n    uint256 public pointsLimit = 0;\r\n    uint32 public lastCheckedToken = 0;\r\n    uint32 public winnerCounter = 0;\r\n    uint32 public lastAssigned = 0;\r\n    uint256 public auxWorstPoints = 500000000;\r\n    uint32 public payoutRange = 0;\r\n    uint32 public lastPrizeGiven = 0;\r\n    uint256 public prizePool = 0;\r\n    uint256 public adminPool = 0;\r\n    uint256 public finalizedTime = 0;\r\n\r\n    enum teamState { None, ROS, QUARTERS, SEMIS, FINAL }\r\n    enum pointsValidationState { Unstarted, LimitSet, LimitCalculated, OrderChecked, TopWinnersAssigned, WinnersAssigned, Finished }\r\n    \r\n    /**\r\n    * groups1     scores of the first half of matches (8 bits each)\r\n    * groups2     scores of the second half of matches (8 bits each)\r\n    * brackets    winner's team ids of each round (5 bits each)\r\n    * timeStamp   creation timestamp\r\n    * extra       number of yellow and red cards (16 bits each)\r\n    */\r\n    struct Token {\r\n        uint192 groups1;\r\n        uint192 groups2;\r\n        uint160 brackets;\r\n        uint64 timeStamp;\r\n        uint32  extra;\r\n    }\r\n\r\n    struct GroupResult{\r\n        uint8 teamOneGoals;\r\n        uint8 teamTwoGoals;\r\n    }\r\n\r\n    struct BracketPhase{\r\n        uint8[16] roundOfSixteenTeamsIds;\r\n        mapping (uint8 => bool) teamExists;\r\n        mapping (uint8 => teamState) middlePhaseTeamsIds;\r\n        uint8[4] finalsTeamsIds;\r\n    }\r\n\r\n    struct Extras {\r\n        uint16 yellowCards;\r\n        uint16 redCards;\r\n    }\r\n\r\n    \r\n    // List of all tokens\r\n    Token[] tokens;\r\n\r\n    GroupResult[48] groupsResults;\r\n    BracketPhase bracketsResults;\r\n    Extras extraResults;\r\n\r\n    // List of all tokens that won \r\n    uint256[] sortedWinners;\r\n\r\n    // List of the worst tokens (they also win)\r\n    uint256[] worstTokens;\r\n    pointsValidationState public pValidationState = pointsValidationState.Unstarted;\r\n\r\n    mapping (address => uint256[]) public tokensOfOwnerMap;\r\n    mapping (uint256 => address) public ownerOfTokenMap;\r\n    mapping (uint256 => address) public tokensApprovedMap;\r\n    mapping (uint256 => uint256) public tokenToPayoutMap;\r\n    mapping (uint256 => uint16) public tokenToPointsMap;    \r\n\r\n\r\n    event LogTokenBuilt(address creatorAddress, uint256 tokenId, Token token);\r\n    event LogDataSourceCallbackList(uint8[] result);\r\n    event LogDataSourceCallbackInt(uint8 result);\r\n    event LogDataSourceCallbackTwoInt(uint8 result, uint8 result2);\r\n\r\n}\r\n\r\n\r\n///Author Dieter Shirley (https://github.com/dete)\r\ncontract ERC721 {\r\n\r\n    event LogTransfer(address from, address to, uint256 tokenId);\r\n    event LogApproval(address owner, address approved, uint256 tokenId);\r\n\r\n    function name() public view returns (string);\r\n    function symbol() public view returns (string);\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title AccessControlLayer\r\n* @author CryptoCup Team (https://cryptocup.io/about)\r\n* @dev Containes basic admin modifiers to restrict access to some functions. Allows\r\n* for pauseing, and setting emergency stops.\r\n*/\r\ncontract AccessControlLayer is DataLayer{\r\n\r\n    bool public paused = false;\r\n    bool public finalized = false;\r\n    bool public saleOpen = true;\r\n\r\n   /**\r\n   * @dev Main modifier to limit access to delicate functions.\r\n   */\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that checks that the contract is not paused\r\n    */\r\n    modifier isNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that checks that the contract is paused\r\n    */\r\n    modifier isPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that checks that the contract has finished successfully\r\n    */\r\n    modifier hasFinished() {\r\n        require((gameFinishedTime != 0) && now >= (gameFinishedTime + (15 days)));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that checks that the contract has finalized\r\n    */\r\n    modifier hasFinalized() {\r\n        require(finalized);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if pValidationState is in the provided stats\r\n    * @param state State required to run\r\n    */\r\n    modifier checkState(pointsValidationState state){\r\n        require(pValidationState == state);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer contract's ownership\r\n    * @param _newAdmin Address to be set\r\n    */\r\n    function setAdmin(address _newAdmin) external onlyAdmin {\r\n\r\n        require(_newAdmin != address(0));\r\n        adminAddress = _newAdmin;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the contract pause state\r\n    * @param state True to pause\r\n    */\r\n    function setPauseState(bool state) external onlyAdmin {\r\n        paused = state;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the contract to finalized\r\n    * @param state True to finalize\r\n    */\r\n    function setFinalized(bool state) external onlyAdmin {\r\n        paused = state;\r\n        finalized = state;\r\n        if(finalized == true)\r\n            finalizedTime = now;\r\n    }\r\n}\r\n\r\n/**\r\n* @title CryptoCupToken, main implemantations of the ERC721 standard\r\n* @author CryptoCup Team (https://cryptocup.io/about)\r\n*/\r\ncontract CryptocupToken is AccessControlLayer, ERC721 {\r\n\r\n    //FUNCTIONALTIY\r\n    /**\r\n    * @notice checks if a user owns a token\r\n    * @param userAddress - The address to check.\r\n    * @param tokenId - ID of the token that needs to be verified.\r\n    * @return true if the userAddress provided owns the token.\r\n    */\r\n    function _userOwnsToken(address userAddress, uint256 tokenId) internal view returns (bool){\r\n\r\n         return ownerOfTokenMap[tokenId] == userAddress;\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice checks if the address provided is approved for a given token \r\n    * @param userAddress \r\n    * @param tokenId \r\n    * @return true if it is aproved\r\n    */\r\n    function _tokenIsApproved(address userAddress, uint256 tokenId) internal view returns (bool) {\r\n\r\n        return tokensApprovedMap[tokenId] == userAddress;\r\n    }\r\n\r\n    /**\r\n    * @notice transfers the token specified from sneder address to receiver address.\r\n    * @param fromAddress the sender address that initially holds the token.\r\n    * @param toAddress the receipient of the token.\r\n    * @param tokenId ID of the token that will be sent.\r\n    */\r\n    function _transfer(address fromAddress, address toAddress, uint256 tokenId) internal {\r\n\r\n      require(tokensOfOwnerMap[toAddress].length < 100);\r\n      require(pValidationState == pointsValidationState.Unstarted);\r\n      \r\n      tokensOfOwnerMap[toAddress].push(tokenId);\r\n      ownerOfTokenMap[tokenId] = toAddress;\r\n\r\n      uint256[] storage tokenArray = tokensOfOwnerMap[fromAddress];\r\n      for (uint256 i = 0; i < tokenArray.length; i++){\r\n        if(tokenArray[i] == tokenId){\r\n          tokenArray[i] = tokenArray[tokenArray.length-1];\r\n        }\r\n      }\r\n      delete tokenArray[tokenArray.length-1];\r\n      tokenArray.length--;\r\n\r\n      delete tokensApprovedMap[tokenId];\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Approve the address for a given token\r\n    * @param tokenId - ID of token to be approved\r\n    * @param userAddress - Address that will be approved\r\n    */\r\n    function _approve(uint256 tokenId, address userAddress) internal {\r\n        tokensApprovedMap[tokenId] = userAddress;\r\n    }\r\n\r\n    /**\r\n    * @notice set token owner to an address\r\n    * @dev sets token owner on the contract data structures\r\n    * @param ownerAddress address to be set\r\n    * @param tokenId Id of token to be used\r\n    */\r\n    function _setTokenOwner(address ownerAddress, uint256 tokenId) internal{\r\n\r\n    \ttokensOfOwnerMap[ownerAddress].push(tokenId);\r\n      ownerOfTokenMap[tokenId] = ownerAddress;\r\n    \r\n    }\r\n\r\n    //ERC721 INTERFACE\r\n    function name() public view returns (string){\r\n      return \"Cryptocup\";\r\n    }\r\n\r\n    function symbol() public view returns (string){\r\n      return \"CC\";\r\n    }\r\n\r\n    \r\n    function balanceOf(address userAddress) public view returns (uint256 count) {\r\n      return tokensOfOwnerMap[userAddress].length;\r\n\r\n    }\r\n\r\n    function transfer(address toAddress,uint256 tokenId) external isNotPaused {\r\n\r\n      require(toAddress != address(0));\r\n      require(toAddress != address(this));\r\n      require(_userOwnsToken(msg.sender, tokenId));\r\n\r\n      _transfer(msg.sender, toAddress, tokenId);\r\n      LogTransfer(msg.sender, toAddress, tokenId);\r\n\r\n    }\r\n\r\n\r\n    function transferFrom(address fromAddress, address toAddress, uint256 tokenId) external isNotPaused {\r\n\r\n      require(toAddress != address(0));\r\n      require(toAddress != address(this));\r\n      require(_tokenIsApproved(msg.sender, tokenId));\r\n      require(_userOwnsToken(fromAddress, tokenId));\r\n\r\n      _transfer(fromAddress, toAddress, tokenId);\r\n      LogTransfer(fromAddress, toAddress, tokenId);\r\n\r\n    }\r\n\r\n    function approve( address toAddress, uint256 tokenId) external isNotPaused {\r\n\r\n        require(toAddress != address(0));\r\n        require(_userOwnsToken(msg.sender, tokenId));\r\n\r\n        _approve(tokenId, toAddress);\r\n        LogApproval(msg.sender, toAddress, tokenId);\r\n\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n\r\n        return tokens.length;\r\n\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address ownerAddress) {\r\n\r\n        ownerAddress = ownerOfTokenMap[tokenId];\r\n        require(ownerAddress != address(0));\r\n\r\n    }\r\n\r\n    function tokensOfOwner(address ownerAddress) external view returns(uint256[] tokenIds) {\r\n\r\n        tokenIds = tokensOfOwnerMap[ownerAddress];\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n* @title GameLogicLayer, contract in charge of everything related to calculating points, asigning\r\n* winners, and distributing prizes.\r\n* @author CryptoCup Team (https://cryptocup.io/about)\r\n*/\r\ncontract GameLogicLayer is CryptocupToken{\r\n\r\n    using SafeMath for *;\r\n\r\n    uint8 TEAM_RESULT_MASK_GROUPS = 15;\r\n    uint160 RESULT_MASK_BRACKETS = 31;\r\n    uint16 EXTRA_MASK_BRACKETS = 65535;\r\n\r\n    uint16 private lastPosition;\r\n    uint16 private superiorQuota;\r\n    \r\n    uint16[] private payDistributionAmount = [1,1,1,1,1,1,1,1,1,1,5,5,10,20,50,100,100,200,500,1500,2500];\r\n    uint32[] private payoutDistribution;\r\n\r\n\tevent LogGroupDataArrived(uint matchId, uint8 result, uint8 result2);\r\n    event LogRoundOfSixteenArrived(uint id, uint8 result);\r\n    event LogMiddlePhaseArrived(uint matchId, uint8 result);\r\n    event LogFinalsArrived(uint id, uint8[4] result);\r\n    event LogExtrasArrived(uint id, uint16 result);\r\n    \r\n    //ORACLIZE\r\n    function dataSourceGetGroupResult(uint matchId) external onlyAdmin{\r\n        dataSource.getGroupResult(matchId);\r\n    }\r\n\r\n    function dataSourceGetRoundOfSixteen(uint index) external onlyAdmin{\r\n        dataSource.getRoundOfSixteenTeams(index);\r\n    }\r\n\r\n    function dataSourceGetRoundOfSixteenResult(uint matchId) external onlyAdmin{\r\n        dataSource.getRoundOfSixteenResult(matchId);\r\n    }\r\n\r\n    function dataSourceGetQuarterResult(uint matchId) external onlyAdmin{\r\n        dataSource.getQuarterResult(matchId);\r\n    }\r\n    \r\n    function dataSourceGetSemiResult(uint matchId) external onlyAdmin{\r\n        dataSource.getSemiResult(matchId);\r\n    }\r\n\r\n    function dataSourceGetFinals() external onlyAdmin{\r\n        dataSource.getFinalTeams();\r\n    }\r\n\r\n    function dataSourceGetYellowCards() external onlyAdmin{\r\n        dataSource.getYellowCards();\r\n    }\r\n\r\n    function dataSourceGetRedCards() external onlyAdmin{\r\n        dataSource.getRedCards();\r\n    }\r\n\r\n    /**\r\n    * @notice sets a match result to the contract storage\r\n    * @param matchId id of match to check\r\n    * @param result number of goals the first team scored\r\n    * @param result2 number of goals the second team scored\r\n    */\r\n    \r\n    function dataSourceCallbackGroup(uint matchId, uint8 result, uint8 result2) public {\r\n\r\n        require (msg.sender == dataSourceAddress);\r\n        require (matchId >= 0 && matchId <= 47);\r\n\r\n        groupsResults[matchId].teamOneGoals = result;\r\n        groupsResults[matchId].teamTwoGoals = result2;\r\n\r\n        LogGroupDataArrived(matchId, result, result2);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice sets the sixteen teams that made it through groups to the contract storage\r\n    * @param id index of sixteen teams\r\n    * @param result results to be set\r\n    */\r\n\r\n    function dataSourceCallbackRoundOfSixteen(uint id, uint8 result) public {\r\n\r\n        require (msg.sender == dataSourceAddress);\r\n\r\n        bracketsResults.roundOfSixteenTeamsIds[id] = result;\r\n        bracketsResults.teamExists[result] = true;\r\n        \r\n        LogRoundOfSixteenArrived(id, result);\r\n\r\n    }\r\n\r\n    function dataSourceCallbackTeamId(uint matchId, uint8 result) public {\r\n        require (msg.sender == dataSourceAddress);\r\n\r\n        teamState state = bracketsResults.middlePhaseTeamsIds[result];\r\n\r\n        if (matchId >= 48 && matchId <= 55){\r\n            if (state < teamState.ROS)\r\n                bracketsResults.middlePhaseTeamsIds[result] = teamState.ROS;\r\n        } else if (matchId >= 56 && matchId <= 59){\r\n            if (state < teamState.QUARTERS)\r\n                bracketsResults.middlePhaseTeamsIds[result] = teamState.QUARTERS;\r\n        } else if (matchId == 60 || matchId == 61){\r\n            if (state < teamState.SEMIS)\r\n                bracketsResults.middlePhaseTeamsIds[result] = teamState.SEMIS;\r\n        }\r\n\r\n        LogMiddlePhaseArrived(matchId, result);\r\n    }\r\n\r\n    /**\r\n    * @notice sets the champion, second, third and fourth teams to the contract storage\r\n    * @param id \r\n    * @param result ids of the four teams\r\n    */\r\n    function dataSourceCallbackFinals(uint id, uint8[4] result) public {\r\n\r\n        require (msg.sender == dataSourceAddress);\r\n\r\n        uint256 i;\r\n\r\n        for(i = 0; i < 4; i++){\r\n            bracketsResults.finalsTeamsIds[i] = result[i];\r\n        }\r\n\r\n        LogFinalsArrived(id, result);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice sets the number of cards to the contract storage\r\n    * @param id 101 for yellow cards, 102 for red cards\r\n    * @param result amount of cards\r\n    */\r\n    function dataSourceCallbackExtras(uint id, uint16 result) public {\r\n\r\n        require (msg.sender == dataSourceAddress);\r\n\r\n        if (id == 101){\r\n            extraResults.yellowCards = result;\r\n        } else if (id == 102){\r\n            extraResults.redCards = result;\r\n        }\r\n\r\n        LogExtrasArrived(id, result);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice check if prediction for a match winner is correct\r\n    * @param realResultOne amount of goals team one scored\r\n    * @param realResultTwo amount of goals team two scored\r\n    * @param tokenResultOne amount of goals team one was predicted to score\r\n    * @param tokenResultTwo amount of goals team two was predicted to score\r\n    * @return \r\n    */\r\n    function matchWinnerOk(uint8 realResultOne, uint8 realResultTwo, uint8 tokenResultOne, uint8 tokenResultTwo) internal pure returns(bool){\r\n\r\n        int8 realR = int8(realResultOne - realResultTwo);\r\n        int8 tokenR = int8(tokenResultOne - tokenResultTwo);\r\n\r\n        return (realR > 0 && tokenR > 0) || (realR < 0 && tokenR < 0) || (realR == 0 && tokenR == 0);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice get points from a single match \r\n    * @param matchIndex \r\n    * @param groupsPhase token predictions\r\n    * @return 10 if predicted score correctly, 3 if predicted only who would win\r\n    * and 0 if otherwise\r\n    */\r\n    function getMatchPointsGroups (uint256 matchIndex, uint192 groupsPhase) internal view returns(uint16 matchPoints) {\r\n\r\n        uint8 tokenResultOne = uint8(groupsPhase & TEAM_RESULT_MASK_GROUPS);\r\n        uint8 tokenResultTwo = uint8((groupsPhase >> 4) & TEAM_RESULT_MASK_GROUPS);\r\n\r\n        uint8 teamOneGoals = groupsResults[matchIndex].teamOneGoals;\r\n        uint8 teamTwoGoals = groupsResults[matchIndex].teamTwoGoals;\r\n\r\n        if (teamOneGoals == tokenResultOne && teamTwoGoals == tokenResultTwo){\r\n            matchPoints += 10;\r\n        } else {\r\n            if (matchWinnerOk(teamOneGoals, teamTwoGoals, tokenResultOne, tokenResultTwo)){\r\n                matchPoints += 3;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice calculates points from the last two matches\r\n    * @param brackets token predictions\r\n    * @return amount of points gained from the last two matches\r\n    */\r\n    function getFinalRoundPoints (uint160 brackets) internal view returns(uint16 finalRoundPoints) {\r\n\r\n        uint8[3] memory teamsIds;\r\n\r\n        for (uint i = 0; i <= 2; i++){\r\n            brackets = brackets >> 5; //discard 4th place\r\n            teamsIds[2-i] = uint8(brackets & RESULT_MASK_BRACKETS);\r\n        }\r\n\r\n        if (teamsIds[0] == bracketsResults.finalsTeamsIds[0]){\r\n            finalRoundPoints += 100;\r\n        }\r\n\r\n        if (teamsIds[2] == bracketsResults.finalsTeamsIds[2]){\r\n            finalRoundPoints += 25;\r\n        }\r\n\r\n        if (teamsIds[0] == bracketsResults.finalsTeamsIds[1]){\r\n            finalRoundPoints += 50;\r\n        }\r\n\r\n        if (teamsIds[1] == bracketsResults.finalsTeamsIds[0] || teamsIds[1] == bracketsResults.finalsTeamsIds[1]){\r\n            finalRoundPoints += 50;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice calculates points for round of sixteen, quarter-finals and semifinals\r\n    * @param size amount of matches in round\r\n    * @param round ros, qf, sf or f\r\n    * @param brackets predictions\r\n    * @return amount of points\r\n    */\r\n    function getMiddleRoundPoints(uint8 size, teamState round, uint160 brackets) internal view returns(uint16 middleRoundResults){\r\n\r\n        uint8 teamId;\r\n\r\n        for (uint i = 0; i < size; i++){\r\n            teamId = uint8(brackets & RESULT_MASK_BRACKETS);\r\n\r\n            if (uint(bracketsResults.middlePhaseTeamsIds[teamId]) >= uint(round) ) {\r\n                middleRoundResults+=60;\r\n            }\r\n\r\n            brackets = brackets >> 5;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice calculates points for correct predictions of group winners\r\n    * @param brackets token predictions\r\n    * @return amount of points\r\n    */\r\n    function getQualifiersPoints(uint160 brackets) internal view returns(uint16 qualifiersPoints){\r\n\r\n        uint8 teamId;\r\n\r\n        for (uint256 i = 0; i <= 15; i++){\r\n            teamId = uint8(brackets & RESULT_MASK_BRACKETS);\r\n\r\n            if (teamId == bracketsResults.roundOfSixteenTeamsIds[15-i]){\r\n                qualifiersPoints+=30;\r\n            } else if (bracketsResults.teamExists[teamId]){\r\n                qualifiersPoints+=25;\r\n            }\r\n            \r\n            brackets = brackets >> 5;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice calculates points won by yellow and red cards predictions\r\n    * @param extras token predictions\r\n    * @return amount of points\r\n    */\r\n    function getExtraPoints(uint32 extras) internal view returns(uint16 extraPoints){\r\n\r\n        uint16 redCards = uint16(extras & EXTRA_MASK_BRACKETS);\r\n        extras = extras >> 16;\r\n        uint16 yellowCards = uint16(extras);\r\n\r\n        if (redCards == extraResults.redCards){\r\n            extraPoints+=20;\r\n        }\r\n\r\n        if (yellowCards == extraResults.yellowCards){\r\n            extraPoints+=20;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice calculates total amount of points for a token\r\n    * @param t token to calculate points for\r\n    * @return total amount of points\r\n    */\r\n    function calculateTokenPoints (Token memory t) internal view returns(uint16 points){\r\n        \r\n        //Groups phase 1\r\n        uint192 g1 = t.groups1;\r\n        for (uint256 i = 0; i <= 23; i++){\r\n            points+=getMatchPointsGroups(23-i, g1);\r\n            g1 = g1 >> 8;\r\n        }\r\n\r\n        //Groups phase 2\r\n        uint192 g2 = t.groups2;\r\n        for (i = 0; i <= 23; i++){\r\n            points+=getMatchPointsGroups(47-i, g2);\r\n            g2 = g2 >> 8;\r\n        }\r\n        \r\n        uint160 bracketsLocal = t.brackets;\r\n\r\n        //Brackets phase 1\r\n        points+=getFinalRoundPoints(bracketsLocal);\r\n        bracketsLocal = bracketsLocal >> 20;\r\n\r\n        //Brackets phase 2 \r\n        points+=getMiddleRoundPoints(4, teamState.QUARTERS, bracketsLocal);\r\n        bracketsLocal = bracketsLocal >> 20;\r\n\r\n        //Brackets phase 3 \r\n        points+=getMiddleRoundPoints(8, teamState.ROS, bracketsLocal);\r\n        bracketsLocal = bracketsLocal >> 40;\r\n\r\n        //Brackets phase 4\r\n        points+=getQualifiersPoints(bracketsLocal);\r\n\r\n        //Extras\r\n        points+=getExtraPoints(t.extra);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the points of all the tokens between the last chunk set and the amount given.\r\n    * @dev This function uses all the data collected earlier by oraclize to calculate points.\r\n    * @param amount The amount of tokens that should be analyzed.\r\n    */\r\n\tfunction calculatePointsBlock(uint32 amount) external{\r\n\r\n        require (gameFinishedTime == 0);\r\n        require(amount + lastCheckedToken <= tokens.length);\r\n\r\n\r\n        for (uint256 i = lastCalculatedToken; i < (lastCalculatedToken + amount); i++) {\r\n            uint16 points = calculateTokenPoints(tokens[i]);\r\n            tokenToPointsMap[i] = points;\r\n            if(worstTokens.length == 0 || points <= auxWorstPoints){\r\n                if(worstTokens.length != 0 && points < auxWorstPoints){\r\n                  worstTokens.length = 0;\r\n                }\r\n                if(worstTokens.length < 100){\r\n                    auxWorstPoints = points;\r\n                    worstTokens.push(i);\r\n                }\r\n            }\r\n        }\r\n\r\n        lastCalculatedToken += amount;\r\n  \t}\r\n\r\n    /**\r\n    * @notice Sets the structures for payout distribution, last position and superior quota. Payout distribution is the\r\n    * percentage of the pot each position gets, last position is the percentage of the pot the last position gets,\r\n    * and superior quota is the total amount OF winners that are given a prize.\r\n    * @dev Each of this structures is dynamic and is assigned depending on the total amount of tokens in the game  \r\n    */\r\n    function setPayoutDistributionId () internal {\r\n        if(tokens.length < 101){\r\n            payoutDistribution = [289700, 189700, 120000, 92500, 75000, 62500, 52500, 42500, 40000, 35600, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n            lastPosition = 0;\r\n            superiorQuota = 10;\r\n        }else if(tokens.length < 201){\r\n            payoutDistribution = [265500, 165500, 105500, 75500, 63000, 48000, 35500, 20500, 20000, 19500, 18500, 17800, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n            lastPosition = 0;\r\n            superiorQuota = 20;\r\n        }else if(tokens.length < 301){\r\n            payoutDistribution = [260700, 155700, 100700, 70900, 60700, 45700, 35500, 20500, 17900, 12500, 11500, 11000, 10670, 0, 0, 0, 0, 0, 0, 0, 0];\r\n            lastPosition = 0;\r\n            superiorQuota = 30;\r\n        }else if(tokens.length < 501){\r\n            payoutDistribution = [238600, 138600, 88800, 63800, 53800, 43800, 33800, 18800, 17500, 12500, 9500, 7500, 7100, 6700, 0, 0, 0, 0, 0, 0, 0];\r\n            lastPosition = 0;\r\n            superiorQuota = 50;\r\n        }else if(tokens.length < 1001){\r\n            payoutDistribution = [218300, 122300, 72300, 52400, 43900, 33900, 23900, 16000, 13000, 10000, 9000, 7000, 5000, 4000, 3600, 0, 0, 0, 0, 0, 0];\r\n            lastPosition = 4000;\r\n            superiorQuota = 100;\r\n        }else if(tokens.length < 2001){\r\n            payoutDistribution = [204500, 114000, 64000, 44100, 35700, 26700, 22000, 15000, 11000, 9500, 8500, 6500, 4600, 2500, 2000, 1800, 0, 0, 0, 0, 0];\r\n            lastPosition = 2500;\r\n            superiorQuota = 200;\r\n        }else if(tokens.length < 3001){\r\n            payoutDistribution = [189200, 104800, 53900, 34900, 29300, 19300, 15300, 14000, 10500, 8300, 8000, 6000, 3800, 2500, 2000, 1500, 1100, 0, 0, 0, 0];\r\n            lastPosition = 2500;\r\n            superiorQuota = 300;\r\n        }else if(tokens.length < 5001){\r\n            payoutDistribution = [178000, 100500, 47400, 30400, 24700, 15500, 15000, 12000, 10200, 7800, 7400, 5500, 3300, 2000, 1500, 1200, 900, 670, 0, 0, 0];\r\n            lastPosition = 2000;\r\n            superiorQuota = 500;\r\n        }else if(tokens.length < 10001){\r\n            payoutDistribution = [157600, 86500, 39000, 23100, 18900, 15000, 14000, 11000, 9300, 6100, 6000, 5000, 3800, 1500, 1100, 900, 700, 500, 360, 0, 0];\r\n            lastPosition = 1500;\r\n            superiorQuota = 1000;\r\n        }else if(tokens.length < 25001){\r\n            payoutDistribution = [132500, 70200, 31300, 18500, 17500, 14000, 13500, 10500, 7500, 5500, 5000, 4000, 3000, 1000, 900, 700, 600, 400, 200, 152, 0];\r\n            lastPosition = 1000;\r\n            superiorQuota = 2500;\r\n        } else {\r\n            payoutDistribution = [120000, 63000,  27000, 18800, 17300, 13700, 13000, 10000, 6300, 5000, 4500, 3900, 2500, 900, 800, 600, 500, 350, 150, 100, 70];\r\n            lastPosition = 900;\r\n            superiorQuota = 5000;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the id of the last token that will be given a prize.\r\n    * @dev This is done to offload some of the calculations needed for sorting, and to cap the number of sorts\r\n    * needed to just the winners and not the whole array of tokens.\r\n    * @param tokenId last token id\r\n    */\r\n    function setLimit(uint256 tokenId) external onlyAdmin{\r\n        require(tokenId < tokens.length);\r\n        require(pValidationState == pointsValidationState.Unstarted || pValidationState == pointsValidationState.LimitSet);\r\n        pointsLimit = tokenId;\r\n        pValidationState = pointsValidationState.LimitSet;\r\n        lastCheckedToken = 0;\r\n        lastCalculatedToken = 0;\r\n        winnerCounter = 0;\r\n        \r\n        setPayoutDistributionId();\r\n    }\r\n\r\n    /**\r\n    * @notice Sets the 10th percentile of the sorted array of points\r\n    * @param amount tokens in a chunk\r\n    */\r\n    function calculateWinners(uint32 amount) external onlyAdmin checkState(pointsValidationState.LimitSet){\r\n        require(amount + lastCheckedToken <= tokens.length);\r\n        uint256 points = tokenToPointsMap[pointsLimit];\r\n\r\n        for(uint256 i = lastCheckedToken; i < lastCheckedToken + amount; i++){\r\n            if(tokenToPointsMap[i] > points ||\r\n                (tokenToPointsMap[i] == points && i <= pointsLimit)){\r\n                winnerCounter++;\r\n            }\r\n        }\r\n        lastCheckedToken += amount;\r\n\r\n        if(lastCheckedToken == tokens.length){\r\n            require(superiorQuota == winnerCounter);\r\n            pValidationState = pointsValidationState.LimitCalculated;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Checks if the order given offchain coincides with the order of the actual previously calculated points\r\n    * in the smart contract.\r\n    * @dev the token sorting is done offchain so as to save on the huge amount of gas and complications that \r\n    * could occur from doing all the sorting onchain.\r\n    * @param sortedChunk chunk sorted by points\r\n    */\r\n    function checkOrder(uint32[] sortedChunk) external onlyAdmin checkState(pointsValidationState.LimitCalculated){\r\n        require(sortedChunk.length + sortedWinners.length <= winnerCounter);\r\n\r\n        for(uint256 i=0;i < sortedChunk.length-1;i++){\r\n            uint256 id = sortedChunk[i];\r\n            uint256 sigId = sortedChunk[i+1];\r\n            require(tokenToPointsMap[id] > tokenToPointsMap[sigId] ||\r\n                (tokenToPointsMap[id] == tokenToPointsMap[sigId] &&  id < sigId));\r\n        }\r\n\r\n        if(sortedWinners.length != 0){\r\n            uint256 id2 = sortedWinners[sortedWinners.length-1];\r\n            uint256 sigId2 = sortedChunk[0];\r\n            require(tokenToPointsMap[id2] > tokenToPointsMap[sigId2] ||\r\n                (tokenToPointsMap[id2] == tokenToPointsMap[sigId2] && id2 < sigId2));\r\n        }\r\n\r\n        for(uint256 j=0;j < sortedChunk.length;j++){\r\n            sortedWinners.push(sortedChunk[j]);\r\n        }\r\n\r\n        if(sortedWinners.length == winnerCounter){\r\n            require(sortedWinners[sortedWinners.length-1] == pointsLimit);\r\n            pValidationState = pointsValidationState.OrderChecked;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice If anything during the point calculation and sorting part should fail, this function can reset \r\n    * data structures to their initial position, so as to  \r\n    */\r\n    function resetWinners(uint256 newLength) external onlyAdmin checkState(pointsValidationState.LimitCalculated){\r\n        \r\n        sortedWinners.length = newLength;\r\n    \r\n    }\r\n\r\n    /**\r\n    * @notice Assigns prize percentage for the lucky top 30 winners. Each token will be assigned a uint256 inside\r\n    * tokenToPayoutMap structure that represents the size of the pot that belongs to that token. If any tokens\r\n    * tie inside of the first 30 tokens, the prize will be summed and divided equally. \r\n    */\r\n    function setTopWinnerPrizes() external onlyAdmin checkState(pointsValidationState.OrderChecked){\r\n\r\n        uint256 percent = 0;\r\n        uint[] memory tokensEquals = new uint[](30);\r\n        uint16 tokenEqualsCounter = 0;\r\n        uint256 currentTokenId;\r\n        uint256 currentTokenPoints;\r\n        uint256 lastTokenPoints;\r\n        uint32 counter = 0;\r\n        uint256 maxRange = 13;\r\n        if(tokens.length < 201){\r\n          maxRange = 10;\r\n        }\r\n        \r\n\r\n        while(payoutRange < maxRange){\r\n          uint256 inRangecounter = payDistributionAmount[payoutRange];\r\n          while(inRangecounter > 0){\r\n            currentTokenId = sortedWinners[counter];\r\n            currentTokenPoints = tokenToPointsMap[currentTokenId];\r\n\r\n            inRangecounter--;\r\n\r\n            //Special case for the last one\r\n            if(inRangecounter == 0 && payoutRange == maxRange - 1){\r\n                if(currentTokenPoints == lastTokenPoints){\r\n                  percent += payoutDistribution[payoutRange];\r\n                  tokensEquals[tokenEqualsCounter] = currentTokenId;\r\n                  tokenEqualsCounter++;\r\n                }else{\r\n                  tokenToPayoutMap[currentTokenId] = payoutDistribution[payoutRange];\r\n                }\r\n            }\r\n\r\n            if(counter != 0 && (currentTokenPoints != lastTokenPoints || (inRangecounter == 0 && payoutRange == maxRange - 1))){ //Fix second condition\r\n                    for(uint256 i=0;i < tokenEqualsCounter;i++){\r\n                        tokenToPayoutMap[tokensEquals[i]] = percent.div(tokenEqualsCounter);\r\n                    }\r\n                    percent = 0;\r\n                    tokensEquals = new uint[](30);\r\n                    tokenEqualsCounter = 0;\r\n            }\r\n\r\n            percent += payoutDistribution[payoutRange];\r\n            tokensEquals[tokenEqualsCounter] = currentTokenId;\r\n            \r\n            tokenEqualsCounter++;\r\n            counter++;\r\n\r\n            lastTokenPoints = currentTokenPoints;\r\n           }\r\n           payoutRange++;\r\n        }\r\n\r\n        pValidationState = pointsValidationState.TopWinnersAssigned;\r\n        lastPrizeGiven = counter;\r\n    }\r\n\r\n    /**\r\n    * @notice Sets prize percentage to every address that wins from the position 30th onwards\r\n    * @dev If there are less than 300 tokens playing, then this function will set nothing.\r\n    * @param amount tokens in a chunk\r\n    */\r\n    function setWinnerPrizes(uint32 amount) external onlyAdmin checkState(pointsValidationState.TopWinnersAssigned){\r\n        require(lastPrizeGiven + amount <= winnerCounter);\r\n        \r\n        uint16 inRangeCounter = payDistributionAmount[payoutRange];\r\n        for(uint256 i = 0; i < amount; i++){\r\n          if (inRangeCounter == 0){\r\n            payoutRange++;\r\n            inRangeCounter = payDistributionAmount[payoutRange];\r\n          }\r\n\r\n          uint256 tokenId = sortedWinners[i + lastPrizeGiven];\r\n\r\n          tokenToPayoutMap[tokenId] = payoutDistribution[payoutRange];\r\n\r\n          inRangeCounter--;\r\n        }\r\n        //i + amount prize was not given yet, so amount -1\r\n        lastPrizeGiven += amount;\r\n        payDistributionAmount[payoutRange] = inRangeCounter;\r\n\r\n        if(lastPrizeGiven == winnerCounter){\r\n            pValidationState = pointsValidationState.WinnersAssigned;\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Sets prizes for last tokens and sets prize pool amount\r\n    */\r\n    function setLastPositions() external onlyAdmin checkState(pointsValidationState.WinnersAssigned){\r\n        \r\n            \r\n        for(uint256 j = 0;j < worstTokens.length;j++){\r\n            uint256 tokenId = worstTokens[j];\r\n            tokenToPayoutMap[tokenId] += lastPosition.div(worstTokens.length);\r\n        }\r\n\r\n        uint256 balance = address(this).balance;\r\n        adminPool = balance.mul(25).div(100);\r\n        prizePool = balance.mul(75).div(100);\r\n\r\n        pValidationState = pointsValidationState.Finished;\r\n        gameFinishedTime = now;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title CoreLayer\r\n* @author CryptoCup Team (https://cryptocup.io/about)\r\n* @notice Main contract\r\n*/\r\ncontract CoreLayer is GameLogicLayer {\r\n    \r\n    function CoreLayer() public {\r\n        adminAddress = msg.sender;\r\n        deploymentTime = now;\r\n    }\r\n\r\n    /** \r\n    * @dev Only accept eth from the admin\r\n    */\r\n    function() external payable {\r\n        require(msg.sender == adminAddress);\r\n\r\n    }\r\n\r\n    function isDataSourceCallback() public pure returns (bool){\r\n        return true;\r\n    }   \r\n\r\n    /** \r\n    * @notice Builds ERC721 token with the predictions provided by the user.\r\n    * @param groups1  - First half of the group matches scores encoded in a uint192.\r\n    * @param groups2 -  Second half of the groups matches scores encoded in a uint192.\r\n    * @param brackets - Bracket information encoded in a uint160.\r\n    * @param extra -    Extra information (number of red cards and yellow cards) encoded in a uint32.\r\n    * @dev An automatic timestamp is added for internal use.\r\n    */\r\n    function buildToken(uint192 groups1, uint192 groups2, uint160 brackets, uint32 extra) external payable isNotPaused {\r\n\r\n        Token memory token = Token({\r\n            groups1: groups1,\r\n            groups2: groups2,\r\n            brackets: brackets,\r\n            timeStamp: uint64(now),\r\n            extra: extra\r\n        });\r\n\r\n        require(msg.value >= _getTokenPrice());\r\n        require(msg.sender != address(0));\r\n        require(tokens.length < WCCTOKEN_CREATION_LIMIT);\r\n        require(tokensOfOwnerMap[msg.sender].length < 100);\r\n        require(now < WORLD_CUP_START); //World cup Start\r\n\r\n        uint256 tokenId = tokens.push(token) - 1;\r\n        require(tokenId == uint256(uint32(tokenId)));\r\n\r\n        _setTokenOwner(msg.sender, tokenId);\r\n        LogTokenBuilt(msg.sender, tokenId, token);\r\n\r\n    }\r\n\r\n    /** \r\n    * @param tokenId - ID of token to get.\r\n    * @return Returns all the valuable information about a specific token.\r\n    */\r\n    function getToken(uint256 tokenId) external view returns (uint192 groups1, uint192 groups2, uint160 brackets, uint64 timeStamp, uint32 extra) {\r\n\r\n        Token storage token = tokens[tokenId];\r\n\r\n        groups1 = token.groups1;\r\n        groups2 = token.groups2;\r\n        brackets = token.brackets;\r\n        timeStamp = token.timeStamp;\r\n        extra = token.extra;\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Called by the development team once the World Cup has ended (adminPool is set) \r\n    * @dev Allows dev team to retrieve adminPool\r\n    */\r\n    function adminWithdrawBalance() external onlyAdmin {\r\n\r\n        adminAddress.transfer(adminPool);\r\n        adminPool = 0;\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Allows any user to retrieve their asigned prize. This would be the sum of the price of all the tokens\r\n    * owned by the caller of this function.\r\n    * @dev If the caller has no prize, the function will revert costing no gas to the caller.\r\n    */\r\n    function withdrawPrize() external checkState(pointsValidationState.Finished){\r\n        uint256 prize = 0;\r\n        uint256[] memory tokenList = tokensOfOwnerMap[msg.sender];\r\n        \r\n        for(uint256 i = 0;i < tokenList.length; i++){\r\n            prize += tokenToPayoutMap[tokenList[i]];\r\n            tokenToPayoutMap[tokenList[i]] = 0;\r\n        }\r\n        \r\n        require(prize > 0);\r\n        msg.sender.transfer((prizePool.mul(prize)).div(1000000));\r\n      \r\n    }\r\n\r\n    \r\n    /**\r\n    * @notice Gets current token price \r\n    */\r\n    function _getTokenPrice() internal view returns(uint256 tokenPrice){\r\n\r\n        if ( now >= THIRD_PHASE){\r\n            tokenPrice = (150 finney);\r\n        } else if (now >= SECOND_PHASE) {\r\n            tokenPrice = (110 finney);\r\n        } else if (now >= FIRST_PHASE) {\r\n            tokenPrice = (75 finney);\r\n        } else {\r\n            tokenPrice = STARTING_PRICE;\r\n        }\r\n\r\n        require(tokenPrice >= STARTING_PRICE && tokenPrice <= (200 finney));\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the data source contract address \r\n    * @param _address Address to be set\r\n    */\r\n    function setDataSourceAddress(address _address) external onlyAdmin {\r\n        \r\n        DataSourceInterface c = DataSourceInterface(_address);\r\n\r\n        require(c.isDataSource());\r\n\r\n        dataSource = c;\r\n        dataSourceAddress = _address;\r\n    }\r\n\r\n    /**\r\n    * @notice Testing function to corroborate group data from oraclize call\r\n    * @param x Id of the match to get\r\n    * @return uint8 Team 1 goals\r\n    * @return uint8 Team 2 goals\r\n    */\r\n    function getGroupData(uint x) external view returns(uint8 a, uint8 b){\r\n        a = groupsResults[x].teamOneGoals;\r\n        b = groupsResults[x].teamTwoGoals;  \r\n    }\r\n\r\n    /**\r\n    * @notice Testing function to corroborate round of sixteen data from oraclize call\r\n    * @return An array with the ids of the round of sixteen teams\r\n    */\r\n    function getBracketData() external view returns(uint8[16] a){\r\n        a = bracketsResults.roundOfSixteenTeamsIds;\r\n    }\r\n\r\n    /**\r\n    * @notice Testing function to corroborate brackets data from oraclize call\r\n    * @param x Team id\r\n    * @return The place the team reached\r\n    */\r\n    function getBracketDataMiddleTeamIds(uint8 x) external view returns(teamState a){\r\n        a = bracketsResults.middlePhaseTeamsIds[x];\r\n    }\r\n\r\n    /**\r\n    * @notice Testing function to corroborate finals data from oraclize call\r\n    * @return the 4 (four) final teams ids\r\n    */\r\n    function getBracketDataFinals() external view returns(uint8[4] a){\r\n        a = bracketsResults.finalsTeamsIds;\r\n    }\r\n\r\n    /**\r\n    * @notice Testing function to corroborate extra data from oraclize call\r\n    * @return amount of yellow and red cards\r\n    */\r\n    function getExtrasData() external view returns(uint16 a, uint16 b){\r\n        a = extraResults.yellowCards;\r\n        b = extraResults.redCards;  \r\n    }\r\n\r\n    //EMERGENCY CALLS\r\n    //If something goes wrong or fails, these functions will allow retribution for token holders \r\n\r\n    /**\r\n    * @notice if there is an unresolvable problem, users can call to this function to get a refund.\r\n    */\r\n    function emergencyWithdraw() external hasFinalized{\r\n\r\n        uint256 balance = STARTING_PRICE * tokensOfOwnerMap[msg.sender].length;\r\n\r\n        delete tokensOfOwnerMap[msg.sender];\r\n        msg.sender.transfer(balance);\r\n\r\n    }\r\n\r\n     /**\r\n    * @notice Let the admin cash-out the entire contract balance 10 days after game has finished.\r\n    */\r\n    function finishedGameWithdraw() external onlyAdmin hasFinished{\r\n\r\n        uint256 balance = address(this).balance;\r\n        adminAddress.transfer(balance);\r\n\r\n    }\r\n    \r\n    /**\r\n    * @notice Let the admin cash-out the entire contract balance 10 days after game has finished.\r\n    */\r\n    function emergencyWithdrawAdmin() external hasFinalized onlyAdmin{\r\n\r\n        require(finalizedTime != 0 &&  now >= finalizedTime + 10 days );\r\n        msg.sender.transfer(address(this).balance);\r\n\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"dataSourceGetFinals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataSource\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setFinalized\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromAddress\",\"type\":\"address\"},{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"dataSourceGetRoundOfSixteenResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"calculateWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToPayoutMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOfTokenMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pointsLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setDataSourceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8[4]\"}],\"name\":\"dataSourceCallbackFinals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"getGroupData\",\"outputs\":[{\"name\":\"a\",\"type\":\"uint8\"},{\"name\":\"b\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCheckedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenToPointsMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"dataSourceGetRoundOfSixteen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"dataSourceGetSemiResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCalculatedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDataSourceCallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"groups1\",\"type\":\"uint192\"},{\"name\":\"groups2\",\"type\":\"uint192\"},{\"name\":\"brackets\",\"type\":\"uint160\"},{\"name\":\"extra\",\"type\":\"uint32\"}],\"name\":\"buildToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setTopWinnerPrizes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLength\",\"type\":\"uint256\"}],\"name\":\"resetWinners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sortedChunk\",\"type\":\"uint32[]\"}],\"name\":\"checkOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setLastPositions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastAssigned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBracketData\",\"outputs\":[{\"name\":\"a\",\"type\":\"uint8[16]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"dataSourceGetQuarterResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"result2\",\"type\":\"uint8\"}],\"name\":\"dataSourceCallbackGroup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutRange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pValidationState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auxWorstPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"dataSourceCallbackRoundOfSixteen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dataSourceGetRedCards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"setWinnerPrizes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdrawAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"dataSourceCallbackTeamId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnerCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensOfOwnerMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishedGameWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"calculatePointsBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExtrasData\",\"outputs\":[{\"name\":\"a\",\"type\":\"uint16\"},{\"name\":\"b\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dataSourceGetYellowCards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPauseState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPrizeGiven\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dataSourceAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"name\":\"groups1\",\"type\":\"uint192\"},{\"name\":\"groups2\",\"type\":\"uint192\"},{\"name\":\"brackets\",\"type\":\"uint160\"},{\"name\":\"timeStamp\",\"type\":\"uint64\"},{\"name\":\"extra\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint16\"}],\"name\":\"dataSourceCallbackExtras\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deploymentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensApprovedMap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"dataSourceGetGroupResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint8\"}],\"name\":\"getBracketDataMiddleTeamIds\",\"outputs\":[{\"name\":\"a\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBracketDataFinals\",\"outputs\":[{\"name\":\"a\",\"type\":\"uint8[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"adminWithdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameFinishedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"result2\",\"type\":\"uint8\"}],\"name\":\"LogGroupDataArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"LogRoundOfSixteenArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"LogMiddlePhaseArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8[4]\"}],\"name\":\"LogFinalsArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint16\"}],\"name\":\"LogExtrasArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"LogTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"LogApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"name\":\"groups1\",\"type\":\"uint192\"},{\"name\":\"groups2\",\"type\":\"uint192\"},{\"name\":\"brackets\",\"type\":\"uint160\"},{\"name\":\"timeStamp\",\"type\":\"uint64\"},{\"name\":\"extra\",\"type\":\"uint32\"}],\"indexed\":false,\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"LogTokenBuilt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8[]\"}],\"name\":\"LogDataSourceCallbackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"LogDataSourceCallbackInt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"result2\",\"type\":\"uint8\"}],\"name\":\"LogDataSourceCallbackTwoInt\",\"type\":\"event\"}]","ContractName":"CoreLayer","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://955b297a0de8941e133b44c5e8dda2c24d97efb52c653db4c300752cbdddae15"}]}