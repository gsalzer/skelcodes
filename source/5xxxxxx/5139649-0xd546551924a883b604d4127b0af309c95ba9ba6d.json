{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// \r\n// UberDelta Exchange Contract - v1.0.0\r\n// \r\n//  www.uberdelta.com\r\n//\r\n\r\ncontract Token {\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n  \r\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    require(b > 0); //gentler than an assert.\r\n    c = a / b;\r\n    return c;\r\n  }\r\n\r\n\r\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract OwnerManager {\r\n\r\n  address public owner;\r\n  address public newOwner;\r\n  address public manager;\r\n\r\n  event OwnershipTransferProposed(address indexed _from, address indexed _to);\r\n  event OwnershipTransferConfirmed(address indexed _from, address indexed _to);\r\n  event NewManager(address indexed _newManager);\r\n\r\n\r\n  modifier onlyOwner {\r\n    assert(msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  modifier onlyManager {\r\n    assert(msg.sender == manager);\r\n    _;\r\n  }\r\n\r\n\r\n  function OwnerManager() public{\r\n    owner = msg.sender;\r\n    manager = msg.sender;\r\n  }\r\n\r\n\r\n  function transferOwnership(address _newOwner) onlyOwner external{\r\n    require(_newOwner != owner);\r\n    \r\n    OwnershipTransferProposed(owner, _newOwner);\r\n    \r\n    newOwner = _newOwner;\r\n  }\r\n\r\n\r\n  function confirmOwnership() external {\r\n    assert(msg.sender == newOwner);\r\n    \r\n    OwnershipTransferConfirmed(owner, newOwner);\r\n    \r\n    owner = newOwner;\r\n  }\r\n\r\n\r\n  function newManager(address _newManager) onlyOwner external{\r\n    require(_newManager != address(0x0));\r\n    \r\n    NewManager(_newManager);\r\n    \r\n    manager = _newManager;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Helper is OwnerManager {\r\n\r\n  mapping (address => bool) public isHelper;\r\n\r\n  modifier onlyHelper {\r\n    assert(isHelper[msg.sender] == true);\r\n    _;\r\n  }\r\n\r\n  event ChangeHelper(\r\n    address indexed helper,\r\n    bool status\r\n  );\r\n\r\n  function Helper() public{\r\n    isHelper[msg.sender] = true;\r\n  }\r\n\r\n  function changeHelper(address _helper, bool _status) external onlyManager {\r\n\t  ChangeHelper(_helper, _status);\r\n    isHelper[_helper] = _status;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Compliance {\r\n  function canDeposit(address _user) public view returns (bool isAllowed);\r\n  function canTrade(address _token, address _user) public view returns (bool isAllowed);\r\n  function validateTrade(\r\n    address _token,\r\n    address _getUser,\r\n    address _giveUser\r\n  )\r\n    public\r\n    view\r\n    returns (bool isAllowed)\r\n  ;\r\n}\r\n\r\ncontract OptionRegistry {\r\n  function registerOptionPair(\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires\r\n  )\r\n  public\r\n  returns(bool)\r\n  ;\r\n  \r\n  function isOptionPairRegistered(\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires\r\n  )\r\n  public\r\n  view\r\n  returns(bool)  \r\n  ;\r\n  \r\n}\r\n\r\ncontract EOS {\r\n    function register(string key) public;\r\n}\r\n\r\ncontract UberDelta is SafeMath, OwnerManager, Helper {\r\n\r\n  // The account that will receive fees\r\n  address public feeAccount;\r\n  \r\n  // The account that will receive lost ERC20 tokens\r\n  address public sweepAccount;\r\n  \r\n  // The address of the compliance engine\r\n  address public complianceAddress;\r\n  \r\n  // The address of the options registry\r\n  address public optionsRegistryAddress;\r\n  \r\n  // The address of the next exchange contract\r\n  address public newExchange;\r\n\r\n  // Turn off deposits and trades, allow upgrade and withdraw\r\n  bool public contractLocked;\r\n  \r\n  bytes32 signedTradeHash = keccak256(\r\n    \"address contractAddress\",\r\n    \"address takerTokenAddress\",\r\n    \"uint256 takerTokenAmount\",\r\n    \"address makerTokenAddress\",\r\n    \"uint256 makerTokenAmount\",\r\n    \"uint256 tradeExpires\",\r\n    \"uint256 salt\",\r\n    \"address maker\",\r\n    \"address restrictedTo\"\r\n  );\r\n  \r\n  bytes32 signedWithdrawHash = keccak256(\r\n    \"address contractAddress\",\r\n    \"uint256 amount\",\r\n    \"uint256 fee\",\r\n    \"uint256 withdrawExpires\",\r\n    \"uint256 salt\",\r\n    \"address maker\",\r\n    \"address restrictedTo\"\r\n  );\r\n\r\n\r\n  // Balance per token, for each user.\r\n  mapping (address => mapping (address => uint256)) public balances;\r\n  \r\n  // global token balance tracking (to detect lost tokens)\r\n  mapping (address => uint256) public globalBalance;\r\n  \r\n  // List of orders created by calling the exchange contract directly.\r\n  mapping (bytes32 => bool) public orders;\r\n  \r\n  // Lists the amount of each order that has been filled or cancelled.\r\n  mapping (bytes32 => uint256) public orderFills;\r\n  \r\n  // Tokens that need to be checked through the compliance engine.\r\n  mapping (address => bool) public restrictedTokens;\r\n\r\n  // Mapping of fees by user class (default class == 0x0)\r\n  mapping (uint256 => uint256) public feeByClass;\r\n  \r\n  // Mapping of users to user classes.\r\n  mapping (address => uint256) public userClass; \r\n  \r\n  \r\n  /*******************************************\r\n  / Exchange Regular Events\r\n  /******************************************/\r\n  \r\n  // Note: Order creation is usually off-chain\r\n  event Order(\r\n    bytes32 indexed tradePair,\r\n    address indexed maker,\r\n    address[4] addressData,\r\n    uint256[4] numberData\r\n  );\r\n  \r\n  event Cancel(\r\n    bytes32 indexed tradePair,\r\n    address indexed maker,\r\n    address[4] addressData,\r\n    uint256[4] numberData,\r\n    uint256 status\r\n  );\r\n  \r\n   event FailedTrade( \r\n    bytes32 indexed tradePair,\r\n    address indexed taker,\r\n    bytes32 hash,\r\n    uint256 failReason\r\n  ); \r\n  \r\n  event Trade( \r\n    bytes32 indexed tradePair,\r\n    address indexed maker,\r\n    address indexed taker,\r\n    address makerToken,\r\n    address takerToken,\r\n    address restrictedTo,\r\n    uint256[4] numberData,\r\n    uint256 tradeAmount,\r\n    bool fillOrKill\r\n  );\r\n  \r\n  event Deposit(\r\n    address indexed token,\r\n    address indexed toUser,\r\n    address indexed sender,\r\n    uint256 amount\r\n  );\r\n  \r\n  event Withdraw(\r\n    address indexed token,\r\n    address indexed toUser,\r\n    uint256 amount\r\n  );\r\n\r\n  event InternalTransfer(\r\n    address indexed token,\r\n    address indexed toUser,\r\n    address indexed sender,\r\n    uint256 amount\r\n  );\r\n\r\n  event TokenSweep(\r\n    address indexed token,\r\n    address indexed sweeper,\r\n    uint256 amount,\r\n    uint256 balance\r\n  );\r\n  \r\n  event RestrictToken(\r\n    address indexed token,\r\n    bool status\r\n  );\r\n  \r\n  event NewExchange(\r\n    address newExchange\r\n  );\r\n  \r\n  event ChangeFeeAccount(\r\n    address feeAccount\r\n  );\r\n  \r\n  event ChangeSweepAccount(\r\n    address sweepAccount\r\n  );\r\n  \r\n  event ChangeClassFee(\r\n    uint256 indexed class,\r\n    uint256 fee\r\n  );\r\n  \r\n  event ChangeUserClass(\r\n    address indexed user,\r\n    uint256 class\r\n  );\r\n  \r\n  event LockContract(\r\n    bool status\r\n  );\r\n  \r\n  event UpdateComplianceAddress(\r\n    address newComplianceAddress\r\n  );\r\n  \r\n  event UpdateOptionsRegistryAddress(\r\n    address newOptionsRegistryAddress\r\n  );\r\n  \r\n  event Upgrade(\r\n    address indexed user,\r\n    address indexed token,\r\n    address newExchange,\r\n    uint256 amount\r\n  );\r\n  \r\n  event RemoteWithdraw(\r\n    address indexed maker,\r\n    address indexed sender,\r\n    uint256 withdrawAmount,\r\n    uint256 feeAmount,\r\n    uint256 withdrawExpires,\r\n    uint256 salt,\r\n    address restrictedTo\r\n  );\r\n  \r\n  event CancelRemoteWithdraw(\r\n    address indexed maker,\r\n    uint256 withdrawAmount,\r\n    uint256 feeAmount,\r\n    uint256 withdrawExpires,\r\n    uint256 salt,\r\n    address restrictedTo,\r\n    uint256 status\r\n  );\r\n\r\n  //Constructor Function, set initial values.\r\n  function UberDelta() public {\r\n    feeAccount = owner;\r\n    sweepAccount = owner;\r\n    feeByClass[0x0] = 3000000000000000;\r\n    contractLocked = false;\r\n    complianceAddress = this;\r\n    optionsRegistryAddress = this;\r\n  }\r\n\r\n\r\n  // Prevent raw sends of Eth.\r\n  function() public {\r\n    revert();\r\n  }\r\n  \r\n  \r\n  \r\n  /*******************************************\r\n  / Contract Control Functions\r\n  /******************************************/\r\n  function changeNewExchange(address _newExchange) external onlyOwner {\r\n    //since _newExchange being zero turns off the upgrade function, lets\r\n    //allow this to be reset to 0x0.\r\n    \r\n    newExchange = _newExchange;\r\n    \r\n    NewExchange(_newExchange);\r\n  }\r\n\r\n\r\n  function changeFeeAccount(address _feeAccount) external onlyManager {\r\n    require(_feeAccount != address(0x0));\r\n    \r\n    feeAccount = _feeAccount;\r\n    \r\n    ChangeFeeAccount(_feeAccount);\r\n  }\r\n\r\n  function changeSweepAccount(address _sweepAccount) external onlyManager {\r\n    require(_sweepAccount != address(0x0));\r\n    \r\n    sweepAccount = _sweepAccount;\r\n    \r\n    ChangeSweepAccount(_sweepAccount);\r\n  }\r\n\r\n  function changeClassFee(uint256 _class, uint256 _fee) external onlyManager {\r\n    require(_fee <= 10000000000000000); //Max 1%.\r\n\r\n    feeByClass[_class] = _fee;\r\n\r\n    ChangeClassFee(_class, _fee);\r\n  }\r\n  \r\n  function changeUserClass(address _user, uint256 _newClass) external onlyHelper {\r\n    userClass[_user] = _newClass;\r\n    \r\n    ChangeUserClass(_user, _newClass);\r\n  }\r\n  \r\n  //Turn off deposits and trades, but still allow withdrawals and upgrades.\r\n  function lockContract(bool _lock) external onlyManager {\r\n    contractLocked = _lock;\r\n    \r\n    LockContract(_lock);\r\n  }\r\n  \r\n  function updateComplianceAddress(address _newComplianceAddress)\r\n    external\r\n    onlyManager\r\n  {\r\n    complianceAddress = _newComplianceAddress;\r\n    \r\n    UpdateComplianceAddress(_newComplianceAddress);\r\n  }\r\n\r\n  function updateOptionsRegistryAddress(address _newOptionsRegistryAddress)\r\n    external\r\n    onlyManager\r\n  {\r\n    optionsRegistryAddress = _newOptionsRegistryAddress;\r\n    \r\n    UpdateOptionsRegistryAddress(_newOptionsRegistryAddress);\r\n  }\r\n\r\n\r\n  // restriction function for tokens that need additional verifications\r\n  function tokenRestriction(address _newToken, bool _status) external onlyHelper {\r\n    restrictedTokens[_newToken] = _status;\r\n    \r\n    RestrictToken(_newToken, _status);\r\n  }\r\n\r\n  \r\n  //Turn off deposits and trades, but still allow withdrawals and upgrades.\r\n  modifier notLocked() {\r\n    require(!contractLocked);\r\n    _;\r\n  }\r\n  \r\n  \r\n  /*******************************************************\r\n  / Deposit/Withdrawal/Transfer\r\n  /\r\n  / In all of the following functions, it should be noted\r\n  / that the 0x0 address is used to represent ETH.\r\n  /******************************************************/\r\n  \r\n  // SafeMath sanity checks inputs in deposit(), withdraw(), and token functions.\r\n  \r\n  // Deposit ETH in the contract to trade with\r\n  function deposit() external notLocked payable returns(uint256) {\r\n    require(Compliance(complianceAddress).canDeposit(msg.sender)); \r\n    // defaults to true until we change compliance code\r\n    \r\n    balances[address(0x0)][msg.sender] = safeAdd(balances[address(0x0)][msg.sender], msg.value);\r\n    globalBalance[address(0x0)] = safeAdd(globalBalance[address(0x0)], msg.value);\r\n\r\n    Deposit(0x0, msg.sender, msg.sender, msg.value);\r\n    \r\n    return(msg.value);\r\n  }\r\n\r\n  // Withdraw ETH from the contract to your wallet  (internal transaction on etherscan)\r\n  function withdraw(uint256 _amount) external returns(uint256) {\r\n    //require(balances[address(0x0)][msg.sender] >= _amount);\r\n    //handled by safeSub.\r\n    \r\n    balances[address(0x0)][msg.sender] = safeSub(balances[address(0x0)][msg.sender], _amount);\r\n    globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _amount);\r\n \r\n    //transfer has a built in require\r\n    msg.sender.transfer(_amount);\r\n    \r\n    Withdraw(0x0, msg.sender, _amount);\r\n    \r\n    return(_amount);\r\n  }\r\n\r\n\r\n  // Deposit ERC20 tokens in the contract to trade with\r\n  // Token(_token).approve(this, _amount) must be called in advance\r\n  // ERC223 tokens must be deposited by a transfer to this contract ( see tokenFallBack(..) )\r\n  function depositToken(address _token, uint256 _amount) external notLocked returns(uint256) {\r\n    require(_token != address(0x0));\r\n    \r\n    require(Compliance(complianceAddress).canDeposit(msg.sender));\r\n\r\n    balances[_token][msg.sender] = safeAdd(balances[_token][msg.sender], _amount);\r\n    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\r\n    \r\n    require(Token(_token).transferFrom(msg.sender, this, _amount));\r\n\r\n    Deposit(_token, msg.sender, msg.sender, _amount);\r\n    \r\n    return(_amount);\r\n  }\r\n\r\n  // Withdraw ERC20/223 tokens from the contract back to your wallet\r\n  function withdrawToken(address _token, uint256 _amount)\r\n    external\r\n    returns (uint256)\r\n  {\r\n    if (_token == address(0x0)){\r\n      //keep the nulls to reduce gas usage.\r\n      //require(balances[_token)][msg.sender] >= _amount);\r\n      //handled by safeSub.\r\n      balances[address(0x0)][msg.sender] = safeSub(balances[address(0x0)][msg.sender], _amount);\r\n      globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _amount);\r\n\r\n      //transfer has a built in require\r\n      msg.sender.transfer(_amount);\r\n    } else {\r\n      //require(balances[_token][msg.sender] >= _amount);\r\n      //handled by safeSub \r\n \r\n      balances[_token][msg.sender] = safeSub(balances[_token][msg.sender], _amount);\r\n      globalBalance[_token] = safeSub(globalBalance[_token], _amount);\r\n\r\n      require(Token(_token).transfer(msg.sender, _amount));\r\n    }    \r\n\r\n    Withdraw(_token, msg.sender, _amount);\r\n    \r\n    return _amount;\r\n  }\r\n\r\n  // Deposit ETH in the contract on behalf of another address\r\n  // Warning: afterwards, only _user will be able to trade or withdraw these funds\r\n  function depositToUser(address _toUser) external payable notLocked returns (bool success) {\r\n    require(\r\n        (_toUser != address(0x0))\r\n     && (_toUser != address(this))\r\n     && (Compliance(complianceAddress).canDeposit(_toUser))\r\n    );\r\n    \r\n    balances[address(0x0)][_toUser] = safeAdd(balances[address(0x0)][_toUser], msg.value);\r\n    globalBalance[address(0x0)] = safeAdd(globalBalance[address(0x0)], msg.value);\r\n    \r\n    Deposit(0x0, _toUser, msg.sender, msg.value);\r\n    \r\n    return true;\r\n  }\r\n\r\n  // Deposit ERC20 tokens in the contract on behalf of another address\r\n  // Token(_token).approve(this, _amount) must be called in advance\r\n  // Warning: afterwards, only _toUser will be able to trade or withdraw these funds\r\n  // ERC223 tokens must be deposited by a transfer to this contract ( see tokenFallBack(..) )\r\n  function depositTokenToUser(\r\n    address _toUser,\r\n    address _token,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    notLocked\r\n    returns (bool success)\r\n  {\r\n    require(\r\n        (_token != address(0x0))\r\n\r\n     && (_toUser  != address(0x0))\r\n     && (_toUser  != address(this))\r\n     && (_toUser  != _token)\r\n     && (Compliance(complianceAddress).canDeposit(_toUser))\r\n    );\r\n    \r\n    balances[_token][_toUser] = safeAdd(balances[_token][_toUser], _amount);\r\n    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\r\n\r\n    require(Token(_token).transferFrom(msg.sender, this, _amount));\r\n\r\n    Deposit(_token, _toUser, msg.sender, _amount);\r\n    \r\n    return true;\r\n  }\r\n\r\n\r\n  //ERC223 Token Acceptor function, called when an ERC2223 token is transferred to this contract\r\n  // provide _sendTo to make it a deposit on behalf of another address (depositToUser)\r\n  function tokenFallback(\r\n    address _from,  // user calling the function\r\n    uint256 _value, // the number of tokens\r\n    bytes _sendTo     // \"deposit to other user\" if exactly 20 bytes sent\r\n    \r\n  )\r\n    external\r\n    notLocked\r\n  {\r\n    //first lets figure out who this is going to.\r\n    address toUser = _from;     //probably this\r\n    if (_sendTo.length == 20){  //but use data for sendTo otherwise.\r\n\r\n      // I'm about 90% sure I don't need to do the casting here, but for\r\n      // like twenty gas, I'll take the protection from potentially\r\n      // stomping on weird memory locations.\r\n      \r\n      uint256 asmAddress;\r\n      assembly { //uses 50 gas\r\n        asmAddress := calldataload(120)\r\n      }\r\n      toUser = address(asmAddress);\r\n    }\r\n    \r\n    //sanity checks.\r\n    require(\r\n        (toUser != address(0x0))\r\n     && (toUser != address(this))\r\n     && (toUser != msg.sender)  // msg.sender is the token\r\n     && (Compliance(complianceAddress).canDeposit(toUser))\r\n    );\r\n    \r\n    // check if a contract is calling this\r\n    uint256 codeLength;\r\n    assembly {\r\n      codeLength := extcodesize(caller)\r\n    }\r\n    require(codeLength > 0);    \r\n    \r\n    globalBalance[msg.sender] = safeAdd(globalBalance[msg.sender], _value);\r\n    balances[msg.sender][toUser] = safeAdd(balances[msg.sender][toUser], _value);\r\n    \r\n    //sanity check, and as a perk, we check for balanceOf();\r\n    require(Token(msg.sender).balanceOf(this) >= _value);\r\n\r\n    Deposit(msg.sender, toUser, _from, _value);\r\n  }\r\n\r\n  // Move deposited tokens or ETH (0x0) from one to another address within the contract\r\n  function internalTransfer(\r\n    address _toUser,\r\n    address _token,\r\n    uint256 _amount\r\n  )\r\n    external\r\n    notLocked \r\n    returns(uint256)\r\n  {\r\n    require(\r\n        (balances[_token][msg.sender] >= _amount)\r\n     && (_toUser != address(0x0))\r\n     && (_toUser != address(this))\r\n     && (_toUser != _token)\r\n     && (Compliance(complianceAddress).canDeposit(_toUser))\r\n    );\r\n \r\n    balances[_token][msg.sender] = safeSub(balances[_token][msg.sender], _amount);\r\n    balances[_token][_toUser] = safeAdd(balances[_token][_toUser], _amount);\r\n\r\n    InternalTransfer(_token, _toUser, msg.sender, _amount);\r\n    \r\n    return(_amount);\r\n  }\r\n  \r\n  // return the token/ETH balance a user has deposited in the contract\r\n  function balanceOf(address _token, address _user) external view returns (uint) {\r\n    return balances[_token][_user];\r\n  }\r\n\r\n  \r\n  // In order to see the ERC20 total balance, we're calling an external contract,\r\n  // and this contract claims to be ERC20, but we don't know what's really there.\r\n  // We can't rely on the EVM or solidity to enforce \"view\", so even though a\r\n  // normal token can rely on itself to be non-malicious, we can't.\r\n  // We have no idea what potentially evil tokens we'll be interacting with.\r\n  // The call to check the reported balance needs to go after the state changes,\r\n  // even though it's un-natural. Now, on one hand, this function might at first\r\n  // appear safe, since we're only allowing the sweeper address to access\r\n  // *this function,* but we are reading the state of the globalBalance.\r\n  // In theory, a malicious token could do the following:\r\n  //  1a) Check if the caller of balanceOf is our contract, if it's not, act normally.\r\n  //  1b) If the caller is our contract, it does the following:\r\n  //  2) Read our contracts globalBalance for its own address.\r\n  //  3) Sets our contract's balance of the token (in the token controller) to our internal globalBalance\r\n  //  4) Allocates some other address the difference in globalBalance and actual balance for our contract.\r\n  //  5) Report back to this function exactly the amount we had in globalBalance.\r\n  // (which, by then is true, since they were stolen).\r\n  // Now we're always going to see 0 extra tokens, and our users have had their tokens perminantly lost.\r\n  // bonus: this is why there is no \"sweep all\" function.\r\n    \r\n  // Detect ERC20 tokens that have been sent to the contract without a deposit (lost tokens),\r\n  // which are not included in globalBalance[..]\r\n  function sweepTokenAmount(address _token, uint256 _amount) external returns(uint256) {\r\n    assert(msg.sender == sweepAccount);\r\n\r\n    balances[_token][sweepAccount] = safeAdd(balances[_token][sweepAccount], _amount);\r\n    globalBalance[_token] = safeAdd(globalBalance[_token], _amount);\r\n    \r\n    //You go last!\r\n\tif(_token != address(0x0)) { \r\n      require(globalBalance[_token] <= Token(_token).balanceOf(this));\r\n\t} else {\r\n\t  // if another contract performs selfdestruct(UberDelta),\r\n    // ETH can get in here without being in globalBalance\r\n\t  require(globalBalance[address(0x0)] <= this.balance); \r\n\t}\r\n    \r\n    TokenSweep(_token, msg.sender, _amount, balances[_token][sweepAccount]);\r\n    \r\n    return(_amount);\r\n  }\r\n  \r\n  \r\n  /*******************************************\r\n  / Regular Trading functions\r\n  /******************************************/\r\n  \r\n  //now contracts can place orders!\r\n  \r\n  \r\n  // Normal order creation happens off-chain and orders are signed by creators,\r\n  // this function allows for on-chain orders to be created\r\n  function order(\r\n    address[4] _addressData,\r\n    uint256[4] _numberData //web3 isn't ready for structs.\r\n  )\r\n    external\r\n    notLocked\r\n    returns (bool success)\r\n  {\r\n  \r\n//    _addressData[2] is maker;\r\n    if (msg.sender != _addressData[2]) { return false; }\r\n    \r\n    bytes32 hash = getHash(_addressData, _numberData);\r\n\r\n    orders[hash] = true;\r\n\r\n    Order(\r\n      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n      msg.sender,\r\n      _addressData,\r\n      _numberData);\r\n    \r\n    return true;\r\n  }  \r\n\r\n\r\n  function tradeBalances(\r\n    address _takerTokenAddress,\r\n    uint256 _takerTokenAmount,\r\n    address _makerTokenAddress,\r\n    uint256 _makerTokenAmount,\r\n    address _maker,\r\n    uint256 _tradeAmount\r\n  )\r\n    internal\r\n  {\r\n    require(_takerTokenAmount > 0); //safeDiv\r\n\r\n    // We charge only the takers this fee\r\n    uint256 feeValue = safeMul(_tradeAmount, feeByClass[userClass[msg.sender]]) / (1 ether);\r\n    \r\n    balances[_takerTokenAddress][_maker] =\r\n      safeAdd(balances[_takerTokenAddress][_maker], _tradeAmount);\r\n    balances[_takerTokenAddress][msg.sender] =\r\n      safeSub(balances[_takerTokenAddress][msg.sender], safeAdd(_tradeAmount, feeValue));\r\n    \r\n    balances[_makerTokenAddress][_maker] =\r\n      safeSub(\r\n        balances[_makerTokenAddress][_maker],\r\n        safeMul(_makerTokenAmount, _tradeAmount) / _takerTokenAmount\r\n      );\r\n    balances[_makerTokenAddress][msg.sender] =\r\n      safeAdd(\r\n        balances[_makerTokenAddress][msg.sender],\r\n        safeMul(_makerTokenAmount, _tradeAmount) / _takerTokenAmount\r\n      );\r\n    \r\n    balances[_takerTokenAddress][feeAccount] =\r\n      safeAdd(balances[_takerTokenAddress][feeAccount], feeValue);\r\n  }\r\n\r\n\r\n  function trade(\r\n    address[4] _addressData,\r\n    uint256[4] _numberData, //web3 isn't ready for structs.\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s,\r\n    uint256 _amount,\r\n    bool _fillOrKill\r\n  )\r\n    external\r\n    notLocked\r\n    returns(uint256 tradeAmount)\r\n  {\r\n  \r\n//      _addressData[0], // takerTokenAddress;\r\n//      _numberData[0], // takerTokenAmount;\r\n//      _addressData[1], // makerTokenAddress;\r\n//      _numberData[1], // makerTokenAmount;\r\n//      _numberData[2], // tradeExpires;\r\n//      _numberData[3], // salt;\r\n//      _addressData[2], // maker;\r\n//      _addressData[3] // restrictedTo;\r\n    \r\n    bytes32 hash = getHash(_addressData, _numberData);\r\n    \r\n    tradeAmount = safeSub(_numberData[0], orderFills[hash]); //avail to trade\r\n    \r\n    //balance of giveToken / amount I said I'd give of giveToken * amount I said I want of getToken\r\n    if (\r\n      tradeAmount > safeDiv(\r\n        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\r\n        _numberData[1]\r\n      )\r\n    )\r\n    {\r\n      tradeAmount = safeDiv(\r\n        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\r\n        _numberData[1]\r\n      );\r\n    }\r\n    \r\n    if (tradeAmount > _amount) { tradeAmount = _amount; }\r\n    \r\n        //_numberData[0] is takerTokenAmount\r\n    if (tradeAmount == 0) { //idfk. There's nothing there to get. Canceled? Traded?\r\n      if (orderFills[hash] < _numberData[0]) { //Maker seems to be missing tokens?\r\n        FailedTrade(\r\n          (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n          msg.sender,\r\n          hash,\r\n          0\r\n        );\r\n      } else {  // either cancelled or already traded.\r\n        FailedTrade(\r\n          (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n          msg.sender,\r\n          hash,\r\n          1\r\n        );\r\n      }\r\n      return 0;\r\n    }\r\n    \r\n    \r\n    if (block.number > _numberData[2]) { //order is expired\r\n      FailedTrade(\r\n        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n        msg.sender,\r\n        hash,\r\n        2\r\n      );\r\n      return 0;\r\n    }\r\n\r\n\r\n    if ((_fillOrKill == true) && (tradeAmount < _amount)) { //didnt fill, so kill\r\n      FailedTrade(\r\n        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n        msg.sender,\r\n        hash,\r\n        3\r\n      );\r\n      return 0;\r\n    }\r\n    \r\n        \r\n    uint256 feeValue = safeMul(_amount, feeByClass[userClass[msg.sender]]) / (1 ether);\r\n\r\n    //if they trade more than they have, get 0.\r\n    if ( (_amount + feeValue) > balances[_addressData[0]][msg.sender])  { \r\n      FailedTrade(\r\n        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n        msg.sender,\r\n        hash,\r\n        4\r\n      );\r\n      return 0;\r\n    }\r\n    \r\n    if ( //not a valid order.\r\n        (ecrecover(keccak256(signedTradeHash, hash), _v, _r, _s) != _addressData[2])\r\n        && (! orders[hash])\r\n    )\r\n    {\r\n      FailedTrade(\r\n        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n        msg.sender,\r\n        hash,\r\n        5\r\n      );\r\n      return 0;\r\n    }\r\n\r\n    \r\n    if ((_addressData[3] != address(0x0)) && (_addressData[3] != msg.sender)) { //check restrictedTo\r\n      FailedTrade(\r\n        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n        msg.sender,\r\n        hash,\r\n        6\r\n      );\r\n      return 0;\r\n    }\r\n        \r\n    \r\n    if ( //if there's a compliance restriction.\r\n      ((_addressData[0] != address(0x0)) //if not Eth, and restricted, check with Compliance.\r\n        && (restrictedTokens[_addressData[0]] )\r\n        && ! Compliance(complianceAddress).validateTrade(_addressData[0], _addressData[2], msg.sender)\r\n      )\r\n      || ((_addressData[1] != address(0x0))  //ditto\r\n        && (restrictedTokens[_addressData[1]])\r\n        && ! Compliance(complianceAddress).validateTrade(_addressData[1], _addressData[2], msg.sender)\r\n      )\r\n    )\r\n    {\r\n      FailedTrade(\r\n        (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n        msg.sender,\r\n        hash,\r\n        7\r\n      );\r\n      return 0;\r\n    }\r\n    \r\n    //Do the thing!\r\n    \r\n    tradeBalances(\r\n      _addressData[0], // takerTokenAddress;\r\n      _numberData[0], // takerTokenAmount;\r\n      _addressData[1], // makerTokenAddress;\r\n      _numberData[1], // makerTokenAmount;\r\n      _addressData[2], // maker;\r\n      tradeAmount\r\n    );\r\n\r\n    orderFills[hash] = safeAdd(orderFills[hash], tradeAmount);\r\n\r\n    Trade(\r\n      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n      _addressData[2],\r\n      msg.sender,\r\n      _addressData[1],\r\n      _addressData[0],\r\n      _addressData[3],\r\n      _numberData,\r\n      tradeAmount,\r\n      _fillOrKill\r\n    );\r\n    \r\n    return(tradeAmount);\r\n  }\r\n  \r\n  \r\n  // Cancel a signed order, once this is confirmed nobody will be able to trade it anymore\r\n  function cancelOrder(\r\n    address[4] _addressData,\r\n    uint256[4] _numberData //web3 isn't ready for structs.\r\n  )\r\n    external\r\n    returns(uint256 amountCancelled)\r\n  {\r\n    \r\n    require(msg.sender == _addressData[2]);\r\n    \r\n    //  msg.sender can 'cancel' nonexistent orders since they're offchain.\r\n    bytes32 hash = getHash(_addressData, _numberData);\r\n \r\n    amountCancelled = safeSub(_numberData[0],orderFills[hash]);\r\n    \r\n    orderFills[hash] = _numberData[0];\r\n \r\n    //event trigger is moved ahead of balance resetting to allow expression of the already-filled amount\r\n//    _numberData[0] is takerTokenAmount;\r\n    Cancel(\r\n      (bytes32(_addressData[0]) ^ bytes32(_addressData[1])),\r\n      msg.sender,\r\n      _addressData,\r\n      _numberData,\r\n      amountCancelled);\r\n\r\n    return amountCancelled;    \r\n  }\r\n\r\n\r\n\r\n  /**************************\r\n  / Remote Withdraw\r\n  ***************************/\r\n  \r\n  // Perform an ETH withdraw transaction for someone else based on their signed message\r\n  // Useful if the owner of the funds does not have enough ETH for gas fees in their wallet.\r\n  // msg.sender receives fee for the effort and gas costs\r\n  function remoteWithdraw(\r\n    uint256 _withdrawAmount,\r\n    uint256 _feeAmount,\r\n    uint256 _withdrawExpires,\r\n    uint256 _salt,\r\n    address _maker,\r\n    address _restrictedTo, //0x0 = anyone\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  )\r\n    external\r\n    notLocked\r\n    returns(bool)\r\n  {\r\n    //is the withdraw possible?\r\n    require(\r\n        (balances[address(0x0)][_maker] >= safeAdd(_withdrawAmount, _feeAmount))\r\n     && (\r\n            (_restrictedTo == address(0x0))\r\n         || (_restrictedTo == msg.sender)\r\n        )\r\n     && ((_feeAmount == 0) || (Compliance(complianceAddress).canDeposit(msg.sender)))\r\n    );\r\n    \r\n    //has this withdraw happened already? (and generate the hash)\r\n\r\n    bytes32 hash = keccak256(\r\n      this, \r\n      _withdrawAmount,\r\n      _feeAmount,\r\n      _withdrawExpires,\r\n      _salt,\r\n      _maker,\r\n      _restrictedTo\r\n    );\r\n\r\n    require(orderFills[hash] == 0);\r\n\r\n    //is this real?\r\n    require(\r\n      ecrecover(keccak256(signedWithdrawHash, hash), _v, _r, _s) == _maker\r\n    );\r\n    \r\n    //only once.\r\n    orderFills[hash] = 1;\r\n\r\n    balances[address(0x0)][_maker] =\r\n      safeSub(balances[address(0x0)][_maker], safeAdd(_withdrawAmount, _feeAmount));\r\n    // pay fee to the user performing the remote withdraw\r\n    balances[address(0x0)][msg.sender] = safeAdd(balances[address(0x0)][msg.sender], _feeAmount);\r\n    \r\n    globalBalance[address(0x0)] = safeSub(globalBalance[address(0x0)], _withdrawAmount);\r\n\r\n    RemoteWithdraw(\r\n      _maker,\r\n      msg.sender,\r\n      _withdrawAmount,\r\n      _feeAmount,\r\n      _withdrawExpires,\r\n      _salt,\r\n      _restrictedTo\r\n    );\r\n\r\n    //implicit require included.\r\n    _maker.transfer(_withdrawAmount);\r\n    \r\n    return(true);\r\n  }\r\n\r\n  // cancel a signed request for a remote withdraw\r\n  function cancelRemoteWithdraw(\r\n    uint256 _withdrawAmount,\r\n    uint256 _feeAmount,\r\n    uint256 _withdrawExpires,\r\n    uint256 _salt,\r\n    address _restrictedTo //0x0 = anyone\r\n  )\r\n    external\r\n  {\r\n      // msg.sender can cancel nonexsistent orders.\r\n    bytes32 hash = keccak256(\r\n      this, \r\n      _withdrawAmount,\r\n      _feeAmount,\r\n      _withdrawExpires,\r\n      _salt,\r\n      msg.sender,\r\n      _restrictedTo\r\n    );\r\n    \r\n    CancelRemoteWithdraw(\r\n      msg.sender,\r\n      _withdrawAmount,\r\n      _feeAmount,\r\n      _withdrawExpires,\r\n      _salt,\r\n      _restrictedTo,\r\n      orderFills[hash]\r\n    );\r\n    \r\n    //set to completed after, event shows pre-cancel status.\r\n    orderFills[hash] = 1;\r\n  }\r\n  \r\n  \r\n \r\n\r\n  /**************************\r\n  /Upgrade Function\r\n  ***************************/\r\n      \r\n  // move tokens/ETH over to a new upgraded smart contract  (avoids having to withdraw & deposit)\r\n  function upgrade(address _token) external returns(uint256 moveBalance) {\r\n    require (newExchange != address(0x0));\r\n\r\n    moveBalance = balances[_token][msg.sender];\r\n\r\n    globalBalance[_token] = safeSub(globalBalance[_token], moveBalance);\r\n    balances[_token][msg.sender] = 0;\r\n\r\n    if (_token != address(0x0)){\r\n      require(Token(_token).approve(newExchange, moveBalance));\r\n      require(UberDelta(newExchange).depositTokenToUser(msg.sender, _token, moveBalance));\r\n    } else {\r\n      require(UberDelta(newExchange).depositToUser.value(moveBalance)(msg.sender));\r\n    }\r\n\r\n    Upgrade(msg.sender, _token, newExchange, moveBalance);\r\n    \r\n    return(moveBalance);\r\n  }\r\n\r\n\r\n  \r\n  /*******************************************\r\n  / Data View functions\r\n  /******************************************/\r\n  \r\n  function testTrade(\r\n    address[4] _addressData,\r\n    uint256[4] _numberData, //web3 isn't ready for structs.\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s,\r\n    uint256 _amount,\r\n    address _sender,\r\n    bool _fillOrKill\r\n  )\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    uint256 feeValue = safeMul(_amount, feeByClass[userClass[_sender]]) / (1 ether);\r\n\r\n    if (\r\n      contractLocked\r\n      ||\r\n      ((_addressData[0] != address(0x0)) //if not Eth, and restricted, check with Compliance.\r\n        && (restrictedTokens[_addressData[0]] )\r\n        && ! Compliance(complianceAddress).validateTrade(_addressData[0], _addressData[2], _sender)\r\n      )\r\n      || ((_addressData[1] != address(0x0))  //ditto\r\n        && (restrictedTokens[_addressData[1]])\r\n        && ! Compliance(complianceAddress).validateTrade(_addressData[1], _addressData[2], _sender)\r\n      )\r\n         //if they trade more than they have, get 0.\r\n      || ((_amount + feeValue) > balances[_addressData[0]][_sender]) \r\n      || ((_addressData[3] != address(0x0)) && (_addressData[3] != _sender)) //check restrictedTo\r\n    )\r\n    {\r\n      return 0;\r\n    }\r\n      \r\n    uint256 tradeAmount = availableVolume(\r\n        _addressData,\r\n        _numberData,\r\n        _v,\r\n        _r,\r\n        _s\r\n    );\r\n    \r\n    if (tradeAmount > _amount) { tradeAmount = _amount; }\r\n    \r\n    if ((_fillOrKill == true) && (tradeAmount < _amount)) {\r\n      return 0;\r\n    }\r\n\r\n    return tradeAmount;\r\n  }\r\n\r\n\r\n  // get how much of an order is left (unfilled)\r\n  // return value in order of _takerTokenAddress\r\n  function availableVolume(\r\n    address[4] _addressData,\r\n    uint256[4] _numberData, //web3 isn't ready for structs.\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  )\r\n    public\r\n    view\r\n    returns(uint256 amountRemaining)\r\n  {     \r\n//    _addressData[0] // takerTokenAddress;\r\n//    _numberData[0] // takerTokenAmount;\r\n//    _addressData[1] // makerTokenAddress;\r\n//    _numberData[1] // makerTokenAmount;\r\n//    _numberData[2] // tradeExpires;\r\n//    _numberData[3] // salt;\r\n//    _addressData[2] // maker;\r\n//    _addressData[3] // restrictedTo;\r\n\r\n    bytes32 hash = getHash(_addressData, _numberData);\r\n\r\n    if (\r\n      (block.number > _numberData[2])\r\n      || ( \r\n        (ecrecover(keccak256(signedTradeHash, hash), _v, _r, _s) != _addressData[2])\r\n        && (! orders[hash])\r\n      )\r\n    ) { return 0; }\r\n\r\n    //uint256 amountRemaining = safeSub(myTrade.takerTokenAmount, orderFills[hash]);\r\n     amountRemaining = safeSub(_numberData[0], orderFills[hash]);\r\n\r\n    if (\r\n      amountRemaining < safeDiv(\r\n        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\r\n        _numberData[1]\r\n      )\r\n    ) return amountRemaining;\r\n\r\n    return (\r\n      safeDiv(\r\n        safeMul(balances[_addressData[1]][_addressData[2]], _numberData[0]),\r\n        _numberData[1]\r\n      )\r\n    );\r\n  }\r\n\r\n\r\n  // get how much of an order has been filled\r\n  // return value in order of _takerTokenAddress\r\n  function getUserFee(\r\n    address _user\r\n  )\r\n    external\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return feeByClass[userClass[_user]];\r\n  }\r\n\r\n\r\n  // get how much of an order has been filled\r\n  // return value in order of _takerTokenAddress\r\n  function amountFilled(\r\n    address[4] _addressData,\r\n    uint256[4] _numberData //web3 isn't ready for structs.\r\n  )\r\n    external\r\n    view\r\n    returns(uint256)\r\n  {\r\n    bytes32 hash = getHash(_addressData, _numberData);\r\n\r\n    return orderFills[hash];\r\n  }\r\n\r\n  \r\n  // check if a request for a remote withdraw is still valid\r\n  function testRemoteWithdraw(\r\n    uint256 _withdrawAmount,\r\n    uint256 _feeAmount,\r\n    uint256 _withdrawExpires,\r\n    uint256 _salt,\r\n    address _maker,\r\n    address _restrictedTo,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s,\r\n    address _sender\r\n  )\r\n    external\r\n    view\r\n    returns(uint256)\r\n  {\r\n    bytes32 hash = keccak256(\r\n      this,\r\n      _withdrawAmount,\r\n      _feeAmount,\r\n      _withdrawExpires,\r\n      _salt,\r\n      _maker,\r\n      _restrictedTo\r\n    );\r\n\r\n    if (\r\n      contractLocked\r\n      ||\r\n      (balances[address(0x0)][_maker] < safeAdd(_withdrawAmount, _feeAmount))\r\n      ||((_restrictedTo != address(0x0)) && (_restrictedTo != _sender))\r\n      || (orderFills[hash] != 0)\r\n      || (ecrecover(keccak256(signedWithdrawHash, hash), _v, _r, _s) != _maker)\r\n      || ((_feeAmount > 0) && (! Compliance(complianceAddress).canDeposit(_sender)))\r\n    )\r\n    {\r\n      return 0;\r\n    } else {\r\n      return _withdrawAmount;\r\n    }\r\n  }\r\n  \r\n  \r\n  \r\n  function getHash(\r\n    address[4] _addressData,\r\n    uint256[4] _numberData //web3 isn't ready for structs.\r\n  )\r\n    public\r\n    view\r\n    returns(bytes32)\r\n  {\r\n    return(\r\n      keccak256(\r\n        this,\r\n        _addressData[0], // takerTokenAddress;\r\n        _numberData[0], // takerTokenAmount;\r\n        _addressData[1], // makerTokenAddress;\r\n        _numberData[1], // makerTokenAmount;\r\n        _numberData[2], // tradeExpires;\r\n        _numberData[3], // salt;\r\n        _addressData[2], // maker;\r\n        _addressData[3] // restrictedTo;\r\n      )\r\n    );\r\n  }\r\n  \r\n  \r\n\r\n  /***********************************\r\n  / Compliance View Code\r\n  ************************************/\r\n  //since the compliance code might move, we should have a way to always\r\n  //call a function to this contract to get the current values\r\n\r\n    function testCanDeposit(\r\n    address _user\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return(Compliance(complianceAddress).canDeposit(_user));\r\n  }\r\n  \r\n  function testCanTrade(\r\n    address _token,\r\n    address _user\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return(Compliance(complianceAddress).canTrade(_token, _user));\r\n  }\r\n\r\n  \r\n  function testValidateTrade(\r\n    address _token,\r\n    address _getUser,\r\n    address _giveUser\r\n  )\r\n    external\r\n    view\r\n    returns (bool isAllowed)\r\n  {\r\n    return(Compliance(complianceAddress).validateTrade(_token, _getUser, _giveUser));\r\n  }\r\n  \r\n\r\n\r\n  /**************************\r\n  / Default Compliance Code\r\n  ***************************/\r\n  // These will eventually live in a different contract.\r\n  // every can deposit by default, later a registry?\r\n  // For now, always say no if called for trades. \r\n  // the earliest use may be halting trade in a token.\r\n  function canDeposit(\r\n    address _user\r\n  )\r\n    public\r\n    view\r\n    returns (bool isAllowed)\r\n  {\r\n    return(true);\r\n  }\r\n  \r\n  function canTrade(\r\n    address _token,\r\n    address _user\r\n  )\r\n    public\r\n    view\r\n    returns (bool isAllowed)\r\n  {\r\n    return(false);\r\n  }\r\n\r\n  \r\n  function validateTrade(\r\n    address _token,\r\n    address _getUser,\r\n    address _giveUser\r\n  )\r\n    public\r\n    view\r\n    returns (bool isAllowed)\r\n  {\r\n    return(false);\r\n  }\r\n  \r\n\r\n\r\n  /***********************************\r\n  / THIS IS WHERE OPTIONS LIVE!!!!\r\n  /**********************************/\r\n  \r\n  \r\n  mapping (address => uint256) public exercisedOptions;\r\n  \r\n  //get asset for tickets\r\n  event CollapseOption(\r\n    address indexed user,\r\n    address indexed holderTicketAddress,\r\n    address indexed writerTicketAddress,\r\n    uint256 ticketsCollapsed,\r\n    bytes32 optionPair //assetTokenAddress xor strikeTokenAddress\r\n  );    \r\n  \r\n  //get holderticket + asset for strike\r\n  event ExcerciseUnwind(\r\n    address indexed user,\r\n    address indexed holderTicketAddress,\r\n    uint256 ticketsUnwound,\r\n    bytes32 optionPair,\r\n    bool fillOrKill\r\n  );  \r\n  \r\n  //get asset for writerticket\r\n  event ExpireOption(\r\n    address indexed user,\r\n    address indexed writerTicketAddress,\r\n    uint256 ticketsExpired,\r\n    bytes32 optionPair\r\n  );  \r\n  \r\n  //get tickets for asset\r\n  event CreateOption(\r\n    address indexed user,\r\n    address indexed holderTicketAddress,\r\n    address indexed writerTicketAddress,\r\n    uint256 ticketsCreated,\r\n    bytes32 optionPair\r\n  );  \r\n  \r\n  //get assset for strike + holderticket\r\n  event ExcerciseOption(\r\n    address indexed user,\r\n    address indexed holderTicketAddress,\r\n    uint256 ticketsExcercised,\r\n    bytes32 optionPair //assetTokenAddress xor strikeTokenAddress\r\n  );  \r\n  \r\n  /******************\r\n  / optionFunctions\r\n  ******************/\r\n  \r\n  //if before expiry, deposit asset, get buy ticket, write ticket\r\n  // 1 ticket gets (10^18) option units credited to them.\r\n  function createOptionPair( //#65\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires,\r\n    uint256 _ticketAmount //tickets times (1 ether)\r\n  )\r\n    external\r\n    notLocked\r\n    returns (uint256 ticketsCreated)\r\n  {\r\n    //if before expiry\r\n    require (block.number < _optionExpires); //option would be expired\r\n    \r\n    //if they have the asset\r\n    //[checked by safemath during locking]\r\n\r\n    //lock asset to 0x0.\r\n    //the percent of one contract times _assetTokenAmount = amount moving\r\n    //creation fee?\r\n    balances[_assetTokenAddress][0x0] =\r\n      safeAdd(\r\n        balances[_assetTokenAddress][0x0],\r\n        safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\r\n      );\r\n\r\n    balances[_assetTokenAddress][msg.sender] =\r\n      safeSub(\r\n        balances[_assetTokenAddress][msg.sender],\r\n        safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\r\n      );\r\n    \r\n    \r\n    address holderTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      false\r\n    );\r\n    \r\n    address writerTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      true\r\n    );\r\n    \r\n    //issue write option\r\n    balances[writerTicketAddress][msg.sender] =\r\n      safeAdd(balances[writerTicketAddress][msg.sender], _ticketAmount);\r\n    globalBalance[writerTicketAddress] =\r\n      safeAdd(globalBalance[writerTicketAddress], _ticketAmount);\r\n\r\n    //issue hold option\r\n    balances[holderTicketAddress][msg.sender] =\r\n      safeAdd(balances[holderTicketAddress][msg.sender], _ticketAmount);\r\n    globalBalance[holderTicketAddress] =\r\n      safeAdd(globalBalance[holderTicketAddress], _ticketAmount);\r\n\r\n    CreateOption(\r\n      msg.sender,\r\n      holderTicketAddress,\r\n      writerTicketAddress,\r\n      _ticketAmount,\r\n      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\r\n    );\r\n    \r\n    //check if we need to register, and do if we do.\r\n    if (\r\n      OptionRegistry(optionsRegistryAddress).isOptionPairRegistered(\r\n        _assetTokenAddress,\r\n        _assetTokenAmount,\r\n        _strikeTokenAddress,\r\n        _strikeTokenAmount,\r\n        _optionExpires\r\n      )\r\n      == false\r\n    )\r\n    {\r\n      require(\r\n        OptionRegistry(optionsRegistryAddress).registerOptionPair(\r\n          _assetTokenAddress,\r\n          _assetTokenAmount,\r\n          _strikeTokenAddress,\r\n          _strikeTokenAmount,\r\n          _optionExpires\r\n        )\r\n      );\r\n    }\r\n    return _ticketAmount;\r\n  }\r\n  \r\n  //if own buy & writer ticket get asset, void tickets\r\n  // 1 ticket gets 10^18 option units voided.\r\n  function collapseOptionPair( //#66\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires,\r\n    uint256 _ticketAmount\r\n  )\r\n    external\r\n    returns (uint256 ticketsCollapsed)\r\n  {\r\n    \r\n    address holderTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      false\r\n    );\r\n    \r\n    address writerTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      true\r\n    );\r\n    \r\n    //if they have the write option\r\n    //if they have the hold option\r\n    require (\r\n      (balances[holderTicketAddress][msg.sender] >= _ticketAmount)\r\n      && (balances[writerTicketAddress][msg.sender] >= _ticketAmount)\r\n    );\r\n    //I guess it can be expired, since you have both legs.\r\n    \r\n    //void write option\r\n    balances[writerTicketAddress][msg.sender] =\r\n      safeSub(balances[writerTicketAddress][msg.sender], _ticketAmount);\r\n    globalBalance[writerTicketAddress] =\r\n      safeSub(globalBalance[writerTicketAddress], _ticketAmount);\r\n\r\n    //void hold option\r\n    balances[holderTicketAddress][msg.sender] =\r\n      safeSub(balances[holderTicketAddress][msg.sender], _ticketAmount);\r\n    globalBalance[holderTicketAddress] =\r\n      safeSub(globalBalance[holderTicketAddress], _ticketAmount);\r\n \r\n    //unlock asset\r\n    balances[_assetTokenAddress][0x0] = safeSub(\r\n      balances[_assetTokenAddress][0x0],\r\n      safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\r\n    );\r\n\r\n    balances[_assetTokenAddress][msg.sender] = safeAdd(\r\n      balances[_assetTokenAddress][msg.sender],\r\n      safeDiv(safeMul(_assetTokenAmount, _ticketAmount), 1 ether)\r\n    );\r\n    \r\n    //emit event\r\n    CollapseOption(\r\n      msg.sender,\r\n      holderTicketAddress,\r\n      writerTicketAddress,\r\n      _ticketAmount,\r\n      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\r\n    );\r\n    \r\n    return _ticketAmount;\r\n  }\r\n\r\n  /*about invisableHandOfAdamSmith():\r\n    q: why would someone ever want to buy an out-of-the-money,\r\n       collaterized call option at strike price?\r\n\r\n    a: if an american option is executed, and the collateral's movement\r\n       makes it later out of the money, the value of the option would\r\n       need to be calculated by including the \"pre-executed\" amount.\r\n       * \r\n       This would prevent an external actor performing weird arb trades\r\n       (write a billion tickets, collapse a billion tickets, profit!).\r\n       Skip the middle man! Writers are more likely to get 100% token or\r\n       strike at expiry, based on market value, and holders still have\r\n       their option intact.\r\n       * \r\n       Arbers gonna arb. Let them do their thing.\r\n*/\r\n\r\n  //if there have been executions, Adam Smith can deposit asset, get strike, up to execution amount.\r\n//  function invisibleHandOfAdamSmith( //#67\r\n\r\n  function optionExcerciseUnwind(\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires,\r\n    uint256 _ticketAmount,\r\n    bool _fillOrKill //do we want? probably...\r\n  )\r\n    external\r\n    notLocked\r\n    returns (uint256 ticketsUnwound) //(amountTraded)\r\n  {\r\n    //only before, equal to expiry\r\n    require(block.number <= _optionExpires);\r\n    \r\n    address holderTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      false\r\n    );\r\n    \r\n    //if strike-pool[hash] != 0 {\r\n    ticketsUnwound = exercisedOptions[holderTicketAddress];\r\n\r\n    //fill or kill.\r\n    require((_fillOrKill == false) || (ticketsUnwound >= _ticketAmount));\r\n\r\n    //get amount to trade.\r\n    if (ticketsUnwound > _ticketAmount) ticketsUnwound = _ticketAmount;\r\n    \r\n    require(ticketsUnwound > 0);\r\n    //cant buy zero, either because not avail, or you asked for zero.\r\n \r\n    //check compliance, like a trade!\r\n    require(\r\n      (! restrictedTokens[holderTicketAddress]) //if it is not restricted\r\n    || Compliance(complianceAddress).canTrade(holderTicketAddress, msg.sender) // or compliance says yes.\r\n    );\r\n\r\n    //debit balance of caller of asset tokens, credit 0x0\r\n    balances[_assetTokenAddress][msg.sender] = safeSub(\r\n      balances[_assetTokenAddress][msg.sender],\r\n      safeDiv(safeMul(_assetTokenAmount, ticketsUnwound), 1 ether)\r\n    );\r\n\r\n    balances[_assetTokenAddress][0x0] = safeAdd(\r\n      balances[_assetTokenAddress][0x0],\r\n      safeDiv(safeMul(_assetTokenAmount, ticketsUnwound), 1 ether)\r\n    );\r\n    \r\n    //debit balance of exercisedOptions of holdOption, credit caller.\r\n    //no change in global balances.\r\n    exercisedOptions[holderTicketAddress] =\r\n      safeSub(exercisedOptions[holderTicketAddress], ticketsUnwound);\r\n    balances[holderTicketAddress][msg.sender] =\r\n      safeAdd(balances[holderTicketAddress][msg.sender], ticketsUnwound);\r\n\r\n    //debit balance of 0x0 of strike, credit caller.\r\n    balances[_strikeTokenAddress][0x0] = safeSub(\r\n      balances[_strikeTokenAddress][0x0],\r\n      safeDiv(safeMul(_strikeTokenAmount, ticketsUnwound), 1 ether)\r\n    );\r\n\r\n    balances[_strikeTokenAddress][msg.sender] = safeAdd(\r\n      balances[_strikeTokenAddress][msg.sender],\r\n      safeDiv(safeMul(_strikeTokenAmount, ticketsUnwound), 1 ether)\r\n    );\r\n    \r\n    //emit event.\r\n    ExcerciseUnwind(\r\n      msg.sender,\r\n      holderTicketAddress,\r\n      ticketsUnwound,\r\n      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress)),\r\n      _fillOrKill\r\n    );\r\n    \r\n    return ticketsUnwound;\r\n  }\r\n  \r\n  //if before expiry, and own hold ticket, then pay strike, get asset, void hold ticket\r\n  function excerciseOption( //#68\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires,\r\n    uint256 _ticketAmount\r\n  )\r\n  external \r\n  returns (uint256 ticketsExcercised)\r\n  {  \r\n    //only holder before, equal to expiry\r\n    require(block.number <= _optionExpires);\r\n    \r\n    address holderTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      false\r\n    );\r\n    \r\n    //get balance of tickets\r\n    ticketsExcercised = balances[holderTicketAddress][msg.sender];\r\n    require(ticketsExcercised >= _ticketAmount); //its just a balance here.\r\n    \r\n    //get amount to trade.\r\n    if (ticketsExcercised > _ticketAmount) ticketsExcercised = _ticketAmount;\r\n    \r\n    //cant execute zero, either you have zero, or you asked for zero.\r\n    require(ticketsExcercised > 0);\r\n    \r\n    //debit balance of caller for holdOption, credit exercisedOptions    \r\n    balances[holderTicketAddress][msg.sender] =\r\n      safeSub(balances[holderTicketAddress][msg.sender], ticketsExcercised);\r\n    exercisedOptions[holderTicketAddress] =\r\n      safeAdd(exercisedOptions[holderTicketAddress], ticketsExcercised);\r\n        \r\n    //debit balance of caller for strikeToken, credit 0x0\r\n    balances[_strikeTokenAddress][msg.sender] = safeSub(\r\n      balances[_strikeTokenAddress][msg.sender],\r\n      safeDiv(safeMul(_strikeTokenAmount, ticketsExcercised), 1 ether)\r\n    );\r\n\r\n    balances[_strikeTokenAddress][0x0] = safeAdd(\r\n      balances[_strikeTokenAddress][0x0],\r\n      safeDiv(safeMul(_strikeTokenAmount, ticketsExcercised), 1 ether)\r\n    );\r\n    \r\n    //debit balance of 0x0 of asset, credit caller.   \r\n    balances[_assetTokenAddress][0x0] = safeSub(\r\n      balances[_assetTokenAddress][0x0],\r\n      safeDiv(safeMul(_assetTokenAmount, ticketsExcercised), 1 ether)\r\n    );\r\n    \r\n    balances[_assetTokenAddress][msg.sender] = safeAdd(\r\n      balances[_assetTokenAddress][msg.sender],\r\n      safeDiv(safeMul(_assetTokenAmount, ticketsExcercised), 1 ether)\r\n    );\r\n\r\n    \r\n    //no change in global balances.\r\n    //emit event.\r\n    ExcerciseOption(\r\n      msg.sender,\r\n      holderTicketAddress,\r\n      ticketsExcercised,\r\n      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\r\n    );\r\n    \r\n    return ticketsExcercised;\r\n  }\r\n\r\n  \r\n  //if after expiry, get collateral, void option.\r\n  function expireOption( //#69\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires,\r\n    uint256 _ticketAmount\r\n  )\r\n  external \r\n  returns (uint256 ticketsExpired)\r\n  {\r\n  //only writer, only after expiry\r\n    require(block.number > _optionExpires);\r\n        \r\n    address holderTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      false\r\n    );\r\n    \r\n    address writerTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      true\r\n    );\r\n    \r\n    //get balance of tickets\r\n    ticketsExpired = balances[writerTicketAddress][msg.sender];\r\n    require(ticketsExpired >= _ticketAmount); //its just a balance here.\r\n    \r\n    //get amount to trade.\r\n    if (ticketsExpired > _ticketAmount) ticketsExpired = _ticketAmount;\r\n    \r\n    //cant execute zero, either you have zero, or you asked for zero.\r\n    require(ticketsExpired > 0);\r\n    \r\n    // debit holder tickets from user, add to exercisedOptions.\r\n    balances[writerTicketAddress][msg.sender] =\r\n      safeSub(balances[writerTicketAddress][msg.sender], ticketsExpired);\r\n    exercisedOptions[writerTicketAddress] =\r\n      safeAdd(exercisedOptions[writerTicketAddress], ticketsExpired);\r\n    \r\n    //calculate amounts\r\n    uint256 strikeTokenAmount =\r\n      safeDiv(\r\n        safeMul(\r\n          safeDiv(safeMul(ticketsExpired, _strikeTokenAmount), 1 ether), //tickets\r\n          exercisedOptions[holderTicketAddress]\r\n        ),\r\n        globalBalance[holderTicketAddress]\r\n      );\r\n\r\n    uint256 assetTokenAmount =\r\n      safeDiv(\r\n        safeMul(\r\n          safeDiv(safeMul(ticketsExpired, _assetTokenAmount), 1 ether), //tickets\r\n          safeSub(globalBalance[holderTicketAddress], exercisedOptions[holderTicketAddress])\r\n        ),\r\n        globalBalance[holderTicketAddress]\r\n      );\r\n    \r\n\r\n    //debit zero, add to msg.sender\r\n    balances[_strikeTokenAddress][0x0] =\r\n      safeSub(balances[_strikeTokenAddress][0x0], strikeTokenAmount);\r\n    balances[_assetTokenAddress][0x0] =\r\n      safeSub(balances[_assetTokenAddress][0x0], assetTokenAmount);\r\n    balances[_strikeTokenAddress][msg.sender] =\r\n      safeAdd(balances[_strikeTokenAddress][msg.sender], strikeTokenAmount);\r\n    balances[_assetTokenAddress][msg.sender] =\r\n      safeAdd(balances[_assetTokenAddress][msg.sender], assetTokenAmount);\r\n  \r\n  //set inactive\r\n\r\n    ExpireOption( //#69]\r\n      msg.sender,\r\n      writerTicketAddress,\r\n      ticketsExpired,\r\n      (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress))\r\n    );\r\n    return ticketsExpired;\r\n  }\r\n\r\n\r\n  //get an option's Hash's address\r\n  //  (•_•)  ( •_•)>⌐■-■  (⌐■_■)\r\n  //\r\n  //going from 32 bytes to 20 bytes still gives us 160 bits of hash goodness.\r\n  //that's still a crazy large number, and used by ethereum for addresses.\r\n  function getOptionAddress(\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires,\r\n    bool _isWriter\r\n  )\r\n    public\r\n    view\r\n    returns(address)\r\n  {\r\n    return(\r\n      address(\r\n        keccak256(\r\n          _assetTokenAddress,\r\n          _assetTokenAmount,\r\n          _strikeTokenAddress,\r\n          _strikeTokenAmount,\r\n          _optionExpires,\r\n          _isWriter\r\n        )\r\n      )\r\n    );\r\n  }\r\n\r\n  /***********************************\r\n  / Options View Code\r\n  ************************************/\r\n  //since the options code might move, we should have a way to always\r\n  //call a function to this contract to get the current values\r\n  \r\n  function testIsOptionPairRegistered(\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires\r\n  )\r\n  external\r\n  view\r\n  returns(bool)\r\n  {\r\n    return(\r\n      OptionRegistry(optionsRegistryAddress).isOptionPairRegistered(\r\n        _assetTokenAddress,\r\n        _assetTokenAmount,\r\n        _strikeTokenAddress,\r\n        _strikeTokenAmount,\r\n        _optionExpires\r\n      )\r\n    );\r\n  }\r\n  \r\n\r\n  /***********************************\r\n  / Default Options Registration Code\r\n  ************************************/\r\n  // Register emits an event and adds it to restrictedToken.\r\n  // We'll deal with any other needed registration later.\r\n  // Set up for upgradeable external contract.\r\n  // return bools.\r\n  \r\n  event RegisterOptionsPair(\r\n    bytes32 indexed optionPair, //assetTokenAddress xor strikeTokenAddress\r\n    address indexed writerTicketAddress,\r\n    address indexed holderTicketAddress,\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires\r\n  );  \r\n  \r\n    \r\n  function registerOptionPair(\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires\r\n  )\r\n  public\r\n  returns(bool)\r\n  {\r\n    address holderTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      false\r\n    );\r\n    \r\n//    if (\r\n//      isOptionPairRegistered(\r\n//        _assetTokenAddress,\r\n//        _assetTokenAmount,\r\n//        _strikeTokenAddress,\r\n//        _strikeTokenAmount,\r\n//        _optionExpires\r\n//      )\r\n//    )\r\n    //cheaper not to make call gaswise, same result.\r\n    \r\n    if (restrictedTokens[holderTicketAddress]) {\r\n      return false;\r\n    //return halts execution, but else is better for readibility\r\n    } else {\r\n\r\n      address writerTicketAddress = getOptionAddress(\r\n        _assetTokenAddress,\r\n        _assetTokenAmount,\r\n        _strikeTokenAddress,\r\n        _strikeTokenAmount,\r\n        _optionExpires,\r\n        true\r\n      );\r\n    \r\n      restrictedTokens[holderTicketAddress] = true;\r\n      restrictedTokens[writerTicketAddress] = true;\r\n    \r\n      //an external contract would need to call something like this:\r\n      // after being registered as a helper contract on the main site.\r\n      //UberDelta(uberdeltaAddress).tokenRestriction(holderTicketAddress, true);\r\n      //UberDelta(uberdeltaAddress).tokenRestriction(writerTicketAddress, true);\r\n    \r\n      RegisterOptionsPair(\r\n        (bytes32(_assetTokenAddress) ^ bytes32(_strikeTokenAddress)),\r\n        holderTicketAddress,\r\n        writerTicketAddress,\r\n        _assetTokenAddress,\r\n        _assetTokenAmount,\r\n        _strikeTokenAddress,\r\n        _strikeTokenAmount,\r\n        _optionExpires\r\n      );\r\n    \r\n      return(true);\r\n    }\r\n  }\r\n  \r\n  \r\n  // for v1, we'll simply return if there's a restriction.\r\n  function isOptionPairRegistered(\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires\r\n  )\r\n  public\r\n  view\r\n  returns(bool)\r\n  {\r\n    address holderTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      false\r\n    );\r\n    \r\n    return(restrictedTokens[holderTicketAddress]);\r\n  }\r\n  \r\n  \r\n  function getOptionPair(\r\n    address _assetTokenAddress,\r\n    uint256 _assetTokenAmount,\r\n    address _strikeTokenAddress,\r\n    uint256 _strikeTokenAmount,\r\n    uint256 _optionExpires\r\n  )\r\n  public\r\n  view\r\n  returns(address holderTicketAddress, address writerTicketAddress)\r\n  {\r\n    holderTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      false\r\n    );\r\n    \r\n    writerTicketAddress = getOptionAddress(\r\n      _assetTokenAddress,\r\n      _assetTokenAmount,\r\n      _strikeTokenAddress,\r\n      _strikeTokenAmount,\r\n      _optionExpires,\r\n      true\r\n    );\r\n    \r\n    return(holderTicketAddress, writerTicketAddress);\r\n  }\r\n  \r\n  \r\n  /******************\r\n  / EOS Registration\r\n  ******************/\r\n  // some users will accidentally keep EOS on the exchange during the snapshot.\r\n  function EOSRegistration (string _key) external onlyOwner{\r\n    EOS(0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf).register(_key);\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_getUser\",\"type\":\"address\"},{\"name\":\"_giveUser\",\"type\":\"address\"}],\"name\":\"validateTrade\",\"outputs\":[{\"name\":\"isAllowed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[{\"name\":\"moveBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_newClass\",\"type\":\"uint256\"}],\"name\":\"changeUserClass\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"},{\"name\":\"_isWriter\",\"type\":\"bool\"}],\"name\":\"getOptionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userClass\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressData\",\"type\":\"address[4]\"},{\"name\":\"_numberData\",\"type\":\"uint256[4]\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"availableVolume\",\"outputs\":[{\"name\":\"amountRemaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toUser\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositTokenToUser\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAmount\",\"type\":\"uint256\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_withdrawExpires\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_restrictedTo\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"remoteWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_class\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"changeClassFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"testCanTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_withdrawAmount\",\"type\":\"uint256\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_withdrawExpires\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_maker\",\"type\":\"address\"},{\"name\":\"_restrictedTo\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"testRemoteWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"}],\"name\":\"isOptionPairRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"canDeposit\",\"outputs\":[{\"name\":\"isAllowed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"string\"}],\"name\":\"EOSRegistration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeByClass\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newComplianceAddress\",\"type\":\"address\"}],\"name\":\"updateComplianceAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toUser\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"internalTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newExchange\",\"type\":\"address\"}],\"name\":\"changeNewExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressData\",\"type\":\"address[4]\"},{\"name\":\"_numberData\",\"type\":\"uint256[4]\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_fillOrKill\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"tradeAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"canTrade\",\"outputs\":[{\"name\":\"isAllowed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exercisedOptions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"optionsRegistryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"},{\"name\":\"_ticketAmount\",\"type\":\"uint256\"},{\"name\":\"_fillOrKill\",\"type\":\"bool\"}],\"name\":\"optionExcerciseUnwind\",\"outputs\":[{\"name\":\"ticketsUnwound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressData\",\"type\":\"address[4]\"},{\"name\":\"_numberData\",\"type\":\"uint256[4]\"}],\"name\":\"order\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"}],\"name\":\"testIsOptionPairRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"lockContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_getUser\",\"type\":\"address\"},{\"name\":\"_giveUser\",\"type\":\"address\"}],\"name\":\"testValidateTrade\",\"outputs\":[{\"name\":\"isAllowed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"newManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"globalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"}],\"name\":\"getOptionPair\",\"outputs\":[{\"name\":\"holderTicketAddress\",\"type\":\"address\"},{\"name\":\"writerTicketAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toUser\",\"type\":\"address\"}],\"name\":\"depositToUser\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newToken\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"tokenRestriction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOptionsRegistryAddress\",\"type\":\"address\"}],\"name\":\"updateOptionsRegistryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isHelper\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_sendTo\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sweepAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"},{\"name\":\"_ticketAmount\",\"type\":\"uint256\"}],\"name\":\"collapseOptionPair\",\"outputs\":[{\"name\":\"ticketsCollapsed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressData\",\"type\":\"address[4]\"},{\"name\":\"_numberData\",\"type\":\"uint256[4]\"}],\"name\":\"amountFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"},{\"name\":\"_ticketAmount\",\"type\":\"uint256\"}],\"name\":\"expireOption\",\"outputs\":[{\"name\":\"ticketsExpired\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressData\",\"type\":\"address[4]\"},{\"name\":\"_numberData\",\"type\":\"uint256[4]\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_fillOrKill\",\"type\":\"bool\"}],\"name\":\"testTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_helper\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"changeHelper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"restrictedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAmount\",\"type\":\"uint256\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_withdrawExpires\",\"type\":\"uint256\"},{\"name\":\"_salt\",\"type\":\"uint256\"},{\"name\":\"_restrictedTo\",\"type\":\"address\"}],\"name\":\"cancelRemoteWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sweepTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"}],\"name\":\"registerOptionPair\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"testCanDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"},{\"name\":\"_ticketAmount\",\"type\":\"uint256\"}],\"name\":\"createOptionPair\",\"outputs\":[{\"name\":\"ticketsCreated\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addressData\",\"type\":\"address[4]\"},{\"name\":\"_numberData\",\"type\":\"uint256[4]\"}],\"name\":\"getHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressData\",\"type\":\"address[4]\"},{\"name\":\"_numberData\",\"type\":\"uint256[4]\"}],\"name\":\"cancelOrder\",\"outputs\":[{\"name\":\"amountCancelled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sweepAccount\",\"type\":\"address\"}],\"name\":\"changeSweepAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"complianceAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_optionExpires\",\"type\":\"uint256\"},{\"name\":\"_ticketAmount\",\"type\":\"uint256\"}],\"name\":\"excerciseOption\",\"outputs\":[{\"name\":\"ticketsExcercised\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradePair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"addressData\",\"type\":\"address[4]\"},{\"indexed\":false,\"name\":\"numberData\",\"type\":\"uint256[4]\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradePair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"addressData\",\"type\":\"address[4]\"},{\"indexed\":false,\"name\":\"numberData\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradePair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"failReason\",\"type\":\"uint256\"}],\"name\":\"FailedTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tradePair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"restrictedTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numberData\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fillOrKill\",\"type\":\"bool\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toUser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toUser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toUser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InternalTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sweeper\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"TokenSweep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"RestrictToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newExchange\",\"type\":\"address\"}],\"name\":\"NewExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"feeAccount\",\"type\":\"address\"}],\"name\":\"ChangeFeeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sweepAccount\",\"type\":\"address\"}],\"name\":\"ChangeSweepAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"class\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ChangeClassFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"class\",\"type\":\"uint256\"}],\"name\":\"ChangeUserClass\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LockContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newComplianceAddress\",\"type\":\"address\"}],\"name\":\"UpdateComplianceAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOptionsRegistryAddress\",\"type\":\"address\"}],\"name\":\"UpdateOptionsRegistryAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newExchange\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawExpires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"restrictedTo\",\"type\":\"address\"}],\"name\":\"RemoteWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawExpires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"salt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"restrictedTo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"CancelRemoteWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"holderTicketAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"writerTicketAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketsCollapsed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"optionPair\",\"type\":\"bytes32\"}],\"name\":\"CollapseOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"holderTicketAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketsUnwound\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"optionPair\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"fillOrKill\",\"type\":\"bool\"}],\"name\":\"ExcerciseUnwind\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"writerTicketAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketsExpired\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"optionPair\",\"type\":\"bytes32\"}],\"name\":\"ExpireOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"holderTicketAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"writerTicketAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketsCreated\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"optionPair\",\"type\":\"bytes32\"}],\"name\":\"CreateOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"holderTicketAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ticketsExcercised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"optionPair\",\"type\":\"bytes32\"}],\"name\":\"ExcerciseOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"optionPair\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"writerTicketAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"holderTicketAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_assetTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_strikeTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_strikeTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_optionExpires\",\"type\":\"uint256\"}],\"name\":\"RegisterOptionsPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"helper\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"ChangeHelper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"NewManager\",\"type\":\"event\"}]","ContractName":"UberDelta","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://317153de19af478b43d81e97e1c28efe4b98fc942063e2b31a630fa1d22bb948"}]}