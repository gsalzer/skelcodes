{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n @title Token77G\r\n\r\n*/\r\n\r\ncontract Token77G is Claimable, StandardToken {\r\n\r\n    string constant public name = \"GraphenTech\";\r\n    string constant public symbol = \"77G\";\r\n    uint8 constant public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it\r\n\r\n    uint256 public graphenRestrictedDate;\r\n    //Contains restricted tokens that cannot be sold before graphenDeadLine\r\n    mapping (address => uint256) private restrictedTokens;\r\n    // This array contains the list of address to be used by DAO contract\r\n    address[] private addList;\r\n    address private icoadd;\r\n\r\n    /**\r\n     @dev this event generates a public event on the blockchain that will notify clients\r\n    **/\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     @dev this event notifies clients about the amount burnt\r\n    **/\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n     /**\r\n     @dev Constructor function\r\n          Initializes contract with initial supply tokens to the creator of the contract and\r\n          allocates restriceted amount of tokens to some addresses\r\n    */\r\n    function Token77G(\r\n    address _team,\r\n    address _reserve,\r\n    address _advisors,\r\n    uint _deadLine\r\n    )\r\n    public\r\n    {\r\n\r\n        icoadd = msg.sender;\r\n        totalSupply_ = (19000000000) * 10 ** uint256(decimals);\r\n\r\n        balances[_reserve] = balances[_reserve].add((1890500000) * 10 ** uint256(decimals));\r\n        addAddress(_reserve);\r\n        emit Transfer(icoadd, _reserve, (1890500000) * 10 ** uint256(decimals));\r\n\r\n        allocateTokens(_team, (1330000000) * 10 ** uint256(decimals));\r\n        emit Transfer(icoadd, _team, (1330000000) * 10 ** uint256(decimals));\r\n\r\n        balances[_advisors] = balances[_advisors].add((950000000) * 10 ** uint256(decimals));\r\n        addAddress(_advisors);\r\n        emit Transfer(icoadd, _advisors, (950000000) * 10 ** uint256(decimals));\r\n\r\n        balances[icoadd] = (14829500000) * 10 **uint256(decimals);\r\n        graphenRestrictedDate = _deadLine;\r\n\r\n    }\r\n\r\n    /**\r\n     @dev Return number of restricted tokens from address\r\n\r\n\r\n      @param _add The address to check restricted tokens\r\n    */\r\n    function restrictedTokensOf(address _add) public view returns(uint restrctedTokens) {\r\n        return restrictedTokens[_add];\r\n    }\r\n\r\n    /**\r\n     @dev Transfer tokens\r\n          Send `_value` tokens to `_to` from your account\r\n\r\n      @param _to The address of the recipient\r\n      @param _value the amount to send\r\n    */\r\n    // solhint-disable-next-line\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        uint256  tmpRestrictedDate;\r\n\r\n        if (restrictedTokens[msg.sender] > 0) {\r\n            require((now < tmpRestrictedDate && _value <= (balances[msg.sender].sub(restrictedTokens[msg.sender])))||now >= tmpRestrictedDate);// solhint-disable-line\r\n        }\r\n        if (balances[_to] == 0) addAddress(_to);\r\n        _transfer(_to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev Transfer tokens from one address to another\r\n        @param _from address The address which you want to send tokens from\r\n        @param _to address The address which you want to transfer to\r\n        @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\r\n        uint256 tmpRestrictedDate;\r\n\r\n        if (restrictedTokens[msg.sender] > 0) {\r\n            require((now < tmpRestrictedDate && _value <= (balances[msg.sender]-restrictedTokens[msg.sender]))||now >= tmpRestrictedDate);// solhint-disable-line\r\n        }\r\n\r\n        if (balances[_to] == 0)addAddress(_to);\r\n        super.transferFrom(_from, _to, _value);\r\n        return true;\r\n\r\n    }\r\n     /**\r\n     @dev Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    // solhint-disable-next-line\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);            // Subtract from the sender\r\n        totalSupply_ = totalSupply_.sub(_value);                      // Updates totalSupply_\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, 0x0, _value);\r\n        return true;\r\n    }\r\n\r\n     /**\r\n     @dev Returns address by position\r\n\r\n     @param _index contains the position to find in addList\r\n     */\r\n    function getAddressFromList(uint256 _index)public view  returns (address add) {\r\n        require(_index < addList.length);\r\n        return addList[_index];\r\n    }\r\n\r\n     /**\r\n     @dev Returns length of address list\r\n\r\n     @return uint list size\r\n     */\r\n    function getAddListSize()public view  returns (uint) {\r\n        return addList.length;\r\n    }\r\n\r\n     /**\r\n     @dev This function adds a number of tokes to an address and sets this tokens as restricted.\r\n\r\n      @param _add The address to allocate restricted tokens\r\n      @param _value Number of tokens to be given\r\n    */\r\n    function allocateTokens(address _add, uint256 _value) private {\r\n        balances[_add] = balances[_add].add(_value);\r\n        restrictedTokens[_add] = restrictedTokens[_add].add(_value);\r\n        addAddress(_add);\r\n    }\r\n\r\n     /**\r\n     @dev Internal transfer, only can be called by this contract.\r\n\r\n      @param _to The address of the recipient\r\n      @param _value number of tokens to be transfered.\r\n     */\r\n    function _transfer(address _to, uint256 _value) private {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balances[msg.sender] >= _value);\r\n        // Check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n        // Save this for an assertion in the future\r\n        uint256 previousBalances = balances[msg.sender].add(balances[_to]);\r\n        // Subtract from the sender\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);// Con libreria Maths\r\n        // Add the same to the recipient\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[msg.sender] + balances[_to] == previousBalances);\r\n    }\r\n\r\n   /**\r\n     @dev Adcd ..\r\n     cd a new address to list of address\r\n          Include `_add´ if doesn´t exist within addList\r\n\r\n     @param _add contains the address to be included in the addList.\r\n     */\r\n    function addAddress(address _add) private {\r\n        addList.push(_add);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n @title ICO_Graphene\r\n*/\r\n\r\ncontract ICO_Graphene is Claimable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // Shows  number of tokens available for Private-ICO\r\n    uint256 public availablePrivateICO;\r\n    // Shows  number of tokens available for PRE-ICO\r\n    uint256 public availablePreICO;\r\n    // Shows  number of tokens available for ICO_w1\r\n    uint256 public availableICO_w1;\r\n    // Shows  number of tokens available for ICO_w2\r\n    uint256 public availableICO_w2;\r\n\r\n    // Shows  number of tokens totals available for ICO\r\n    uint256 public availableICO;\r\n\r\n    // Counts ETHs raised in the ICO\r\n    uint256 public amountRaised;\r\n    // Number of tokens sold within Private-ICO, PRE-ICO and ICO_w1 and ICO_w2\r\n    uint256 public tokensSold;\r\n    // Number of token decimals\r\n    uint256 private decimals;\r\n\r\n    // Shows PrivateICO starting timestamp\r\n    uint256 public startPrivateICO = 1528329600; // 1528329600 Thursday, 07-Jun-18 00:00:00 UTC\r\n    // Shows PrivateICO ending timestamp\r\n    uint256 public endPrivateICO = 1532649599; // 1532649599 Thursday, 26-Jul-18 23:59:59 UTC\r\n\r\n    // Shows Pre-ICO starting timestamp\r\n    uint256 public startPreICO = 1532649600; // 1532649600 Friday, 27-Jul-18 00:00:00 UTC\r\n    // Shows Pre-ICO ending timestamp\r\n    uint256 public endPreICO = 1535327999; // 1535327999 Sunday, 26-Aug-18 23:59:59 UTC\r\n\r\n    // Shows ICO starting timestamp\r\n    uint256 public startICO_w1 = 1535328000; // 1535328000 Monday, 27-Aug-18 00:00:00 UTC\r\n    // Shows ICO ending timestamp\r\n    uint256 public endICO_w1 = 1538006399; // 1538006399 Thursday, 26-Sep-18 23:59:59 UTC\r\n\r\n    // Shows ICO starting timestamp\r\n    uint256 public startICO_w2 = 1538006400; // 1538006400 Friday, 27-Sep-18 00:00:00 UTC\r\n    // Shows ICO ending timestamp\r\n    uint256 public endICO_w2 = 1540684799; // 1540684799 Wednesday, 27-Oct-18 23:59:59 UTC\r\n\r\n    // ICO status list\r\n    enum StatusList { NotStarted, Running, Waiting, Closed, Paused}\r\n    // ICO current status\r\n    StatusList public status;\r\n    // ICO stages list\r\n    enum StagesList { N_A, PrivateICO, PreICO, ICO_w1, ICO_w2}\r\n    // ICO current status\r\n    StagesList public stage;\r\n    // Contains token price within each stage\r\n    uint256[5] private tokenPrice;\r\n    // Contains token contract\r\n    Token77G private tokenReward;\r\n\r\n    // Some tokens cannot be sold before this date.\r\n    // 6 moths after finish ico\r\n    uint256 public restrictedTokensDate = 1550447999; // Sunday, 17-Feb-19 23:59:59 UTC\r\n\r\n    // Contains token contract address\r\n    address public tokenAdd;\r\n\r\n    // Shows purchase address and amount\r\n    mapping(address => uint256) public purchaseMap;\r\n    // Contains ETHs that cannot be sent to an address.\r\n    // mapping(address => uint256) public failToTranferList;\r\n\r\n    // List of address\r\n\r\n    // Token's delivery\r\n    address constant private TOKENSRESERVE = 0xA89779a50b3540677495e12eA09f02B6Bf09803F;\r\n    address constant private TEAM = 0x39E545F03d26334d735815Bb9882423cE46d8326;\r\n    address constant private ADVISORS = 0x96DFaBbD575C48d82e5bCC92f64E0349Da60712a;\r\n\r\n    // Eth's delivery\r\n    address constant private SALARIES = 0x99330754059f1348296526a52AA4F787a7648B46;\r\n    address constant private MARKETINGandBUSINESS = 0x824663D62c22f2592c5a3DC37638C09907adE7Ec;\r\n    address constant private RESEARCHandDEVELOPMENT = 0x7156023Cd4579Eb6a7A171062A44574809B353C8;\r\n    address constant private RESERVE = 0xAE55c485Fe70Ce6E547A30f5F4b28F32D9c1c093;\r\n    address constant private FACTORIES = 0x30CF1d5F0c561118fA017f15B86f914ef5C078e6;\r\n    address constant private PLANEQUIPMENT = 0xC74c83d8eC7c6233715b0aD8Ba4da8f72301fA24;\r\n    address constant private PRODUCTION = 0xEa0553a23469cb7140190d443762d70664a36343;\r\n\r\n\r\n    /**\r\n     @dev This event notifies a tokens purchase\r\n    **/\r\n    event Purchase(address _from, uint _amount, uint _tokens);\r\n\r\n    /**\r\n     @dev Checks if ICO is active\r\n     @param _status StatusList condition to compare with current status\r\n    **/\r\n    modifier onlyInState (StatusList _status) {\r\n        require(_status == status);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     @dev Checks if ICO status is not PAUSED\r\n    **/\r\n    modifier onlyIfNotPaused() {\r\n        require(status != StatusList.Paused);\r\n        _;\r\n    }\r\n\r\n     /**\r\n     @dev Constructor. Creates ICO_Graphene tokens and define PrivateICO, PreICO, ICO tokens.\r\n          ICO status and stages are set to initial values.\r\n    */\r\n    function ICO_Graphene() public {\r\n\r\n        tokenReward = new Token77G(TEAM, TOKENSRESERVE, ADVISORS, restrictedTokensDate);\r\n\r\n        tokenAdd = tokenReward;\r\n        decimals = tokenReward.decimals();\r\n        status = StatusList.NotStarted;\r\n        stage = StagesList.N_A;\r\n        amountRaised = 0;\r\n        tokensSold = 0;\r\n\r\n        availablePrivateICO = (1729000000) * 10 ** uint256(decimals);\r\n        availablePreICO = (3325000000) * 10 ** uint256(decimals);\r\n        availableICO_w1 = (5120500000) * 10 ** uint256(decimals);\r\n        availableICO_w2 = (4655000000) * 10 ** uint256(decimals);\r\n\r\n        tokenPrice = [0, 13860000000000, 14850000000000, 17820000000000, 19800000000000];\r\n\r\n    }\r\n\r\n     /**\r\n\r\n     @dev The function (Fallback) without name is the default function that is called whenever\r\n          anyone sends funds to a contract, this method starts purchase process.\r\n     */\r\n    function () public payable onlyIfNotPaused {\r\n        updateStatus();\r\n        if (stage == StagesList.PrivateICO) {\r\n            require(msg.value >= 1000000000000000000 wei);\r\n        }\r\n        _transfer();\r\n        updateStatusViaTokens();\r\n    }\r\n\r\n      /**\r\n     @dev Standar function to kill ICO contract and return ETHs to owner.\r\n    */\r\n    function kill()\r\n    external onlyOwner onlyInState(StatusList.Closed) {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /**\r\n     @dev Public function to be call by owner that changes ICO status to Pause.\r\n          No other function will be available if status is Pause but unpause()\r\n     */\r\n    function pause() public onlyOwner {\r\n        updateStatus();\r\n        require(status != StatusList.Closed);\r\n        status = StatusList.Paused;\r\n    }\r\n\r\n    /**\r\n     @dev Public function to be call by owner when ICO status is Paused, it changes ICO status to the right status\r\n          based on ICO dates.\r\n     */\r\n    function unpause() public onlyOwner onlyInState(StatusList.Paused) {\r\n        updateStatus();\r\n        updateStatusViaTokens();\r\n    }\r\n\r\n    /**\r\n     @dev PRE-ICO and ICO times can be changed with this function by the owner if ICO has not started.\r\n    *     This function changes startTimestamp time with _startingTime given.\r\n     @param     _startPrivateICO contains new starting date for PRE-ICO\r\n     @param     _endPrivateICO contains new ending date for PRE-ICO\r\n     @param     _startPreICO contains new starting date for ICO\r\n     @param     _endPreICO contains new ending date for ICO\r\n     @param     _startICO_w1 contains new starting date for PRE-ICO\r\n     @param     _endICO_w1 contains new ending date for PRE-ICO\r\n     @param     _startICO_w2 contains new starting date for ICO\r\n     @param     _endICO_w2 contains new ending date for ICO\r\n    */\r\n    function setNewICOTime(\r\n    uint _startPrivateICO,\r\n    uint _endPrivateICO,\r\n    uint _startPreICO,\r\n    uint _endPreICO,\r\n    uint _startICO_w1,\r\n    uint _endICO_w1,\r\n    uint _startICO_w2,\r\n    uint _endICO_w2\r\n    )\r\n    public\r\n    onlyOwner onlyInState(StatusList.NotStarted) {\r\n        require(now < startPrivateICO && startPrivateICO < endPrivateICO && startPreICO < endPreICO && startICO_w1 < endICO_w1 && startICO_w2 < endICO_w2); // solhint-disable-line\r\n        startPrivateICO = _startPrivateICO;\r\n        endPrivateICO = _endPrivateICO;\r\n        startPreICO = _startPreICO;\r\n        endPreICO = _endPreICO;\r\n        startICO_w1 = _startICO_w1;\r\n        endICO_w1 = _endICO_w1;\r\n        startICO_w2 = _startICO_w2;\r\n        endICO_w2 = _endICO_w2;\r\n    }\r\n\r\n    /**\r\n     @dev This function can be call by owner to close the ICO if status is closed .\r\n    *     Transfer the excess tokens to RESERVE if there are available tokens\r\n    */\r\n     function closeICO() public onlyOwner {\r\n        updateStatus();\r\n        require(status == StatusList.Closed);\r\n        transferExcessTokensToReserve();\r\n    }\r\n\r\n    function transferExcessTokensToReserve() internal {\r\n      availableICO = tokenReward.balanceOf(this);\r\n      if (availableICO > 0) {\r\n        tokenReward.transfer(TOKENSRESERVE, availableICO);\r\n      }\r\n    }\r\n\r\n    /**\r\n     @dev Internal function to manage ICO status, as described in the withepaper\r\n          ICO is available for purchases if date & time is within the PRE-ICO or ICO dates.\r\n     */\r\n    function updateStatus() internal {\r\n        if (now >= endICO_w2) {// solhint-disable-line\r\n            status = StatusList.Closed;\r\n        } else {\r\n            // solhint-disable-next-line\r\n            if ((now > endPrivateICO && now < startPreICO) || (now > endPreICO && now < startICO_w1)) {\r\n                status = StatusList.Waiting;\r\n            } else {\r\n                if (now < startPrivateICO) {// solhint-disable-line\r\n                    status = StatusList.NotStarted;\r\n                } else {\r\n                    status = StatusList.Running;\r\n                    updateStages();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     @dev Internal function to manage ICO status when tokens are sold out.\r\n          ICO has a number of limmited tokens to be sold within PrivateICO, PRE-ICO and ICO stages,\r\n          this method changes status to WaitingICO if PRE-ICO tokens are sold out or\r\n          Closed when ICO tokens are sold out.\r\n     */\r\n    function updateStatusViaTokens() internal {\r\n        availableICO = tokenReward.balanceOf(this);\r\n        if (availablePrivateICO == 0 && stage == StagesList.PrivateICO) status = StatusList.Waiting;\r\n        if (availablePreICO == 0 && stage == StagesList.PreICO) status = StatusList.Waiting;\r\n        if (availableICO_w1 == 0 && stage == StagesList.ICO_w1) status = StatusList.Waiting;\r\n        if (availableICO_w2 == 0 && stage == StagesList.ICO_w2) status = StatusList.Waiting;\r\n        if (availableICO == 0) status = StatusList.Closed;\r\n    }\r\n\r\n    /**\r\n     @dev Internal function to manage ICO stages.\r\n          Stage is used in order to calculate the proper token price.\r\n     */\r\n    function updateStages() internal onlyInState(StatusList.Running) {\r\n        if (now <= endPrivateICO && now > startPrivateICO) { stage = StagesList.PrivateICO; return;}// solhint-disable-line\r\n        if (now <= endPreICO && now > startPreICO) { stage = StagesList.PreICO; return;}// solhint-disable-line\r\n        if (now <= endICO_w1 && now > startICO_w1) { stage = StagesList.ICO_w1; return;}// solhint-disable-line\r\n        if (now <= endICO_w2 && now > startICO_w2) { stage = StagesList.ICO_w2; return;}// solhint-disable-lin\r\n        stage = StagesList.N_A;\r\n    }\r\n\r\n     /**\r\n      @dev Private function to manage GrapheneTech purchases by calculating the right number\r\n           of tokens based on the value sent.\r\n           Includes any purchase within a mapping to track address and amount spent.\r\n           Tracks the number of tokens sold. and ICO amount raised\r\n           Transfer tokens to the buyer address.\r\n           Calculates refound value if applais.\r\n     */\r\n    function _transfer() private onlyInState(StatusList.Running) {\r\n        uint amount = msg.value;\r\n        uint amountToReturn = 0;\r\n        uint tokens = 0;\r\n        (tokens, amountToReturn) = getTokens(amount);\r\n        purchaseMap[msg.sender] = purchaseMap[msg.sender].add(amount);\r\n        tokensSold = tokensSold.add(tokens);\r\n        amount = amount.sub(amountToReturn);\r\n        amountRaised = amountRaised.add(amount);\r\n        if (stage == StagesList.PrivateICO) availablePrivateICO = availablePrivateICO.sub(tokens);\r\n        if (stage == StagesList.PreICO) availablePreICO = availablePreICO.sub(tokens);\r\n        if (stage == StagesList.ICO_w1) availableICO_w1 = availableICO_w1.sub(tokens);\r\n        if (stage == StagesList.ICO_w2) availableICO_w2 = availableICO_w2.sub(tokens);\r\n        tokenReward.transfer(msg.sender, tokens);\r\n        sendETH(amount);\r\n\r\n        if (amountToReturn > 0) {\r\n            bool refound = msg.sender.send(amountToReturn);\r\n            require(refound);\r\n        }\r\n\r\n        emit Purchase(msg.sender, amount, tokens);\r\n    }\r\n\r\n     /**\r\n      @dev Returns the number of tokens based on the ETH sent and token price.\r\n\r\n      @param _value this contais the ETHs sent and it is used to calculate the right number of tokens to be transfered.\r\n      @return number of tokens based on the ETH sent and token price.\r\n     */\r\n    function getTokens(uint256 _value)\r\n    private view\r\n    onlyInState(StatusList.Running)\r\n    returns(uint256 numTokens, uint256 amountToReturn) {\r\n\r\n        uint256 eths = _value.mul(10**decimals);//Adding decimals to get an acurate number of tokens\r\n        numTokens = 0;\r\n        uint256 tokensAvailable = 0;\r\n        numTokens = eths.div(tokenPrice[uint256(stage)]);\r\n\r\n        if (stage == StagesList.PrivateICO) {\r\n            tokensAvailable = availablePrivateICO;\r\n        } else if (stage == StagesList.PreICO) {\r\n            tokensAvailable = availablePreICO;\r\n        } else if (stage == StagesList.ICO_w1) {\r\n            tokensAvailable = availableICO_w1;\r\n        } else if (stage == StagesList.ICO_w2) {\r\n            tokensAvailable = availableICO_w2;\r\n        }\r\n\r\n        if (tokensAvailable >= numTokens) {\r\n            amountToReturn = 0;\r\n        } else {\r\n            numTokens = tokensAvailable;\r\n            amountToReturn = _value.sub(numTokens.div(10**decimals).mul(tokenPrice[uint256(stage)]));\r\n        }\r\n\r\n        return (numTokens, amountToReturn);\r\n    }\r\n\r\n    /**\r\n     @dev This function sends ETHs to the list of address SALARIES, MARKETINGandBUSINESS, RESEARCHandDEVELOPMENT, RESERVE, FACTORIES, PLANEQUIPMENT, PRODUCTION\r\n     @param _amount this are the ETHs that have to be send between different address.\r\n\r\n    */\r\n    function sendETH(uint _amount)  private {\r\n\r\n        uint paymentSALARIES = _amount.mul(3).div(100);\r\n        uint paymentMARKETINGandBUSINESS = _amount.mul(4).div(100);\r\n        uint paymentRESEARCHandDEVELOPMENT = _amount.mul(14).div(100);\r\n        uint paymentRESERVE = _amount.mul(18).div(100);\r\n        uint paymentFACTORIES = _amount.mul(24).div(100);\r\n        uint paymentPLANEQUIPMENT = _amount.mul(19).div(100);\r\n        uint paymentPRODUCTION = _amount.mul(18).div(100);\r\n\r\n        SALARIES.transfer(paymentSALARIES);\r\n        MARKETINGandBUSINESS.transfer(paymentMARKETINGandBUSINESS);\r\n        RESEARCHandDEVELOPMENT.transfer(paymentRESEARCHandDEVELOPMENT);\r\n        RESERVE.transfer(paymentRESERVE);\r\n        FACTORIES.transfer(paymentFACTORIES);\r\n        PLANEQUIPMENT.transfer(paymentPLANEQUIPMENT);\r\n        PRODUCTION.transfer(paymentPRODUCTION);\r\n\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"availableICO_w2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPrivateICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startPrivateICO\",\"type\":\"uint256\"},{\"name\":\"_endPrivateICO\",\"type\":\"uint256\"},{\"name\":\"_startPreICO\",\"type\":\"uint256\"},{\"name\":\"_endPreICO\",\"type\":\"uint256\"},{\"name\":\"_startICO_w1\",\"type\":\"uint256\"},{\"name\":\"_endICO_w1\",\"type\":\"uint256\"},{\"name\":\"_startICO_w2\",\"type\":\"uint256\"},{\"name\":\"_endICO_w2\",\"type\":\"uint256\"}],\"name\":\"setNewICOTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchaseMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startICO_w1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availablePrivateICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availablePreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPrivateICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endICO_w1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restrictedTokensDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startICO_w2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endICO_w2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableICO_w1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ICO_Graphene","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d7a0a9e4d4f45e014aea81134bc788251b30ea6ed498a5456aafdca7424b9c76"}]}