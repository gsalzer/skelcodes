{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/// @title a contract interface of the ERC-20 token standard\r\n/// @author Mish Ochu\r\n/// @dev Ref: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\ninterface ERC20 {\r\n\r\n  // Required methods\r\n  function transfer (address to, uint256 value) public returns (bool success);\r\n  function transferFrom (address from, address to, uint256 value) public returns (bool success);\r\n  function approve (address spender, uint256 value) public returns (bool success);\r\n  function allowance (address owner, address spender) public constant returns (uint256 remaining);\r\n  function balanceOf (address owner) public constant returns (uint256 balance);\r\n  // Events\r\n  event Transfer (address indexed from, address indexed to, uint256 value);\r\n  event Approval (address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// @title Interface for contracts conforming to ERC-165: Pseudo-Introspection, or standard interface detection\r\n/// @author Mish Ochu\r\ninterface ERC165 {\r\n  /// @dev true iff the interface is supported\r\n  function supportsInterface(bytes4 interfaceID) external constant returns (bool);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event NewOwner(address indexed owner);\r\n\r\n  function Ownable () public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier restricted () {\r\n    require(owner == msg.sender);\r\n    _;\r\n  }\r\n\r\n  function setOwner (address candidate) public restricted returns (bool) {\r\n    require(candidate != address(0));\r\n    owner = candidate;\r\n    NewOwner(owner);\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\ncontract InterfaceSignatureConstants {\r\n  bytes4 constant InterfaceSignature_ERC165 =\r\n    bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n  bytes4 constant InterfaceSignature_ERC20 =\r\n    bytes4(keccak256('totalSupply()')) ^\r\n    bytes4(keccak256('balanceOf(address)')) ^\r\n    bytes4(keccak256('transfer(address,uint256)')) ^\r\n    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('approve(address,uint256)')) ^\r\n    bytes4(keccak256('allowance(address,address)'));\r\n\r\n  bytes4 constant InterfaceSignature_ERC20_PlusOptions = \r\n    bytes4(keccak256('name()')) ^\r\n    bytes4(keccak256('symbol()')) ^\r\n    bytes4(keccak256('decimals()')) ^\r\n    bytes4(keccak256('totalSupply()')) ^\r\n    bytes4(keccak256('balanceOf(address)')) ^\r\n    bytes4(keccak256('transfer(address,uint256)')) ^\r\n    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('approve(address,uint256)')) ^\r\n    bytes4(keccak256('allowance(address,address)'));\r\n}\r\n\r\ncontract AirdropCampaign is Ownable, InterfaceSignatureConstants {\r\n  address public tokenAddress;\r\n  address public tokenHolderAddress;\r\n  uint256 public disbursementAmount;\r\n  bool    public canDisburseMultipleTimes;\r\n\r\n  mapping (address => uint256) public disbursements;\r\n\r\n  modifier notHolder () {\r\n    if (tokenHolderAddress == msg.sender) revert();\r\n    _;\r\n  }\r\n\r\n  function AirdropCampaign (address tokenContract, address tokenHolder, uint256 amount) Ownable() public {\r\n    // allow for not supplying the constructor with a working token\r\n    // and updating it later, however, if an address is supplied make\r\n    // sure it conforms to our token requirements\r\n    if (tokenContract != address(0)) {\r\n      setTokenAddress(tokenContract);\r\n    }\r\n\r\n    if (tokenHolder != address(0)) {\r\n      setTokenHolderAddress(tokenHolder);\r\n    }\r\n\r\n    setDisbursementAmount(amount);\r\n  }\r\n\r\n  function register () public notHolder {\r\n    if (!canDisburseMultipleTimes &&\r\n        disbursements[msg.sender] > uint256(0)) revert();\r\n\r\n    ERC20 tokenContract = ERC20(tokenAddress);\r\n\r\n    disbursements[msg.sender] += disbursementAmount;\r\n    if (!tokenContract.transferFrom(tokenHolderAddress, msg.sender, disbursementAmount)) revert();\r\n  }\r\n\r\n  function setTokenAddress (address candidate) public restricted {\r\n    ERC165 candidateContract = ERC165(candidate);\r\n\r\n    // roundabout way of verifying this\r\n    // 1. this address must have the code for 'supportsInterface' (ERC165), and,\r\n    // 2. this address must return true given the hash of the interface for ERC20\r\n    if (!candidateContract.supportsInterface(InterfaceSignature_ERC20)) revert();\r\n    tokenAddress = candidateContract;\r\n  }\r\n\r\n  function setDisbursementAmount (uint256 amount) public restricted {\r\n    if (amount == 0) revert();\r\n    disbursementAmount = amount;\r\n  }\r\n\r\n  function setCanDisburseMultipleTimes (bool value) public restricted {\r\n    canDisburseMultipleTimes = value;\r\n  }\r\n\r\n  function setTokenHolderAddress(address holder) public restricted {\r\n    tokenHolderAddress = holder;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setDisbursementAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenHolderAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"disbursements\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canDisburseMultipleTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setCanDisburseMultipleTimes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"setTokenHolderAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disbursementAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"tokenHolder\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"}]","ContractName":"AirdropCampaign","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000235fe624e044a05eed7a43e16e3083bc8a4287a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002a5a058fc295ed000000","Library":"","SwarmSource":"bzzr://4c5c4abfeb21dc45e1e9cc9555fef78f1613f451fa20f85d13fd2bd70d0b77c9"}]}