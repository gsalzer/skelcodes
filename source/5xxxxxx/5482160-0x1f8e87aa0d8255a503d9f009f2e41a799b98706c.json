{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\nThis file is part of the Cryptaur Contract.\r\n\r\nThe CryptaurToken Contract is free software: you can redistribute it and/or\r\nmodify it under the terms of the GNU lesser General Public License as published\r\nby the Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version. See the GNU lesser General Public License\r\nfor more details.\r\n\r\nYou should have received a copy of the GNU lesser General Public License\r\nalong with the CryptaurToken Contract. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n@author Ilya Svirin <i.svirin@nordavind.ru>\r\nDonation address 0x3Ad38D1060d1c350aF29685B2b8Ec3eDE527452B\r\n*/\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract owned {\r\n\r\n    address public owner;\r\n    address public candidate;\r\n\r\n    function owned() payable public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function changeOwner(address _owner) onlyOwner public {\r\n        candidate = _owner;\r\n    }\r\n    \r\n    function confirmOwner() public {\r\n        require(candidate == msg.sender);\r\n        owner = candidate;\r\n        delete candidate;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Part of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Base {\r\n    uint public totalSupply;\r\n    function balanceOf(address who) public constant returns (uint);\r\n    function transfer(address to, uint value) public;\r\n}\r\n\r\ncontract CryptaurRewards {\r\n    function payment(address _buyer, address _seller, uint _amount, address _opinionLeader) public returns(uint fee);\r\n}\r\n\r\ncontract CryputarReserveFund {\r\n    function depositNotification(uint _amount) public;\r\n    function withdrawNotification(uint _amount) public;\r\n}\r\n\r\n/**\r\n * @title Allows to store liked adsress(slave address) connected to the main address (master address)\r\n */\r\ncontract AddressBook {\r\n\r\n    struct AddressRelations {\r\n        SlaveDictionary slaves;\r\n        bool hasValue;\r\n    }\r\n\r\n    struct SlaveDictionary\r\n    {\r\n        address[] values;\r\n        mapping(address => uint) keys;\r\n    }\r\n\r\n    event WalletLinked(address indexed _master, address indexed _slave);\r\n    event WalletUnlinked(address indexed _master, address indexed _slave);\r\n    event AddressChanged(address indexed _old, address indexed _new);\r\n\r\n    mapping(address => AddressRelations) private masterToSlaves;\r\n    mapping(address => address) private slaveToMasterAddress;\r\n    uint8 public maxLinkedWalletCount = 5;\r\n\r\n    function AddressBook() public {}\r\n\r\n    function getLinkedWallets(address _wallet) public view returns (address[]) {\r\n        return masterToSlaves[_wallet].slaves.values;\r\n    }\r\n\r\n    /**\r\n     * Only owner of master wallet can add additional wallet.\r\n     */\r\n    function linkToMasterWalletInternal(address _masterWallet, address _linkedWallet) internal {\r\n        require(_masterWallet != _linkedWallet && _linkedWallet != address(0));\r\n        require(isMasterWallet(_masterWallet));\r\n        require(!isLinkedWallet(_linkedWallet) && !isMasterWallet(_linkedWallet));\r\n        AddressRelations storage rel = masterToSlaves[_masterWallet];\r\n        require(rel.slaves.values.length < maxLinkedWalletCount);    \r\n        rel.slaves.values.push(_linkedWallet);\r\n        rel.slaves.keys[_linkedWallet] = rel.slaves.values.length - 1;\r\n        slaveToMasterAddress[_linkedWallet] = _masterWallet;\r\n        WalletLinked(_masterWallet, _linkedWallet);\r\n    }\r\n \r\n    function unLinkFromMasterWalletInternal(address _masterWallet, address _linkedWallet) internal {\r\n        require(_masterWallet != _linkedWallet && _linkedWallet != address(0));\r\n        require(_masterWallet == getMasterWallet(_linkedWallet));\r\n        SlaveDictionary storage slaves = masterToSlaves[_masterWallet].slaves;\r\n        uint indexToDelete = slaves.keys[_linkedWallet];\r\n        address keyToMove = slaves.values[slaves.values.length - 1];\r\n        slaves.values[indexToDelete] = keyToMove;\r\n        slaves.keys[keyToMove] = indexToDelete;\r\n        slaves.values.length--;\r\n        delete slaves.keys[_linkedWallet];\r\n        delete slaveToMasterAddress[_linkedWallet];\r\n        WalletUnlinked(_masterWallet, _linkedWallet);\r\n    }\r\n\r\n    function isMasterWallet(address _addr) internal constant returns (bool) {\r\n        return masterToSlaves[_addr].hasValue;\r\n    }\r\n\r\n    function isLinkedWallet(address _addr) internal constant returns (bool) {\r\n        return slaveToMasterAddress[_addr] != address(0);\r\n    }\r\n\r\n    /**\r\n     * Guess that address book already had changing address.\r\n     */ \r\n    function applyChangeWalletAddress(address _old, address _new) internal {\r\n        require(isMasterWallet(_old) || isLinkedWallet(_old));\r\n        require(_new != address(0));\r\n        if (isMasterWallet(_old)) {\r\n            // Cannt change master address with existed linked\r\n            require(!isLinkedWallet(_new));\r\n            require(masterToSlaves[_new].slaves.values.length == 0);\r\n            changeMasterAddress(_old, _new);\r\n        }\r\n        else {\r\n            // Cannt change linked address with existed master and linked to another master\r\n            require(!isMasterWallet(_new) && !isLinkedWallet(_new));\r\n            changeLinkedAddress(_old, _new);\r\n        }\r\n    }\r\n\r\n    function addMasterWallet(address _master) internal {\r\n        require(_master != address(0));\r\n        masterToSlaves[_master].hasValue = true;\r\n    }\r\n\r\n    function getMasterWallet(address _wallet) internal constant returns(address) {\r\n        if(isMasterWallet(_wallet))\r\n            return _wallet;\r\n        return slaveToMasterAddress[_wallet];  \r\n    }\r\n\r\n    /**\r\n     * Try to find master address by any other; otherwise add to address book as master.\r\n     */\r\n    function getOrAddMasterWallet(address _wallet) internal returns (address) {\r\n        address masterWallet = getMasterWallet(_wallet);\r\n        if (masterWallet == address(0))\r\n            addMasterWallet(_wallet);\r\n        return _wallet;\r\n    }\r\n\r\n    function changeLinkedAddress(address _old, address _new) internal {\r\n        slaveToMasterAddress[_new] = slaveToMasterAddress[_old];     \r\n        SlaveDictionary storage slaves = masterToSlaves[slaveToMasterAddress[_new]].slaves;\r\n        uint index = slaves.keys[_old];\r\n        slaves.values[index] = _new;\r\n        delete slaveToMasterAddress[_old];\r\n    }\r\n    \r\n    function changeMasterAddress(address _old, address _new) internal {    \r\n        masterToSlaves[_new] = masterToSlaves[_old];  \r\n        SlaveDictionary storage slaves = masterToSlaves[_new].slaves;\r\n        for (uint8 i = 0; i < slaves.values.length; ++i)\r\n            slaveToMasterAddress[slaves.values[i]] = _new;\r\n        delete masterToSlaves[_old];\r\n    }\r\n}\r\n\r\ncontract CryptaurDepository is owned, AddressBook {\r\n    enum UnlimitedMode {UNLIMITED, LIMITED}\r\n\r\n    event Deposit(address indexed _who, uint _amount, bytes32 _txHash);\r\n    event Withdraw(address indexed _who, uint _amount);\r\n    event Payment(address indexed _buyer, address indexed _seller, uint _amount, address indexed _opinionLeader, bool _dapp);\r\n    event Freeze(address indexed _who, bool _freeze);\r\n    event Share(address indexed _who, address indexed _dapp, uint _amount);\r\n    event SetUnlimited(bool _unlimited, address indexed _dapp);\r\n\r\n    ERC20Base cryptaurToken = ERC20Base(0x88d50B466BE55222019D71F9E8fAe17f5f45FCA1);\r\n    address public cryptaurRecovery;\r\n    address public cryptaurRewards;\r\n    address public cryptaurReserveFund;\r\n    address public backend;\r\n    modifier onlyBackend {\r\n        require(backend == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrBackend {\r\n        require(owner == msg.sender || backend == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier notFreezed {\r\n        require(!freezedAll && !freezed[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    mapping(address => uint) internal balances;\r\n    mapping(address => mapping (address => uint256)) public available;\r\n    mapping(address => bool) public freezed;\r\n    mapping(address => mapping(address => UnlimitedMode)) public unlimitedMode;\r\n    bool freezedAll;\r\n  \r\n    function CryptaurDepository() owned() public {}\r\n\r\n    function sub(uint _a, uint _b) internal pure returns (uint) {\r\n        assert(_b <= _a);\r\n        return _a - _b;\r\n    }\r\n\r\n    function add(uint _a, uint _b) internal pure returns (uint) {\r\n        uint c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n\r\n    function balanceOf(address _who) constant public returns (uint) {\r\n        return balances[getMasterWallet(_who)];\r\n    }\r\n\r\n    function setUnlimitedMode(bool _unlimited, address _dapp) public {\r\n        address masterWallet = getOrAddMasterWallet(msg.sender);\r\n        unlimitedMode[masterWallet][_dapp] = _unlimited ? UnlimitedMode.UNLIMITED : UnlimitedMode.LIMITED;\r\n        SetUnlimited(_unlimited, _dapp);\r\n    }\r\n\r\n    function transferToToken(address[] _addresses) public onlyOwnerOrBackend {\r\n        for (uint index = 0; index < _addresses.length; index++) {\r\n            address addr = _addresses[index];\r\n            uint amount = balances[addr];\r\n            if (amount > 0) {\r\n                balances[addr] = 0;\r\n                cryptaurToken.transfer(addr, amount);\r\n                Withdraw(addr, amount);\r\n            }        \r\n        }\r\n    }\r\n\r\n    function setBackend(address _backend) onlyOwner public {\r\n        backend = _backend;\r\n    }\r\n\r\n    function setCryptaurRecovery(address _cryptaurRecovery) onlyOwner public {\r\n        cryptaurRecovery = _cryptaurRecovery;\r\n    }\r\n\r\n    function setCryptaurToken(address _cryptaurToken) onlyOwner public {\r\n        cryptaurToken = ERC20Base(_cryptaurToken);\r\n    }\r\n\r\n    function setCryptaurRewards(address _cryptaurRewards) onlyOwner public {\r\n        cryptaurRewards = _cryptaurRewards;\r\n    }\r\n\r\n    function setCryptaurReserveFund(address _cryptaurReserveFund) onlyOwner public {\r\n        cryptaurReserveFund = _cryptaurReserveFund;\r\n    }\r\n    \r\n    function changeAddress(address _old, address _new) public {\r\n        require(msg.sender == cryptaurRecovery);\r\n        applyChangeWalletAddress(_old, _new);\r\n        balances[_new] = add(balances[_new], balances[_old]);\r\n        balances[_old] = 0;\r\n        AddressChanged(_old, _new);\r\n    }\r\n\r\n    function linkToMasterWallet(address _linkedWallet) public {\r\n        linkToMasterWalletInternal(msg.sender, _linkedWallet);\r\n    }\r\n\r\n    function unLinkFromMasterWallet(address _linkedWallet) public {\r\n        unLinkFromMasterWalletInternal(msg.sender, _linkedWallet);\r\n    }\r\n\r\n    function linkToMasterWallet(address _masterWallet, address _linkedWallet) onlyOwnerOrBackend public {\r\n        linkToMasterWalletInternal(_masterWallet, _linkedWallet);\r\n    }\r\n\r\n    function unLinkFromMasterWallet(address _masterWallet, address _linkedWallet) onlyOwnerOrBackend public {\r\n        unLinkFromMasterWalletInternal(_masterWallet, _linkedWallet);\r\n    }\r\n\r\n    function setMaxLinkedWalletCount(uint8 _newMaxCount) public onlyOwnerOrBackend {\r\n        maxLinkedWalletCount = _newMaxCount;\r\n    }\r\n    \r\n    function freeze(address _who, bool _freeze) onlyOwner public {\r\n        address masterWallet = getMasterWallet(_who);\r\n        if (masterWallet == address(0))\r\n            masterWallet = _who;\r\n        freezed[masterWallet] = _freeze;\r\n        Freeze(masterWallet, _freeze);\r\n    }\r\n\r\n    function freeze(bool _freeze) public onlyOwnerOrBackend {\r\n        freezedAll = _freeze;\r\n    }\r\n    \r\n    function deposit(address _who, uint _amount, bytes32 _txHash) notFreezed onlyBackend public {\r\n        address masterWallet = getOrAddMasterWallet(_who);\r\n        require(!freezed[masterWallet]);\r\n        balances[masterWallet] = add(balances[masterWallet], _amount);\r\n        Deposit(masterWallet, _amount, _txHash);\r\n    }\r\n    \r\n    function withdraw(uint _amount) public notFreezed {\r\n        address masterWallet = getMasterWallet(msg.sender);   \r\n        require(balances[masterWallet] >= _amount);\r\n        require(!freezed[masterWallet]);\r\n        balances[masterWallet] = sub(balances[masterWallet], _amount);\r\n        cryptaurToken.transfer(masterWallet, _amount);\r\n        Withdraw(masterWallet, _amount);\r\n    }\r\n\r\n    function balanceOf2(address _who, address _dapp) constant public returns (uint) { \r\n        return balanceOf2Internal(getMasterWallet(_who), _dapp);\r\n    }\r\n    \r\n    function balanceOf2Internal(address _who, address _dapp) constant internal returns (uint) {\r\n        uint avail;\r\n        if (!freezed[_who]) {\r\n            if (unlimitedMode[_who][_dapp] == UnlimitedMode.UNLIMITED) {\r\n                avail = balances[_who];\r\n            } \r\n            else {\r\n                avail = available[_who][_dapp];\r\n                if (avail > balances[_who])\r\n                    avail = balances[_who];\r\n            }\r\n        }\r\n        return avail;\r\n    }\r\n    /**\r\n     * @dev Function pay wrapper auto share balance.\r\n     * When dapp pay to the client, increase its balance at first. Then share \"_amount\"\r\n     * of client balance to dapp for the further purchases.\r\n     * \r\n     * Only dapp wallet should use this function.\r\n     */\r\n    function pay2(address _seller, uint _amount, address _opinionLeader) public notFreezed {\r\n        address dapp = getOrAddMasterWallet(msg.sender);\r\n        address seller = getOrAddMasterWallet(_seller);\r\n        require(!freezed[dapp] && !freezed[seller]);\r\n        payInternal(dapp, seller, _amount, _opinionLeader);\r\n        available[seller][dapp] = add(available[seller][dapp], _amount);\r\n    }\r\n\r\n    function pay(address _seller, uint _amount, address _opinionLeader) public notFreezed {\r\n        address buyer = getOrAddMasterWallet(msg.sender);\r\n        address seller = getOrAddMasterWallet(_seller);\r\n        require(!freezed[buyer] && !freezed[seller]);\r\n        payInternal(buyer, seller, _amount, _opinionLeader);\r\n    }\r\n    \r\n    /**\r\n     * @dev Common internal pay function.\r\n     * OpinionLeader is optional, can be zero.\r\n     */\r\n    function payInternal(address _buyer, address _seller, uint _amount, address _opinionLeader) internal {    \r\n        require(balances[_buyer] >= _amount);\r\n        uint fee;\r\n        if (cryptaurRewards != 0 && cryptaurReserveFund != 0) {\r\n            fee = CryptaurRewards(cryptaurRewards).payment(_buyer, _seller, _amount, _opinionLeader);\r\n        }\r\n        balances[_buyer] = sub(balances[_buyer], _amount);\r\n        balances[_seller] = add(balances[_seller], _amount - fee);\r\n        if (fee != 0) {\r\n            balances[cryptaurReserveFund] = add(balances[cryptaurReserveFund], fee);\r\n            CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);\r\n        }\r\n        Payment(_buyer, _seller, _amount, _opinionLeader, false);\r\n    }\r\n    \r\n    function payDAPP(address _buyer, uint _amount, address _opinionLeader) public notFreezed {\r\n        address buyerMasterWallet = getOrAddMasterWallet(_buyer);\r\n        require(balanceOf2Internal(buyerMasterWallet, msg.sender) >= _amount);\r\n        require(!freezed[buyerMasterWallet]);\r\n        uint fee;\r\n        if (cryptaurRewards != 0 && cryptaurReserveFund != 0) {\r\n            fee = CryptaurRewards(cryptaurRewards).payment(buyerMasterWallet, msg.sender, _amount, _opinionLeader);\r\n        }\r\n        balances[buyerMasterWallet] = sub(balances[buyerMasterWallet], _amount);\r\n        balances[msg.sender] = add(balances[msg.sender], _amount - fee);\r\n\r\n        if (unlimitedMode[buyerMasterWallet][msg.sender] == UnlimitedMode.LIMITED)\r\n            available[buyerMasterWallet][msg.sender] -= _amount;\r\n        if (fee != 0) {\r\n            balances[cryptaurReserveFund] += fee;\r\n            CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);\r\n        }\r\n        Payment(buyerMasterWallet, msg.sender, _amount, _opinionLeader, true);\r\n    }\r\n\r\n    function shareBalance(address _dapp, uint _amount) public notFreezed {\r\n        address masterWallet = getMasterWallet(msg.sender);\r\n        require(masterWallet != address(0));\r\n        require(!freezed[masterWallet]);\r\n        available[masterWallet][_dapp] = _amount;\r\n        Share(masterWallet, _dapp, _amount);\r\n    }\r\n    \r\n    function transferFromFund(address _to, uint _amount) public {\r\n        require(msg.sender == owner || msg.sender == cryptaurRewards || msg.sender == backend);\r\n        require(cryptaurReserveFund != address(0));\r\n        require(balances[cryptaurReserveFund] >= _amount);\r\n        address masterWallet = getOrAddMasterWallet(_to);\r\n        balances[masterWallet] = add(balances[masterWallet], _amount);\r\n        balances[cryptaurReserveFund] = sub(balances[cryptaurReserveFund], _amount);\r\n        CryputarReserveFund(cryptaurReserveFund).withdrawNotification(_amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"backend\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxLinkedWalletCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMaxCount\",\"type\":\"uint8\"}],\"name\":\"setMaxLinkedWalletCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_opinionLeader\",\"type\":\"address\"}],\"name\":\"pay2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_masterWallet\",\"type\":\"address\"},{\"name\":\"_linkedWallet\",\"type\":\"address\"}],\"name\":\"linkToMasterWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"transferToToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"candidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unlimitedMode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cryptaurRewards\",\"type\":\"address\"}],\"name\":\"setCryptaurRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cryptaurRecovery\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unlimited\",\"type\":\"bool\"},{\"name\":\"_dapp\",\"type\":\"address\"}],\"name\":\"setUnlimitedMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cryptaurReserveFund\",\"type\":\"address\"}],\"name\":\"setCryptaurReserveFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_dapp\",\"type\":\"address\"}],\"name\":\"balanceOf2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFromFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cryptaurRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cryptaurRecovery\",\"type\":\"address\"}],\"name\":\"setCryptaurRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dapp\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"shareBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_opinionLeader\",\"type\":\"address\"}],\"name\":\"payDAPP\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"available\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_linkedWallet\",\"type\":\"address\"}],\"name\":\"unLinkFromMasterWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getLinkedWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_backend\",\"type\":\"address\"}],\"name\":\"setBackend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_linkedWallet\",\"type\":\"address\"}],\"name\":\"linkToMasterWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cryptaurToken\",\"type\":\"address\"}],\"name\":\"setCryptaurToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_masterWallet\",\"type\":\"address\"},{\"name\":\"_linkedWallet\",\"type\":\"address\"}],\"name\":\"unLinkFromMasterWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_old\",\"type\":\"address\"},{\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"changeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_opinionLeader\",\"type\":\"address\"}],\"name\":\"pay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cryptaurReserveFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_opinionLeader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_dapp\",\"type\":\"bool\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_dapp\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Share\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_unlimited\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"_dapp\",\"type\":\"address\"}],\"name\":\"SetUnlimited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_master\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_slave\",\"type\":\"address\"}],\"name\":\"WalletLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_master\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_slave\",\"type\":\"address\"}],\"name\":\"WalletUnlinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"AddressChanged\",\"type\":\"event\"}]","ContractName":"CryptaurDepository","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e35a49341e5b5c6a56329baae3ceb49d499ffaec93643c9a9b83ff84e9552656"}]}