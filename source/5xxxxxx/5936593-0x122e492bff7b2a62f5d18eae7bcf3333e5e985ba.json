{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n    public;\r\n}\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n    /**\r\n     * @dev Magic value to be returned upon successful reception of an NFT\r\n     *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n     *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n     */\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n     *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n     *  than the magic value MUST result in the transaction being reverted.\r\n     *  Note: the contract address is always the message sender.\r\n     * @param _from The sending address\r\n     * @param _tokenId The NFT identifier which is being transfered\r\n     * @param _data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath128 {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath64 {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath32 {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath16 {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint16 a, uint16 b) internal pure returns (uint16 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint16 a, uint16 b) internal pure returns (uint16 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath8 {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     *  as the code is not actually created until after the constructor finishes.\r\n     * @param addr address to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n *\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n *\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes sig) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        //Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract MintibleUtility is Ownable {\r\n    using SafeMath     for uint256;\r\n    using SafeMath128  for uint128;\r\n    using SafeMath64   for uint64;\r\n    using SafeMath32   for uint32;\r\n    using SafeMath16   for uint16;\r\n    using SafeMath8    for uint8;\r\n    using AddressUtils for address;\r\n    using ECRecovery   for bytes32;\r\n\r\n    uint256 private nonce;\r\n\r\n    bool public paused;\r\n\r\n    modifier notPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * @dev Uses binary search to find the index of the off given\r\n     */\r\n    function getIndexFromOdd(uint32 _odd, uint32[] _odds) internal pure returns (uint) {\r\n        uint256 low = 0;\r\n        uint256 high = _odds.length.sub(1);\r\n\r\n        while (low < high) {\r\n            uint256 mid = (low.add(high)) / 2;\r\n            if (_odd >= _odds[mid]) {\r\n                low = mid.add(1);\r\n            } else {\r\n                high = mid;\r\n            }\r\n        }\r\n\r\n        return low;\r\n    }\r\n\r\n    /*\r\n     * Using the `nonce` and a range, it generates a random value using `keccak256` and random distribution\r\n     */\r\n    function rand(uint32 min, uint32 max) internal returns (uint32) {\r\n        nonce++;\r\n        return uint32(keccak256(abi.encodePacked(nonce, uint(blockhash(block.number.sub(1)))))) % (min.add(max)).sub(min);\r\n    }\r\n\r\n\r\n    /*\r\n     *  Sub array utility functions\r\n     */\r\n\r\n    function getUintSubArray(uint256[] _arr, uint256 _start, uint256 _end) internal pure returns (uint256[]) {\r\n        uint256[] memory ret = new uint256[](_end.sub(_start));\r\n        for (uint256 i = _start; i < _end; i++) {\r\n            ret[i - _start] = _arr[i];\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    function getUint32SubArray(uint256[] _arr, uint256 _start, uint256 _end) internal pure returns (uint32[]) {\r\n        uint32[] memory ret = new uint32[](_end.sub(_start));\r\n        for (uint256 i = _start; i < _end; i++) {\r\n            ret[i - _start] = uint32(_arr[i]);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    function getUint64SubArray(uint256[] _arr, uint256 _start, uint256 _end) internal pure returns (uint64[]) {\r\n        uint64[] memory ret = new uint64[](_end.sub(_start));\r\n        for (uint256 i = _start; i < _end; i++) {\r\n            ret[i - _start] = uint64(_arr[i]);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n/****************************************\r\n *                                      *\r\n *        ERC721 IMPLEMENTATION         *\r\n *                                      *\r\n ****************************************/\r\n\r\ncontract MintibleOwnership is ERC721, MintibleUtility {\r\n\r\n    struct AccountItem {\r\n        uint64  categoryId;\r\n        uint128 latestActionTime;\r\n        uint64  lastModifiedNonce;\r\n        address owner;\r\n    }\r\n\r\n    struct ShopItem {\r\n        uint128  cooldown;\r\n        uint128  price;\r\n        uint64   supply;\r\n        uint16   numberOfOutputs;\r\n        uint8    isDestroyable;\r\n        uint32[] odds;\r\n        uint64[] categoryIds;\r\n    }\r\n\r\n    // Marketplace handling\r\n    mapping(address => uint) public marketplaceToValidBlockNumber;\r\n\r\n    // id specific mappings\r\n    uint256 public id;\r\n    mapping(uint256 => AccountItem) public idToAccountItem;\r\n\r\n    // User address specific mappings\r\n    mapping(address => uint256) public numberOfItemsOwned;\r\n    mapping(address => uint)    public balances;\r\n\r\n    // Category Id creator\r\n    uint64 public categoryId;\r\n    mapping(uint64 => ShopItem) public categoryIdToItem;\r\n    mapping(uint64 => address)  public categoryIdCreator;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) internal tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\r\n\r\n    /**\r\n     * @dev Guarantees msg.sender is owner of the given token\r\n     * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n     */\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n     * @param _tokenId uint256 ID of the token to validate\r\n     */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        require(isApprovedOrOwner(msg.sender, _tokenId));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param _owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return numberOfItemsOwned[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param _tokenId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = idToAccountItem[_tokenId].owner;\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param _tokenId uint256 ID of the token to query the existence of\r\n     * @return whether the token exists\r\n     */\r\n    function exists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = idToAccountItem[_tokenId].owner;\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * @dev The zero address indicates there is no approved address.\r\n     * @dev There can only be one approved address per token at a given time.\r\n     * @dev Can only be called by the token owner or an approved operator.\r\n     * @param _to address to be approved for the given token ID\r\n     * @param _tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n            tokenApprovals[_tokenId] = _to;\r\n            emit Approval(owner, _to, _tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * @param _tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param _to operator address to set the approval\r\n     * @param _approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address _to, bool _approved) public {\r\n        require(_to != msg.sender);\r\n        operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param _owner owner address which you want to query the approval of\r\n     * @param _operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * @dev Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) notPaused {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        idToAccountItem[_tokenId].lastModifiedNonce = idToAccountItem[_tokenId].lastModifiedNonce.add(1);\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n     *  which is called upon a safe transfer, and return the magic value\r\n     *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n     *  the transfer is reverted.\r\n     * @dev Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n    public\r\n    canTransfer(_tokenId)\r\n    notPaused\r\n    {\r\n        // solium-disable-next-line arg-overflow\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n     *  which is called upon a safe transfer, and return the magic value\r\n     *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n     *  the transfer is reverted.\r\n     * @dev Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n    public\r\n    canTransfer(_tokenId)\r\n    notPaused\r\n    {\r\n        transferFrom(_from, _to, _tokenId);\r\n        // solium-disable-next-line arg-overflow\r\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param _spender address of the spender to query\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *  is an operator of the owner, or is the owner of the token\r\n     * NB: We allow the this contract in all cases, since any action on that contract requires a user signature\r\n     */\r\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(_tokenId);\r\n        bool isApproved = block.number > marketplaceToValidBlockNumber[_spender] && marketplaceToValidBlockNumber[_spender] > 0;\r\n        return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender) || isApproved;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * @dev Reverts if the given token ID already exists\r\n     * @param _to The address that will own the minted token\r\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n     */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * @dev Reverts if the token does not exist\r\n     * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n     */\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        clearApproval(_owner, _tokenId);\r\n        removeTokenFrom(_owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to clear current approval of a given token ID\r\n     * @dev Reverts if the given address is not indeed the owner of the token\r\n     * @param _owner owner of the token\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n            emit Approval(_owner, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to add a token ID to the list of a given address\r\n     * @param _to address representing the new owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require(idToAccountItem[_tokenId].owner == address(0));\r\n        idToAccountItem[_tokenId].owner = _to;\r\n        numberOfItemsOwned[_to] = numberOfItemsOwned[_to].add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to remove a token ID from the list of a given address\r\n     * @param _from address representing the previous owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _from);\r\n        numberOfItemsOwned[_from] = numberOfItemsOwned[_from].sub(1);\r\n        idToAccountItem[_tokenId].owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * @dev The call is not executed if the target address is not a contract\r\n     * @param _from address representing the previous owner of the given token ID\r\n     * @param _to target address that will receive the tokens\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n    internal\r\n    returns (bool)\r\n    {\r\n        if (!_to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\r\n        return (retval == ERC721_RECEIVED);\r\n    }\r\n}\r\n\r\ncontract Mintible is MintibleOwnership {\r\n\r\n    event Create(uint256[] flattenedMetadata, uint128[] prices, uint64[] supplies, uint64 firstCategoryId, uint128[] localShopItemIds);\r\n    event Buy(uint64 categoryId, uint256[] itemIds, address buyerAddress, uint256 totalPaid, uint256 fee);\r\n    event Withdraw(address user, uint256 amount);\r\n    event ActionResult(uint256 id, uint256[] newIds, uint64[] newCategoryIds, uint256 lastActionTime);\r\n\r\n    /*\r\n     * @dev Sets `id` and `categoryId` to 1, since we want 0 as the invalid value\r\n     */\r\n    constructor(address _marketplace) public {\r\n        marketplaceToValidBlockNumber[_marketplace] = block.number;\r\n        categoryId++;\r\n        id++;\r\n    }\r\n\r\n    /*\r\n     * @dev Sets the contract `pause` boolean\r\n     */\r\n    function setPaused(bool _isPaused) public onlyOwner {\r\n        paused = _isPaused;\r\n    }\r\n\r\n    /*\r\n     * @dev Sets `_marketplace` to valid at block number `_blockNumber`\r\n     */\r\n    function setMarketplace(address _marketplace, uint _blockNumber) public onlyOwner {\r\n        marketplaceToValidBlockNumber[_marketplace] = _blockNumber;\r\n    }\r\n\r\n    /*\r\n     * @dev Creates a tree-like structure of categoryIds that are linked through their actions\r\n     * Also defines prices and supplies for those put for sale directly\r\n     */\r\n    function create(uint256[] _creationData, uint128[] _prices, uint64[] _supplies, uint128[] _localShopItemIds) external notPaused {\r\n\r\n        // Validate Supply and Prices\r\n        require(_prices.length > 0 && _prices.length == _supplies.length);\r\n\r\n        // Index in data array\r\n        uint64 indexOffset = categoryId;\r\n\r\n        uint256 j = 0;\r\n        for (uint64 i = indexOffset; i < indexOffset.add(uint64(_prices.length)); i++) {\r\n\r\n            _create(i, _prices[i.sub(indexOffset)], _supplies[i.sub(indexOffset)]);\r\n\r\n            if (_creationData[j] > 0) {\r\n                _handleData(_creationData, i, j, indexOffset, _prices.length);\r\n                j = j.add(4).add(_creationData[j].mul(2));\r\n            } else {\r\n                j = j.add(1);\r\n            }\r\n        }\r\n\r\n        emit Create(_creationData, _prices, _supplies, indexOffset, _localShopItemIds);\r\n    }\r\n\r\n    /*\r\n     * @dev Creates a new item and sets price and supply if necessary\r\n     */\r\n    function _create(uint64 _categoryId, uint128 _price, uint64 _supply) private {\r\n\r\n        categoryIdCreator[_categoryId] = msg.sender;\r\n\r\n        if (_supply != 0) {\r\n            categoryIdToItem[_categoryId].supply = _supply;\r\n            categoryIdToItem[_categoryId].price = _price;\r\n        }\r\n\r\n        categoryId++;\r\n    }\r\n\r\n    /*\r\n     * @dev Creates the action data and validates it\r\n     */\r\n    function _handleData(uint256[] _creationData, uint64 _i, uint256 _j, uint64 _indexOffset, uint256 _length) private {\r\n        uint32[] memory odds        = getUint32SubArray(_creationData, _j.add(1), _j.add(1).add(_creationData[_j]));\r\n        uint64[] memory categoryIds = getUint64SubArray(_creationData, _j.add(1).add(_creationData[_j]), _j.add(1).add(_creationData[_j].mul(2)));\r\n\r\n        _validateData(odds, categoryIds, _length);\r\n\r\n        for (uint256 k = 0; k < categoryIds.length; k++) {\r\n            categoryIds[k] = categoryIds[k].add(_indexOffset);\r\n        }\r\n\r\n        categoryIdToItem[_i].cooldown        = uint128(_creationData[_j.add(3).add(_creationData[_j].mul(2))]);\r\n        categoryIdToItem[_i].numberOfOutputs = uint16(_creationData[_j.add(2).add(_creationData[_j].mul(2))]);\r\n        categoryIdToItem[_i].isDestroyable   = uint8(_creationData[_j.add(1).add(_creationData[_j].mul(2))]);\r\n        categoryIdToItem[_i].odds            = odds;\r\n        categoryIdToItem[_i].categoryIds     = categoryIds;\r\n    }\r\n\r\n    /*\r\n     * @dev Validates that the action data is valid\r\n     */\r\n    function _validateData(uint32[] _odds, uint64[] _categoryIds, uint256 _length) private pure {\r\n\r\n        // Validate length\r\n        require(_odds.length == _categoryIds.length);\r\n\r\n        // Validate id in range\r\n        for (uint256 i = 0; i < _categoryIds.length; i++) {\r\n            require(_categoryIds[i] <= _length);\r\n        }\r\n\r\n        // Validate Odds\r\n        require(_odds[0] > 0);\r\n        for (uint256 j = 0; j < _odds.length.sub(1); j++) {\r\n            require(_odds[j] < _odds[j + 1]);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev This function can be called by anyone to buy `_amount` of `_categoryId` if there is enough supply left\r\n     */\r\n    function buy(uint64 _categoryId, uint64 _amount) external payable notPaused {\r\n        require(_categoryId > 0 && _categoryId < categoryId);\r\n        require(_amount > 0);\r\n\r\n        require(categoryIdToItem[_categoryId].supply >= _amount);\r\n        require(categoryIdToItem[_categoryId].price.mul(uint128(_amount)) == msg.value);\r\n\r\n        categoryIdToItem[_categoryId].supply = categoryIdToItem[_categoryId].supply.sub(_amount);\r\n\r\n        uint256[] memory itemIds = new uint[](_amount);\r\n        for (uint64 i = 0; i < _amount; i++) {\r\n            idToAccountItem[id].categoryId = _categoryId;\r\n            _mint(msg.sender, id);\r\n\r\n            itemIds[i] = id;\r\n            id++;\r\n        }\r\n\r\n        uint256 totalPaid = msg.value;\r\n\r\n        // 3.5% fee\r\n        uint256 fee = totalPaid.mul(35 finney) / 1 ether;\r\n\r\n        uint256 netPaid = totalPaid.sub(fee);\r\n\r\n        balances[categoryIdCreator[_categoryId]] = balances[categoryIdCreator[_categoryId]].add(netPaid);\r\n        balances[owner] = balances[owner].add(fee);\r\n\r\n        emit Buy(_categoryId, itemIds, msg.sender, totalPaid, fee);\r\n    }\r\n\r\n    /*\r\n     * @dev This function is called on an item and does what its shopItem is defined to do\r\n     *      It can generate new items and it can also destroy itself in the process\r\n     *      In order to be called, the `cooldown` must be satisfied. All items start with no cooldown\r\n     *\r\n     */\r\n    function action(uint256 _id) external notPaused {\r\n        AccountItem storage accountItem = idToAccountItem[_id];\r\n\r\n        require(accountItem.owner == msg.sender);\r\n\r\n        ShopItem storage shopItem = categoryIdToItem[accountItem.categoryId];\r\n\r\n        // This is simply verifying that calling an action on the item makes sense\r\n        require(shopItem.odds.length > 0);\r\n\r\n        // Verify that the cooldown is satisfied\r\n        require(accountItem.latestActionTime == 0 || now.sub(accountItem.latestActionTime) > shopItem.cooldown);\r\n        // Refresh cooldown\r\n        accountItem.latestActionTime = uint128(now);\r\n        accountItem.lastModifiedNonce = accountItem.lastModifiedNonce.add(1);\r\n\r\n        uint32[] memory odds = shopItem.odds;\r\n        uint64[] memory categoryIds = shopItem.categoryIds;\r\n\r\n        uint256[] memory newIds = new uint256[](shopItem.numberOfOutputs);\r\n        uint64[] memory newCategoryIds = new uint64[](shopItem.numberOfOutputs);\r\n\r\n        // shopItem[2*len+1] is the number of items returned\r\n        for (uint256 i = 0; i < shopItem.numberOfOutputs; i++) {\r\n            uint32 randomValue = rand(0, odds[odds.length.sub(1)]);\r\n\r\n            uint256 index = getIndexFromOdd(randomValue, odds);\r\n\r\n            idToAccountItem[id].categoryId = categoryIds[index];\r\n            _mint(msg.sender, id);\r\n\r\n            newIds[i] = id;\r\n            newCategoryIds[i] = categoryIds[index];\r\n\r\n            id++;\r\n        }\r\n\r\n        // Destroy item if necessary\r\n        if (shopItem.isDestroyable == 1) {\r\n            // Destroy _id\r\n            _burn(msg.sender, _id);\r\n        }\r\n\r\n        emit ActionResult(_id, newIds, newCategoryIds, accountItem.latestActionTime);\r\n    }\r\n\r\n    /*\r\n     * @dev Function to allow `msg.sender` to withdraw `_amount` of money from his balance\r\n     * Balance is build from fees on buy and on trades on the marketplace\r\n     */\r\n    function withdraw(uint256 _amount) public {\r\n        require(balances[msg.sender] >= _amount);\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        msg.sender.transfer(_amount);\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    /*\r\n     * Below is the implementation of the Mintible Interface\r\n     */\r\n\r\n\r\n    /*\r\n     * @dev pays `msg.value` to the creator of categoryId related to `_id`\r\n     */\r\n    function payFee(uint256 _id) public payable {\r\n        address creator = categoryIdCreator[idToAccountItem[_id].categoryId];\r\n        balances[creator] = balances[creator].add(msg.value);\r\n    }\r\n\r\n    /*\r\n     * @dev This is to keep track of the state of the item. If anything is executed on the item, this nonce\r\n     * ensures that it represents the latest state\r\n     */\r\n    function getLastModifiedNonce(uint256 _id) public view returns (uint) {\r\n        return idToAccountItem[_id].lastModifiedNonce;\r\n    }\r\n\r\n    /**\r\n     * Functionality Accessors\r\n     */\r\n    function getCategoryId() public view returns (uint) {\r\n        return categoryId;\r\n    }\r\n\r\n    function getNumberOfOdds(uint64 _categoryId) public view returns (uint) {\r\n        return categoryIdToItem[_categoryId].odds.length;\r\n    }\r\n\r\n    function getOddValue(uint64 _categoryId, uint256 _i) public view returns (uint) {\r\n        return categoryIdToItem[_categoryId].odds[_i];\r\n    }\r\n\r\n    function getNumberOfCategoryIds(uint64 _categoryId) public view returns (uint) {\r\n        return categoryIdToItem[_categoryId].categoryIds.length;\r\n    }\r\n\r\n    function getCategoryIdsValue(uint64 _categoryId, uint256 _i) public view returns (uint) {\r\n        return categoryIdToItem[_categoryId].categoryIds[_i];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint64\"},{\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getCategoryIdsValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getLastModifiedNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint64\"}],\"name\":\"getNumberOfCategoryIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint64\"}],\"name\":\"getNumberOfOdds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"categoryIdCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCategoryId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketplace\",\"type\":\"address\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"setMarketplace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"categoryIdToItem\",\"outputs\":[{\"name\":\"cooldown\",\"type\":\"uint128\"},{\"name\":\"price\",\"type\":\"uint128\"},{\"name\":\"supply\",\"type\":\"uint64\"},{\"name\":\"numberOfOutputs\",\"type\":\"uint16\"},{\"name\":\"isDestroyable\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketplaceToValidBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"numberOfItemsOwned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"action\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"categoryId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAccountItem\",\"outputs\":[{\"name\":\"categoryId\",\"type\":\"uint64\"},{\"name\":\"latestActionTime\",\"type\":\"uint128\"},{\"name\":\"lastModifiedNonce\",\"type\":\"uint64\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint64\"},{\"name\":\"_amount\",\"type\":\"uint64\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"payFee\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creationData\",\"type\":\"uint256[]\"},{\"name\":\"_prices\",\"type\":\"uint128[]\"},{\"name\":\"_supplies\",\"type\":\"uint64[]\"},{\"name\":\"_localShopItemIds\",\"type\":\"uint128[]\"}],\"name\":\"create\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_categoryId\",\"type\":\"uint64\"},{\"name\":\"_i\",\"type\":\"uint256\"}],\"name\":\"getOddValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_marketplace\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"flattenedMetadata\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"prices\",\"type\":\"uint128[]\"},{\"indexed\":false,\"name\":\"supplies\",\"type\":\"uint64[]\"},{\"indexed\":false,\"name\":\"firstCategoryId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"localShopItemIds\",\"type\":\"uint128[]\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"categoryId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"newCategoryIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"name\":\"lastActionTime\",\"type\":\"uint256\"}],\"name\":\"ActionResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"Mintible","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000af200f2daebb04e8651c29a3adcf1a6a10fa074f","Library":"","SwarmSource":"bzzr://bc45395df37e128a8fd67822d06ff14d7f625f4f9f3c574e9642dfb377ff1479"}]}