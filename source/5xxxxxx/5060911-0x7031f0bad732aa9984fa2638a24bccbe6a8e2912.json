{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n// File: contracts/TulipsSaleInterface.sol\r\n\r\n/** @title Crypto Tulips Initial Sale Interface\r\n* @dev This interface sets the standard for initial sale\r\n* contract. All future sale contracts should follow this.\r\n*/\r\ninterface TulipsSaleInterface {\r\n    function putOnInitialSale(uint256 tulipId) external;\r\n    function createAuction(\r\n        uint256 _tulipId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _transferFrom\r\n    )external;\r\n}\r\n\r\n// File: contracts/ERC721.sol\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n}\r\n\r\n// File: contracts/ERC721MetaData.sol\r\n\r\n/// @title The external contract that is responsible for generatingmetadata for the tulips,\r\n/// Taken from crypto kitties source. May change with our own implementation\r\ncontract ERC721Metadata {\r\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\r\n    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\r\n        if (_tokenId == 1) {\r\n            buffer[0] = \"Hello World! :D\";\r\n            count = 15;\r\n        } else if (_tokenId == 2) {\r\n            buffer[0] = \"I would definitely choose a medi\";\r\n            buffer[1] = \"um length string.\";\r\n            count = 49;\r\n        } else if (_tokenId == 3) {\r\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\r\n            buffer[2] = \" tristique vestibulum id, libero\";\r\n            buffer[3] = \" suscipit varius sapien aliquam.\";\r\n            count = 128;\r\n        }\r\n    }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/TulipsRoles.sol\r\n\r\n/*\r\n* @title Crypto Tulips SaleAuction\r\n* @dev .\r\n*/\r\ncontract TulipsRoles is Pausable {\r\n\r\n    modifier onlyFinancial() {\r\n        require(msg.sender == address(financialAccount));\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperations() {\r\n        require(msg.sender == address(operationsAccount));\r\n        _;\r\n    }\r\n\r\n    function TulipsRoles() Ownable() public {\r\n        financialAccount = msg.sender;\r\n        operationsAccount = msg.sender;\r\n    }\r\n\r\n    address public financialAccount;\r\n    address public operationsAccount;\r\n\r\n    function transferFinancial(address newFinancial) public onlyOwner {\r\n        require(newFinancial != address(0));\r\n        financialAccount = newFinancial;\r\n    }\r\n\r\n    function transferOperations(address newOperations) public onlyOwner {\r\n        require(newOperations != address(0));\r\n        operationsAccount = newOperations;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/TulipsStorage.sol\r\n\r\ncontract TulipsStorage is TulipsRoles {\r\n\r\n    //// DATA\r\n\r\n    /*\r\n    * Main tulip struct.\r\n    * Visual Info is the dna used to create the tulip image\r\n    * Visual Hash hash of the image file to confirm validity if needed.\r\n    */\r\n    struct Tulip {\r\n        uint256 visualInfo;\r\n        bytes32 visualHash;\r\n    }\r\n\r\n    //// STORAGE\r\n    /*\r\n    * @dev Array of all tulips created indexed with tulipID.\r\n    */\r\n    Tulip[] public tulips;\r\n\r\n    /*\r\n    * @dev Maps tulipId's to owner addreses\r\n    */\r\n    mapping (uint256 => address) public tulipIdToOwner;\r\n\r\n    /*\r\n    * @dev Maps owner adress to number of tulips owned.\r\n    * Bookkeeping for compliance with ERC20 and ERC721. Doesn't mean much in terms of\r\n    * value of individual unfungable assets.\r\n    */\r\n    mapping (address => uint256) tulipOwnershipCount;\r\n\r\n    /// @dev Maps tulipId to approved reciever of a pending token transfer.\r\n    mapping (uint256 => address) public tulipIdToApprovedTranserAddress;\r\n}\r\n\r\n// File: contracts/TulipsTokenInterface.sol\r\n\r\n/*\r\n* @title Crypto Tulips Token Interface\r\n* @dev This contract provides interface to ERC721 support.\r\n*/\r\ncontract TulipsTokenInterface is TulipsStorage, ERC721 {\r\n\r\n    //// TOKEN SPECS & META DATA\r\n\r\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant name = \"CryptoTulips\";\r\n    string public constant symbol = \"CT\";\r\n\r\n    /*\r\n    * @dev This external contract will return Tulip metadata. We are making this changable in case\r\n    * we need to update our current uri scheme later on.\r\n    */\r\n    ERC721Metadata public erc721Metadata;\r\n\r\n    /// @dev Set the address of the external contract that generates the metadata.\r\n    function setMetadataAddress(address _contractAddress) public onlyOperations {\r\n        erc721Metadata = ERC721Metadata(_contractAddress);\r\n    }\r\n\r\n    //// EVENTS\r\n\r\n    /*\r\n    * @dev Transfer event as defined in ERC721.\r\n    */\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    /*\r\n    * @dev Approval event as defined in ERC721.\r\n    */\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    //// TRANSFER DATA\r\n\r\n    /*\r\n    * @dev Maps tulipId to approved transfer address\r\n    */\r\n    mapping (uint256 => address) public tulipIdToApproved;\r\n\r\n\r\n    //// PUBLIC FACING FUNCTIONS\r\n    /*\r\n    * @notice Returns total number of Tulips created so far.\r\n    */\r\n    function totalSupply() public view returns (uint) {\r\n        return tulips.length - 1;\r\n    }\r\n\r\n    /*\r\n    * @notice Returns the number of Tulips owned by given address.\r\n    * @param _owner The Tulip owner.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return tulipOwnershipCount[_owner];\r\n    }\r\n\r\n    /*\r\n    * @notice Returns the owner of the given Tulip\r\n    */\r\n    function ownerOf(uint256 _tulipId)\r\n        external\r\n        view\r\n        returns (address owner)\r\n    {\r\n        owner = tulipIdToOwner[_tulipId];\r\n\r\n        // If owner adress is empty this is still a fresh Tulip waiting for its first owner.\r\n        require(owner != address(0));\r\n    }\r\n\r\n    /*\r\n    * @notice Unlocks the tulip for transfer. The reciever can calltransferFrom() to\r\n    * get ownership of the tulip. This is a safer method since you can revoke the transfer\r\n    * if you mistakenly send it to an invalid address.\r\n    * @param _to The reciever address. Set to address(0) to revoke the approval.\r\n    * @param _tulipId The tulip to be transfered\r\n    */\r\n    function approve(\r\n        address _to,\r\n        uint256 _tulipId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Only an owner can grant transfer approval.\r\n        require(tulipIdToOwner[_tulipId] == msg.sender);\r\n\r\n        // Register the approval\r\n        _approve(_tulipId, _to);\r\n\r\n        // Emit approval event.\r\n        Approval(msg.sender, _to, _tulipId);\r\n    }\r\n\r\n    /*\r\n    * @notice Transfers a tulip to another address without confirmation.\r\n    * If the reciever's address is invalid tulip may be lost! Use approve() and transferFrom() instead.\r\n    * @param _to The reciever address.\r\n    * @param _tulipId The tulip to be transfered\r\n    */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tulipId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Safety checks for common mistakes.\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n\r\n        // You can only send tulips you own.\r\n        require(tulipIdToOwner[_tulipId] == msg.sender);\r\n\r\n        // Do the transfer\r\n        _transfer(msg.sender, _to, _tulipId);\r\n    }\r\n\r\n    /*\r\n    * @notice This method allows the caller to recieve a tulip if the caller is the approved address\r\n    * caller can also give another address to recieve the tulip.\r\n    * @param _from Current owner of the tulip.\r\n    * @param _to New owner of the tulip\r\n    * @param _tulipId The tulip to be transfered\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tulipId\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Safety checks for common mistakes.\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n\r\n        // Check for approval and valid ownership\r\n        require(tulipIdToApproved[_tulipId] == msg.sender);\r\n        require(tulipIdToOwner[_tulipId] == _from);\r\n\r\n        // Do the transfer\r\n        _transfer(_from, _to, _tulipId);\r\n    }\r\n\r\n    /// @notice Returns metadata for the tulip.\r\n    /// @param _tulipId The tulip to recieve information on\r\n    function tokenMetadata(uint256 _tulipId, string _preferredTransport) external view returns (string infoUrl) {\r\n        // We will set the meta data scheme in an external contract\r\n        require(erc721Metadata != address(0));\r\n\r\n        // Contracts cannot return string to each other so we do this\r\n        bytes32[4] memory buffer;\r\n        uint256 count;\r\n        (buffer, count) = erc721Metadata.getMetadata(_tulipId, _preferredTransport);\r\n\r\n        return _toString(buffer, count);\r\n    }\r\n\r\n    //// INTERNAL FUNCTIONS THAT ACTUALLY DO STUFF\r\n    // These are called by public facing functions after sanity checks\r\n\r\n    function _transfer(address _from, address _to, uint256 _tulipId) internal {\r\n        // Increase total Tulips owned by _to address\r\n        tulipOwnershipCount[_to]++;\r\n\r\n        // Decrease total Tulips owned by _from address, if _from address is not empty\r\n        if (_from != address(0)) {\r\n            tulipOwnershipCount[_from]--;\r\n        }\r\n\r\n        // Update mapping of tulipID -> ownerAddress\r\n        tulipIdToOwner[_tulipId] = _to;\r\n\r\n        // Emit the transfer event.\r\n        Transfer(_from, _to, _tulipId);\r\n    }\r\n\r\n    function _approve(uint256 _tulipId, address _approved) internal{\r\n        tulipIdToApproved[_tulipId] = _approved;\r\n        // Approve event is only sent on public facing function\r\n    }\r\n\r\n    //// UTILITY FUNCTIONS\r\n\r\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength)private view returns (string) {\r\n        var outputString = new string(_stringLength);\r\n        uint256 outputPtr;\r\n        uint256 bytesPtr;\r\n\r\n        assembly {\r\n            outputPtr := add(outputString, 32)\r\n            bytesPtr := _rawBytes\r\n        }\r\n\r\n        _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n        return outputString;\r\n    }\r\n\r\n    function _memcpy(uint dest, uint src, uint len) private view {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/TulipsCreation.sol\r\n\r\n/*\r\n* @title Crypto Tulips Creation Mechanisms & Core Contract\r\n* @dev This contract provides methods in which we create new tulips.\r\n*/\r\ncontract TulipsCreation is TulipsTokenInterface {\r\n\r\n    //// STATS & LIMITS\r\n    uint256 public constant TOTAL_TULIP_SUPPLY = 100000;\r\n    uint256 public totalTulipCount;\r\n\r\n    //// Sale contract\r\n    TulipsSaleInterface public initialSaleContract;\r\n\r\n    //// EVENTS\r\n\r\n    /*\r\n    * @dev Announces creation of a new tulip.\r\n    */\r\n    event TulipCreation(uint256 tulipId, uint256 visualInfo);\r\n\r\n    /*\r\n    * We have this in case we have to change the initial sale contract\r\n    */\r\n    function setSaleAuction(address _initialSaleContractAddress) external onlyOwner {\r\n        initialSaleContract = TulipsSaleInterface(_initialSaleContractAddress);\r\n    }\r\n\r\n    function getSaleAuctionAddress() external view returns(address){\r\n        return address(initialSaleContract);\r\n    }\r\n\r\n    //// CREATION INTERFACE\r\n    /*\r\n    * @dev This function mints a new Tulip .\r\n    * @param _visualInfo Visual information used to generate tulip image.\r\n    * @param _visualHash Keccak hash of generated image.\r\n    */\r\n    function createTulip( uint256 _visualInfo, bytes32 _visualHash )  external onlyOperations\r\n        returns (uint)\r\n    {\r\n        require(totalTulipCount<TOTAL_TULIP_SUPPLY);\r\n\r\n        Tulip memory tulip = Tulip({\r\n            visualInfo: _visualInfo,\r\n            visualHash: _visualHash\r\n        });\r\n\r\n        uint256 tulipId = tulips.push(tulip) - 1;\r\n\r\n        // New created tulip is owned by initial sale auction at first\r\n        tulipIdToOwner[tulipId] = address(initialSaleContract);\r\n        initialSaleContract.putOnInitialSale(tulipId);\r\n\r\n        totalTulipCount++;\r\n\r\n        // Let the world know about this new tulip\r\n        TulipCreation(\r\n            tulipId, _visualInfo\r\n        );\r\n\r\n        return tulipId;\r\n    }\r\n\r\n    /*\r\n    * @dev This method authorizes for transfer and puts tulip on auction on a single call.\r\n    * This could be done in two seperate calls approve() and createAuction()\r\n    * but this way we can offer a single operation version that canbe triggered from web ui.\r\n    */\r\n    function putOnAuction(\r\n        uint256 _tulipId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n\r\n        require(tulipIdToOwner[_tulipId] == msg.sender);\r\n\r\n        tulipIdToApproved[_tulipId] = address(initialSaleContract);\r\n\r\n        initialSaleContract.createAuction(\r\n            _tulipId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_tulipId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tulipId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operationsAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tulipId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"putOnAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_visualInfo\",\"type\":\"uint256\"},{\"name\":\"_visualHash\",\"type\":\"bytes32\"}],\"name\":\"createTulip\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tulipIdToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tulipId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_TULIP_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tulipIdToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSaleAuctionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"financialAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tulipIdToApprovedTranserAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFinancial\",\"type\":\"address\"}],\"name\":\"transferFinancial\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tulipId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperations\",\"type\":\"address\"}],\"name\":\"transferOperations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tulipId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tulips\",\"outputs\":[{\"name\":\"visualInfo\",\"type\":\"uint256\"},{\"name\":\"visualHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTulipCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initialSaleContractAddress\",\"type\":\"address\"}],\"name\":\"setSaleAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setMetadataAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tulipId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"visualInfo\",\"type\":\"uint256\"}],\"name\":\"TulipCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TulipsCreation","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://394519735d534986e6be3e35895138872c08761fbe6cd61ac3e740cba93beed6"}]}