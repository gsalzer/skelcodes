{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract TwoUp {\r\n    // Punter who made the most recent bet\r\n    address public punterAddress;\r\n    // Amount of that most recent bet\r\n    uint256 public puntAmount;\r\n    // Is there someone waiting with a bet down?\r\n    bool public punterWaiting;\r\n\r\n    // Note the lack of owner privileges. The house gets nothing, like true blue\r\n    // Aussie two-up. Also this feels more legal idunno\r\n\r\n    // Don't let mad dogs bet more than 10 ether and don't let time wasters send\r\n    // empty transactions.\r\n    modifier withinRange {\r\n        assert(msg.value > 0 ether && msg.value < 10 ether);\r\n        _;\r\n    }\r\n    \r\n    // Initialise/Create Contract\r\n    function TwoUp() public {\r\n        punterWaiting = false;\r\n    }\r\n    \r\n    // Main Function. All action happens by users submitting a bet to the smart\r\n    // contract. No message is required, just a bet. If you bet more than your \r\n    // opponent then you will get the change sent back to you. If you bet less\r\n    // then they will get their change sent back to them. i.e. the actual wager\r\n    // amount is min(bet_1,bet_2).\r\n    function () payable public withinRange {\r\n        if (punterWaiting){\r\n            uint256 _payout = min(msg.value,puntAmount);\r\n            if (rand(punterAddress) >= rand(msg.sender)) {\r\n                punterAddress.transfer(_payout+puntAmount);\r\n                if ((msg.value-_payout)>0)\r\n                    msg.sender.transfer(msg.value-_payout);\r\n            } else {\r\n                msg.sender.transfer(_payout+msg.value);\r\n                if ((puntAmount-_payout)>0)\r\n                    punterAddress.transfer(puntAmount-_payout);\r\n            }\r\n            punterWaiting = false;\r\n        } else {\r\n            punterWaiting = true;\r\n            punterAddress = msg.sender;\r\n            puntAmount = msg.value;\r\n        }\r\n    }\r\n    \r\n    // min(a,b) function required for tidiness\r\n    function min(uint256 _a, uint256 _b) private pure returns(uint256){\r\n        if (_b < _a) {\r\n            return _b;\r\n        } else {\r\n            return _a;\r\n        }\r\n    }\r\n    function rand(address _who) private view returns(bytes32){\r\n        return keccak256(_who,now);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"puntAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"punterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"punterWaiting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"TwoUp","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://123a479c4b1e375ff3de709cd68dd7a7829b7816cefa180e10976680d270b993"}]}