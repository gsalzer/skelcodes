{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/* ==================================================================== */\r\n/* Copyright (c) 2018 The Priate Conquest Project.  All rights reserved.\r\n/* \r\n/* https://www.pirateconquest.com One of the world's slg games of blockchain \r\n/*  \r\n/* authors rainy@livestar.com/Jonny.Fu@livestar.com\r\n/*                 \r\n/* ==================================================================== */\r\n/// This Random is inspired by https://github.com/axiomzen/eth-random\r\ncontract Random {\r\n    uint256 _seed;\r\n\r\n    function _rand() internal returns (uint256) {\r\n        _seed = uint256(keccak256(_seed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));\r\n        return _seed;\r\n    }\r\n\r\n    function _randBySeed(uint256 _outSeed) internal view returns (uint256) {\r\n        return uint256(keccak256(_outSeed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));\r\n    }\r\n\r\n    \r\n    function _randByRange(uint256 _min, uint256 _max) internal returns (uint256) {\r\n        if (_min >= _max) {\r\n            return _min;\r\n        }\r\n        return (_rand() % (_max - _min +1)) + _min;\r\n    }\r\n\r\n    function _rankByNumber(uint256 _max) internal returns (uint256) {\r\n        return _rand() % _max;\r\n    }\r\n    \r\n}\r\n\r\ninterface CaptainTokenInterface {\r\n  function CreateCaptainToken(address _owner,uint256 _price, uint32 _captainId, uint32 _color,uint32 _atk,uint32 _defense,uint32 _atk_min,uint32 _atk_max) public ;\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n  function setTokenPrice(uint256 _tokenId, uint256 _price) external;\r\n  function checkCaptain(address _owner,uint32 _captainId) external returns (bool);\r\n  function setSelled(uint256 _tokenId, bool fsell) external;\r\n}\r\n\r\ninterface CaptainGameConfigInterface {\r\n  function getCardInfo(uint32 cardId) external constant returns (uint32,uint32,uint32, uint32,uint32,uint256,uint256);\r\n  function getSellable(uint32 _captainId) external returns (bool);\r\n  function getLevelConfig(uint32 cardId, uint32 level) external view returns (uint32 atk,uint32 defense,uint32 atk_min,uint32 atk_max);\r\n}\r\n\r\ncontract CaptainPreSell is Random {\r\n  using SafeMath for SafeMath;\r\n  address devAddress;\r\n  \r\n  function CaptainPreSell() public {\r\n    devAddress = msg.sender;\r\n  }\r\n\r\n  CaptainTokenInterface public captains;\r\n  CaptainGameConfigInterface public config; \r\n  /// @dev The BuyToken event is fired whenever a token is sold.\r\n  event BuyToken(uint256 tokenId, uint256 oldPrice, address prevOwner, address winner);\r\n  \r\n  //mapping\r\n  mapping(uint32 => uint256) captainToCount;\r\n  mapping(address => uint32[]) captainUserMap; \r\n  /// @notice No tipping!\r\n  /// @dev Reject all Ether from being sent here, unless it's from one of the\r\n  ///  two auction contracts. (Hopefully, we can prevent user accidents.)\r\n  function() external payable {\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == devAddress);\r\n    _;\r\n  }\r\n\r\n  //setting configuration\r\n  function setGameConfigContract(address _address) external onlyOwner {\r\n    config = CaptainGameConfigInterface(_address);\r\n  }\r\n\r\n  //setting configuration\r\n  function setCaptainTokenContract(address _address) external onlyOwner {\r\n    captains = CaptainTokenInterface(_address);\r\n  }\r\n\r\n  function prepurchase(uint32 _captainId) external payable {\r\n    uint32 color;\r\n    uint32 atk;\r\n    uint32 defense;\r\n    uint256 price;\r\n    uint256 captainCount;\r\n    uint256 SellCount = captainToCount[_captainId];\r\n    (color,atk,,,defense,price,captainCount) = config.getCardInfo(_captainId);\r\n    require(config.getSellable(_captainId) == true);\r\n    SellCount += 1;\r\n    require(SellCount<=captainCount);\r\n    uint256 rdm = _randByRange(90,110) % 10000;\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(msg.sender != address(0));\r\n    require(!captains.checkCaptain(msg.sender,_captainId));\r\n    // Making sure sent amount is greater than or equal to the sellingPrice\r\n    require(msg.value >= price);\r\n     //get the config\r\n    uint32 atk_min;\r\n    uint32 atk_max; \r\n    (,,atk_min,atk_max) = config.getLevelConfig(_captainId,1);\r\n   \r\n    atk_min = uint32(SafeMath.div(SafeMath.mul(uint256(atk_min),rdm),100));\r\n    atk_max = uint32(SafeMath.div(SafeMath.mul(uint256(atk_max),rdm),100));\r\n   \r\n    price = SafeMath.div(SafeMath.mul(price,130),100);\r\n    captains.CreateCaptainToken(msg.sender,price,_captainId,color,atk, defense,atk_min,atk_max);\r\n  \r\n    uint256 balance = captains.balanceOf(msg.sender);\r\n    uint256 tokenId = captains.tokenOfOwnerByIndex(msg.sender,balance-1);\r\n    captains.setTokenPrice(tokenId,price);\r\n    //captains.setSelled(tokenId,true);\r\n    captainToCount[_captainId] = SellCount;\r\n\r\n    //transfer\r\n    //devAddress.transfer(msg.value);\r\n    //event \r\n    BuyToken(_captainId, price,address(this),msg.sender);\r\n  }\r\n\r\n  function getCaptainCount(uint32 _captainId) external constant returns (uint256) {\r\n    return captainToCount[_captainId];\r\n  }\r\n\r\n  //@notice withraw all by dev\r\n  function withdraw() external onlyOwner {\r\n    require(this.balance>0);\r\n    msg.sender.transfer(this.balance);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint32 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function div32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function add32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGameConfigContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCaptainTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_captainId\",\"type\":\"uint32\"}],\"name\":\"prepurchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"captains\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_captainId\",\"type\":\"uint32\"}],\"name\":\"getCaptainCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"BuyToken\",\"type\":\"event\"}]","ContractName":"CaptainPreSell","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8b4829798694c87d8fb7d05fac2835effb337bff82e638cda22bef2f8a272c2b"}]}