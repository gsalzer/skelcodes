{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/*\r\ndeveloped by cryptonomica.net, 2018\r\nlast version: 2018-02-18\r\ngithub: https://github.com/Cryptonomica/\r\n*/\r\n\r\ncontract CryptonomicaVerification {\r\n\r\n    /* ---------------------- Verification Data */\r\n\r\n    // Ethereum address is connected to OpenPGP public key data from Cryptonomica.net\r\n    // Ethereum address can be connected to one OpenPGP key only, and one time only\r\n    // If OpenPGP key expires, user have to use another Ethereum address for new OpenPGP public key\r\n    // But user can verify multiple Ethereum accounts with the same OpenPGP key\r\n\r\n    // ---- mappings to store verification data, to make it accessible for other smart contracts\r\n    // we store sting data as bytes32 (http://solidity.readthedocs.io/en/develop/types.html#fixed-size-byte-arrays)\r\n    // !!! -> up to 32 ASCII letters,\r\n    // see: https://ethereum.stackexchange.com/questions/6729/how-many-letters-can-bytes32-keep\r\n\r\n    // OpenPGP Message Format https://tools.ietf.org/html/rfc4880#section-12.2 : \"A V4 fingerprint is the 160-bit SHA-1 hash ...\"\r\n    // thus fingerprint is 20 bytes, in hexadecimal 40 symbols string representation\r\n    // fingerprints are stored as upper case strings like:\r\n    // 57A5FEE5A34D563B4B85ADF3CE369FD9E77173E5\r\n    // or as bytes20: \"0x57A5FEE5A34D563B4B85ADF3CE369FD9E77173E5\" from web3.js or Bytes20 from web3j\r\n    // see: https://crypto.stackexchange.com/questions/32087/how-to-generate-fingerprint-for-pgp-public-key\r\n    mapping(address => bytes20) public fingerprint; // ..............................................................0\r\n\r\n    // we use unverifiedFingerprintAsString to store fingerprint provided by user\r\n    mapping(address => string) public unverifiedFingerprint; // (!) Gas requirement: infinite\r\n\r\n    mapping(address => uint) public keyCertificateValidUntil; // unix time ..........................................1\r\n    mapping(address => bytes32) public firstName; // ................................................................2\r\n    mapping(address => bytes32) public lastName; // .................................................................3\r\n    mapping(address => uint) public birthDate; // unix time .........................................................4\r\n    // Nationality - from user passport or id document:\r\n    // 2-letter country codes defined in ISO 3166\r\n    // like returned by Locale.getISOCountries() in Java (upper case)\r\n    // see: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\r\n    mapping(address => bytes32) public nationality; //      .........................................................5\r\n    mapping(address => uint256) public verificationAddedOn; // unix time ............................................6\r\n    mapping(address => uint256) public revokedOn; // unix time, returns uint256: 0 if verification is not revoked ...7\r\n    // this will be longer than 32 char, and have to be properly formatted (with \"\\n\")\r\n    mapping(address => string) public signedString; //.(!) Gas requirement: infinite.................................8\r\n\r\n    // unix time online converter: https://www.epochconverter.com\r\n    // for coders: http://www.convert-unix-time.com\r\n    mapping(address => uint256) public signedStringUploadedOnUnixTime;\r\n\r\n    // this allows to search for account connected to fingerprint\r\n    // as a key we use fingerprint as bytes32, like 0x57A5FEE5A34D563B4B85ADF3CE369FD9E77173E5\r\n    mapping(bytes20 => address) public addressAttached; //\r\n\r\n    // (!) Gas requirement: infinite\r\n    string public stringToSignExample = \"I hereby confirm that the address <address lowercase> is my Ethereum address\";\r\n\r\n    /* the same data as above stored as a struct:\r\n    struct will be returned as 'List' in web3j (only one function call needed) */\r\n    mapping(address => Verification) public verification; // (!) Gas requirement: infinite\r\n    struct Verification {\r\n        // all string have to be <= 32 chars\r\n        string fingerprint; // ................................................0\r\n        uint keyCertificateValidUntil; // .....................................1\r\n        string firstName; // ..................................................2\r\n        string lastName;// ....................................................3\r\n        uint birthDate; //  ...................................................4\r\n        string nationality; //  ...............................................5\r\n        uint verificationAddedOn;// ...........................................6\r\n        uint revokedOn; // ....................................................7\r\n        string signedString; //................................................8\r\n        // uint256 signedStringUploadedOnUnixTime; //... Stack too deep\r\n    }\r\n\r\n    /*  -------------------- Administrative Data */\r\n    address public owner; // smart contract owner (super admin)\r\n    mapping(address => bool) public isManager; // list of managers\r\n\r\n    uint public priceForVerificationInWei; // see converter on https://etherconverter.online/\r\n\r\n    address public withdrawalAddress; // address to send Ether from this contract\r\n    bool public withdrawalAddressFixed = false; // this can be smart contract with manages ETH from this SC\r\n\r\n    /* --------------------- Constructor */\r\n    function CryptonomicaVerification() public {// Constructor must be public or internal\r\n        owner = msg.sender;\r\n        isManager[msg.sender] = true;\r\n        withdrawalAddress = msg.sender;\r\n    }\r\n\r\n    /* -------------------- Utility functions : ---------------------- */\r\n\r\n    // (?) CryptonomicaVerification.stringToBytes32(string memory) : Is constant but potentially should not be.\r\n    // probably because of 'using low-level calls' or 'using inline assembly that contains certain opcodes'\r\n    // but 'The compiler does not enforce yet that a pure method is not reading from the state.'\r\n    // > in fact works as constant\r\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {// (!) Gas requirement: infinite\r\n        // require(bytes(source).length <= 32); // causes error, but string have to be max 32 chars\r\n\r\n        // https://ethereum.stackexchange.com/questions/9603/understanding-mload-assembly-function\r\n        // http://solidity.readthedocs.io/en/latest/assembly.html\r\n        // this converts every char to its byte representation\r\n        // see hex codes on http://www.asciitable.com/ (7 > 37, a > 61, z > 7a)\r\n        // \"az7\" > 0x617a370000000000000000000000000000000000000000000000000000000000\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    // see also:\r\n    // https://ethereum.stackexchange.com/questions/2519/how-to-convert-a-bytes32-to-string\r\n    // https://ethereum.stackexchange.com/questions/1081/how-to-concatenate-a-bytes32-array-to-a-string\r\n    // 0x617a370000000000000000000000000000000000000000000000000000000000 > \"az7\"\r\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string){// (!) Gas requirement: infinite\r\n        // string memory str = string(_bytes32);\r\n        // TypeError: Explicit type conversion not allowed from \"bytes32\" to \"string storage pointer\"\r\n        // thus we should convert bytes32 to bytes (to dynamically-sized byte array)\r\n        bytes memory bytesArray = new bytes(32);\r\n        for (uint256 i; i < 32; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n\r\n    /* -------------------- Verification functions : ---------------------- */\r\n\r\n    // from user acc\r\n    // (!) Gas requirement: infinite\r\n    function uploadSignedString(string _fingerprint, bytes20 _fingerprintBytes20, string _signedString) public payable {\r\n\r\n        // check length of the uploaded string,\r\n        // it expected to be a 64 chars string signed with OpenPGP standard signature\r\n        // bytes: Dynamically-sized byte array,\r\n        // see: http://solidity.readthedocs.io/en/develop/types.html#dynamically-sized-byte-array\r\n        // if (bytes(_signedString).length > 1000) {//\r\n        //    revert();\r\n        //    // (payable)\r\n        // }\r\n        // --- not needed: if string is to big -> out of gas\r\n\r\n        // check payment :\r\n        if (msg.value < priceForVerificationInWei) {\r\n            revert();\r\n            // (payable)\r\n        }\r\n\r\n        // if signed string already uploaded, should revert\r\n        if (signedStringUploadedOnUnixTime[msg.sender] != 0) {\r\n            revert();\r\n            // (payable)\r\n        }\r\n\r\n        // fingerprint should be uppercase 40 symbols\r\n        if (bytes(_fingerprint).length != 40) {\r\n            revert();\r\n            // (payable)\r\n        }\r\n\r\n        // fingerprint can be connected to one eth address only\r\n        if (addressAttached[_fingerprintBytes20] != 0) {\r\n            revert();\r\n            // (payable)\r\n        }\r\n\r\n        // at this stage we can not be sure that key with this fingerprint really owned by user\r\n        // thus we store it as 'unverified'\r\n        unverifiedFingerprint[msg.sender] = _fingerprint;\r\n\r\n        signedString[msg.sender] = verification[msg.sender].signedString = _signedString;\r\n\r\n        // uint256 - Unix Time\r\n        signedStringUploadedOnUnixTime[msg.sender] = block.timestamp;\r\n\r\n        SignedStringUploaded(msg.sender, _fingerprint, _signedString);\r\n\r\n    }\r\n\r\n    event SignedStringUploaded(address indexed fromAccount, string fingerprint, string uploadedString);\r\n\r\n    // from 'manager' account only\r\n    // (!) Gas requirement: infinite\r\n    function addVerificationData(\r\n        address _acc, //\r\n        string _fingerprint, // \"57A5FEE5A34D563B4B85ADF3CE369FD9E77173E5\"\r\n        bytes20 _fingerprintBytes20, // \"0x57A5FEE5A34D563B4B85ADF3CE369FD9E77173E5\"\r\n        uint _keyCertificateValidUntil, //\r\n        string _firstName, //\r\n        string _lastName, //\r\n        uint _birthDate, //\r\n        string _nationality) public {\r\n\r\n        // (!!!) only manager can add verification data\r\n        require(isManager[msg.sender]);\r\n\r\n        // check input\r\n        // fingerprint should be uppercase 40 symbols\r\n        // require(bytes(_fingerprint).length == 40);\r\n        // require(bytes(_firstName).length <= 32);\r\n        // require(bytes(_lastName).length <= 32);\r\n        // _nationality should be like \"IL\" or \"US\"\r\n        // require(bytes(_nationality).length == 2);\r\n        // >>> if we control manager account we can make checks before sending data to smart contract (cheaper)\r\n\r\n        // check if signed string uploaded\r\n        require(signedStringUploadedOnUnixTime[_acc] != 0);\r\n        // to make possible adding verification only one time:\r\n        require(verificationAddedOn[_acc] == 0);\r\n\r\n        verification[_acc].fingerprint = _fingerprint;\r\n        fingerprint[_acc] = _fingerprintBytes20;\r\n\r\n        addressAttached[_fingerprintBytes20] = _acc;\r\n\r\n        verification[_acc].keyCertificateValidUntil = keyCertificateValidUntil[_acc] = _keyCertificateValidUntil;\r\n        verification[_acc].firstName = _firstName;\r\n        firstName[_acc] = stringToBytes32(_firstName);\r\n        verification[_acc].lastName = _lastName;\r\n        lastName[_acc] = stringToBytes32(_lastName);\r\n        verification[_acc].birthDate = birthDate[_acc] = _birthDate;\r\n        verification[_acc].nationality = _nationality;\r\n        nationality[_acc] = stringToBytes32(_nationality);\r\n        verification[_acc].verificationAddedOn = verificationAddedOn[_acc] = block.timestamp;\r\n\r\n        VerificationAdded(\r\n            verification[_acc].fingerprint,\r\n            _acc,\r\n        // keyCertificateValidUntil[_acc],\r\n        // verification[_acc].firstName,\r\n        // verification[_acc].lastName,\r\n        // birthDate[_acc],\r\n        // verification[_acc].nationality,\r\n            msg.sender\r\n        );\r\n        // return true;\r\n    }\r\n\r\n    event VerificationAdded (\r\n        string forFingerprint,\r\n        address indexed verifiedAccount, // (1) indexed\r\n    // uint keyCertificateValidUntilUnixTime,\r\n    // string userFirstName,\r\n    // string userLastName,\r\n    // uint userBirthDate,\r\n    // string userNationality,\r\n        address verificationAddedByAccount\r\n    );\r\n\r\n    // from user or 'manager' account\r\n    function revokeVerification(address _acc) public {// (!) Gas requirement: infinite\r\n        require(msg.sender == _acc || isManager[msg.sender]);\r\n\r\n        verification[_acc].revokedOn = revokedOn[_acc] = block.timestamp;\r\n\r\n        // event\r\n        VerificationRevoked(\r\n            _acc,\r\n            verification[_acc].fingerprint,\r\n            block.timestamp,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    event VerificationRevoked (\r\n        address indexed revocedforAccount, // (1) indexed\r\n        string withFingerprint,\r\n        uint revokedOnUnixTime,\r\n        address indexed revokedBy // (2) indexed\r\n    );\r\n\r\n    /* -------------------- Administrative functions : ---------------------- */\r\n\r\n    // to avoid mistakes: owner (super admin) should be changed in two steps\r\n    // change is valid when accepted from new owner address\r\n    address private newOwner;\r\n    // only owner\r\n    function changeOwnerStart(address _newOwner) public {\r\n        require(msg.sender == owner);\r\n        newOwner = _newOwner;\r\n        ChangeOwnerStarted(msg.sender, _newOwner);\r\n    } //\r\n    event ChangeOwnerStarted (address indexed startedBy, address indexed newOwner);\r\n    // only by new owner\r\n    function changeOwnerAccept() public {\r\n        require(msg.sender == newOwner);\r\n        // event here:\r\n        OwnerChanged(owner, newOwner);\r\n        owner = newOwner;\r\n    } //\r\n    event OwnerChanged(address indexed from, address indexed to);\r\n\r\n    // only owner\r\n    function addManager(address _acc) public {\r\n        require(msg.sender == owner);\r\n        isManager[_acc] = true;\r\n        ManagerAdded(_acc, msg.sender);\r\n    } //\r\n    event ManagerAdded (address indexed added, address indexed addedBy);\r\n    // only owner\r\n    function removeManager(address manager) public {\r\n        require(msg.sender == owner);\r\n        isManager[manager] = false;\r\n        ManagerRemoved(manager, msg.sender);\r\n    } //\r\n    event ManagerRemoved(address indexed removed, address indexed removedBy);\r\n\r\n    // only by manager\r\n    function setPriceForVerification(uint priceInWei) public {\r\n        // see converter on https://etherconverter.online\r\n        require(isManager[msg.sender]);\r\n        uint oldPrice = priceForVerificationInWei;\r\n        priceForVerificationInWei = priceInWei;\r\n        PriceChanged(oldPrice, priceForVerificationInWei, msg.sender);\r\n    } //\r\n    event PriceChanged(uint from, uint to, address indexed changedBy);\r\n\r\n    // !!! can be called by any user or contract\r\n    // check for re-entrancy vulnerability http://solidity.readthedocs.io/en/develop/security-considerations.html#re-entrancy\r\n    // >>> since we are making a withdrawal to our own contract only there is no possible attack using re-entrancy vulnerability,\r\n    function withdrawAllToWithdrawalAddress() public returns (bool) {// (!) Gas requirement: infinite\r\n        // http://solidity.readthedocs.io/en/develop/security-considerations.html#sending-and-receiving-ether\r\n        // about <address>.send(uint256 amount) and <address>.transfer(uint256 amount)\r\n        // see: http://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=transfer#address-related\r\n        // https://ethereum.stackexchange.com/questions/19341/address-send-vs-address-transfer-best-practice-usage\r\n        uint sum = this.balance;\r\n        if (!withdrawalAddress.send(this.balance)) {// makes withdrawal and returns true or false\r\n            Withdrawal(withdrawalAddress, sum, msg.sender, false);\r\n            return false;\r\n        }\r\n        Withdrawal(withdrawalAddress, sum, msg.sender, true);\r\n        return true;\r\n    } //\r\n    event Withdrawal(address indexed to, uint sumInWei, address indexed by, bool success);\r\n\r\n    // only owner\r\n    function setWithdrawalAddress(address _withdrawalAddress) public {\r\n        require(msg.sender == owner);\r\n        require(!withdrawalAddressFixed);\r\n        WithdrawalAddressChanged(withdrawalAddress, _withdrawalAddress, msg.sender);\r\n        withdrawalAddress = _withdrawalAddress;\r\n    } //\r\n    event WithdrawalAddressChanged(address indexed from, address indexed to, address indexed changedBy);\r\n\r\n    // only owner\r\n    function fixWithdrawalAddress(address _withdrawalAddress) public returns (bool) {\r\n        require(msg.sender == owner);\r\n        require(withdrawalAddress == _withdrawalAddress);\r\n\r\n        // prevents event if already fixed\r\n        require(!withdrawalAddressFixed);\r\n\r\n        withdrawalAddressFixed = true;\r\n        WithdrawalAddressFixed(withdrawalAddress, msg.sender);\r\n        return true;\r\n    } //\r\n    // this event can be fired one time only\r\n    event WithdrawalAddressFixed(address withdrawalAddressFixedAs, address fixedBy);\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalAddress\",\"type\":\"address\"}],\"name\":\"fixWithdrawalAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceForVerificationInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unverifiedFingerprint\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalAddress\",\"type\":\"address\"}],\"name\":\"setWithdrawalAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"signedString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_acc\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"verificationAddedOn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"signedStringUploadedOnUnixTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"birthDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnerStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"keyCertificateValidUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fingerprint\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_acc\",\"type\":\"address\"},{\"name\":\"_fingerprint\",\"type\":\"string\"},{\"name\":\"_fingerprintBytes20\",\"type\":\"bytes20\"},{\"name\":\"_keyCertificateValidUntil\",\"type\":\"uint256\"},{\"name\":\"_firstName\",\"type\":\"string\"},{\"name\":\"_lastName\",\"type\":\"string\"},{\"name\":\"_birthDate\",\"type\":\"uint256\"},{\"name\":\"_nationality\",\"type\":\"string\"}],\"name\":\"addVerificationData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalAddressFixed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"revokedOn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bytes32\",\"type\":\"bytes32\"}],\"name\":\"bytes32ToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"verification\",\"outputs\":[{\"name\":\"fingerprint\",\"type\":\"string\"},{\"name\":\"keyCertificateValidUntil\",\"type\":\"uint256\"},{\"name\":\"firstName\",\"type\":\"string\"},{\"name\":\"lastName\",\"type\":\"string\"},{\"name\":\"birthDate\",\"type\":\"uint256\"},{\"name\":\"nationality\",\"type\":\"string\"},{\"name\":\"verificationAddedOn\",\"type\":\"uint256\"},{\"name\":\"revokedOn\",\"type\":\"uint256\"},{\"name\":\"signedString\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeOwnerAccept\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"firstName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllToWithdrawalAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stringToSignExample\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"string\"}],\"name\":\"stringToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fingerprint\",\"type\":\"string\"},{\"name\":\"_fingerprintBytes20\",\"type\":\"bytes20\"},{\"name\":\"_signedString\",\"type\":\"string\"}],\"name\":\"uploadSignedString\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes20\"}],\"name\":\"addressAttached\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_acc\",\"type\":\"address\"}],\"name\":\"revokeVerification\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nationality\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"setPriceForVerification\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fingerprint\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"uploadedString\",\"type\":\"string\"}],\"name\":\"SignedStringUploaded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"forFingerprint\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"verifiedAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"verificationAddedByAccount\",\"type\":\"address\"}],\"name\":\"VerificationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"revocedforAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withFingerprint\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"revokedOnUnixTime\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"revokedBy\",\"type\":\"address\"}],\"name\":\"VerificationRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"startedBy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwnerStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"added\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"addedBy\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"removed\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"removedBy\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sumInWei\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"WithdrawalAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"withdrawalAddressFixedAs\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fixedBy\",\"type\":\"address\"}],\"name\":\"WithdrawalAddressFixed\",\"type\":\"event\"}]","ContractName":"CryptonomicaVerification","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5d883535e3010c345f71e8432366745740f31a379d0340e8801b497f4fee1aa9"}]}