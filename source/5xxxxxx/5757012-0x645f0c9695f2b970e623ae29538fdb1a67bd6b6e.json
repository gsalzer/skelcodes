{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract _8thereum {\r\n\r\n\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    // only people with tokens\r\n    modifier onlyTokenHolders() \r\n    {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n    \r\n    // only people with profits\r\n    modifier onlyDividendPositive() \r\n    {\r\n        require(myDividends(true) > 0);\r\n        _;\r\n    }\r\n\r\n    // only owner\r\n    modifier onlyOwner() \r\n    { \r\n        require (address(msg.sender) == owner); \r\n        _; \r\n    }\r\n    \r\n    // only non-whales\r\n    modifier onlyNonOwner() \r\n    { \r\n        require (address(msg.sender) != owner); \r\n        _; \r\n    }\r\n    \r\n    modifier onlyFoundersIfNotPublic() \r\n    {\r\n        if(!openToThePublic)\r\n        {\r\n            require (founders[address(msg.sender)] == true);   \r\n        }\r\n        _;\r\n    }    \r\n    \r\n    modifier onlyApprovedContracts()\r\n    {\r\n        if(!gameList[msg.sender])\r\n        {\r\n            require (msg.sender == tx.origin);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingEthereum,\r\n        uint256 tokensMinted,\r\n        address indexed referredBy\r\n    );\r\n    \r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethereumEarned\r\n    );\r\n    \r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethereumReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethereumWithdrawn\r\n    );\r\n    \r\n    event lotteryPayout(\r\n        address customerAddress, \r\n        uint256 lotterySupply\r\n    );\r\n    \r\n    event whaleDump(\r\n        uint256 amount\r\n    );\r\n    \r\n    // ERC20\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n    \r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public name = \"8thereum\";\r\n    string public symbol = \"BIT\";\r\n    bool public openToThePublic = false;\r\n    address public owner;\r\n    uint8 constant public decimals = 18;\r\n    uint8 constant internal dividendFee = 15;\r\n    uint256 constant internal tokenPrice = 500000000000000;//0.0005 ether\r\n    uint256 constant internal magnitude = 2**64;\r\n    uint256 constant public referralLinkRequirement = 5e18;// 5 token minimum for referral link\r\n    \r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    mapping(address => bool) internal gameList;\r\n    mapping(address => uint256) internal publicTokenLedger;\r\n    mapping(address => uint256) public   whaleLedger;\r\n    mapping(address => uint256) public   gameLedger;\r\n    mapping(address => uint256) internal referralBalances;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => mapping(address => uint256)) public gamePlayers;\r\n    mapping(address => bool) internal founders;\r\n    address[] lotteryPlayers;\r\n    uint256 internal lotterySupply = 0;\r\n    uint256 internal tokenSupply = 0;\r\n    uint256 internal gameSuppply = 0;\r\n    uint256 internal profitPerShare_;\r\n    \r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --  \r\n    */\r\n    constructor()\r\n        public\r\n    {\r\n        // no admin, but the owner of the contract is the address used for whale\r\n        owner = address(msg.sender);\r\n\r\n        // add founders here... Founders don't get any special priveledges except being first in line at launch day\r\n        founders[owner] = true; //owner's address\r\n        founders[0x7e474fe5Cfb720804860215f407111183cbc2f85] = true; //KENNY\r\n        founders[0x5138240E96360ad64010C27eB0c685A8b2eDE4F2] = true; //crypt0b!t \r\n        founders[0xAA7A7C2DECB180f68F11E975e6D92B5Dc06083A6] = true; //NumberOfThings \r\n        founders[0x6DC622a04Fd13B6a1C3C5B229CA642b8e50e1e74] = true; //supermanlxvi\r\n        founders[0x41a21b264F9ebF6cF571D4543a5b3AB1c6bEd98C] = true; //Ravi\r\n    }\r\n    \r\n     \r\n    /**\r\n     * Converts all incoming ethereum to tokens for the caller, and passes down the referral address\r\n     */\r\n    function buy(address referredyBy)\r\n        onlyFoundersIfNotPublic()\r\n        public\r\n        payable\r\n        returns(uint256)\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        excludeWhale(referredyBy); \r\n    }\r\n    \r\n    /**\r\n     * Fallback function to handle ethereum that was send straight to the contract\r\n     */\r\n    function()\r\n        onlyFoundersIfNotPublic()\r\n        payable\r\n        public\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        excludeWhale(0x0); \r\n    }\r\n    \r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function reinvest()\r\n        onlyDividendPositive()\r\n        onlyNonOwner()\r\n        public\r\n    {   \r\n        \r\n        require (msg.sender == tx.origin);\r\n        \r\n        // fetch dividends\r\n        uint256 dividends = myDividends(false); // retrieve ref. bonus later in the code\r\n        \r\n        // pay out the dividends virtually\r\n        address customerAddress = msg.sender;\r\n        payoutsTo_[customerAddress] +=  int256(SafeMath.mul(dividends, magnitude));\r\n        \r\n        // retrieve ref. bonus\r\n        dividends += referralBalances[customerAddress];\r\n        referralBalances[customerAddress] = 0;\r\n        \r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(dividends, 0x0);\r\n        \r\n        // fire event for logging \r\n        emit onReinvestment(customerAddress, dividends, _tokens);\r\n    }\r\n    \r\n    /**\r\n     * Alias of sell() and withdraw().\r\n     */\r\n    function exit()\r\n        onlyNonOwner()\r\n        onlyTokenHolders()\r\n        public\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        \r\n        // get token count for caller & sell them all\r\n        address customerAddress = address(msg.sender);\r\n        uint256 _tokens = publicTokenLedger[customerAddress];\r\n        \r\n        if(_tokens > 0) \r\n        {\r\n            sell(_tokens);\r\n        }\r\n\r\n        withdraw();\r\n    }\r\n\r\n    /**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw()\r\n        onlyNonOwner()\r\n        onlyDividendPositive()\r\n        public\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        \r\n        // setup data\r\n        address customerAddress = msg.sender;\r\n        uint256 dividends = myDividends(false); // get ref. bonus later in the code\r\n        \r\n        // update dividend tracker\r\n        payoutsTo_[customerAddress] +=  int256(SafeMath.mul(dividends, magnitude));\r\n        \r\n        // add ref. bonus\r\n        dividends += referralBalances[customerAddress];\r\n        referralBalances[customerAddress] = 0;\r\n        \r\n        customerAddress.transfer(dividends);\r\n        \r\n        // fire event for logging \r\n        emit onWithdraw(customerAddress, dividends);\r\n    }\r\n    \r\n    /**\r\n     * Liquifies tokens to ethereum.\r\n     */\r\n    function sell(uint256 _amountOfTokens)\r\n        onlyNonOwner()\r\n        onlyTokenHolders()\r\n        public\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0));\r\n\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 ethereum = tokensToEthereum_(_tokens);\r\n        uint256 dividends = (ethereum * dividendFee) / 100;\r\n        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\r\n        \r\n        //Take some divs for the lottery and whale\r\n        uint256 lotteryAndWhaleFee = dividends / 3;\r\n        dividends -= lotteryAndWhaleFee;\r\n        \r\n        //figure out the lotteryFee\r\n        uint256 lotteryFee = lotteryAndWhaleFee / 2;\r\n        //add tokens to the whale\r\n        uint256 whaleFee = lotteryAndWhaleFee - lotteryFee;\r\n        whaleLedger[owner] += whaleFee;\r\n        //add tokens to the lotterySupply\r\n        lotterySupply += ethereumToTokens_(lotteryFee);\r\n        // burn the sold tokens\r\n        tokenSupply -=  _tokens;\r\n        publicTokenLedger[msg.sender] -= _tokens;\r\n        \r\n        \r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (taxedEthereum * magnitude));\r\n        payoutsTo_[msg.sender] -= _updatedPayouts;  \r\n        \r\n        // dividing by zero is a bad idea\r\n        if (tokenSupply > 0) \r\n        {\r\n            // update the amount of dividends per token\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (dividends * magnitude) / tokenSupply);\r\n        }\r\n        \r\n        // fire event for logging \r\n        emit onTokenSell(msg.sender, _tokens, taxedEthereum);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        onlyNonOwner()\r\n        onlyTokenHolders()\r\n        onlyApprovedContracts()\r\n        public\r\n        returns(bool)\r\n    {\r\n        assert(_toAddress != owner);\r\n        \r\n        // setup\r\n        if(gameList[msg.sender] == true) //If game is transferring tokens\r\n        {\r\n            require((_amountOfTokens <= gameLedger[msg.sender]) && (_amountOfTokens > 0 ));\r\n             // exchange tokens\r\n            gameLedger[msg.sender] -= _amountOfTokens;\r\n            gameSuppply -= _amountOfTokens;\r\n            publicTokenLedger[_toAddress] += _amountOfTokens; \r\n            \r\n            // update dividend trackers\r\n            payoutsTo_[_toAddress] += int256(profitPerShare_ * _amountOfTokens); \r\n        }\r\n        else if (gameList[_toAddress] == true) //If customer transferring tokens to game\r\n        {\r\n            // make sure we have the requested tokens\r\n            //each game should only cost one token to play\r\n            require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 && (_amountOfTokens == 1e18)));\r\n             \r\n             // exchange tokens\r\n            publicTokenLedger[msg.sender] -=  _amountOfTokens;\r\n            gameLedger[_toAddress] += _amountOfTokens; \r\n            gameSuppply += _amountOfTokens;\r\n            gamePlayers[_toAddress][msg.sender] += _amountOfTokens;\r\n            \r\n            // update dividend trackers\r\n            payoutsTo_[msg.sender] -= int256(profitPerShare_ * _amountOfTokens);\r\n        }\r\n        else{\r\n            // make sure we have the requested tokens\r\n            require((_amountOfTokens <= publicTokenLedger[msg.sender]) && (_amountOfTokens > 0 ));\r\n                // exchange tokens\r\n            publicTokenLedger[msg.sender] -= _amountOfTokens;\r\n            publicTokenLedger[_toAddress] += _amountOfTokens; \r\n            \r\n            // update dividend trackers\r\n            payoutsTo_[msg.sender] -= int256(profitPerShare_ * _amountOfTokens);\r\n            payoutsTo_[_toAddress] += int256(profitPerShare_ * _amountOfTokens); \r\n            \r\n        }\r\n        \r\n        // fire event for logging \r\n        emit Transfer(msg.sender, _toAddress, _amountOfTokens); \r\n        \r\n        // ERC20\r\n        return true;\r\n       \r\n    }\r\n    \r\n    /*----------  OWNER ONLY FUNCTIONS  ----------*/\r\n\r\n    /**\r\n     * future games can be added so they can't earn divs on their token balances\r\n     */\r\n    function setGames(address newGameAddress)\r\n    onlyOwner()\r\n    public\r\n    {\r\n        gameList[newGameAddress] = true;\r\n    }\r\n    \r\n    /**\r\n     * Want to prevent snipers from buying prior to launch\r\n     */\r\n    function goPublic() \r\n        onlyOwner()\r\n        public \r\n        returns(bool)\r\n\r\n    {\r\n        openToThePublic = true;\r\n        return openToThePublic;\r\n    }\r\n    \r\n    \r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Ethereum stored in the contract\r\n     */\r\n    function totalEthereumBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (tokenSupply + lotterySupply + gameSuppply); //adds the tokens from ambassadors to the supply (but not to the dividends calculation which is based on the supply)\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return balanceOf(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividends owned by the caller.\r\n     * If `_includeReferralBonus` is to to 1/true, the referral bonus will be included in the calculations.\r\n     * The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\r\n     * But in the internal calculations, we want them separate. \r\n     */ \r\n    function myDividends(bool _includeReferralBonus) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        return _includeReferralBonus ? dividendsOf(msg.sender) + referralBalances[msg.sender] : dividendsOf(msg.sender) ;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 balance;\r\n\r\n        if (customerAddress == owner) \r\n        { \r\n            // to show div balance of owner\r\n            balance = whaleLedger[customerAddress]; \r\n        }\r\n        else if(gameList[customerAddress] == true) \r\n        {\r\n            // games can still see their token balance\r\n            balance = gameLedger[customerAddress];\r\n        }\r\n        else \r\n        {   \r\n            // to see token balance for anyone else\r\n            balance = publicTokenLedger[customerAddress];\r\n        }\r\n        return balance;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the dividend balance of any single address.\r\n     */\r\n    function dividendsOf(address customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n      return (uint256) ((int256)(profitPerShare_ * publicTokenLedger[customerAddress]) - payoutsTo_[customerAddress]) / magnitude;\r\n    }\r\n    \r\n    /**\r\n     * Return the buy and sell price of 1 individual token.\r\n     */\r\n    function buyAndSellPrice()\r\n    public\r\n    pure \r\n    returns(uint256)\r\n    {\r\n        uint256 ethereum = tokenPrice;\r\n        uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, dividendFee ), 100);\r\n        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\r\n        return taxedEthereum;\r\n    }\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price of buy orders.\r\n     */\r\n    function calculateTokensReceived(uint256 ethereumToSpend) \r\n        public \r\n        pure \r\n        returns(uint256)\r\n    {\r\n        require(ethereumToSpend >= tokenPrice);\r\n        uint256 dividends = SafeMath.div(SafeMath.mul(ethereumToSpend, dividendFee ), 100);\r\n        uint256 taxedEthereum = SafeMath.sub(ethereumToSpend, dividends);\r\n        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\r\n        \r\n        return amountOfTokens;\r\n    }\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price of sell orders.\r\n     */\r\n    function calculateEthereumReceived(uint256 tokensToSell) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        require(tokensToSell <= tokenSupply);\r\n        uint256 ethereum = tokensToEthereum_(tokensToSell);\r\n        uint256 dividends = SafeMath.div(SafeMath.mul(ethereum, dividendFee ), 100);\r\n        uint256 taxedEthereum = SafeMath.sub(ethereum, dividends);\r\n        return taxedEthereum;\r\n    }\r\n    \r\n    \r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    \r\n    \r\n    function excludeWhale(address referredyBy) \r\n        onlyNonOwner()\r\n        internal \r\n        returns(uint256) \r\n    { \r\n        require (msg.sender == tx.origin);\r\n        uint256 tokenAmount;\r\n\r\n        tokenAmount = purchaseTokens(msg.value, referredyBy); //redirects to purchaseTokens so same functionality\r\n\r\n        if(gameList[msg.sender] == true)\r\n        {\r\n            tokenSupply = SafeMath.sub(tokenSupply, tokenAmount); // takes out game's tokens from the tokenSupply (important for redistribution)\r\n            publicTokenLedger[msg.sender] = SafeMath.sub(publicTokenLedger[msg.sender], tokenAmount); // takes out game's tokens from its ledger so it is \"officially\" holding 0 tokens. (=> doesn't receive dividends anymore)\r\n            gameLedger[msg.sender] += tokenAmount;    //it gets a special ledger so it can't sell its tokens\r\n            gameSuppply += tokenAmount; // we need this for a correct totalSupply() number later\r\n        }\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n\r\n    function purchaseTokens(uint256 incomingEthereum, address referredyBy)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        require (msg.sender == tx.origin);\r\n        // data setup\r\n        uint256 undividedDivs = SafeMath.div(SafeMath.mul(incomingEthereum, dividendFee ), 100);\r\n        \r\n        //divide the divs\r\n        uint256 lotteryAndWhaleFee = undividedDivs / 3;\r\n        uint256 referralBonus = lotteryAndWhaleFee;\r\n        uint256 dividends = SafeMath.sub(undividedDivs, (referralBonus + lotteryAndWhaleFee));\r\n        uint256 taxedEthereum = incomingEthereum - undividedDivs;\r\n        uint256 amountOfTokens = ethereumToTokens_(taxedEthereum);\r\n        uint256 whaleFee = lotteryAndWhaleFee / 2;\r\n        //add divs to whale\r\n        whaleLedger[owner] += whaleFee;\r\n        \r\n        //add tokens to the lotterySupply\r\n        lotterySupply += ethereumToTokens_(lotteryAndWhaleFee - whaleFee);\r\n        \r\n        //add entry to lottery\r\n        lotteryPlayers.push(msg.sender);\r\n       \r\n        uint256 fee = dividends * magnitude;\r\n \r\n        require(amountOfTokens > 0 && (amountOfTokens + tokenSupply) > tokenSupply);\r\n        \r\n        // is the user referred by a masternode?\r\n        if(\r\n            // is this a referred purchase?\r\n            referredyBy != 0x0000000000000000000000000000000000000000 &&\r\n\r\n            // no cheating!\r\n            referredyBy != msg.sender && \r\n            \r\n            //can't use games for referralBonus\r\n            gameList[referredyBy] == false  &&\r\n            \r\n            // does the referrer have at least 5 tokens?\r\n            publicTokenLedger[referredyBy] >= referralLinkRequirement\r\n        )\r\n        {\r\n            // wealth redistribution\r\n            referralBalances[referredyBy] += referralBonus;\r\n        } else\r\n        {\r\n            // no ref purchase\r\n            // add the referral bonus back\r\n            dividends += referralBonus;\r\n            fee = dividends * magnitude;\r\n        }\r\n\r\n        uint256 payoutDividends = isWhalePaying();\r\n        \r\n        // we can't give people infinite ethereum\r\n        if(tokenSupply > 0)\r\n        {\r\n            // add tokens to the pool\r\n            tokenSupply += amountOfTokens;\r\n            \r\n             // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n            profitPerShare_ += ((payoutDividends + dividends) * magnitude / (tokenSupply));\r\n            \r\n            // calculate the amount of tokens the customer receives over his purchase \r\n            fee -= fee-(amountOfTokens * (dividends * magnitude / (tokenSupply)));\r\n        } else \r\n        {\r\n            // add tokens to the pool\r\n            tokenSupply = amountOfTokens;\r\n            \r\n            //if there are zero tokens prior to this buy, and the whale is triggered, send dividends back to whale\r\n            if(whaleLedger[owner] == 0)\r\n            {\r\n                whaleLedger[owner] = payoutDividends;\r\n            }\r\n        }\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        publicTokenLedger[msg.sender] += amountOfTokens;\r\n        \r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        // BUT, you still get the whale's divs from your purchase.... so, you still get SOMETHING.\r\n        int256 _updatedPayouts = int256((profitPerShare_ * amountOfTokens) - fee);\r\n        payoutsTo_[msg.sender] += _updatedPayouts;\r\n        \r\n     \r\n        // fire event for logging \r\n        emit onTokenPurchase(msg.sender, incomingEthereum, amountOfTokens, referredyBy);\r\n        \r\n        return amountOfTokens;\r\n    }\r\n    \r\n    \r\n     /**\r\n     * Calculate token sell value.\r\n     * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\r\n     */\r\n    function isWhalePaying()\r\n    private\r\n    returns(uint256)\r\n    {\r\n        uint256 payoutDividends = 0;\r\n         // this is where we check for lottery winner\r\n        if(whaleLedger[owner] >= 1 ether)\r\n        {\r\n            if(lotteryPlayers.length > 0)\r\n            {\r\n                uint256 winner = uint256(blockhash(block.number-1))%lotteryPlayers.length;\r\n                \r\n                publicTokenLedger[lotteryPlayers[winner]] += lotterySupply;\r\n                emit lotteryPayout(lotteryPlayers[winner], lotterySupply);\r\n                tokenSupply += lotterySupply;\r\n                lotterySupply = 0;\r\n                delete lotteryPlayers;\r\n               \r\n            }\r\n            //whale pays out everyone its divs\r\n            payoutDividends = whaleLedger[owner];\r\n            whaleLedger[owner] = 0;\r\n            emit whaleDump(payoutDividends);\r\n        }\r\n        return payoutDividends;\r\n    }\r\n\r\n    /**\r\n     * Calculate Token price based on an amount of incoming ethereum\r\n     *It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\r\n     */\r\n    function ethereumToTokens_(uint256 ethereum)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 tokensReceived = ((ethereum / tokenPrice) * 1e18);\r\n               \r\n        return tokensReceived;\r\n    }\r\n    \r\n    /**\r\n     * Calculate token sell value.\r\n     * It's a simple algorithm. Hopefully, you don't need a whitepaper with it in scientific notation.\r\n     */\r\n     function tokensToEthereum_(uint256 coin)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 ethReceived = tokenPrice * (SafeMath.div(coin, 1e18));\r\n        \r\n        return ethReceived;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n     /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gamePlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openToThePublic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyAndSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newGameAddress\",\"type\":\"address\"}],\"name\":\"setGames\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameLedger\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralLinkRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"goPublic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whaleLedger\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referredyBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"lotterySupply\",\"type\":\"uint256\"}],\"name\":\"lotteryPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"whaleDump\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"_8thereum","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3637cf81412a5eb6fa4422456bf78125c5b141ef8f78f9bccff76d0d8ddbd2fa"}]}