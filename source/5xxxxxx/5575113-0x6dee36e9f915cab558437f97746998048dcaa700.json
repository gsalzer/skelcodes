{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/*\r\n  Standard ERC20 Token.\r\n  https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n*/\r\ncontract ERC20 {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint public totalSupply;\r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n\r\n    event Created(uint time);\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n    event AllowanceUsed(address indexed owner, address indexed spender, uint amount);\r\n\r\n    constructor(string _name, string _symbol)\r\n        public\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        emit Created(now);\r\n    }\r\n\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // Attempts to transfer `_value` from `_from` to `_to`\r\n    //  if `_from` has sufficient allowance for `msg.sender`.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        address _spender = msg.sender;\r\n        require(allowance[_from][_spender] >= _value);\r\n        allowance[_from][_spender] -= _value;\r\n        emit AllowanceUsed(_from, _spender, _value);\r\n        return _transfer(_from, _to, _value);\r\n    }\r\n\r\n    // Transfers balance from `_from` to `_to` if `_to` has sufficient balance.\r\n    // Called from transfer() and transferFrom().\r\n    function _transfer(address _from, address _to, uint _value)\r\n        private\r\n        returns (bool success)\r\n    {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface HasTokenFallback {\r\n    function tokenFallback(address _from, uint256 _amount, bytes _data)\r\n        external\r\n        returns (bool success);\r\n}\r\ncontract ERC667 is ERC20 {\r\n    constructor(string _name, string _symbol)\r\n        public\r\n        ERC20(_name, _symbol)\r\n    {}\r\n\r\n    function transferAndCall(address _to, uint _value, bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(super.transfer(_to, _value));\r\n        require(HasTokenFallback(_to).tokenFallback(msg.sender, _value, _data));\r\n        return true;\r\n    }\r\n}\r\n\r\n/*********************************************************\r\n******************* DIVIDEND TOKEN ***********************\r\n**********************************************************\r\n\r\nUI: https://www.pennyether.com/status/tokens\r\n\r\nAn ERC20 token that can accept Ether and distribute it\r\nperfectly to all Token Holders relative to each account's\r\nbalance at the time the dividend is received.\r\n\r\nThe Token is owned by the creator, and can be frozen,\r\nminted, and burned by the owner.\r\n\r\nNotes:\r\n    - Accounts can view or receive dividends owed at any time\r\n    - Dividends received are immediately credited to all\r\n      current Token Holders and can be redeemed at any time.\r\n    - Per above, upon transfers, dividends are not\r\n      transferred. They are kept by the original sender, and\r\n      not credited to the receiver.\r\n    - Uses \"pull\" instead of \"push\". Token holders must pull\r\n      their own dividends.\r\n\r\nComptroller Permissions:\r\n    - mintTokens(account, amt): via comp.fund() and comp.fundCapital()\r\n    - burnTokens(account, amt): via comp.burnTokens()\r\n    - setFrozen(true): Called before CrowdSale\r\n    - setFrozen(false): Called after CrowdSale, if softCap met\r\n*/\r\ncontract DividendToken is ERC667\r\n{\r\n    // if true, tokens cannot be transferred\r\n    bool public isFrozen;\r\n\r\n    // Comptroller can call .mintTokens() and .burnTokens().\r\n    address public comptroller = msg.sender;\r\n    modifier onlyComptroller(){ require(msg.sender==comptroller); _; }\r\n\r\n    // How dividends work:\r\n    //\r\n    // - A \"point\" is a fraction of a Wei (1e-32), it's used to reduce rounding errors.\r\n    //\r\n    // - totalPointsPerToken represents how many points each token is entitled to\r\n    //   from all the dividends ever received. Each time a new deposit is made, it\r\n    //   is incremented by the points oweable per token at the time of deposit:\r\n    //     (depositAmtInWei * POINTS_PER_WEI) / totalSupply\r\n    //\r\n    // - Each account has a `creditedPoints` and `lastPointsPerToken`\r\n    //   - lastPointsPerToken:\r\n    //       The value of totalPointsPerToken the last time `creditedPoints` was changed.\r\n    //   - creditedPoints:\r\n    //       How many points have been credited to the user. This is incremented by:\r\n    //         (`totalPointsPerToken` - `lastPointsPerToken` * balance) via\r\n    //         `.updateCreditedPoints(account)`. This occurs anytime the balance changes\r\n    //         (transfer, mint, burn).\r\n    //\r\n    // - .collectOwedDividends() calls .updateCreditedPoints(account), converts points\r\n    //   to wei and pays account, then resets creditedPoints[account] to 0.\r\n    //\r\n    // - \"Credit\" goes to Nick Johnson for the concept.\r\n    //\r\n    uint constant POINTS_PER_WEI = 1e32;\r\n    uint public dividendsTotal;\r\n    uint public dividendsCollected;\r\n    uint public totalPointsPerToken;\r\n    uint public totalBurned;\r\n    mapping (address => uint) public creditedPoints;\r\n    mapping (address => uint) public lastPointsPerToken;\r\n\r\n    // Events\r\n    event Frozen(uint time);\r\n    event UnFrozen(uint time);\r\n    event TokensMinted(uint time, address indexed account, uint amount, uint newTotalSupply);\r\n    event TokensBurned(uint time, address indexed account, uint amount, uint newTotalSupply);\r\n    event CollectedDividends(uint time, address indexed account, uint amount);\r\n    event DividendReceived(uint time, address indexed sender, uint amount);\r\n\r\n    constructor(string _name, string _symbol)\r\n        public\r\n        ERC667(_name, _symbol)\r\n    {}\r\n\r\n    // Upon receiving payment, increment lastPointsPerToken.\r\n    function ()\r\n        payable\r\n        public\r\n    {\r\n        if (msg.value == 0) return;\r\n        // POINTS_PER_WEI is 1e32.\r\n        // So, no multiplication overflow unless msg.value > 1e45 wei (1e27 ETH)\r\n        totalPointsPerToken += (msg.value * POINTS_PER_WEI) / totalSupply;\r\n        dividendsTotal += msg.value;\r\n        emit DividendReceived(now, msg.sender, msg.value);\r\n    }\r\n\r\n    /*************************************************************/\r\n    /******* COMPTROLLER FUNCTIONS *******************************/\r\n    /*************************************************************/\r\n    // Credits dividends, then mints more tokens.\r\n    function mint(address _to, uint _amount)\r\n        onlyComptroller\r\n        public\r\n    {\r\n        _updateCreditedPoints(_to);\r\n        totalSupply += _amount;\r\n        balanceOf[_to] += _amount;\r\n        emit TokensMinted(now, _to, _amount, totalSupply);\r\n    }\r\n    \r\n    // Credits dividends, burns tokens.\r\n    function burn(address _account, uint _amount)\r\n        onlyComptroller\r\n        public\r\n    {\r\n        require(balanceOf[_account] >= _amount);\r\n        _updateCreditedPoints(_account);\r\n        balanceOf[_account] -= _amount;\r\n        totalSupply -= _amount;\r\n        totalBurned += _amount;\r\n        emit TokensBurned(now, _account, _amount, totalSupply);\r\n    }\r\n\r\n    // when set to true, prevents tokens from being transferred\r\n    function freeze(bool _isFrozen)\r\n        onlyComptroller\r\n        public\r\n    {\r\n        if (isFrozen == _isFrozen) return;\r\n        isFrozen = _isFrozen;\r\n        if (_isFrozen) emit Frozen(now);\r\n        else emit UnFrozen(now);\r\n    }\r\n\r\n    /*************************************************************/\r\n    /********** PUBLIC FUNCTIONS *********************************/\r\n    /*************************************************************/\r\n    \r\n    // Normal ERC20 transfer, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {   \r\n        // ensure tokens are not frozen.\r\n        require(!isFrozen);\r\n        _updateCreditedPoints(msg.sender);\r\n        _updateCreditedPoints(_to);\r\n        return ERC20.transfer(_to, _value);\r\n    }\r\n\r\n    // Normal ERC20 transferFrom, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(!isFrozen);\r\n        _updateCreditedPoints(_from);\r\n        _updateCreditedPoints(_to);\r\n        return ERC20.transferFrom(_from, _to, _value);\r\n    }\r\n    \r\n    // Normal ERC667 transferAndCall, except before transferring\r\n    //  it credits points for both the sender and receiver.\r\n    function transferAndCall(address _to, uint _value, bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(!isFrozen);\r\n        _updateCreditedPoints(msg.sender);\r\n        _updateCreditedPoints(_to);\r\n        return ERC667.transferAndCall(_to, _value, _data);  \r\n    }\r\n\r\n    // Updates creditedPoints, sends all wei to the owner\r\n    function collectOwedDividends()\r\n        public\r\n        returns (uint _amount)\r\n    {\r\n        // update creditedPoints, store amount, and zero it.\r\n        _updateCreditedPoints(msg.sender);\r\n        _amount = creditedPoints[msg.sender] / POINTS_PER_WEI;\r\n        creditedPoints[msg.sender] = 0;\r\n        dividendsCollected += _amount;\r\n        emit CollectedDividends(now, msg.sender, _amount);\r\n        require(msg.sender.call.value(_amount)());\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** PRIVATE METHODS / VIEWS **************************/\r\n    /*************************************************************/\r\n    // Credits _account with whatever dividend points they haven't yet been credited.\r\n    //  This needs to be called before any user's balance changes to ensure their\r\n    //  \"lastPointsPerToken\" credits their current balance, and not an altered one.\r\n    function _updateCreditedPoints(address _account)\r\n        private\r\n    {\r\n        creditedPoints[_account] += _getUncreditedPoints(_account);\r\n        lastPointsPerToken[_account] = totalPointsPerToken;\r\n    }\r\n\r\n    // For a given account, returns how many Wei they haven't yet been credited.\r\n    function _getUncreditedPoints(address _account)\r\n        private\r\n        view\r\n        returns (uint _amount)\r\n    {\r\n        uint _pointsPerToken = totalPointsPerToken - lastPointsPerToken[_account];\r\n        // The upper bound on this number is:\r\n        //   ((1e32 * TOTAL_DIVIDEND_AMT) / totalSupply) * balances[_account]\r\n        // Since totalSupply >= balances[_account], this will overflow only if\r\n        //   TOTAL_DIVIDEND_AMT is around 1e45 wei. Not ever going to happen.\r\n        return _pointsPerToken * balanceOf[_account];\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********* CONSTANTS *****************************************/\r\n    /*************************************************************/\r\n    // Returns how many wei a call to .collectOwedDividends() would transfer.\r\n    function getOwedDividends(address _account)\r\n        public\r\n        constant\r\n        returns (uint _amount)\r\n    {\r\n        return (_getUncreditedPoints(_account) + creditedPoints[_account])/POINTS_PER_WEI;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"creditedPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectOwedDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comptroller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getOwedDividends\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastPointsPerToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isFrozen\",\"type\":\"bool\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPointsPerToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Frozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"UnFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"TokensMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newTotalSupply\",\"type\":\"uint256\"}],\"name\":\"TokensBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CollectedDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AllowanceUsed\",\"type\":\"event\"}]","ContractName":"DividendToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000f50656e6e794574686572546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000550454e4e59000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://df25abe8afe9f3662e14fc14779fe5fd8c0b80cf7d8347e3734eca9ade7624ed"}]}