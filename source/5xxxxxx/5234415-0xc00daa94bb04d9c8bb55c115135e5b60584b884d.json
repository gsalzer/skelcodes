{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure  returns (uint) {\r\n    uint c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    require(b > 0);\r\n    uint c = a / b;\r\n    require(a == b * c + a % b);\r\n    return c;\r\n  }\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n  function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n  function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n  function min256(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint);\r\n  function transfer(address to, uint value) public;\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint);\r\n  function transferFrom(address from, address to, uint value) public;\r\n  function approve(address spender, uint value) public;\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  \r\n  using SafeMath for uint;\r\n  \r\n  mapping(address => uint) balances;\r\n\r\n  function transfer(address _to, uint _value) public{\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  function balanceOf(address _owner) public constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\n\r\ncontract StandardToken is BasicToken, ERC20 {\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transferFrom(address _from, address _to, uint _value) public {\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint _value) public{\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    function transferOwnership(address newOwner) onlyOwner public{\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *  TTC token contract. Implements\r\n */\r\ncontract TTC is StandardToken, Ownable {\r\n  string public constant name = \"TTC\";\r\n  string public constant symbol = \"TTC\";\r\n  uint public constant decimals = 18;\r\n\r\n\r\n  // Constructor\r\n  function TTC() public {\r\n      totalSupply = 1000000000000000000000000000;\r\n      balances[msg.sender] = totalSupply; // Send all tokens to owner\r\n  }\r\n\r\n  /**\r\n   *  Burn away the specified amount of SkinCoin tokens\r\n   */\r\n  function burn(uint _value) onlyOwner public returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    totalSupply = totalSupply.sub(_value);\r\n    Transfer(msg.sender, 0x0, _value);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Crowdsale is Ownable{\r\n    \r\n    using SafeMath for uint;\r\n\r\n    struct Backer {\r\n        uint weiReceived; \r\n        uint coinSent;\r\n        uint coinReadyToSend;\r\n    }\r\n\r\n    /*\r\n    * Constants\r\n    */\r\n\r\n    /**\r\n    * ICO Phases.\r\n    *\r\n    * - PreStart:   tokens are not yet sold/issued\r\n    * - PreIco:     new tokens sold/issued at the discounted price\r\n    * - PauseIco:   tokens are not sold/issued\r\n    * - MainIco     new tokens sold/issued at the regular price\r\n    * - AfterIco:   tokens are not sold/issued\r\n    */\r\n    enum Phases {PreStart, PreIco, PauseIco, MainIco, AfterIco}\r\n\r\n    /* Maximum number of TTC to pre ico sell */\r\n    uint public constant PRE_MAX_CAP = 25000000000000000000000000; // 25,000,000 TTC\r\n\r\n    /* Maximum number of TTC to main ico sell */\r\n    uint public constant MAIN_MAX_CAP = 125000000000000000000000000; // 125,000,000 TTC\r\n\r\n    /* Minimum amount to invest */\r\n    uint public constant MIN_INVEST_ETHER = 100 finney;\r\n\r\n    /* Crowdsale period */\r\n    uint private constant PRE_START_TIME = 1520820000;  // 2018-03-12 10:00 AM (UTC + 08:00)\r\n    uint private constant PRE_END_TIME = 1521079200;    // 2018-03-15 10:00 AM (UTC + 08:00)\r\n    uint private constant MAIN_START_TIME = 1522029600; // 2018-03-26 10:00 AM (UTC + 08:00)\r\n    uint private constant MAIN_END_TIME = 1524189600;   // 2018-04-20 10:00 AM (UTC + 08:00)\r\n\r\n    /* Number of TTC per Ether */\r\n    uint public constant PRE_COIN_PER_ETHER_ICO = 5000000000000000000000; // 5,000 TTC\r\n    uint public constant MAIN_COIN_PER_ETHER_ICO = 4000000000000000000000; // 4,000 TTC\r\n\r\n    /*\r\n    * Variables\r\n    */\r\n    /* TTC contract reference */\r\n    TTC public coin;\r\n\r\n    /*Maximum Ether for one address during pre ico or main ico */\r\n    uint public maximumCoinsPerAddress = 10 ether;\r\n    \r\n    /* Multisig contract that will receive the Ether during pre ico*/\r\n    address public preMultisigEther;\r\n    /* Number of Ether received during pre ico */\r\n    uint public preEtherReceived;\r\n    /* Number of TTC sent to Ether contributors during pre ico */\r\n    uint public preCoinSentToEther;\r\n\r\n    /* Multisig contract that will receive the Ether during main ico*/\r\n    address public mainMultisigEther;\r\n    /* Number of Ether received during main ico */\r\n    uint public mainEtherReceived;\r\n    /* Number of TTC sent to Ether contributors during main ico */\r\n    uint public mainCoinSentToEther;\r\n\r\n    /* Backers Ether indexed by their Ethereum address */\r\n    mapping(address => Backer) public preBackers;\r\n    address[] internal preReadyToSendAddress;\r\n    mapping(address => Backer) public mainBackers;\r\n    address[] internal mainReadyToSendAddress;\r\n\r\n    /* White List */\r\n    mapping(address => bool) public whiteList;\r\n\r\n    /* Current Phase */\r\n    Phases public phase = Phases.PreStart;\r\n\r\n    /*\r\n    * Modifiers\r\n    */\r\n\r\n    modifier respectTimeFrame() {\r\n        require((now >= PRE_START_TIME) && (now < PRE_END_TIME ) || (now >= MAIN_START_TIME) && (now < MAIN_END_TIME ));\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Event\r\n    */\r\n    event LogReceivedETH(address addr, uint value);\r\n    event LogCoinsEmited(address indexed from, uint amount);\r\n\r\n    /*\r\n     * Constructor\r\n    */\r\n    function Crowdsale() public{\r\n        \r\n    }\r\n\r\n    /**\r\n    *   Allow to set TTC address\r\n    */\r\n    function setTTCAddress(address _addr) onlyOwner public {\r\n        require(_addr != address(0));\r\n        coin = TTC(_addr);\r\n    }\r\n\r\n    /**\r\n     * Allow to change the team multisig address in the case of emergency.\r\n     */\r\n    function setMultisigPre(address _addr) onlyOwner public {\r\n        require(_addr != address(0));\r\n        preMultisigEther = _addr;\r\n    }\r\n\r\n    /**\r\n     * Allow to change the team multisig address in the case of emergency.\r\n     */\r\n    function setMultisigMain(address _addr) onlyOwner public {\r\n        require(_addr != address(0));\r\n        mainMultisigEther = _addr;\r\n    }\r\n\r\n    /**\r\n    *   Allow to change the maximum Coin one address can buy during the ico\r\n    */\r\n    function setMaximumCoinsPerAddress(uint _cnt) onlyOwner public{\r\n        maximumCoinsPerAddress = _cnt;\r\n    }\r\n\r\n    /* \r\n     * The fallback function corresponds to a donation in ETH\r\n     */\r\n    function() respectTimeFrame  payable public{\r\n        require(whiteList[msg.sender]);\r\n        receiveETH(msg.sender);\r\n    }\r\n\r\n    /*\r\n     *  Receives a donation in Ether\r\n    */\r\n    function receiveETH(address _beneficiary) internal {\r\n        require(msg.value >= MIN_INVEST_ETHER) ; \r\n        adjustPhaseBasedOnTime();\r\n        uint coinToSend ;\r\n\r\n        if(phase == Phases.PreIco) {\r\n            Backer storage preBacker = preBackers[_beneficiary];\r\n            require(preBacker.weiReceived.add(msg.value) <= maximumCoinsPerAddress);\r\n\r\n            coinToSend = msg.value.mul(PRE_COIN_PER_ETHER_ICO).div(1 ether); \r\n            require(coinToSend.add(preCoinSentToEther) <= PRE_MAX_CAP) ;\r\n\r\n            preBacker.coinSent = preBacker.coinSent.add(coinToSend);\r\n            preBacker.weiReceived = preBacker.weiReceived.add(msg.value);   \r\n            preBacker.coinReadyToSend = preBacker.coinReadyToSend.add(coinToSend);\r\n            preReadyToSendAddress.push(_beneficiary);\r\n\r\n            // Update the total wei collected during the crowdfunding\r\n            preEtherReceived = preEtherReceived.add(msg.value); \r\n            preCoinSentToEther = preCoinSentToEther.add(coinToSend);\r\n\r\n            // Send events\r\n            LogReceivedETH(_beneficiary, preEtherReceived); \r\n\r\n        }else if (phase == Phases.MainIco){\r\n            Backer storage mainBacker = mainBackers[_beneficiary];\r\n            require(mainBacker.weiReceived.add(msg.value) <= maximumCoinsPerAddress);\r\n\r\n            coinToSend = msg.value.mul(MAIN_COIN_PER_ETHER_ICO).div(1 ether);   \r\n            require(coinToSend.add(mainCoinSentToEther) <= MAIN_MAX_CAP) ;\r\n\r\n            mainBacker.coinSent = mainBacker.coinSent.add(coinToSend);\r\n            mainBacker.weiReceived = mainBacker.weiReceived.add(msg.value);   \r\n            mainBacker.coinReadyToSend = mainBacker.coinReadyToSend.add(coinToSend);\r\n            mainReadyToSendAddress.push(_beneficiary);\r\n\r\n            // Update the total wei collected during the crowdfunding\r\n            mainEtherReceived = mainEtherReceived.add(msg.value); \r\n            mainCoinSentToEther = mainCoinSentToEther.add(coinToSend);\r\n\r\n            // Send events\r\n            LogReceivedETH(_beneficiary, mainEtherReceived); \r\n        }\r\n    }\r\n\r\n    /*\r\n    *   Adjust phase base on time\r\n    */\r\n    function adjustPhaseBasedOnTime() internal {\r\n\r\n        if (now < PRE_START_TIME) {\r\n            if (phase != Phases.PreStart) {\r\n                phase = Phases.PreStart;\r\n            }\r\n        } else if (now >= PRE_START_TIME && now < PRE_END_TIME) {\r\n            if (phase != Phases.PreIco) {\r\n                phase = Phases.PreIco;\r\n            }\r\n        } else if (now >= PRE_END_TIME && now < MAIN_START_TIME) {\r\n            if (phase != Phases.PauseIco) {\r\n                phase = Phases.PauseIco;\r\n            }\r\n        }else if (now >= MAIN_START_TIME && now < MAIN_END_TIME) {\r\n            if (phase != Phases.MainIco) {\r\n                phase = Phases.MainIco;\r\n            }\r\n        }else {\r\n            if (phase != Phases.AfterIco){\r\n                phase = Phases.AfterIco;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    /*\r\n    *   Durign the pre ico, should be called by owner to send TTC to beneficiary address\r\n    */\r\n    function preSendTTC() onlyOwner public {\r\n        for(uint i=0; i < preReadyToSendAddress.length ; i++){\r\n            address backerAddress = preReadyToSendAddress[i];\r\n            uint coinReadyToSend = preBackers[backerAddress].coinReadyToSend;\r\n            if ( coinReadyToSend > 0) {\r\n                preBackers[backerAddress].coinReadyToSend = 0;\r\n                coin.transfer(backerAddress, coinReadyToSend);\r\n                LogCoinsEmited(backerAddress, coinReadyToSend);\r\n            }\r\n        }\r\n        delete preReadyToSendAddress;\r\n        require(preMultisigEther.send(this.balance)) ; \r\n    }\r\n\r\n    /*\r\n    *   Durign the main ico, should be called by owner to send TTC to beneficiary address\r\n    */\r\n    function mainSendTTC() onlyOwner public{\r\n        for(uint i=0; i < mainReadyToSendAddress.length ; i++){\r\n            address backerAddress = mainReadyToSendAddress[i];\r\n            uint coinReadyToSend = mainBackers[backerAddress].coinReadyToSend;\r\n            if ( coinReadyToSend > 0) {\r\n                mainBackers[backerAddress].coinReadyToSend = 0;\r\n                coin.transfer(backerAddress, coinReadyToSend);\r\n                LogCoinsEmited(backerAddress, coinReadyToSend);\r\n            }\r\n        }\r\n        delete mainReadyToSendAddress;\r\n        require(mainMultisigEther.send(this.balance)) ; \r\n\r\n    }\r\n\r\n    /*\r\n    *  White list, only address in white list can buy TTC\r\n    */\r\n    function addWhiteList(address[] _whiteList) onlyOwner public{\r\n        for (uint i =0;i<_whiteList.length;i++){\r\n            whiteList[_whiteList[i]] = true;\r\n        }   \r\n    }\r\n\r\n    /*  \r\n     * Finalize the crowdsale, should be called after the refund period\r\n    */\r\n    function finalize() onlyOwner public {\r\n        adjustPhaseBasedOnTime();\r\n        require(phase == Phases.AfterIco);\r\n        require(this.balance > 0);\r\n        require(mainMultisigEther.send(this.balance)) ; \r\n        uint remains = coin.balanceOf(this);\r\n        if (remains > 0) { \r\n            coin.transfer(owner,remains);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Manually back TTC owner address.\r\n     */\r\n    function backTTCOwner() onlyOwner public {\r\n        coin.transferOwnership(owner);\r\n    }\r\n\r\n\r\n    /**\r\n     * Transfer remains to owner in case if impossible to do min invest\r\n     */\r\n    function getPreRemainCoins() onlyOwner public {\r\n        uint preRemains = PRE_MAX_CAP - preCoinSentToEther;\r\n        Backer storage backer = preBackers[owner];\r\n        coin.transfer(owner, preRemains); \r\n        backer.coinSent = backer.coinSent.add(preRemains);\r\n        preCoinSentToEther = preCoinSentToEther.add(preRemains);\r\n        \r\n        LogCoinsEmited(this ,preRemains);\r\n        LogReceivedETH(owner, preEtherReceived); \r\n    }\r\n\r\n\r\n    /**\r\n     * Transfer remains to owner in case if impossible to do min invest\r\n     */\r\n    function getMainRemainCoins() onlyOwner public {\r\n        uint mainRemains = MAIN_MAX_CAP - mainCoinSentToEther;\r\n        Backer storage backer = mainBackers[owner];\r\n        coin.transfer(owner, mainRemains); \r\n        backer.coinSent = backer.coinSent.add(mainRemains);\r\n        mainCoinSentToEther = mainCoinSentToEther.add(mainRemains);\r\n\r\n        LogCoinsEmited(this ,mainRemains);\r\n        LogReceivedETH(owner, mainEtherReceived); \r\n    }\r\n\r\n    /**\r\n    *   Refund to specific address \r\n    */\r\n    function refund(address _beneficiary) onlyOwner public {\r\n\r\n        uint valueToSend = 0;\r\n        Backer storage preBacker = preBackers[_beneficiary];\r\n        if (preBacker.coinReadyToSend > 0){ \r\n            uint preValueToSend = preBacker.coinReadyToSend.mul(1 ether).div(PRE_COIN_PER_ETHER_ICO);\r\n            preBacker.coinSent = preBacker.coinSent.sub(preBacker.coinReadyToSend);\r\n            preBacker.weiReceived = preBacker.weiReceived.sub(preValueToSend);   \r\n            preEtherReceived = preEtherReceived.sub(preValueToSend); \r\n            preCoinSentToEther = preCoinSentToEther.sub(preBacker.coinReadyToSend);\r\n            preBacker.coinReadyToSend = 0;\r\n            valueToSend = valueToSend + preValueToSend;\r\n\r\n        }\r\n\r\n        Backer storage mainBacker = mainBackers[_beneficiary];\r\n        if (mainBacker.coinReadyToSend > 0){ \r\n            uint mainValueToSend = mainBacker.coinReadyToSend.mul(1 ether).div(MAIN_COIN_PER_ETHER_ICO);\r\n            mainBacker.coinSent = mainBacker.coinSent.sub(mainBacker.coinReadyToSend);\r\n            mainBacker.weiReceived = mainBacker.weiReceived.sub(mainValueToSend);   \r\n            mainEtherReceived = mainEtherReceived.sub(mainValueToSend); \r\n            mainCoinSentToEther = mainCoinSentToEther.sub(mainBacker.coinReadyToSend);\r\n            mainBacker.coinReadyToSend = 0;\r\n            valueToSend = valueToSend + mainValueToSend;\r\n\r\n        }\r\n        if (valueToSend > 0){\r\n            require(_beneficiary.send(valueToSend));\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    /**\r\n    *   Refund to all address\r\n    */  \r\n    function refundAll() onlyOwner public {\r\n\r\n        for(uint i=0; i < preReadyToSendAddress.length ; i++){\r\n            refund(preReadyToSendAddress[i]);\r\n\r\n        }\r\n        \r\n        for(uint j=0; j < mainReadyToSendAddress.length ; j++){\r\n            refund(mainReadyToSendAddress[j]);\r\n\r\n        }\r\n\r\n        delete preReadyToSendAddress;\r\n        delete mainReadyToSendAddress;\r\n\r\n    }\r\n    \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PRE_MAX_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preCoinSentToEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMultisigPre\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAIN_COIN_PER_ETHER_ICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"preBackers\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"coinSent\",\"type\":\"uint256\"},{\"name\":\"coinReadyToSend\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMainRemainCoins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRE_COIN_PER_ETHER_ICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whiteList\",\"type\":\"address[]\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mainBackers\",\"outputs\":[{\"name\":\"weiReceived\",\"type\":\"uint256\"},{\"name\":\"coinSent\",\"type\":\"uint256\"},{\"name\":\"coinReadyToSend\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainMultisigEther\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVEST_ETHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"backTTCOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maximumCoinsPerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preMultisigEther\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mainSendTTC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getPreRemainCoins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"preSendTTC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cnt\",\"type\":\"uint256\"}],\"name\":\"setMaximumCoinsPerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainCoinSentToEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAIN_MAX_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainEtherReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preEtherReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMultisigMain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTTCAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogReceivedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogCoinsEmited\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c4bc333a166e83952f6e139002c460c8e4579d5ec39b2be6538502ea18c0f1a6"}]}