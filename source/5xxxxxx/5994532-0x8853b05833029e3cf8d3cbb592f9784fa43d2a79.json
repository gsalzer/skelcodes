{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: contracts/ERC165/ERC165.sol\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces.\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ncontract ERC165 {\r\n\r\n  // bytes4(keccak256('supportsInterface(bytes4)'));\r\n  bytes4 constant INTERFACE_ERC165 = 0x01ffc9a7;\r\n\r\n  /**\r\n   * @dev Checks if the smart contract includes a specific interface.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceID) public pure returns (bool) {\r\n    return _interfaceID == INTERFACE_ERC165;\r\n  }\r\n}\r\n\r\n// File: contracts/ERC721/ERC721Basic.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n  // bytes4(keccak256('balanceOf(address)')) ^\r\n  // bytes4(keccak256('ownerOf(uint256)')) ^\r\n  // bytes4(keccak256('approve(address,uint256)')) ^\r\n  // bytes4(keccak256('getApproved(uint256)')) ^\r\n  // bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n  // bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n  // bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n  // bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n  // bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'));\r\n  bytes4 constant INTERFACE_ERC721 = 0x80ac58cd;\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool indexed _approved);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n\r\n  // Note: This is not in the official ERC-721 standard so it's not included in the interface hash\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId) public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId) public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data) public;\r\n}\r\n\r\n// File: contracts/ERC721/ERC721.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  // bytes4(keccak256('totalSupply()')) ^\r\n  // bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n  // bytes4(keccak256('tokenByIndex(uint256)'));\r\n  bytes4 constant INTERFACE_ERC721_ENUMERABLE = 0x780e9d63;\r\n\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  // bytes4(keccak256('name()')) ^\r\n  // bytes4(keccak256('symbol()')) ^\r\n  // bytes4(keccak256('tokenURI(uint256)'));\r\n  bytes4 constant INTERFACE_ERC721_METADATA = 0x5b5e139f;\r\n\r\n  function name() public view returns (string _name);\r\n  function symbol() public view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\n/* solium-disable-next-line no-empty-blocks */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n// File: contracts/library/ProxyOwnable.sol\r\n\r\n/**\r\n * @title ProxyOwnable\r\n * @dev Essentially the Ownable contract, renamed for the purposes of separating it from the\r\n *  DelayedOwnable contract (the owner of the token contract).\r\n */\r\ncontract ProxyOwnable {\r\n  address public proxyOwner;\r\n\r\n  event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `proxyOwner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    proxyOwner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == proxyOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferProxyOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));\r\n\r\n    emit ProxyOwnershipTransferred(proxyOwner, _newOwner);\r\n\r\n    proxyOwner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/CodexRecordProxy.sol\r\n\r\n/**\r\n * @title CodexRecordProxy, a proxy contract for token storage\r\n * @dev This allows the token owner to optionally upgrade the token in the future\r\n *  if there are changes needed in the business logic. See the upgradeTo function\r\n *  for caveats.\r\n * Based on MIT licensed code from\r\n *  https://github.com/zeppelinos/labs/tree/master/upgradeability_using_inherited_storage\r\n */\r\ncontract CodexRecordProxy is ProxyOwnable {\r\n  event Upgraded(string version, address indexed implementation);\r\n\r\n  string public version;\r\n  address public implementation;\r\n\r\n  constructor(address _implementation) public {\r\n    upgradeTo(\"1\", _implementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Fallback function. Any transaction sent to this contract that doesn't match the\r\n   *  upgradeTo signature will fallback to this function, which in turn will use\r\n   *  DELEGATECALL to delegate the transaction data to the implementation.\r\n   */\r\n  function () payable public {\r\n    address _implementation = implementation;\r\n\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      calldatacopy(ptr, 0, calldatasize)\r\n      let result := delegatecall(gas, _implementation, ptr, calldatasize, 0, 0)\r\n      let size := returndatasize\r\n      returndatacopy(ptr, 0, size)\r\n\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Since name is passed into the ERC721 token constructor, it's not stored in the CodexRecordProxy\r\n   *  contract. Thus, we call into the contract directly to retrieve its value.\r\n   * @return string The name of the token\r\n   */\r\n  function name() external view returns (string) {\r\n    ERC721Metadata tokenMetadata = ERC721Metadata(implementation);\r\n\r\n    return tokenMetadata.name();\r\n  }\r\n\r\n  /**\r\n   * @dev Since symbol is passed into the ERC721 token constructor, it's not stored in the CodexRecordProxy\r\n   *  contract. Thus, we call into the contract directly to retrieve its value.\r\n   * @return string The symbol of token\r\n   */\r\n  function symbol() external view returns (string) {\r\n    ERC721Metadata tokenMetadata = ERC721Metadata(implementation);\r\n\r\n    return tokenMetadata.symbol();\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the CodexRecordProxy to point at a new implementation. Only callable by the owner.\r\n   *  Only upgrade the token after extensive testing has been done. The storage is append only.\r\n   *  The new token must inherit from the previous token so the shape of the storage is maintained.\r\n   * @param _version The version of the token\r\n   * @param _implementation The address at which the implementation is available\r\n   */\r\n  function upgradeTo(string _version, address _implementation) public onlyOwner {\r\n    require(\r\n      keccak256(abi.encodePacked(_version)) != keccak256(abi.encodePacked(version)),\r\n      \"The version cannot be the same\");\r\n\r\n    require(\r\n      _implementation != implementation,\r\n      \"The implementation cannot be the same\");\r\n\r\n    require(\r\n      _implementation != address(0),\r\n      \"The implementation cannot be the 0 address\");\r\n\r\n    version = _version;\r\n    implementation = _implementation;\r\n\r\n    emit Upgraded(version, implementation);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_version\",\"type\":\"string\"},{\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferProxyOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"version\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ProxyOwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CodexRecordProxy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002c00a92a9c5c919a1a4b5a8ee6bc520f61dbe421","Library":"","SwarmSource":"bzzr://83a557ba1aa9f6ac77ad377a575a0a385b9d2174badc0156a5d6babaf85ad0a3"}]}