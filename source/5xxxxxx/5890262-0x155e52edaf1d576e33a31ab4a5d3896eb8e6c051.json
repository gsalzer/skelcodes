{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function decimals() public view returns(uint digits);\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Burn(address indexed _from, uint256 _value);\r\n\r\n}\r\n\r\ninterface tokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\r\n}\r\n\r\n\r\ncontract Ownable {\r\n\r\n    /// `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address newOwner=0x0;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    ///change the owner\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /// accept the ownership\r\n    function acceptOwnership() public{\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\ncontract Controlled is Ownable{\r\n\r\n    function Controlled() public {\r\n        exclude[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        if(msg.sender != owner){\r\n            require(admins[msg.sender]);\r\n        }\r\n        _;\r\n    }\r\n\r\n    mapping(address => bool) admins;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transferEnabled = false;\r\n\r\n    // frozen account\r\n    mapping(address => bool) exclude;\r\n    mapping(address => bool) locked;\r\n    mapping(address => bool) public frozenAccount;\r\n\r\n    // The nonce for avoid transfer replay attacks\r\n    mapping(address => uint256) nonces;\r\n\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n\r\n    function setAdmin(address _addr, bool isAdmin) public onlyOwner returns (bool success){\r\n        admins[_addr]=isAdmin;\r\n        return true;\r\n    }\r\n\r\n\r\n    function enableTransfer(bool _enable) public onlyOwner{\r\n        transferEnabled=_enable;\r\n    }\r\n\r\n\r\n    function setExclude(address _addr, bool isExclude) public onlyOwner returns (bool success){\r\n        exclude[_addr]=isExclude;\r\n        return true;\r\n    }\r\n\r\n    function setLock(address _addr, bool isLock) public onlyAdmin returns (bool success){\r\n        locked[_addr]=isLock;\r\n        return true;\r\n    }\r\n\r\n\r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\r\n    /*\r\n     * Get the nonce\r\n     * @param _addr\r\n     */\r\n    function getNonce(address _addr) public constant returns (uint256){\r\n        return nonces[_addr];\r\n    }\r\n\r\n    modifier transferAllowed(address _addr) {\r\n        if (!exclude[_addr]) {\r\n            assert(transferEnabled);\r\n            assert(!locked[_addr]);\r\n            assert(!frozenAccount[_addr]);\r\n        }\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract FeeControlled is Controlled{\r\n\r\n    // receive transfer fee account\r\n    address feeReceAccount = 0x0;\r\n\r\n    // transfer rate  default value,  rate/10000\r\n    uint16 defaultTransferRate = 0;\r\n     // transfer fee min & max\r\n    uint256 transferFeeMin = 0;\r\n    uint256 transferFeeMax = 10 ** 10;\r\n\r\n    // transfer rate, rate/10000\r\n    mapping(address => int16) transferRates;\r\n    // reverse transfer rate when receive from user\r\n    mapping(address => int16) transferReverseRates;\r\n\r\n\r\n    function setFeeReceAccount(address _addr) public onlyAdmin\r\n    returns (bool success){\r\n        require(_addr != address(0) && feeReceAccount != _addr);\r\n        feeReceAccount = _addr;\r\n        return true;\r\n    }\r\n\r\n    function setFeeParams(uint16 _transferRate, uint256 _transferFeeMin, uint256 _transferFeeMax) public onlyAdmin\r\n    returns (bool success){\r\n        require(_transferRate>=0  && _transferRate<10000);\r\n        require(_transferFeeMin>=0 && _transferFeeMin<transferFeeMax);\r\n        transferFeeMin = _transferFeeMin;\r\n        transferFeeMax = _transferFeeMax;\r\n        defaultTransferRate = _transferRate;\r\n        if(feeReceAccount==0x0){\r\n            feeReceAccount = owner;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function setTransferRate(address[] _addrs, int16 _transferRate) public onlyAdmin\r\n    returns (bool success){\r\n        require((_transferRate>=0  || _transferRate==-1)&& _transferRate<10000);\r\n        for(uint256 i = 0; i < _addrs.length ; i++){\r\n            address _addr = _addrs[i];\r\n            transferRates[_addr] = _transferRate;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function removeTransferRate(address[] _addrs) public onlyAdmin\r\n    returns (bool success){\r\n        for(uint256 i = 0; i < _addrs.length ; i++){\r\n            address _addr = _addrs[i];\r\n            delete transferRates[_addr];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setReverseRate(address[] _addrs, int16 _reverseRate) public onlyAdmin\r\n    returns (bool success){\r\n        require(_reverseRate>0 && _reverseRate<10000);\r\n        for(uint256 i = 0; i < _addrs.length ; i++){\r\n            address _addr = _addrs[i];\r\n            transferReverseRates[_addr] = _reverseRate;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function removeReverseRate(address[] _addrs) public onlyAdmin returns (bool success){\r\n        for(uint256 i = 0; i < _addrs.length ; i++){\r\n            address _addr = _addrs[i];\r\n            delete transferReverseRates[_addr];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getTransferRate(address _addr) public constant returns(uint16 transferRate){\r\n        if(_addr==owner || exclude[_addr] || transferRates[_addr]==-1){\r\n            return 0;\r\n        }else if(transferRates[_addr]==0){\r\n            return defaultTransferRate;\r\n        }else{\r\n            return uint16(transferRates[_addr]);\r\n        }\r\n    }\r\n\r\n    function getTransferFee(address _addr, uint256 _value) public constant returns(uint256 transferFee){\r\n        uint16 transferRate = getTransferRate(_addr);\r\n        transferFee = 0x0;\r\n        if(transferRate>0){\r\n           transferFee =  _value * transferRate / 10000;\r\n        }\r\n        if(transferFee<transferFeeMin){\r\n            transferFee = transferFeeMin;\r\n        }\r\n        if(transferFee>transferFeeMax){\r\n            transferFee = transferFeeMax;\r\n        }\r\n        return transferFee;\r\n    }\r\n\r\n    function getReverseRate(address _addr) public constant returns(uint16 reverseRate){\r\n        return uint16(transferReverseRates[_addr]);\r\n    }\r\n\r\n    function getReverseFee(address _addr, uint256 _value) public constant returns(uint256 reverseFee){\r\n        uint16 reverseRate = uint16(transferReverseRates[_addr]);\r\n        reverseFee = 0x0;\r\n        if(reverseRate>0){\r\n            reverseFee = _value * reverseRate / 10000;\r\n        }\r\n        if(reverseFee<transferFeeMin){\r\n            reverseFee = transferFeeMin;\r\n        }\r\n        if(reverseFee>transferFeeMax){\r\n            reverseFee = transferFeeMax;\r\n        }\r\n        return reverseFee;\r\n    }\r\n\r\n}\r\n\r\ncontract TokenERC20 is ERC20, Controlled {\r\n\r\n   // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    string public version = 'v1.0';\r\n\r\n    // 18 decimals is the strongly suggested default, avoid changing it\r\n    uint256 public totalSupply;\r\n\r\n    uint256 public allocateEndTime;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    \r\n\r\n    function totalSupply() public view returns(uint){\r\n        return totalSupply;\r\n    }\r\n\r\n    function decimals() public view returns(uint){\r\n        return decimals;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns(uint){\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) \r\n    public view returns (uint remaining){\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    \r\n\r\n    // Allocate tokens to the users\r\n    // @param _owners The owners list of the token\r\n    // @param _values The value list of the token\r\n    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {\r\n        require(allocateEndTime > now);\r\n        require(_owners.length == _values.length);\r\n        for(uint256 i = 0; i < _owners.length ; i++){\r\n            address to = _owners[i];\r\n            uint256 value = _values[i];\r\n            require(totalSupply + value > totalSupply && balances[to] + value > balances[to]) ;\r\n            totalSupply += value;\r\n            balances[to] += value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) transferAllowed(_from) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balances[_from] >= _value);\r\n        // Check for overflows\r\n        require(balances[_to] + _value > balances[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balances[_from] + balances[_to];\r\n        // Subtract from the sender\r\n        balances[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balances[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[_from] + balances[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowed[_from][msg.sender]);     // Check allowance\r\n        allowed[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n    returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n    public\r\n    returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowed[_from][msg.sender]);    // Check allowance\r\n        balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /*\r\n    * Proxy transfer  token. When some users of the ethereum account has no ether,\r\n    * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\r\n    * @param _from\r\n    * @param _to\r\n    * @param _value\r\n    * @param feeProxy\r\n    * @param _v\r\n    * @param _r\r\n    * @param _s\r\n    */\r\n    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeProxy,\r\n        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\r\n        require(_value + _feeProxy >= _value);\r\n        require(balances[_from] >=_value  + _feeProxy);\r\n        uint256 nonce = nonces[_from];\r\n        bytes32 h = keccak256(_from,_to,_value,_feeProxy,nonce);\r\n        require(_from == ecrecover(h,_v,_r,_s));\r\n        require(balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] + _feeProxy > balances[msg.sender]);\r\n        balances[_from] -= (_value  + _feeProxy);\r\n        balances[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        if(_feeProxy>0){\r\n            balances[msg.sender] += _feeProxy;\r\n            Transfer(_from, msg.sender, _feeProxy);\r\n        }\r\n        nonces[_from] = nonce + 1;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract StableToken is TokenERC20, FeeControlled {\r\n\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        return _transferWithRate(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        return _transferWithRate(_from, _to, _value);\r\n    }\r\n\r\n     function _transferWithRate(address _from, address _to, uint256 _value)  transferAllowed(_from) internal returns (bool success) {\r\n        // check transfer rate and transfer fee to owner\r\n        require(balances[_from] >= _value);\r\n        uint256 transferFee = getTransferFee(_from, _value);\r\n        require(balances[_from] >= _value + transferFee);\r\n        if(msg.sender!=_from){\r\n            require(allowed[_from][msg.sender] >= _value + transferFee);\r\n        }\r\n        require(balances[_to] + _value > balances[_to]);\r\n        if(transferFee>0){\r\n            require(balances[feeReceAccount] + transferFee > balances[feeReceAccount]);\r\n        }\r\n\r\n        balances[_from] -= (_value + transferFee);\r\n        if(msg.sender!=_from){\r\n            allowed[_from][msg.sender] -= (_value + transferFee);\r\n        }\r\n\r\n        balances[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n\r\n        if(transferFee>0){\r\n            balances[feeReceAccount] += transferFee;\r\n            Transfer(_from, feeReceAccount, transferFee);\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n     /*\r\n     * Proxy transfer token with reverse transfer fee. When some users of the ethereum account has no ether,\r\n     * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\r\n     * @param _from\r\n     * @param _to, must be reverse address\r\n     * @param _value\r\n     * @param fee\r\n     * @param _v\r\n     * @param _r\r\n     * @param _s\r\n     */\r\n    function transferReverseProxy(address _from, address _to, uint256 _value,uint256 _feeProxy,\r\n        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\r\n        require(_feeProxy>=0);\r\n        require(balances[_from] >= _value + _feeProxy);\r\n        require(getReverseRate(_to)>0);\r\n        uint256 nonce = nonces[_from];\r\n        bytes32 h = keccak256(_from,_to,_value, _feeProxy, nonce);\r\n        require(_from == ecrecover(h,_v,_r,_s));\r\n\r\n        uint256 transferReverseFee = getReverseFee(_to, _value);\r\n        require(transferReverseFee>0);\r\n        require(balances[_to] + _value > balances[_to]);\r\n        require(balances[feeReceAccount] + transferReverseFee > balances[feeReceAccount]);\r\n        require(balances[msg.sender] + _feeProxy >= balances[msg.sender]);\r\n\r\n        balances[_from] -= (_value + _feeProxy);\r\n        balances[_to] += (_value - transferReverseFee);\r\n        balances[feeReceAccount] += transferReverseFee;\r\n        Transfer(_from, _to, _value);\r\n        Transfer(_to, feeReceAccount, transferReverseFee);\r\n        if(_feeProxy>0){\r\n            balances[msg.sender] += _feeProxy;\r\n            Transfer(_from, msg.sender, _feeProxy);\r\n        }\r\n\r\n        nonces[_from] = nonce + 1;\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * Proxy transfer  token. When some users of the ethereum account has no ether,\r\n    * he or she can authorize the agent for broadcast transactions, and agents may charge agency fees\r\n    * @param _from\r\n    * @param _to\r\n    * @param _value\r\n    * @param feeProxy\r\n    * @param _v\r\n    * @param _r\r\n    * @param _s\r\n    */\r\n    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeProxy,\r\n        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\r\n        uint256 transferFee = getTransferFee(_from, _value);\r\n        require(_value + transferFee + _feeProxy >= _value);\r\n        require(balances[_from] >=_value + transferFee + _feeProxy);\r\n        uint256 nonce = nonces[_from];\r\n        bytes32 h = keccak256(_from,_to,_value,_feeProxy,nonce);\r\n        require(_from == ecrecover(h,_v,_r,_s));\r\n        require(balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] + _feeProxy > balances[msg.sender]);\r\n        balances[_from] -= (_value + transferFee + _feeProxy);\r\n        balances[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        if(_feeProxy>0){\r\n            balances[msg.sender] += _feeProxy;\r\n            Transfer(_from, msg.sender, _feeProxy);\r\n        }\r\n        if(transferFee>0){\r\n            balances[feeReceAccount] += transferFee;\r\n            Transfer(_from, feeReceAccount, transferFee);\r\n        }\r\n        nonces[_from] = nonce + 1;\r\n        return true;\r\n    }\r\n\r\n   /*\r\n    * Wrapper function:  transferProxy + transferReverseProxy\r\n    * address[] _addrs => [_from, _origin, _to]\r\n    * uint256[] _values => [_value, _feeProxy]\r\n    * token flows\r\n    * _from->_origin: _value\r\n    * _from->sender: _feeProxy\r\n    * _origin->_to: _value\r\n    * _to->feeAccount: transferFee\r\n    * _from sign:\r\n    * (_v[0],_r[0],_s[0]) = sign(_from, _origin, _value, _feeProxy, nonces[_from])\r\n    * _origin sign:\r\n    * (_v[1],_r[1],_s[1]) = sign(_origin, _to, _value)\r\n    */\r\n    function transferReverseProxyThirdParty(address[] _addrs, uint256[] _values,\r\n        uint8[] _v, bytes32[] _r, bytes32[] _s)\r\n        public transferAllowed(_addrs[0]) returns (bool){\r\n        address _from = _addrs[0];\r\n        address _origin = _addrs[1];\r\n        address _to = _addrs[2];\r\n        uint256 _value = _values[0];\r\n        uint256 _feeProxy = _values[1];\r\n\r\n        require(_feeProxy>=0);\r\n        require(balances[_from] >= (_value + _feeProxy));\r\n        require(getReverseRate(_to)>0);\r\n        uint256 transferReverseFee = getReverseFee(_to, _value);\r\n        require(transferReverseFee>0);\r\n\r\n        // check sign _from => _origin\r\n        uint256 nonce = nonces[_from];\r\n        bytes32 h = keccak256(_from, _origin, _value, _feeProxy, nonce);\r\n        require(_from == ecrecover(h,_v[0],_r[0],_s[0]));\r\n         // check sign _origin => _to\r\n        bytes32 h1 = keccak256(_origin, _to, _value);\r\n        require(_origin == ecrecover(h1,_v[1],_r[1],_s[1]));\r\n\r\n\r\n        require(balances[_to] + _value > balances[_to]);\r\n        require(balances[feeReceAccount] + transferReverseFee > balances[feeReceAccount]);\r\n        require(balances[msg.sender] + _feeProxy >= balances[msg.sender]);\r\n\r\n        balances[_from] -= _value + _feeProxy;\r\n        balances[_to] += (_value - transferReverseFee);\r\n        balances[feeReceAccount] += transferReverseFee;\r\n       \r\n        Transfer(_from, _origin, _value);\r\n        Transfer(_origin, _to, _value);\r\n        Transfer(_to, feeReceAccount, transferReverseFee);\r\n        \r\n        if(_feeProxy>0){\r\n            balances[msg.sender] += _feeProxy;\r\n            Transfer(_from, msg.sender, _feeProxy);\r\n        }\r\n       \r\n\r\n        nonces[_from] = nonce + 1;\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Proxy approve that some one can authorize the agent for broadcast transaction\r\n     * which call approve method, and agents may charge agency fees\r\n     * @param _from The address which should tranfer TOKEN to others\r\n     * @param _spender The spender who allowed by _from\r\n     * @param _value The value that should be tranfered.\r\n     * @param _v\r\n     * @param _r\r\n     * @param _s\r\n     */\r\n    function approveProxy(address _from, address _spender, uint256 _value,\r\n        uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {\r\n        uint256 nonce = nonces[_from];\r\n        bytes32 hash = keccak256(_from,_spender,_value,nonce);\r\n        require(_from == ecrecover(hash,_v,_r,_s));\r\n        allowed[_from][_spender] = _value;\r\n        Approval(_from, _spender, _value);\r\n        nonces[_from] = nonce + 1;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract HanYinToken is StableToken{\r\n    \r\n    function HanYinToken() public {\r\n        name = \"HanYin stable Token\";\r\n        decimals = 6;\r\n        symbol = \"HYT\";\r\n        version = 'v1.0';\r\n        \r\n        allocateEndTime = now + 1 days;\r\n\r\n        setFeeParams(100, 0, 1000000000000);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferRate\",\"type\":\"uint16\"},{\"name\":\"_transferFeeMin\",\"type\":\"uint256\"},{\"name\":\"_transferFeeMax\",\"type\":\"uint256\"}],\"name\":\"setFeeParams\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"removeTransferRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getReverseFee\",\"outputs\":[{\"name\":\"reverseFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTransferRate\",\"outputs\":[{\"name\":\"transferRate\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_transferRate\",\"type\":\"int16\"}],\"name\":\"setTransferRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_feeProxy\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"transferReverseProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_reverseRate\",\"type\":\"int16\"}],\"name\":\"setReverseRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"approveProxy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeReceAccount\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"isExclude\",\"type\":\"bool\"}],\"name\":\"setExclude\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getReverseRate\",\"outputs\":[{\"name\":\"reverseRate\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"allocateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"isLock\",\"type\":\"bool\"}],\"name\":\"setLock\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"removeReverseRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"transferReverseProxyThirdParty\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocateEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_feeProxy\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"transferProxy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"enableTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getTransferFee\",\"outputs\":[{\"name\":\"transferFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"HanYinToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://64f3f396eceea6b0ab3d155d8f27a73772e25c2b48bf3aca4893da002be9af25"}]}