{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/flavours/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/commons/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/flavours/Lockable.sol\r\n\r\n/**\r\n * @title Lockable\r\n * @dev Base contract which allows children to\r\n *      implement main operations locking mechanism.\r\n */\r\ncontract Lockable is Ownable {\r\n  event Lock();\r\n  event Unlock();\r\n\r\n  bool public locked = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable\r\n  *       only when the contract is not locked.\r\n   */\r\n  modifier whenNotLocked() {\r\n    require(!locked);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable\r\n   *      only when the contract is locked.\r\n   */\r\n  modifier whenLocked() {\r\n    require(locked);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to locke, triggers locked state\r\n   */\r\n  function lock() onlyOwner whenNotLocked public {\r\n    locked = true;\r\n    Lock();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner\r\n   *      to unlock, returns to unlocked state\r\n   */\r\n  function unlock() onlyOwner whenLocked public {\r\n    locked = false;\r\n    Unlock();\r\n  }\r\n}\r\n\r\n// File: contracts/base/BaseFixedERC20Token.sol\r\n\r\ncontract BaseFixedERC20Token is Lockable {\r\n  using SafeMath for uint;\r\n\r\n  /// @dev ERC20 Total supply\r\n  uint public totalSupply;\r\n\r\n  mapping(address => uint) balances;\r\n\r\n  mapping(address => mapping (address => uint)) private allowed;\r\n\r\n  /// @dev Fired if Token transfered accourding to ERC20\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  /// @dev Fired if Token withdraw is approved accourding to ERC20\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address.\r\n   * @param owner_ The address to query the the balance of.\r\n   * @return An uint representing the amount owned by the passed address.\r\n   */\r\n  function balanceOf(address owner_) public view returns (uint balance) {\r\n    return balances[owner_];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer token for a specified address\r\n   * @param to_ The address to transfer to.\r\n   * @param value_ The amount to be transferred.\r\n   */\r\n  function transfer(address to_, uint value_) whenNotLocked public returns (bool) {\r\n    require(to_ != address(0) && value_ <= balances[msg.sender]);\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(value_);\r\n    balances[to_] = balances[to_].add(value_);\r\n    Transfer(msg.sender, to_, value_);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param from_ address The address which you want to send tokens from\r\n   * @param to_ address The address which you want to transfer to\r\n   * @param value_ uint the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address from_, address to_, uint value_) whenNotLocked public returns (bool) {\r\n    require(to_ != address(0) && value_ <= balances[from_] && value_ <= allowed[from_][msg.sender]);\r\n    balances[from_] = balances[from_].sub(value_);\r\n    balances[to_] = balances[to_].add(value_);\r\n    allowed[from_][msg.sender] = allowed[from_][msg.sender].sub(value_);\r\n    Transfer(from_, to_, value_);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering.\r\n   *\r\n   * To change the approve amount you first have to reduce the addresses\r\n   * allowance to zero by calling `approve(spender_, 0)` if it is not\r\n   * already 0 to mitigate the race condition described in:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * @param spender_ The address which will spend the funds.\r\n   * @param value_ The amount of tokens to be spent.\r\n   */\r\n  function approve(address spender_, uint value_) whenNotLocked public returns (bool) {\r\n    if (value_ != 0 && allowed[msg.sender][spender_] != 0) {\r\n      revert();\r\n    }\r\n    allowed[msg.sender][spender_] = value_;\r\n    Approval(msg.sender, spender_, value_);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner_ address The address which owns the funds.\r\n   * @param spender_ address The address which will spend the funds.\r\n   * @return A uint specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address owner_, address spender_) view public returns (uint) {\r\n    return allowed[owner_][spender_];\r\n  }\r\n}\r\n\r\n// File: contracts/base/BaseICOToken.sol\r\n\r\n/**\r\n * @dev Not mintable, ERC20 compilant token, distributed by ICO/Pre-ICO.\r\n */\r\ncontract BaseICOToken is BaseFixedERC20Token {\r\n\r\n  /// @dev Available supply of tokens\r\n  uint public availableSupply;\r\n\r\n  /// @dev ICO/Pre-ICO smart contract allowed to distribute public funds for this\r\n  address public ico;\r\n\r\n  /// @dev Fired if investment for `amount` of tokens performed by `to` address\r\n  event ICOTokensInvested(address indexed to, uint amount);\r\n\r\n  /// @dev ICO contract changed for this token\r\n  event ICOChanged(address indexed icoContract);\r\n\r\n  /**\r\n   * @dev Not mintable, ERC20 compilant token, distributed by ICO/Pre-ICO.\r\n   * @param totalSupply_ Total tokens supply.\r\n   */\r\n  function BaseICOToken(uint totalSupply_) public {\r\n    locked = true; // Audit: I'd call lock() for better readability\r\n    totalSupply = totalSupply_;\r\n    availableSupply = totalSupply_;\r\n  }\r\n\r\n  /**\r\n   * @dev Set address of ICO smart-contract which controls token\r\n   * initial token distribution.\r\n   * @param ico_ ICO contract address.\r\n   */\r\n  function changeICO(address ico_) onlyOwner public {\r\n    ico = ico_;\r\n    ICOChanged(ico);\r\n  }\r\n\r\n  // Audit: Keep the sender logic separated from the input validation\r\n  // Audit Create modifier onlyICOAddress -  and use it in the icoInvestment method\r\n  function isValidICOInvestment(address to_, uint amount_) internal view returns(bool) {\r\n    return msg.sender == ico && to_ != address(0) && amount_ <= availableSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev Assign `amount_` of tokens to investor identified by `to_` address.\r\n   * @param to_ Investor address.\r\n   * @param amount_ Number of tokens distributed.\r\n   */\r\n  function icoInvestment(address to_, uint amount_) public returns (uint) {\r\n    require(isValidICOInvestment(to_, amount_));\r\n    availableSupply -= amount_; // Audit: Please keep using safe math here too \r\n    balances[to_] = balances[to_].add(amount_);\r\n    ICOTokensInvested(to_, amount_);\r\n    return amount_;\r\n  }\r\n}\r\n\r\n// File: contracts/base/BaseICO.sol\r\n\r\n/**\r\n * @dev Base abstract smart contract for any ICO\r\n */\r\ncontract BaseICO is Ownable {\r\n\r\n  /// @dev ICO state\r\n  enum State {\r\n    // ICO is not active and not started\r\n    Inactive,\r\n    // ICO is active, tokens can be distributed among investors.\r\n    // ICO parameters (end date, hard/low caps) cannot be changed.\r\n    Active,\r\n    // ICO is suspended, tokens cannot be distributed among investors.\r\n    // ICO can be resumed to `Active state`.\r\n    // ICO parameters (end date, hard/low caps) may changed.\r\n    Suspended,\r\n    // ICO is termnated by owner, ICO cannot be resumed.\r\n    Terminated,\r\n    // ICO goals are not reached,\r\n    // ICO terminated and cannot be resumed.\r\n    NotCompleted,\r\n    // ICO completed, ICO goals reached successfully,\r\n    // ICO terminated and cannot be resumed.\r\n    Completed\r\n  }\r\n\r\n  /// @dev Token which controlled by this ICO\r\n  BaseICOToken public token;\r\n\r\n  /// @dev Current ICO state.\r\n  State public state;\r\n\r\n  /// @dev ICO start date seconds since epoch.\r\n  uint public startAt;\r\n\r\n  /// @dev ICO end date seconds since epoch.\r\n  uint public endAt;\r\n\r\n  /// @dev Minimal amount of investments in wei needed for successfull ICO\r\n  uint public lowCapWei; // Audit: I'd name this softCapWei\r\n\r\n  /// @dev Maximal amount of investments in wei for this ICO.\r\n  /// If reached ICO will be in `Completed` state.\r\n  uint public hardCapWei;\r\n\r\n  /// @dev Minimal amount of investments in wei per investor.\r\n  uint public lowCapTxWei; // Audit: I'd name this minimalContributionWei\r\n\r\n  /// @dev Maximal amount of investments in wei per investor.\r\n  uint public hardCapTxWei; // Audit: I'd name this maximumContributionWei\r\n\r\n  /// @dev Number of investments collected by this ICO\r\n  uint public collectedWei;\r\n\r\n  /// @dev Team wallet used to collect funds\r\n  address public teamWallet;\r\n\r\n  /// @dev True if whitelist enabled\r\n  bool public whitelistEnabled = true;\r\n\r\n  /// @dev ICO whitelist\r\n  mapping (address => bool) public whitelist;\r\n\r\n  // ICO state transition events\r\n  event ICOStarted(uint indexed endAt, uint lowCapWei, uint hardCapWei, uint lowCapTxWei, uint hardCapTxWei);\r\n  event ICOResumed(uint indexed endAt, uint lowCapWei, uint hardCapWei, uint lowCapTxWei, uint hardCapTxWei);\r\n  event ICOSuspended();\r\n  event ICOTerminated();\r\n  event ICONotCompleted();\r\n  event ICOCompleted(uint collectedWei);\r\n  event ICOInvestment(address indexed from, uint investedWei, uint tokens, uint8 bonusPct);\r\n  event ICOWhitelisted(address indexed addr);\r\n  event ICOBlacklisted(address indexed addr);\r\n\r\n  modifier isSuspended() {\r\n    require(state == State.Suspended);\r\n    _;\r\n  }\r\n\r\n  modifier isActive() {\r\n    require(state == State.Active);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Add address to ICO whitelist\r\n   * @param address_ Investor address\r\n   */\r\n  function whitelist(address address_) external onlyOwner {\r\n    whitelist[address_] = true;\r\n    ICOWhitelisted(address_);\r\n  }\r\n\r\n  /**\r\n   * Remove address from ICO whitelist\r\n   * @param address_ Investor address\r\n   */\r\n  function blacklist(address address_) external onlyOwner {\r\n    delete whitelist[address_];\r\n    ICOBlacklisted(address_);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if given address in ICO whitelist\r\n   */\r\n  function whitelisted(address address_) public view returns (bool) {\r\n    if (whitelistEnabled) {\r\n      return whitelist[address_];\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Enable whitelisting\r\n   */\r\n  function enableWhitelist() public onlyOwner {\r\n    whitelistEnabled = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Disable whitelisting\r\n   */\r\n  function disableWhitelist() public onlyOwner {\r\n    whitelistEnabled = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Trigger start of ICO.\r\n   * @param endAt_ ICO end date, seconds since epoch.\r\n   */\r\n  function start(uint endAt_) onlyOwner public {\r\n    require(endAt_ > block.timestamp && state == State.Inactive);\r\n    endAt = endAt_;\r\n    startAt = block.timestamp;\r\n    state = State.Active;\r\n    ICOStarted(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);\r\n  }\r\n\r\n  /**\r\n   * @dev Suspend this ICO.\r\n   * ICO can be activated later by calling `resume()` function.\r\n   * In suspend state, ICO owner can change basic ICO paraneter using `tune()` function,\r\n   * tokens cannot be distributed among investors.\r\n   */\r\n  function suspend() onlyOwner isActive public {\r\n    state = State.Suspended;\r\n    ICOSuspended();\r\n  }\r\n\r\n  /**\r\n   * @dev Terminate the ICO.\r\n   * ICO goals are not reached, ICO terminated and cannot be resumed.\r\n   */\r\n  function terminate() onlyOwner public {\r\n    require(state != State.Terminated &&\r\n            state != State.NotCompleted &&\r\n            state != State.Completed);\r\n    state = State.Terminated;\r\n    ICOTerminated();\r\n  }\r\n\r\n  /**\r\n   * @dev Change basic ICO parameters. Can be done only during `Suspended` state.\r\n   * Any provided parameter is used only if it is not zero.\r\n   * @param endAt_ ICO end date seconds since epoch. Used if it is not zero.\r\n   * @param lowCapWei_ ICO low capacity. Used if it is not zero.\r\n   * @param hardCapWei_ ICO hard capacity. Used if it is not zero.\r\n   * @param lowCapTxWei_ Min limit for ICO per transaction\r\n   * @param hardCapTxWei_ Hard limit for ICO per transaction\r\n   */\r\n  function tune(uint endAt_,\r\n                uint lowCapWei_,\r\n                uint hardCapWei_,\r\n                uint lowCapTxWei_,\r\n                uint hardCapTxWei_) onlyOwner isSuspended public {\r\n    if (endAt_ > block.timestamp) {\r\n      endAt = endAt_;\r\n    }\r\n    if (lowCapWei_ > 0) {\r\n      lowCapWei = lowCapWei_;\r\n    }\r\n    if (hardCapWei_ > 0) {\r\n      hardCapWei = hardCapWei_;\r\n    }\r\n    if (lowCapTxWei_ > 0) {\r\n      lowCapTxWei = lowCapTxWei_;\r\n    }\r\n    if (hardCapTxWei_ > 0) {\r\n      hardCapTxWei = hardCapTxWei_;\r\n    }\r\n    require(lowCapWei <= hardCapWei && lowCapTxWei <= hardCapTxWei);\r\n    touch();\r\n  }\r\n\r\n  /**\r\n   * @dev Resume a previously suspended ICO.\r\n   */\r\n  function resume() onlyOwner isSuspended public {\r\n    state = State.Active;\r\n    ICOResumed(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);\r\n    touch();\r\n  }\r\n\r\n  /**\r\n   * @dev Send ether to the fund collection wallet\r\n   */\r\n   // Audit: I could not find logic for refund on softCap not reached\r\n   // Audit: Something like this might make sense for this case:\r\n   // https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/crowdsale/RefundVault.sol\r\n   // Here is how it can be used:\r\n   // https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/crowdsale/RefundableCrowdsale.sol\r\n  function forwardFunds() internal {\r\n    teamWallet.transfer(msg.value);\r\n  }\r\n\r\n  /**\r\n   * @dev Recalculate ICO state based on current block time.\r\n   * Should be called periodically by ICO owner.\r\n   */\r\n  function touch() public;\r\n\r\n  /**\r\n   * @dev Buy tokens\r\n   */\r\n  function buyTokens() public payable;\r\n}\r\n\r\n// File: contracts/OTCPreICO.sol\r\n\r\n// Audit: If this contract is used for the full ICO not only the pre-sale it might make sense to rename it to OTCCrowdsale or something similar\r\n\r\n \r\n/**\r\n * @title OTCrit Pre-ICO smart contract.\r\n */\r\ncontract OTCPreICO is BaseICO {\r\n  using SafeMath for uint;\r\n\r\n  /// @dev 18 decimals for token\r\n  uint internal constant ONE_TOKEN = 1e18;\r\n\r\n  /// @dev 1e18 WEI == 1ETH == 5000 tokens\r\n  uint public constant ETH_TOKEN_EXCHANGE_RATIO = 5000;\r\n\r\n  // Audit: It might be better for these setters to be in a constructur in the BaseICO\r\n  function OTCPreICO(address icoToken_,\r\n                     address teamWallet_,\r\n                     uint lowCapWei_,\r\n                     uint hardCapWei_,\r\n                     uint lowCapTxWei_,\r\n                     uint hardCapTxWei_) public {\r\n    require(icoToken_ != address(0) && teamWallet_ != address(0));\r\n    token = BaseICOToken(icoToken_); \r\n    teamWallet = teamWallet_;\r\n    state = State.Inactive;\r\n    lowCapWei = lowCapWei_;\r\n    hardCapWei = hardCapWei_;\r\n    lowCapTxWei = lowCapTxWei_;\r\n    hardCapTxWei = hardCapTxWei_;\r\n  }\r\n\r\n  /**\r\n   * @dev Recalculate ICO state based on current block time.\r\n   * Should be called periodically by ICO owner.\r\n   */\r\n  function touch() public {\r\n    if (state != State.Active && state != State.Suspended) {\r\n      return;\r\n    }\r\n    if (collectedWei >= hardCapWei) {\r\n      state = State.Completed;\r\n      endAt = block.timestamp;\r\n      ICOCompleted(collectedWei);\r\n    } else if (block.timestamp >= endAt) {\r\n      if (collectedWei < lowCapWei) {\r\n        state = State.NotCompleted;\r\n        ICONotCompleted();\r\n      } else {\r\n        state = State.Completed;\r\n        ICOCompleted(collectedWei);\r\n      }\r\n    }\r\n  }\r\n\r\n  function buyTokens() public payable {\r\n    require(state == State.Active &&\r\n            block.timestamp <= endAt &&\r\n            msg.value >= lowCapTxWei &&\r\n            msg.value <= hardCapTxWei &&\r\n            collectedWei + msg.value <= hardCapWei &&\r\n            whitelisted(msg.sender) );\r\n    uint amountWei = msg.value;\r\n    uint8 bonus = (block.timestamp - startAt >= 1 weeks) ? 10 : 20;\r\n    uint iwei = bonus > 0 ? amountWei.mul(100 + bonus).div(100) : amountWei;\r\n    uint itokens = iwei * ETH_TOKEN_EXCHANGE_RATIO;\r\n    token.icoInvestment(msg.sender, itokens); // Transfer tokens to investor\r\n    collectedWei = collectedWei.add(amountWei);\r\n    ICOInvestment(msg.sender, amountWei, itokens, bonus);\r\n    forwardFunds();\r\n    touch();\r\n  }\r\n\r\n  /**\r\n   * Accept direct payments\r\n   */\r\n  function() external payable {\r\n    buyTokens();\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_TOKEN_EXCHANGE_RATIO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapTxWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowCapTxWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endAt_\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"touch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endAt_\",\"type\":\"uint256\"},{\"name\":\"lowCapWei_\",\"type\":\"uint256\"},{\"name\":\"hardCapWei_\",\"type\":\"uint256\"},{\"name\":\"lowCapTxWei_\",\"type\":\"uint256\"},{\"name\":\"hardCapTxWei_\",\"type\":\"uint256\"}],\"name\":\"tune\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"suspend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowCapWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"icoToken_\",\"type\":\"address\"},{\"name\":\"teamWallet_\",\"type\":\"address\"},{\"name\":\"lowCapWei_\",\"type\":\"uint256\"},{\"name\":\"hardCapWei_\",\"type\":\"uint256\"},{\"name\":\"lowCapTxWei_\",\"type\":\"uint256\"},{\"name\":\"hardCapTxWei_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"endAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lowCapWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lowCapTxWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapTxWei\",\"type\":\"uint256\"}],\"name\":\"ICOStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"endAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lowCapWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lowCapTxWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCapTxWei\",\"type\":\"uint256\"}],\"name\":\"ICOResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICOSuspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICOTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ICONotCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"collectedWei\",\"type\":\"uint256\"}],\"name\":\"ICOCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"investedWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusPct\",\"type\":\"uint8\"}],\"name\":\"ICOInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ICOWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ICOBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OTCPreICO","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"0000000000000000000000008e81e62f7f4400e0e0b8c783f1b5d1d5c10e71880000000000000000000000003fbd2cf3de0f52bbe9786662c3791fbb468654e200000000000000000000000000000000000000000000000ad78ebc5ac620000000000000000000000000000000000000000000000000005150ae84a8cdf0000000000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000000000000000000000000005150ae84a8cdf00000","Library":"","SwarmSource":"bzzr://5d43999c80bfb54a9411fae286950beda520b8229ecd7f47efdd520ff17388f5"}]}