{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\ncontract Owned\r\n{\r\n    address public owner;\r\n\r\n    modifier onlyOwner\r\n\t{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner()\r\n\t{\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Agricoin is Owned\r\n{\r\n    // Dividends payout struct.\r\n    struct DividendPayout\r\n    {\r\n        uint amount;            // Value of dividend payout.\r\n        uint momentTotalSupply; // Total supply in payout moment,\r\n    }\r\n\r\n    // Redemption payout struct.\r\n    struct RedemptionPayout\r\n    {\r\n        uint amount;            // Value of redemption payout.\r\n        uint momentTotalSupply; // Total supply in payout moment.\r\n        uint price;             // Price of Agricoin in weis.\r\n    }\r\n\r\n    // Balance struct with dividends and redemptions record.\r\n    struct Balance\r\n    {\r\n        uint icoBalance;\r\n        uint balance;                       // Agricoin balance.\r\n        uint posibleDividends;              // Dividend number, which user can get.\r\n        uint lastDividensPayoutNumber;      // Last dividend payout index, which user has gotten.\r\n        uint posibleRedemption;             // Redemption value in weis, which user can use.\r\n        uint lastRedemptionPayoutNumber;    // Last redemption payout index, which user has used.\r\n    }\r\n\r\n    // Can act only one from payers.\r\n    modifier onlyPayer()\r\n    {\r\n        require(payers[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n    // Can act only after token activation.\r\n    modifier onlyActivated()\r\n    {\r\n        require(isActive);\r\n        _;\r\n    }\r\n\r\n    // Transfer event.\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);    \r\n\r\n    // Approve event.\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    // Activate event.\r\n    event Activate(bool icoSuccessful);\r\n\r\n    // DividendPayout dividends event.\r\n    event PayoutDividends(uint etherAmount, uint indexed id);\r\n\r\n    // DividendPayout redemption event.\r\n    event PayoutRedemption(uint etherAmount, uint indexed id, uint price);\r\n\r\n    // Get unpaid event.\r\n    event GetUnpaid(uint etherAmount);\r\n\r\n    // Get dividends.\r\n    event GetDividends(address indexed investor, uint etherAmount);\r\n\r\n    // Constructor.\r\n    function Agricoin(uint payout_period_start, uint payout_period_end, address _payer) public\r\n    {\r\n        owner = msg.sender;// Save the owner.\r\n\r\n        // Set payout period.\r\n        payoutPeriodStart = payout_period_start;\r\n        payoutPeriodEnd = payout_period_end;\r\n\r\n        payers[_payer] = true;\r\n    }\r\n\r\n    // Activate token.\r\n\tfunction activate(bool icoSuccessful) onlyOwner() external returns (bool)\r\n\t{\r\n\t\trequire(!isActive);// Check once activation.\r\n\r\n        startDate = now;// Save activation date.\r\n\t\tisActive = true;// Make token active.\r\n\t\towner = 0x00;// Set owner to null.\r\n\t\t\r\n        if (icoSuccessful)\r\n        {\r\n            isSuccessfulIco = true;\r\n            totalSupply += totalSupplyOnIco;\r\n            Activate(true);// Call activation event.\r\n        }\r\n        else\r\n        {\r\n            Activate(false);// Call activation event.\r\n        }\r\n\r\n        return true;\r\n\t}\r\n\r\n    // Add new payer by payer.\r\n    function addPayer(address payer) onlyPayer() external\r\n    {\r\n        payers[payer] = true;\r\n    }\r\n\r\n    // Get balance of address.\r\n\tfunction balanceOf(address owner) public view returns (uint)\r\n\t{\r\n\t\treturn balances[owner].balance;\r\n\t}\r\n\r\n    // Get posible dividends value.\r\n    function posibleDividendsOf(address owner) public view returns (uint)\r\n    {\r\n        return balances[owner].posibleDividends;\r\n    }\r\n\r\n    // Get posible redemption value.\r\n    function posibleRedemptionOf(address owner) public view returns (uint)\r\n    {\r\n        return balances[owner].posibleRedemption;\r\n    }\r\n\r\n    // Transfer _value etheres to _to.\r\n    function transfer(address _to, uint _value) onlyActivated() external returns (bool)\r\n    {\r\n        require(balanceOf(msg.sender) >= _value);\r\n\r\n        recalculate(msg.sender);// Recalculate user's struct.\r\n        \r\n        if (_to != 0x00)// For normal transfer.\r\n        {\r\n            recalculate(_to);// Recalculate recipient's struct.\r\n\r\n            // Change balances.\r\n            balances[msg.sender].balance -= _value;\r\n            balances[_to].balance += _value;\r\n\r\n            Transfer(msg.sender, _to, _value);// Call transfer event.\r\n        }\r\n        else// For redemption transfer.\r\n        {\r\n            require(payoutPeriodStart <= now && now >= payoutPeriodEnd);// Check redemption period.\r\n            \r\n            uint amount = _value * redemptionPayouts[amountOfRedemptionPayouts].price;// Calculate amount of weis in redemption.\r\n\r\n            require(amount <= balances[msg.sender].posibleRedemption);// Check redemption limits.\r\n\r\n            // Change user's struct.\r\n            balances[msg.sender].posibleRedemption -= amount;\r\n            balances[msg.sender].balance -= _value;\r\n\r\n            totalSupply -= _value;// Decrease total supply.\r\n\r\n            msg.sender.transfer(amount);// Transfer redemption to user.\r\n\r\n            Transfer(msg.sender, _to, _value);// Call transfer event.\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Transfer from _from to _to _value tokens.\r\n    function transferFrom(address _from, address _to, uint _value) onlyActivated() external returns (bool)\r\n    {\r\n        // Check transfer posibility.\r\n        require(balances[_from].balance >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(_to != 0x00);\r\n\r\n        // Recalculate structs.\r\n        recalculate(_from);\r\n        recalculate(_to);\r\n\r\n        // Change balances.\r\n        balances[_from].balance -= _value;\r\n        balances[_to].balance += _value;\r\n        \r\n        Transfer(_from, _to, _value);// Call tranfer event.\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Approve for transfers.\r\n    function approve(address _spender, uint _value) onlyActivated() public returns (bool)\r\n    {\r\n        // Recalculate structs.\r\n        recalculate(msg.sender);\r\n        recalculate(_spender);\r\n\r\n        allowed[msg.sender][_spender] = _value;// Set allowed.\r\n        \r\n        Approval(msg.sender, _spender, _value);// Call approval event.\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Get allowance.\r\n    function allowance(address _owner, address _spender) onlyActivated() external view returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Mint _value tokens to _to address.\r\n    function mint(address _to, uint _value, bool icoMinting) onlyOwner() external returns (bool)\r\n    {\r\n        require(!isActive);// Check no activation.\r\n\r\n        if (icoMinting)\r\n        {\r\n            balances[_to].icoBalance += _value;\r\n            totalSupplyOnIco += _value;\r\n        }\r\n        else\r\n        {\r\n            balances[_to].balance += _value;// Increase user's balance.\r\n            totalSupply += _value;// Increase total supply.\r\n\r\n            Transfer(0x00, _to, _value);// Call transfer event.\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Pay dividends.\r\n    function payDividends() onlyPayer() onlyActivated() external payable returns (bool)\r\n    {\r\n        require(now >= payoutPeriodStart && now <= payoutPeriodEnd);// Check payout period.\r\n\r\n        dividendPayouts[amountOfDividendsPayouts].amount = msg.value;// Set payout amount in weis.\r\n        dividendPayouts[amountOfDividendsPayouts].momentTotalSupply = totalSupply;// Save total supply on that moment.\r\n        \r\n        PayoutDividends(msg.value, amountOfDividendsPayouts);// Call dividend payout event.\r\n\r\n        amountOfDividendsPayouts++;// Increment dividend payouts amount.\r\n\r\n        return true;\r\n    }\r\n\r\n    // Pay redemption.\r\n    function payRedemption(uint price) onlyPayer() onlyActivated() external payable returns (bool)\r\n    {\r\n        require(now >= payoutPeriodStart && now <= payoutPeriodEnd);// Check payout period.\r\n\r\n        redemptionPayouts[amountOfRedemptionPayouts].amount = msg.value;// Set payout amount in weis.\r\n        redemptionPayouts[amountOfRedemptionPayouts].momentTotalSupply = totalSupply;// Save total supply on that moment.\r\n        redemptionPayouts[amountOfRedemptionPayouts].price = price;// Set price of Agricoin in weis at this redemption moment.\r\n\r\n        PayoutRedemption(msg.value, amountOfRedemptionPayouts, price);// Call redemption payout event.\r\n\r\n        amountOfRedemptionPayouts++;// Increment redemption payouts amount.\r\n\r\n        return true;\r\n    }\r\n\r\n    // Get back unpaid dividends and redemption.\r\n    function getUnpaid() onlyPayer() onlyActivated() external returns (bool)\r\n    {\r\n        require(now >= payoutPeriodEnd);// Check end payout period.\r\n\r\n        GetUnpaid(this.balance);// Call getting unpaid ether event.\r\n\r\n        msg.sender.transfer(this.balance);// Transfer all ethers back to payer.\r\n\r\n        return true;\r\n    }\r\n\r\n    // Recalculates dividends and redumptions.\r\n    function recalculate(address user) onlyActivated() public returns (bool)\r\n    {\r\n        if (isSuccessfulIco)\r\n        {\r\n            if (balances[user].icoBalance != 0)\r\n            {\r\n                balances[user].balance += balances[user].icoBalance;\r\n                Transfer(0x00, user, balances[user].icoBalance);\r\n                balances[user].icoBalance = 0;\r\n            }\r\n        }\r\n\r\n        // Check for necessity of recalculation.\r\n        if (balances[user].lastDividensPayoutNumber == amountOfDividendsPayouts &&\r\n            balances[user].lastRedemptionPayoutNumber == amountOfRedemptionPayouts)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        uint addedDividend = 0;\r\n\r\n        // For dividends.\r\n        for (uint i = balances[user].lastDividensPayoutNumber; i < amountOfDividendsPayouts; i++)\r\n        {\r\n            addedDividend += (balances[user].balance * dividendPayouts[i].amount) / dividendPayouts[i].momentTotalSupply;\r\n        }\r\n\r\n        balances[user].posibleDividends += addedDividend;\r\n        balances[user].lastDividensPayoutNumber = amountOfDividendsPayouts;\r\n\r\n        uint addedRedemption = 0;\r\n\r\n        // For redemption.\r\n        for (uint j = balances[user].lastRedemptionPayoutNumber; j < amountOfRedemptionPayouts; j++)\r\n        {\r\n            addedRedemption += (balances[user].balance * redemptionPayouts[j].amount) / redemptionPayouts[j].momentTotalSupply;\r\n        }\r\n\r\n        balances[user].posibleRedemption += addedRedemption;\r\n        balances[user].lastRedemptionPayoutNumber = amountOfRedemptionPayouts;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Get dividends.\r\n    function () external payable\r\n    {\r\n        if (payoutPeriodStart >= now && now <= payoutPeriodEnd)// Check payout period.\r\n        {\r\n            if (posibleDividendsOf(msg.sender) > 0)// Check posible dividends.\r\n            {\r\n                uint dividendsAmount = posibleDividendsOf(msg.sender);// Get posible dividends amount.\r\n\r\n                GetDividends(msg.sender, dividendsAmount);// Call getting dividends event.\r\n\r\n                balances[msg.sender].posibleDividends = 0;// Set balance to zero.\r\n\r\n                msg.sender.transfer(dividendsAmount);// Transfer dividends amount.\r\n            }\r\n        }\r\n    }\r\n\r\n    // Token name.\r\n    string public constant name = \"Agricoin\";\r\n    \r\n    // Token market symbol.\r\n    string public constant symbol = \"AGR\";\r\n    \r\n    // Amount of digits after comma.\r\n    uint public constant decimals = 2;\r\n\r\n    // Total supply.\r\n    uint public totalSupply;\r\n\r\n    // Total supply on ICO only;\r\n    uint public totalSupplyOnIco;\r\n       \r\n    // Activation date.\r\n    uint public startDate;\r\n    \r\n    // Payment period start date, setted by ICO contract before activation.\r\n    uint public payoutPeriodStart;\r\n    \r\n    // Payment period last date, setted by ICO contract before activation.\r\n    uint public payoutPeriodEnd;\r\n    \r\n    // Dividends DividendPayout counter.\r\n    uint public amountOfDividendsPayouts = 0;\r\n\r\n    // Redemption DividendPayout counter.\r\n    uint public amountOfRedemptionPayouts = 0;\r\n\r\n    // Dividend payouts.\r\n    mapping (uint => DividendPayout) public dividendPayouts;\r\n    \r\n    // Redemption payouts.\r\n    mapping (uint => RedemptionPayout) public redemptionPayouts;\r\n\r\n    // Dividend and redemption payers.\r\n    mapping (address => bool) public payers;\r\n\r\n    // Balance records.\r\n    mapping (address => Balance) public balances;\r\n\r\n    // Allowed balances.\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n\r\n    // Set true for activating token. If false then token isn't working.\r\n    bool public isActive = false;\r\n\r\n    // Set true for activate ico minted tokens.\r\n    bool public isSuccessfulIco = false;\r\n}\r\n\r\ncontract Bounty is Owned\r\n{\r\n    // Get bounty event.\r\n    event GetBounty(address indexed bountyHunter, uint amount);\r\n\r\n    // Add bounty event.\r\n    event AddBounty(address indexed bountyHunter, uint amount);\r\n\r\n    // Constructor.\r\n    function Bounty(address agricoinAddress) public\r\n    {\r\n        owner = msg.sender;\r\n        token = agricoinAddress;\r\n    }\r\n\r\n    // Add bounty for hunter.\r\n    function addBountyForHunter(address hunter, uint bounty) onlyOwner() external returns (bool)\r\n    {\r\n        require(!Agricoin(token).isActive());// Check token activity.\r\n\r\n        bounties[hunter] += bounty;// Increase bounty for hunter.\r\n        bountyTotal += bounty;// Increase total bounty value.\r\n\r\n        AddBounty(hunter, bounty);// Call add bounty event.\r\n\r\n        return true;\r\n    }\r\n\r\n    // Get bounty.\r\n    function getBounty() external returns (uint)\r\n    {\r\n        require(Agricoin(token).isActive());// Check token activity.\r\n        require(bounties[msg.sender] != 0);// Check balance of bounty hunter.\r\n        \r\n        if (Agricoin(token).transfer(msg.sender, bounties[msg.sender]))// Transfer bounty tokens to bounty hunter.\r\n        {\r\n            uint amount = bounties[msg.sender];\r\n            bountyTotal -= amount;// Decrease total bounty.\r\n\r\n            GetBounty(msg.sender, amount);// Get bounty event.\r\n            \r\n            bounties[msg.sender] = 0;// Set bounty for hunter to zero.\r\n\r\n            return amount;\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // Bounties.\r\n    mapping (address => uint) public bounties;\r\n\r\n    // Total bounty.\r\n    uint public bountyTotal = 0;\r\n\r\n    // Agricoin token.\r\n    address public token;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bountyTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bounties\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hunter\",\"type\":\"address\"},{\"name\":\"bounty\",\"type\":\"uint256\"}],\"name\":\"addBountyForHunter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getBounty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"agricoinAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bountyHunter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GetBounty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bountyHunter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddBounty\",\"type\":\"event\"}]","ContractName":"Bounty","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d42c50dedae71f7ad62e7792e83d7736637689d9","Library":"","SwarmSource":"bzzr://b53804ed4c2d09a4f24cf1cd412afef0e33e3787ac6333eca216de712e861e09"}]}