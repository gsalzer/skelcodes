{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/************************************************** */\r\n/* WhenHub TokenVesting Contract                    */\r\n/* Author: Nik Kalyani  nik@whenhub.com             */\r\n/* Copyright (c) 2018 CalendarTree, Inc.            */\r\n/* https://interface.whenhub.com                    */\r\n/************************************************** */\r\ncontract TokenVesting {\r\n    using SafeMath for uint256;\r\n\r\n\r\n    /* VestingGrant is used to implement business rules regarding token vesting       */\r\n    struct VestingGrant {\r\n        bool isGranted;                                                 // Flag to indicate grant was issued\r\n        address issuer;                                                 // Account that issued grant\r\n        address beneficiary;                                            // Beneficiary of grant\r\n        uint256 grantJiffys;                                            // Number of Jiffys granted\r\n        uint256 startTimestamp;                                         // Start date/time of vesting\r\n        uint256 cliffTimestamp;                                         // Cliff date/time for vesting\r\n        uint256 endTimestamp;                                           // End date/time of vesting\r\n        bool isRevocable;                                               // Whether issuer can revoke and reclaim Jiffys\r\n        uint256 releasedJiffys;                                         // Number of Jiffys already released\r\n    }\r\n\r\n    mapping(address => VestingGrant) private vestingGrants;             // Token grants subject to vesting\r\n    address[] private vestingGrantLookup;                               // Lookup table of token grants\r\n\r\n    uint private constant GENESIS_TIMESTAMP = 1514764800;                       // Jan 1, 2018 00:00:00 UTC (arbitrary date/time for timestamp validation)\r\n    uint private constant ONE_MONTH = 2629743;\r\n    uint private constant ONE_YEAR = 31556926;\r\n    uint private constant TWO_YEARS = 63113852;\r\n    uint private constant THREE_YEARS = 94670778;\r\n\r\n    bool private initialized = false;\r\n\r\n    /* Vesting Events */\r\n    event Grant             // Fired when an account grants tokens to another account on a vesting schedule\r\n                            (\r\n                                address indexed owner, \r\n                                address indexed beneficiary, \r\n                                uint256 valueVested,\r\n                                uint256 valueUnvested\r\n                            );\r\n\r\n    event Revoke            // Fired when an account revokes previously granted unvested tokens to another account\r\n                            (\r\n                                address indexed owner, \r\n                                address indexed beneficiary, \r\n                                uint256 value\r\n                            );\r\n\r\n    // This contract does not accept any Ether\r\n    function() public {\r\n        revert();\r\n    }\r\n\r\n    string public name = \"TokenVesting\";\r\n\r\n    // Controlling WHENToken contract (cannot be changed)\r\n    WHENToken whenContract;\r\n\r\n    modifier requireIsOperational() \r\n    {\r\n        require(whenContract.isOperational());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor\r\n    *\r\n    * @param whenTokenContract Address of the WHENToken contract\r\n    */\r\n    function TokenVesting\r\n                                (\r\n                                    address whenTokenContract\r\n                                ) \r\n                                public\r\n    {\r\n        whenContract = WHENToken(whenTokenContract);\r\n\r\n    }\r\n\r\n     /**\r\n    * @dev Initial token grants for various accounts\r\n    *\r\n    * @param companyAccount Account representing the Company for granting tokens\r\n    * @param partnerAccount Account representing the Partner for granting tokens\r\n    * @param foundationAccount Account representing the Foundation for granting tokens\r\n    */    \r\n    function initialize         (\r\n                                    address companyAccount,\r\n                                    address partnerAccount, \r\n                                    address foundationAccount\r\n                                )\r\n                                external\r\n    {\r\n        require(!initialized);\r\n\r\n        initialized = true;\r\n\r\n        uint256 companyJiffys;\r\n        uint256 partnerJiffys;\r\n        uint256 foundationJiffys;\r\n        (companyJiffys, partnerJiffys, foundationJiffys) = whenContract.getTokenAllocations();\r\n\r\n        // Grant tokens for current and future use of company\r\n        // One-third initial grant; two-year vesting for balance starting after one year\r\n        uint256 companyInitialGrant = companyJiffys.div(3);\r\n        grant(companyAccount, companyInitialGrant, companyInitialGrant.mul(2), GENESIS_TIMESTAMP + ONE_YEAR, 0, TWO_YEARS, false);\r\n\r\n        // Grant vesting tokens to partner account for use in incentivizing partners\r\n        // Three-year vesting, with six-month cliff\r\n        grant(partnerAccount, 0, partnerJiffys, GENESIS_TIMESTAMP, ONE_MONTH.mul(6), THREE_YEARS, true);\r\n\r\n        // Grant vesting tokens to foundation account for charitable use\r\n        // Three-year vesting, with six-month cliff\r\n        grant(foundationAccount, 0, foundationJiffys, GENESIS_TIMESTAMP, ONE_MONTH.mul(6), THREE_YEARS, true);\r\n    }\r\n\r\n    /**\r\n    * @dev Grants a beneficiary Jiffys using a vesting schedule\r\n    *\r\n    * @param beneficiary The account to whom Jiffys are being granted\r\n    * @param vestedJiffys Fully vested Jiffys that will be granted\r\n    * @param unvestedJiffys Jiffys that are granted but not vested\r\n    * @param startTimestamp Date/time when vesting begins\r\n    * @param cliffSeconds Date/time prior to which tokens vest but cannot be released\r\n    * @param vestingSeconds Vesting duration (also known as vesting term)\r\n    * @param revocable Indicates whether the granting account is allowed to revoke the grant\r\n    */   \r\n    function grant\r\n                            (\r\n                                address beneficiary, \r\n                                uint256 vestedJiffys,\r\n                                uint256 unvestedJiffys, \r\n                                uint256 startTimestamp, \r\n                                uint256 cliffSeconds, \r\n                                uint256 vestingSeconds, \r\n                                bool revocable\r\n                            ) \r\n                            public \r\n                            requireIsOperational\r\n    {\r\n        require(beneficiary != address(0));\r\n        require(!vestingGrants[beneficiary].isGranted);         // Can't have multiple grants for same account\r\n        require((vestedJiffys > 0) || (unvestedJiffys > 0));    // There must be Jiffys that are being granted\r\n\r\n        require(startTimestamp >= GENESIS_TIMESTAMP);           // Just a way to prevent really old dates\r\n        require(vestingSeconds > 0);\r\n        require(cliffSeconds >= 0);\r\n        require(cliffSeconds < vestingSeconds);\r\n\r\n        whenContract.vestingGrant(msg.sender, beneficiary, vestedJiffys, unvestedJiffys);\r\n\r\n        // The vesting grant is added to the beneficiary and the vestingGrant lookup table is updated\r\n        vestingGrants[beneficiary] = VestingGrant({\r\n                                                    isGranted: true,\r\n                                                    issuer: msg.sender,                                                   \r\n                                                    beneficiary: beneficiary, \r\n                                                    grantJiffys: unvestedJiffys,\r\n                                                    startTimestamp: startTimestamp,\r\n                                                    cliffTimestamp: startTimestamp + cliffSeconds,\r\n                                                    endTimestamp: startTimestamp + vestingSeconds,\r\n                                                    isRevocable: revocable,\r\n                                                    releasedJiffys: 0\r\n                                                });\r\n\r\n        vestingGrantLookup.push(beneficiary);\r\n\r\n        Grant(msg.sender, beneficiary, vestedJiffys, unvestedJiffys);   // Fire event\r\n\r\n        // If the cliff time has already passed or there is no cliff, then release\r\n        // any Jiffys for which the beneficiary is already eligible\r\n        if (vestingGrants[beneficiary].cliffTimestamp <= now) {\r\n            releaseFor(beneficiary);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets current grant balance for caller\r\n    *\r\n    */ \r\n    function getGrantBalance() \r\n                            external \r\n                            view \r\n                            returns(uint256) \r\n    {\r\n       return getGrantBalanceOf(msg.sender);        \r\n    }\r\n\r\n    /**\r\n    * @dev Gets current grant balance for an account\r\n    *\r\n    * The return value subtracts Jiffys that have previously\r\n    * been released.\r\n    *\r\n    * @param account Account whose grant balance is returned\r\n    *\r\n    */ \r\n    function getGrantBalanceOf\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            view \r\n                            returns(uint256) \r\n    {\r\n        require(account != address(0));\r\n        require(vestingGrants[account].isGranted);\r\n        \r\n        return(vestingGrants[account].grantJiffys.sub(vestingGrants[account].releasedJiffys));\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Releases Jiffys that have been vested for caller\r\n    *\r\n    */ \r\n    function release() \r\n                            public \r\n    {\r\n        releaseFor(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Releases Jiffys that have been vested for an account\r\n    *\r\n    * @param account Account whose Jiffys will be released\r\n    *\r\n    */ \r\n    function releaseFor\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            requireIsOperational \r\n    {\r\n        require(account != address(0));\r\n        require(vestingGrants[account].isGranted);\r\n        require(vestingGrants[account].cliffTimestamp <= now);\r\n        \r\n        // Calculate vesting rate per second        \r\n        uint256 jiffysPerSecond = (vestingGrants[account].grantJiffys.div(vestingGrants[account].endTimestamp.sub(vestingGrants[account].startTimestamp)));\r\n\r\n        // Calculate how many jiffys can be released\r\n        uint256 releasableJiffys = now.sub(vestingGrants[account].startTimestamp).mul(jiffysPerSecond).sub(vestingGrants[account].releasedJiffys);\r\n\r\n        // If the additional released Jiffys would cause the total released to exceed total granted, then\r\n        // cap the releasable Jiffys to whatever was granted.\r\n        if ((vestingGrants[account].releasedJiffys.add(releasableJiffys)) > vestingGrants[account].grantJiffys) {\r\n            releasableJiffys = vestingGrants[account].grantJiffys.sub(vestingGrants[account].releasedJiffys);\r\n        }\r\n\r\n        if (releasableJiffys > 0) {\r\n            // Update the released Jiffys counter\r\n            vestingGrants[account].releasedJiffys = vestingGrants[account].releasedJiffys.add(releasableJiffys);\r\n            whenContract.vestingTransfer(vestingGrants[account].issuer, account, releasableJiffys);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns a lookup table of all vesting grant beneficiaries\r\n    *\r\n    */ \r\n    function getGrantBeneficiaries() \r\n                            external \r\n                            view \r\n                            returns(address[]) \r\n    {\r\n        return vestingGrantLookup;        \r\n    }\r\n\r\n    /**\r\n    * @dev Revokes previously issued vesting grant\r\n    *\r\n    * For a grant to be revoked, it must be revocable.\r\n    * In addition, only the unreleased tokens can be revoked.\r\n    *\r\n    * @param account Account for which a prior grant will be revoked\r\n    */ \r\n    function revoke\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            requireIsOperational \r\n    {\r\n        require(account != address(0));\r\n        require(vestingGrants[account].isGranted);\r\n        require(vestingGrants[account].isRevocable);\r\n        require(vestingGrants[account].issuer == msg.sender); // Only the original issuer can revoke a grant\r\n\r\n        // Set the isGranted flag to false to prevent any further\r\n        // actions on this grant from ever occurring\r\n        vestingGrants[account].isGranted = false;        \r\n        \r\n        // Get the remaining balance of the grant\r\n        uint256 balanceJiffys = vestingGrants[account].grantJiffys.sub(vestingGrants[account].releasedJiffys);\r\n        Revoke(vestingGrants[account].issuer, account, balanceJiffys);\r\n\r\n        // If there is any balance left, return it to the issuer\r\n        if (balanceJiffys > 0) {\r\n            whenContract.vestingTransfer(msg.sender, msg.sender, balanceJiffys);\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract WHENToken {\r\n\r\n    function isOperational() public view returns(bool);\r\n    function vestingGrant(address owner, address beneficiary, uint256 vestedJiffys, uint256 unvestedJiffys) external;\r\n    function vestingTransfer(address owner, address beneficiary, uint256 jiffys) external;\r\n    function getTokenAllocations() external view returns(uint256, uint256, uint256);\r\n}\r\n\r\n/*\r\nLICENSE FOR SafeMath and TokenVesting\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016 Smart Contract Solutions, Inc.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\nlibrary SafeMath {\r\n/* Copyright (c) 2016 Smart Contract Solutions, Inc. */\r\n/* See License at end of file                        */\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n        return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGrantBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"vestedJiffys\",\"type\":\"uint256\"},{\"name\":\"unvestedJiffys\",\"type\":\"uint256\"},{\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"name\":\"cliffSeconds\",\"type\":\"uint256\"},{\"name\":\"vestingSeconds\",\"type\":\"uint256\"},{\"name\":\"revocable\",\"type\":\"bool\"}],\"name\":\"grant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"companyAccount\",\"type\":\"address\"},{\"name\":\"partnerAccount\",\"type\":\"address\"},{\"name\":\"foundationAccount\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getGrantBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releaseFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGrantBeneficiaries\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"whenTokenContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueVested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"valueUnvested\",\"type\":\"uint256\"}],\"name\":\"Grant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Revoke\",\"type\":\"event\"}]","ContractName":"TokenVesting","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f4fe95603881d0e07954fd7605e0e9a916e42c44","Library":"","SwarmSource":"bzzr://f12879a66bc0a1a3cfb450f99f68c03865ee983e5b2c4bee96f930818a5a1ff9"}]}