{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n\r\n// D.H.A.R.M.A. Initiative Swan Protocol\r\n// The protocol must be executed at least once every 108 minutes\r\n// Failure to do so releases the reward to the last executor\r\ncontract Protocol108 {\r\n\t// smart contract version\r\n\tuint public version = 1;\r\n\r\n\t// countdown timer reset value\r\n\tuint length = 6480;\r\n\r\n\t// last time protocol was executed\r\n\tuint offset;\r\n\r\n\t// last executor of the protocol\r\n\taddress public executor;\r\n\r\n\t// number of times protocol was executed\r\n\t// zero value means protocol is in initialization state\r\n\tuint public cycle;\r\n\r\n\t// total value volume passed through\r\n\tuint public volume;\r\n\r\n\t// creates the protocol\r\n\tfunction Protocol108() public {\r\n\t}\r\n\r\n\t// initializes the protocol\r\n\tfunction initialize() public payable {\r\n\t\t// validate protocol state\r\n\t\tassert(cycle == 0);\r\n\r\n\t\t// update the protocol\r\n\t\tupdate();\r\n\t}\r\n\r\n\t// executes the protocol\r\n\tfunction execute() public payable {\r\n\t\t// validate protocol state\r\n\t\tassert(cycle > 0);\r\n\t\tassert(offset + length > now);\r\n\r\n\t\t// update the protocol\r\n\t\tupdate();\r\n\t}\r\n\r\n\t// withdraws the reward to the last executor\r\n\tfunction withdraw() public {\r\n\t\t// validate protocol state\r\n\t\tassert(cycle > 0);\r\n\t\tassert(offset + length <= now);\r\n\r\n\t\t// validate input(s)\r\n\t\trequire(msg.sender == executor);\r\n\r\n\t\t// reset cycle count\r\n\t\tcycle = 0;\r\n\r\n\t\t// transfer the reward\r\n\t\texecutor.transfer(this.balance);\r\n\t}\r\n\r\n\t// updates the protocol state by\r\n\t// updating offset, last executor and cycle count\r\n\tfunction update() private {\r\n\t\t// validate input(s)\r\n\t\tvalidate(msg.value);\r\n\r\n\t\t// update offset (last execution time)\r\n\t\toffset = now;\r\n\r\n\t\t// update last executor\r\n\t\texecutor = msg.sender;\r\n\r\n\t\t// update cycle\r\n\t\tcycle++;\r\n\r\n\t\t// update total volume\r\n\t\tvolume += msg.value;\r\n\t}\r\n\r\n\t// validates the input sequence of numbers\r\n\t// simplest impl (current): positive value\r\n\t// proper impl (consideration for future versions): 00..0481516234200..0-like values\r\n\t// where any number of leading/trailing zeroes allowed\r\n\t// calling this function as part of transaction returns true or throws an exception\r\n\t// calling this function as constant returns true or false\r\n\tfunction validate(uint sequence) public constant returns (bool) {\r\n\t\t// validate the sequence\r\n\t\trequire(sequence > 0);\r\n\r\n\t\t// we won't get here if validation fails\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// number of seconds left until protocol terminates\r\n\tfunction countdown() public constant returns (uint) {\r\n\t\t// check if protocol is initialized\r\n\t\tif(cycle == 0) {\r\n\t\t\t// for uninitialized protocol its equal to length\r\n\t\t\treturn length;\r\n\t\t}\r\n\r\n\t\t// for active/terminated protocol calculate the value\r\n\t\tuint n = now;\r\n\r\n\t\t// check for negative overflow\r\n\t\tif(offset + length > n) {\r\n\t\t\t// positive countdown\r\n\t\t\treturn offset + length - n;\r\n\t\t}\r\n\r\n\t\t// zero or negative countdown\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t// the default payable function, performs one of\r\n\t// initialize(), execute() or withdraw() depending on protocol state\r\n\tfunction() public payable {\r\n\t\tif(cycle == 0) {\r\n\t\t\t// protocol not yet initialized, try to initialize\r\n\t\t\tinitialize();\r\n\t\t}\r\n\t\telse if(offset + length > now) {\r\n\t\t\t// protocol is eligible for execution, execute\r\n\t\t\texecute();\r\n\t\t}\r\n\t\telse if(this.balance > 0) {\r\n\t\t\t// protocol has terminated, withdraw the reward\r\n\t\t\twithdraw();\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// invalid protocol state\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"execute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"volume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countdown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sequence\",\"type\":\"uint256\"}],\"name\":\"validate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Protocol108","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cc1a3d1e05cbd22cd470b6e5ca81077dbe14be691b82b0013bf44cbaa1d70903"}]}