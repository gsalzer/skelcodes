{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\nlibrary ContractHelpers {\r\n  function isContract(address addr) internal view returns (bool) {\r\n      uint size;\r\n      assembly { size := extcodesize(addr) }\r\n      return size > 0;\r\n    }\r\n}\r\n\r\ncontract BetWinner is Ownable {\r\n  address owner;\r\n\r\n  // team has name and its total bet amount and bettors\r\n  struct Team {\r\n    string name;\r\n    uint256 bets;\r\n    address[] bettors;\r\n    mapping(address => uint256) bettorAmount;\r\n  }\r\n\r\n  Team[] teams;\r\n  uint8 public winningTeamIndex = 255; // 255 => not set\r\n\r\n  // payout table for winners\r\n  mapping(address => uint256) public payOuts;\r\n\r\n  bool public inited;\r\n\r\n  // timestamps\r\n  uint32 public bettingStart;\r\n  uint32 public bettingEnd;\r\n  uint32 public winnerAnnounced;\r\n\r\n  uint8 public feePercentage;\r\n  uint public minimumBet;\r\n  uint public totalFee;\r\n\r\n  // events\r\n  event BetPlaced(address indexed _from, uint8 indexed _teamId, uint _value);\r\n  event Withdraw(address indexed _to, uint _value);\r\n  event Started(uint bettingStartTime, uint numberOfTeams);\r\n  event WinnerAnnounced(uint8 indexed teamIndex);\r\n\r\n  // constructor\r\n  function BetWinner() public Ownable() {\r\n    feePercentage = 2;\r\n    minimumBet = 100 szabo;\r\n  }\r\n\r\n  // get bettingStart, bettingEnd, winnerAnnounced, winnerIndex, teams count\r\n  function betInfo() public view returns (uint32, uint32, uint32, uint8, uint) {\r\n    return (bettingStart, bettingEnd, winnerAnnounced, winningTeamIndex, teams.length);\r\n  }\r\n  function bettingStarted() private view returns (bool) {\r\n    return now >= bettingStart;\r\n  }\r\n  function bettingEnded() private view returns (bool) {\r\n    return now >= bettingEnd;\r\n  }\r\n\r\n  // remember to add all teams before calling startBetting\r\n  function addTeam(string _name) public onlyOwner {\r\n    require(!inited);\r\n    Team memory t = Team({\r\n      name: _name,\r\n      bets: 0,\r\n      bettors: new address[](0)\r\n    });\r\n    teams.push(t);\r\n  }\r\n  \r\n  // set betting start and stop times. after that teams cannot be added\r\n  function startBetting(uint32 _bettingStart, uint32 _bettingEnd) public onlyOwner {\r\n    require(!inited);\r\n\r\n    bettingStart = _bettingStart;\r\n    bettingEnd = _bettingEnd;\r\n\r\n    inited = true;\r\n\r\n    Started(bettingStart, teams.length - 1);\r\n  }\r\n\r\n  // get total bet amount for address for team\r\n  function getBetAmount(uint8 teamIndex) view public returns (uint) {\r\n    return teams[teamIndex].bettorAmount[msg.sender];\r\n  }\r\n\r\n  // get team data (name, total bets, bettor count)\r\n  function getTeam(uint8 teamIndex) view public returns (string, uint, uint) {\r\n    Team memory t = teams[teamIndex];\r\n    return (t.name, t.bets, t.bettors.length);\r\n  }\r\n\r\n  // get total bets for every team\r\n  function totalBets() view public returns (uint) {\r\n    uint total = 0;\r\n    for (uint i = 0; i < teams.length; i++) {\r\n      total += teams[i].bets;\r\n    }\r\n    return total;\r\n  }\r\n\r\n  // place bet to team\r\n  function bet(uint8 teamIndex) payable public {\r\n    // betting has to be started and not ended and winningTeamIndex must be 255 (not announced)\r\n    require(bettingStarted() && !bettingEnded() && winningTeamIndex == 255);\r\n    // value must be at least minimum bet\r\n    require(msg.value >= minimumBet);\r\n    // must not be smart contract address\r\n    require(!ContractHelpers.isContract(msg.sender));\r\n    // check that we have team in that index we are betting\r\n    require(teamIndex < teams.length);\r\n\r\n    // get storage ref\r\n    Team storage team = teams[teamIndex];\r\n    // add bet to team\r\n    team.bets += msg.value;\r\n\r\n    // if new bettor, save address for paying winnings\r\n    if (team.bettorAmount[msg.sender] == 0) {\r\n      team.bettors.push(msg.sender);\r\n    }\r\n\r\n    // send event\r\n    BetPlaced(msg.sender, teamIndex, msg.value);\r\n    // add bettor betting amount, so we can pay correct amount if win\r\n    team.bettorAmount[msg.sender] += msg.value;\r\n  }\r\n\r\n  // calculate fee from the losing portion of total pot\r\n  function removeFeeAmount(uint totalPot, uint winnersPot) private returns(uint) {\r\n    uint remaining = SafeMath.sub(totalPot, winnersPot);\r\n    // if we only have winners, take no fee\r\n    if (remaining == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // calculate fee\r\n    uint feeAmount = SafeMath.div(remaining, 100);\r\n    feeAmount = feeAmount * feePercentage;\r\n\r\n    totalFee = feeAmount;\r\n    // return loser side pot - fee = winnings\r\n    return remaining - feeAmount;\r\n  }\r\n\r\n  // announce winner\r\n  function announceWinner(uint8 teamIndex) public onlyOwner {\r\n    // ensure we have a team here\r\n    require(teamIndex < teams.length);\r\n    // ensure that betting is ended before announcing winner and winner has not been announced\r\n    require(bettingEnded() && winningTeamIndex == 255);\r\n    winningTeamIndex = teamIndex;\r\n    winnerAnnounced = uint32(now);\r\n\r\n    WinnerAnnounced(teamIndex);\r\n    // calculate payouts for winners\r\n    calculatePayouts();\r\n  }\r\n\r\n  // calculate payouts\r\n  function calculatePayouts() private {\r\n    uint totalAmount = totalBets();\r\n    Team storage wt = teams[winningTeamIndex];\r\n    uint winTeamAmount = wt.bets;\r\n    // if we have no winners, no need to do anything\r\n    if (winTeamAmount == 0) {\r\n      return;\r\n    }\r\n\r\n    // substract fee\r\n    uint winnings = removeFeeAmount(totalAmount, winTeamAmount);\r\n\r\n    // calc percentage of total pot for every winner bettor\r\n    for (uint i = 0; i < wt.bettors.length; i++) {\r\n      // get bet amount\r\n      uint betSize = wt.bettorAmount[wt.bettors[i]];\r\n      // get bettor percentage of pot\r\n      uint percentage = SafeMath.div((betSize*100), winTeamAmount);\r\n      // calculate winnings\r\n      uint payOut = winnings * percentage;\r\n      // add winnings and original bet = total payout\r\n      payOuts[wt.bettors[i]] = SafeMath.div(payOut, 100) + betSize;\r\n    }\r\n  }\r\n\r\n  // winner can withdraw payout after winner is announced\r\n  function withdraw() public {\r\n    // check that we have winner announced\r\n    require(winnerAnnounced > 0 && uint32(now) > winnerAnnounced);\r\n    // check that we have payout calculated for address.\r\n    require(payOuts[msg.sender] > 0);\r\n\r\n    // no double withdrawals\r\n    uint po = payOuts[msg.sender];\r\n    payOuts[msg.sender] = 0;\r\n\r\n    Withdraw(msg.sender, po);\r\n    // transfer payout to sender\r\n    msg.sender.transfer(po);\r\n  }\r\n\r\n  // withdraw owner fee when winner is announced\r\n  function withdrawFee() public onlyOwner {\r\n    require(totalFee > 0);\r\n    // owner cannot withdraw fee before winner is announced. This is incentive for contract owner to announce winner\r\n    require(winnerAnnounced > 0 && now > winnerAnnounced);\r\n    // make sure owner cannot withdraw more than fee amount\r\n    msg.sender.transfer(totalFee);\r\n    // set total fee to zero, so owner cannot empty whole contract\r\n    totalFee = 0;\r\n  }\r\n\r\n  // cancel and set all bets to payouts\r\n  function cancel() public onlyOwner {\r\n    require (winningTeamIndex == 255);\r\n    winningTeamIndex = 254;\r\n    winnerAnnounced = uint32(now);\r\n\r\n    Team storage t = teams[0];\r\n    for (uint i = 0; i < t.bettors.length; i++) {\r\n      payOuts[t.bettors[i]] += t.bettorAmount[t.bettors[i]];\r\n    }\r\n    Team storage t2 = teams[1];\r\n    for (i = 0; i < t2.bettors.length; i++) {\r\n      payOuts[t2.bettors[i]] += t2.bettorAmount[t2.bettors[i]];\r\n    }\r\n  }\r\n\r\n  // can kill contract after winnerAnnounced + 8 weeks\r\n  function kill() public onlyOwner {\r\n    // cannot kill contract before winner is announced and it's been announced at least for 8 weeks\r\n    require(winnerAnnounced > 0 && uint32(now) > (winnerAnnounced + 8 weeks));\r\n    selfdestruct(msg.sender);\r\n  }\r\n\r\n  // prevent eth transfers to this contract\r\n  function () public payable {\r\n    revert();\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"teamIndex\",\"type\":\"uint8\"}],\"name\":\"announceWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"teamIndex\",\"type\":\"uint8\"}],\"name\":\"getBetAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inited\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"betInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningTeamIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bettingStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bettingEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payOuts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"teamIndex\",\"type\":\"uint8\"}],\"name\":\"getTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"teamIndex\",\"type\":\"uint8\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bettingStart\",\"type\":\"uint32\"},{\"name\":\"_bettingEnd\",\"type\":\"uint32\"}],\"name\":\"startBetting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnerAnnounced\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"addTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_teamId\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bettingStartTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numberOfTeams\",\"type\":\"uint256\"}],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"teamIndex\",\"type\":\"uint8\"}],\"name\":\"WinnerAnnounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BetWinner","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7bd983a7cebf8e2bb496ed7d3025ef93daab46adad02001fc3c6864462f77cca"}]}