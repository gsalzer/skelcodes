{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/Utils/Math.sol\r\n\r\nlibrary MathUtils {\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint result = a + b;\r\n\r\n        if (a == 0 || b == 0) {\r\n            return result;\r\n        }\r\n\r\n        require(result > a && result > b);\r\n\r\n        return result;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(a >= b);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint result = a * b;\r\n\r\n        require(result / a == b);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/Token/Balance.sol\r\n\r\ncontract Balance {\r\n    mapping(address => uint) public balances;\r\n\r\n    // ERC20 function\r\n    function balanceOf(address account) public constant returns (uint) {\r\n        return balances[account];\r\n    }\r\n\r\n    modifier hasSufficientBalance(address account, uint balance) {\r\n        require(balances[account] >= balance);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/Utils/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function isOwner() view public returns (bool) {\r\n        return msg.sender == owner;\r\n    }\r\n\r\n    modifier grantOwner {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/Token/CrowdsaleState.sol\r\n\r\ninterface CrowdsaleState {\r\n    function isCrowdsaleSuccessful() external view returns(bool);\r\n}\r\n\r\n// File: contracts/Token/HardCap.sol\r\n\r\ninterface HardCap {\r\n    function getHardCap() external pure returns(uint);\r\n}\r\n\r\n// File: contracts/Token/Crowdsale.sol\r\n\r\ncontract Crowdsale is Ownable {\r\n    address public crowdsaleContract;\r\n\r\n    function isCrowdsale() internal view returns(bool) {\r\n        return crowdsaleSet() && msg.sender == crowdsaleContract;\r\n    }\r\n\r\n    function crowdsaleSet() internal view returns(bool) {\r\n        return crowdsaleContract != address(0);\r\n    }\r\n\r\n    function addressIsCrowdsale(address _address) public view returns(bool) {\r\n        return crowdsaleSet() && crowdsaleContract == _address;\r\n    }\r\n\r\n    function setCrowdsaleContract(address crowdsale) public grantOwner {\r\n        require(crowdsaleContract == address(0));\r\n        crowdsaleContract = crowdsale;\r\n    }\r\n\r\n    function crowdsaleSuccessful() internal view returns(bool) {\r\n        require(crowdsaleSet());\r\n        return CrowdsaleState(crowdsaleContract).isCrowdsaleSuccessful();\r\n    }\r\n\r\n    function getCrowdsaleHardCap() internal view returns(uint) {\r\n        require(crowdsaleSet());\r\n        return HardCap(crowdsaleContract).getHardCap();\r\n    }\r\n}\r\n\r\n// File: contracts/Token/TotalSupply.sol\r\n\r\ncontract TotalSupply {\r\n    uint public totalSupply = 1000000000 * 10**18;\r\n\r\n    // ERC20 function\r\n    function totalSupply() external constant returns (uint) {\r\n        return totalSupply;\r\n    }\r\n}\r\n\r\n// File: contracts/Token/Burnable.sol\r\n\r\ncontract Burnable is TotalSupply, Balance, Ownable, Crowdsale {\r\n    using MathUtils for uint;\r\n\r\n    event Burn(address account, uint value);\r\n\r\n    function burn(uint amount) public grantBurner hasSufficientBalance(msg.sender, amount) {\r\n        balances[msg.sender] = balances[msg.sender].sub(amount);\r\n        totalSupply = totalSupply.sub(amount);\r\n        emit Burn(msg.sender, amount);\r\n    }\r\n\r\n    modifier grantBurner {\r\n        require(isCrowdsale());\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/Token/TokenRecipient.sol\r\n\r\ninterface TokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\r\n}\r\n\r\n// File: contracts/Token/CryptoPoliceOfficerToken.sol\r\n\r\n/// ERC20 compliant token contract\r\ncontract CryptoPoliceOfficerToken is TotalSupply, Balance, Burnable {\r\n    using MathUtils for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n\r\n    mapping(address => mapping(address => uint)) allowances;\r\n    \r\n    bool public publicTransfersEnabled = false;\r\n    uint public releaseStartTime;\r\n\r\n    uint public lockedAmount;\r\n    TokenLock[] public locks;\r\n\r\n    struct TokenLock {\r\n        uint amount;\r\n        uint timespan;\r\n        bool released;\r\n    }\r\n\r\n    event Transfer(\r\n        address indexed fromAccount,\r\n        address indexed destination,\r\n        uint amount\r\n    );\r\n    \r\n    event Approval(\r\n        address indexed fromAccount,\r\n        address indexed destination,\r\n        uint amount\r\n    );\r\n    \r\n    constructor(\r\n        string tokenName,\r\n        string tokenSymbol\r\n    )\r\n        public\r\n    {\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n    \r\n    function _transfer(\r\n        address source,\r\n        address destination,\r\n        uint amount\r\n    )\r\n        internal\r\n        hasSufficientBalance(source, amount)\r\n        whenTransferable(destination)\r\n        hasUnlockedAmount(source, amount)\r\n    {\r\n        require(destination != address(this) && destination != 0x0);\r\n\r\n        if (amount > 0) {\r\n            balances[source] -= amount;\r\n            balances[destination] = balances[destination].add(amount);\r\n        }\r\n\r\n        emit Transfer(source, destination, amount);\r\n    }\r\n\r\n    function transfer(address destination, uint amount)\r\n    public returns (bool)\r\n    {\r\n        _transfer(msg.sender, destination, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address source,\r\n        address destination,\r\n        uint amount\r\n    )\r\n        public returns (bool)\r\n    {\r\n        require(allowances[source][msg.sender] >= amount);\r\n\r\n        allowances[source][msg.sender] -= amount;\r\n\r\n        _transfer(source, destination, amount);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Allow destination address to withdraw funds from account that is caller\r\n     * of this function\r\n     *\r\n     * @param destination The one who receives permission\r\n     * @param amount How much funds can be withdrawn\r\n     * @return Whether or not approval was successful\r\n     */\r\n    function approve(\r\n        address destination,\r\n        uint amount\r\n    )\r\n        public returns (bool)\r\n    {\r\n        allowances[msg.sender][destination] = amount;\r\n        emit Approval(msg.sender, destination, amount);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function allowance(\r\n        address fromAccount,\r\n        address destination\r\n    )\r\n        public constant returns (uint)\r\n    {\r\n        return allowances[fromAccount][destination];\r\n    }\r\n\r\n    function approveAndCall(\r\n        address _spender,\r\n        uint256 _value,\r\n        bytes _extraData\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        TokenRecipient spender = TokenRecipient(_spender);\r\n\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function enablePublicTransfers()\r\n    public grantOwner\r\n    {\r\n        require(crowdsaleSuccessful());\r\n        \r\n        publicTransfersEnabled = true;\r\n        releaseStartTime = now;\r\n    }\r\n\r\n    function addTokenLock(uint amount, uint timespan)\r\n    public grantOwner\r\n    {\r\n        require(releaseStartTime == 0);\r\n        requireOwnerUnlockedAmount(amount);\r\n\r\n        locks.push(TokenLock({\r\n            amount: amount,\r\n            timespan: timespan,\r\n            released: false\r\n        }));\r\n\r\n        lockedAmount += amount;\r\n    }\r\n\r\n    function releaseLockedTokens(uint8 idx)\r\n    public grantOwner\r\n    {\r\n        require(releaseStartTime > 0);\r\n        require(!locks[idx].released);\r\n        require((releaseStartTime + locks[idx].timespan) < now);\r\n\r\n        locks[idx].released = true;\r\n        lockedAmount -= locks[idx].amount;\r\n    }\r\n\r\n    function requireOwnerUnlockedAmount(uint amount)\r\n    internal view\r\n    {\r\n        require(balanceOf(owner).sub(lockedAmount) >= amount);\r\n    }\r\n\r\n    function setCrowdsaleContract(address crowdsale)\r\n    public grantOwner\r\n    {\r\n        super.setCrowdsaleContract(crowdsale);\r\n        transfer(crowdsale, getCrowdsaleHardCap());\r\n    }\r\n\r\n    modifier hasUnlockedAmount(address account, uint amount) {\r\n        if (owner == account) {\r\n            requireOwnerUnlockedAmount(amount);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier whenTransferable(address destination) {\r\n        require(publicTransfersEnabled\r\n            || isCrowdsale()\r\n            || (isOwner() && addressIsCrowdsale(destination) && balanceOf(crowdsaleContract) == 0)\r\n            || (isOwner() && !crowdsaleSet())\r\n        );\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"source\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enablePublicTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"crowdsale\",\"type\":\"address\"}],\"name\":\"setCrowdsaleContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicTransfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint8\"}],\"name\":\"releaseLockedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"timespan\",\"type\":\"uint256\"}],\"name\":\"addTokenLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fromAccount\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locks\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"timespan\",\"type\":\"uint256\"},{\"name\":\"released\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addressIsCrowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAccount\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAccount\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"CryptoPoliceOfficerToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b4f666669636572436f696e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044f46435200000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://f12f6763bbf2e9622f9d3df92761f828e277b66f9754ea3dfa4803155ab83fa0"}]}