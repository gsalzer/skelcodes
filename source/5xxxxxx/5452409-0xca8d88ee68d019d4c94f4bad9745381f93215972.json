{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// File: contracts/ISimpleCrowdsale.sol\r\n\r\ninterface ISimpleCrowdsale {\r\n    function getSoftCap() external view returns(uint256);\r\n    function isContributorInLists(address contributorAddress) external view returns(bool);\r\n    function processReservationFundContribution(\r\n        address contributor,\r\n        uint256 tokenAmount,\r\n        uint256 tokenBonusAmount\r\n    ) external payable;\r\n}\r\n\r\n// File: contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract.\r\n    */\r\n    function Ownable(address _owner) public {\r\n        owner = _owner == address(0) ? msg.sender : _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev confirm ownership by a new owner\r\n    */\r\n    function confirmOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n// File: contracts/fund/ICrowdsaleFund.sol\r\n\r\n/**\r\n * @title ICrowdsaleFund\r\n * @dev Fund methods used by crowdsale contract\r\n */\r\ninterface ICrowdsaleFund {\r\n    /**\r\n    * @dev Function accepts user`s contributed ether and logs contribution\r\n    * @param contributor Contributor wallet address.\r\n    */\r\n    function processContribution(address contributor) external payable;\r\n    /**\r\n    * @dev Function is called on the end of successful crowdsale\r\n    */\r\n    function onCrowdsaleEnd() external;\r\n    /**\r\n    * @dev Function is called if crowdsale failed to reach soft cap\r\n    */\r\n    function enableCrowdsaleRefund() external;\r\n}\r\n\r\n// File: contracts/fund/ICrowdsaleReservationFund.sol\r\n\r\n/**\r\n * @title ICrowdsaleReservationFund\r\n * @dev ReservationFund methods used by crowdsale contract\r\n */\r\ninterface ICrowdsaleReservationFund {\r\n    /**\r\n     * @dev Check if contributor has transactions\r\n     */\r\n    function canCompleteContribution(address contributor) external returns(bool);\r\n    /**\r\n     * @dev Complete contribution\r\n     * @param contributor Contributor`s address\r\n     */\r\n    function completeContribution(address contributor) external;\r\n    /**\r\n     * @dev Function accepts user`s contributed ether and amount of tokens to issue\r\n     * @param contributor Contributor wallet address.\r\n     * @param _tokensToIssue Token amount to issue\r\n     * @param _bonusTokensToIssue Bonus token amount to issue\r\n     */\r\n    function processContribution(address contributor, uint256 _tokensToIssue, uint256 _bonusTokensToIssue) external payable;\r\n\r\n    /**\r\n     * @dev Function returns current user`s contributed ether amount\r\n     */\r\n    function contributionsOf(address contributor) external returns(uint256);\r\n\r\n    /**\r\n     * @dev Function is called on the end of successful crowdsale\r\n     */\r\n    function onCrowdsaleEnd() external;\r\n}\r\n\r\n// File: contracts/token/IERC20Token.sol\r\n\r\n/**\r\n * @title IERC20Token - ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20Token {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value)  public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\r\n    function approve(address _spender, uint256 _value)  public returns (bool success);\r\n    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\ncontract SafeMath {\r\n    /**\r\n    * @dev constructor\r\n    */\r\n    function SafeMath() public {\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(a >= b);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/token/LockedTokens.sol\r\n\r\n/**\r\n * @title LockedTokens\r\n * @dev Lock tokens for certain period of time\r\n */\r\ncontract LockedTokensTest is SafeMath {\r\n    struct Tokens {\r\n        uint256 amount;\r\n        uint256 lockEndTime;\r\n        bool released;\r\n    }\r\n\r\n    event TokensUnlocked(address _to, uint256 _value);\r\n\r\n    IERC20Token public token;\r\n    address public crowdsaleAddress;\r\n    mapping(address => Tokens[]) public walletTokens;\r\n\r\n    /**\r\n     * @dev LockedTokens constructor\r\n     * @param _token ERC20 compatible token contract\r\n     * @param _crowdsaleAddress Crowdsale contract address\r\n     */\r\n    function LockedTokensTest(IERC20Token _token, address _crowdsaleAddress) public {\r\n        token = _token;\r\n        crowdsaleAddress = _crowdsaleAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Functions locks tokens\r\n     * @param _to Wallet address to transfer tokens after _lockEndTime\r\n     * @param _amount Amount of tokens to lock\r\n     * @param _lockEndTime End of lock period\r\n     */\r\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\r\n        require(msg.sender == crowdsaleAddress);\r\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\r\n    }\r\n\r\n    /**\r\n     * @dev Called by owner of locked tokens to release them\r\n     */\r\n    function releaseTokens() public {\r\n        require(walletTokens[msg.sender].length > 0);\r\n\r\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\r\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\r\n                walletTokens[msg.sender][i].released = true;\r\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\r\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ownership/MultiOwnable.sol\r\n\r\n/**\r\n * @title MultiOwnable\r\n * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\r\n * functions, this simplifies the implementation of \"users permissions\".\r\n */\r\ncontract MultiOwnable {\r\n    address public manager; // address used to set owners\r\n    address[] public owners;\r\n    mapping(address => bool) public ownerByAddress;\r\n\r\n    event SetOwners(address[] owners);\r\n\r\n    modifier onlyOwner() {\r\n        require(ownerByAddress[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev MultiOwnable constructor sets the manager\r\n     */\r\n    function MultiOwnable() public {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to set owners addresses\r\n     */\r\n    function setOwners(address[] _owners) public {\r\n        require(msg.sender == manager);\r\n        _setOwners(_owners);\r\n\r\n    }\r\n\r\n    function _setOwners(address[] _owners) internal {\r\n        for(uint256 i = 0; i < owners.length; i++) {\r\n            ownerByAddress[owners[i]] = false;\r\n        }\r\n\r\n\r\n        for(uint256 j = 0; j < _owners.length; j++) {\r\n            ownerByAddress[_owners[j]] = true;\r\n        }\r\n        owners = _owners;\r\n        SetOwners(_owners);\r\n    }\r\n\r\n    function getOwners() public constant returns (address[]) {\r\n        return owners;\r\n    }\r\n}\r\n\r\n// File: contracts/token/ERC20Token.sol\r\n\r\n/**\r\n * @title ERC20Token - ERC20 base implementation\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20Token is IERC20Token, SafeMath {\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\r\n\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n// File: contracts/token/ITokenEventListener.sol\r\n\r\n/**\r\n * @title ITokenEventListener\r\n * @dev Interface which should be implemented by token listener\r\n */\r\ninterface ITokenEventListener {\r\n    /**\r\n     * @dev Function is called after token transfer/transferFrom\r\n     * @param _from Sender address\r\n     * @param _to Receiver address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function onTokenTransfer(address _from, address _to, uint256 _value) external;\r\n}\r\n\r\n// File: contracts/token/ManagedToken.sol\r\n\r\n/**\r\n * @title ManagedToken\r\n * @dev ERC20 compatible token with issue and destroy facilities\r\n * @dev All transfers can be monitored by token event listener\r\n */\r\ncontract ManagedToken is ERC20Token, MultiOwnable {\r\n    bool public allowTransfers = false;\r\n    bool public issuanceFinished = false;\r\n\r\n    ITokenEventListener public eventListener;\r\n\r\n    event AllowTransfersChanged(bool _newState);\r\n    event Issue(address indexed _to, uint256 _value);\r\n    event Destroy(address indexed _from, uint256 _value);\r\n    event IssuanceFinished();\r\n\r\n    modifier transfersAllowed() {\r\n        require(allowTransfers);\r\n        _;\r\n    }\r\n\r\n    modifier canIssue() {\r\n        require(!issuanceFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev ManagedToken constructor\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owners Owners list\r\n     */\r\n    function ManagedToken(address _listener, address[] _owners) public {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        }\r\n        _setOwners(_owners);\r\n    }\r\n\r\n    /**\r\n     * @dev Enable/disable token transfers. Can be called only by owners\r\n     * @param _allowTransfers True - allow False - disable\r\n     */\r\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\r\n        allowTransfers = _allowTransfers;\r\n        AllowTransfersChanged(_allowTransfers);\r\n    }\r\n\r\n    /**\r\n     * @dev Set/remove token event listener\r\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\r\n     */\r\n    function setListener(address _listener) public onlyOwner {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        } else {\r\n            delete eventListener;\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transfer(_to, _value);\r\n        if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transferFrom(_from, _to, _value);\r\n        if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(_from, _to, _value);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function hasListener() internal view returns(bool) {\r\n        if(eventListener == address(0)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Issue tokens to specified wallet\r\n     * @param _to Wallet address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\r\n        totalSupply = safeAdd(totalSupply, _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Issue(_to, _value);\r\n        Transfer(address(0), _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\r\n     * @dev Fund contract address must be in the list of owners to burn token during refund\r\n     * @param _from Wallet address\r\n     * @param _value Amount of tokens to destroy\r\n     */\r\n    function destroy(address _from, uint256 _value) external {\r\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\r\n        require(balances[_from] >= _value);\r\n        totalSupply = safeSub(totalSupply, _value);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        Transfer(_from, address(0), _value);\r\n        Destroy(_from, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Finish token issuance\r\n     * @return True if success\r\n     */\r\n    function finishIssuance() public onlyOwner returns (bool) {\r\n        issuanceFinished = true;\r\n        IssuanceFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/token/TransferLimitedToken.sol\r\n\r\n/**\r\n * @title TransferLimitedToken\r\n * @dev Token with ability to limit transfers within wallets included in limitedWallets list for certain period of time\r\n */\r\ncontract TransferLimitedToken is ManagedToken {\r\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\r\n\r\n    mapping(address => bool) public limitedWallets;\r\n    uint256 public limitEndDate;\r\n    address public limitedWalletsManager;\r\n    bool public isLimitEnabled;\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == limitedWalletsManager);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if transfer between addresses is available\r\n     * @param _from From address\r\n     * @param _to To address\r\n     */\r\n    modifier canTransfer(address _from, address _to)  {\r\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev TransferLimitedToken constructor\r\n     * @param _limitStartDate Limit start date\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owners Owners list\r\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\r\n     */\r\n    function TransferLimitedToken(\r\n        uint256 _limitStartDate,\r\n        address _listener,\r\n        address[] _owners,\r\n        address _limitedWalletsManager\r\n    ) public ManagedToken(_listener, _owners)\r\n    {\r\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\r\n        isLimitEnabled = true;\r\n        limitedWalletsManager = _limitedWalletsManager;\r\n    }\r\n\r\n    /**\r\n     * @dev Add address to limitedWallets\r\n     * @dev Can be called only by manager\r\n     */\r\n    function addLimitedWalletAddress(address _wallet) public {\r\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\r\n        limitedWallets[_wallet] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Del address from limitedWallets\r\n     * @dev Can be called only by manager\r\n     */\r\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\r\n        limitedWallets[_wallet] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Disable transfer limit manually. Can be called only by manager\r\n     */\r\n    function disableLimit() public onlyManager {\r\n        isLimitEnabled = false;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\r\n        return super.approve(_spender,_value);\r\n    }\r\n}\r\n\r\n// File: contracts/Crowdsale.sol\r\n\r\ncontract TheAbyssDAICO is Ownable, SafeMath, Pausable, ISimpleCrowdsale {\r\n    enum AdditionalBonusState {\r\n        Unavailable,\r\n        Active,\r\n        Applied\r\n    }\r\n\r\n    uint256 public constant ADDITIONAL_BONUS_NUM = 3;\r\n    uint256 public constant ADDITIONAL_BONUS_DENOM = 100;\r\n\r\n    uint256 public constant ETHER_MIN_CONTRIB = 0.0002 ether;\r\n    uint256 public constant ETHER_MAX_CONTRIB = 20 ether;\r\n\r\n    uint256 public constant ETHER_MIN_CONTRIB_PRIVATE = 100 ether;\r\n    uint256 public constant ETHER_MAX_CONTRIB_PRIVATE = 3000 ether;\r\n\r\n    uint256 public constant ETHER_MIN_CONTRIB_USA = 0.0002 ether;\r\n    uint256 public constant ETHER_MAX_CONTRIB_USA = 20 ether;\r\n\r\n    uint256 public constant SALE_START_TIME = 1523904300; // 16.04.2018 14:00:00 UTC\r\n    uint256 public constant SALE_END_TIME = 1523906100; // 16.05.2018 14:00:00 UTC\r\n\r\n    uint256 public constant BONUS_WINDOW_1_END_TIME = SALE_START_TIME + 2 days;\r\n    uint256 public constant BONUS_WINDOW_2_END_TIME = SALE_START_TIME + 7 days;\r\n    uint256 public constant BONUS_WINDOW_3_END_TIME = SALE_START_TIME + 14 days;\r\n    uint256 public constant BONUS_WINDOW_4_END_TIME = SALE_START_TIME + 21 days;\r\n\r\n    uint256 public constant MAX_CONTRIB_CHECK_END_TIME = SALE_START_TIME + 1 days;\r\n\r\n    uint256 public constant BNB_TOKEN_PRICE_NUM = 169;\r\n    uint256 public constant BNB_TOKEN_PRICE_DENOM = 1;\r\n\r\n    uint256 public tokenPriceNum = 0;\r\n    uint256 public tokenPriceDenom = 0;\r\n    \r\n    TransferLimitedToken public token;\r\n    ICrowdsaleFund public fund;\r\n    ICrowdsaleReservationFund public reservationFund;\r\n    LockedTokensTest public lockedTokens;\r\n\r\n    mapping(address => bool) public whiteList;\r\n    mapping(address => bool) public privilegedList;\r\n    mapping(address => AdditionalBonusState) public additionalBonusOwnerState;\r\n    mapping(address => uint256) public userTotalContributed;\r\n\r\n    address public bnbTokenWallet;\r\n    address public referralTokenWallet;\r\n    address public foundationTokenWallet;\r\n    address public advisorsTokenWallet;\r\n    address public companyTokenWallet;\r\n    address public reserveTokenWallet;\r\n    address public bountyTokenWallet;\r\n\r\n    uint256 public totalEtherContributed = 0;\r\n    uint256 public rawTokenSupply = 0;\r\n\r\n    // BNB\r\n    IERC20Token public bnbToken;\r\n    uint256 public BNB_HARD_CAP = 300000 ether; // 300K BNB\r\n    uint256 public BNB_MIN_CONTRIB = 1000 ether; // 1K BNB\r\n    mapping(address => uint256) public bnbContributions;\r\n    uint256 public totalBNBContributed = 0;\r\n\r\n    uint256 public hardCap = 0; // World hard cap will be set right before Token Sale\r\n    uint256 public softCap = 0; // World soft cap will be set right before Token Sale\r\n\r\n    bool public bnbRefundEnabled = false;\r\n\r\n    event LogContribution(address contributor, uint256 amountWei, uint256 tokenAmount, uint256 tokenBonus, bool additionalBonusApplied, uint256 timestamp);\r\n    event ReservationFundContribution(address contributor, uint256 amountWei, uint256 tokensToIssue, uint256 bonusTokensToIssue, uint256 timestamp);\r\n    event LogBNBContribution(address contributor, uint256 amountBNB, uint256 tokenAmount, uint256 tokenBonus, bool additionalBonusApplied, uint256 timestamp);\r\n\r\n    modifier checkContribution() {\r\n        require(isValidContribution());\r\n        _;\r\n    }\r\n\r\n    modifier checkBNBContribution() {\r\n        require(isValidBNBContribution());\r\n        _;\r\n    }\r\n\r\n    modifier checkCap() {\r\n        require(validateCap());\r\n        _;\r\n    }\r\n\r\n    modifier checkTime() {\r\n        require(now >= SALE_START_TIME && now <= SALE_END_TIME);\r\n        _;\r\n    }\r\n\r\n    function TheAbyssDAICO(\r\n        address bnbTokenAddress,\r\n        address tokenAddress,\r\n        address fundAddress,\r\n        address reservationFundAddress,\r\n        address _bnbTokenWallet,\r\n        address _referralTokenWallet,\r\n        address _foundationTokenWallet,\r\n        address _advisorsTokenWallet,\r\n        address _companyTokenWallet,\r\n        address _reserveTokenWallet,\r\n        address _bountyTokenWallet,\r\n        address _owner\r\n    ) public\r\n        Ownable(_owner)\r\n    {\r\n        require(tokenAddress != address(0));\r\n\r\n        bnbToken = IERC20Token(bnbTokenAddress);\r\n        token = TransferLimitedToken(tokenAddress);\r\n        fund = ICrowdsaleFund(fundAddress);\r\n        reservationFund = ICrowdsaleReservationFund(reservationFundAddress);\r\n\r\n        bnbTokenWallet = _bnbTokenWallet;\r\n        referralTokenWallet = _referralTokenWallet;\r\n        foundationTokenWallet = _foundationTokenWallet;\r\n        advisorsTokenWallet = _advisorsTokenWallet;\r\n        companyTokenWallet = _companyTokenWallet;\r\n        reserveTokenWallet = _reserveTokenWallet;\r\n        bountyTokenWallet = _bountyTokenWallet;\r\n    }\r\n\r\n    /**\r\n     * @dev check if address can contribute\r\n     */\r\n    function isContributorInLists(address contributor) external view returns(bool) {\r\n        return whiteList[contributor] || privilegedList[contributor] || token.limitedWallets(contributor);\r\n    }\r\n\r\n    /**\r\n     * @dev check contribution amount and time\r\n     */\r\n    function isValidContribution() internal view returns(bool) {\r\n        uint256 currentUserContribution = safeAdd(msg.value, userTotalContributed[msg.sender]);\r\n        if(whiteList[msg.sender] && msg.value >= ETHER_MIN_CONTRIB) {\r\n            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB ) {\r\n                    return false;\r\n            }\r\n            return true;\r\n\r\n        }\r\n        if(privilegedList[msg.sender] && msg.value >= ETHER_MIN_CONTRIB_PRIVATE) {\r\n            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB_PRIVATE ) {\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if(token.limitedWallets(msg.sender) && msg.value >= ETHER_MIN_CONTRIB_USA) {\r\n            if(now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB_USA) {\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check hard cap overflow\r\n     */\r\n    function validateCap() internal view returns(bool){\r\n        if(msg.value <= safeSub(hardCap, totalEtherContributed)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Set token price once before start of crowdsale\r\n     */\r\n    function setTokenPrice(uint256 _tokenPriceNum, uint256 _tokenPriceDenom) public onlyOwner {\r\n        require(tokenPriceNum == 0 && tokenPriceDenom == 0);\r\n        require(_tokenPriceNum > 0 && _tokenPriceDenom > 0);\r\n        tokenPriceNum = _tokenPriceNum;\r\n        tokenPriceDenom = _tokenPriceDenom;\r\n    }\r\n\r\n    /**\r\n     * @dev Set hard cap.\r\n     * @param _hardCap - Hard cap value\r\n     */\r\n    function setHardCap(uint256 _hardCap) public onlyOwner {\r\n        require(hardCap == 0);\r\n        hardCap = _hardCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Set soft cap.\r\n     * @param _softCap - Soft cap value\r\n     */\r\n    function setSoftCap(uint256 _softCap) public onlyOwner {\r\n        require(softCap == 0);\r\n        softCap = _softCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Get soft cap amount\r\n     **/\r\n    function getSoftCap() external view returns(uint256) {\r\n        return softCap;\r\n    }\r\n\r\n    /**\r\n     * @dev Check bnb contribution time, amount and hard cap overflow\r\n     */\r\n    function isValidBNBContribution() internal view returns(bool) {\r\n        if(token.limitedWallets(msg.sender)) {\r\n            return false;\r\n        }\r\n        if(!whiteList[msg.sender] && !privilegedList[msg.sender]) {\r\n            return false;\r\n        }\r\n        uint256 amount = bnbToken.allowance(msg.sender, address(this));\r\n        if(amount < BNB_MIN_CONTRIB || safeAdd(totalBNBContributed, amount) > BNB_HARD_CAP) {\r\n            return false;\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Calc bonus amount by contribution time\r\n     */\r\n    function getBonus() internal constant returns (uint256, uint256) {\r\n        uint256 numerator = 0;\r\n        uint256 denominator = 100;\r\n\r\n        if(now < BONUS_WINDOW_1_END_TIME) {\r\n            numerator = 25;\r\n        } else if(now < BONUS_WINDOW_2_END_TIME) {\r\n            numerator = 15;\r\n        } else if(now < BONUS_WINDOW_3_END_TIME) {\r\n            numerator = 10;\r\n        } else if(now < BONUS_WINDOW_4_END_TIME) {\r\n            numerator = 5;\r\n        } else {\r\n            numerator = 0;\r\n        }\r\n\r\n        return (numerator, denominator);\r\n    }\r\n\r\n    function addToLists(\r\n        address _wallet,\r\n        bool isInWhiteList,\r\n        bool isInPrivilegedList,\r\n        bool isInLimitedList,\r\n        bool hasAdditionalBonus\r\n    ) public onlyOwner {\r\n        if(isInWhiteList) {\r\n            whiteList[_wallet] = true;\r\n        }\r\n        if(isInPrivilegedList) {\r\n            privilegedList[_wallet] = true;\r\n        }\r\n        if(isInLimitedList) {\r\n            token.addLimitedWalletAddress(_wallet);\r\n        }\r\n        if(hasAdditionalBonus) {\r\n            additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active;\r\n        }\r\n        if(reservationFund.canCompleteContribution(_wallet)) {\r\n            reservationFund.completeContribution(_wallet);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add wallet to whitelist. For contract owner only.\r\n     */\r\n    function addToWhiteList(address _wallet) public onlyOwner {\r\n        whiteList[_wallet] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Add wallet to additional bonus members. For contract owner only.\r\n     */\r\n    function addAdditionalBonusMember(address _wallet) public onlyOwner {\r\n        additionalBonusOwnerState[_wallet] = AdditionalBonusState.Active;\r\n    }\r\n\r\n    /**\r\n     * @dev Add wallet to privileged list. For contract owner only.\r\n     */\r\n    function addToPrivilegedList(address _wallet) public onlyOwner {\r\n        privilegedList[_wallet] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Set LockedTokens contract address\r\n     */\r\n    function setLockedTokens(address lockedTokensAddress) public onlyOwner {\r\n        lockedTokens = LockedTokensTest(lockedTokensAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function to receive ether contributions\r\n     */\r\n    function () payable public whenNotPaused {\r\n        if(whiteList[msg.sender] || privilegedList[msg.sender] || token.limitedWallets(msg.sender)) {\r\n            processContribution(msg.sender, msg.value);\r\n        } else {\r\n            processReservationContribution(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function processReservationContribution(address contributor, uint256 amount) private checkTime checkCap {\r\n        require(amount >= ETHER_MIN_CONTRIB);\r\n\r\n        if(now <= MAX_CONTRIB_CHECK_END_TIME) {\r\n            uint256 currentUserContribution = safeAdd(amount, reservationFund.contributionsOf(contributor));\r\n            require(currentUserContribution <= ETHER_MAX_CONTRIB);\r\n        }\r\n        uint256 bonusNum = 0;\r\n        uint256 bonusDenom = 100;\r\n        (bonusNum, bonusDenom) = getBonus();\r\n        uint256 tokenBonusAmount = 0;\r\n        uint256 tokenAmount = safeDiv(safeMul(amount, tokenPriceNum), tokenPriceDenom);\r\n\r\n        if(bonusNum > 0) {\r\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\r\n        }\r\n\r\n        reservationFund.processContribution.value(amount)(\r\n            contributor,\r\n            tokenAmount,\r\n            tokenBonusAmount\r\n        );\r\n        ReservationFundContribution(contributor, amount, tokenAmount, tokenBonusAmount, now);\r\n    }\r\n\r\n    /**\r\n     * @dev Process BNB token contribution\r\n     * Transfer all amount of tokens approved by sender. Calc bonuses and issue tokens to contributor.\r\n     */\r\n    function processBNBContribution() public whenNotPaused checkTime checkBNBContribution {\r\n        bool additionalBonusApplied = false;\r\n        uint256 bonusNum = 0;\r\n        uint256 bonusDenom = 100;\r\n        (bonusNum, bonusDenom) = getBonus();\r\n        uint256 amountBNB = bnbToken.allowance(msg.sender, address(this));\r\n        bnbToken.transferFrom(msg.sender, address(this), amountBNB);\r\n        bnbContributions[msg.sender] = safeAdd(bnbContributions[msg.sender], amountBNB);\r\n\r\n        uint256 tokenBonusAmount = 0;\r\n        uint256 tokenAmount = safeDiv(safeMul(amountBNB, BNB_TOKEN_PRICE_NUM), BNB_TOKEN_PRICE_DENOM);\r\n        rawTokenSupply = safeAdd(rawTokenSupply, tokenAmount);\r\n        if(bonusNum > 0) {\r\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\r\n        }\r\n\r\n        if(additionalBonusOwnerState[msg.sender] ==  AdditionalBonusState.Active) {\r\n            additionalBonusOwnerState[msg.sender] = AdditionalBonusState.Applied;\r\n            uint256 additionalBonus = safeDiv(safeMul(tokenAmount, ADDITIONAL_BONUS_NUM), ADDITIONAL_BONUS_DENOM);\r\n            tokenBonusAmount = safeAdd(tokenBonusAmount, additionalBonus);\r\n            additionalBonusApplied = true;\r\n        }\r\n\r\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\r\n        token.issue(msg.sender, tokenTotalAmount);\r\n        totalBNBContributed = safeAdd(totalBNBContributed, amountBNB);\r\n\r\n        LogBNBContribution(msg.sender, amountBNB, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\r\n    }\r\n\r\n    /**\r\n     * @dev Process ether contribution. Calc bonuses and issue tokens to contributor.\r\n     */\r\n    function processContribution(address contributor, uint256 amount) private checkTime checkContribution checkCap {\r\n        bool additionalBonusApplied = false;\r\n        uint256 bonusNum = 0;\r\n        uint256 bonusDenom = 100;\r\n        (bonusNum, bonusDenom) = getBonus();\r\n        uint256 tokenBonusAmount = 0;\r\n\r\n        uint256 tokenAmount = safeDiv(safeMul(amount, tokenPriceNum), tokenPriceDenom);\r\n        rawTokenSupply = safeAdd(rawTokenSupply, tokenAmount);\r\n\r\n        if(bonusNum > 0) {\r\n            tokenBonusAmount = safeDiv(safeMul(tokenAmount, bonusNum), bonusDenom);\r\n        }\r\n\r\n        if(additionalBonusOwnerState[contributor] ==  AdditionalBonusState.Active) {\r\n            additionalBonusOwnerState[contributor] = AdditionalBonusState.Applied;\r\n            uint256 additionalBonus = safeDiv(safeMul(tokenAmount, ADDITIONAL_BONUS_NUM), ADDITIONAL_BONUS_DENOM);\r\n            tokenBonusAmount = safeAdd(tokenBonusAmount, additionalBonus);\r\n            additionalBonusApplied = true;\r\n        }\r\n\r\n        processPayment(contributor, amount, tokenAmount, tokenBonusAmount, additionalBonusApplied);\r\n    }\r\n\r\n    /**\r\n     * @dev Process ether contribution before KYC. Calc bonuses and tokens to issue after KYC.\r\n     */\r\n    function processReservationFundContribution(\r\n        address contributor,\r\n        uint256 tokenAmount,\r\n        uint256 tokenBonusAmount\r\n    ) external payable checkCap {\r\n        require(msg.sender == address(reservationFund));\r\n        require(msg.value > 0);\r\n\r\n        processPayment(contributor, msg.value, tokenAmount, tokenBonusAmount, false);\r\n    }\r\n\r\n    function processPayment(address contributor, uint256 etherAmount, uint256 tokenAmount, uint256 tokenBonusAmount, bool additionalBonusApplied) internal {\r\n        uint256 tokenTotalAmount = safeAdd(tokenAmount, tokenBonusAmount);\r\n\r\n        token.issue(contributor, tokenTotalAmount);\r\n        fund.processContribution.value(etherAmount)(contributor);\r\n        totalEtherContributed = safeAdd(totalEtherContributed, etherAmount);\r\n        userTotalContributed[contributor] = safeAdd(userTotalContributed[contributor], etherAmount);\r\n        LogContribution(contributor, etherAmount, tokenAmount, tokenBonusAmount, additionalBonusApplied, now);\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize crowdsale if we reached hard cap or current time > SALE_END_TIME\r\n     */\r\n    function finalizeCrowdsale() public onlyOwner {\r\n        if(\r\n            (totalEtherContributed >= safeSub(hardCap, 20 ether) && totalBNBContributed >= safeSub(BNB_HARD_CAP, 10000 ether)) ||\r\n            (now >= SALE_END_TIME && totalEtherContributed >= softCap)\r\n        ) {\r\n            fund.onCrowdsaleEnd();\r\n            reservationFund.onCrowdsaleEnd();\r\n            // BNB transfer\r\n            bnbToken.transfer(bnbTokenWallet, bnbToken.balanceOf(address(this)));\r\n\r\n            // Referral\r\n            uint256 referralTokenAmount = safeDiv(rawTokenSupply, 10);\r\n            token.issue(referralTokenWallet, referralTokenAmount);\r\n\r\n            // Foundation\r\n            uint256 foundationTokenAmount = safeDiv(token.totalSupply(), 2); // 20%\r\n            lockedTokens.addTokens(foundationTokenWallet, foundationTokenAmount, now + 365 days);\r\n\r\n            uint256 suppliedTokenAmount = token.totalSupply();\r\n\r\n            // Reserve\r\n            uint256 reservedTokenAmount = safeDiv(safeMul(suppliedTokenAmount, 3), 10); // 18%\r\n            token.issue(address(lockedTokens), reservedTokenAmount);\r\n            lockedTokens.addTokens(reserveTokenWallet, reservedTokenAmount, now + 183 days);\r\n\r\n            // Advisors\r\n            uint256 advisorsTokenAmount = safeDiv(suppliedTokenAmount, 10); // 6%\r\n            token.issue(advisorsTokenWallet, advisorsTokenAmount);\r\n\r\n            // Company\r\n            uint256 companyTokenAmount = safeDiv(suppliedTokenAmount, 4); // 15%\r\n            token.issue(address(lockedTokens), companyTokenAmount);\r\n            lockedTokens.addTokens(companyTokenWallet, companyTokenAmount, now + 730 days);\r\n\r\n            // Bounty\r\n            uint256 bountyTokenAmount = safeDiv(suppliedTokenAmount, 60); // 1%\r\n            token.issue(bountyTokenWallet, bountyTokenAmount);\r\n\r\n            token.setAllowTransfers(true);\r\n\r\n        } else if(now >= SALE_END_TIME) {\r\n            // Enable fund`s crowdsale refund if soft cap is not reached\r\n            fund.enableCrowdsaleRefund();\r\n            reservationFund.onCrowdsaleEnd();\r\n            bnbRefundEnabled = true;\r\n        }\r\n        token.finishIssuance();\r\n    }\r\n\r\n    /**\r\n     * @dev Function is called by contributor to refund BNB token payments if crowdsale failed to reach soft cap\r\n     */\r\n    function refundBNBContributor() public {\r\n        require(bnbRefundEnabled);\r\n        require(bnbContributions[msg.sender] > 0);\r\n        uint256 amount = bnbContributions[msg.sender];\r\n        bnbContributions[msg.sender] = 0;\r\n        bnbToken.transfer(msg.sender, amount);\r\n        token.destroy(msg.sender, token.balanceOf(msg.sender));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"BNB_HARD_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bnbTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"privilegedList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_MIN_CONTRIB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_MAX_CONTRIB_PRIVATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bnbToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rawTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNB_TOKEN_PRICE_DENOM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"tokenBonusAmount\",\"type\":\"uint256\"}],\"name\":\"processReservationFundContribution\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bnbContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALE_START_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addToWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSoftCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addToPrivilegedList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"processBNBContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDITIONAL_BONUS_DENOM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addAdditionalBonusMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"isInWhiteList\",\"type\":\"bool\"},{\"name\":\"isInPrivilegedList\",\"type\":\"bool\"},{\"name\":\"isInLimitedList\",\"type\":\"bool\"},{\"name\":\"hasAdditionalBonus\",\"type\":\"bool\"}],\"name\":\"addToLists\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNB_TOKEN_PRICE_NUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundBNBContributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_WINDOW_4_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contributor\",\"type\":\"address\"}],\"name\":\"isContributorInLists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CONTRIB_CHECK_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundationTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBNBContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_MIN_CONTRIB_USA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"additionalBonusOwnerState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_MIN_CONTRIB_PRIVATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lockedTokensAddress\",\"type\":\"address\"}],\"name\":\"setLockedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDITIONAL_BONUS_NUM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservationFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hardCap\",\"type\":\"uint256\"}],\"name\":\"setHardCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_softCap\",\"type\":\"uint256\"}],\"name\":\"setSoftCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_WINDOW_2_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_WINDOW_1_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNB_MIN_CONTRIB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorsTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_MAX_CONTRIB_USA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenPriceNum\",\"type\":\"uint256\"},{\"name\":\"_tokenPriceDenom\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bnbRefundEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyTokenWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHER_MAX_CONTRIB\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceDenom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_WINDOW_3_END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"bnbTokenAddress\",\"type\":\"address\"},{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"fundAddress\",\"type\":\"address\"},{\"name\":\"reservationFundAddress\",\"type\":\"address\"},{\"name\":\"_bnbTokenWallet\",\"type\":\"address\"},{\"name\":\"_referralTokenWallet\",\"type\":\"address\"},{\"name\":\"_foundationTokenWallet\",\"type\":\"address\"},{\"name\":\"_advisorsTokenWallet\",\"type\":\"address\"},{\"name\":\"_companyTokenWallet\",\"type\":\"address\"},{\"name\":\"_reserveTokenWallet\",\"type\":\"address\"},{\"name\":\"_bountyTokenWallet\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"additionalBonusApplied\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LogContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensToIssue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusTokensToIssue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ReservationFundContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"additionalBonusApplied\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LogBNBContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TheAbyssDAICO","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b8c77482e45f1f44de1745f52c74426c631bdd52000000000000000000000000c979370c6f6f6850099c2f8d6cfd97e9ffd1ef21000000000000000000000000a05237d6caf35ab0c1142a904bcf0ddfc7a4e261000000000000000000000000d994738b14c78df7a774d32f44a4b579daee9aed0000000000000000000000003910bd425f902c9d52044fb79ca2948feb463e8b0000000000000000000000003910bd425f902c9d52044fb79ca2948feb463e8b0000000000000000000000003910bd425f902c9d52044fb79ca2948feb463e8b0000000000000000000000003910bd425f902c9d52044fb79ca2948feb463e8b0000000000000000000000003910bd425f902c9d52044fb79ca2948feb463e8b0000000000000000000000003910bd425f902c9d52044fb79ca2948feb463e8b0000000000000000000000003910bd425f902c9d52044fb79ca2948feb463e8b0000000000000000000000003910bd425f902c9d52044fb79ca2948feb463e8b","Library":"","SwarmSource":"bzzr://74c46f1f296dfc146f2b43bace40d821198add9f6f4b4e64e20fd5698feb1efb"}]}