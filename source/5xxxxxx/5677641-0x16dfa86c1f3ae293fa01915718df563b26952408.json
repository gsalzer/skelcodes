{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\ncontract SafeMath{\r\n\r\n  // math operations with safety checks that throw on error\r\n  // small gas improvement\r\n\r\n  function safeMul(uint256 a, uint256 b) internal returns (uint256){\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n  \r\n  function safeDiv(uint256 a, uint256 b) internal returns (uint256){\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n  \r\n  function safeSub(uint256 a, uint256 b) internal returns (uint256){\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  \r\n  function safeAdd(uint256 a, uint256 b) internal returns (uint256){\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  // mitigate short address attack\r\n  // https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34\r\n  modifier onlyPayloadSize(uint numWords){\r\n     assert(msg.data.length >= numWords * 32 + 4);\r\n     _;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract Token{ // ERC20 standard\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is Token, SafeMath{\r\n\r\n    uint256 public totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2) returns (bool success){\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value && _value > 0);\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) returns (bool success){\r\n        require(_to != address(0));\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance){\r\n        return balances[_owner];\r\n    }\r\n    \r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    function approve(address _spender, uint256 _value) onlyPayloadSize(2) returns (bool success){\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) returns (bool success){\r\n        require(allowed[msg.sender][_spender] == _oldValue);\r\n        allowed[msg.sender][_spender] = _newValue;\r\n        Approval(msg.sender, _spender, _newValue);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining){\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // this creates an array with all balances\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n}\r\n\r\n\r\ncontract EDEX is StandardToken{\r\n\r\n    // public variables of the token\r\n\r\n    string public name = \"Equadex\";\r\n    string public symbol = \"EDEX\";\r\n    uint256 public decimals = 18;\r\n    \r\n    // reachable if max amount raised\r\n    uint256 public maxSupply = 100000000e18;\r\n    \r\n    // ICO starting and ending blocks, can be changed as needed\r\n    uint256 public icoStartBlock;\r\n    // icoEndBlock = icoStartBlock + 345,600 blocks for 2 months ICO\r\n    uint256 public icoEndBlock;\r\n\r\n    // set the wallets with different levels of authority\r\n    address public mainWallet;\r\n    address public secondaryWallet;\r\n    \r\n    // time to wait between secondaryWallet price updates, mainWallet can update without restrictions\r\n    uint256 public priceUpdateWaitingTime = 1 hours;\r\n\r\n    uint256 public previousUpdateTime = 0;\r\n    \r\n    // strucure of price\r\n    PriceEDEX public currentPrice;\r\n    uint256 public minInvestment = 0.01 ether;\r\n    \r\n    // for tokens allocated to the team\r\n    address public grantVestedEDEXContract;\r\n    bool private grantVestedEDEXSet = false;\r\n    \r\n    // halt the crowdsale should any suspicious behavior of a third-party be identified\r\n    // tokens will be locked for trading until they are listed on exchanges\r\n    bool public haltICO = false;\r\n    bool public setTrading = false;\r\n\r\n    // maps investor address to a liquidation request\r\n    mapping (address => Liquidation) public liquidations;\r\n    // maps previousUpdateTime to the next price\r\n    mapping (uint256 => PriceEDEX) public prices;\r\n    // maps verified addresses\r\n    mapping (address => bool) public verified;\r\n\r\n    event Verification(address indexed investor);\r\n    event LiquidationCall(address indexed investor, uint256 amountTokens);\r\n    event Liquidations(address indexed investor, uint256 amountTokens, uint256 etherAmount);\r\n    event Buy(address indexed investor, address indexed beneficiary, uint256 ethValue, uint256 amountTokens);\r\n    event PrivateSale(address indexed investor, uint256 amountTokens);\r\n    event PriceEDEXUpdate(uint256 topInteger, uint256 bottomInteger);\r\n    event AddLiquidity(uint256 etherAmount);\r\n    event RemoveLiquidity(uint256 etherAmount);\r\n    \r\n    // for price updates as a rational number\r\n    struct PriceEDEX{\r\n        uint256 topInteger;\r\n        uint256 bottomInteger;\r\n    }\r\n\r\n    struct Liquidation{\r\n        uint256 tokens;\r\n        uint256 time;\r\n    }\r\n\r\n    // grantVestedEDEXContract and mainWallet can transfer to allow team allocations\r\n    modifier isSetTrading{\r\n        require(setTrading || msg.sender == mainWallet || msg.sender == grantVestedEDEXContract);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVerified{\r\n        require(verified[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMainWallet{\r\n        require(msg.sender == mainWallet);\r\n        _;\r\n    }\r\n\r\n    modifier onlyControllingWallets{\r\n        require(msg.sender == secondaryWallet || msg.sender == mainWallet);\r\n        _;\r\n    }\r\n\r\n    modifier only_if_secondaryWallet{\r\n        if (msg.sender == secondaryWallet) _;\r\n    }\r\n    modifier require_waited{\r\n        require(safeSub(now, priceUpdateWaitingTime) >= previousUpdateTime);\r\n        _;\r\n    }\r\n    modifier only_if_increase (uint256 newTopInteger){\r\n        if (newTopInteger > currentPrice.topInteger) _;\r\n    }\r\n\r\n    function EDEX(address secondaryWalletInput, uint256 priceTopIntegerInput, uint256 startBlockInput, uint256 endBlockInput){\r\n        require(secondaryWalletInput != address(0));\r\n        require(endBlockInput > startBlockInput);\r\n        require(priceTopIntegerInput > 0);\r\n        mainWallet = msg.sender;\r\n        secondaryWallet = secondaryWalletInput;\r\n        verified[mainWallet] = true;\r\n        verified[secondaryWallet] = true;\r\n        // priceTopIntegerInput = 800,000 for 1 ETH = 800 EDEX\r\n        currentPrice = PriceEDEX(priceTopIntegerInput, 1000);\r\n        // icoStartBlock should be around block number 5,709,200 = June 1st 2018\r\n        icoStartBlock = startBlockInput;\r\n        // icoEndBlock = icoStartBlock + 345,600 blocks\r\n        icoEndBlock = endBlockInput;\r\n        previousUpdateTime = now;\r\n    }\r\n\r\n    function setGrantVestedEDEXContract(address grantVestedEDEXContractInput) external onlyMainWallet{\r\n        require(grantVestedEDEXContractInput != address(0));\r\n        grantVestedEDEXContract = grantVestedEDEXContractInput;\r\n        verified[grantVestedEDEXContract] = true;\r\n        grantVestedEDEXSet = true;\r\n    }\r\n\r\n    function updatePriceEDEX(uint256 newTopInteger) external onlyControllingWallets{\r\n        require(newTopInteger > 0);\r\n        require_limited_change(newTopInteger);\r\n        currentPrice.topInteger = newTopInteger;\r\n        // maps time to new PriceEDEX\r\n        prices[previousUpdateTime] = currentPrice;\r\n        previousUpdateTime = now;\r\n        PriceEDEXUpdate(newTopInteger, currentPrice.bottomInteger);\r\n    }\r\n\r\n    function require_limited_change (uint256 newTopInteger) private only_if_secondaryWallet require_waited only_if_increase(newTopInteger){\r\n        uint256 percentage_diff = 0;\r\n        percentage_diff = safeMul(newTopInteger, 100) / currentPrice.topInteger;\r\n        percentage_diff = safeSub(percentage_diff, 100);\r\n        // secondaryWallet can increase price by 20% maximum once every priceUpdateWaitingTime\r\n        require(percentage_diff <= 20);\r\n    }\r\n\r\n    function updatePriceBottomInteger(uint256 newBottomInteger) external onlyMainWallet{\r\n        require(block.number > icoEndBlock);\r\n        require(newBottomInteger > 0);\r\n        currentPrice.bottomInteger = newBottomInteger;\r\n        // maps time to new Price\r\n        prices[previousUpdateTime] = currentPrice;\r\n        previousUpdateTime = now;\r\n        PriceEDEXUpdate(currentPrice.topInteger, newBottomInteger);\r\n    }\r\n\r\n    function tokenAllocation(address investor, uint256 amountTokens) private{\r\n        require(grantVestedEDEXSet);\r\n        // the 15% allocated to the team\r\n        uint256 teamAllocation = safeMul(amountTokens, 1764705882352941) / 1e16;\r\n        uint256 newTokens = safeAdd(amountTokens, teamAllocation);\r\n        require(safeAdd(totalSupply, newTokens) <= maxSupply);\r\n        totalSupply = safeAdd(totalSupply, newTokens);\r\n        balances[investor] = safeAdd(balances[investor], amountTokens);\r\n        balances[grantVestedEDEXContract] = safeAdd(balances[grantVestedEDEXContract], teamAllocation);\r\n    }\r\n\r\n    function privateSaleTokens(address investor, uint amountTokens) external onlyMainWallet{\r\n        require(block.number < icoEndBlock);\r\n        require(investor != address(0));\r\n        verified[investor] = true;\r\n        tokenAllocation(investor, amountTokens);\r\n        Verification(investor);\r\n        PrivateSale(investor, amountTokens);\r\n    }\r\n\r\n    function verifyInvestor(address investor) external onlyControllingWallets{\r\n        verified[investor] = true;\r\n        Verification(investor);\r\n    }\r\n    \r\n    // blacklists bot addresses using ICO whitelisted addresses\r\n    function removeVerifiedInvestor(address investor) external onlyControllingWallets{\r\n        verified[investor] = false;\r\n        Verification(investor);\r\n    }\r\n\r\n    function buy() external payable{\r\n        buyTo(msg.sender);\r\n    }\r\n\r\n    function buyTo(address investor) public payable onlyVerified{\r\n        require(!haltICO);\r\n        require(investor != address(0));\r\n        require(msg.value >= minInvestment);\r\n        require(block.number >= icoStartBlock && block.number < icoEndBlock);\r\n        uint256 icoBottomInteger = icoBottomIntegerPrice();\r\n        uint256 tokensToBuy = safeMul(msg.value, currentPrice.topInteger) / icoBottomInteger;\r\n        tokenAllocation(investor, tokensToBuy);\r\n        // send ether to mainWallet\r\n        mainWallet.transfer(msg.value);\r\n        Buy(msg.sender, investor, msg.value, tokensToBuy);\r\n    }\r\n\r\n    // bonus scheme during ICO, 1 ETH = 800 EDEX for 1st 20 days, 1 ETH = 727 EDEX for 2nd 20 days, 1 ETH = 667 EDEX for 3rd 20 days\r\n    function icoBottomIntegerPrice() public constant returns (uint256){\r\n        uint256 icoDuration = safeSub(block.number, icoStartBlock);\r\n        uint256 bottomInteger;\r\n        // icoDuration < 115,200 blocks = 20 days\r\n        if (icoDuration < 100){\r\n            return currentPrice.bottomInteger;\r\n        }\r\n        // icoDuration < 230,400 blocks = 40 days\r\n        else if (icoDuration < 200 ){\r\n            bottomInteger = safeMul(currentPrice.bottomInteger, 110) / 100;\r\n            return bottomInteger;\r\n        }\r\n        else{\r\n            bottomInteger = safeMul(currentPrice.bottomInteger, 120) / 100;\r\n            return bottomInteger;\r\n        }\r\n    }\r\n\r\n    // change ICO starting date if more time needed for preparation\r\n    function changeIcoStartBlock(uint256 newIcoStartBlock) external onlyMainWallet{\r\n        require(block.number < icoStartBlock);\r\n        require(block.number < newIcoStartBlock);\r\n        icoStartBlock = newIcoStartBlock;\r\n    }\r\n\r\n    function changeIcoEndBlock(uint256 newIcoEndBlock) external onlyMainWallet{\r\n        require(block.number < icoEndBlock);\r\n        require(block.number < newIcoEndBlock);\r\n        icoEndBlock = newIcoEndBlock;\r\n    }\r\n\r\n    function changePriceUpdateWaitingTime(uint256 newPriceUpdateWaitingTime) external onlyMainWallet{\r\n        priceUpdateWaitingTime = newPriceUpdateWaitingTime;\r\n    }\r\n\r\n    function requestLiquidation(uint256 amountTokensToLiquidate) external isSetTrading onlyVerified{\r\n        require(block.number > icoEndBlock);\r\n        require(amountTokensToLiquidate > 0);\r\n        address investor = msg.sender;\r\n        require(balanceOf(investor) >= amountTokensToLiquidate);\r\n        require(liquidations[investor].tokens == 0);\r\n        balances[investor] = safeSub(balances[investor], amountTokensToLiquidate);\r\n        liquidations[investor] = Liquidation({tokens: amountTokensToLiquidate, time: previousUpdateTime});\r\n        LiquidationCall(investor, amountTokensToLiquidate);\r\n    }\r\n\r\n    function liquidate() external{\r\n        address investor = msg.sender;\r\n        uint256 tokens = liquidations[investor].tokens;\r\n        require(tokens > 0);\r\n        uint256 requestTime = liquidations[investor].time;\r\n        // obtain the next price that was set after the request\r\n        PriceEDEX storage price = prices[requestTime];\r\n        require(price.topInteger > 0);\r\n        uint256 liquidationValue = safeMul(tokens, price.bottomInteger) / price.topInteger;\r\n        // if there is enough ether on the contract, proceed. Otherwise, send back tokens\r\n        liquidations[investor].tokens = 0;\r\n        if (this.balance >= liquidationValue)\r\n            enact_liquidation_greater_equal(investor, liquidationValue, tokens);\r\n        else\r\n            enact_liquidation_less(investor, liquidationValue, tokens);\r\n    }\r\n\r\n    function enact_liquidation_greater_equal(address investor, uint256 liquidationValue, uint256 tokens) private{\r\n        assert(this.balance >= liquidationValue);\r\n        balances[mainWallet] = safeAdd(balances[mainWallet], tokens);\r\n        investor.transfer(liquidationValue);\r\n        Liquidations(investor, tokens, liquidationValue);\r\n    }\r\n    \r\n    function enact_liquidation_less(address investor, uint256 liquidationValue, uint256 tokens) private{\r\n        assert(this.balance < liquidationValue);\r\n        balances[investor] = safeAdd(balances[investor], tokens);\r\n        Liquidations(investor, tokens, 0);\r\n    }\r\n\r\n    function checkLiquidationValue(uint256 amountTokensToLiquidate) constant returns (uint256 etherValue){\r\n        require(amountTokensToLiquidate > 0);\r\n        require(balanceOf(msg.sender) >= amountTokensToLiquidate);\r\n        uint256 liquidationValue = safeMul(amountTokensToLiquidate, currentPrice.bottomInteger) / currentPrice.topInteger;\r\n        require(this.balance >= liquidationValue);\r\n        return liquidationValue;\r\n    }\r\n\r\n    // add liquidity to contract for investor liquidation\r\n    function addLiquidity() external onlyControllingWallets payable{\r\n        require(msg.value > 0);\r\n        AddLiquidity(msg.value);\r\n    }\r\n\r\n    // remove liquidity from contract\r\n    function removeLiquidity(uint256 amount) external onlyControllingWallets{\r\n        require(amount <= this.balance);\r\n        mainWallet.transfer(amount);\r\n        RemoveLiquidity(amount);\r\n    }\r\n\r\n    function changeMainWallet(address newMainWallet) external onlyMainWallet{\r\n        require(newMainWallet != address(0));\r\n        mainWallet = newMainWallet;\r\n    }\r\n\r\n    function changeSecondaryWallet(address newSecondaryWallet) external onlyMainWallet{\r\n        require(newSecondaryWallet != address(0));\r\n        secondaryWallet = newSecondaryWallet;\r\n    }\r\n\r\n    function enableTrading() external onlyMainWallet{\r\n        require(block.number > icoEndBlock);\r\n        setTrading = true;\r\n    }\r\n\r\n    function claimEDEX(address _token) external onlyMainWallet{\r\n        require(_token != address(0));\r\n        Token token = Token(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(mainWallet, balance);\r\n     }\r\n\r\n    // disable transfers and allow them once token is tradeable\r\n    function transfer(address _to, uint256 _value) isSetTrading returns (bool success){\r\n        return super.transfer(_to, _value);\r\n    }\r\n    function transferFrom(address _from, address _to, uint256 _value) isSetTrading returns (bool success){\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function haltICO() external onlyMainWallet{\r\n        haltICO = true;\r\n    }\r\n    \r\n    function unhaltICO() external onlyMainWallet{\r\n        haltICO = false;\r\n    }\r\n    \r\n    // fallback function\r\n    function() payable{\r\n        require(tx.origin == msg.sender);\r\n        buyTo(msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"unhaltICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"verified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"haltICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"removeVerifiedInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBottomInteger\",\"type\":\"uint256\"}],\"name\":\"updatePriceBottomInteger\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mainWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"liquidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousUpdateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMainWallet\",\"type\":\"address\"}],\"name\":\"changeMainWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoEndBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"privateSaleTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceUpdateWaitingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newIcoEndBlock\",\"type\":\"uint256\"}],\"name\":\"changeIcoEndBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setTrading\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimEDEX\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newIcoStartBlock\",\"type\":\"uint256\"}],\"name\":\"changeIcoStartBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_oldValue\",\"type\":\"uint256\"},{\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"changeApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidations\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountTokensToLiquidate\",\"type\":\"uint256\"}],\"name\":\"requestLiquidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"topInteger\",\"type\":\"uint256\"},{\"name\":\"bottomInteger\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amountTokensToLiquidate\",\"type\":\"uint256\"}],\"name\":\"checkLiquidationValue\",\"outputs\":[{\"name\":\"etherValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPriceUpdateWaitingTime\",\"type\":\"uint256\"}],\"name\":\"changePriceUpdateWaitingTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prices\",\"outputs\":[{\"name\":\"topInteger\",\"type\":\"uint256\"},{\"name\":\"bottomInteger\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTopInteger\",\"type\":\"uint256\"}],\"name\":\"updatePriceEDEX\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecondaryWallet\",\"type\":\"address\"}],\"name\":\"changeSecondaryWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoBottomIntegerPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"verifyInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"grantVestedEDEXContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"buyTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"grantVestedEDEXContractInput\",\"type\":\"address\"}],\"name\":\"setGrantVestedEDEXContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondaryWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"secondaryWalletInput\",\"type\":\"address\"},{\"name\":\"priceTopIntegerInput\",\"type\":\"uint256\"},{\"name\":\"startBlockInput\",\"type\":\"uint256\"},{\"name\":\"endBlockInput\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"Verification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"LiquidationCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"Liquidations\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"PrivateSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"topInteger\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bottomInteger\",\"type\":\"uint256\"}],\"name\":\"PriceEDEXUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"EDEX","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000019dd20f92842754c26b9eaaada3e166b2d465c0000000000000000000000000000000000000000000000000000000000000c35000000000000000000000000000000000000000000000000000000000000571d9000000000000000000000000000000000000000000000000000000000005c74c0","Library":"","SwarmSource":"bzzr://2a79eac9eb605123d74cc53108c3f316d783001e335ccbd9e0e22d0bd497052b"}]}