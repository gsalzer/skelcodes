{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Deed Standard\r\n/// @author William Entriken (https://phor.net), et. al.\r\n/// @dev Specification at https://github.com/ethereum/eips/XXXFinalUrlXXX\r\ninterface ERC721 {\r\n\r\n    // COMPLIANCE WITH ERC-165 (DRAFT) /////////////////////////////////////////\r\n\r\n    /// @dev ERC-165 (draft) interface signature for itself\r\n    // bytes4 internal constant INTERFACE_SIGNATURE_ERC165 = // 0x01ffc9a7\r\n    //     bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    /// @dev ERC-165 (draft) interface signature for ERC721\r\n    // bytes4 internal constant INTERFACE_SIGNATURE_ERC721 = // 0xda671b9b\r\n    //     bytes4(keccak256('ownerOf(uint256)')) ^\r\n    //     bytes4(keccak256('countOfDeeds()')) ^\r\n    //     bytes4(keccak256('countOfDeedsByOwner(address)')) ^\r\n    //     bytes4(keccak256('deedOfOwnerByIndex(address,uint256)')) ^\r\n    //     bytes4(keccak256('approve(address,uint256)')) ^\r\n    //     bytes4(keccak256('takeOwnership(uint256)'));\r\n\r\n    /// @notice Query a contract to see if it supports a certain interface\r\n    /// @dev Returns `true` the interface is supported and `false` otherwise,\r\n    ///  returns `true` for INTERFACE_SIGNATURE_ERC165 and\r\n    ///  INTERFACE_SIGNATURE_ERC721, see ERC-165 for other interface signatures.\r\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool);\r\n\r\n    // PUBLIC QUERY FUNCTIONS //////////////////////////////////////////////////\r\n\r\n    /// @notice Find the owner of a deed\r\n    /// @param _deedId The identifier for a deed we are inspecting\r\n    /// @dev Deeds assigned to zero address are considered invalid, and\r\n    ///  queries about them do throw.\r\n    /// @return The non-zero address of the owner of deed `_deedId`, or `throw`\r\n    ///  if deed `_deedId` is not tracked by this contract\r\n    function ownerOf(uint256 _deedId) external view returns (address _owner);\r\n\r\n    /// @notice Count deeds tracked by this contract\r\n    /// @return A count of valid deeds tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function countOfDeeds() external view returns (uint256 _count);\r\n\r\n    /// @notice Count all deeds assigned to an owner\r\n    /// @dev Throws if `_owner` is the zero address, representing invalid deeds.\r\n    /// @param _owner An address where we are interested in deeds owned by them\r\n    /// @return The number of deeds owned by `_owner`, possibly zero\r\n    function countOfDeedsByOwner(address _owner) external view returns (uint256 _count);\r\n\r\n    /// @notice Enumerate deeds assigned to an owner\r\n    /// @dev Throws if `_index` >= `countOfDeedsByOwner(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid deeds.\r\n    /// @param _owner An address where we are interested in deeds owned by them\r\n    /// @param _index A counter less than `countOfDeedsByOwner(_owner)`\r\n    /// @return The identifier for the `_index`th deed assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId);\r\n\r\n    // TRANSFER MECHANISM //////////////////////////////////////////////////////\r\n\r\n    /// @dev This event emits when ownership of any deed changes by any\r\n    ///  mechanism. This event emits when deeds are created (`from` == 0) and\r\n    ///  destroyed (`to` == 0). Exception: during contract creation, any\r\n    ///  transfers may occur without emitting `Transfer`. At the time of any transfer,\r\n    ///  the \"approved taker\" is implicitly reset to the zero address.\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed deedId);\r\n\r\n    /// @dev The Approve event emits to log the \"approved taker\" for a deed -- whether\r\n    ///  set for the first time, reaffirmed by setting the same value, or setting to\r\n    ///  a new value. The \"approved taker\" is the zero address if nobody can take the\r\n    ///  deed now or it is an address if that address can call `takeOwnership` to attempt\r\n    ///  taking the deed. Any change to the \"approved taker\" for a deed SHALL cause\r\n    ///  Approve to emit. However, an exception, the Approve event will not emit when\r\n    ///  Transfer emits, this is because Transfer implicitly denotes the \"approved taker\"\r\n    ///  is reset to the zero address.\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed deedId);\r\n\r\n    /// @notice Set the \"approved taker\" for your deed, or revoke approval by\r\n    ///  setting the zero address. You may `approve` any number of times while\r\n    ///  the deed is assigned to you, only the most recent approval matters. Emits\r\n    ///  an Approval event.\r\n    /// @dev Throws if `msg.sender` does not own deed `_deedId` or if `_to` ==\r\n    ///  `msg.sender` or if `_deedId` is not a valid deed.\r\n    /// @param _deedId The deed for which you are granting approval\r\n    function approve(address _to, uint256 _deedId) external payable;\r\n\r\n    /// @notice Become owner of a deed for which you are currently approved\r\n    /// @dev Throws if `msg.sender` is not approved to become the owner of\r\n    ///  `deedId` or if `msg.sender` currently owns `_deedId` or if `_deedId is not a\r\n    ///  valid deed.\r\n    /// @param _deedId The deed that is being transferred\r\n    function takeOwnership(uint256 _deedId) external payable;\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract MonsterAccessControl {\r\n    event ContractUpgrade(address newContract);\r\n\r\n     // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public adminAddress;\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress);\r\n        _;\r\n    }\r\n}\r\n\r\n// This contract stores all data on the blockchain\r\n// only our other contracts can interact with this\r\n// the data here will be valid for all eternity even if other contracts get updated\r\n// this way we can make sure that our Monsters have a hard-coded value attached to them\r\n// that no one including us can change(!)\r\ncontract MonstersData {\r\n    address coreContract;\r\n\r\n    struct Monster {\r\n        // timestamp of block when this monster was spawned/created\r\n        uint64 birthTime;\r\n\r\n        // generation number\r\n        // gen0 is the very first generation - the later monster spawn the less likely they are to have\r\n        // special attributes and stats\r\n        uint16 generation;\r\n\r\n        uint16 mID; // this id (from 1 to 151) is responsible for everything visually like showing the real deal!\r\n        bool tradeable;\r\n\r\n        // breeding\r\n        bool female;\r\n\r\n        // is this monster exceptionally rare?\r\n        bool shiny;\r\n    }\r\n\r\n    // lv1 base stats\r\n    struct MonsterBaseStats {\r\n        uint16 hp;\r\n        uint16 attack;\r\n        uint16 defense;\r\n        uint16 spAttack;\r\n        uint16 spDefense;\r\n        uint16 speed;\r\n    }\r\n\r\n    struct Trainer {\r\n        // timestamp of block when this player/trainer was created\r\n        uint64 birthTime;\r\n\r\n        // add username\r\n        string username;\r\n\r\n        // current area in the \"world\"\r\n        uint16 currArea;\r\n\r\n        address owner;\r\n    }\r\n\r\n    // take timestamp of block this game was created on the blockchain\r\n    uint64 creationBlock = uint64(now);\r\n}\r\n\r\ncontract MonstersBase is MonsterAccessControl, MonstersData {\r\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a monster\r\n    ///  ownership is assigned, including births.\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    bool lockedMonsterCreator = false;\r\n\r\n    MonsterAuction public monsterAuction;\r\n    MonsterCreatorInterface public monsterCreator;\r\n\r\n    function setMonsterCreatorAddress(address _address) external onlyAdmin {\r\n        // only set this once so we (the devs) can't cheat!\r\n        require(!lockedMonsterCreator);\r\n        MonsterCreatorInterface candidateContract = MonsterCreatorInterface(_address);\r\n\r\n        monsterCreator = candidateContract;\r\n        lockedMonsterCreator = true;\r\n    }\r\n\r\n    // An approximation of currently how many seconds are in between blocks.\r\n    uint256 public secondsPerBlock = 15;\r\n\r\n    // array containing all monsters in existence\r\n    Monster[] monsters;\r\n\r\n    uint8[] areas;\r\n    uint8 areaIndex = 0;\r\n\r\n    mapping(address => Trainer) public addressToTrainer;\r\n    /// @dev A mapping from monster IDs to the address that owns them. All monster have\r\n    ///  some valid owner address, even gen0 monster are created with a non-zero owner.\r\n    mapping (uint256 => address) public monsterIndexToOwner;\r\n    // @dev A mapping from owner address to count of tokens that address owns.\r\n    // Used internally inside balanceOf() to resolve ownership count.\r\n    mapping (address => uint256) ownershipTokenCount;\r\n    mapping (uint256 => address) public monsterIndexToApproved;\r\n    mapping (uint256 => string) public monsterIdToNickname;\r\n    mapping (uint256 => bool) public monsterIdToTradeable;\r\n    mapping (uint256 => uint256) public monsterIdToGeneration;\r\n    \r\n    mapping (uint256 => uint8[7]) public monsterIdToIVs;\r\n\r\n    // adds new area to world\r\n    function _createArea() internal {\r\n        areaIndex++;\r\n        areas.push(areaIndex);\r\n    }\r\n\r\n    function _createMonster(uint256 _generation, address _owner, uint256 _mID, bool _tradeable,\r\n        bool _female, bool _shiny) internal returns (uint)\r\n    {\r\n\r\n        Monster memory _monster = Monster({\r\n            generation: uint16(_generation),\r\n            birthTime: uint64(now),\r\n            mID: uint16(_mID),\r\n            tradeable: _tradeable,\r\n            female: _female,\r\n            shiny: _shiny\r\n        });\r\n\r\n        uint256 newMonsterId = monsters.push(_monster) - 1;\r\n\r\n        require(newMonsterId == uint256(uint32(newMonsterId)));\r\n\r\n        monsterIdToNickname[newMonsterId] = \"\";\r\n\r\n        _transfer(0, _owner, newMonsterId);\r\n\r\n        return newMonsterId;\r\n    }\r\n\r\n    function _createTrainer(string _username, uint16 _starterId, address _owner) internal returns (uint mon) {\r\n        Trainer memory _trainer = Trainer({\r\n            birthTime: uint64(now),\r\n            username: string(_username),\r\n             // sets to first area!,\r\n            currArea: uint16(1),\r\n            owner: address(_owner)\r\n        });\r\n\r\n        addressToTrainer[_owner] = _trainer;\r\n\r\n        bool gender = monsterCreator.getMonsterGender();\r\n\r\n        // starters cannot be traded and are not shiny\r\n        if (_starterId == 1) {\r\n            mon = _createMonster(0, _owner, 1, false, gender, false);\r\n        } else if (_starterId == 2) {\r\n            mon = _createMonster(0, _owner, 4, false, gender, false);\r\n        } else if (_starterId == 3) {\r\n            mon = _createMonster(0, _owner, 7, false, gender, false);\r\n        }\r\n    }\r\n\r\n    function _moveToArea(uint16 _newArea, address player) internal {\r\n        addressToTrainer[player].currArea = _newArea;\r\n    }\r\n\r\n    // assigns ownership of monster to address\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        ownershipTokenCount[_to]++;\r\n        monsterIndexToOwner[_tokenId] = _to;\r\n\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n\r\n            // clear any previously approved ownership exchange\r\n            delete monsterIndexToApproved[_tokenId];\r\n        }\r\n\r\n        // Emit Transfer event\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    // Only admin can fix how many seconds per blocks are currently observed.\r\n    function setSecondsPerBlock(uint256 secs) external onlyAdmin {\r\n        //require(secs < cooldowns[0]);\r\n        secondsPerBlock = secs;\r\n    }\r\n}\r\n\r\ncontract MonsterOwnership is MonstersBase, ERC721 {\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return monsterIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    function _isTradeable(uint256 _tokenId) public view returns (bool) {\r\n        return monsterIdToTradeable[_tokenId];\r\n    }\r\n\r\n    /// @dev Checks if a given address currently has transferApproval for a particular monster.\r\n    /// @param _claimant the address we are confirming monster is approved for.\r\n    /// @param _tokenId monster id, only valid when > 0\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return monsterIndexToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokenId) public payable {\r\n        transferFrom(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public payable {\r\n        require(monsterIdToTradeable[_tokenId]);\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any monsters (except very briefly\r\n        // after a gen0 monster is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        \r\n        require(_owns(_from, _tokenId));\r\n        // checks if _to was aproved\r\n        require(_from == msg.sender || msg.sender == address(monsterAuction) || _approvedFor(_to, _tokenId));\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return monsters.length;\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) public view returns (uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount > 0) {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalMonsters = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            uint256 monsterId;\r\n\r\n            for (monsterId = 0; monsterId <= totalMonsters; monsterId++) {\r\n                if (monsterIndexToOwner[monsterId] == _owner) {\r\n                    result[resultIndex] = monsterId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        return new uint256[](0);\r\n    }\r\n\r\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC165 =\r\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n\r\n    bytes4 internal constant INTERFACE_SIGNATURE_ERC721 =\r\n        bytes4(keccak256(\"ownerOf(uint256)\")) ^\r\n        bytes4(keccak256(\"countOfDeeds()\")) ^\r\n        bytes4(keccak256(\"countOfDeedsByOwner(address)\")) ^\r\n        bytes4(keccak256(\"deedOfOwnerByIndex(address,uint256)\")) ^\r\n        bytes4(keccak256(\"approve(address,uint256)\")) ^\r\n        bytes4(keccak256(\"takeOwnership(uint256)\"));\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\r\n        return _interfaceID == INTERFACE_SIGNATURE_ERC165 || _interfaceID == INTERFACE_SIGNATURE_ERC721;\r\n    }\r\n\r\n    function ownerOf(uint256 _deedId) external view returns (address _owner) {\r\n        var owner = monsterIndexToOwner[_deedId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        monsterIndexToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    function countOfDeeds() external view returns (uint256 _count) {\r\n        return totalSupply();\r\n    }\r\n\r\n    function countOfDeedsByOwner(address _owner) external view returns (uint256 _count) {\r\n        var arr = tokensOfOwner(_owner);\r\n        return arr.length;\r\n    }\r\n\r\n    function deedOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _deedId) {\r\n        return tokensOfOwner(_owner)[_index];\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) external payable {\r\n        // Only an owner can grant transfer approval.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Register the approval (replacing any previous approval).\r\n        monsterIndexToApproved[_tokenId] = _to;\r\n\r\n        // Emit approval event.\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function takeOwnership(uint256 _deedId) external payable {\r\n        transferFrom(this.ownerOf(_deedId), msg.sender, _deedId);\r\n    }\r\n}\r\n\r\ncontract MonsterAuctionBase {\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    MonsterOwnership public nonFungibleContract;\r\n    ChainMonstersCore public core;\r\n\r\n    struct Auction {\r\n        // current owner\r\n        address seller;\r\n        // price in wei\r\n        uint256 price;\r\n        // time when auction started\r\n        uint64 startedAt;\r\n        uint256 id;\r\n    }\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping(uint256 => Auction) tokenIdToAuction;\r\n    mapping(uint256 => address) public auctionIdToSeller;\r\n    mapping (address => uint256) public ownershipAuctionCount;\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 price, uint256 uID, address seller);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 price, address newOwner, uint256 uID);\r\n    event AuctionCancelled(uint256 tokenId, uint256 uID);\r\n\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n\r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        AuctionCreated(\r\n            uint256(_tokenId),\r\n            uint256(_auction.price),\r\n            uint256(_auction.id),\r\n            address(_auction.seller)\r\n        );\r\n    }\r\n\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        Auction storage _auction = tokenIdToAuction[_tokenId];\r\n\r\n        uint256 uID = _auction.id;\r\n\r\n        _removeAuction(_tokenId);\r\n        ownershipAuctionCount[_seller]--;\r\n        _transfer(_seller, _tokenId);\r\n\r\n        AuctionCancelled(_tokenId, uID);\r\n    }\r\n\r\n    function _buy(uint256 _tokenId, uint256 _bidAmount) internal returns (uint256) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n        require(_isOnAuction(auction));\r\n\r\n        uint256 price = auction.price;\r\n        require(_bidAmount >= price);\r\n\r\n        address seller = auction.seller;\r\n        uint256 uID = auction.id;\r\n\r\n        // Auction Bid looks fine! so remove\r\n        _removeAuction(_tokenId);\r\n\r\n        ownershipAuctionCount[seller]--;\r\n\r\n        if (price > 0) {\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - auctioneerCut;\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the auction\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelAuction(). )\r\n            if (seller != address(core)) {\r\n                seller.transfer(sellerProceeds);\r\n            }\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the auction is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        AuctionSuccessful(_tokenId, price, msg.sender, uID);\r\n\r\n        return price;\r\n    }\r\n\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n     function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our entry functions carefully cap the maximum values for\r\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\r\n        //  statement in the ClockAuction constructor). The result of this\r\n        //  function is always guaranteed to be <= _price.\r\n        return _price * ownerCut / 10000;\r\n    }\r\n}\r\n\r\ncontract MonsterAuction is  MonsterAuctionBase, Ownable {\r\n    bool public isMonsterAuction = true;\r\n    uint256 public auctionIndex = 0;\r\n\r\n    function MonsterAuction(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        var candidateContract = MonsterOwnership(_nftAddress);\r\n\r\n        nonFungibleContract = candidateContract;\r\n        ChainMonstersCore candidateCoreContract = ChainMonstersCore(_nftAddress);\r\n        core = candidateCoreContract;\r\n    }\r\n\r\n    // only possible to decrease ownerCut!\r\n    function setOwnerCut(uint256 _cut) external onlyOwner {\r\n        require(_cut <= ownerCut);\r\n        ownerCut = _cut;\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner {\r\n        uint256 balance = this.balance;\r\n        owner.transfer(balance);\r\n    }\r\n\r\n    function tokensInAuctionsOfOwner(address _owner) external view returns(uint256[] auctionTokens) {\r\n        uint256 numAuctions = ownershipAuctionCount[_owner];\r\n\r\n        uint256[] memory result = new uint256[](numAuctions);\r\n        uint256 totalAuctions = core.totalSupply();\r\n        uint256 resultIndex = 0;\r\n\r\n        uint256 auctionId;\r\n\r\n        for (auctionId = 0; auctionId <= totalAuctions; auctionId++) {\r\n            Auction storage auction = tokenIdToAuction[auctionId];\r\n            if (auction.seller == _owner) {\r\n                result[resultIndex] = auctionId;\r\n                resultIndex++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function createAuction(uint256 _tokenId, uint256 _price, address _seller) external {\r\n        require(_seller != address(0));\r\n        require(_price == uint256(_price));\r\n        require(core._isTradeable(_tokenId));\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        \r\n        _escrow(msg.sender, _tokenId);\r\n\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint256(_price),\r\n            uint64(now),\r\n            uint256(auctionIndex)\r\n        );\r\n\r\n        auctionIdToSeller[auctionIndex] = _seller;\r\n        ownershipAuctionCount[_seller]++;\r\n\r\n        auctionIndex++;\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    function buy(uint256 _tokenId) external payable {\r\n        //delete auctionIdToSeller[_tokenId];\r\n        // buy will throw if the bid or funds transfer fails\r\n        _buy (_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    function cancelAuction(uint256 _tokenId) external {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    function getAuction(uint256 _tokenId) external view returns (address seller, uint256 price, uint256 startedAt) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n\r\n        return (\r\n            auction.seller,\r\n            auction.price,\r\n            auction.startedAt\r\n        );\r\n    }\r\n\r\n    function getPrice(uint256 _tokenId) external view returns (uint256) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return auction.price;\r\n    }\r\n}\r\n\r\ncontract ChainMonstersAuction is MonsterOwnership {\r\n    bool lockedMonsterAuction = false;\r\n\r\n    function setMonsterAuctionAddress(address _address) external onlyAdmin {\r\n        require(!lockedMonsterAuction);\r\n        MonsterAuction candidateContract = MonsterAuction(_address);\r\n\r\n        require(candidateContract.isMonsterAuction());\r\n\r\n        monsterAuction = candidateContract;\r\n        lockedMonsterAuction = true;\r\n    }\r\n\r\n    uint256 public constant PROMO_CREATION_LIMIT = 5000;\r\n    uint256 public constant GEN0_CREATION_LIMIT = 5000;\r\n\r\n    // Counts the number of monster the contract owner has created.\r\n    uint256 public promoCreatedCount;\r\n    uint256 public gen0CreatedCount;\r\n\r\n    // its stats are completely dependent on the spawn alghorithm\r\n    function createPromoMonster(uint256 _mId, address _owner) external onlyAdmin {\r\n        // during generation we have to keep in mind that we have only 10,000 tokens available\r\n        // which have to be divided by 151 monsters, some rarer than others\r\n        // see WhitePaper for gen0/promo monster plan\r\n        \r\n        // sanity check that this monster ID is actually in game yet\r\n        require(monsterCreator.baseStats(_mId, 1) > 0);\r\n        \r\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\r\n\r\n        promoCreatedCount++;\r\n\r\n        uint8[7] memory ivs = uint8[7](monsterCreator.getGen0IVs());\r\n\r\n        bool gender = monsterCreator.getMonsterGender();\r\n        \r\n        bool shiny = false;\r\n        if (ivs[6] == 1) {\r\n            shiny = true;\r\n        }\r\n        uint256 monsterId = _createMonster(0, _owner, _mId, true, gender, shiny);\r\n        monsterIdToTradeable[monsterId] = true;\r\n\r\n        monsterIdToIVs[monsterId] = ivs;\r\n    }\r\n\r\n    function createGen0Auction(uint256 _mId, uint256 price) external onlyAdmin {\r\n         // sanity check that this monster ID is actually in game yet\r\n        require(monsterCreator.baseStats(_mId, 1) > 0);\r\n        \r\n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\r\n\r\n        uint8[7] memory ivs = uint8[7](monsterCreator.getGen0IVs());\r\n\r\n        bool gender = monsterCreator.getMonsterGender();\r\n        \r\n        bool shiny = false;\r\n        if (ivs[6] == 1) {\r\n            shiny = true;\r\n        }\r\n        \r\n        uint256 monsterId = _createMonster(0, this, _mId, true, gender, shiny);\r\n        monsterIdToTradeable[monsterId] = true;\r\n\r\n        _approve(monsterId, monsterAuction);\r\n\r\n        monsterIdToIVs[monsterId] = ivs;\r\n\r\n        monsterAuction.createAuction(monsterId, price, address(this));\r\n\r\n        gen0CreatedCount++;\r\n    }\r\n}\r\n\r\n// used during launch for world championship\r\n// can and will be upgraded during development with new battle system!\r\n// this is just to give players something to do and test their monsters\r\n// also demonstrates how we can build up more mechanics on top of our locked core contract!\r\ncontract MonsterChampionship is Ownable {\r\n\r\n    bool public isMonsterChampionship = true;\r\n\r\n    ChainMonstersCore core;\r\n\r\n    // list of top ten\r\n    address[10] topTen;\r\n\r\n    // holds the address current \"world\" champion\r\n    address public currChampion;\r\n\r\n    mapping (address => uint256) public addressToPowerlevel;\r\n    mapping (uint256 => address) public rankToAddress;\r\n\r\n    // try to beat every other player in the top10 with your strongest monster!\r\n    // effectively looping through all top10 players, beating them one by one\r\n    // and if strong enough placing your in the top10 as well\r\n    function contestChampion(uint256 _tokenId) external {\r\n        uint maxIndex = 9;\r\n\r\n        // fail tx if player is already champion!\r\n        // in theory players could increase their powerlevel by contesting themselves but\r\n        // this check stops that from happening so other players have the chance to\r\n        // become the temporary champion!\r\n        if (currChampion == msg.sender) {\r\n            revert();\r\n        }\r\n\r\n        require(core.isTrainer(msg.sender));\r\n        require(core.monsterIndexToOwner(_tokenId) == msg.sender);\r\n\r\n        uint myPowerlevel = 10; // todo add calculation method to this contract!\r\n\r\n        // checks if this transaction is useless\r\n        // since we can't fight against ourself!\r\n        // also stops reentrancy attacks\r\n        require(myPowerlevel > addressToPowerlevel[msg.sender]);\r\n\r\n        uint myRank = 0;\r\n\r\n        for (uint i = 0; i <= maxIndex; i++) {\r\n            if (myPowerlevel > addressToPowerlevel[topTen[i]]) {\r\n                // you have beaten this one so increase temporary rank\r\n                myRank = i;\r\n\r\n                if (myRank == maxIndex) {\r\n                    currChampion = msg.sender;\r\n                }\r\n            }\r\n        }\r\n\r\n        addressToPowerlevel[msg.sender] = myPowerlevel;\r\n\r\n        address[10] storage newTopTen = topTen;\r\n\r\n        if (currChampion == msg.sender) {\r\n            for (uint j = 0; j < maxIndex; j++) {\r\n                // remove ourselves from this list in case\r\n                if (newTopTen[j] == msg.sender) {\r\n                    newTopTen[j] = 0x0;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (uint x = 0; x <= myRank; x++) {\r\n            if (x == myRank) {\r\n                newTopTen[x] = msg.sender;\r\n            } else {\r\n                if (x < maxIndex)\r\n                    newTopTen[x] = topTen[x+1];\r\n            }\r\n        }\r\n\r\n        topTen = newTopTen;\r\n    }\r\n\r\n    function getTopPlayers() external view returns (address[10] players) {\r\n        players = topTen;\r\n    }\r\n\r\n    function MonsterChampionship(address coreContract) public {\r\n        core = ChainMonstersCore(coreContract);\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner {\r\n        uint256 balance = this.balance;\r\n        owner.transfer(balance);\r\n    }\r\n}\r\n\r\n\r\n// where the not-so-much \"hidden\" magic happens\r\ncontract MonsterCreatorInterface is Ownable {\r\n    uint8 public lockedMonsterStatsCount = 0;\r\n    uint nonce = 0;\r\n\r\n    function rand(uint16 min, uint16 max) public returns (uint16) {\r\n        nonce++;\r\n        uint16 result = (uint16(keccak256(block.blockhash(block.number-1), nonce))%max);\r\n\r\n        if (result < min) {\r\n            result = result+min;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    mapping(uint256 => uint8[8]) public baseStats;\r\n\r\n    function addBaseStats(uint256 _mId, uint8[8] data) external onlyOwner {\r\n        // lock\" the stats down forever\r\n        // since hp is never going to be 0 this is a valid check\r\n        // so we have to be extra careful when adding new baseStats!\r\n        require(data[0] > 0);\r\n        require(baseStats[_mId][0] == 0);\r\n        baseStats[_mId] = data;\r\n    }\r\n\r\n    function _addBaseStats(uint256 _mId, uint8[8] data) internal {\r\n        baseStats[_mId] = data;\r\n        lockedMonsterStatsCount++;\r\n    }\r\n\r\n    function MonsterCreatorInterface() public {\r\n       // these monsters are already down and \"locked\" down stats/design wise\r\n        _addBaseStats(1, [45, 49, 49, 65, 65, 45, 12, 4]);\r\n        _addBaseStats(2, [60, 62, 63, 80, 80, 60, 12, 4]);\r\n        _addBaseStats(3, [80, 82, 83, 100, 100, 80, 12, 4]);\r\n        _addBaseStats(4, [39, 52, 43, 60, 50, 65, 10, 6]);\r\n        _addBaseStats(5, [58, 64, 58, 80, 65, 80, 10, 6]);\r\n        _addBaseStats(6, [78, 84, 78, 109, 85, 100, 10, 6]);\r\n        _addBaseStats(7, [44, 48, 65, 50, 64, 43, 11, 14]);\r\n        _addBaseStats(8, [59, 63, 80, 65, 80, 58, 11, 14]);\r\n        _addBaseStats(9, [79, 83, 100, 85, 105, 78, 11, 14]);\r\n        _addBaseStats(10, [40, 35, 30, 20, 20, 50, 7, 4]);\r\n\r\n        _addBaseStats(149, [55, 50, 45, 135, 95, 120, 8, 14]);\r\n        _addBaseStats(150, [91, 134, 95, 100, 100, 80, 2, 5]);\r\n        _addBaseStats(151, [100, 100, 100, 100, 100, 100, 5, 19]);\r\n    }\r\n\r\n    // this serves as a lookup for new monsters to be generated since all monsters\r\n    // of the same id share the base stats\r\n    // also makes it possible to only store the monsterId on core and change this one\r\n    // during evolution process to save gas and additional transactions\r\n    function getMonsterStats( uint256 _mID) external constant returns(uint8[8] stats) {\r\n        stats[0] = baseStats[_mID][0];\r\n        stats[1] = baseStats[_mID][1];\r\n        stats[2] = baseStats[_mID][2];\r\n        stats[3] = baseStats[_mID][3];\r\n        stats[4] = baseStats[_mID][4];\r\n        stats[5] = baseStats[_mID][5];\r\n        stats[6] = baseStats[_mID][6];\r\n        stats[7] = baseStats[_mID][7];\r\n    }\r\n\r\n    function getMonsterGender () external returns(bool female) {\r\n        uint16 femaleChance = rand(0, 100);\r\n\r\n        if (femaleChance >= 50) {\r\n            female = true;\r\n        }\r\n    }\r\n\r\n    // generates randomized IVs for a new monster\r\n    function getMonsterIVs() external returns(uint8[7] ivs) {\r\n        bool shiny = false;\r\n\r\n        uint16 chance = rand(1, 8192);\r\n\r\n        if (chance == 42) {\r\n            shiny = true;\r\n        }\r\n\r\n        // IVs range between 0 and 31\r\n        // stat range modified for shiny monsters!\r\n        if (shiny) {\r\n            ivs[0] = uint8(rand(10, 31));\r\n            ivs[1] = uint8(rand(10, 31));\r\n            ivs[2] = uint8(rand(10, 31));\r\n            ivs[3] = uint8(rand(10, 31));\r\n            ivs[4] = uint8(rand(10, 31));\r\n            ivs[5] = uint8(rand(10, 31));\r\n            ivs[6] = 1;\r\n\r\n        } else {\r\n            ivs[0] = uint8(rand(0, 31));\r\n            ivs[1] = uint8(rand(0, 31));\r\n            ivs[2] = uint8(rand(0, 31));\r\n            ivs[3] = uint8(rand(0, 31));\r\n            ivs[4] = uint8(rand(0, 31));\r\n            ivs[5] = uint8(rand(0, 31));\r\n            ivs[6] = 0;\r\n        }\r\n    }\r\n\r\n    // gen0 monsters profit from shiny boost while shiny gen0s have potentially even higher IVs!\r\n    // further increasing the rarity by also doubling the shiny chance!\r\n    function getGen0IVs() external returns (uint8[7] ivs) {\r\n        bool shiny = false;\r\n\r\n        uint16 chance = rand(1, 4096);\r\n\r\n        if (chance == 42) {\r\n            shiny = true;\r\n        }\r\n\r\n        if (shiny) {\r\n            ivs[0] = uint8(rand(15, 31));\r\n            ivs[1] = uint8(rand(15, 31));\r\n            ivs[2] = uint8(rand(15, 31));\r\n            ivs[3] = uint8(rand(15, 31));\r\n            ivs[4] = uint8(rand(15, 31));\r\n            ivs[5] = uint8(rand(15, 31));\r\n            ivs[6] = 1;\r\n        } else {\r\n            ivs[0] = uint8(rand(10, 31));\r\n            ivs[1] = uint8(rand(10, 31));\r\n            ivs[2] = uint8(rand(10, 31));\r\n            ivs[3] = uint8(rand(10, 31));\r\n            ivs[4] = uint8(rand(10, 31));\r\n            ivs[5] = uint8(rand(10, 31));\r\n            ivs[6] = 0;\r\n        }\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner {\r\n        uint256 balance = this.balance;\r\n        owner.transfer(balance);\r\n    }\r\n}\r\n\r\ncontract GameLogicContract {\r\n    bool public isGameLogicContract = true;\r\n\r\n    function GameLogicContract() public {\r\n\r\n    }\r\n}\r\n\r\n\r\ncontract OmegaContract {\r\n    bool public isOmegaContract = true;\r\n\r\n    function OmegaContract() public {\r\n\r\n    }\r\n}\r\n\r\ncontract ChainMonstersCore is ChainMonstersAuction, Ownable {\r\n    // using a bool to enable us to prepare the game\r\n    bool hasLaunched = false;\r\n\r\n    // this address will hold future gamelogic in place\r\n    address gameContract;\r\n\r\n    // this contract\r\n    address omegaContract;\r\n\r\n    function ChainMonstersCore() public {\r\n        adminAddress = msg.sender;\r\n\r\n        _createArea(); // area 1\r\n        _createArea(); // area 2\r\n    }\r\n\r\n    // we don't know the exact interfaces yet so use the lockedMonsterStats value to determine if the game is \"ready\"\r\n    // see WhitePaper for explaination for our upgrade and development roadmap\r\n    function setGameLogicContract(address _candidateContract) external onlyOwner {\r\n        require(monsterCreator.lockedMonsterStatsCount() == 151);\r\n\r\n        require(GameLogicContract(_candidateContract).isGameLogicContract());\r\n\r\n        gameContract = _candidateContract;\r\n    }\r\n\r\n    function setOmegaContract(address _candidateContract) external onlyOwner {\r\n        require(OmegaContract(_candidateContract).isOmegaContract());\r\n        omegaContract = _candidateContract;\r\n    }\r\n\r\n    // omega contract takes care of all neccessary checks so assume that this is correct(!)\r\n    function evolveMonster(uint256 _tokenId, uint16 _toMonsterId) external {\r\n        require(msg.sender == omegaContract);\r\n\r\n        // retrieve current monster struct\r\n        Monster storage mon = monsters[_tokenId];\r\n\r\n        // evolving only changes monster ID since this is responsible for base Stats\r\n        // an evolved monster keeps its gender, generation, IVs and EVs\r\n        mon.mID = _toMonsterId;\r\n    }\r\n\r\n    // only callable by gameContract after the full game is launched\r\n    // since all additional monsters after the promo/gen0 ones need to use this coreContract\r\n    // contract as well we have to prepare this core for our future updates where\r\n    // players can freely roam the world and hunt ChainMonsters thus generating more\r\n    function spawnMonster(uint256 _mId, address _owner) external {\r\n        require(msg.sender == gameContract);\r\n\r\n        uint8[7] memory ivs = uint8[7](monsterCreator.getMonsterIVs());\r\n\r\n        bool gender = monsterCreator.getMonsterGender();\r\n\r\n        bool shiny = false;\r\n        if (ivs[6] == 1) {\r\n            shiny = true;\r\n        }\r\n        \r\n        // important to note that the IV generators do not use Gen0 methods and are Generation 1\r\n        // this means there won't be more than the 10,000 Gen0 monsters sold during the development through the marketplace\r\n        uint256 monsterId = _createMonster(1, _owner, _mId, false, gender, shiny);\r\n        monsterIdToTradeable[monsterId] = true;\r\n\r\n        monsterIdToIVs[monsterId] = ivs;\r\n    }\r\n\r\n    // used to add playable content to the game\r\n    // monsters will only spawn in certain areas so some are locked on release\r\n    // due to the game being in active development on \"launch\"\r\n    // each monster has a maximum number of 3 areas where it can appear\r\n    function createArea() public onlyAdmin {\r\n        _createArea();\r\n    }\r\n\r\n    function createTrainer(string _username, uint16 _starterId) public {\r\n        require(hasLaunched);\r\n\r\n        // only one trainer/account per ethereum address\r\n        require(addressToTrainer[msg.sender].owner == 0);\r\n\r\n        // valid input check\r\n        require(_starterId == 1 || _starterId == 2 || _starterId == 3);\r\n\r\n        uint256 mon = _createTrainer(_username, _starterId, msg.sender);\r\n\r\n        // due to stack limitations we have to assign the IVs here:\r\n        monsterIdToIVs[mon] = monsterCreator.getMonsterIVs();\r\n    }\r\n\r\n    function changeUsername(string _name) public {\r\n        require(addressToTrainer[msg.sender].owner == msg.sender);\r\n        addressToTrainer[msg.sender].username = _name;\r\n    }\r\n\r\n    function changeMonsterNickname(uint256 _tokenId, string _name) public {\r\n        // users won't be able to rename a monster that is part of an auction\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // some string checks...?\r\n        monsterIdToNickname[_tokenId] = _name;\r\n    }\r\n\r\n    function moveToArea(uint16 _newArea) public {\r\n        require(addressToTrainer[msg.sender].currArea > 0);\r\n\r\n        // never allow anyone to move to area 0 or below since this is used\r\n        // to determine if a trainer profile exists in another method!\r\n        require(_newArea > 0);\r\n\r\n        // make sure that this area exists yet!\r\n        require(areas.length >= _newArea);\r\n\r\n        // when player is not stuck doing something else he can move freely!\r\n        _moveToArea(_newArea, msg.sender);\r\n    }\r\n\r\n    // to be changed to retrieve current stats!\r\n    function getMonster(uint256 _id) external view returns (\r\n        uint256 birthTime, uint256 generation, uint8[8] stats,\r\n        uint256 mID, bool tradeable, uint256 uID)\r\n    {\r\n        Monster storage mon = monsters[_id];\r\n        birthTime = uint256(mon.birthTime);\r\n        generation = mon.generation; // hardcoding due to stack too deep error\r\n        mID = uint256(mon.mID);\r\n        tradeable = bool(mon.tradeable);\r\n\r\n        // these values are retrieved from monsterCreator\r\n        stats = uint8[8](monsterCreator.getMonsterStats(uint256(mon.mID)));\r\n\r\n        // hack to overcome solidity's stack limitation in monster struct....\r\n        uID = _id;\r\n    }\r\n\r\n    function isTrainer(address _check) external view returns (bool isTrainer) {\r\n        Trainer storage trainer = addressToTrainer[_check];\r\n\r\n        return (trainer.currArea > 0);\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner {\r\n        uint256 balance = this.balance;\r\n\r\n        owner.transfer(balance);\r\n    }\r\n\r\n    // after we have setup everything we can unlock the game\r\n    // for public\r\n    function launchGame() external onlyOwner {\r\n        hasLaunched = true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensInAuctionsOfOwner\",\"outputs\":[{\"name\":\"auctionTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionIdToSeller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cut\",\"type\":\"uint256\"}],\"name\":\"setOwnerCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMonsterAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownershipAuctionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"core\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_cut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"uID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uID\",\"type\":\"uint256\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"uID\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"}]","ContractName":"MonsterAuction","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f7f6c2836293a661be2690fbacae97f3f027e9c400000000000000000000000000000000000000000000000000000000000003e8","Library":"","SwarmSource":"bzzr://ddb947aa1a3115ebbfa3c33d0149c0896bfea1927d1675321861f87cae1a3ef0"}]}