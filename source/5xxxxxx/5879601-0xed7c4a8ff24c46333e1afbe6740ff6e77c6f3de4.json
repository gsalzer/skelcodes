{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n//https://github.com/OpenZeppelin/zeppelin-solIdity/blob/master/contracts/math/SafeMath.sol\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // SolIdity automatically throws when divIding by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract EtherTool { \r\n    using   SafeMath for uint256;     \r\n\r\n    function EtherTool()  public {\r\n    }\r\n\r\n    bool public globalLocked = false;     \r\n\r\n    function lock() internal {            \r\n        require(!globalLocked);\r\n        globalLocked = true;\r\n    }\r\n\r\n    function unLock() internal {\r\n        require(globalLocked);\r\n        globalLocked = false;\r\n    }    \r\n\r\n    mapping (address => uint256) public userEtherOf;    \r\n    \r\n    function depositEther() public payable {\r\n        if (msg.value > 0){\r\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);  \r\n        }\r\n    }\r\n    \r\n    function withdrawEther() public  returns(bool _result) {                  \r\n        return _withdrawEther(msg.sender);\r\n    }\r\n    \r\n    function withdrawEtherTo(address _user) public returns(bool _result) {     \r\n        return _withdrawEther(_user);\r\n    }\r\n\r\n    function _withdrawEther(address _to) internal returns(bool _result) {     \r\n        require (_to != 0x0);  \r\n        lock();\r\n        uint256 amount = userEtherOf[msg.sender];   \r\n        if(amount > 0) {\r\n            userEtherOf[msg.sender] = 0;\r\n            _to.transfer(amount); \r\n            _result = true;\r\n        }\r\n        else {\r\n            _result = false;\r\n        }\r\n        unLock();\r\n    }\r\n    \r\n    uint public currentEventId = 1;                                    \r\n\r\n    function getEventId() internal returns(uint _result) {           \r\n        _result = currentEventId;\r\n        currentEventId ++;\r\n    }\r\n\r\n    event OnTransfer(address indexed _sender, address indexed _to, bool indexed _done, uint256 _amount, uint _eventTime, uint eventId);\r\n\r\n    function batchTransfer1(address[] _tos, uint256 _amount) public payable returns (uint256 _doneNum){\r\n        lock();\r\n        if(msg.value > 0) {          \r\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\r\n        }\r\n        require(_amount > 0);\r\n        require(_tos.length > 0);\r\n\r\n        _doneNum = 0;\r\n        for(uint i = 0; i < _tos.length; i++){\r\n            bool done = false;\r\n            address to = _tos[i];\r\n            if(to != 0x0 && userEtherOf[msg.sender] >= _amount){\r\n                userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(_amount);\r\n                to.transfer(_amount);                                            \r\n                _doneNum = _doneNum.add(1);\r\n                done = true;\r\n            }\r\n            emit OnTransfer(msg.sender, to, done, _amount, now, getEventId());\r\n        }\r\n        unLock();\r\n    }\r\n\r\n    function batchTransfer2(address[] _tos, uint256[] _amounts) public payable returns (uint256 _doneNum){\r\n        lock();\r\n        if(msg.value > 0) {          \r\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\r\n        }\r\n        require(_amounts.length > 0);\r\n        require(_tos.length > 0);\r\n        require(_tos.length == _amounts.length);\r\n\r\n        _doneNum = 0;\r\n        for(uint i = 0; i < _tos.length; i++){\r\n            bool done = false;\r\n            address to = _tos[i];\r\n            uint256 amount = _amounts[i]; \r\n            if((to != 0x0) && (amount > 0) && (userEtherOf[msg.sender] >= amount)){\r\n                userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(amount);\r\n                to.transfer(amount);                                            \r\n                _doneNum = _doneNum.add(1);\r\n                done = true;\r\n            }\r\n            emit OnTransfer(msg.sender, to, done, amount, now, getEventId());\r\n        }\r\n        unLock();\r\n    }\r\n        \r\n    function uint8ToString(uint8 v) private pure returns (string)\r\n    {\r\n        uint maxlength = 8;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        while (v != 0) {\r\n        uint remainder = v % 10;\r\n        v = v / 10;\r\n        reversed[i++] = byte(48 + remainder);\r\n        }\r\n        bytes memory s = new bytes(i);\r\n        for (uint j = 0; j < i; j++) {\r\n        s[j] = reversed[i - j - 1];\r\n        }\r\n        string memory str = string(s);\r\n        return str;\r\n    }\r\n\r\n    function getBytes32() public view returns (bytes32 _result){\r\n        _result = keccak256(now, block.blockhash(block.number - 1));\r\n    }\r\n\r\n    function getHash1(uint8[5]  _winWhiteBall, uint8 _winRedBall, bytes32 _nonce) public pure returns (bytes32 _result){\r\n        _result =  keccak256(_winWhiteBall, _winRedBall, _nonce);\r\n    }\r\n\r\n    function getHash2(address _user, bytes32 _nonce) public pure returns (bytes32 _result){\r\n        _result =  keccak256(_user, _nonce);\r\n    }\r\n\r\n    function () public payable {                                    //function depositEther() public payable \r\n        if(msg.value > 0) {          \r\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"withdrawEtherTo\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEventId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBytes32\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tos\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"batchTransfer1\",\"outputs\":[{\"name\":\"_doneNum\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userEtherOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_winWhiteBall\",\"type\":\"uint8[5]\"},{\"name\":\"_winRedBall\",\"type\":\"uint8\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"getHash1\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tos\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer2\",\"outputs\":[{\"name\":\"_doneNum\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"getHash2\",\"outputs\":[{\"name\":\"_result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_done\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_eventTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eventId\",\"type\":\"uint256\"}],\"name\":\"OnTransfer\",\"type\":\"event\"}]","ContractName":"EtherTool","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9a558542286acbe7019038a6023e0c4c143a43c7aa2361d0b1d5c27495f98e03"}]}