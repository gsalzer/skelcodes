{"status":"1","message":"OK","result":[{"SourceCode":"contract Certifier {\r\n\tevent Confirmed(address indexed who);\r\n\tevent Revoked(address indexed who);\r\n\tfunction certified(address _who) view public returns (bool);\r\n}\r\n\r\ncontract ERC223ReceivingContract {\r\n\r\n    /// @dev Standard ERC223 function that will handle incoming token transfers.\r\n    /// @param _from  Token sender address.\r\n    /// @param _value Amount of tokens.\r\n    /// @param _data  Transaction metadata.\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC223Basic is ERC20Basic {\r\n\r\n    /**\r\n      * @dev Transfer the specified amount of tokens to the specified address.\r\n      *      Now with a new parameter _data.\r\n      *\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      * @param _data  Transaction metadata.\r\n      */\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool);\r\n\r\n    /**\r\n      * @dev triggered when transfer is successfully called.\r\n      *\r\n      * @param _from  Sender address.\r\n      * @param _to    Receiver address.\r\n      * @param _value Amount of tokens that will be transferred.\r\n      * @param _data  Transaction metadata.\r\n      */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\r\n}\r\n\r\n\r\ncontract SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract DetherBank is ERC223ReceivingContract, Ownable, SafeMath  {\r\n  using BytesLib for bytes;\r\n\r\n  /*\r\n   * Event\r\n   */\r\n  event receiveDth(address _from, uint amount);\r\n  event receiveEth(address _from, uint amount);\r\n  event sendDth(address _from, uint amount);\r\n  event sendEth(address _from, uint amount);\r\n\r\n  mapping(address => uint) public dthShopBalance;\r\n  mapping(address => uint) public dthTellerBalance;\r\n  mapping(address => uint) public ethShopBalance;\r\n  mapping(address => uint) public ethTellerBalance;\r\n\r\n  ERC223Basic public dth;\r\n  bool public isInit = false;\r\n\r\n  /**\r\n   * INIT\r\n   */\r\n  function setDth (address _dth) external onlyOwner {\r\n    require(!isInit);\r\n    dth = ERC223Basic(_dth);\r\n    isInit = true;\r\n  }\r\n\r\n  /**\r\n   * Core fonction\r\n   */\r\n  // withdraw DTH when teller delete\r\n  function withdrawDthTeller(address _receiver) external onlyOwner {\r\n    require(dthTellerBalance[_receiver] > 0);\r\n    uint tosend = dthTellerBalance[_receiver];\r\n    dthTellerBalance[_receiver] = 0;\r\n    require(dth.transfer(_receiver, tosend));\r\n  }\r\n  // withdraw DTH when shop delete\r\n  function withdrawDthShop(address _receiver) external onlyOwner  {\r\n    require(dthShopBalance[_receiver] > 0);\r\n    uint tosend = dthShopBalance[_receiver];\r\n    dthShopBalance[_receiver] = 0;\r\n    require(dth.transfer(_receiver, tosend));\r\n  }\r\n  // withdraw DTH when a shop add by admin is delete\r\n  function withdrawDthShopAdmin(address _from, address _receiver) external onlyOwner  {\r\n    require(dthShopBalance[_from]  > 0);\r\n    uint tosend = dthShopBalance[_from];\r\n    dthShopBalance[_from] = 0;\r\n    require(dth.transfer(_receiver, tosend));\r\n  }\r\n\r\n  // add DTH when shop register\r\n  function addTokenShop(address _from, uint _value) external onlyOwner {\r\n    dthShopBalance[_from] = SafeMath.add(dthShopBalance[_from], _value);\r\n  }\r\n  // add DTH when token register\r\n  function addTokenTeller(address _from, uint _value) external onlyOwner{\r\n    dthTellerBalance[_from] = SafeMath.add(dthTellerBalance[_from], _value);\r\n  }\r\n  // add ETH for escrow teller\r\n  function addEthTeller(address _from, uint _value) external payable onlyOwner returns (bool) {\r\n    ethTellerBalance[_from] = SafeMath.add(ethTellerBalance[_from] ,_value);\r\n    return true;\r\n  }\r\n  // withdraw ETH for teller escrow\r\n  function withdrawEth(address _from, address _to, uint _amount) external onlyOwner {\r\n    require(ethTellerBalance[_from] >= _amount);\r\n    ethTellerBalance[_from] = SafeMath.sub(ethTellerBalance[_from], _amount);\r\n    _to.transfer(_amount);\r\n  }\r\n  // refund all ETH from teller contract\r\n  function refundEth(address _from) external onlyOwner {\r\n    uint toSend = ethTellerBalance[_from];\r\n    if (toSend > 0) {\r\n      ethTellerBalance[_from] = 0;\r\n      _from.transfer(toSend);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * GETTER\r\n   */\r\n  function getDthTeller(address _user) public view returns (uint) {\r\n    return dthTellerBalance[_user];\r\n  }\r\n  function getDthShop(address _user) public view returns (uint) {\r\n    return dthShopBalance[_user];\r\n  }\r\n\r\n  function getEthBalTeller(address _user) public view returns (uint) {\r\n    return ethTellerBalance[_user];\r\n  }\r\n  /// @dev Standard ERC223 function that will handle incoming token transfers.\r\n  // DO NOTHING but allow to receive token when addToken* function are called\r\n  // by the dethercore contract\r\n  function tokenFallback(address _from, uint _value, bytes _data) {\r\n    require(msg.sender == address(dth));\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract DetherAccessControl {\r\n    // This facet controls access control for Dether. There are four roles managed here:\r\n    //\r\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\r\n    //         contracts. It is also the only role that can unpause the smart contract.\r\n    //\r\n    //     - The CMO: The CMO is in charge to open or close activity in zone\r\n    //\r\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\r\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\r\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\r\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\r\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\r\n    // account.\r\n\r\n    /// @dev Emited when contract is upgraded\r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public ceoAddress;\r\n    address public cmoAddress;\r\n    address public csoAddress; // CHIEF SHOP OFFICER\r\n\t  mapping (address => bool) public shopModerators;   // centralised moderator, would become decentralised\r\n    mapping (address => bool) public tellerModerators;   // centralised moderator, would become decentralised\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CMO-only functionality\r\n    modifier onlyCMO() {\r\n        require(msg.sender == cmoAddress);\r\n        _;\r\n    }\r\n\r\n    function isCSO(address _addr) public view returns (bool) {\r\n      return (_addr == csoAddress);\r\n    }\r\n\r\n\r\n    modifier isShopModerator(address _user) {\r\n      require(shopModerators[_user]);\r\n      _;\r\n    }\r\n    modifier isTellerModerator(address _user) {\r\n      require(tellerModerators[_user]);\r\n      _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CMO. Only available to the current CEO.\r\n    /// @param _newCMO The address of the new CMO\r\n    function setCMO(address _newCMO) external onlyCEO {\r\n        require(_newCMO != address(0));\r\n        cmoAddress = _newCMO;\r\n    }\r\n\r\n    function setCSO(address _newCSO) external onlyCEO {\r\n        require(_newCSO != address(0));\r\n        csoAddress = _newCSO;\r\n    }\r\n\r\n    function setShopModerator(address _moderator) external onlyCEO {\r\n      require(_moderator != address(0));\r\n      shopModerators[_moderator] = true;\r\n    }\r\n\r\n    function removeShopModerator(address _moderator) external onlyCEO {\r\n      shopModerators[_moderator] = false;\r\n    }\r\n\r\n    function setTellerModerator(address _moderator) external onlyCEO {\r\n      require(_moderator != address(0));\r\n      tellerModerators[_moderator] = true;\r\n    }\r\n\r\n    function removeTellerModerator(address _moderator) external onlyCEO {\r\n      tellerModerators[_moderator] = false;\r\n    }\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCEO whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CMO account are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyCEO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract DetherSetup is DetherAccessControl  {\r\n\r\n  bool public run1 = false;\r\n  bool public run2 = false;\r\n  // -Need to be whitelisted to be able to register in the contract as a shop or\r\n  // teller, there is two level of identification.\r\n  // -This identification method are now centralised and processed by dether, but\r\n  // will be decentralised soon\r\n  Certifier public smsCertifier;\r\n  Certifier public kycCertifier;\r\n  // Zone need to be open by the CMO before accepting registration\r\n  // The bytes2 parameter wait for a country ID (ex: FR (0x4652 in hex) for france cf:README)\r\n  mapping(bytes2 => bool) public openedCountryShop;\r\n  mapping(bytes2 => bool) public openedCountryTeller;\r\n  // For registering in a zone you need to stake DTH\r\n  // The price can differ by country\r\n  // Uts now a fixed price by the CMO but the price will adjusted automatically\r\n  // regarding different factor in the futur smart contract\r\n  mapping(bytes2 => uint) public licenceShop;\r\n  mapping(bytes2 => uint) public licenceTeller;\r\n\r\n  modifier tier1(address _user) {\r\n    require(smsCertifier.certified(_user));\r\n    _;\r\n  }\r\n  modifier tier2(address _user) {\r\n    require(kycCertifier.certified(_user));\r\n    _;\r\n  }\r\n  modifier isZoneShopOpen(bytes2 _country) {\r\n    require(openedCountryShop[_country]);\r\n    _;\r\n  }\r\n  modifier isZoneTellerOpen(bytes2 _country) {\r\n    require(openedCountryTeller[_country]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * INIT\r\n   */\r\n  function setSmsCertifier (address _smsCertifier) external onlyCEO {\r\n    require(!run1);\r\n    smsCertifier = Certifier(_smsCertifier);\r\n    run1 = true;\r\n  }\r\n  /**\r\n   * CORE FUNCTION\r\n   */\r\n  function setKycCertifier (address _kycCertifier) external onlyCEO {\r\n    require(!run2);\r\n    kycCertifier = Certifier(_kycCertifier);\r\n    run2 = true;\r\n  }\r\n  function setLicenceShopPrice(bytes2 country, uint price) external onlyCMO {\r\n    licenceShop[country] = price;\r\n  }\r\n  function setLicenceTellerPrice(bytes2 country, uint price) external onlyCMO {\r\n    licenceTeller[country] = price;\r\n  }\r\n  function openZoneShop(bytes2 _country) external onlyCMO {\r\n    openedCountryShop[_country] = true;\r\n  }\r\n  function closeZoneShop(bytes2 _country) external onlyCMO {\r\n    openedCountryShop[_country] = false;\r\n  }\r\n  function openZoneTeller(bytes2 _country) external onlyCMO {\r\n    openedCountryTeller[_country] = true;\r\n  }\r\n  function closeZoneTeller(bytes2 _country) external onlyCMO {\r\n    openedCountryTeller[_country] = false;\r\n  }\r\n}\r\n\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toBytes32(bytes _bytes, uint _start) internal  pure returns (bytes32) {\r\n        require(_bytes.length >= (_start + 32));\r\n        bytes32 tempBytes32;\r\n\r\n        assembly {\r\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes32;\r\n    }\r\n\r\n    function toBytes16(bytes _bytes, uint _start) internal  pure returns (bytes16) {\r\n        require(_bytes.length >= (_start + 16));\r\n        bytes16 tempBytes16;\r\n\r\n        assembly {\r\n            tempBytes16 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes16;\r\n    }\r\n\r\n    function toBytes2(bytes _bytes, uint _start) internal  pure returns (bytes2) {\r\n        require(_bytes.length >= (_start + 2));\r\n        bytes2 tempBytes2;\r\n\r\n        assembly {\r\n            tempBytes2 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes2;\r\n    }\r\n\r\n    function toBytes4(bytes _bytes, uint _start) internal  pure returns (bytes4) {\r\n        require(_bytes.length >= (_start + 4));\r\n        bytes4 tempBytes4;\r\n\r\n        assembly {\r\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempBytes4;\r\n    }\r\n\r\n    function toBytes1(bytes _bytes, uint _start) internal  pure returns (bytes1) {\r\n        require(_bytes.length >= (_start + 1));\r\n        bytes1 tempBytes1;\r\n\r\n        assembly {\r\n            tempBytes1 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempBytes1;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}\r\n\r\n\r\ncontract DetherCore is DetherSetup, ERC223ReceivingContract, SafeMath {\r\n  using BytesLib for bytes;\r\n\r\n  /**\r\n  * Event\r\n  */\r\n  // when a Teller is registered\r\n  event RegisterTeller(address indexed tellerAddress);\r\n  // when a teller is deleted\r\n  event DeleteTeller(address indexed tellerAddress);\r\n  // when teller update\r\n  event UpdateTeller(address indexed tellerAddress);\r\n  // when a teller send to a buyer\r\n  event Sent(address indexed _from, address indexed _to, uint amount);\r\n  // when a shop register\r\n  event RegisterShop(address shopAddress);\r\n  // when a shop delete\r\n  event DeleteShop(address shopAddress);\r\n  // when a moderator delete a shop\r\n  event DeleteShopModerator(address indexed moderator, address shopAddress);\r\n  // when a moderator delete a teller\r\n  event DeleteTellerModerator(address indexed moderator, address tellerAddress);\r\n\r\n  /**\r\n   * Modifier\r\n   */\r\n  // if teller has staked enough dth to\r\n  modifier tellerHasStaked(uint amount) {\r\n    require(bank.getDthTeller(msg.sender) >= amount);\r\n    _;\r\n  }\r\n  // if shop has staked enough dth to\r\n  modifier shopHasStaked(uint amount) {\r\n    require(bank.getDthShop(msg.sender) >= amount);\r\n    _;\r\n  }\r\n\r\n  /*\r\n   * External contract\r\n   */\r\n  // DTH contract\r\n  ERC223Basic public dth;\r\n  // bank contract where are stored ETH and DTH\r\n  DetherBank public bank;\r\n\r\n  // teller struct\r\n  struct Teller {\r\n    int32 lat;            // Latitude\r\n    int32 lng;            // Longitude\r\n    bytes2 countryId;     // countryID (in hexa), ISO ALPHA 2 https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\r\n    bytes16 postalCode;   // postalCode if present, in Hexa https://en.wikipedia.org/wiki/List_of_postal_codes\r\n\r\n    int8 currencyId;      // 1 - 100 , cf README\r\n    bytes16 messenger;    // telegrame nickname\r\n    int8 avatarId;        // 1 - 100 , regarding the front-end app you use\r\n    int16 rates;          // margin of tellers , -999 - +9999 , corresponding to -99,9% x 10  , 999,9% x 10\r\n\r\n    uint zoneIndex;       // index of the zone mapping\r\n    uint generalIndex;    // index of general mapping\r\n    bool online;          // switch online/offline, if the tellers want to be inactive without deleting his point\r\n  }\r\n\r\n  /*\r\n   * Reputation field V0.1\r\n   * Reputation is based on volume sell, volume buy, and number of transaction\r\n   */\r\n  mapping(address => uint) volumeBuy;\r\n  mapping(address => uint) volumeSell;\r\n  mapping(address => uint) nbTrade;\r\n\r\n  // general mapping of teller\r\n  mapping(address => Teller) teller;\r\n  // mappoing of teller by COUNTRYCODE => POSTALCODE\r\n  mapping(bytes2 => mapping(bytes16 => address[])) tellerInZone;\r\n  // teller array currently registered\r\n  address[] public tellerIndex; // unordered list of teller register on it\r\n  bool isStarted = false;\r\n  // shop struct\r\n  struct Shop {\r\n    int32 lat;            // latitude\r\n    int32 lng;            // longitude\r\n    bytes2 countryId;     // countryID (in hexa char), ISO ALPHA 2 https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\r\n    bytes16 postalCode;   // postalCode if present (in hexa char), in Hexa https://en.wikipedia.org/wiki/List_of_postal_codes\r\n    bytes16 cat;          // Category of the shop (in hex char), will be used later for search engine and auction by zone\r\n    bytes16 name;         // name of the shop (in hex char)\r\n    bytes32 description;  // description of the shop\r\n    bytes16 opening;      // opening hours, cf README for the format\r\n\r\n    uint zoneIndex;       // index of the zone mapping\r\n    uint generalIndex;    // index of general mapping\r\n    bool detherShop;      // bool if shop is registered by dether as business partnership (still required DTH)\r\n  }\r\n\r\n  // general mapping of shop\r\n  mapping(address => Shop) shop;\r\n  // mapping of teller by COUNTRYCODE => POSTALCODE\r\n  mapping(bytes2 => mapping(bytes16 => address[])) shopInZone;\r\n  // shop array currently registered\r\n  address[] public shopIndex; // unordered list of shop register on it\r\n\r\n  /*\r\n   * Instanciation\r\n   */\r\n  function DetherCore() {\r\n   ceoAddress = msg.sender;\r\n  }\r\n  function initContract (address _dth, address _bank) external onlyCEO {\r\n    require(!isStarted);\r\n    dth = ERC223Basic(_dth);\r\n    bank = DetherBank(_bank);\r\n    isStarted = true;\r\n  }\r\n\r\n  /**\r\n   * Core fonction\r\n   */\r\n\r\n  /**\r\n   * @dev Standard ERC223 function that will handle incoming token transfers.\r\n   * This is the main function to register SHOP or TELLER, its calling when you\r\n   * send token to the DTH contract and by passing data as bytes on the third\r\n   * parameter.\r\n   * Its not supposed to be use on its own but will only handle incoming DTH\r\n   * transaction.\r\n   * The _data will wait for\r\n   * [1st byte] 1 (0x31) for shop OR 2 (0x32) for teller\r\n   * FOR SHOP AND TELLER:\r\n   * 2sd to 5th bytes lat\r\n   * 6th to 9th bytes lng\r\n   * ...\r\n   * Modifier tier1: Check if address is whitelisted with the sms verification\r\n   */\r\n  function tokenFallback(address _from, uint _value, bytes _data) whenNotPaused tier1(_from ) {\r\n    // require than the token fallback is triggered from the dth token contract\r\n    require(msg.sender == address(dth));\r\n    // check first byte to know if its shop or teller registration\r\n    // 1 / 0x31 = shop // 2 / 0x32 = teller\r\n    bytes1 _func = _data.toBytes1(0);\r\n    int32 posLat = _data.toBytes1(1) == bytes1(0x01) ? int32(_data.toBytes4(2)) * -1 : int32(_data.toBytes4(2));\r\n    int32 posLng = _data.toBytes1(6) == bytes1(0x01) ? int32(_data.toBytes4(7)) * -1 : int32(_data.toBytes4(7));\r\n    if (_func == bytes1(0x31)) { // shop registration\r\n      // require staked greater than licence price\r\n      require(_value >= licenceShop[_data.toBytes2(11)]);\r\n      // require its not already shop\r\n      require(!isShop(_from));\r\n      // require zone is open\r\n      require(openedCountryShop[_data.toBytes2(11)]);\r\n\r\n      shop[_from].lat = posLat;\r\n      shop[_from].lng = posLng;\r\n      shop[_from].countryId = _data.toBytes2(11);\r\n      shop[_from].postalCode = _data.toBytes16(13);\r\n      shop[_from].cat = _data.toBytes16(29);\r\n      shop[_from].name = _data.toBytes16(45);\r\n      shop[_from].description = _data.toBytes32(61);\r\n      shop[_from].opening = _data.toBytes16(93);\r\n      shop[_from].generalIndex = shopIndex.push(_from) - 1;\r\n      shop[_from].zoneIndex = shopInZone[_data.toBytes2(11)][_data.toBytes16(13)].push(_from) - 1;\r\n      emit RegisterShop(_from);\r\n      bank.addTokenShop(_from,_value);\r\n      dth.transfer(address(bank), _value);\r\n    } else if (_func == bytes1(0x32)) { // teller registration\r\n      // require staked greater than licence price\r\n      require(_value >= licenceTeller[_data.toBytes2(11)]);\r\n      // require is not already a teller\r\n      require(!isTeller(_from));\r\n      // require zone is open\r\n      require(openedCountryTeller[_data.toBytes2(11)]);\r\n\r\n      teller[_from].lat = posLat;\r\n      teller[_from].lng = posLng;\r\n      teller[_from].countryId = _data.toBytes2(11);\r\n      teller[_from].postalCode = _data.toBytes16(13);\r\n      teller[_from].avatarId = int8(_data.toBytes1(29));\r\n      teller[_from].currencyId = int8(_data.toBytes1(30));\r\n      teller[_from].messenger = _data.toBytes16(31);\r\n      teller[_from].rates = int16(_data.toBytes2(47));\r\n      teller[_from].generalIndex = tellerIndex.push(_from) - 1;\r\n      teller[_from].zoneIndex = tellerInZone[_data.toBytes2(11)][_data.toBytes16(13)].push(_from) - 1;\r\n      teller[_from].online = true;\r\n      emit RegisterTeller(_from);\r\n      bank.addTokenTeller(_from, _value);\r\n      dth.transfer(address(bank), _value);\r\n    } else if (_func == bytes1(0x33)) {  // shop bulk registration\r\n      // We need to have the possibility to register in bulk some shop\r\n      // For big retailer company willing to be listed on dether, we need to have a way to add\r\n      // all their shop from one address\r\n      // This functionnality will become available for anyone willing to list multiple shop\r\n      // in the futures contract\r\n\r\n      // Only the CSO should be able to register shop in bulk\r\n      require(_from == csoAddress);\r\n      // Each shop still need his own staking\r\n      require(_value >= licenceShop[_data.toBytes2(11)]);\r\n      // require the addresses not already registered\r\n      require(!isShop(address(_data.toAddress(109))));\r\n      // require zone is open\r\n      require(openedCountryShop[_data.toBytes2(11)]);\r\n      address newShopAddress = _data.toAddress(109);\r\n      shop[newShopAddress].lat = posLat;\r\n      shop[newShopAddress].lng = posLng;\r\n      shop[newShopAddress].countryId = _data.toBytes2(11);\r\n      shop[newShopAddress].postalCode = _data.toBytes16(13);\r\n      shop[newShopAddress].cat = _data.toBytes16(29);\r\n      shop[newShopAddress].name = _data.toBytes16(45);\r\n      shop[newShopAddress].description = _data.toBytes32(61);\r\n      shop[newShopAddress].opening = _data.toBytes16(93);\r\n      shop[newShopAddress].generalIndex = shopIndex.push(newShopAddress) - 1;\r\n      shop[newShopAddress].zoneIndex = shopInZone[_data.toBytes2(11)][_data.toBytes16(13)].push(newShopAddress) - 1;\r\n      shop[newShopAddress].detherShop = true;\r\n      emit RegisterShop(newShopAddress);\r\n      bank.addTokenShop(newShopAddress, _value);\r\n      dth.transfer(address(bank), _value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * a teller can update his profile\r\n   * If a teller want to change his location, he would need to delete and recreate\r\n   * a new point\r\n   */\r\n  function updateTeller(\r\n    int8 currencyId,\r\n    bytes16 messenger,\r\n    int8 avatarId,\r\n    int16 rates,\r\n    bool online\r\n   ) public payable {\r\n    require(isTeller(msg.sender));\r\n    if (currencyId != teller[msg.sender].currencyId)\r\n    teller[msg.sender].currencyId = currencyId;\r\n    if (teller[msg.sender].messenger != messenger)\r\n     teller[msg.sender].messenger = messenger;\r\n    if (teller[msg.sender].avatarId != avatarId)\r\n     teller[msg.sender].avatarId = avatarId;\r\n    if (teller[msg.sender].rates != rates)\r\n     teller[msg.sender].rates = rates;\r\n    if (teller[msg.sender].online != online)\r\n      teller[msg.sender].online = online;\r\n    if (msg.value > 0) {\r\n      bank.addEthTeller.value(msg.value)(msg.sender, msg.value);\r\n    }\r\n    emit UpdateTeller(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * SellEth\r\n   * @param _to -> the address for the receiver\r\n   * @param _amount -> the amount to send\r\n   */\r\n  function sellEth(address _to, uint _amount) whenNotPaused external {\r\n    require(isTeller(msg.sender));\r\n    require(_to != msg.sender);\r\n    // send eth to the receiver from the bank contract\r\n    bank.withdrawEth(msg.sender, _to, _amount);\r\n    // increase reput for the buyer and the seller Only if the buyer is also whitelisted,\r\n    // It's a way to incentive user to trade on the system\r\n    if (smsCertifier.certified(_to)) {\r\n      volumeBuy[_to] = SafeMath.add(volumeBuy[_to], _amount);\r\n      volumeSell[msg.sender] = SafeMath.add(volumeSell[msg.sender], _amount);\r\n      nbTrade[msg.sender] += 1;\r\n    }\r\n    emit Sent(msg.sender, _to, _amount);\r\n  }\r\n\r\n  /**\r\n   * switchStatus\r\n   * Turn status teller on/off\r\n   */\r\n  function switchStatus(bool _status) external {\r\n    if (teller[msg.sender].online != _status)\r\n     teller[msg.sender].online = _status;\r\n  }\r\n\r\n  /**\r\n   * addFunds\r\n   * teller can add more funds on his sellpoint\r\n   */\r\n  function addFunds() external payable {\r\n    require(isTeller(msg.sender));\r\n    require(bank.addEthTeller.value(msg.value)(msg.sender, msg.value));\r\n  }\r\n\r\n  // gas used 67841\r\n  // a teller can delete a sellpoint\r\n  function deleteTeller() external {\r\n    require(isTeller(msg.sender));\r\n    uint rowToDelete1 = teller[msg.sender].zoneIndex;\r\n    address keyToMove1 = tellerInZone[teller[msg.sender].countryId][teller[msg.sender].postalCode][tellerInZone[teller[msg.sender].countryId][teller[msg.sender].postalCode].length - 1];\r\n    tellerInZone[teller[msg.sender].countryId][teller[msg.sender].postalCode][rowToDelete1] = keyToMove1;\r\n    teller[keyToMove1].zoneIndex = rowToDelete1;\r\n    tellerInZone[teller[msg.sender].countryId][teller[msg.sender].postalCode].length--;\r\n\r\n    uint rowToDelete2 = teller[msg.sender].generalIndex;\r\n    address keyToMove2 = tellerIndex[tellerIndex.length - 1];\r\n    tellerIndex[rowToDelete2] = keyToMove2;\r\n    teller[keyToMove2].generalIndex = rowToDelete2;\r\n    tellerIndex.length--;\r\n    delete teller[msg.sender];\r\n    bank.withdrawDthTeller(msg.sender);\r\n    bank.refundEth(msg.sender);\r\n    emit DeleteTeller(msg.sender);\r\n  }\r\n\r\n  // gas used 67841\r\n  // A moderator can delete a sellpoint\r\n  function deleteTellerMods(address _toDelete) isTellerModerator(msg.sender) external {\r\n    uint rowToDelete1 = teller[_toDelete].zoneIndex;\r\n    address keyToMove1 = tellerInZone[teller[_toDelete].countryId][teller[_toDelete].postalCode][tellerInZone[teller[_toDelete].countryId][teller[_toDelete].postalCode].length - 1];\r\n    tellerInZone[teller[_toDelete].countryId][teller[_toDelete].postalCode][rowToDelete1] = keyToMove1;\r\n    teller[keyToMove1].zoneIndex = rowToDelete1;\r\n    tellerInZone[teller[_toDelete].countryId][teller[_toDelete].postalCode].length--;\r\n\r\n    uint rowToDelete2 = teller[_toDelete].generalIndex;\r\n    address keyToMove2 = tellerIndex[tellerIndex.length - 1];\r\n    tellerIndex[rowToDelete2] = keyToMove2;\r\n    teller[keyToMove2].generalIndex = rowToDelete2;\r\n    tellerIndex.length--;\r\n    delete teller[_toDelete];\r\n    bank.withdrawDthTeller(_toDelete);\r\n    bank.refundEth(_toDelete);\r\n    emit DeleteTellerModerator(msg.sender, _toDelete);\r\n  }\r\n\r\n  // gas used 67841\r\n  // A shop owner can delete his point.\r\n  function deleteShop() external {\r\n    require(isShop(msg.sender));\r\n    uint rowToDelete1 = shop[msg.sender].zoneIndex;\r\n    address keyToMove1 = shopInZone[shop[msg.sender].countryId][shop[msg.sender].postalCode][shopInZone[shop[msg.sender].countryId][shop[msg.sender].postalCode].length - 1];\r\n    shopInZone[shop[msg.sender].countryId][shop[msg.sender].postalCode][rowToDelete1] = keyToMove1;\r\n    shop[keyToMove1].zoneIndex = rowToDelete1;\r\n    shopInZone[shop[msg.sender].countryId][shop[msg.sender].postalCode].length--;\r\n\r\n    uint rowToDelete2 = shop[msg.sender].generalIndex;\r\n    address keyToMove2 = shopIndex[shopIndex.length - 1];\r\n    shopIndex[rowToDelete2] = keyToMove2;\r\n    shop[keyToMove2].generalIndex = rowToDelete2;\r\n    shopIndex.length--;\r\n    delete shop[msg.sender];\r\n    bank.withdrawDthShop(msg.sender);\r\n    emit DeleteShop(msg.sender);\r\n  }\r\n\r\n  // gas used 67841\r\n  // Moderator can delete a shop point\r\n  function deleteShopMods(address _toDelete) isShopModerator(msg.sender) external {\r\n    uint rowToDelete1 = shop[_toDelete].zoneIndex;\r\n    address keyToMove1 = shopInZone[shop[_toDelete].countryId][shop[_toDelete].postalCode][shopInZone[shop[_toDelete].countryId][shop[_toDelete].postalCode].length - 1];\r\n    shopInZone[shop[_toDelete].countryId][shop[_toDelete].postalCode][rowToDelete1] = keyToMove1;\r\n    shop[keyToMove1].zoneIndex = rowToDelete1;\r\n    shopInZone[shop[_toDelete].countryId][shop[_toDelete].postalCode].length--;\r\n\r\n    uint rowToDelete2 = shop[_toDelete].generalIndex;\r\n    address keyToMove2 = shopIndex[shopIndex.length - 1];\r\n    shopIndex[rowToDelete2] = keyToMove2;\r\n    shop[keyToMove2].generalIndex = rowToDelete2;\r\n    shopIndex.length--;\r\n    if (!shop[_toDelete].detherShop)\r\n      bank.withdrawDthShop(_toDelete);\r\n    else\r\n      bank.withdrawDthShopAdmin(_toDelete, csoAddress);\r\n    delete shop[_toDelete];\r\n    emit DeleteShopModerator(msg.sender, _toDelete);\r\n  }\r\n\r\n  /**\r\n   *  GETTER\r\n   */\r\n\r\n  // get teller\r\n  // return teller info\r\n  function getTeller(address _teller) public view returns (\r\n    int32 lat,\r\n    int32 lng,\r\n    bytes2 countryId,\r\n    bytes16 postalCode,\r\n    int8 currencyId,\r\n    bytes16 messenger,\r\n    int8 avatarId,\r\n    int16 rates,\r\n    uint balance,\r\n    bool online,\r\n    uint sellVolume,\r\n    uint numTrade\r\n    ) {\r\n    Teller storage theTeller = teller[_teller];\r\n    lat = theTeller.lat;\r\n    lng = theTeller.lng;\r\n    countryId = theTeller.countryId;\r\n    postalCode = theTeller.postalCode;\r\n    currencyId = theTeller.currencyId;\r\n    messenger = theTeller.messenger;\r\n    avatarId = theTeller.avatarId;\r\n    rates = theTeller.rates;\r\n    online = theTeller.online;\r\n    sellVolume = volumeSell[_teller];\r\n    numTrade = nbTrade[_teller];\r\n    balance = bank.getEthBalTeller(_teller);\r\n  }\r\n\r\n  /*\r\n   * Shop ----------------------------------\r\n   * return Shop value\r\n   */\r\n  function getShop(address _shop) public view returns (\r\n   int32 lat,\r\n   int32 lng,\r\n   bytes2 countryId,\r\n   bytes16 postalCode,\r\n   bytes16 cat,\r\n   bytes16 name,\r\n   bytes32 description,\r\n   bytes16 opening\r\n   ) {\r\n    Shop storage theShop = shop[_shop];\r\n    lat = theShop.lat;\r\n    lng = theShop.lng;\r\n    countryId = theShop.countryId;\r\n    postalCode = theShop.postalCode;\r\n    cat = theShop.cat;\r\n    name = theShop.name;\r\n    description = theShop.description;\r\n    opening = theShop.opening;\r\n   }\r\n\r\n   // get reput\r\n   // return reputation data from teller\r\n  function getReput(address _teller) public view returns (\r\n   uint buyVolume,\r\n   uint sellVolume,\r\n   uint numTrade\r\n   ) {\r\n     buyVolume = volumeBuy[_teller];\r\n     sellVolume = volumeSell[_teller];\r\n     numTrade = nbTrade[_teller];\r\n  }\r\n  // return balance of teller put in escrow\r\n  function getTellerBalance(address _teller) public view returns (uint) {\r\n    return bank.getEthBalTeller(_teller);\r\n  }\r\n\r\n  // return an array of address of all zone present on a zone\r\n  // zone is a mapping COUNTRY => POSTALCODE\r\n  function getZoneShop(bytes2 _country, bytes16 _postalcode) public view returns (address[]) {\r\n     return shopInZone[_country][_postalcode];\r\n  }\r\n\r\n  // return array of address of all shop\r\n  function getAllShops() public view returns (address[]) {\r\n   return shopIndex;\r\n  }\r\n\r\n  function isShop(address _shop) public view returns (bool ){\r\n   return (shop[_shop].countryId != bytes2(0x0));\r\n  }\r\n\r\n  // return an array of address of all teller present on a zone\r\n  // zone is a mapping COUNTRY => POSTALCODE\r\n  function getZoneTeller(bytes2 _country, bytes16 _postalcode) public view returns (address[]) {\r\n     return tellerInZone[_country][_postalcode];\r\n  }\r\n\r\n  // return array of address of all teller\r\n  function getAllTellers() public view returns (address[]) {\r\n   return tellerIndex;\r\n  }\r\n\r\n  // return if teller or not\r\n  function isTeller(address _teller) public view returns (bool ){\r\n    return (teller[_teller].countryId != bytes2(0x0));\r\n  }\r\n\r\n  /*\r\n   * misc\r\n   */\r\n   // return info about how much DTH the shop has staked\r\n  function getStakedShop(address _shop) public view returns (uint) {\r\n    return bank.getDthShop(_shop);\r\n  }\r\n  // return info about how much DTH the teller has staked\r\n  function getStakedTeller(address _teller) public view returns (uint) {\r\n    return bank.getDthTeller(_teller);\r\n  }\r\n  // give ownership to the bank contract\r\n  function transferBankOwnership(address _newbankowner) external onlyCEO whenPaused {\r\n    bank.transferOwnership(_newbankowner);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"dth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isCSO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kycCertifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"licenceShop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shop\",\"type\":\"address\"}],\"name\":\"getShop\",\"outputs\":[{\"name\":\"lat\",\"type\":\"int32\"},{\"name\":\"lng\",\"type\":\"int32\"},{\"name\":\"countryId\",\"type\":\"bytes2\"},{\"name\":\"postalCode\",\"type\":\"bytes16\"},{\"name\":\"cat\",\"type\":\"bytes16\"},{\"name\":\"name\",\"type\":\"bytes16\"},{\"name\":\"description\",\"type\":\"bytes32\"},{\"name\":\"opening\",\"type\":\"bytes16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teller\",\"type\":\"address\"}],\"name\":\"getStakedTeller\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shop\",\"type\":\"address\"}],\"name\":\"isShop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_country\",\"type\":\"bytes2\"}],\"name\":\"openZoneTeller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCMO\",\"type\":\"address\"}],\"name\":\"setCMO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCSO\",\"type\":\"address\"}],\"name\":\"setCSO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"csoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teller\",\"type\":\"address\"}],\"name\":\"getReput\",\"outputs\":[{\"name\":\"buyVolume\",\"type\":\"uint256\"},{\"name\":\"sellVolume\",\"type\":\"uint256\"},{\"name\":\"numTrade\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dth\",\"type\":\"address\"},{\"name\":\"_bank\",\"type\":\"address\"}],\"name\":\"initContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"smsCertifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"switchStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currencyId\",\"type\":\"int8\"},{\"name\":\"messenger\",\"type\":\"bytes16\"},{\"name\":\"avatarId\",\"type\":\"int8\"},{\"name\":\"rates\",\"type\":\"int16\"},{\"name\":\"online\",\"type\":\"bool\"}],\"name\":\"updateTeller\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deleteShop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_shop\",\"type\":\"address\"}],\"name\":\"getStakedShop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTellers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moderator\",\"type\":\"address\"}],\"name\":\"removeShopModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teller\",\"type\":\"address\"}],\"name\":\"getTellerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_country\",\"type\":\"bytes2\"}],\"name\":\"openZoneShop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"shopModerators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newbankowner\",\"type\":\"address\"}],\"name\":\"transferBankOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"openedCountryShop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moderator\",\"type\":\"address\"}],\"name\":\"setShopModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shopIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deleteTeller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cmoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tellerIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"country\",\"type\":\"bytes2\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setLicenceShopPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_country\",\"type\":\"bytes2\"}],\"name\":\"closeZoneTeller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addFunds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moderator\",\"type\":\"address\"}],\"name\":\"removeTellerModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toDelete\",\"type\":\"address\"}],\"name\":\"deleteShopMods\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_country\",\"type\":\"bytes2\"},{\"name\":\"_postalcode\",\"type\":\"bytes16\"}],\"name\":\"getZoneShop\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_country\",\"type\":\"bytes2\"}],\"name\":\"closeZoneShop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tellerModerators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"openedCountryTeller\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moderator\",\"type\":\"address\"}],\"name\":\"setTellerModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"run2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllShops\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kycCertifier\",\"type\":\"address\"}],\"name\":\"setKycCertifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toDelete\",\"type\":\"address\"}],\"name\":\"deleteTellerMods\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"country\",\"type\":\"bytes2\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setLicenceTellerPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"licenceTeller\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teller\",\"type\":\"address\"}],\"name\":\"getTeller\",\"outputs\":[{\"name\":\"lat\",\"type\":\"int32\"},{\"name\":\"lng\",\"type\":\"int32\"},{\"name\":\"countryId\",\"type\":\"bytes2\"},{\"name\":\"postalCode\",\"type\":\"bytes16\"},{\"name\":\"currencyId\",\"type\":\"int8\"},{\"name\":\"messenger\",\"type\":\"bytes16\"},{\"name\":\"avatarId\",\"type\":\"int8\"},{\"name\":\"rates\",\"type\":\"int16\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"online\",\"type\":\"bool\"},{\"name\":\"sellVolume\",\"type\":\"uint256\"},{\"name\":\"numTrade\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"run1\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_country\",\"type\":\"bytes2\"},{\"name\":\"_postalcode\",\"type\":\"bytes16\"}],\"name\":\"getZoneTeller\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teller\",\"type\":\"address\"}],\"name\":\"isTeller\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_smsCertifier\",\"type\":\"address\"}],\"name\":\"setSmsCertifier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tellerAddress\",\"type\":\"address\"}],\"name\":\"RegisterTeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tellerAddress\",\"type\":\"address\"}],\"name\":\"DeleteTeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tellerAddress\",\"type\":\"address\"}],\"name\":\"UpdateTeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"shopAddress\",\"type\":\"address\"}],\"name\":\"RegisterShop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"shopAddress\",\"type\":\"address\"}],\"name\":\"DeleteShop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"moderator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shopAddress\",\"type\":\"address\"}],\"name\":\"DeleteShopModerator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"moderator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tellerAddress\",\"type\":\"address\"}],\"name\":\"DeleteTellerModerator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"DetherCore","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2ee67d4b02f6b6352e2ccdcecb6599d026a375af869d537f5ff8ce92f6e4d7e3"}]}