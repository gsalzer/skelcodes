{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\ncontract GroupBuyContract {\r\n  /*** CONSTANTS ***/\r\n  uint256 public constant MAX_CONTRIBUTION_SLOTS = 20;\r\n  uint256 private firstStepLimit =  0.053613 ether;\r\n  uint256 private secondStepLimit = 0.564957 ether;\r\n\r\n  /*** DATATYPES ***/\r\n  // @dev A Group is created for all the contributors who want to contribute\r\n  //  to the purchase of a particular token.\r\n  struct Group {\r\n    // Array of addresses of contributors in group\r\n    address[] contributorArr;\r\n    // Maps address to an address's position (+ 1) in the contributorArr;\r\n    // 1 is added to the position because zero is the default value in the mapping\r\n    mapping(address => uint256) addressToContributorArrIndex;\r\n    mapping(address => uint256) addressToContribution; // user address to amount contributed\r\n    bool exists; // For tracking whether a group has been initialized or not\r\n    uint256 contributedBalance; // Total amount contributed\r\n    uint256 purchasePrice; // Price of purchased token\r\n  }\r\n\r\n  // @dev A Contributor record is created for each user participating in\r\n  //  this group buy contract. It stores the group ids the user contributed to\r\n  //  and a record of their sale proceeds.\r\n  struct Contributor {\r\n    // Maps tokenId to an tokenId's position (+ 1) in the groupArr;\r\n    // 1 is added to the position because zero is the default value in the mapping\r\n    mapping(uint256 => uint) tokenIdToGroupArrIndex;\r\n    // Array of tokenIds contributed to by a contributor\r\n    uint256[] groupArr;\r\n    bool exists;\r\n    // Ledger for withdrawable balance for this user.\r\n    //  Funds can come from excess paid into a groupBuy,\r\n    //  or from withdrawing from a group, or from\r\n    //  sale proceeds from a token.\r\n    uint256 withdrawableBalance;\r\n  }\r\n\r\n  /*** EVENTS ***/\r\n  /// Admin Events\r\n  // @dev Event noting commission paid to contract\r\n  event Commission(uint256 _tokenId, uint256 amount);\r\n\r\n  /// Contract Events\r\n  // @dev Event signifiying that contract received funds via fallback fn\r\n  event FundsReceived(address _from, uint256 amount);\r\n\r\n  /// User Events\r\n  // @dev Event marking funds deposited into user _to's account\r\n  event FundsDeposited(address _to, uint256 amount);\r\n\r\n  // @dev Event marking a withdrawal of amount by user _to\r\n  event FundsWithdrawn(address _to, uint256 amount);\r\n\r\n  // @dev Event noting an interest distribution for user _to for token _tokenId.\r\n  //  Token Group will not be disbanded\r\n  event InterestDeposited(uint256 _tokenId, address _to, uint256 amount);\r\n\r\n  // @dev Event for when a contributor joins a token group _tokenId\r\n  event JoinGroup(\r\n    uint256 _tokenId,\r\n    address contributor,\r\n    uint256 groupBalance,\r\n    uint256 contributionAdded\r\n  );\r\n\r\n  // @dev Event for when a contributor leaves a token group\r\n  event LeaveGroup(\r\n    uint256 _tokenId,\r\n    address contributor,\r\n    uint256 groupBalance,\r\n    uint256 contributionSubtracted\r\n  );\r\n\r\n  // @dev Event noting sales proceeds distribution for user _to from sale of token _tokenId\r\n  event ProceedsDeposited(uint256 _tokenId, address _to, uint256 amount);\r\n\r\n  // @dev Event for when a token group purchases a token\r\n  event TokenPurchased(uint256 _tokenId, uint256 balance);\r\n\r\n  /*** STORAGE ***/\r\n  // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n  address public ceoAddress;\r\n  address public cfoAddress;\r\n  address public cooAddress1;\r\n  address public cooAddress2;\r\n  address public cooAddress3;\r\n\r\n  // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n  bool public paused = false;\r\n  bool public forking = false;\r\n\r\n  uint256 public activeGroups;\r\n  uint256 public commissionBalance;\r\n  uint256 private distributionNumerator;\r\n  uint256 private distributionDenominator;\r\n\r\n  CelebrityToken public linkedContract;\r\n\r\n  /// @dev A mapping from token IDs to the group associated with that token.\r\n  mapping(uint256 => Group) private tokenIndexToGroup;\r\n\r\n  // @dev A mapping from owner address to available balance not held by a Group.\r\n  mapping(address => Contributor) private userAddressToContributor;\r\n\r\n  /*** ACCESS MODIFIERS ***/\r\n  /// @dev Access modifier for CEO-only functionality\r\n  modifier onlyCEO() {\r\n    require(msg.sender == ceoAddress);\r\n    _;\r\n  }\r\n\r\n  /// @dev Access modifier for CFO-only functionality\r\n  modifier onlyCFO() {\r\n    require(msg.sender == cfoAddress);\r\n    _;\r\n  }\r\n\r\n  /// @dev Access modifier for COO-only functionality\r\n  modifier onlyCOO() {\r\n    require(\r\n      msg.sender == cooAddress1 ||\r\n      msg.sender == cooAddress2 ||\r\n      msg.sender == cooAddress3\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev Access modifier for contract managers only functionality\r\n  modifier onlyCLevel() {\r\n    require(\r\n      msg.sender == ceoAddress ||\r\n      msg.sender == cooAddress1 ||\r\n      msg.sender == cooAddress2 ||\r\n      msg.sender == cooAddress3 ||\r\n      msg.sender == cfoAddress\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /// @dev Modifier to allow actions only when the contract IS paused\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /// @dev Modifier to allow actions only when the contract IS NOT in forking mode\r\n  modifier whenNotForking() {\r\n    require(!forking);\r\n    _;\r\n  }\r\n\r\n  /// @dev Modifier to allow actions only when the contract IS in forking mode\r\n  modifier whenForking {\r\n    require(forking);\r\n    _;\r\n  }\r\n\r\n  /*** CONSTRUCTOR ***/\r\n  function GroupBuyContract(address contractAddress, uint256 numerator, uint256 denominator) public {\r\n    ceoAddress = msg.sender;\r\n    cooAddress1 = msg.sender;\r\n    cooAddress2 = msg.sender;\r\n    cooAddress3 = msg.sender;\r\n    cfoAddress = msg.sender;\r\n    distributionNumerator = numerator;\r\n    distributionDenominator = denominator;\r\n    linkedContract = CelebrityToken(contractAddress);\r\n  }\r\n\r\n  /*** PUBLIC FUNCTIONS ***/\r\n  /// @notice Fallback fn for receiving ether\r\n  function() external payable {\r\n    FundsReceived(msg.sender, msg.value);\r\n  }\r\n\r\n  /** Action Fns **/\r\n  /// @notice Backup function for activating token purchase\r\n  ///  requires sender to be a member of the group or CLevel\r\n  /// @param _tokenId The ID of the Token group\r\n  function activatePurchase(uint256 _tokenId) external whenNotPaused {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    require(group.addressToContribution[msg.sender] > 0 ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cooAddress1 ||\r\n            msg.sender == cooAddress2 ||\r\n            msg.sender == cooAddress3 ||\r\n            msg.sender == cfoAddress);\r\n\r\n    // Safety check that enough money has been contributed to group\r\n    var price = linkedContract.priceOf(_tokenId);\r\n    require(group.contributedBalance >= price);\r\n\r\n    // Safety check that token had not be purchased yet\r\n    require(group.purchasePrice == 0);\r\n\r\n    _purchase(_tokenId, price);\r\n  }\r\n\r\n  /// @notice Allow user to contribute to _tokenId token group\r\n  /// @param _tokenId The ID of the token group to be joined\r\n  function contributeToTokenGroup(uint256 _tokenId)\r\n  external payable whenNotForking whenNotPaused {\r\n    address userAdd = msg.sender;\r\n    // Safety check to prevent against an un  expected 0x0 default.\r\n    require(_addressNotNull(userAdd));\r\n\r\n    /// Safety check to make sure contributor has not already joined this group\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    var contributor = userAddressToContributor[userAdd];\r\n    if (!group.exists) { // Create group if not exists\r\n      group.exists = true;\r\n      activeGroups += 1;\r\n    } else {\r\n      require(group.addressToContributorArrIndex[userAdd] == 0);\r\n    }\r\n\r\n    if (!contributor.exists) { // Create contributor if not exists\r\n      userAddressToContributor[userAdd].exists = true;\r\n    } else {\r\n      require(contributor.tokenIdToGroupArrIndex[_tokenId] == 0);\r\n    }\r\n\r\n    // Safety check to make sure group isn't currently holding onto token\r\n    //  or has a group record stored (for sales proceeds distribution)\r\n    require(group.purchasePrice == 0);\r\n\r\n    /// Safety check to ensure amount contributed is higher than min required percentage\r\n    ///  of purchase price\r\n    uint256 tokenPrice = linkedContract.priceOf(_tokenId);\r\n    require(msg.value >= uint256(SafeMath.div(tokenPrice, MAX_CONTRIBUTION_SLOTS)));\r\n\r\n    // Index saved is 1 + the array's index, b/c 0 is the default value in a mapping,\r\n    //  so as stored on the mapping, array index will begin at 1\r\n    uint256 cIndex = tokenIndexToGroup[_tokenId].contributorArr.push(userAdd);\r\n    tokenIndexToGroup[_tokenId].addressToContributorArrIndex[userAdd] = cIndex;\r\n\r\n    uint256 amountNeeded = SafeMath.sub(tokenPrice, group.contributedBalance);\r\n    if (msg.value > amountNeeded) {\r\n      tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = amountNeeded;\r\n      tokenIndexToGroup[_tokenId].contributedBalance += amountNeeded;\r\n      // refund excess paid\r\n      userAddressToContributor[userAdd].withdrawableBalance += SafeMath.sub(msg.value, amountNeeded);\r\n      FundsDeposited(userAdd, SafeMath.sub(msg.value, amountNeeded));\r\n    } else {\r\n      tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = msg.value;\r\n      tokenIndexToGroup[_tokenId].contributedBalance += msg.value;\r\n    }\r\n\r\n    // Index saved is 1 + the array's index, b/c 0 is the default value in a mapping,\r\n    //  so as stored on the mapping, array index will begin at 1\r\n    uint256 gIndex = userAddressToContributor[userAdd].groupArr.push(_tokenId);\r\n    userAddressToContributor[userAdd].tokenIdToGroupArrIndex[_tokenId] = gIndex;\r\n\r\n    JoinGroup(\r\n      _tokenId,\r\n      userAdd,\r\n      tokenIndexToGroup[_tokenId].contributedBalance,\r\n      tokenIndexToGroup[_tokenId].addressToContribution[userAdd]\r\n    );\r\n\r\n    // Purchase token if enough funds contributed\r\n    if (tokenIndexToGroup[_tokenId].contributedBalance >= tokenPrice) {\r\n      _purchase(_tokenId, tokenPrice);\r\n    }\r\n  }\r\n\r\n  /// @notice Allow user to leave purchase group; note that their contribution\r\n  ///  will be added to their withdrawable balance, and not directly refunded.\r\n  ///  User can call withdrawBalance to retrieve funds.\r\n  /// @param _tokenId The ID of the Token purchase group to be left\r\n  function leaveTokenGroup(uint256 _tokenId) external whenNotPaused {\r\n    address userAdd = msg.sender;\r\n\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    var contributor = userAddressToContributor[userAdd];\r\n\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_addressNotNull(userAdd));\r\n\r\n    // Safety check to make sure group exists;\r\n    require(group.exists);\r\n\r\n    // Safety check to make sure group hasn't purchased token already\r\n    require(group.purchasePrice == 0);\r\n\r\n    // Safety checks to ensure contributor has contributed to group\r\n    require(group.addressToContributorArrIndex[userAdd] > 0);\r\n    require(contributor.tokenIdToGroupArrIndex[_tokenId] > 0);\r\n\r\n    uint refundBalance = _clearContributorRecordInGroup(_tokenId, userAdd);\r\n    _clearGroupRecordInContributor(_tokenId, userAdd);\r\n\r\n    userAddressToContributor[userAdd].withdrawableBalance += refundBalance;\r\n    FundsDeposited(userAdd, refundBalance);\r\n\r\n    LeaveGroup(\r\n      _tokenId,\r\n      userAdd,\r\n      tokenIndexToGroup[_tokenId].contributedBalance,\r\n      refundBalance\r\n    );\r\n  }\r\n\r\n  /// @notice Allow user to leave purchase group; note that their contribution\r\n  ///  and any funds they have in their withdrawableBalance will transfered to them.\r\n  /// @param _tokenId The ID of the Token purchase group to be left\r\n  function leaveTokenGroupAndWithdrawBalance(uint256 _tokenId) external whenNotPaused {\r\n    address userAdd = msg.sender;\r\n\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    var contributor = userAddressToContributor[userAdd];\r\n\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_addressNotNull(userAdd));\r\n\r\n    // Safety check to make sure group exists;\r\n    require(group.exists);\r\n\r\n    // Safety check to make sure group hasn't purchased token already\r\n    require(group.purchasePrice == 0);\r\n\r\n    // Safety checks to ensure contributor has contributed to group\r\n    require(group.addressToContributorArrIndex[userAdd] > 0);\r\n    require(contributor.tokenIdToGroupArrIndex[_tokenId] > 0);\r\n\r\n    uint refundBalance = _clearContributorRecordInGroup(_tokenId, userAdd);\r\n    _clearGroupRecordInContributor(_tokenId, userAdd);\r\n\r\n    userAddressToContributor[userAdd].withdrawableBalance += refundBalance;\r\n    FundsDeposited(userAdd, refundBalance);\r\n\r\n    _withdrawUserFunds(userAdd);\r\n\r\n    LeaveGroup(\r\n      _tokenId,\r\n      userAdd,\r\n      tokenIndexToGroup[_tokenId].contributedBalance,\r\n      refundBalance\r\n    );\r\n  }\r\n\r\n  /// @dev Withdraw balance from own account\r\n  function withdrawBalance() external whenNotPaused {\r\n    require(_addressNotNull(msg.sender));\r\n    require(userAddressToContributor[msg.sender].exists);\r\n\r\n    _withdrawUserFunds(msg.sender);\r\n  }\r\n\r\n  /** Admin Fns **/\r\n  /// @notice Fn for adjusting commission rate\r\n  /// @param numerator Numerator for calculating funds distributed\r\n  /// @param denominator Denominator for calculating funds distributed\r\n  function adjustCommission(uint256 numerator, uint256 denominator) external onlyCLevel {\r\n    require(numerator <= denominator);\r\n    distributionNumerator = numerator;\r\n    distributionDenominator = denominator;\r\n  }\r\n\r\n  /// @dev In the event of needing a fork, this function moves all\r\n  ///  of a group's contributors' contributions into their withdrawable balance.\r\n  /// @notice Group is dissolved after fn call\r\n  /// @param _tokenId The ID of the Token purchase group\r\n  function dissolveTokenGroup(uint256 _tokenId) external onlyCOO whenForking {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n\r\n    // Safety check to make sure group exists and had not purchased a token\r\n    require(group.exists);\r\n    require(group.purchasePrice == 0);\r\n\r\n    for (uint i = 0; i < tokenIndexToGroup[_tokenId].contributorArr.length; i++) {\r\n      address userAdd = tokenIndexToGroup[_tokenId].contributorArr[i];\r\n\r\n      var userContribution = group.addressToContribution[userAdd];\r\n\r\n      _clearGroupRecordInContributor(_tokenId, userAdd);\r\n\r\n      // clear contributor record on group\r\n      tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = 0;\r\n      tokenIndexToGroup[_tokenId].addressToContributorArrIndex[userAdd] = 0;\r\n\r\n      // move contributor's contribution to their withdrawable balance\r\n      userAddressToContributor[userAdd].withdrawableBalance += userContribution;\r\n      ProceedsDeposited(_tokenId, userAdd, userContribution);\r\n    }\r\n    activeGroups -= 1;\r\n    tokenIndexToGroup[_tokenId].exists = false;\r\n  }\r\n\r\n  /// @dev Backup fn to allow distribution of funds after sale,\r\n  ///  for the special scenario where an alternate sale platform is used;\r\n  /// @notice Group is dissolved after fn call\r\n  /// @param _tokenId The ID of the Token purchase group\r\n  /// @param _amount Funds to be distributed\r\n  function distributeCustomSaleProceeds(uint256 _tokenId, uint256 _amount) external onlyCOO {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n\r\n    // Safety check to make sure group exists and had purchased the token\r\n    require(group.exists);\r\n    require(group.purchasePrice > 0);\r\n    require(_amount > 0);\r\n\r\n    _distributeProceeds(_tokenId, _amount);\r\n  }\r\n\r\n  /* /// @dev Allow distribution of interest payment,\r\n  ///  Group is intact after fn call\r\n  /// @param _tokenId The ID of the Token purchase group\r\n  function distributeInterest(uint256 _tokenId) external onlyCOO payable {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    var amount = msg.value;\r\n    var excess = amount;\r\n\r\n    // Safety check to make sure group exists and had purchased the token\r\n    require(group.exists);\r\n    require(group.purchasePrice > 0);\r\n    require(amount > 0);\r\n\r\n    for (uint i = 0; i < tokenIndexToGroup[_tokenId].contributorArr.length; i++) {\r\n      address userAdd = tokenIndexToGroup[_tokenId].contributorArr[i];\r\n\r\n      // calculate contributor's interest proceeds and add to their withdrawable balance\r\n      uint256 userProceeds = uint256(SafeMath.div(SafeMath.mul(amount,\r\n        tokenIndexToGroup[_tokenId].addressToContribution[userAdd]),\r\n        tokenIndexToGroup[_tokenId].contributedBalance));\r\n      userAddressToContributor[userAdd].withdrawableBalance += userProceeds;\r\n\r\n      excess -= userProceeds;\r\n\r\n      InterestDeposited(_tokenId, userAdd, userProceeds);\r\n    }\r\n    commissionBalance += excess;\r\n    Commission(_tokenId, excess);\r\n  } */\r\n\r\n  /// @dev Distribute funds after a token is sold.\r\n  ///  Group is dissolved after fn call\r\n  /// @param _tokenId The ID of the Token purchase group\r\n  function distributeSaleProceeds(uint256 _tokenId) external onlyCOO {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n\r\n    // Safety check to make sure group exists and had purchased the token\r\n    require(group.exists);\r\n    require(group.purchasePrice > 0);\r\n\r\n    // Safety check to make sure token had been sold\r\n    uint256 currPrice = linkedContract.priceOf(_tokenId);\r\n    uint256 soldPrice = _newPrice(group.purchasePrice);\r\n    require(currPrice > soldPrice);\r\n\r\n    uint256 paymentIntoContract = uint256(SafeMath.div(SafeMath.mul(soldPrice, 94), 100));\r\n    _distributeProceeds(_tokenId, paymentIntoContract);\r\n  }\r\n\r\n  /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n  ///  a bug or exploit is detected and we need to limit damage.\r\n  function pause() external onlyCLevel whenNotPaused {\r\n    paused = true;\r\n  }\r\n\r\n  /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n  ///  one reason we may pause the contract is when CFO or COO accounts are\r\n  ///  compromised.\r\n  function unpause() external onlyCEO whenPaused {\r\n    // can't unpause if contract was upgraded\r\n    paused = false;\r\n  }\r\n\r\n  /// @dev Called by any \"C-level\" role to set the contract to . Used only when\r\n  ///  a bug or exploit is detected and we need to limit damage.\r\n  function setToForking() external onlyCLevel whenNotForking {\r\n    forking = true;\r\n  }\r\n\r\n  /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n  ///  one reason we may pause the contract is when CFO or COO accounts are\r\n  ///  compromised.\r\n  function setToNotForking() external onlyCEO whenForking {\r\n    // can't unpause if contract was upgraded\r\n    forking = false;\r\n  }\r\n\r\n  /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n  /// @param _newCEO The address of the new CEO\r\n  function setCEO(address _newCEO) external onlyCEO {\r\n    require(_newCEO != address(0));\r\n\r\n    ceoAddress = _newCEO;\r\n  }\r\n\r\n  /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\r\n  /// @param _newCFO The address of the new CFO\r\n  function setCFO(address _newCFO) external onlyCEO {\r\n    require(_newCFO != address(0));\r\n\r\n    cfoAddress = _newCFO;\r\n  }\r\n\r\n  /// @dev Assigns a new address to act as the COO1. Only available to the current CEO.\r\n  /// @param _newCOO1 The address of the new COO1\r\n  function setCOO1(address _newCOO1) external onlyCEO {\r\n    require(_newCOO1 != address(0));\r\n\r\n    cooAddress1 = _newCOO1;\r\n  }\r\n\r\n  /// @dev Assigns a new address to act as the COO2. Only available to the current CEO.\r\n  /// @param _newCOO2 The address of the new COO2\r\n  function setCOO2(address _newCOO2) external onlyCEO {\r\n    require(_newCOO2 != address(0));\r\n\r\n    cooAddress2 = _newCOO2;\r\n  }\r\n\r\n  /// @dev Assigns a new address to act as the COO3. Only available to the current CEO.\r\n  /// @param _newCOO3 The address of the new COO3\r\n  function setCOO3(address _newCOO3) external onlyCEO {\r\n    require(_newCOO3 != address(0));\r\n\r\n    cooAddress3 = _newCOO3;\r\n  }\r\n\r\n  /// @dev Backup fn to allow transfer of token out of\r\n  ///  contract, for use where a purchase group wants to use an alternate\r\n  ///  selling platform\r\n  /// @param _tokenId The ID of the Token purchase group\r\n  /// @param _to Address to transfer token to\r\n  function transferToken(uint256 _tokenId, address _to) external onlyCOO {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n\r\n    // Safety check to make sure group exists and had purchased the token\r\n    require(group.exists);\r\n    require(group.purchasePrice > 0);\r\n\r\n    linkedContract.transfer(_to, _tokenId);\r\n  }\r\n\r\n  /// @dev Withdraws sale commission, CFO-only functionality\r\n  /// @param _to Address for commission to be sent to\r\n  function withdrawCommission(address _to) external onlyCFO {\r\n    uint256 balance = commissionBalance;\r\n    address transferee = (_to == address(0)) ? cfoAddress : _to;\r\n    commissionBalance = 0;\r\n    if (balance > 0) {\r\n      transferee.transfer(balance);\r\n    }\r\n    FundsWithdrawn(transferee, balance);\r\n  }\r\n\r\n  /** Information Query Fns **/\r\n  /// @dev Get contributed balance in _tokenId token group for user\r\n  /// @param _tokenId The ID of the token to be queried\r\n  function getContributionBalanceForTokenGroup(uint256 _tokenId, address userAdd) external view returns (uint balance) {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    require(group.exists);\r\n    balance = group.addressToContribution[userAdd];\r\n  }\r\n\r\n  /// @dev Get contributed balance in _tokenId token group for user\r\n  /// @param _tokenId The ID of the token to be queried\r\n  function getSelfContributionBalanceForTokenGroup(uint256 _tokenId) external view returns (uint balance) {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    require(group.exists);\r\n    balance = group.addressToContribution[msg.sender];\r\n  }\r\n\r\n  /// @dev Get array of contributors' addresses in _tokenId token group\r\n  /// @param _tokenId The ID of the token to be queried\r\n  function getContributorsInTokenGroup(uint256 _tokenId) external view returns (address[] contribAddr) {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    require(group.exists);\r\n    contribAddr = group.contributorArr;\r\n  }\r\n\r\n  /// @dev Get no. of contributors in _tokenId token group\r\n  /// @param _tokenId The ID of the token to be queried\r\n  function getContributorsInTokenGroupCount(uint256 _tokenId) external view returns (uint count) {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    require(group.exists);\r\n    count = group.contributorArr.length;\r\n  }\r\n\r\n  /// @dev Get list of tokenIds of token groups a user contributed to\r\n  function getGroupsContributedTo(address userAdd) external view returns (uint256[] groupIds) {\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_addressNotNull(userAdd));\r\n\r\n    var contributor = userAddressToContributor[userAdd];\r\n    require(contributor.exists);\r\n\r\n    groupIds = contributor.groupArr;\r\n  }\r\n\r\n  /// @dev Get list of tokenIds of token groups the user contributed to\r\n  function getSelfGroupsContributedTo() external view returns (uint256[] groupIds) {\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_addressNotNull(msg.sender));\r\n\r\n    var contributor = userAddressToContributor[msg.sender];\r\n    require(contributor.exists);\r\n\r\n    groupIds = contributor.groupArr;\r\n  }\r\n\r\n  /// @dev Get price at which token group purchased _tokenId token\r\n  function getGroupPurchasedPrice(uint256 _tokenId) external view returns (uint256 price) {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    require(group.exists);\r\n    require(group.purchasePrice > 0);\r\n    price = group.purchasePrice;\r\n  }\r\n\r\n  /// @dev Get withdrawable balance from sale proceeds for a user\r\n  function getWithdrawableBalance() external view returns (uint256 balance) {\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_addressNotNull(msg.sender));\r\n\r\n    var contributor = userAddressToContributor[msg.sender];\r\n    require(contributor.exists);\r\n\r\n    balance = contributor.withdrawableBalance;\r\n  }\r\n\r\n  /// @dev Get total contributed balance in _tokenId token group\r\n  /// @param _tokenId The ID of the token group to be queried\r\n  function getTokenGroupTotalBalance(uint256 _tokenId) external view returns (uint balance) {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n    require(group.exists);\r\n    balance = group.contributedBalance;\r\n  }\r\n\r\n  /*** PRIVATE FUNCTIONS ***/\r\n  /// @dev Safety check on _to address to prevent against an unexpected 0x0 default.\r\n  /// @param _to Address to be checked\r\n  function _addressNotNull(address _to) private pure returns (bool) {\r\n    return _to != address(0);\r\n  }\r\n\r\n  /// @dev Clears record of a Contributor from a Group's record\r\n  /// @param _tokenId Token ID of Group to be cleared\r\n  /// @param _userAdd Address of Contributor\r\n  function _clearContributorRecordInGroup(uint256 _tokenId, address _userAdd) private returns (uint256 refundBalance) {\r\n    var group = tokenIndexToGroup[_tokenId];\r\n\r\n    // Index was saved is 1 + the array's index, b/c 0 is the default value\r\n    //  in a mapping.\r\n    uint cIndex = group.addressToContributorArrIndex[_userAdd] - 1;\r\n    uint lastCIndex = group.contributorArr.length - 1;\r\n    refundBalance = group.addressToContribution[_userAdd];\r\n\r\n    // clear contribution record in group\r\n    tokenIndexToGroup[_tokenId].addressToContributorArrIndex[_userAdd] = 0;\r\n    tokenIndexToGroup[_tokenId].addressToContribution[_userAdd] = 0;\r\n\r\n    // move address in last position to deleted contributor's spot\r\n    if (lastCIndex > 0) {\r\n      tokenIndexToGroup[_tokenId].addressToContributorArrIndex[group.contributorArr[lastCIndex]] = cIndex;\r\n      tokenIndexToGroup[_tokenId].contributorArr[cIndex] = group.contributorArr[lastCIndex];\r\n    }\r\n\r\n    tokenIndexToGroup[_tokenId].contributorArr.length -= 1;\r\n    tokenIndexToGroup[_tokenId].contributedBalance -= refundBalance;\r\n  }\r\n\r\n  /// @dev Clears record of a Group from a Contributor's record\r\n  /// @param _tokenId Token ID of Group to be cleared\r\n  /// @param _userAdd Address of Contributor\r\n  function _clearGroupRecordInContributor(uint256 _tokenId, address _userAdd) private {\r\n    // Index saved is 1 + the array's index, b/c 0 is the default value\r\n    //  in a mapping.\r\n    uint gIndex = userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[_tokenId] - 1;\r\n    uint lastGIndex = userAddressToContributor[_userAdd].groupArr.length - 1;\r\n\r\n    // clear Group record in Contributor\r\n    userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[_tokenId] = 0;\r\n\r\n    // move tokenId from end of array to deleted Group record's spot\r\n    if (lastGIndex > 0) {\r\n      userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[userAddressToContributor[_userAdd].groupArr[lastGIndex]] = gIndex;\r\n      userAddressToContributor[_userAdd].groupArr[gIndex] = userAddressToContributor[_userAdd].groupArr[lastGIndex];\r\n    }\r\n\r\n    userAddressToContributor[_userAdd].groupArr.length -= 1;\r\n  }\r\n\r\n  /// @dev Redistribute proceeds from token purchase\r\n  /// @param _tokenId Token ID of token to be purchased\r\n  /// @param _amount Amount paid into contract for token\r\n  function _distributeProceeds(uint256 _tokenId, uint256 _amount) private {\r\n    uint256 fundsForDistribution = uint256(SafeMath.div(SafeMath.mul(_amount,\r\n      distributionNumerator), distributionDenominator));\r\n    uint256 commission = _amount;\r\n\r\n    for (uint i = 0; i < tokenIndexToGroup[_tokenId].contributorArr.length; i++) {\r\n      address userAdd = tokenIndexToGroup[_tokenId].contributorArr[i];\r\n\r\n      // calculate contributor's sale proceeds and add to their withdrawable balance\r\n      uint256 userProceeds = uint256(SafeMath.div(SafeMath.mul(fundsForDistribution,\r\n        tokenIndexToGroup[_tokenId].addressToContribution[userAdd]),\r\n        tokenIndexToGroup[_tokenId].contributedBalance));\r\n\r\n      _clearGroupRecordInContributor(_tokenId, userAdd);\r\n\r\n      // clear contributor record on group\r\n      tokenIndexToGroup[_tokenId].addressToContribution[userAdd] = 0;\r\n      tokenIndexToGroup[_tokenId].addressToContributorArrIndex[userAdd] = 0;\r\n\r\n      commission -= userProceeds;\r\n      userAddressToContributor[userAdd].withdrawableBalance += userProceeds;\r\n      ProceedsDeposited(_tokenId, userAdd, userProceeds);\r\n    }\r\n\r\n    commissionBalance += commission;\r\n    Commission(_tokenId, commission);\r\n\r\n    activeGroups -= 1;\r\n    tokenIndexToGroup[_tokenId].exists = false;\r\n    tokenIndexToGroup[_tokenId].contributorArr.length = 0;\r\n    tokenIndexToGroup[_tokenId].contributedBalance = 0;\r\n    tokenIndexToGroup[_tokenId].purchasePrice = 0;\r\n  }\r\n\r\n  /// @dev Calculates next price of celebrity token\r\n  /// @param _oldPrice Previous price\r\n  function _newPrice(uint256 _oldPrice) private view returns (uint256 newPrice) {\r\n    if (_oldPrice < firstStepLimit) {\r\n      // first stage\r\n      newPrice = SafeMath.div(SafeMath.mul(_oldPrice, 200), 94);\r\n    } else if (_oldPrice < secondStepLimit) {\r\n      // second stage\r\n      newPrice = SafeMath.div(SafeMath.mul(_oldPrice, 120), 94);\r\n    } else {\r\n      // third stage\r\n      newPrice = SafeMath.div(SafeMath.mul(_oldPrice, 115), 94);\r\n    }\r\n  }\r\n\r\n  /// @dev Calls CelebrityToken purchase fn and updates records\r\n  /// @param _tokenId Token ID of token to be purchased\r\n  /// @param _amount Amount to be paid to CelebrityToken\r\n  function _purchase(uint256 _tokenId, uint256 _amount) private {\r\n    tokenIndexToGroup[_tokenId].purchasePrice = _amount;\r\n    linkedContract.purchase.value(_amount)(_tokenId);\r\n    TokenPurchased(_tokenId, _amount);\r\n  }\r\n\r\n  function _withdrawUserFunds(address userAdd) private {\r\n    uint256 balance = userAddressToContributor[userAdd].withdrawableBalance;\r\n    userAddressToContributor[userAdd].withdrawableBalance = 0;\r\n\r\n    if (balance > 0) {\r\n      FundsWithdrawn(userAdd, balance);\r\n      userAdd.transfer(balance);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n  // Required methods\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function implementsERC721() public pure returns (bool);\r\n  function ownerOf(uint256 _tokenId) public view returns (address addr);\r\n  function takeOwnership(uint256 _tokenId) public;\r\n  function totalSupply() public view returns (uint256 total);\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function transfer(address _to, uint256 _tokenId) public;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 tokenId);\r\n  event Approval(address indexed owner, address indexed approved, uint256 tokenId);\r\n\r\n  // Optional\r\n  // function name() public view returns (string name);\r\n  // function symbol() public view returns (string symbol);\r\n  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\r\n  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\r\n}\r\n\r\n\r\ncontract CelebrityToken is ERC721 {\r\n\r\n  /*** EVENTS ***/\r\n\r\n  /// @dev The Birth event is fired whenever a new person comes into existence.\r\n  event Birth(uint256 tokenId, string name, address owner);\r\n\r\n  /// @dev The TokenSold event is fired whenever a token is sold.\r\n  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);\r\n\r\n  /// @dev Transfer event as defined in current draft of ERC721.\r\n  ///  ownership is assigned, including births.\r\n  event Transfer(address from, address to, uint256 tokenId);\r\n\r\n  /*** CONSTANTS ***/\r\n\r\n  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n  string public constant NAME = \"CryptoCelebrities\"; // solhint-disable-line\r\n  string public constant SYMBOL = \"CelebrityToken\"; // solhint-disable-line\r\n\r\n  address public ceoAddress;\r\n  address public cooAddress;\r\n\r\n  uint256 public promoCreatedCount;\r\n\r\n  /*** DATATYPES ***/\r\n  struct Person {\r\n    string name;\r\n  }\r\n\r\n  /*** CONSTRUCTOR ***/\r\n  function CelebrityToken() public {\r\n    ceoAddress = msg.sender;\r\n    cooAddress = msg.sender;\r\n  }\r\n\r\n  /*** PUBLIC FUNCTIONS ***/\r\n  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\r\n  /// @param _to The address to be granted transfer approval. Pass address(0) to\r\n  ///  clear all approvals.\r\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  /// @dev Required for ERC-721 compliance.\r\n  function approve(\r\n    address _to,\r\n    uint256 _tokenId\r\n  ) public;\r\n\r\n  /// For querying balance of a particular account\r\n  /// @param _owner The address for balance query\r\n  /// @dev Required for ERC-721 compliance.\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n  /// @dev Creates a new promo Person with the given name, with given _price and assignes it to an address.\r\n  function createPromoPerson(address _owner, string _name, uint256 _price) public;\r\n\r\n  /// @dev Creates a new Person with the given name.\r\n  function createContractPerson(string _name) public;\r\n\r\n  /// @notice Returns all the relevant information about a specific person.\r\n  /// @param _tokenId The tokenId of the person of interest.\r\n  function getPerson(uint256 _tokenId) public view returns (\r\n    string personName,\r\n    uint256 sellingPrice,\r\n    address owner\r\n  );\r\n\r\n  function implementsERC721() public pure returns (bool);\r\n\r\n  /// @dev Required for ERC-721 compliance.\r\n  function name() public pure returns (string);\r\n\r\n  /// For querying owner of token\r\n  /// @param _tokenId The tokenID for owner inquiry\r\n  /// @dev Required for ERC-721 compliance.\r\n  function ownerOf(uint256 _tokenId)\r\n    public\r\n    view\r\n    returns (address owner);\r\n    \r\n  function payout(address _to) public;\r\n\r\n  // Allows someone to send ether and obtain the token\r\n  function purchase(uint256 _tokenId) public payable;\r\n\r\n  function priceOf(uint256 _tokenId) public view returns (uint256 price);\r\n  /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n  /// @param _newCEO The address of the new CEO\r\n  function setCEO(address _newCEO) public;\r\n\r\n  /// @dev Assigns a new address to act as the COO. Only available to the current COO.\r\n  /// @param _newCOO The address of the new COO\r\n  function setCOO(address _newCOO) public;\r\n\r\n  /// @dev Required for ERC-721 compliance.\r\n  function symbol() public pure returns (string);\r\n  /// @notice Allow pre-approved user to take ownership of a token\r\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  /// @dev Required for ERC-721 compliance.\r\n  function takeOwnership(uint256 _tokenId) public;\r\n\r\n  /// @param _owner The owner whose celebrity tokens we are interested in.\r\n  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\r\n  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n  ///  not contract-to-contract calls.\r\n  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens);\r\n\r\n  /// For querying totalSupply of token\r\n  /// @dev Required for ERC-721 compliance.\r\n  function totalSupply() public view returns (uint256 total);\r\n\r\n  /// Owner initates the transfer of the token to another account\r\n  /// @param _to The address for the token to be transferred to.\r\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  /// @dev Required for ERC-721 compliance.\r\n  function transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  ) public;\r\n\r\n  /// Third-party initiates transfer of token from address _from to address _to\r\n  /// @param _from The address for the token to be transferred from.\r\n  /// @param _to The address for the token to be transferred to.\r\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  /// @dev Required for ERC-721 compliance.\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  ) public;\r\n\r\n  /*** PRIVATE FUNCTIONS ***/\r\n  /// Safety check on _to address to prevent against an unexpected 0x0 default.\r\n  function _addressNotNull(address _to) private pure returns (bool);\r\n\r\n  /// For checking approval of transfer for address _to\r\n  function _approved(address _to, uint256 _tokenId) private view returns (bool);\r\n\r\n  /// For creating Person\r\n  function _createPerson(string _name, address _owner, uint256 _price) private;\r\n\r\n  /// Check for token ownership\r\n  function _owns(address claimant, uint256 _tokenId) private view returns (bool);\r\n\r\n  /// For paying out balance on contract\r\n  function _payout(address _to) private;\r\n\r\n  /// @dev Assigns ownership of a specific Person to an address.\r\n  function _transfer(address _from, address _to, uint256 _tokenId) private;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"distributeSaleProceeds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setToForking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenGroupTotalBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setToNotForking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getSelfContributionBalanceForTokenGroup\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"dissolveTokenGroup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"userAdd\",\"type\":\"address\"}],\"name\":\"getContributionBalanceForTokenGroup\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forking\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"contributeToTokenGroup\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CONTRIBUTION_SLOTS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"leaveTokenGroup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getContributorsInTokenGroupCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getContributorsInTokenGroup\",\"outputs\":[{\"name\":\"contribAddr\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO2\",\"type\":\"address\"}],\"name\":\"setCOO2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"adjustCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"leaveTokenGroupAndWithdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawableBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO3\",\"type\":\"address\"}],\"name\":\"setCOO3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activeGroups\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSelfGroupsContributedTo\",\"outputs\":[{\"name\":\"groupIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAdd\",\"type\":\"address\"}],\"name\":\"getGroupsContributedTo\",\"outputs\":[{\"name\":\"groupIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"activatePurchase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"linkedContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getGroupPurchasedPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO1\",\"type\":\"address\"}],\"name\":\"setCOO1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distributeCustomSaleProceeds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Commission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InterestDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"groupBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contributionAdded\",\"type\":\"uint256\"}],\"name\":\"JoinGroup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"groupBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contributionSubtracted\",\"type\":\"uint256\"}],\"name\":\"LeaveGroup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProceedsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"TokenPurchased\",\"type\":\"event\"}]","ContractName":"GroupBuyContract","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bb5ed1edeb5149af3ab43ea9c7a6963b3c1374f700000000000000000000000000000000000000000000000000000000000000610000000000000000000000000000000000000000000000000000000000000064","Library":"","SwarmSource":"bzzr://3c7145beb8dd3ec20d09d90c8823e283d3e88c519aeb52819089d5cb7b2ba797"}]}