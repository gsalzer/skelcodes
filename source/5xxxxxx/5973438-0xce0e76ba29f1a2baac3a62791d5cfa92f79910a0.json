{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: contracts/ds-auth/auth.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/AssetPriceOracle.sol\r\n\r\ncontract AssetPriceOracle is DSAuth {\r\n    // Maximum value expressible with uint128 is 340282366920938463463374607431768211456.\r\n    // Using 18 decimals for price records (standard Ether precision), \r\n    // the possible values are between 0 and 340282366920938463463.374607431768211456.\r\n\r\n    struct AssetPriceRecord {\r\n        uint128 price;\r\n        bool isRecord;\r\n    }\r\n\r\n    mapping(uint128 => mapping(uint128 => AssetPriceRecord)) public assetPriceRecords;\r\n\r\n    event AssetPriceRecorded(\r\n        uint128 indexed assetId,\r\n        uint128 indexed blockNumber,\r\n        uint128 indexed price\r\n    );\r\n\r\n    constructor() public {\r\n    }\r\n    \r\n    function recordAssetPrice(uint128 assetId, uint128 blockNumber, uint128 price) public auth {\r\n        assetPriceRecords[assetId][blockNumber].price = price;\r\n        assetPriceRecords[assetId][blockNumber].isRecord = true;\r\n        emit AssetPriceRecorded(assetId, blockNumber, price);\r\n    }\r\n\r\n    function getAssetPrice(uint128 assetId, uint128 blockNumber) public view returns (uint128 price) {\r\n        AssetPriceRecord storage priceRecord = assetPriceRecords[assetId][blockNumber];\r\n        require(priceRecord.isRecord);\r\n        return priceRecord.price;\r\n    }\r\n\r\n    function () public {\r\n        // dont receive ether via fallback method (by not having 'payable' modifier on this function).\r\n    }\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n * Source: https://github.com/facuspagnuolo/zeppelin-solidity/blob/feature/705_add_safe_math_int_ops/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two unsigned integers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Multiplies two signed integers, throws on overflow.\r\n  */\r\n  function mul(int256 a, int256 b) internal pure returns (int256) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    int256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two unsigned integers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two signed integers, truncating the quotient.\r\n  */\r\n  function div(int256 a, int256 b) internal pure returns (int256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // Overflow only happens when the smallest negative int is multiplied by -1.\r\n    int256 INT256_MIN = int256((uint256(1) << 255));\r\n    assert(a != INT256_MIN || b != -1);\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two signed integers, throws on overflow.\r\n  */\r\n  function sub(int256 a, int256 b) internal pure returns (int256) {\r\n    int256 c = a - b;\r\n    assert((b >= 0 && c <= a) || (b < 0 && c > a));\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two unsigned integers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two signed integers, throws on overflow.\r\n  */\r\n  function add(int256 a, int256 b) internal pure returns (int256) {\r\n    int256 c = a + b;\r\n    assert((b >= 0 && c >= a) || (b < 0 && c < a));\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/ContractForDifference.sol\r\n\r\ncontract ContractForDifference is DSAuth {\r\n    using SafeMath for int256;\r\n\r\n    enum Position { Long, Short }\r\n    \r\n    /**\r\n     * A party to the contract. Either the maker or the taker.\r\n     */\r\n    struct Party {\r\n        address addr;\r\n        uint128 withdrawBalance; // Amount the Party can withdraw, as a result of settled contract.\r\n        Position position;\r\n        bool isPaid;\r\n    }\r\n    \r\n    struct Cfd {\r\n        Party maker;\r\n        Party taker;\r\n\r\n        uint128 assetId;\r\n        uint128 amount; // in Wei.\r\n        uint128 contractStartBlock; // Block number\r\n        uint128 contractEndBlock; // Block number\r\n\r\n        // CFD state variables\r\n        bool isTaken;\r\n        bool isSettled;\r\n        bool isRefunded;\r\n    }\r\n\r\n    uint128 public leverage = 1; // Global leverage of the CFD contract.\r\n    AssetPriceOracle public priceOracle;\r\n\r\n    mapping(uint128 => Cfd) public contracts;\r\n    uint128                 public numberOfContracts;\r\n\r\n    event LogMakeCfd (\r\n    uint128 indexed cfdId, \r\n    address indexed makerAddress, \r\n    Position indexed makerPosition,\r\n    uint128 assetId,\r\n    uint128 amount,\r\n    uint128 contractEndBlock);\r\n\r\n    event LogTakeCfd (\r\n    uint128 indexed cfdId,\r\n    address indexed makerAddress,\r\n    Position makerPosition,\r\n    address indexed takerAddress,\r\n    Position takerPosition,\r\n    uint128 assetId,\r\n    uint128 amount,\r\n    uint128 contractStartBlock,\r\n    uint128 contractEndBlock);\r\n\r\n    event LogCfdSettled (\r\n    uint128 indexed cfdId,\r\n    address indexed makerAddress,\r\n    address indexed takerAddress,\r\n    uint128 amount,\r\n    uint128 startPrice,\r\n    uint128 endPrice,\r\n    uint128 makerSettlement,\r\n    uint128 takerSettlement);\r\n\r\n    event LogCfdRefunded (\r\n    uint128 indexed cfdId,\r\n    address indexed makerAddress,\r\n    uint128 amount);\r\n\r\n    event LogCfdForceRefunded (\r\n    uint128 indexed cfdId,\r\n    address indexed makerAddress,\r\n    uint128 makerAmount,\r\n    address indexed takerAddress,\r\n    uint128 takerAmount);\r\n\r\n    event LogWithdrawal (\r\n    uint128 indexed cfdId,\r\n    address indexed withdrawalAddress,\r\n    uint128 amount);\r\n\r\n    // event Debug (\r\n    //     string description,\r\n    //     uint128 uintValue,\r\n    //     int128 intValue\r\n    // );\r\n\r\n    constructor(address priceOracleAddress) public {\r\n        priceOracle = AssetPriceOracle(priceOracleAddress);\r\n    }\r\n\r\n    function makeCfd(\r\n        address makerAddress,\r\n        uint128 assetId,\r\n        Position makerPosition,\r\n        uint128 contractEndBlock\r\n        )\r\n        public\r\n        payable\r\n        returns (uint128)\r\n    {\r\n        require(contractEndBlock > block.number); // Contract end block must be after current block.\r\n        require(msg.value > 0); // Contract Wei amount must be more than zero - contracts for zero Wei does not make sense.\r\n        require(makerAddress != address(0)); // Maker must provide a non-zero address.\r\n        \r\n        uint128 contractId = numberOfContracts;\r\n\r\n        /**\r\n         * Initialize CFD struct using tight variable packing pattern.\r\n         * See https://fravoll.github.io/solidity-patterns/tight_variable_packing.html\r\n         */\r\n        Party memory maker = Party(makerAddress, 0, makerPosition, false);\r\n        Party memory taker = Party(address(0), 0, Position.Long, false);\r\n        Cfd memory newCfd = Cfd(\r\n            maker,\r\n            taker,\r\n            assetId,\r\n            uint128(msg.value),\r\n            0,\r\n            contractEndBlock,\r\n            false,\r\n            false,\r\n            false\r\n        );\r\n\r\n        contracts[contractId] = newCfd;\r\n\r\n        // contracts[contractId].maker.addr = makerAddress;\r\n        // contracts[contractId].maker.position = makerPosition;\r\n        // contracts[contractId].assetId = assetId;\r\n        // contracts[contractId].amount = uint128(msg.value);\r\n        // contracts[contractId].contractEndBlock = contractEndBlock;\r\n\r\n        numberOfContracts++;\r\n        \r\n        emit LogMakeCfd(\r\n            contractId,\r\n            contracts[contractId].maker.addr,\r\n            contracts[contractId].maker.position,\r\n            contracts[contractId].assetId,\r\n            contracts[contractId].amount,\r\n            contracts[contractId].contractEndBlock\r\n        );\r\n\r\n        return contractId;\r\n    }\r\n\r\n    function getCfd(\r\n        uint128 cfdId\r\n        ) \r\n        public \r\n        view \r\n        returns (address makerAddress, Position makerPosition, address takerAddress, Position takerPosition, uint128 assetId, uint128 amount, uint128 startTime, uint128 endTime, bool isTaken, bool isSettled, bool isRefunded)\r\n        {\r\n        Cfd storage cfd = contracts[cfdId];\r\n        return (\r\n            cfd.maker.addr,\r\n            cfd.maker.position,\r\n            cfd.taker.addr,\r\n            cfd.taker.position,\r\n            cfd.assetId,\r\n            cfd.amount,\r\n            cfd.contractStartBlock,\r\n            cfd.contractEndBlock,\r\n            cfd.isTaken,\r\n            cfd.isSettled,\r\n            cfd.isRefunded\r\n        );\r\n    }\r\n\r\n    function takeCfd(\r\n        uint128 cfdId, \r\n        address takerAddress\r\n        ) \r\n        public\r\n        payable\r\n        returns (bool success) {\r\n        Cfd storage cfd = contracts[cfdId];\r\n        \r\n        require(cfd.isTaken != true);                  // Contract must not be taken.\r\n        require(cfd.isSettled != true);                // Contract must not be settled.\r\n        require(cfd.isRefunded != true);               // Contract must not be refunded.\r\n        require(cfd.maker.addr != address(0));         // Contract must have a maker,\r\n        require(cfd.taker.addr == address(0));         // and no taker.\r\n        // require(takerAddress != cfd.maker.addr);       // Maker and Taker must not be the same address. (disabled for now)\r\n        require(msg.value == cfd.amount);              // Takers deposit must match makers deposit.\r\n        require(takerAddress != address(0));           // Taker must provide a non-zero address.\r\n        require(block.number <= cfd.contractEndBlock); // Taker must take contract before end block.\r\n\r\n        cfd.taker.addr = takerAddress;\r\n        // Make taker position the inverse of maker position\r\n        cfd.taker.position = cfd.maker.position == Position.Long ? Position.Short : Position.Long;\r\n        cfd.contractStartBlock = uint128(block.number);\r\n        cfd.isTaken = true;\r\n\r\n        emit LogTakeCfd(\r\n            cfdId,\r\n            cfd.maker.addr,\r\n            cfd.maker.position,\r\n            cfd.taker.addr,\r\n            cfd.taker.position,\r\n            cfd.assetId,\r\n            cfd.amount,\r\n            cfd.contractStartBlock,\r\n            cfd.contractEndBlock\r\n        );\r\n            \r\n        return true;\r\n    }\r\n\r\n    function settleAndWithdrawCfd(\r\n        uint128 cfdId\r\n        )\r\n        public {\r\n        address makerAddr = contracts[cfdId].maker.addr;\r\n        address takerAddr = contracts[cfdId].taker.addr;\r\n\r\n        settleCfd(cfdId);\r\n        withdraw(cfdId, makerAddr);\r\n        withdraw(cfdId, takerAddr);\r\n    }\r\n\r\n    function settleCfd(\r\n        uint128 cfdId\r\n        )\r\n        public\r\n        returns (bool success) {\r\n        Cfd storage cfd = contracts[cfdId];\r\n\r\n        require(cfd.contractEndBlock <= block.number); // Contract must have met its end time.\r\n        require(!cfd.isSettled);                       // Contract must not be settled already.\r\n        require(!cfd.isRefunded);                      // Contract must not be refunded.\r\n        require(cfd.isTaken);                          // Contract must be taken.\r\n        require(cfd.maker.addr != address(0));         // Contract must have a maker address.\r\n        require(cfd.taker.addr != address(0));         // Contract must have a taker address.\r\n\r\n        // Get relevant variables\r\n        uint128 amount = cfd.amount;\r\n        uint128 startPrice = priceOracle.getAssetPrice(cfd.assetId, cfd.contractStartBlock);\r\n        uint128 endPrice = priceOracle.getAssetPrice(cfd.assetId, cfd.contractEndBlock);\r\n\r\n        /**\r\n         * Register settlements for maker and taker.\r\n         * Maker recieves any leftover wei from integer division.\r\n         */\r\n        uint128 takerSettlement = getSettlementAmount(amount, startPrice, endPrice, cfd.taker.position);\r\n        if (takerSettlement > 0) {\r\n            cfd.taker.withdrawBalance = takerSettlement;\r\n        }\r\n\r\n        uint128 makerSettlement = (amount * 2) - takerSettlement;\r\n        cfd.maker.withdrawBalance = makerSettlement;\r\n\r\n        // Mark contract as settled.\r\n        cfd.isSettled = true;\r\n\r\n        emit LogCfdSettled (\r\n            cfdId,\r\n            cfd.maker.addr,\r\n            cfd.taker.addr,\r\n            amount,\r\n            startPrice,\r\n            endPrice,\r\n            makerSettlement,\r\n            takerSettlement\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdraw(\r\n        uint128 cfdId, \r\n        address partyAddress\r\n    )\r\n    public {\r\n        Cfd storage cfd = contracts[cfdId];\r\n        Party storage party = partyAddress == cfd.maker.addr ? cfd.maker : cfd.taker;\r\n        require(party.withdrawBalance > 0); // The party must have a withdraw balance from previous settlement.\r\n        require(!party.isPaid); // The party must have already been paid out, fx from a refund.\r\n        \r\n        uint128 amount = party.withdrawBalance;\r\n        party.withdrawBalance = 0;\r\n        party.isPaid = true;\r\n        \r\n        party.addr.transfer(amount);\r\n\r\n        emit LogWithdrawal(\r\n            cfdId,\r\n            party.addr,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function getSettlementAmount(\r\n        uint128 amountUInt,\r\n        uint128 entryPriceUInt,\r\n        uint128 exitPriceUInt,\r\n        Position position\r\n    )\r\n    public\r\n    view\r\n    returns (uint128) {\r\n        require(position == Position.Long || position == Position.Short);\r\n\r\n        // If price didn't change, settle for equal amount to long and short.\r\n        if (entryPriceUInt == exitPriceUInt) {return amountUInt;}\r\n\r\n        // If entry price is 0 and exit price is more than 0, all must go to long position and nothing to short.\r\n        if (entryPriceUInt == 0 && exitPriceUInt > 0) {\r\n            return position == Position.Long ? amountUInt * 2 : 0;\r\n        }\r\n\r\n        // Cast uint128 to int256 to support negative numbers and increase over- and underflow limits\r\n        int256 entryPrice = int256(entryPriceUInt);\r\n        int256 exitPrice = int256(exitPriceUInt);\r\n        int256 amount = int256(amountUInt);\r\n\r\n        // Price diff calc depends on which position we are calculating settlement for.\r\n        int256 priceDiff = position == Position.Long ? exitPrice.sub(entryPrice) : entryPrice.sub(exitPrice);\r\n        int256 settlement = amount.add(priceDiff.mul(amount).mul(leverage).div(entryPrice));\r\n        if (settlement < 0) {\r\n            return 0; // Calculated settlement was negative. But a party can't lose more than his deposit, so he's just awarded 0.\r\n        } else if (settlement > amount * 2) {\r\n            return amountUInt * 2; // Calculated settlement was more than the total deposits, so settle for the total deposits.\r\n        } else {\r\n            return uint128(settlement); // Settlement was more than zero and less than sum of deposit amounts, so we can settle it as is.\r\n        }\r\n    }\r\n\r\n    function refundCfd(\r\n        uint128 cfdId\r\n    )\r\n    public\r\n    returns (bool success) {\r\n        Cfd storage cfd = contracts[cfdId];\r\n        require(!cfd.isSettled);                // Contract must not be settled already.\r\n        require(!cfd.isTaken);                  // Contract must not be taken.\r\n        require(!cfd.isRefunded);               // Contract must not be refunded already.\r\n        require(msg.sender == cfd.maker.addr);  // Function caller must be the contract maker.\r\n\r\n        cfd.isRefunded = true;\r\n        cfd.maker.isPaid = true;\r\n        cfd.maker.addr.transfer(cfd.amount);\r\n\r\n        emit LogCfdRefunded(\r\n            cfdId,\r\n            cfd.maker.addr,\r\n            cfd.amount\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function forceRefundCfd(\r\n        uint128 cfdId\r\n    )\r\n    public\r\n    auth\r\n    {\r\n        Cfd storage cfd = contracts[cfdId];\r\n        require(!cfd.isRefunded); // Contract must not be refunded already.\r\n\r\n        cfd.isRefunded = true;\r\n\r\n        // Refund Taker\r\n        uint128 takerAmount = 0;\r\n        if (cfd.taker.addr != address(0)) {\r\n            takerAmount = cfd.amount;\r\n            cfd.taker.withdrawBalance = 0; // Refunding must reset withdraw balance, if any.\r\n            cfd.taker.addr.transfer(cfd.amount);\r\n        }\r\n\r\n        // Refund Maker\r\n        cfd.maker.withdrawBalance = 0; // Refunding must reset withdraw balance, if any.\r\n        cfd.maker.addr.transfer(cfd.amount);\r\n        \r\n        emit LogCfdForceRefunded(\r\n            cfdId,\r\n            cfd.maker.addr,\r\n            cfd.amount,\r\n            cfd.taker.addr,\r\n            takerAmount\r\n        );\r\n    } \r\n\r\n    function () public {\r\n        // dont receive ether via fallback method (by not having 'payable' modifier on this function).\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amountUInt\",\"type\":\"uint128\"},{\"name\":\"entryPriceUInt\",\"type\":\"uint128\"},{\"name\":\"exitPriceUInt\",\"type\":\"uint128\"},{\"name\":\"position\",\"type\":\"uint8\"}],\"name\":\"getSettlementAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cfdId\",\"type\":\"uint128\"},{\"name\":\"partyAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cfdId\",\"type\":\"uint128\"}],\"name\":\"settleAndWithdrawCfd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leverage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cfdId\",\"type\":\"uint128\"}],\"name\":\"refundCfd\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint128\"},{\"name\":\"makerPosition\",\"type\":\"uint8\"},{\"name\":\"contractEndBlock\",\"type\":\"uint128\"}],\"name\":\"makeCfd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cfdId\",\"type\":\"uint128\"}],\"name\":\"forceRefundCfd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cfdId\",\"type\":\"uint128\"}],\"name\":\"settleCfd\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"contracts\",\"outputs\":[{\"components\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"withdrawBalance\",\"type\":\"uint128\"},{\"name\":\"position\",\"type\":\"uint8\"},{\"name\":\"isPaid\",\"type\":\"bool\"}],\"name\":\"maker\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"withdrawBalance\",\"type\":\"uint128\"},{\"name\":\"position\",\"type\":\"uint8\"},{\"name\":\"isPaid\",\"type\":\"bool\"}],\"name\":\"taker\",\"type\":\"tuple\"},{\"name\":\"assetId\",\"type\":\"uint128\"},{\"name\":\"amount\",\"type\":\"uint128\"},{\"name\":\"contractStartBlock\",\"type\":\"uint128\"},{\"name\":\"contractEndBlock\",\"type\":\"uint128\"},{\"name\":\"isTaken\",\"type\":\"bool\"},{\"name\":\"isSettled\",\"type\":\"bool\"},{\"name\":\"isRefunded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cfdId\",\"type\":\"uint128\"}],\"name\":\"getCfd\",\"outputs\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"makerPosition\",\"type\":\"uint8\"},{\"name\":\"takerAddress\",\"type\":\"address\"},{\"name\":\"takerPosition\",\"type\":\"uint8\"},{\"name\":\"assetId\",\"type\":\"uint128\"},{\"name\":\"amount\",\"type\":\"uint128\"},{\"name\":\"startTime\",\"type\":\"uint128\"},{\"name\":\"endTime\",\"type\":\"uint128\"},{\"name\":\"isTaken\",\"type\":\"bool\"},{\"name\":\"isSettled\",\"type\":\"bool\"},{\"name\":\"isRefunded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cfdId\",\"type\":\"uint128\"},{\"name\":\"takerAddress\",\"type\":\"address\"}],\"name\":\"takeCfd\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"priceOracleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cfdId\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"makerPosition\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"contractEndBlock\",\"type\":\"uint128\"}],\"name\":\"LogMakeCfd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cfdId\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerPosition\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"takerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerPosition\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"contractStartBlock\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"contractEndBlock\",\"type\":\"uint128\"}],\"name\":\"LogTakeCfd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cfdId\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"takerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"startPrice\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"endPrice\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"makerSettlement\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"takerSettlement\",\"type\":\"uint128\"}],\"name\":\"LogCfdSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cfdId\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"LogCfdRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cfdId\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerAmount\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"takerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"takerAmount\",\"type\":\"uint128\"}],\"name\":\"LogCfdForceRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"cfdId\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"withdrawalAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"LogWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"ContractForDifference","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004b7a34f1ef5c78226e9ca017595426188daac7ce","Library":"","SwarmSource":"bzzr://a6e9cfb5df25b150c8e3efbd3f4205598e687ae26f7363c3efc08e3564afeea1"}]}