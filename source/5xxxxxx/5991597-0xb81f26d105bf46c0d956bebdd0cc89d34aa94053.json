{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20Events {\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n}\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address guy) public view returns (uint);\r\n    function allowance(address src, address guy) public view returns (uint);\r\n\r\n    function approve(address guy, uint wad) public returns (bool);\r\n    function transfer(address dst, uint wad) public returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint wad\r\n    ) public returns (bool);\r\n}\r\n\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped;\r\n\r\n    modifier stoppable {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    constructor(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) public view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract DSToken is DSTokenBase(0), DSStop {\r\n\r\n    bytes32  public  symbol;\r\n    uint256  public  decimals = 18; // standard token precision. override to customize\r\n\r\n    constructor(bytes32 symbol_) public {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n\r\n    function approve(address guy) public stoppable returns (bool) {\r\n        return super.approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        return super.approve(guy, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function push(address dst, uint wad) public {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function pull(address src, uint wad) public {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) public {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    function mint(uint wad) public {\r\n        mint(msg.sender, wad);\r\n    }\r\n    function burn(uint wad) public {\r\n        burn(msg.sender, wad);\r\n    }\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        _balances[guy] = add(_balances[guy], wad);\r\n        _supply = add(_supply, wad);\r\n        emit Mint(guy, wad);\r\n    }\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\r\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\r\n        }\r\n\r\n        _balances[guy] = sub(_balances[guy], wad);\r\n        _supply = sub(_supply, wad);\r\n        emit Burn(guy, wad);\r\n    }\r\n\r\n    // Optional token name\r\n    bytes32   public  name = \"\";\r\n\r\n    function setName(bytes32 name_) public auth {\r\n        name = name_;\r\n    }\r\n}\r\n\r\ncontract ERC223ReceivingContract {\r\n\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param _from Transaction initiator, analogue of msg.sender\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @param _data Data containig a function signature and/or parameters\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) public;\r\n\r\n\r\n    /// @dev For ERC20 backward compatibility, same with above tokenFallback but without data.\r\n    /// The function execution could fail, but do not influence the token transfer.\r\n    /// @param _from Transaction initiator, analogue of msg.sender\r\n    /// @param _value Number of tokens to transfer.\r\n    //  function tokenFallback(address _from, uint256 _value) public;\r\n}\r\n\r\n\r\ncontract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable public returns (bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns (bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns (bool);\r\n}\r\n\r\n\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { if (msg.sender != controller) revert(); _; }\r\n\r\n    address public controller;\r\n\r\n    constructor() { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\r\n}\r\n\r\ncontract ERC223 {\r\n    function transfer(address to, uint amount, bytes data) public returns (bool ok);\r\n\r\n    function transferFrom(address from, address to, uint256 amount, bytes data) public returns (bool ok);\r\n\r\n    function transfer(address to, uint amount, bytes data, string custom_fallback) public returns (bool ok);\r\n\r\n    function transferFrom(address from, address to, uint256 amount, bytes data, string custom_fallback) public returns (bool ok);\r\n\r\n    event ERC223Transfer(address indexed from, address indexed to, uint amount, bytes data);\r\n\r\n    event ReceivingContractTokenFallbackFailed(address indexed from, address indexed to, uint amount);\r\n}\r\n\r\ncontract AKC is DSToken(\"AKC\"), ERC223, Controlled {\r\n\r\n    constructor() {\r\n        setName(\"ARTWOOK Coin\");\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) public returns (bool success) {\r\n        // Alerts the token controller of the transfer\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               revert();\r\n        }\r\n\r\n        success = super.transferFrom(_from, _to, _amount);\r\n\r\n        if (success && isContract(_to))\r\n        {\r\n            // ERC20 backward compatiability\r\n            if(!_to.call(bytes4(keccak256(\"tokenFallback(address,uint256)\")), _from, _amount)) {\r\n                // do nothing when error in call in case that the _to contract is not inherited from ERC223ReceivingContract\r\n                // revert();\r\n                // bytes memory empty;\r\n\r\n                emit ReceivingContractTokenFallbackFailed(_from, _to, _amount);\r\n\r\n                // Even the fallback failed if there is such one, the transfer will not be revert since \"revert()\" is not called.\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * ERC 223\r\n     * Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _amount, bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Alerts the token controller of the transfer\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               revert();\r\n        }\r\n\r\n        require(super.transferFrom(_from, _to, _amount));\r\n\r\n        if (isContract(_to)) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(_from, _amount, _data);\r\n        }\r\n\r\n        emit ERC223Transfer(_from, _to, _amount, _data);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * ERC 223\r\n     * Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     * https://github.com/ethereum/EIPs/issues/223\r\n     * function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\r\n     */\r\n    /// @notice Send `_value` tokens to `_to` from `msg.sender` and trigger\r\n    /// tokenFallback if sender is a contract.\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param _to Address of token receiver.\r\n    /// @param _amount Number of tokens to transfer.\r\n    /// @param _data Data to be sent to tokenFallback\r\n    /// @return Returns success of function call.\r\n    function transfer(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes _data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        return transferFrom(msg.sender, _to, _amount, _data);\r\n    }\r\n\r\n    /*\r\n     * ERC 223\r\n     * Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Alerts the token controller of the transfer\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               revert();\r\n        }\r\n\r\n        require(super.transferFrom(_from, _to, _amount));\r\n\r\n        if (isContract(_to)) {\r\n            if(_to == address(this)) revert();\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);\r\n        }\r\n\r\n        emit ERC223Transfer(_from, _to, _amount, _data);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * ERC 223\r\n     * Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint _amount,\r\n        bytes _data,\r\n        string _custom_fallback)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                revert();\r\n        }\r\n\r\n        return super.approve(_spender, _amount);\r\n    }\r\n\r\n    function mint(address _guy, uint _wad) auth stoppable {\r\n        super.mint(_guy, _wad);\r\n\r\n        Transfer(0, _guy, _wad);\r\n    }\r\n    function burn(address _guy, uint _wad) auth stoppable {\r\n        super.burn(_guy, _wad);\r\n\r\n        Transfer(_guy, 0, _wad);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        if (!approve(_spender, _amount)) revert();\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    /// @notice The fallback function: If the contract's controller has not been\r\n    ///  set to 0, then the `proxyPayment` method is called which relays the\r\n    ///  ether and creates tokens as described in the token controller contract\r\n    function ()  payable {\r\n        if (isContract(controller)) {\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                revert();\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n//////////\r\n// Safety Methods\r\n//////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20 token = ERC20(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        emit ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n////////////////\r\n// Events\r\n////////////////\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error.\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address that transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n    emit OwnershipTransferred(owner, newOwner);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Assign a paused status to contract to pause and continue later.\r\n *\r\n */\r\ncontract Pausable is Ownable {\r\n    bool public paused = false;\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    /**\r\n     * @dev Throws if paused is true.\r\n     */\r\n    modifier whenNotPaused() { require(!paused); _; }\r\n\r\n    /**\r\n     * @dev Throws if paused is false.\r\n     */\r\n    modifier whenPaused() { require(paused); _; }\r\n\r\n    /**\r\n     * @dev Set paused to true.\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Set paused to false.\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n/**\r\n * @title Withdrawable\r\n * @dev Allow contract owner to withdrow Ether or ERC20 token from contract.\r\n *\r\n */\r\ncontract Withdrawable is Ownable {\r\n    /**\r\n    * @dev withdraw Ether from contract\r\n    * @param _to The address transfer Ether to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function withdrawEther(address _to, uint _value) onlyOwner public returns(bool) {\r\n        require(_to != address(0));\r\n        require(address(this).balance >= _value);\r\n\r\n        _to.transfer(_value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev withdraw ERC20 token from contract\r\n    * @param _token ERC20 token contract address.\r\n    * @param _to The address transfer Token to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function withdrawTokens(ERC20 _token, address _to, uint _value) onlyOwner public returns(bool) {\r\n        require(_to != address(0));\r\n\r\n        return _token.transfer(_to, _value);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ArtwookCoinCrowdsale\r\n * @dev AKC token sale contract.\r\n */\r\ncontract AKCCrowdsale is Pausable, Withdrawable {\r\n  using SafeMath for uint;\r\n\r\n  struct Step {\r\n      uint priceTokenWei;\r\n      uint minInvestEth;\r\n      uint timestamp;\r\n      uint tokensSold;\r\n      uint collectedWei;\r\n\r\n  }\r\n  AKC public token;\r\n  address public beneficiary;\r\n\r\n  Step[] public steps;\r\n  uint8 public currentStep = 0;\r\n  uint public totalTokensSold = 0;\r\n  uint public totalCollectedWei = 0;\r\n  bool public crowdsaleClosed = false;\r\n  uint public totalTokensForSale = 0;\r\n\r\n  event Purchase(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\r\n  event NextStep(uint8 step);\r\n  event CrowdsaleClose();\r\n\r\n  /**\r\n  * @dev Initialize the crowdsale conditions.\r\n  * @param akctoken AKC token contract address.\r\n  */\r\n  function AKCCrowdsale(AKC akctoken, uint phase1, uint phase2, uint phase3, uint phase4, address multiSigWallet) public {\r\n      require(token==address(0));\r\n      /* token = new AKC(); */\r\n      token = akctoken;\r\n      beneficiary = multiSigWallet;\r\n      // crowdsale only sale 4.5% of totalSupply\r\n      totalTokensForSale = 9000000 ether;\r\n      uint oneEther = 1 ether;\r\n      /**\r\n      * Crowdsale is conducted in three phases. Token exchange rate is 1Ether:3000AKC\r\n      * The crowdsale starts on July 20, 2018.\r\n      * 2018/07/20 - 2018/07/29   15% off on AKC token exchange rate.\r\n      * 2018/07/30 - 2018/08/08   10% off on AKC token exchange rate.\r\n      * 2018/08/09 - 2018/08/18   5% off on AKC token exchange rate.\r\n      * 2018/08/19 - 2018/08/30   Original exchange rate.\r\n      */\r\n      steps.push(Step(oneEther.div(3450), 1 ether, phase1, 0, 0));\r\n      steps.push(Step(oneEther.div(3300), 1 ether, phase2, 0, 0));\r\n      steps.push(Step(oneEther.div(3150), 1 ether, phase3, 0, 0));\r\n      steps.push(Step(oneEther.div(3000), 1 ether, phase4, 0, 0));\r\n  }\r\n\r\n  /**\r\n  * @dev Fallback function that will delegate the request to purchase().\r\n  */\r\n  function() external payable  {\r\n      purchase(msg.sender);\r\n  }\r\n\r\n  /**\r\n  * @dev purchase AKC\r\n  * @param sender The address to receive AKC.\r\n  */\r\n  function purchase(address sender) whenNotPaused payable public {\r\n      require(!crowdsaleClosed);\r\n      require(now>steps[0].timestamp);\r\n      /* Update the step based on the current time. */\r\n      if (now > steps[1].timestamp && currentStep < 1){\r\n        currentStep = 1;\r\n        emit NextStep(currentStep);\r\n      }\r\n      if (now > steps[2].timestamp && currentStep < 2){\r\n        currentStep = 2;\r\n        emit NextStep(currentStep);\r\n      }\r\n      if (now > steps[3].timestamp && currentStep < 3){\r\n        currentStep = 3;\r\n        emit NextStep(currentStep);\r\n      }\r\n      /* Step memory step = steps[currentStep]; */\r\n\r\n      require(msg.value >= steps[currentStep].minInvestEth);\r\n      require(totalTokensSold < totalTokensForSale);\r\n\r\n      uint sum = msg.value;\r\n      uint amount = sum.div(steps[currentStep].priceTokenWei).mul(1 ether);\r\n      uint retSum = 0;\r\n\r\n      /* Calculate excess Ether */\r\n      if(totalTokensSold.add(amount) > totalTokensForSale) {\r\n          uint retAmount = totalTokensSold.add(amount).sub(totalTokensForSale);\r\n          retSum = retAmount.mul(steps[currentStep].priceTokenWei).div(1 ether);\r\n          amount = amount.sub(retAmount);\r\n          sum = sum.sub(retSum);\r\n      }\r\n\r\n      /* Record purchase info */\r\n      totalTokensSold = totalTokensSold.add(amount);\r\n      totalCollectedWei = totalCollectedWei.add(sum);\r\n      steps[currentStep].tokensSold = steps[currentStep].tokensSold.add(amount);\r\n      steps[currentStep].collectedWei = steps[currentStep].collectedWei.add(sum);\r\n\r\n      /* Mint and Send AKC */\r\n      /* token.mint(sender, amount); */\r\n      token.transfer(sender, amount);\r\n\r\n      /* Return the excess Ether */\r\n      if(retSum > 0) {\r\n          sender.transfer(retSum);\r\n      }\r\n\r\n      beneficiary.transfer(address(this).balance);\r\n      emit Purchase(sender, amount, sum);\r\n  }\r\n\r\n  /**\r\n  * @dev close crowdsale.\r\n  */\r\n  function closeCrowdsale() onlyOwner public {\r\n      require(!crowdsaleClosed);\r\n      /* Transfer the Ether from the contract to the beneficiary's address.*/\r\n      beneficiary.transfer(address(this).balance);\r\n      /* Transfer the AKC from the contract to the beneficiary's address.*/\r\n      token.transfer(beneficiary, token.balanceOf(address(this)));\r\n      crowdsaleClosed = true;\r\n      emit CrowdsaleClose();\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"steps\",\"outputs\":[{\"name\":\"priceTokenWei\",\"type\":\"uint256\"},{\"name\":\"minInvestEth\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"name\":\"collectedWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollectedWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"akctoken\",\"type\":\"address\"},{\"name\":\"phase1\",\"type\":\"uint256\"},{\"name\":\"phase2\",\"type\":\"uint256\"},{\"name\":\"phase3\",\"type\":\"uint256\"},{\"name\":\"phase4\",\"type\":\"uint256\"},{\"name\":\"multiSigWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"step\",\"type\":\"uint8\"}],\"name\":\"NextStep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CrowdsaleClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AKCCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001ca43a170bad619322e6f54d46b57e504db663aa000000000000000000000000000000000000000000000000000000005b512600000000000000000000000000000000000000000000000000000000005b5e5500000000000000000000000000000000000000000000000000000000005b6b8400000000000000000000000000000000000000000000000000000000005b78b3000000000000000000000000007a8e60416dac9b84e59cae2184ee32b507f3095f","Library":"","SwarmSource":"bzzr://6d480ff429ad4c88f726ddc37eda407d01998756bd0a927689486c59c3f72041"}]}