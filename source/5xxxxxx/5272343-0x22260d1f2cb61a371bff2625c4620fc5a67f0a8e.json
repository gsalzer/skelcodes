{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n/**\r\n * split income between shareholders\r\n */\r\ncontract Share {\r\n  address public owner;\r\n  address[] public shares;\r\n  bool public pause;\r\n  mapping (address => uint256) public holds;\r\n\r\n  function Share() public {\r\n    owner = msg.sender;\r\n    shares.push(owner);\r\n    pause = false;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPaused() {\r\n    require(!pause);\r\n    _;\r\n  }\r\n\r\n  function pause() public onlyOwner {\r\n    pause = true;\r\n  }\r\n\r\n  function unpause() public onlyOwner {\r\n    pause = false;\r\n  }\r\n\r\n  function addShare(address _share) public onlyOwner {\r\n    for (uint i = 0; i < shares.length; i ++) {\r\n      if (shares[i] == _share) {\r\n        return;\r\n      }\r\n    }\r\n    shares.push(_share);\r\n  }\r\n\r\n  function removeShare(address _share) public onlyOwner {\r\n    uint i = 0;\r\n    for (; i < shares.length; i ++) {\r\n      if (shares[i] == _share) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (i > shares.length - 1) {\r\n      //not found\r\n      return;\r\n    } else {\r\n      shares[i] = shares[shares.length - 1];\r\n      shares.length = shares.length - 1;\r\n      return;\r\n    }\r\n  }\r\n\r\n  function split(uint256 value) internal {\r\n    uint256 each = value / shares.length;\r\n\r\n    for (uint i = 0; i < shares.length; i ++) {\r\n      holds[shares[i]] += each;\r\n    }\r\n\r\n    holds[owner] += value - each * shares.length;\r\n    return;\r\n  }\r\n\r\n  function withdrawal() public whenNotPaused {\r\n    if (holds[msg.sender] > 0) {\r\n      uint256 v = holds[msg.sender];\r\n      holds[msg.sender] = 0;\r\n      msg.sender.transfer(v);\r\n    }\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint);\r\n  function transfer(address to, uint value) public;\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint);\r\n  function transferFrom(address from, address to, uint value) public;\r\n  function approve(address spender, uint value) public;\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract AirDrop is Share {\r\n  // owner => (token addr => token amount)  \r\n  mapping(address => mapping(address => uint256)) toDrop;\r\n\r\n  uint256 public fee;\r\n\r\n  function AirDrop (uint256 _fee) public {\r\n      fee = _fee;\r\n  }\r\n   \r\n  function setFee(uint256 _fee) public onlyOwner {\r\n    fee = _fee;\r\n  }\r\n\r\n  function drop(address _token, address[] dsts, uint256 value) public payable whenNotPaused {\r\n    require(dsts.length > 0);\r\n    uint256 total = dsts.length * value;\r\n    assert(total / dsts.length == value);\r\n    require(msg.value >= fee);\r\n    \r\n    split(fee);\r\n    \r\n    uint256 i = 0;\r\n    if (_token == address(0)) {\r\n      //send ETH\r\n      require((fee + total) >= total);\r\n      require(msg.value >= (fee + total));\r\n      \r\n      while (i < dsts.length) {\r\n        dsts[i].transfer(value);        \r\n        i += 1;\r\n      }\r\n\r\n    } else {\r\n      ERC20 erc20 = ERC20(_token);\r\n      require(erc20.allowance(msg.sender, this) >= total);\r\n\r\n      while (i < dsts.length) {\r\n        erc20.transferFrom(msg.sender, dsts[i], value);\r\n        i += 1;\r\n      }\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"dsts\",\"type\":\"address[]\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shares\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_share\",\"type\":\"address\"}],\"name\":\"addShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"holds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_share\",\"type\":\"address\"}],\"name\":\"removeShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"AirDrop","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://43015ed0c13e59e804308b27e3796f39915fcf6b83a3c1d5ac9ca03e914ae1b9"}]}