{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.20;\r\n\r\ncontract PapereumTokenBridge {\r\n    function makeNonFungible(uint256 amount, address owner) public;\r\n    function token() public returns (PapereumToken);\r\n}\r\n\r\n\r\ncontract PapereumToken {\r\n\r\n    string public name = \"Papereum\";\r\n    string public symbol = \"PPRM\";\r\n    uint8 public decimals = 0; // Papereum tokens are not divisible\r\n    uint256 public totalSupply = 100000; // Only 100 000 Non-divisable pieces of Art\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    bool public isTradable = false;\r\n\r\n    address public owner = address(0);\r\n    PapereumTokenBridge public bridge;\r\n\r\n    function PapereumToken() public {\r\n        owner = msg.sender;\r\n        balanceOf[owner] = totalSupply;\r\n        Transfer(address(0), owner, totalSupply);\r\n    }\r\n\r\n    function setBridge(address _bridge) public {\r\n        require(msg.sender == owner);\r\n        require(isTradable);\r\n        require(_bridge != address(0));\r\n        require(bridge == address(0));\r\n        bridge = PapereumTokenBridge(_bridge);\r\n        require(bridge.token() == this);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(isTradable || msg.sender == owner);\r\n        require(_to != address(0));\r\n        require(balanceOf[msg.sender] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        if (_to == address(bridge)) {\r\n            bridge.makeNonFungible(_value, msg.sender);\r\n        }\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(isTradable);\r\n        require(_to != address(0));\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        require(allowance[_from][msg.sender] >= _value);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        if (_to == address(bridge)) {\r\n            bridge.makeNonFungible(_value, msg.sender); // Caller takes ownership of trackable tokens\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        require(allowance[msg.sender][_spender] + _addedValue >= allowance[msg.sender][_spender]);\r\n        allowance[msg.sender][_spender] = allowance[msg.sender][_spender] + _addedValue;\r\n        Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowance[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowance[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowance[msg.sender][_spender] = oldValue - _subtractedValue;\r\n        }\r\n        Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function burn(address newOwner) public returns (bool success) {\r\n        require(msg.sender == owner);\r\n        require(!isTradable);\r\n        require(newOwner != address(0));\r\n        uint256 value = balanceOf[owner];\r\n        balanceOf[owner] = 0;\r\n        totalSupply -= value;\r\n        isTradable = true;\r\n        Transfer(owner, address(0), value);\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public {\r\n        require(msg.sender == owner);\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract PapereumCrowdsale {\r\n    // Wallet where all ether will be\r\n    address public constant WALLET = 0xE77E35a07794761277870521C80d1cA257383292;\r\n    // Wallet for team tokens\r\n    address public constant TEAM_WALLET = 0x5C31f06b4AAC5D5c84Fd7735971B951d7E5104A0;\r\n    // Wallet for media support tokens\r\n    address public constant MEDIA_SUPPORT_WALLET = 0x8E6618e41879d8BE1F7a0E658294E8A1359e4383;\r\n\r\n    uint256 public constant ICO_TOKENS = 93000;\r\n    uint8 public constant ICO_TOKENS_PERCENT = 93;\r\n    uint8 public constant TEAM_TOKENS_PERCENT = 2;\r\n    uint8 public constant MEDIA_SUPPORT_PERCENT = 5;\r\n    uint256 public constant START_TIME = 1518998400; // 2018/02/19 00:00 UTC +0\r\n    uint256 public constant END_TIME = 1525046400; // 2018/04/30 00:00 UTC +0\r\n    uint256 public constant RATE = 1e16; // 100 tokens costs 1 ether\r\n\r\n    // The token being sold\r\n    PapereumToken public token;\r\n    // amount of raised money in wei\r\n    uint256 public weiRaised;\r\n    bool public isFinalized = false;\r\n    address private tokenMinter;\r\n    address public owner;\r\n    uint256 private icoBalance = ICO_TOKENS;\r\n\r\n    event Progress(uint256 tokensSold, uint256 weiRaised);\r\n\r\n    event Finalized();\r\n    /**\r\n    * When there no tokens left to mint and token minter tries to manually mint tokens\r\n    * this event is raised to signal how many tokens we have to charge back to purchaser\r\n    */\r\n    event ManualTokenMintRequiresRefund(address indexed purchaser, uint256 value);\r\n\r\n    function PapereumCrowdsale() public {\r\n        token = new PapereumToken();\r\n        owner = msg.sender;\r\n        tokenMinter = msg.sender;\r\n    }\r\n\r\n    // fallback function can be used to buy tokens or claim refund\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function assignTokens(address[] _receivers, uint256[] _amounts) external {\r\n        require(msg.sender == tokenMinter || msg.sender == owner);\r\n        require(_receivers.length > 0 && _receivers.length <= 100);\r\n        require(_receivers.length == _amounts.length);\r\n        require(!isFinalized);\r\n        for (uint256 i = 0; i < _receivers.length; i++) {\r\n            address receiver = _receivers[i];\r\n            uint256 amount = _amounts[i];\r\n\r\n            require(receiver != address(0));\r\n            require(amount > 0);\r\n\r\n            uint256 excess = appendContribution(receiver, amount);\r\n\r\n            if (excess > 0) {\r\n                ManualTokenMintRequiresRefund(receiver, excess);\r\n            }\r\n        }\r\n        Progress(ICO_TOKENS - icoBalance, weiRaised);\r\n    }\r\n\r\n    function buyTokens(address beneficiary) private {\r\n        require(beneficiary != address(0));\r\n        require(validPurchase());\r\n\r\n        uint256 weiReceived = msg.value;\r\n\r\n        uint256 tokens;\r\n        uint256 refund;\r\n        (tokens, refund) = calculateTokens(weiReceived);\r\n\r\n        uint256 excess = appendContribution(beneficiary, tokens);\r\n        refund += (excess > 0 ? ((excess * weiReceived) / tokens) : 0);\r\n\r\n        tokens -= excess;\r\n        weiReceived -= refund;\r\n        weiRaised += weiReceived;\r\n\r\n        if (refund > 0) {\r\n            msg.sender.transfer(refund);\r\n        }\r\n\r\n        WALLET.transfer(weiReceived);\r\n        Progress(ICO_TOKENS - icoBalance, weiRaised);\r\n    }\r\n\r\n    /**\r\n    * @dev Must be called after crowdsale ends, to do some extra finalization\r\n    * work. Calls the contract's finalization function.\r\n    */\r\n    function finalize() public {\r\n        require(msg.sender == owner);\r\n        require(!isFinalized);\r\n        require(getNow() > END_TIME || icoBalance == 0);\r\n        isFinalized = true;\r\n\r\n        uint256 totalSoldTokens = ICO_TOKENS - icoBalance;\r\n\r\n        uint256 teamTokens = (TEAM_TOKENS_PERCENT * totalSoldTokens) / ICO_TOKENS_PERCENT;\r\n        token.transfer(TEAM_WALLET, teamTokens);\r\n        uint256 mediaTokens = (MEDIA_SUPPORT_PERCENT * totalSoldTokens) / ICO_TOKENS_PERCENT;\r\n        token.transfer(MEDIA_SUPPORT_WALLET, mediaTokens);\r\n\r\n        token.burn(owner);\r\n\r\n        Finalized();\r\n    }\r\n\r\n    function setTokenMinter(address _tokenMinter) public {\r\n        require(msg.sender == owner);\r\n        require(_tokenMinter != address(0));\r\n        tokenMinter = _tokenMinter;\r\n    }\r\n\r\n    function getNow() internal view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    function calculateTokens(uint256 _weiAmount) internal view returns (uint256 tokens, uint256 refundWei) {\r\n        tokens = _weiAmount / RATE;\r\n        refundWei = _weiAmount - (tokens * RATE);\r\n        uint256 now_ = getNow();\r\n        uint256 bonus = 0;\r\n\r\n        if (now_ < 1519603200) { // 26-02-2018\r\n            if (tokens >= 2000) bonus = 30;\r\n            else if (tokens >= 500) bonus = 25;\r\n            else if (tokens >= 50) bonus = 20;\r\n            else if (tokens >= 10) bonus = 10;\r\n        } else if (now_ < 1521417600) { // 19-03-2018\r\n            if (tokens >= 10) bonus = 7;\r\n        } else if (now_ < 1522627200) { // 02-04-2018\r\n            if (tokens >= 10) bonus = 5;\r\n        } else if (now_ < 1523232000) { // 09-04-2018\r\n            if (tokens >= 10) bonus = 3;\r\n        }\r\n\r\n        tokens += (tokens * bonus) / 100; // with totalSupply <= 100000 and decimals=0 no need in SafeMath\r\n    }\r\n\r\n    function appendContribution(address _beneficiary, uint256 _tokens) internal returns (uint256 excess) {\r\n        excess = 0;\r\n        require(_tokens >= 10);\r\n        if (_tokens > icoBalance) {\r\n            excess = icoBalance - _tokens;\r\n            _tokens = icoBalance;\r\n        }\r\n        if (_tokens > 0) {\r\n            icoBalance -= _tokens;\r\n            token.transfer(_beneficiary, _tokens);\r\n        }\r\n    }\r\n\r\n    // @return true if the transaction can buy tokens\r\n    function validPurchase() internal view returns (bool) {\r\n        bool withinPeriod = getNow() >= START_TIME && getNow() <= END_TIME;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        bool canTransfer = icoBalance > 0;\r\n        return withinPeriod && nonZeroPurchase && canTransfer;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public {\r\n        require(msg.sender == owner);\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MEDIA_SUPPORT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"assignTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MEDIA_SUPPORT_WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WALLET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenMinter\",\"type\":\"address\"}],\"name\":\"setTokenMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_TOKENS_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM_TOKENS_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiRaised\",\"type\":\"uint256\"}],\"name\":\"Progress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ManualTokenMintRequiresRefund\",\"type\":\"event\"}]","ContractName":"PapereumCrowdsale","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://28912e20ad1f3500ad2c9c38bb88fe449d6b59fe075e4968552433c9bf6e9314"}]}