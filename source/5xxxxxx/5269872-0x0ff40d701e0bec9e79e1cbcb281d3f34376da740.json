{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n//\r\n/* CONTRACT */\r\n\r\ncontract SafeMath {\r\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n// END_OF_contract_SafeMath\r\n//_________________________________________________________\r\n//\r\n/* INTERFACES */\r\n//\r\ninterface tokenRecipient {\r\n\t\r\n\tfunction receiveApproval(address _from, uint256 _tokenAmountApproved, address tokenMacroansy, bytes _extraData) public returns(bool success); \r\n}   \r\n//________________________________________________________\r\n//\r\n    interface ICO {\r\n\r\n        function buy( uint payment, address buyer, bool isPreview) public returns(bool success, uint amount);\r\n        function redeemCoin(uint256 amount, address redeemer, bool isPreview) public returns (bool success, uint redeemPayment);\r\n        function sell(uint256 amount, address seller, bool isPreview) public returns (bool success, uint sellPayment );\r\n        function paymentAction(uint paymentValue, address beneficiary, uint paytype) public returns(bool success);\r\n\r\n        function recvShrICO( address _spender, uint256 _value, uint ShrID)  public returns (bool success);\r\n        function burn( uint256 value, bool unburn, uint totalSupplyStart, uint balOfOwner)  public returns( bool success);\r\n\r\n        function getSCF() public returns(uint seriesCapFactorMulByTenPowerEighteen);\r\n        function getMinBal() public returns(uint minBalForAccnts_ );\r\n        function getAvlShares(bool show) public  returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding);\r\n    }\r\n//_______________________________________________________ \r\n//\r\n    interface Exchg{\r\n        \r\n        function sell_Exchg_Reg( uint amntTkns, uint tknPrice, address seller) public returns(bool success);\r\n        function buy_Exchg_booking( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment ) public returns(bool success);\r\n        function buy_Exchg_BkgChk( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment) public returns(bool success);\r\n        function updateSeller( address seller, uint tknsApr, address buyer, uint payment) public returns(bool success);  \r\n\r\n        function getExchgComisnMulByThousand() public returns(uint exchgCommissionMulByThousand_);  \r\n\r\n        function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_);\r\n    }\r\n//_________________________________________________________\r\n\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n\r\n/* CONTRACT */\r\n//\r\n    contract TokenERC20Interface {\r\n\r\n        function totalSupply() public constant returns (uint coinLifeTimeTotalSupply);\r\n        function balanceOf(address tokenOwner) public constant returns (uint coinBalance);\r\n        function allowance(address tokenOwner, address spender) public constant returns (uint coinsRemaining);\r\n        function transfer(address to, uint tokens) public returns (bool success);\r\n        function approve(address spender, uint tokens) public returns (bool success);\r\n        function transferFrom(address _from, address to, uint tokens) public returns (bool success);\r\n        event Transfer(address indexed _from, address indexed to, uint tokens);\r\n        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    }\r\n//END_OF_contract_ERC20Interface \r\n//_________________________________________________________________\r\n/* CONTRACT */\r\n/**\r\n* COPYRIGHT Macroansy \r\n* http://www.macroansy.org\r\n*/\r\ncontract TokenMacroansy is TokenERC20Interface, SafeMath { \r\n    \r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    //\r\n    address internal owner; \r\n    address private  beneficiaryFunds;\r\n    //\r\n    uint256 public totalSupply;\r\n    uint256 internal totalSupplyStart;\r\n    //\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    mapping( address => bool) internal frozenAccount;\r\n    //\r\n    mapping(address => uint) private msgSndr;\r\n    //\r\n    address tkn_addr; address ico_addr; address exchg_addr;\r\n    //\r\n    uint256 internal allowedIndividualShare;\r\n    uint256 internal allowedPublicShare;\r\n//\r\n    //uint256 internal allowedFounderShare;\r\n    //uint256 internal allowedPOOLShare;\r\n    //uint256 internal allowedVCShare;\r\n    //uint256 internal allowedColdReserve;\r\n//_________________________________________________________\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);    \r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Burn(address indexed from, uint amount);\r\n    event UnBurn(address indexed from, uint amount);\r\n    event FundOrPaymentTransfer(address beneficiary, uint amount); \r\n    event FrozenFunds(address target, bool frozen);\r\n    event BuyAtMacroansyExchg(address buyer, address seller, uint tokenAmount, uint payment);\r\n//_________________________________________________________\r\n//\r\n//CONSTRUCTOR\r\n    /* Initializes contract with initial supply tokens to the creator of the contract \r\n    */\r\n    function TokenMacroansy()  public {\r\n        \r\n        owner = msg.sender;\r\n        beneficiaryFunds = owner;\r\n        //totalSupplyStart = initialSupply * 10** uint256(decimals);  \r\n        totalSupplyStart = 3999 * 10** uint256(decimals);     \r\n        totalSupply = totalSupplyStart; \r\n        //\r\n        balanceOf[msg.sender] = totalSupplyStart;    \r\n        Transfer(address(0), msg.sender, totalSupplyStart);\r\n        //                 \r\n        name = \"TokenMacroansy\";  \r\n        symbol = \"$BEE\";\r\n        //  \r\n        allowedIndividualShare = uint(1)*totalSupplyStart/100; \r\n        allowedPublicShare = uint(20)* totalSupplyStart/100;     \r\n        //\r\n        //allowedFounderShare = uint(20)*totalSupplyStart/100; \r\n        //allowedPOOLShare = uint(9)* totalSupplyStart/100; \r\n        //allowedColdReserve = uint(41)* totalSupplyStart/100;\r\n        //allowedVCShare =  uint(10)* totalSupplyStart/100;  \r\n    } \r\n//_________________________________________________________\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    } \r\n    function wadmin_transferOr(address _Or) public onlyOwner {\r\n        owner = _Or;\r\n    }          \r\n//_________________________________________________________\r\n   /**\r\n     * @notice Show the `totalSupply` for this Token contract\r\n     */\r\n    function totalSupply() constant public returns (uint coinLifeTimeTotalSupply) {\r\n        return totalSupply ;   \r\n    }  \r\n//_________________________________________________________\r\n   /**\r\n     * @notice Show the `tokenOwner` balances for this contract\r\n     * @param tokenOwner the token owners address\r\n     */\r\n    function balanceOf(address tokenOwner) constant public  returns (uint coinBalance) {\r\n        return balanceOf[tokenOwner];\r\n    } \r\n//_________________________________________________________\r\n   /**\r\n     * @notice Show the allowance given by `tokenOwner` to the `spender`\r\n     * @param tokenOwner the token owner address allocating allowance\r\n     * @param spender the allowance spenders address\r\n     */\r\n    function allowance(address tokenOwner, address spender) constant public returns (uint coinsRemaining) {\r\n        return allowance[tokenOwner][spender];\r\n    }\r\n//_________________________________________________________\r\n//\r\n    function wadmin_setContrAddr(address icoAddr, address exchAddr ) public onlyOwner returns(bool success){\r\n       tkn_addr = this; ico_addr = icoAddr; exchg_addr = exchAddr;\r\n       return true;\r\n    }          \r\n    //\r\n    function _getTknAddr() internal  returns(address tkn_ma_addr){  return(tkn_addr); }\r\n    function _getIcoAddr() internal  returns(address ico_ma_addr){  return(ico_addr); } \r\n    function _getExchgAddr() internal returns(address exchg_ma_addr){ return(exchg_addr); } \r\n    // _getTknAddr(); _getIcoAddr(); _getExchgAddr();  \r\n    //  address tkn_addr; address ico_addr; address exchg_addr;\r\n//_________________________________________________________\r\n//\r\n    /* Internal transfer, only can be called by this contract */\r\n    //\r\n    function _transfer(address _from, address _to, uint _value) internal  {\r\n        require (_to != 0x0);                                       \r\n        require(!frozenAccount[_from]);                             \r\n        require(!frozenAccount[_to]);                               \r\n        uint valtmp = _value;\r\n        uint _valueA = valtmp;\r\n        valtmp = 0;                       \r\n        require (balanceOf[_from] >= _valueA);                       \r\n        require (balanceOf[_to] + _valueA > balanceOf[_to]);                   \r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];                               \r\n        balanceOf[_from] = safeSub(balanceOf[_from], _valueA);                                  \r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _valueA); \r\n        Transfer(_from, _to, _valueA);\r\n        _valueA = 0;\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);       \r\n    }\r\n//________________________________________________________\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * @notice Allows to Send Coins to other accounts\r\n     * @param _to The address of the recipient of coins\r\n     * @param _value The amount of coins to send\r\n     */\r\n     function transfer(address _to, uint256 _value) public returns(bool success) {\r\n\r\n        //check sender and receiver allw limits in accordance with ico contract\r\n        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);\r\n        bool sucsByrLmt = _chkBuyerLmts( _to, _value);\r\n        require(sucsSlrLmt == true && sucsByrLmt == true);\r\n        //\r\n        uint valtmp = _value;    \r\n        uint _valueTemp = valtmp; \r\n        valtmp = 0;                 \r\n        _transfer(msg.sender, _to, _valueTemp);\r\n        _valueTemp = 0;\r\n        return true;      \r\n    }  \r\n//_________________________________________________________\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * @notice sender can set an allowance for another contract, \r\n     * @notice and the other contract interface function receiveApproval \r\n     * @notice can call this funtion for token as payment and add further coding for service.\r\n     * @notice please also refer to function approveAndCall\r\n     * @notice Send `_value` tokens to `_to` on behalf of `_from`\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient of coins\r\n     * @param _value The amount coins to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        \r\n        uint valtmp = _value;\r\n        uint _valueA = valtmp;\r\n        valtmp = 0;\r\n        require(_valueA <= allowance[_from][msg.sender]);     \r\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _valueA);\r\n        _transfer(_from, _to, _valueA);\r\n        _valueA = 0;\r\n        return true;\r\n    }\r\n//_________________________________________________________\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * @notice Allows `_spender` to spend no more than `_value` coins from your account\r\n     * @param _spender The address authorized to spend\r\n     * @param _value The max amount of coins allocated to spender\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        \r\n        //check sender and receiver allw limits in accordance with ico contract\r\n        bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value);\r\n        bool sucsByrLmt = _chkBuyerLmts( _spender, _value);\r\n        require(sucsSlrLmt == true && sucsByrLmt == true);\r\n        //\r\n        uint valtmp = _value;\r\n        uint _valueA = valtmp;\r\n        valtmp = 0;         \r\n        allowance[msg.sender][_spender] = _valueA;\r\n        Approval(msg.sender, _spender, _valueA);\r\n         _valueA =0;\r\n        return true;\r\n    }\r\n//_________________________________________________________\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` coins in from your account\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount of coins the spender can spend\r\n     * @param _extraData some extra information to send to the spender contracts\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        \r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        uint valtmp = _value;\r\n        uint _valueA = valtmp;\r\n        valtmp = 0;         \r\n        if (approve(_spender, _valueA)) {           \r\n            spender.receiveApproval(msg.sender, _valueA, this, _extraData);            \r\n        }\r\n        _valueA = 0; \r\n        return true;\r\n    }\r\n//_________________________________________________________\r\n//\r\n    /**\r\n    * @notice `freeze` Prevent | Allow` `target` from sending & receiving tokens\r\n    * @param target Address to be frozen\r\n    * @param freeze either to freeze it or not\r\n    */\r\n    function wadmin_freezeAccount(address target, bool freeze) onlyOwner public returns(bool success) {\r\n        frozenAccount[target] = freeze;      \r\n        FrozenFunds(target, freeze);\r\n        return true;\r\n    }\r\n//________________________________________________________\r\n//\r\n    function _safeTransferTkn( address _from, address _to, uint amount) internal returns(bool sucsTrTk){\r\n          \r\n          uint tkA = amount;\r\n          uint tkAtemp = tkA;\r\n          tkA = 0;\r\n                   _transfer(_from, _to, tkAtemp); \r\n          tkAtemp = 0;\r\n          return true;\r\n    }      \r\n//_________________________________________________________\r\n//\r\n    function _safeTransferPaymnt( address paymentBenfcry, uint payment) internal returns(bool sucsTrPaymnt){\r\n              \r\n          uint pA = payment; \r\n          uint paymentTemp = pA;\r\n          pA = 0;\r\n                  paymentBenfcry.transfer(paymentTemp); \r\n          FundOrPaymentTransfer(paymentBenfcry, paymentTemp);                       \r\n          paymentTemp = 0; \r\n          \r\n          return true;\r\n    }\r\n//_________________________________________________________\r\n//\r\n    function _safePaymentActionAtIco( uint payment, address paymentBenfcry, uint paytype) internal returns(bool success){\r\n              \r\n    // payment req to ico\r\n          uint Pm = payment;\r\n          uint PmTemp = Pm;\r\n          Pm = 0;  \r\n          ICO ico = ICO(_getIcoAddr());       \r\n          // paytype 1 for redeempayment and 2 for sell payment\r\n          bool pymActSucs = ico.paymentAction( PmTemp, paymentBenfcry, paytype);\r\n          require(pymActSucs ==  true);\r\n          PmTemp = 0;\r\n          \r\n          return true;\r\n    }\r\n\r\n//_________________________________________________________\r\n    /* @notice Allows to Buy ICO tokens directly from this contract by sending ether\r\n    */\r\n    function buyCoinsAtICO() payable public returns(bool success) { \r\n\r\n        msgSndr[msg.sender] = msg.value;\r\n\r\n        ICO ico = ICO(_getIcoAddr() );\r\n\r\n        require(  msg.value > 0 );\r\n        \r\n        // buy exe at ico\r\n        bool icosuccess;  uint tknsBuyAppr;        \r\n        (icosuccess, tknsBuyAppr) = ico.buy( msg.value, msg.sender, false);        \r\n                require( icosuccess == true );\r\n        \r\n        // tkn transfer\r\n        bool sucsTrTk =  _safeTransferTkn( owner, msg.sender, tknsBuyAppr);\r\n        require(sucsTrTk == true);\r\n\r\n        msgSndr[msg.sender] = 0;\r\n\r\n        return (true) ;\r\n    }     \r\n//_____________________________________________________________\r\n//\r\n    /* @notice Allows anyone to preview a Buy of ICO tokens before an actual buy\r\n    */\r\n\r\n    function buyCoinsPreview(uint myProposedPaymentInWEI) public view returns(bool success, uint tokensYouCanBuy, uint yourSafeMinBalReqdInWEI) { \r\n        \r\n        uint payment = myProposedPaymentInWEI;\r\n       \r\n        msgSndr[msg.sender] = payment;  \r\n        success = false;\r\n        \r\n        ICO ico = ICO(_getIcoAddr() );\r\n\r\n        tokensYouCanBuy = 0;\r\n        bool icosuccess;            \r\n        (icosuccess, tokensYouCanBuy) = ico.buy( payment, msg.sender, true);        \r\n\r\n        msgSndr[msg.sender] = 0;\r\n\r\n        return ( icosuccess, tokensYouCanBuy, ico.getMinBal()) ;\r\n    }\r\n//_____________________________________________________________\r\n     /**\r\n     *  @notice Allows Token owners to Redeem Tokens to this Contract for its value promised\r\n     */\r\n    function redeemCoinsToICO( uint256 amountOfCoinsToRedeem) public returns (bool success ) {\r\n\r\n    uint amount = amountOfCoinsToRedeem;\r\n\r\n    msgSndr[msg.sender] = amount;  \r\n      bool isPreview = false;\r\n\r\n      ICO ico = ICO(_getIcoAddr());\r\n\r\n      // redeem exe at ico\r\n      bool icosuccess ; uint redeemPaymentValue;\r\n      (icosuccess , redeemPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview);\r\n      require( icosuccess == true);  \r\n\r\n      require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemPaymentValue) );\r\n\r\n      bool sucsTrTk = false; bool pymActSucs = false;\r\n      if(isPreview == false) {\r\n\r\n        // transfer tkns\r\n        sucsTrTk =  _safeTransferTkn( msg.sender, owner, amount);\r\n        require(sucsTrTk == true);        \r\n\r\n        // payment req to ico  1 for redeempayment and 2 for sell payment         \r\n      msgSndr[msg.sender] = redeemPaymentValue;\r\n        pymActSucs = _safePaymentActionAtIco( redeemPaymentValue, msg.sender, 1);\r\n        require(pymActSucs ==  true);\r\n      } \r\n\r\n    msgSndr[msg.sender] = 0;  \r\n\r\n      return (true);        \r\n    } \r\n//_________________________________________________________\r\n    /**\r\n     *  @notice Allows Token owners to Sell Tokens directly to this Contract\r\n     *\r\n     */    \r\n     function sellCoinsToICO( uint256 amountOfCoinsToSell ) public returns (bool success ) {\r\n\r\n      uint amount = amountOfCoinsToSell;\r\n\r\n      msgSndr[msg.sender] = amount;  \r\n        bool isPreview = false;\r\n\r\n        ICO ico = ICO(_getIcoAddr() );\r\n\r\n        // sell exe at ico\r\n        bool icosuccess; uint sellPaymentValue; \r\n        ( icosuccess ,  sellPaymentValue) = ico.sell( amount, msg.sender, isPreview);\r\n        require( icosuccess == true );\r\n\r\n        require( _getIcoAddr().balance >= safeAdd(ico.getMinBal() , sellPaymentValue) );\r\n\r\n        bool sucsTrTk = false; bool pymActSucs = false;\r\n        if(isPreview == false){\r\n\r\n          // token transfer\r\n          sucsTrTk =  _safeTransferTkn( msg.sender, owner,  amount);\r\n          require(sucsTrTk == true);\r\n\r\n          // payment request to ico  1 for redeempayment and 2 for sell payment\r\n        msgSndr[msg.sender] = sellPaymentValue;\r\n          pymActSucs = _safePaymentActionAtIco( sellPaymentValue, msg.sender, 2);\r\n          require(pymActSucs ==  true);\r\n        }\r\n\r\n      msgSndr[msg.sender] = 0;\r\n\r\n        return ( true);                \r\n    }\r\n//________________________________________________________\r\n    /**\r\n    * @notice a sellers allowed limits in holding ico tokens is checked\r\n    */\r\n    //\r\n    function _chkSellerLmts( address seller, uint amountOfCoinsSellerCanSell) internal returns(bool success){   \r\n\r\n      uint amountTkns = amountOfCoinsSellerCanSell; \r\n      success = false;\r\n      ICO ico = ICO( _getIcoAddr() );\r\n      uint seriesCapFactor = ico.getSCF();\r\n\r\n      if( amountTkns <= balanceOf[seller]  &&  balanceOf[seller] <=  safeDiv(allowedIndividualShare*seriesCapFactor,10**18) ){\r\n        success = true;\r\n      }\r\n      return success;\r\n    }\r\n    // bool sucsSlrLmt = _chkSellerLmts( address seller, uint amountTkns);\r\n//_________________________________________________________    \r\n//\r\n    /**\r\n    * @notice a buyers allowed limits in holding ico tokens is checked \r\n    */\r\n    function _chkBuyerLmts( address buyer, uint amountOfCoinsBuyerCanBuy)  internal  returns(bool success){\r\n\r\n    \tuint amountTkns = amountOfCoinsBuyerCanBuy;\r\n        success = false;\r\n        ICO ico = ICO( _getIcoAddr() );\r\n        uint seriesCapFactor = ico.getSCF();\r\n\r\n        if( amountTkns <= safeSub( safeDiv(allowedIndividualShare*seriesCapFactor,10**18), balanceOf[buyer] )) {\r\n          success = true;\r\n        } \r\n        return success;        \r\n    }\r\n//_________________________________________________________\r\n//\r\n    /**\r\n    * @notice a buyers allowed limits in holding ico tokens along with financial capacity to buy is checked\r\n    */\r\n    function _chkBuyerLmtsAndFinl( address buyer, uint amountTkns, uint priceOfr) internal returns(bool success){\r\n       \r\n       success = false;\r\n\r\n      // buyer limits\r\n       bool sucs1 = false; \r\n       sucs1 = _chkBuyerLmts( buyer, amountTkns);\r\n\r\n      // buyer funds\r\n       ICO ico = ICO( _getIcoAddr() );\r\n       bool sucs2 = false;\r\n       if( buyer.balance >=  safeAdd( safeMul(amountTkns , priceOfr) , ico.getMinBal() )  )  sucs2 = true;\r\n       if( sucs1 == true && sucs2 == true)  success = true;   \r\n\r\n       return success;\r\n    }\r\n//_________________________________________________________\r\n//\r\n     function _slrByrLmtChk( address seller, uint amountTkns, uint priceOfr, address buyer) internal returns(bool success){\r\n     \r\n      // seller limits check\r\n        bool successSlrl; \r\n        (successSlrl) = _chkSellerLmts( seller, amountTkns); \r\n\r\n      // buyer limits check\r\n        bool successByrlAFinl;\r\n        (successByrlAFinl) = _chkBuyerLmtsAndFinl( buyer, amountTkns, priceOfr);\r\n        \r\n        require( successSlrl == true && successByrlAFinl == true);\r\n\r\n        return true;\r\n    }\r\n//___________________________________________________________________\r\n    /**\r\n    * @notice allows a seller to formally register his sell offer at ExchangeMacroansy\r\n    */\r\n      function sellBkgAtExchg( uint amountOfCoinsOffer, uint priceOfOneCoinInWEI) public returns(bool success){\r\n\r\n        uint amntTkns = amountOfCoinsOffer ;\r\n        uint tknPrice = priceOfOneCoinInWEI;\r\n      \r\n        // seller limits\r\n        bool successSlrl;\r\n        (successSlrl) = _chkSellerLmts( msg.sender, amntTkns); \r\n        require(successSlrl == true);\r\n\r\n      msgSndr[msg.sender] = amntTkns;  \r\n\r\n      // bkg registration at exchange\r\n\r\n        Exchg em = Exchg(_getExchgAddr());\r\n\r\n        bool  emsuccess; \r\n        (emsuccess) = em.sell_Exchg_Reg( amntTkns, tknPrice, msg.sender );\r\n        require(emsuccess == true );\r\n            \r\n      msgSndr[msg.sender] = 0;\r\n\r\n        return true;         \r\n    }\r\n//_________________________________________________________ \r\n//    \r\n    /**\r\n    * @notice function for booking and locking for a buy with respect to a sale offer registered\r\n    * @notice after booking then proceed for payment using func buyCoinsAtExchg \r\n    * @notice payment booking value and actual payment value should be exact\r\n    */  \r\n      function buyBkgAtExchg( address seller, uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint myProposedPaymentInWEI) public returns(bool success){ \r\n        \r\n        uint amountTkns = sellersCoinAmountOffer;\r\n        uint priceOfr = sellersPriceOfOneCoinInWEI;\r\n        uint payment = myProposedPaymentInWEI;         \r\n    \r\n      msgSndr[msg.sender] = amountTkns;\r\n\r\n        // seller buyer limits check\r\n        bool sucsLmt = _slrByrLmtChk( seller, amountTkns, priceOfr, msg.sender);\r\n        require(sucsLmt == true);\r\n\r\n        // booking at exchange\r\n     \r\n        Exchg em = Exchg(_getExchgAddr()); \r\n\r\n        bool emBkgsuccess;\r\n        (emBkgsuccess)= em.buy_Exchg_booking( seller, amountTkns, priceOfr, msg.sender, payment);\r\n            require( emBkgsuccess == true );\r\n\r\n      msgSndr[msg.sender] = 0;  \r\n\r\n        return true;        \r\n    }\r\n//________________________________________________________\r\n\r\n    /**\r\n    * @notice for buyingCoins at ExchangeMacroansy \r\n    * @notice please first book the buy through function_buy_Exchg_booking\r\n    */\r\n   // function buyCoinsAtExchg( address seller, uint amountTkns, uint priceOfr) payable public returns(bool success) {\r\n\r\n    function buyCoinsAtExchg( address seller, uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI) payable public returns(bool success) {\r\n       \r\n        uint amountTkns = sellersCoinAmountOffer;\r\n        uint priceOfr = sellersPriceOfOneCoinInWEI;\t       \r\n        require( msg.value > 0 && msg.value <= safeMul(amountTkns, priceOfr ) );\r\n\r\n      msgSndr[msg.sender] = amountTkns;\r\n\r\n        // calc tokens that can be bought  \r\n  \r\n        uint tknsBuyAppr = safeDiv(msg.value , priceOfr);\r\n\r\n        // check buyer booking at exchange\r\n  \r\n        Exchg em = Exchg(_getExchgAddr()); \r\n        \r\n        bool sucsBkgChk = em.buy_Exchg_BkgChk(seller, amountTkns, priceOfr, msg.sender, msg.value); \r\n        require(sucsBkgChk == true);\r\n\r\n       // update seller reg and buyer booking at exchange\r\n\r\n      msgSndr[msg.sender] = tknsBuyAppr;  \r\n \r\n        bool emUpdateSuccess;\r\n        (emUpdateSuccess) = em.updateSeller(seller, tknsBuyAppr, msg.sender, msg.value); \r\n        require( emUpdateSuccess == true );\r\n        \r\n       // token transfer in this token contract\r\n\r\n        bool sucsTrTkn = _safeTransferTkn( seller, msg.sender, tknsBuyAppr);\r\n        require(sucsTrTkn == true);\r\n\r\n        // payment to seller        \r\n        bool sucsTrPaymnt;\r\n        sucsTrPaymnt = _safeTransferPaymnt( seller,  safeSub( msg.value , safeDiv(msg.value*em.getExchgComisnMulByThousand(),1000) ) );\r\n        require(sucsTrPaymnt == true );\r\n       //  \r\n        BuyAtMacroansyExchg(msg.sender, seller, tknsBuyAppr, msg.value); //event\r\n\r\n      msgSndr[msg.sender] = 0; \r\n        \r\n        return true;\r\n    } \r\n//___________________________________________________________\r\n\r\n   /**\r\n     * @notice Fall Back Function, not to receive ether directly and/or accidentally\r\n     *\r\n     */\r\n    function () public payable {\r\n        if(msg.sender != owner) revert();\r\n    }\r\n//_________________________________________________________\r\n\r\n    /*\r\n    * @notice Burning tokens ie removing tokens from the formal total supply\r\n    */\r\n    function wadmin_burn( uint256 value, bool unburn) onlyOwner public returns( bool success ) { \r\n\r\n        msgSndr[msg.sender] = value;\r\n         ICO ico = ICO( _getIcoAddr() );\r\n            if( unburn == false) {\r\n\r\n                balanceOf[owner] = safeSub( balanceOf[owner] , value);\r\n                totalSupply = safeSub( totalSupply, value);\r\n                Burn(owner, value);\r\n\r\n            }\r\n            if( unburn == true) {\r\n\r\n                balanceOf[owner] = safeAdd( balanceOf[owner] , value);\r\n                totalSupply = safeAdd( totalSupply , value);\r\n                UnBurn(owner, value);\r\n\r\n            }\r\n        \r\n        bool icosuccess = ico.burn( value, unburn, totalSupplyStart, balanceOf[owner] );\r\n        require( icosuccess == true);             \r\n        \r\n        return true;                     \r\n    }\r\n//_________________________________________________________\r\n    /*\r\n    * @notice Withdraw Payments to beneficiary \r\n    * @param withdrawAmount the amount withdrawn in wei\r\n    */\r\n    function wadmin_withdrawFund(uint withdrawAmount) onlyOwner public returns(bool success) {\r\n      \r\n        success = _withdraw(withdrawAmount);          \r\n        return success;      \r\n    }   \r\n//_________________________________________________________\r\n     /*internal function can called by this contract only\r\n     */\r\n    function _withdraw(uint _withdrawAmount) internal returns(bool success) {\r\n\r\n        bool sucsTrPaymnt = _safeTransferPaymnt( beneficiaryFunds, _withdrawAmount); \r\n        require(sucsTrPaymnt == true);         \r\n        return true;     \r\n    }\r\n//_________________________________________________________\r\n    /**\r\n     *  @notice Allows to receive coins from Contract Share approved by contract\r\n     *  @notice to receive the share, it has to be already approved by the contract\r\n     *  @notice the share Id will be provided by contract while payments are made through other channels like paypal\r\n     *  @param amountOfCoinsToReceive the allocated allowance of coins to be transferred to you   \r\n     *  @param  ShrID  1 is FounderShare, 2 is POOLShare, 3 is ColdReserveShare, 4 is VCShare, 5 is PublicShare, 6 is RdmSellPool\r\n     */ \r\n    function receiveICOcoins( uint256 amountOfCoinsToReceive, uint ShrID )  public returns (bool success){ \r\n\r\n      msgSndr[msg.sender] = amountOfCoinsToReceive;\r\n        ICO ico = ICO( _getIcoAddr() );\r\n        bool  icosuccess;  \r\n        icosuccess = ico.recvShrICO(msg.sender, amountOfCoinsToReceive, ShrID ); \r\n        require (icosuccess == true);\r\n\r\n        bool sucsTrTk;\r\n        sucsTrTk =  _safeTransferTkn( owner, msg.sender, amountOfCoinsToReceive);\r\n        require(sucsTrTk == true);\r\n\r\n      msgSndr[msg.sender] = 0;\r\n\r\n        return  true;\r\n    }\r\n//_______________________________________________________\r\n//  called by other contracts\r\n    function sendMsgSndr(address caller, address origin) public returns(bool success, uint value){\r\n        \r\n        (success, value) = _sendMsgSndr(caller, origin);        \r\n         return(success, value);  \r\n    }\r\n//_______________________________________________________\r\n//\r\n    function _sendMsgSndr(address caller,  address origin) internal returns(bool success, uint value){ \r\n       \r\n        require(caller == _getIcoAddr() || caller == _getExchgAddr()); \r\n          //require(origin == tx.origin);          \r\n        return(true, msgSndr[origin]);  \r\n    }\r\n//_______________________________________________________\r\n//\r\n    function a_viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_){\r\n\r\n      if(show == true){\r\n\r\n          Exchg em = Exchg(_getExchgAddr()); \r\n         \r\n        ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, exchgCommissionMulByThousand_) = em.viewSellOffersAtExchangeMacroansy( seller, show) ; \r\n\r\n        return ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, exchgCommissionMulByThousand_);\r\n      }\r\n    }\r\n//_________________________________________________________\r\n//\r\n\tfunction a_viewCoinSupplyAndFunding(bool show) public view returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding){\r\n\r\n\t    if(show == true){\r\n\t      ICO ico = ICO( _getIcoAddr() );\r\n\r\n\t      ( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding) = ico.getAvlShares(show);\r\n\r\n\t      return( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding);\r\n\t    }\r\n\t}\r\n//_______________________________________________________\r\n//\r\n\t\t\t/*\r\n\t\t\tbool private isEndOk;\r\n\t\t\t\tfunction endOfRewards(bool isEndNow) public onlyOwner {\r\n\r\n\t\t\t\t\t\tisEndOk == isEndNow;\r\n\t\t\t\t}\r\n\t\t\t\tfunction endOfRewardsConfirmed(bool isEndNow) public onlyOwner{\r\n\r\n\t\t\t\t\tif(isEndOk == true && isEndNow == true) selfdestruct(owner);\r\n\t\t\t\t}\r\n\t\t\t*/\r\n//_______________________________________________________\r\n}\r\n// END_OF_CONTRACT","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"sellersCoinAmountOffer\",\"type\":\"uint256\"},{\"name\":\"sellersPriceOfOneCoinInWEI\",\"type\":\"uint256\"},{\"name\":\"myProposedPaymentInWEI\",\"type\":\"uint256\"}],\"name\":\"buyBkgAtExchg\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"sellersCoinAmountOffer\",\"type\":\"uint256\"},{\"name\":\"sellersPriceOfOneCoinInWEI\",\"type\":\"uint256\"}],\"name\":\"buyCoinsAtExchg\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"wadmin_freezeAccount\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfCoinsToReceive\",\"type\":\"uint256\"},{\"name\":\"ShrID\",\"type\":\"uint256\"}],\"name\":\"receiveICOcoins\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"coinLifeTimeTotalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"caller\",\"type\":\"address\"},{\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"sendMsgSndr\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfCoinsOffer\",\"type\":\"uint256\"},{\"name\":\"priceOfOneCoinInWEI\",\"type\":\"uint256\"}],\"name\":\"sellBkgAtExchg\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_Or\",\"type\":\"address\"}],\"name\":\"wadmin_transferOr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"myProposedPaymentInWEI\",\"type\":\"uint256\"}],\"name\":\"buyCoinsPreview\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"tokensYouCanBuy\",\"type\":\"uint256\"},{\"name\":\"yourSafeMinBalReqdInWEI\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"coinBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"show\",\"type\":\"bool\"}],\"name\":\"a_viewSellOffersAtExchangeMacroansy\",\"outputs\":[{\"name\":\"sellersCoinAmountOffer\",\"type\":\"uint256\"},{\"name\":\"sellersPriceOfOneCoinInWEI\",\"type\":\"uint256\"},{\"name\":\"sellerBookedTime\",\"type\":\"uint256\"},{\"name\":\"buyerWhoBooked\",\"type\":\"address\"},{\"name\":\"buyPaymentBooked\",\"type\":\"uint256\"},{\"name\":\"buyerBookedTime\",\"type\":\"uint256\"},{\"name\":\"exchgCommissionMulByThousand_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"icoAddr\",\"type\":\"address\"},{\"name\":\"exchAddr\",\"type\":\"address\"}],\"name\":\"wadmin_setContrAddr\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"unburn\",\"type\":\"bool\"}],\"name\":\"wadmin_burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"show\",\"type\":\"bool\"}],\"name\":\"a_viewCoinSupplyAndFunding\",\"outputs\":[{\"name\":\"totalSupplyOfCoinsInSeriesNow\",\"type\":\"uint256\"},{\"name\":\"coinsAvailableForSale\",\"type\":\"uint256\"},{\"name\":\"icoFunding\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"coinsRemaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfCoinsToRedeem\",\"type\":\"uint256\"}],\"name\":\"redeemCoinsToICO\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyCoinsAtICO\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"wadmin_withdrawFund\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfCoinsToSell\",\"type\":\"uint256\"}],\"name\":\"sellCoinsToICO\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundOrPaymentTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"BuyAtMacroansyExchg\",\"type\":\"event\"}]","ContractName":"TokenMacroansy","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://125df393ab313f6732df733c605bf16f2c7ceeae5bc5332c6dddaa67b6743743"}]}