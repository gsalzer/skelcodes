{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic \r\n{\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath \r\n{\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c  / a == b);\r\n        return c;\r\n    }\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return a  / b;\r\n    }\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\npragma solidity ^0.4.23;\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic \r\n{\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ncontract Owner\r\n{\r\n    address internal owner;\r\n    mapping(address => bool) internal admins;\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    modifier onlyAdmin {\r\n        require(admins[msg.sender] == true || msg.sender == owner);\r\n        _;\r\n    }\r\n    function changeOwner(address newOwner) public onlyOwner returns(bool)\r\n    {\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n    function setAdmin(address addr) public onlyOwner returns(bool) \r\n    {\r\n        admins[addr] = true;\r\n        return true;\r\n    }\r\n    function delAdmin(address addr) public onlyOwner returns(bool) \r\n    {\r\n        admins[addr] = false;\r\n        return true;\r\n    }\r\n}\r\npragma solidity ^0.4.23;\r\ncontract MayaPlus is Owner \r\n{\r\n    mapping(address => uint256) internal balances;\r\n    function parse2wei(uint _value) internal pure returns(uint)\r\n    {\r\n        uint decimals = 18;\r\n        return _value * (10 ** uint256(decimals));\r\n    }\r\n    address public ADDR_MAYA_ORG;\r\n    address public ADDR_MAYA_MARKETING ;\r\n    address public ADDR_MAYA_TEAM;\r\n    address public ADDR_MAYA_ASSOCIATION;\r\n    struct IcoRule\r\n    {\r\n        uint startTime;\r\n        uint endTime;\r\n        uint rate;\r\n        uint shareRuleGroupId;\r\n        address[] addrList;\r\n        bool canceled;\r\n    }\r\n    IcoRule[] icoRuleList;\r\n    mapping (address => uint[] ) addr2icoRuleIdList;\r\n    event GetIcoRule(uint startTime, uint endTime, uint rate, uint shareRuleGroupId, bool canceled);\r\n    function icoRuleAdd(uint startTime, uint endTime, uint rate, uint shareRuleGroupId) public onlyOwner returns (bool) \r\n    {\r\n        address[] memory addr;\r\n        bool canceled = false;\r\n        IcoRule memory item = IcoRule(startTime, endTime, rate, shareRuleGroupId, addr, canceled);\r\n        icoRuleList.push(item);\r\n        return true;\r\n    }\r\n    function icoRuleUpdate(uint index, uint startTime, uint endTime, uint rate, uint shareRuleGroupId) public onlyOwner returns (bool) \r\n    {\r\n        require(icoRuleList.length > index);\r\n        if (startTime > 0) {\r\n            icoRuleList[index].startTime = startTime;\r\n        }\r\n        if (endTime > 0) {\r\n            icoRuleList[index].endTime = endTime;\r\n        }\r\n        if (rate > 0) {\r\n            icoRuleList[index].rate = rate;\r\n        }\r\n        icoRuleList[index].shareRuleGroupId = shareRuleGroupId;\r\n        return true;\r\n    }\r\n    function icoPushAddr(uint index, address addr) internal returns (bool) \r\n    {\r\n        icoRuleList[index].addrList.push(addr);\r\n        return true;\r\n    }\r\n    function icoRuleCancel(uint index) public onlyOwner returns (bool) \r\n    {\r\n        require(icoRuleList.length > index);\r\n        icoRuleList[index].canceled = true;\r\n        return true;\r\n    }\r\n    function getIcoRuleList() public returns (uint count) \r\n    {\r\n        count = icoRuleList.length;\r\n        for (uint i = 0; i < count ; i++)\r\n        {\r\n            emit GetIcoRule(icoRuleList[i].startTime, icoRuleList[i].endTime, icoRuleList[i].rate, icoRuleList[i].shareRuleGroupId, \r\n            icoRuleList[i].canceled);\r\n        }\r\n    }\r\n    function getIcoAddrCount(uint icoRuleId) public view onlyOwner returns (uint count) \r\n    {\r\n        count = icoRuleList[icoRuleId - 1].addrList.length;\r\n    }\r\n    function getIcoAddrListByIcoRuleId(uint icoRuleId, uint index) public view onlyOwner returns (address addr) \r\n    {\r\n        addr = icoRuleList[icoRuleId - 1].addrList[index];\r\n    }\r\n    function initIcoRule() internal returns(bool) \r\n    {\r\n        icoRuleAdd(1529424001, 1532275199, 2600, 0);\r\n        icoRuleAdd(1532275201, 1533484799, 2100, 0);\r\n        icoRuleAdd(1533484801, 1534694399, 1700, 0);\r\n        icoRuleAdd(1534694401, 1535903999, 1400, 0);\r\n        icoRuleAdd(1535904001, 1537113599, 1100, 0);\r\n    }\r\n    struct ShareRule {\r\n        uint startTime;\r\n        uint endTime;\r\n        uint rateDenominator;\r\n    }\r\n    event GetShareRule(address addr, uint startTime, uint endTime, uint rateDenominator);\r\n    mapping (uint => ShareRule[]) shareRuleGroup;\r\n    mapping (address => uint) addr2shareRuleGroupId;\r\n    mapping (address => uint ) sharedAmount;\r\n    mapping (address => uint ) icoAmount;\r\n    ShareRule[] srlist_Team;\r\n    function initShareRule4Publicity() internal returns( bool )\r\n    {\r\n        ShareRule memory sr;\r\n        sr = ShareRule(1548432001, 1579967999, 5);\r\n        srlist_Team.push( sr );\r\n        sr = ShareRule(1579968001, 1611590399, 5);\r\n        srlist_Team.push( sr );\r\n        sr = ShareRule(1611590401, 1643126399, 5);\r\n        srlist_Team.push( sr );\r\n        sr = ShareRule(1643126401, 1674662399, 5);\r\n        srlist_Team.push( sr );\r\n        sr = ShareRule(1674662401, 1706198399, 5);\r\n        srlist_Team.push( sr );\r\n        shareRuleGroup[2] = srlist_Team;\r\n        addr2shareRuleGroupId[ADDR_MAYA_TEAM] = 2;\r\n        return true;\r\n    }\r\n    function initPublicityAddr() internal \r\n    {\r\n        ADDR_MAYA_MARKETING = address(0xb92863581E6C3Ba7eDC78fFa45CdbBa59A4aD03C);\r\n        balances[ADDR_MAYA_MARKETING] = parse2wei(50000000);\r\n        ADDR_MAYA_ASSOCIATION = address(0xff849bf00Fd77C357A7B9A09E572a1510ff7C0dC);\r\n        balances[ADDR_MAYA_ASSOCIATION] = parse2wei(500000000);\r\n        ADDR_MAYA_TEAM = address(0xb391e1b2186DB3b8d2F3D0968F30AB456F1eCa57);\r\n        balances[ADDR_MAYA_TEAM] = parse2wei(100000000);\r\n        initShareRule4Publicity();\r\n    }\r\n    function updateShareRuleGroup(uint id, uint index, uint startTime, uint endTime, uint rateDenominator) public onlyOwner returns(bool)\r\n    {\r\n        if (startTime > 0) {\r\n            shareRuleGroup[id][index].startTime = startTime;\r\n        }\r\n        if (endTime > 0) {\r\n            shareRuleGroup[id][index].endTime = endTime;\r\n        }\r\n        if (rateDenominator > 0) {\r\n            shareRuleGroup[id][index].rateDenominator = rateDenominator;\r\n        }\r\n        return true;\r\n    }\r\n    function tokenShareShow(address addr) public returns(uint shareRuleGroupId) \r\n    {\r\n        shareRuleGroupId = addr2shareRuleGroupId[addr];\r\n        if (shareRuleGroupId == 0) {\r\n            return 0;\r\n        }\r\n        ShareRule[] memory shareRuleList = shareRuleGroup[shareRuleGroupId];\r\n        uint count = shareRuleList.length;\r\n        for (uint i = 0; i < count ; i++)\r\n        {\r\n            emit GetShareRule(addr, shareRuleList[i].startTime, shareRuleList[i].endTime, shareRuleList[i].rateDenominator);\r\n        }\r\n        return shareRuleGroupId;\r\n    }\r\n    function setAccountShareRuleGroupId(address addr, uint shareRuleGroupId) public onlyOwner returns(bool)\r\n    {\r\n        addr2shareRuleGroupId[addr] = shareRuleGroupId;\r\n        return true;\r\n    }\r\n}\r\npragma solidity ^0.4.23;\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic, MayaPlus \r\n{\r\n    using SafeMath for uint256;\r\n    uint256 internal totalSupply_;\r\n    mapping (address => bool) internal locked;\r\n    mapping (address => bool) internal isAgent;\r\n    mapping (address => uint) internal agentRate;\r\n    function setAgentRate(address addr, uint rate) public onlyAdmin returns(bool)\r\n    {\r\n        require( addr != address(0) );\r\n        agentRate[addr] = rate;\r\n        return true;\r\n    }\r\n    /**\r\n    * alan: lock or unlock account\r\n    */\r\n    function lockAccount(address _addr) public onlyAdmin returns (bool)\r\n    {\r\n        require(_addr != address(0));\r\n        locked[_addr] = true;\r\n        return true;\r\n    }\r\n    function unlockAccount(address _addr) public onlyAdmin returns (bool)\r\n    {\r\n        require(_addr != address(0));\r\n        locked[_addr] = false;\r\n        return true;\r\n    }\r\n    /**\r\n    * alan: get lock status\r\n    */\r\n    function isLocked(address addr) public view returns(bool) \r\n    {\r\n        return locked[addr];\r\n    }\r\n    bool internal stopped = false;\r\n    modifier running {\r\n        assert (!stopped);\r\n        _;\r\n    }\r\n    function stop() public onlyOwner \r\n    {\r\n        stopped = true;\r\n    }\r\n    function start() public onlyOwner \r\n    {\r\n        stopped = false;\r\n    }\r\n    function isStopped() public view returns(bool)\r\n    {\r\n        return stopped;\r\n    }\r\n    /**\r\n    * @dev total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) \r\n    {\r\n        return totalSupply_;\r\n    }\r\n    function getRemainShareAmount() public view returns(uint)\r\n    {\r\n        return getRemainShareAmountInternal(msg.sender);\r\n    }\r\n    function getRemainShareAmountInternal(address addr) internal view returns(uint)\r\n    {\r\n        uint canTransferAmount = 0;\r\n        uint srgId = addr2shareRuleGroupId[addr];\r\n        bool allowTransfer = false;\r\n        if (srgId == 0) {\r\n            canTransferAmount = balances[addr];\r\n            return canTransferAmount;\r\n        }\r\n        else\r\n        {\r\n            ShareRule[] memory shareRuleList = shareRuleGroup[srgId];\r\n            uint count = shareRuleList.length;\r\n            for (uint i = 0; i < count ; i++)\r\n            {\r\n                if ( shareRuleList[i].startTime < now && now < shareRuleList[i].endTime)\r\n                {\r\n                    canTransferAmount = (i + 1).mul(icoAmount[addr]).div(shareRuleList[i].rateDenominator).sub( sharedAmount[addr]);\r\n                    return canTransferAmount;\r\n                }\r\n            }\r\n            if (allowTransfer == false)\r\n            {\r\n                bool isOverTime = true;\r\n                for (i = 0; i < count ; i++) {\r\n                    if ( now < shareRuleList[i].endTime) {\r\n                        isOverTime = false;\r\n                    }\r\n                }\r\n                if (isOverTime == true) {\r\n                    allowTransfer = true;\r\n                    canTransferAmount = balances[addr];\r\n                    return canTransferAmount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public running returns (bool) \r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        require( locked[msg.sender] != true);\r\n        require( locked[_to] != true);\r\n        require( getRemainShareAmount() >= _value );\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        sharedAmount[msg.sender] = sharedAmount[msg.sender].add( _value );\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) \r\n    {\r\n        return balances[_owner];\r\n    }\r\n}\r\npragma solidity ^0.4.23;\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken \r\n{\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public running returns (bool) \r\n    {\r\n        require(_to != address(0));\r\n        require( locked[_from] != true && locked[_to] != true);\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the\r\n    old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public running returns (bool) \r\n    {\r\n        require(getRemainShareAmountInternal(msg.sender) >= _value);\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) \r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\ncontract AlanPlusToken is StandardToken\r\n{\r\n    event Burn(address indexed from, uint256 value);\r\n    /**\r\n    * Destroy tokens\r\n    * Remove `_value` tokens from the system irreversibly\r\n    * @param _value the amount of money to burn\r\n    */\r\n    function burn(uint256 _value) public onlyOwner running returns (bool success) \r\n    {\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n    /**\r\n    * Destroy tokens from other account\r\n    *\r\n    * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n    *\r\n    * @param _from the address of the senderT\r\n    * @param _value the amount of money to burn\r\n    */\r\n    function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) \r\n    {\r\n        require(balances[_from] >= _value);\r\n        if (_value <= allowed[_from][msg.sender]) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        else {\r\n            allowed[_from][msg.sender] = 0;\r\n        }\r\n        balances[_from] -= _value;\r\n        totalSupply_ -= _value;\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\npragma solidity ^0.4.23;\r\ncontract MAYA is AlanPlusToken \r\n{\r\n    string public constant name = \"Maya\";\r\n    string public constant symbol = \"MAYA\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 private constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\r\n    function () public payable \r\n    {\r\n        uint curIcoRate = 0;\r\n        if (agentRate[msg.sender] > 0) {\r\n            curIcoRate = agentRate[msg.sender];\r\n        }\r\n        else \r\n        {\r\n            uint icoRuleIndex = 500;\r\n            for (uint i = 0; i < icoRuleList.length ; i++)\r\n            {\r\n                if ((icoRuleList[i].canceled != true) && (icoRuleList[i].startTime < now && now < icoRuleList[i].endTime)) {\r\n                    curIcoRate = icoRuleList[i].rate;\r\n                    icoRuleIndex = i;\r\n                }\r\n            }\r\n            if (icoRuleIndex == 500)\r\n            {\r\n                require(icoRuleIndex != 500);\r\n                addr2icoRuleIdList[msg.sender].push( 0 );\r\n                addr2shareRuleGroupId[msg.sender] = addr2shareRuleGroupId[msg.sender] > 0 ? addr2shareRuleGroupId[msg.sender] : 0;\r\n            }\r\n            else\r\n            {\r\n                addr2shareRuleGroupId[msg.sender] = addr2shareRuleGroupId[msg.sender] > 0 ? addr2shareRuleGroupId[msg.sender] : icoRuleList[icoRuleIndex].shareRuleGroupId;\r\n                addr2icoRuleIdList[msg.sender].push( icoRuleIndex + 1 );\r\n                icoPushAddr(icoRuleIndex, msg.sender);\r\n            }\r\n        }\r\n        uint amountMAYA = 0;\r\n        amountMAYA = msg.value.mul( curIcoRate );\r\n        balances[msg.sender] = balances[msg.sender].add(amountMAYA);\r\n        icoAmount[msg.sender] = icoAmount[msg.sender].add(amountMAYA);\r\n        balances[owner] = balances[owner].sub(amountMAYA);\r\n        ADDR_MAYA_ORG.transfer(msg.value);\r\n    }\r\n    event AddBalance(address addr, uint amount);\r\n    event SubBalance(address addr, uint amount);\r\n    address addrContractCaller;\r\n    modifier isContractCaller {\r\n        require(msg.sender == addrContractCaller);\r\n        _;\r\n    }\r\n    function addBalance(address addr, uint amount) public isContractCaller returns(bool)\r\n    {\r\n        require(addr != address(0));\r\n        balances[addr] = balances[addr].add(amount);\r\n        emit AddBalance(addr, amount);\r\n        return true;\r\n    }\r\n    function subBalance(address addr, uint amount) public isContractCaller returns(bool)\r\n    {\r\n        require(balances[addr] >= amount);\r\n        balances[addr] = balances[addr].sub(amount);\r\n        emit SubBalance(addr, amount);\r\n        return true;\r\n    }\r\n    function setAddrContractCaller(address addr) onlyOwner public returns(bool)\r\n    {\r\n        require(addr != address(0));\r\n        addrContractCaller = addr;\r\n        return true;\r\n    }\r\n    constructor(uint totalSupply) public \r\n    {\r\n        owner = msg.sender;\r\n        ADDR_MAYA_ORG = owner;\r\n        totalSupply_ = totalSupply > 0 ? totalSupply : INITIAL_SUPPLY;\r\n        uint assignedAmount = 500000000 + 50000000 + 100000000;\r\n        assignedAmount = parse2wei(assignedAmount);\r\n        balances[owner] = totalSupply_.sub( assignedAmount );\r\n        initIcoRule();\r\n        initPublicityAddr();\r\n        lockAccount(ADDR_MAYA_TEAM);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"icoRuleId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getIcoAddrListByIcoRuleId\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"shareRuleGroupId\",\"type\":\"uint256\"}],\"name\":\"setAccountShareRuleGroupId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainShareAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAddrContractCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setAgentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"lockAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDR_MAYA_ASSOCIATION\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getIcoRuleList\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDR_MAYA_ORG\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"delAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"rateDenominator\",\"type\":\"uint256\"}],\"name\":\"updateShareRuleGroup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDR_MAYA_MARKETING\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"tokenShareShow\",\"outputs\":[{\"name\":\"shareRuleGroupId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"unlockAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"icoRuleId\",\"type\":\"uint256\"}],\"name\":\"getIcoAddrCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADDR_MAYA_TEAM\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"icoRuleCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"shareRuleGroupId\",\"type\":\"uint256\"}],\"name\":\"icoRuleUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"subBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"shareRuleGroupId\",\"type\":\"uint256\"}],\"name\":\"icoRuleAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SubBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"shareRuleGroupId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"canceled\",\"type\":\"bool\"}],\"name\":\"GetIcoRule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rateDenominator\",\"type\":\"uint256\"}],\"name\":\"GetShareRule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MAYA","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bc5fde8648e9e0ef6e16af85c286ca8bee77a11a388db6e679774e8cfddb6235"}]}