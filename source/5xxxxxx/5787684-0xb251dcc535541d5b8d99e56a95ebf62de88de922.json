{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\ncontract ERC223 {\r\n\t\r\n\t// Get the account balance of another account with address owner\r\n\tfunction balanceOf(address owner) public view returns (uint);\r\n\t\r\n\tfunction name() public view returns (string);\r\n\tfunction symbol() public view returns (string);\r\n\tfunction decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint);\r\n\r\n\t// Needed due to backwards compatibility reasons because of ERC20 transfer function does't have bytes\r\n\t// parameter. This function must transfer tokens and invoke the function tokenFallback(address, uint256,\r\n\t// bytes) in to, if to is a contract. If the tokenFallback function is not implemented in to (receiver \r\n\t// contract), the transaaction must fail and the transfer of tokens should not occur.\r\n\tfunction transfer(address to, uint value) public returns (bool success);\r\n\r\n\t// This function must transfer tokens and invoke the function tokenFallback(address, uint256, bytes) in\r\n\t// to, if to is a contract. If the tokenFallback function is not implemented in to (receiver contract), then\r\n\t// the transaction must fail and the transfer of tokens should not occur.\r\n\t// If to is an externally owned address, then the transaction must be sent without trying to execute\r\n\t// tokenFallback in to.\r\n\t// data can be attached to this token transaction it will stay in blockchain forever(requires more gas).\r\n\t// data can be empty.\r\n    function transfer(address to, uint value, bytes data) public returns (bool success);\r\n\r\n    //\r\n    function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed from, address indexed to, uint indexed value, bytes data);\r\n}\r\n\r\n// File: contracts/ERC223ReceivingContract.sol\r\n\r\ncontract ERC223ReceivingContract { \r\n\t\r\n\t// A function for handling token transfers, which is called from the token contract, when a token holder sends\r\n\t// tokens. from is the address of the sender of the token, value is the amount of incoming tokens, and data is\r\n\t// attached data siimilar to msg.data of Ether transactions. It works by analogy with the fallback function of\r\n\t// Ether transactions and returns nothing.\r\n    function tokenFallback(address from, uint value, bytes data) public;\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {function mul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    } \r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n    }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n         return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/MyToken.sol\r\n\r\n/*\r\n * @title Reference implementation fo the ERC223 standard token.\r\n */\r\ncontract MyToken is ERC223 {\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint) balances; // List of user balances.\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint public totalSupply;\r\n\r\n \r\n    constructor(string _name, string _symbol, uint8 _decimals, uint _totalSupply) public {\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t\tdecimals = _decimals;\r\n\t\ttotalSupply = _totalSupply;\r\n\t\tbalances[msg.sender] = _totalSupply;\r\n\t}\r\n\r\n    function name() public view returns (string) {\r\n\t\t return name;\r\n    }\r\n\r\n    function symbol() public view returns (string) {\r\n\t\treturn symbol;\r\n\t}\r\n\r\n    function decimals() public view returns (uint8) {\r\n    \treturn decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n    \treturn totalSupply;\r\n    }\r\n\r\n\r\n\tfunction balanceOf(address owner) public view returns (uint) {\r\n\t\treturn balances[owner];\r\n\t}\r\n\r\n\tfunction transfer(address to, uint value, bytes data) public returns (bool) {\r\n\t\tif(balanceOf(msg.sender) < value) revert();\r\n\t\t// Standard function transfer similar to ERC20 transfer with no data.\r\n\t\t// Added due to backwards compatibility reasons.\r\n\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(value);\r\n\t\tbalances[to] = balances[to].add(value);\r\n\t\tif(isContract(to)) {\r\n\t\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(to);\r\n\t\t\treceiver.tokenFallback(msg.sender, value, data);\r\n\t\t}\r\n\t\temit Transfer(msg.sender, to, value, data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transfer(address to, uint value) public returns (bool) {\r\n\t\tif(balanceOf(msg.sender) < value) revert();\r\n\t\tbytes memory empty;\r\n\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        if(isContract(to)) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(to);\r\n            receiver.tokenFallback(msg.sender, value, empty);\r\n        }\r\n        emit Transfer(msg.sender, to, value, empty);\r\n        return true;\r\n\t}\r\n\r\n\tfunction transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {\r\n\t\tif(balanceOf(msg.sender) < value) revert();\r\n\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n\t\tif (isContract(to)) {\r\n            assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));\r\n        }\r\n        emit Transfer(msg.sender, to, value, data);\r\n        return true;\r\n\t}\r\n\r\n\tfunction isContract(address addr) private view returns (bool) {\r\n\t\tuint len;\r\n\t\tassembly {\r\n\t\t\tlen := extcodesize(addr)\r\n\t\t}\r\n\t\treturn (len > 0);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"customFallback\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MyToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000004a817c8000000000000000000000000000000000000000000000000000000000000000007417274436f696e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044841525400000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://f8170bac0f22accdeb2be19881b8b1594368fc1228ce96bc4c7b910c8dcefaa9"}]}