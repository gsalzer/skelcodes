{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = true;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract CryptoPhoenixes is Ownable, Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  address public subDev;\r\n  Phoenix[] private phoenixes;\r\n  uint256 public PHOENIX_POOL;\r\n  uint256 public EXPLOSION_DENOMINATOR = 1000; //Eg explosivePower = 30 -> 3%\r\n  bool public ALLOW_BETA = true;\r\n  uint BETA_CUTOFF;\r\n\r\n  // devFunds\r\n  mapping (address => uint256) public devFunds;\r\n\r\n  // dividends\r\n  mapping (address => uint256) public userFunds;\r\n\r\n  // Events\r\n  event PhoenixPurchased(\r\n    uint256 _phoenixId,\r\n    address oldOwner,\r\n    address newOwner,\r\n    uint256 price,\r\n    uint256 nextPrice\r\n  );\r\n  \r\n  event PhoenixExploded(\r\n      uint256 phoenixId,\r\n      address owner,\r\n      uint256 payout,\r\n      uint256 price,\r\n      uint nextExplosionTime\r\n  );\r\n\r\n  event WithdrewFunds(\r\n    address owner\r\n  );\r\n\r\n  // Caps for price changes and cutoffs\r\n  uint256 constant private QUARTER_ETH_CAP  = 0.25 ether;\r\n  uint256 constant private ONE_ETH_CAP  = 1.0 ether;\r\n  uint256 public BASE_PRICE = 0.0025 ether;\r\n  uint256 public PRICE_CUTOFF = 1.0 ether;\r\n  uint256 public HIGHER_PRICE_RESET_PERCENTAGE = 20;\r\n  uint256 public LOWER_PRICE_RESET_PERCENTAGE = 10;\r\n\r\n  // Struct to store Phoenix Data\r\n  struct Phoenix {\r\n    uint256 price;  // Current price of phoenix\r\n    uint256 dividendPayout; // The percent of the dividends pool rewarded\r\n    uint256 explosivePower; // Percentage that phoenix can claim from PHOENIX_POOL after explode() function is called\r\n    uint cooldown; // Time it takes for phoenix to recharge till next explosion\r\n    uint nextExplosionTime; // Time of next explosion\r\n    address previousOwner;  // Owner of the phoenix who triggered explosion in previous round\r\n    address currentOwner; // Owner of phoenix in current round\r\n  }\r\n\r\n// Check if game is in beta or not. Certain functions will be disabled after beta period ends.\r\n  modifier inBeta() {\r\n    require(ALLOW_BETA);\r\n    _;\r\n  }\r\n\r\n// Main function to set the beta period and sub developer\r\n  function CryptoPhoenixes(address _subDev) {\r\n    BETA_CUTOFF = now + 90 * 1 days; //Allow 3 months to tweak parameters\r\n    subDev = _subDev;\r\n  }\r\n  \r\n// Function anyone can call to turn off beta, thus disabling some functions\r\n  function closeBeta() {\r\n    require(now >= BETA_CUTOFF);\r\n    ALLOW_BETA = false;\r\n  }\r\n\r\n  function createPhoenix(uint256 _payoutPercentage, uint256 _explosivePower, uint _cooldown) onlyOwner public {\r\n    \r\n    var phoenix = Phoenix({\r\n    price: BASE_PRICE,\r\n    dividendPayout: _payoutPercentage,\r\n    explosivePower: _explosivePower,\r\n    cooldown: _cooldown,\r\n    nextExplosionTime: now,\r\n    previousOwner: address(0),\r\n    currentOwner: this\r\n    });\r\n\r\n    phoenixes.push(phoenix);\r\n  }\r\n\r\n  function createMultiplePhoenixes(uint256[] _payoutPercentages, uint256[] _explosivePowers, uint[] _cooldowns) onlyOwner public {\r\n    require(_payoutPercentages.length == _explosivePowers.length);\r\n    require(_explosivePowers.length == _cooldowns.length);\r\n    \r\n    for (uint256 i = 0; i < _payoutPercentages.length; i++) {\r\n      createPhoenix(_payoutPercentages[i],_explosivePowers[i],_cooldowns[i]);\r\n    }\r\n  }\r\n\r\n  function getPhoenix(uint256 _phoenixId) public view returns (\r\n    uint256 price,\r\n    uint256 nextPrice,\r\n    uint256 dividendPayout,\r\n    uint256 effectivePayout,\r\n    uint256 explosivePower,\r\n    uint cooldown,\r\n    uint nextExplosionTime,\r\n    address previousOwner,\r\n    address currentOwner\r\n  ) {\r\n    var phoenix = phoenixes[_phoenixId];\r\n    price = phoenix.price;\r\n    nextPrice = getNextPrice(phoenix.price);\r\n    dividendPayout = phoenix.dividendPayout;\r\n    effectivePayout = phoenix.dividendPayout.mul(10000).div(getTotalPayout());\r\n    explosivePower = phoenix.explosivePower;\r\n    cooldown = phoenix.cooldown;\r\n    nextExplosionTime = phoenix.nextExplosionTime;\r\n    previousOwner = phoenix.previousOwner;\r\n    currentOwner = phoenix.currentOwner;\r\n  }\r\n\r\n/**\r\n  * @dev Determines next price of token\r\n  * @param _price uint256 ID of current price\r\n*/\r\n  function getNextPrice (uint256 _price) private pure returns (uint256 _nextPrice) {\r\n    if (_price < QUARTER_ETH_CAP) {\r\n      return _price.mul(140).div(100); //1.4x\r\n    } else if (_price < ONE_ETH_CAP) {\r\n      return _price.mul(130).div(100); //1.3x\r\n    } else {\r\n      return _price.mul(125).div(100); //1.25x\r\n    }\r\n  }\r\n\r\n/**\r\n  * @dev Set dividend payout of phoenix\r\n  * @param _phoenixId id of phoenix\r\n  * @param _payoutPercentage uint256 Desired payout percentage\r\n*/\r\n  function setDividendPayout (uint256 _phoenixId, uint256 _payoutPercentage) onlyOwner inBeta {\r\n    Phoenix phoenix = phoenixes[_phoenixId];\r\n    phoenix.dividendPayout = _payoutPercentage;\r\n  }\r\n\r\n/**\r\n  * @dev Set explosive power of phoenix\r\n  * @param _phoenixId id of phoenix\r\n  * @param _explosivePower uint256 Desired claimable percentage from PHOENIX_POOL\r\n*/\r\n  function setExplosivePower (uint256 _phoenixId, uint256 _explosivePower) onlyOwner inBeta {\r\n    Phoenix phoenix = phoenixes[_phoenixId];\r\n    phoenix.explosivePower = _explosivePower;\r\n  }\r\n\r\n/**\r\n  * @dev Set cooldown of phoenix\r\n  * @param _phoenixId id of phoenix\r\n  * @param _cooldown uint256 Desired cooldown time\r\n*/\r\n  function setCooldown (uint256 _phoenixId, uint256 _cooldown) onlyOwner inBeta {\r\n    Phoenix phoenix = phoenixes[_phoenixId];\r\n    phoenix.cooldown = _cooldown;\r\n  }\r\n\r\n/**\r\n  * @dev Set price cutoff when determining phoenix price after explosion. To adjust for ETH price fluctuations\r\n  * @param _price uint256 Price cutoff in wei\r\n*/\r\n  function setPriceCutoff (uint256 _price) onlyOwner {\r\n    PRICE_CUTOFF = _price;\r\n  }\r\n\r\n/**\r\n  * @dev Set price percentage for when price exceeds or equates to price cutoff to reset to\r\n  * @param _percentage uint256 Desired percentage\r\n*/\r\n  function setHigherPricePercentage (uint256 _percentage) onlyOwner inBeta {\r\n    require(_percentage > 0);\r\n    require(_percentage < 100);\r\n    HIGHER_PRICE_RESET_PERCENTAGE = _percentage;\r\n  }\r\n\r\n/**\r\n  * @dev Set price percentage for when price is lower than price cutoff to reset to\r\n  * @param _percentage uint256 Desired percentage\r\n*/\r\n  function setLowerPricePercentage (uint256 _percentage) onlyOwner inBeta {\r\n    require(_percentage > 0);\r\n    require(_percentage < 100);\r\n    LOWER_PRICE_RESET_PERCENTAGE = _percentage;\r\n  }\r\n\r\n/**\r\n  * @dev Set base price for phoenixes. To adjust for ETH price fluctuations\r\n  * @param _amount uint256 Desired amount in wei\r\n*/\r\n  function setBasePrice (uint256 _amount) onlyOwner {\r\n    require(_amount > 0);\r\n    BASE_PRICE = _amount;\r\n  }\r\n\r\n/**\r\n  * @dev Purchase show from previous owner\r\n  * @param _phoenixId uint256 of token\r\n*/\r\n  function purchasePhoenix(uint256 _phoenixId) whenNotPaused public payable {\r\n    Phoenix phoenix = phoenixes[_phoenixId];\r\n    //Get current price of phoenix\r\n    uint256 price = phoenix.price;\r\n\r\n    // revert checks\r\n    require(price > 0);\r\n    require(msg.value >= price);\r\n    //prevent multiple subsequent purchases\r\n    require(outgoingOwner != msg.sender);\r\n\r\n    //Get owners of phoenixes\r\n    address previousOwner = phoenix.previousOwner;\r\n    address outgoingOwner = phoenix.currentOwner;\r\n\r\n    //Define Cut variables\r\n    uint256 devCut;  \r\n    uint256 dividendsCut; \r\n    uint256 previousOwnerCut;\r\n    uint256 phoenixPoolCut;\r\n    uint256 phoenixPoolPurchaseExcessCut;\r\n    \r\n    //Calculate excess\r\n    uint256 purchaseExcess = msg.value.sub(price);\r\n\r\n    //handle boundary case where we assign previousOwner to the user\r\n    if (previousOwner == address(0)) {\r\n        phoenix.previousOwner = msg.sender;\r\n    }\r\n    \r\n    //Calculate cuts\r\n    (devCut,dividendsCut,previousOwnerCut,phoenixPoolCut) = calculateCuts(price);\r\n\r\n    // Amount payable to old owner minus the developer's and pools' cuts.\r\n    uint256 outgoingOwnerCut = price.sub(devCut);\r\n    outgoingOwnerCut = outgoingOwnerCut.sub(dividendsCut);\r\n    outgoingOwnerCut = outgoingOwnerCut.sub(previousOwnerCut);\r\n    outgoingOwnerCut = outgoingOwnerCut.sub(phoenixPoolCut);\r\n    \r\n    // Take 2% cut from leftovers of overbidding\r\n    phoenixPoolPurchaseExcessCut = purchaseExcess.mul(2).div(100);\r\n    purchaseExcess = purchaseExcess.sub(phoenixPoolPurchaseExcessCut);\r\n    phoenixPoolCut = phoenixPoolCut.add(phoenixPoolPurchaseExcessCut);\r\n\r\n    // set new price\r\n    phoenix.price = getNextPrice(price);\r\n\r\n    // set new owner\r\n    phoenix.currentOwner = msg.sender;\r\n\r\n    //Actual transfer\r\n    devFunds[owner] = devFunds[owner].add(devCut.mul(7).div(10)); //70% of dev cut goes to owner\r\n    devFunds[subDev] = devFunds[subDev].add(devCut.mul(3).div(10)); //30% goes to other dev\r\n    distributeDividends(dividendsCut);\r\n    userFunds[previousOwner] = userFunds[previousOwner].add(previousOwnerCut);\r\n    PHOENIX_POOL = PHOENIX_POOL.add(phoenixPoolCut);\r\n\r\n    //handle boundary case where we exclude currentOwner == address(this) when transferring funds\r\n    if (outgoingOwner != address(this)) {\r\n      sendFunds(outgoingOwner,outgoingOwnerCut);\r\n    }\r\n\r\n    // Send refund to owner if needed\r\n    if (purchaseExcess > 0) {\r\n      sendFunds(msg.sender,purchaseExcess);\r\n    }\r\n\r\n    // raise event\r\n    PhoenixPurchased(_phoenixId, outgoingOwner, msg.sender, price, phoenix.price);\r\n  }\r\n\r\n  function calculateCuts(uint256 _price) private pure returns (\r\n    uint256 devCut, \r\n    uint256 dividendsCut,\r\n    uint256 previousOwnerCut,\r\n    uint256 phoenixPoolCut\r\n    ) {\r\n      // Calculate cuts\r\n      // 2% goes to developers\r\n      devCut = _price.mul(2).div(100);\r\n\r\n      // 2.5% goes to dividends\r\n      dividendsCut = _price.mul(25).div(1000); \r\n\r\n      // 0.5% goes to owner of phoenix in previous exploded round\r\n      previousOwnerCut = _price.mul(5).div(1000);\r\n\r\n      // 10-12% goes to phoenix pool\r\n      phoenixPoolCut = calculatePhoenixPoolCut(_price);\r\n    }\r\n\r\n  function calculatePhoenixPoolCut (uint256 _price) private pure returns (uint256 _poolCut) {\r\n      if (_price < QUARTER_ETH_CAP) {\r\n          return _price.mul(12).div(100); //12%\r\n      } else if (_price < ONE_ETH_CAP) {\r\n          return _price.mul(11).div(100); //11%\r\n      } else {\r\n          return _price.mul(10).div(100); //10%\r\n      }\r\n  }\r\n\r\n  function distributeDividends(uint256 _dividendsCut) private {\r\n    uint256 totalPayout = getTotalPayout();\r\n\r\n    for (uint256 i = 0; i < phoenixes.length; i++) {\r\n      var phoenix = phoenixes[i];\r\n      var payout = _dividendsCut.mul(phoenix.dividendPayout).div(totalPayout);\r\n      userFunds[phoenix.currentOwner] = userFunds[phoenix.currentOwner].add(payout);\r\n    }\r\n  }\r\n\r\n  function getTotalPayout() private view returns(uint256) {\r\n    uint256 totalPayout = 0;\r\n\r\n    for (uint256 i = 0; i < phoenixes.length; i++) {\r\n      var phoenix = phoenixes[i];\r\n      totalPayout = totalPayout.add(phoenix.dividendPayout);\r\n    }\r\n\r\n    return totalPayout;\r\n  }\r\n    \r\n//Note that the previous and current owner will be the same person after this function is called\r\n  function explodePhoenix(uint256 _phoenixId) whenNotPaused public {\r\n      Phoenix phoenix = phoenixes[_phoenixId];\r\n      require(msg.sender == phoenix.currentOwner);\r\n      require(PHOENIX_POOL > 0);\r\n      require(now >= phoenix.nextExplosionTime);\r\n      \r\n      uint256 payout = phoenix.explosivePower.mul(PHOENIX_POOL).div(EXPLOSION_DENOMINATOR);\r\n\r\n      //subtract from phoenix_POOL\r\n      PHOENIX_POOL = PHOENIX_POOL.sub(payout);\r\n      \r\n      //decrease phoenix price\r\n      if (phoenix.price >= PRICE_CUTOFF) {\r\n        phoenix.price = phoenix.price.mul(HIGHER_PRICE_RESET_PERCENTAGE).div(100);\r\n      } else {\r\n        phoenix.price = phoenix.price.mul(LOWER_PRICE_RESET_PERCENTAGE).div(100);\r\n        if (phoenix.price < BASE_PRICE) {\r\n          phoenix.price = BASE_PRICE;\r\n          }\r\n      }\r\n\r\n      // set previous owner to be current owner, so he can get extra dividends next round\r\n      phoenix.previousOwner = msg.sender;\r\n      // reset cooldown\r\n      phoenix.nextExplosionTime = now + (phoenix.cooldown * 1 minutes);\r\n      \r\n      // Finally, payout to user\r\n      sendFunds(msg.sender,payout);\r\n      \r\n      //raise event\r\n      PhoenixExploded(_phoenixId, msg.sender, payout, phoenix.price, phoenix.nextExplosionTime);\r\n  }\r\n  \r\n/**\r\n* @dev Try to send funds immediately\r\n* If it fails, user has to manually withdraw.\r\n*/\r\n  function sendFunds(address _user, uint256 _payout) private {\r\n    if (!_user.send(_payout)) {\r\n      userFunds[_user] = userFunds[_user].add(_payout);\r\n    }\r\n  }\r\n\r\n/**\r\n* @dev Withdraw dev cut.\r\n*/\r\n  function devWithdraw() public {\r\n    uint256 funds = devFunds[msg.sender];\r\n    require(funds > 0);\r\n    devFunds[msg.sender] = 0;\r\n    msg.sender.transfer(funds);\r\n  }\r\n\r\n/**\r\n* @dev Users can withdraw their accumulated dividends\r\n*/\r\n  function withdrawFunds() public {\r\n    uint256 funds = userFunds[msg.sender];\r\n    require(funds > 0);\r\n    userFunds[msg.sender] = 0;\r\n    msg.sender.transfer(funds);\r\n    WithdrewFunds(msg.sender);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"closeBeta\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXPLOSION_DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payoutPercentages\",\"type\":\"uint256[]\"},{\"name\":\"_explosivePowers\",\"type\":\"uint256[]\"},{\"name\":\"_cooldowns\",\"type\":\"uint256[]\"}],\"name\":\"createMultiplePhoenixes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_phoenixId\",\"type\":\"uint256\"}],\"name\":\"getPhoenix\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"nextPrice\",\"type\":\"uint256\"},{\"name\":\"dividendPayout\",\"type\":\"uint256\"},{\"name\":\"effectivePayout\",\"type\":\"uint256\"},{\"name\":\"explosivePower\",\"type\":\"uint256\"},{\"name\":\"cooldown\",\"type\":\"uint256\"},{\"name\":\"nextExplosionTime\",\"type\":\"uint256\"},{\"name\":\"previousOwner\",\"type\":\"address\"},{\"name\":\"currentOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setLowerPricePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phoenixId\",\"type\":\"uint256\"},{\"name\":\"_payoutPercentage\",\"type\":\"uint256\"}],\"name\":\"setDividendPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HIGHER_PRICE_RESET_PERCENTAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPriceCutoff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"devFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phoenixId\",\"type\":\"uint256\"}],\"name\":\"explodePhoenix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phoenixId\",\"type\":\"uint256\"},{\"name\":\"_explosivePower\",\"type\":\"uint256\"}],\"name\":\"setExplosivePower\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_payoutPercentage\",\"type\":\"uint256\"},{\"name\":\"_explosivePower\",\"type\":\"uint256\"},{\"name\":\"_cooldown\",\"type\":\"uint256\"}],\"name\":\"createPhoenix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phoenixId\",\"type\":\"uint256\"}],\"name\":\"purchasePhoenix\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phoenixId\",\"type\":\"uint256\"},{\"name\":\"_cooldown\",\"type\":\"uint256\"}],\"name\":\"setCooldown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"setHigherPricePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PHOENIX_POOL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOWER_PRICE_RESET_PERCENTAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setBasePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"subDev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_CUTOFF\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ALLOW_BETA\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_subDev\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_phoenixId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextPrice\",\"type\":\"uint256\"}],\"name\":\"PhoenixPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"phoenixId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextExplosionTime\",\"type\":\"uint256\"}],\"name\":\"PhoenixExploded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"WithdrewFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"CryptoPhoenixes","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096c3170d0981b7321c618ff35aade41dffedaac9","Library":"","SwarmSource":"bzzr://a43233f5b0f9fe185c55264cf842bb791058a4bdcdddf0b58ce6219bd07e4328"}]}