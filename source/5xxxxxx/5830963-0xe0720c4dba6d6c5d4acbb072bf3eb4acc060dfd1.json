{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.9;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n  function transfer(address _to, uint256 _value) returns (bool success) {\r\n    //Default assumes totalSupply can't be over max (2^256 - 1).\r\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    //Replace the if with this one instead.\r\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  uint256 public totalSupply;\r\n}\r\n\r\ncontract ReserveToken is StandardToken, SafeMath {\r\n  address public minter;\r\n  function ReserveToken() {\r\n    minter = msg.sender;\r\n  }\r\n  function create(address account, uint amount) {\r\n    if (msg.sender != minter) throw;\r\n    balances[account] = safeAdd(balances[account], amount);\r\n    totalSupply = safeAdd(totalSupply, amount);\r\n  }\r\n  function destroy(address account, uint amount) {\r\n    if (msg.sender != minter) throw;\r\n    if (balances[account] < amount) throw;\r\n    balances[account] = safeSub(balances[account], amount);\r\n    totalSupply = safeSub(totalSupply, amount);\r\n  }\r\n}\r\n\r\ncontract AccountLevels {\r\n  //given a user, returns an account level\r\n  //0 = regular user (pays take fee and make fee)\r\n  //1 = market maker silver (pays take fee, no make fee, gets rebate)\r\n  //2 = market maker gold (pays take fee, no make fee, gets entire counterparty's take fee as rebate)\r\n  function accountLevel(address user) constant returns(uint) {}\r\n}\r\n\r\ncontract AccountLevelsTest is AccountLevels {\r\n  mapping (address => uint) public accountLevels;\r\n\r\n  function setAccountLevel(address user, uint level) {\r\n    accountLevels[user] = level;\r\n  }\r\n\r\n  function accountLevel(address user) constant returns(uint) {\r\n    return accountLevels[user];\r\n  }\r\n}\r\n\r\ncontract ELTWagerLedger is SafeMath {\r\n  address public admin; //the admin address\r\n\r\n  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  \r\n  \r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n  function ELTWagerLedger(address admin_) {\r\n    admin = admin_;\r\n  }\r\n\r\n  function() {\r\n    throw;\r\n  }\r\n\r\n  function changeAdmin(address admin_) {\r\n    if (msg.sender != admin) throw;\r\n    admin = admin_;\r\n  }\r\n\r\n  function deposit() payable {\r\n    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\r\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function withdraw(uint amount) {\r\n    if (tokens[0][msg.sender] < amount) throw;\r\n    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\r\n    if (!msg.sender.call.value(amount)()) throw;\r\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\r\n  }\r\n\r\n  function depositToken(address token, uint amount) {\r\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\r\n    if (token==0) throw;\r\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\r\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\r\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function withdrawToken(address token, uint amount) {\r\n    if (token==0) throw;\r\n    if (tokens[token][msg.sender] < amount) throw;\r\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\r\n    if (!Token(token).transfer(msg.sender, amount)) throw;\r\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n  }\r\n\r\n  function balanceOf(address token, address user) constant returns (uint) {\r\n    return tokens[token][user];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"admin_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"ELTWagerLedger","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000096fa4cbb4869efdfec0c97f1178ca02da4cfe084","Library":"","SwarmSource":"bzzr://c4984b0318bff371dcd06c5dde2695228d2a640e99deb4463c6df22e27ec86cc"}]}