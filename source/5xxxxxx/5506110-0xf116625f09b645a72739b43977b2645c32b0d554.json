{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address who) public view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) balances;\r\n    uint256 public endTimeLockedTokensTeam = 1601510399; // +2 years (Wed, 30 Sep 2020 23:59:59 GMT)\r\n    uint256 public endTimeLockedTokensAdvisor = 1554076800; // + 6 months (Mon, 01 Apr 2019 00:00:00 GMT)\r\n    address public walletTeam = 0xdEffB0629FD35AD1A462C13D65f003E9079C3bb1;\r\n    address public walletAdvisor = 0xD437f2289B4d20988EcEAc5E050C6b4860FFF4Ac;\r\n\r\n    /**\r\n    * Protection against short address attack\r\n    */\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // Block the sending of tokens from the fund Advisors\r\n        if ((msg.sender == walletAdvisor) && (now < endTimeLockedTokensAdvisor)) {\r\n            revert();\r\n        }\r\n        // Block the sending of tokens from the fund Team\r\n        if((msg.sender == walletTeam) && (now < endTimeLockedTokensTeam)) {\r\n            revert();\r\n        }\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3) returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public onlyPayloadSize(2) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        }\r\n        else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public ownerTwo;\r\n    struct PermissionFunction {\r\n                bool approveOwner;\r\n                bool approveOwnerTwo;\r\n    }\r\n    PermissionFunction[] public permissions;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        permissions.push(PermissionFunction(false, false));\r\n/*\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            permissions.push(PermissionFunction(false, false));\r\n        }\r\n*/\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner || msg.sender == ownerTwo);\r\n        _;\r\n    }\r\n\r\n\r\n    function setApproveOwner(uint8 _numberFunction, bool _permValue) onlyOwner public {\r\n        if(msg.sender == owner){\r\n            permissions[_numberFunction].approveOwner = _permValue;\r\n        }\r\n        if(msg.sender == ownerTwo){\r\n            permissions[_numberFunction].approveOwnerTwo = _permValue;\r\n        }\r\n    }\r\n\r\n/*\r\n    function getApprove(uint8 _numberFunction) public view onlyOwner returns (bool) {\r\n        if(msg.sender == owner){\r\n            return permissions[_numberFunction].approveOwner;\r\n        }\r\n        if(msg.sender == ownerTwo){\r\n            return permissions[_numberFunction].approveOwnerTwo;\r\n        }\r\n    }\r\n*/\r\n\r\n    function removePermission(uint8 _numberFunction) public onlyOwner {\r\n        permissions[_numberFunction].approveOwner = false;\r\n        permissions[_numberFunction].approveOwnerTwo = false;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n    string public constant name = \"Greencoin\";\r\n    string public constant symbol = \"GNC\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    event Mint(address indexed to, uint256 amount);\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address _to, uint256 _amount, address _owner) internal returns (bool) {\r\n        balances[_to] = balances[_to].add(_amount);\r\n        balances[_owner] = balances[_owner].sub(_amount);\r\n        Mint(_to, _amount);\r\n        Transfer(_owner, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Peterson's Law Protection\r\n     * Claim tokens\r\n     */\r\n    function claimTokens(address _token) public  onlyOwner {\r\n    //function claimTokens(address _token) public {  //for test's\r\n        //require(permissions[4].approveOwner == true && permissions[4].approveOwnerTwo == true);\r\n        if (_token == 0x0) {\r\n                owner.transfer(this.balance);\r\n                return;\r\n            }\r\n        MintableToken token = MintableToken(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        Transfer(_token, owner, balance);\r\n        //removePermission(4);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale is Ownable {\r\n    using SafeMath for uint256;\r\n    // address where funds are collected\r\n    address public wallet;\r\n\r\n    // amount of raised money in wei\r\n    uint256 public weiRaised;\r\n    uint256 public tokenAllocated;\r\n    uint256 public hardWeiCap = 60000 * (10 ** 18); // 60,000 ETH\r\n\r\n    function Crowdsale(\r\n    address _wallet\r\n    )\r\n    public\r\n    {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;\r\n    }\r\n}\r\n\r\n\r\ncontract GNCCrowdsale is Ownable, Crowdsale, MintableToken {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n    * Price: 1 ETH = 500 token\r\n    *\r\n    * 1 Stage  1 ETH = 575  token -- discount 15%\r\n    * 2 Stage  1 ETH = 550  token -- discount 10%\r\n    * 3 Stage  1 ETH = 525  token -- discount 5%\r\n    * 4 Stage  1 ETH = 500  token -- discount 0%\r\n    *\r\n    */\r\n    uint256[] public rates  = [575, 550, 525, 500];\r\n    uint256 public weiMinSale =  1 * 10**17;\r\n\r\n    mapping (address => uint256) public deposited;\r\n    mapping(address => bool) public whitelist;\r\n\r\n    uint256 public constant INITIAL_SUPPLY = 50 * (10 ** 6) * (10 ** uint256(decimals));\r\n    uint256 public fundForSale = 30 *   (10 ** 6) * (10 ** uint256(decimals));\r\n    uint256 public fundTeam =    7500 * (10 ** 3) * (10 ** uint256(decimals));\r\n    uint256 public fundAdvisor = 4500 * (10 ** 3) * (10 ** uint256(decimals));\r\n    uint256 public fundBounty =  500 *  (10 ** 3) * (10 ** uint256(decimals));\r\n    uint256 public fundPreIco =  6000 * (10 ** 3) * (10 ** uint256(decimals));\r\n\r\n    address public addressBounty = 0xE3dd17FdFaCa8b190D2fd71f3a34cA95Cdb0f635;\r\n\r\n    uint256 public countInvestor;\r\n\r\n    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);\r\n    event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken);\r\n    event Burn(address indexed burner, uint256 value);\r\n    event HardCapReached();\r\n    event Finalized();\r\n\r\n    function GNCCrowdsale(\r\n    address _owner,\r\n    address _wallet,\r\n    address _ownerTwo\r\n    )\r\n    public\r\n    Crowdsale(_wallet)\r\n    {\r\n        require(_wallet != address(0));\r\n        require(_owner != address(0));\r\n        require(_ownerTwo != address(0));\r\n        owner = _owner;\r\n        ownerTwo = _ownerTwo;\r\n        totalSupply = INITIAL_SUPPLY;\r\n        bool resultMintForOwner = mintForFund(owner);\r\n        require(resultMintForOwner);\r\n    }\r\n\r\n    // fallback function can be used to buy tokens\r\n    function() payable public {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address _investor) public payable returns (uint256){\r\n        require(_investor != address(0));\r\n        uint256 weiAmount = msg.value;\r\n        uint256 tokens = validPurchaseTokens(weiAmount);\r\n        if (tokens == 0) {revert();}\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokenAllocated = tokenAllocated.add(tokens);\r\n        mint(_investor, tokens, owner);\r\n\r\n        TokenPurchase(_investor, weiAmount, tokens);\r\n        if (deposited[_investor] == 0) {\r\n            countInvestor = countInvestor.add(1);\r\n        }\r\n        deposit(_investor);\r\n        wallet.transfer(weiAmount);\r\n        return tokens;\r\n    }\r\n\r\n    function getTotalAmountOfTokens(uint256 _weiAmount) internal returns (uint256) {\r\n        uint256 currentDate = now;\r\n        //currentDate = 1529020800; //for test's (Jun, 15)\r\n        uint256 currentPeriod = getPeriod(currentDate);\r\n        uint256 amountOfTokens = 0;\r\n        if(currentPeriod < 4){\r\n            amountOfTokens = _weiAmount.mul(rates[currentPeriod]);\r\n            if(whitelist[msg.sender]){\r\n                amountOfTokens = amountOfTokens.mul(105).div(100);\r\n            }\r\n            if (currentPeriod == 0) {\r\n                if (tokenAllocated.add(amountOfTokens) > fundPreIco) {\r\n                    TokenLimitReached(tokenAllocated, amountOfTokens);\r\n                    return 0;\r\n                }\r\n            }\r\n        }\r\n        return amountOfTokens;\r\n    }\r\n\r\n    function getPeriod(uint256 _currentDate) public pure returns (uint) {\r\n        /**\r\n        * 1527811200 - Jun, 01, 2018 00:00:00 && 1530403199 - Jun, 30, 2018 23:59:59\r\n        * 1533081600 - Aug, 01, 2018 00:00:00 && 1534377599 - Aug, 15, 2018 23:59:59\r\n        * 1534377600 - Aug, 16, 2018 00:00:00 && 1535759999 - Aug, 31, 2018 23:59:59\r\n        * 1535760000 - Sep, 01, 2018 00:00:00 && 1538351999 - Sep, 30, 2018 23:59:59\r\n        */\r\n\r\n        if( 1527811200 <= _currentDate && _currentDate <= 1530403199){\r\n            return 0;\r\n        }\r\n        if( 1533081600 <= _currentDate && _currentDate <= 1534377599){\r\n            return 1;\r\n        }\r\n        if( 1534377600 <= _currentDate && _currentDate <= 1535759999){\r\n            return 2;\r\n        }\r\n        if( 1535760000 <= _currentDate && _currentDate <= 1538351999){\r\n            return 3;\r\n        }\r\n        return 10;\r\n    }\r\n\r\n    function deposit(address investor) internal {\r\n        deposited[investor] = deposited[investor].add(msg.value);\r\n    }\r\n\r\n    function mintForFund(address _wallet) internal returns (bool result) {\r\n        result = false;\r\n        require(_wallet != address(0));\r\n        balances[_wallet] = balances[_wallet].add(INITIAL_SUPPLY.sub(fundTeam).sub(fundAdvisor).sub(fundBounty));\r\n        balances[walletTeam] = balances[walletTeam].add(fundTeam);\r\n        balances[walletAdvisor] = balances[walletAdvisor].add(fundAdvisor);\r\n        balances[addressBounty] = balances[addressBounty].add(fundBounty);\r\n        result = true;\r\n    }\r\n\r\n    function getDeposited(address _investor) public view returns (uint256){\r\n        return deposited[_investor];\r\n    }\r\n\r\n    function validPurchaseTokens(uint256 _weiAmount) public returns (uint256) {\r\n        uint256 addTokens = getTotalAmountOfTokens(_weiAmount);\r\n        if(_weiAmount < weiMinSale){\r\n            return 0;\r\n        }\r\n        if (tokenAllocated.add(addTokens) > fundForSale) {\r\n            TokenLimitReached(tokenAllocated, addTokens);\r\n            return 0;\r\n        }\r\n        if (weiRaised.add(_weiAmount) > hardWeiCap) {\r\n            HardCapReached();\r\n            return 0;\r\n        }\r\n        return addTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to burn tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function ownerBurnToken(uint _value) public onlyOwner returns (bool) {\r\n        require(_value > 0);\r\n        require(_value <= balances[owner]);\r\n        require(permissions[0].approveOwner == true && permissions[0].approveOwnerTwo == true);\r\n\r\n        balances[owner] = balances[owner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(owner, _value);\r\n        removePermission(0);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n   * @dev Adds single address to whitelist.\r\n   * @param _beneficiary Address to be added to the whitelist\r\n   */\r\n    function addToWhitelist(address _beneficiary) external onlyOwner {\r\n        //require(permissions[1].approveOwner == true && permissions[1].approveOwnerTwo == true);\r\n        whitelist[_beneficiary] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds list of addresses to whitelist. Not overloaded due to limitations with truffle testing.\r\n     * @param _beneficiaries Addresses to be added to the whitelist\r\n     */\r\n    function addManyToWhitelist(address[] _beneficiaries) external onlyOwner {\r\n        //require(permissions[2].approveOwner == true && permissions[2].approveOwnerTwo == true);\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n            whitelist[_beneficiaries[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes single address from whitelist.\r\n     * @param _beneficiary Address to be removed to the whitelist\r\n     */\r\n    function removeFromWhitelist(address _beneficiary) external onlyOwner {\r\n        //require(permissions[3].approveOwner == true && permissions[3].approveOwnerTwo == true);\r\n        whitelist[_beneficiary] = false;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundAdvisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"getDeposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_currentDate\",\"type\":\"uint256\"}],\"name\":\"getPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"permissions\",\"outputs\":[{\"name\":\"approveOwner\",\"type\":\"bool\"},{\"name\":\"approveOwnerTwo\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressBounty\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardWeiCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberFunction\",\"type\":\"uint8\"},{\"name\":\"_permValue\",\"type\":\"bool\"}],\"name\":\"setApproveOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerTwo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimeLockedTokensAdvisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"addManyToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ownerBurnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletAdvisor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimeLockedTokensTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundBounty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberFunction\",\"type\":\"uint8\"}],\"name\":\"removePermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiMinSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"validPurchaseTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_ownerTwo\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"purchasedToken\",\"type\":\"uint256\"}],\"name\":\"TokenLimitReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HardCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"GNCCrowdsale","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008ac4ebccff568797ea4dbb5f39b0ac534ccb901a000000000000000000000000b668078646d38e2e2b4773783280182707ae5f55000000000000000000000000f1f1ff0b8ee5e4b7d8564cfadec545753f8c9111","Library":"","SwarmSource":"bzzr://a78c1194807c63431d90537c2a4d15eeafb0399f08caac1c195af24f6963f565"}]}