{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * license: MIT\r\n */\r\ncontract OwnableSimple {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function OwnableSimple() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// based on axiomzen, MIT license\r\ncontract RandomApi {\r\n    uint64 _seed = 0;\r\n\r\n    function random(uint64 maxExclusive) public returns (uint64 randomNumber) {\r\n        // the blockhash of the current block (and future block) is 0 because it doesn't exist\r\n        _seed = uint64(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));\r\n        return _seed % maxExclusive;\r\n    }\r\n\r\n    function random256() public returns (uint256 randomNumber) {\r\n        uint256 rand = uint256(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));\r\n        _seed = uint64(rand);\r\n        return rand;\r\n    }\r\n}\r\n\r\n// @title ERC-165: Standard interface detection\r\n// https://github.com/ethereum/EIPs/issues/165\r\ncontract ERC165 {\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\n// @title ERC-721: Non-Fungible Tokens\r\n// @author Dieter Shirley (https://github.com/dete)\r\n// @dev https://github.com/ethereum/eips/issues/721\r\ncontract ERC721 is ERC165 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 count);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    \r\n    // described in old version of the standard\r\n    // use the more flexible transferFrom\r\n    function takeOwnership(uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string);\r\n    // function symbol() public view returns (string);\r\n    function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl);\r\n    \r\n    // Optional, described in old version of the standard\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\r\n    function tokenMetadata(uint256 _tokenId) external view returns (string infoUrl);\r\n}\r\n\r\n// Based on strings library by Nick Johnson <arachnid@notdot.net>\r\n// Apache license\r\n// https://github.com/Arachnid/solidity-stringutils\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n    \r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n    \r\n    function toSlice(string self) internal pure returns (slice) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n    \r\n    function toString(slice self) internal pure returns (string) {\r\n        var ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n    \r\n    function len(slice self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        var ptr = self._ptr - 31;\r\n        var end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n    \r\n    function toSliceB32(bytes32 self) internal pure returns (slice ret) {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n    \r\n    function concat(slice self, slice other) internal pure returns (string) {\r\n        var ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n}\r\n\r\n/**\r\n * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/lifecycle/Pausable.sol\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract PausableSimple is OwnableSimple {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = true;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n// heavily modified from https://github.com/dob/auctionhouse/blob/master/contracts/AuctionHouse.sol\r\n// license: MIT\r\n// original author: Doug Petkanics (petkanics@gmail.com) https://github.com/dob\r\ncontract PresaleMarket is PausableSimple {\r\n    struct Auction {\r\n        address seller;\r\n        uint256 price;           // In wei, can be 0\r\n    }\r\n\r\n    ERC721 public artworkContract;\r\n    mapping (uint256 => Auction) artworkIdToAuction;\r\n\r\n    //      0 means everything goes to the seller\r\n    //   1000 means 1%\r\n    //   2500 means 2.5%\r\n    //   4000 means 4%\r\n    //  50000 means 50%\r\n    // 100000 means everything goes to us\r\n    uint256 public distributionCut = 2500;\r\n    bool public constant isPresaleMarket = true;\r\n\r\n    event AuctionCreated(uint256 _artworkId, uint256 _price);\r\n    event AuctionConcluded(uint256 _artworkId, uint256 _price, address _buyer);\r\n    event AuctionCancelled(uint256 _artworkId);\r\n\r\n    // mapping(address => uint256[]) public auctionsRunByUser;\r\n    // No need to have a dedicated variable\r\n    // Can be found by\r\n    //  iterate all artwork ids owned by this auction contract\r\n    //    get the auction object from artworkIdToAuction\r\n    //      get the seller property\r\n    //        return artwork id\r\n    // however it would be a lot better if our second layer keeps track of it\r\n    function auctionsRunByUser(address _address) external view returns(uint256[]) {\r\n        uint256 allArtworkCount = artworkContract.balanceOf(this);\r\n\r\n        uint256 artworkCount = 0;\r\n        uint256[] memory allArtworkIds = new uint256[](allArtworkCount);\r\n        for(uint256 i = 0; i < allArtworkCount; i++) {\r\n            uint256 artworkId = artworkContract.tokenOfOwnerByIndex(this, i);\r\n            Auction storage auction = artworkIdToAuction[artworkId];\r\n            if(auction.seller == _address) {\r\n                allArtworkIds[artworkCount++] = artworkId;\r\n            }\r\n        }\r\n\r\n        uint256[] memory result = new uint256[](artworkCount);\r\n        for(i = 0; i < artworkCount; i++) {\r\n            result[i] = allArtworkIds[i];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // constructor. rename this if you rename the contract\r\n    function PresaleMarket(address _artworkContract) public {\r\n        artworkContract = ERC721(_artworkContract);\r\n    }\r\n\r\n    function bid(uint256 _artworkId) external payable whenNotPaused {\r\n        require(_isAuctionExist(_artworkId));\r\n        Auction storage auction = artworkIdToAuction[_artworkId];\r\n        require(auction.seller != msg.sender);\r\n        uint256 price = auction.price;\r\n        require(msg.value == price);\r\n\r\n        address seller = auction.seller;\r\n        delete artworkIdToAuction[_artworkId];\r\n\r\n        if(price > 0) {\r\n            uint256 myCut =  price * distributionCut / 100000;\r\n            uint256 sellerCut = price - myCut;\r\n            seller.transfer(sellerCut);\r\n        }\r\n\r\n        AuctionConcluded(_artworkId, price, msg.sender);\r\n        artworkContract.transfer(msg.sender, _artworkId);\r\n    }\r\n\r\n    function getAuction(uint256 _artworkId) external view returns(address seller, uint256 price) {\r\n        require(_isAuctionExist(_artworkId));\r\n        Auction storage auction = artworkIdToAuction[_artworkId];\r\n        return (auction.seller, auction.price);\r\n    }\r\n\r\n    function createAuction(uint256 _artworkId, uint256 _price, address _originalOwner) external whenNotPaused {\r\n        require(msg.sender == address(artworkContract));\r\n\r\n        // Will check to see if the seller owns the asset at the contract\r\n        _takeOwnership(_originalOwner, _artworkId);\r\n\r\n        Auction memory auction;\r\n\r\n        auction.seller = _originalOwner;\r\n        auction.price = _price;\r\n\r\n        _createAuction(_artworkId, auction);\r\n    }\r\n\r\n    function _createAuction(uint256 _artworkId, Auction _auction) internal {\r\n        artworkIdToAuction[_artworkId] = _auction;\r\n        AuctionCreated(_artworkId, _auction.price);\r\n    }\r\n\r\n    function cancelAuction(uint256 _artworkId) external {\r\n        require(_isAuctionExist(_artworkId));\r\n        Auction storage auction = artworkIdToAuction[_artworkId];\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_artworkId, seller);\r\n    }\r\n\r\n    function _cancelAuction(uint256 _artworkId, address _owner) internal {\r\n        delete artworkIdToAuction[_artworkId];\r\n        artworkContract.transfer(_owner, _artworkId);\r\n        AuctionCancelled(_artworkId);\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        msg.sender.transfer(this.balance);\r\n    }\r\n\r\n    // only if there is a bug discovered and we need to migrate to a new market contract\r\n    function cancelAuctionEmergency(uint256 _artworkId) external whenPaused onlyOwner {\r\n        require(_isAuctionExist(_artworkId));\r\n        Auction storage auction = artworkIdToAuction[_artworkId];\r\n        _cancelAuction(_artworkId, auction.seller);\r\n    }\r\n\r\n    // simple methods\r\n\r\n    function _isAuctionExist(uint256 _artworkId) internal view returns(bool) {\r\n        return artworkIdToAuction[_artworkId].seller != address(0);\r\n    }\r\n\r\n    function _owns(address _address, uint256 _artworkId) internal view returns(bool) {\r\n        return artworkContract.ownerOf(_artworkId) == _address;\r\n    }\r\n\r\n    function _takeOwnership(address _originalOwner, uint256 _artworkId) internal {\r\n        artworkContract.transferFrom(_originalOwner, this, _artworkId);\r\n    }\r\n}\r\n\r\ncontract Presale is OwnableSimple, RandomApi, ERC721 {\r\n    using strings for *;\r\n\r\n    // There are 4 batches available for presale.\r\n    // A batch is a set of artworks and\r\n    // we plan to release batches monthly.\r\n    uint256 public batchCount;\r\n    mapping(uint256 => uint256) public prices;\r\n    mapping(uint256 => uint256) public supplies;\r\n    mapping(uint256 => uint256) public sold;\r\n\r\n    // Before each batch is released on the main contract,\r\n    // we will disable transfers (including trading)\r\n    // on this contract.\r\n    // This is to prevent someone selling an artwork\r\n    // on the presale contract when we are migrating\r\n    // the artworks to the main contract.\r\n    mapping(uint256 => bool) public isTransferDisabled;\r\n\r\n    uint256[] public dnas;\r\n    mapping(address => uint256) public ownerToTokenCount;\r\n    mapping (uint256 => address) public artworkIdToOwner;\r\n    mapping (uint256 => address) public artworkIdToTransferApproved;\r\n\r\n    PresaleMarket public presaleMarket;\r\n\r\n    bytes4 constant ERC165Signature_ERC165 = bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    // Latest version of ERC721 perhaps\r\n    bytes4 constant ERC165Signature_ERC721A =\r\n    bytes4(keccak256('totalSupply()')) ^\r\n    bytes4(keccak256('balanceOf(address)')) ^\r\n    bytes4(keccak256('ownerOf(uint256)')) ^\r\n    bytes4(keccak256('approve(address,uint256)')) ^\r\n    bytes4(keccak256('transfer(address,uint256)')) ^\r\n    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('name()')) ^\r\n    bytes4(keccak256('symbol()')) ^\r\n    bytes4(keccak256('tokensOfOwner(address)')) ^\r\n    bytes4(keccak256('tokenMetadata(uint256,string)'));\r\n\r\n    // as described in https://github.com/ethereum/eips/issues/721\r\n    // as of January 23, 2018\r\n    bytes4 constant ERC165Signature_ERC721B =\r\n    bytes4(keccak256('name()')) ^\r\n    bytes4(keccak256('symbol()')) ^\r\n    bytes4(keccak256('totalSupply()')) ^\r\n    bytes4(keccak256('balanceOf(address)')) ^\r\n    bytes4(keccak256('ownerOf(uint256)')) ^\r\n    bytes4(keccak256('approve(address,uint256)')) ^\r\n    bytes4(keccak256('takeOwnership(uint256)')) ^\r\n    bytes4(keccak256('transfer(address,uint256)')) ^\r\n    bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n    bytes4(keccak256('tokenMetadata(uint256)'));\r\n\r\n    function Presale() public {\r\n        // Artworks are released in batches, which we plan to release\r\n        // every month if possible. New batches might contain new characters,\r\n        // or old characters in new poses. Later batches will definitely be\r\n        // more rare.\r\n\r\n        // By buying at presale, you have a chance to buy the\r\n        // artwork at potentially 50% of the public release initial sales price.\r\n        // Note that because the public release uses a sliding price system,\r\n        // once an artwork is in the marketplace, the price will get lower until\r\n        // someone buys it.\r\n\r\n        // Example: You bought a batch 1 artwork at presale for 0.05 eth.\r\n        // When the game launches, the first batch 1 artworks are generated\r\n        // on the marketplace with the initial price of 0.1 eth. You sell yours\r\n        // on the marketplace for 0.08 eth which is lower than the public release\r\n        // initial sales price. If someone buys your artwork, you will get profit.\r\n\r\n        // Note that we do not guarantee any profit whatsoever. The price of an\r\n        // item we sell will get cheaper until someone buys it. So other people might wait\r\n        // for the public release artworks to get cheaper and buy it instead of\r\n        // buying yours.\r\n\r\n        // Distribution of presale artworks:\r\n        // When the game is released, all batch 1 presale artworks\r\n        // will be immediately available for trading.\r\n\r\n        // When other batches are released, first we will generate 10 artworks\r\n        // on the marketplace. After that we will distribute the presale\r\n        // artworks with the rate of around 10 every minute.\r\n        // Note that because of mining uncertainties we cannot guarantee any\r\n        // specific timings.\r\n\r\n        // public release initial sales price >= 0.1 ether\r\n        _addPresale(0.05 ether, 450);\r\n\r\n        // public release initial sales price >= 0.24 ether\r\n        _addPresale(0.12 ether, 325);\r\n\r\n        // public release initial sales price >= 0.7 ether\r\n        _addPresale(0.35 ether, 150);\r\n\r\n        // public release initial sales price >= 2.0 ether\r\n        _addPresale(1.0 ether, 75);\r\n    }\r\n\r\n    function buy(uint256 _batch) public payable {\r\n        require(_batch < batchCount);\r\n        require(msg.value == prices[_batch]); // we don't want to deal with refunds\r\n        require(sold[_batch] < supplies[_batch]);\r\n\r\n        sold[_batch]++;\r\n        uint256 dna = _generateRandomDna(_batch);\r\n\r\n        uint256 artworkId = dnas.push(dna) - 1;\r\n        ownerToTokenCount[msg.sender]++;\r\n        artworkIdToOwner[artworkId] = msg.sender;\r\n\r\n        Transfer(0, msg.sender, artworkId);\r\n    }\r\n\r\n    function getArtworkInfo(uint256 _id) external view returns (\r\n        uint256 dna, address owner) {\r\n        require(_id < totalSupply());\r\n\r\n        dna = dnas[_id];\r\n        owner = artworkIdToOwner[_id];\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        msg.sender.transfer(this.balance);\r\n    }\r\n\r\n    function getBatchInfo(uint256 _batch) external view returns(uint256 price, uint256 supply, uint256 soldAmount) {\r\n        require(_batch < batchCount);\r\n\r\n        return (prices[_batch], supplies[_batch], sold[_batch]);\r\n    }\r\n\r\n    function setTransferDisabled(uint256 _batch, bool _isDisabled) external onlyOwner {\r\n        require(_batch < batchCount);\r\n\r\n        isTransferDisabled[_batch] = _isDisabled;\r\n    }\r\n\r\n    function setPresaleMarketAddress(address _address) public onlyOwner {\r\n        PresaleMarket presaleMarketTest = PresaleMarket(_address);\r\n        require(presaleMarketTest.isPresaleMarket());\r\n        presaleMarket = presaleMarketTest;\r\n    }\r\n\r\n    function sell(uint256 _artworkId, uint256 _price) external {\r\n        require(_isOwnerOf(msg.sender, _artworkId));\r\n        require(_canTransferBatch(_artworkId));\r\n        _approveTransfer(_artworkId, presaleMarket);\r\n        presaleMarket.createAuction(_artworkId, _price, msg.sender);\r\n    }\r\n\r\n    // Helper methods\r\n\r\n    function _addPresale(uint256 _price, uint256 _supply) private {\r\n        prices[batchCount] = _price;\r\n        supplies[batchCount] = _supply;\r\n\r\n        batchCount++;\r\n    }\r\n\r\n    function _generateRandomDna(uint256 _batch) private returns(uint256 dna) {\r\n        uint256 rand = random256() % (10 ** 76);\r\n\r\n        // set batch digits\r\n        rand = rand / 100000000 * 100000000 + _batch;\r\n\r\n        return rand;\r\n    }\r\n\r\n    function _isOwnerOf(address _address, uint256 _tokenId) private view returns (bool) {\r\n        return artworkIdToOwner[_tokenId] == _address;\r\n    }\r\n\r\n    function _approveTransfer(uint256 _tokenId, address _address) internal {\r\n        artworkIdToTransferApproved[_tokenId] = _address;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        artworkIdToOwner[_tokenId] = _to;\r\n        ownerToTokenCount[_to]++;\r\n\r\n        ownerToTokenCount[_from]--;\r\n        delete artworkIdToTransferApproved[_tokenId];\r\n\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _approvedForTransfer(address _address, uint256 _tokenId) internal view returns (bool) {\r\n        return artworkIdToTransferApproved[_tokenId] == _address;\r\n    }\r\n\r\n    function _transferFrom(address _from, address _to, uint256 _tokenId) internal {\r\n        require(_isOwnerOf(_from, _tokenId));\r\n        require(_approvedForTransfer(msg.sender, _tokenId));\r\n\r\n        // prevent accidental transfer\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n\r\n        // perform the transfer and emit Transfer event\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _canTransferBatch(uint256 _tokenId) internal view returns(bool) {\r\n        uint256 batch = dnas[_tokenId] % 10;\r\n        return !isTransferDisabled[batch];\r\n    }\r\n\r\n    function _tokenMetadata(uint256 _tokenId, string _preferredTransport) internal view returns (string infoUrl) {\r\n        _preferredTransport; // we don't use this parameter\r\n\r\n        require(_tokenId < totalSupply());\r\n\r\n        strings.slice memory tokenIdSlice = _uintToBytes(_tokenId).toSliceB32();\r\n        return \"/http/etherwaifu.com/presale/artwork/\".toSlice().concat(tokenIdSlice);\r\n    }\r\n\r\n    // Author: pipermerriam\r\n    // MIT license\r\n    // https://github.com/pipermerriam/ethereum-string-utils\r\n    function _uintToBytes(uint256 v) internal pure returns(bytes32 ret) {\r\n        if (v == 0) {\r\n            ret = '0';\r\n        }\r\n        else {\r\n            while (v > 0) {\r\n                ret = bytes32(uint256(ret) / (2 ** 8));\r\n                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\r\n                v /= 10;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // Required methods of ERC721\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return dnas.length;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return ownerToTokenCount[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address) {\r\n        address theOwner = artworkIdToOwner[_tokenId];\r\n        require(theOwner != address(0));\r\n        return theOwner;\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) external {\r\n        require(_canTransferBatch(_tokenId));\r\n\r\n        require(_isOwnerOf(msg.sender, _tokenId));\r\n\r\n        // MUST throw if _tokenID does not represent an NFT\r\n        // but if it is not NFT, owner is address(0)\r\n        // which means it is impossible because msg.sender is a nonzero address\r\n\r\n        require(msg.sender != _to);\r\n\r\n        address prevApprovedAddress = artworkIdToTransferApproved[_tokenId];\r\n        _approveTransfer(_tokenId, _to);\r\n\r\n        // Don't send Approval event if it is just\r\n        // reaffirming that there is no one approved\r\n        if(!(prevApprovedAddress == address(0) && _to == address(0))) {\r\n            Approval(msg.sender, _to, _tokenId);\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokenId) external {\r\n        require(_canTransferBatch(_tokenId));\r\n        require(_isOwnerOf(msg.sender, _tokenId));\r\n\r\n        // prevent accidental transfers\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_to != address(presaleMarket));\r\n\r\n        // perform the transfer and emit Transfer event\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        require(_canTransferBatch(_tokenId));\r\n        _transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function takeOwnership(uint256 _tokenId) external {\r\n        require(_canTransferBatch(_tokenId));\r\n        address owner = artworkIdToOwner[_tokenId];\r\n        _transferFrom(owner, msg.sender, _tokenId);\r\n    }\r\n\r\n    // Optional methods of ERC721\r\n\r\n    function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds) {\r\n        uint256 count = balanceOf(_owner);\r\n\r\n        uint256[] memory res = new uint256[](count);\r\n        uint256 allArtworkCount = totalSupply();\r\n        uint256 i = 0;\r\n\r\n        for(uint256 artworkId = 1; artworkId <= allArtworkCount && i < count; artworkId++) {\r\n            if(artworkIdToOwner[artworkId] == _owner) {\r\n                res[i++] = artworkId;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\r\n        return _tokenMetadata(_tokenId, _preferredTransport);\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId) {\r\n        require(_index < balanceOf(_owner));\r\n\r\n        // not strictly needed because if the state is consistent then\r\n        // a match will be found\r\n        uint256 allArtworkCount = totalSupply();\r\n\r\n        uint256 i = 0;\r\n        for(uint256 artworkId = 0; artworkId < allArtworkCount; artworkId++) {\r\n            if(artworkIdToOwner[artworkId] == _owner) {\r\n                if(i == _index) {\r\n                    return artworkId;\r\n                } else {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        assert(false); // should never reach here\r\n    }\r\n\r\n    function tokenMetadata(uint256 _tokenId) external view returns (string infoUrl) {\r\n        return _tokenMetadata(_tokenId, \"http\");\r\n    }\r\n\r\n    // ERC-165 Standard interface detection (required)\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        return _interfaceID == ERC165Signature_ERC165 ||\r\n        _interfaceID == ERC165Signature_ERC721A ||\r\n        _interfaceID == ERC165Signature_ERC721B;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_preferredTransport\",\"type\":\"string\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"batchCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_batch\",\"type\":\"uint256\"}],\"name\":\"getBatchInfo\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"supply\",\"type\":\"uint256\"},{\"name\":\"soldAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxExclusive\",\"type\":\"uint64\"}],\"name\":\"random\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_batch\",\"type\":\"uint256\"},{\"name\":\"_isDisabled\",\"type\":\"bool\"}],\"name\":\"setTransferDisabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supplies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"artworkIdToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dnas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerToTokenCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTransferDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"random256\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_batch\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getArtworkInfo\",\"outputs\":[{\"name\":\"dna\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"artworkIdToTransferApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPresaleMarketAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Presale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d0100ed001dc9f62c51263d6b84ec7495ba254b93b0077f0c4fa5bca0960b93e"}]}