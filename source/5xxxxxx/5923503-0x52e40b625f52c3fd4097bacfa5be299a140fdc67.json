{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Owned contract with safe ownership pass.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public contractOwner;\r\n\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public pendingContractOwner;\r\n\r\n    function Owned() {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner check modifier\r\n    */\r\n    modifier onlyContractOwner() {\r\n        if (contractOwner == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can call it\r\n     */\r\n    function destroy() onlyContractOwner {\r\n        suicide(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Prepares ownership pass.\r\n     *\r\n     * Can only be called by current owner.\r\n     *\r\n     * @param _to address of the next owner. 0x0 is not allowed.\r\n     *\r\n     * @return success.\r\n     */\r\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\r\n        if (_to  == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Finalize ownership pass.\r\n     *\r\n     * Can only be called by pending owner.\r\n     *\r\n     * @return success.\r\n     */\r\n    function claimContractOwnership() returns(bool) {\r\n        if (pendingContractOwner != msg.sender) {\r\n            return false;\r\n        }\r\n\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\r\n\r\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\r\n        for(uint i=0;i<tokens.length;i++) {\r\n            address token = tokens[i];\r\n            uint balance = ERC20Interface(token).balanceOf(this);\r\n            if(balance != 0)\r\n                ERC20Interface(token).transfer(_to,balance);\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function checkOnlyContractOwner() internal constant returns(uint) {\r\n        if (contractOwner == msg.sender) {\r\n            return OK;\r\n        }\r\n\r\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\r\n    }\r\n}\r\n\r\ncontract OracleMethodAdapter is Object {\r\n\r\n    event OracleAdded(bytes4 _sig, address _oracle);\r\n    event OracleRemoved(bytes4 _sig, address _oracle);\r\n\r\n    mapping(bytes4 => mapping(address => bool)) public oracles;\r\n\r\n    /// @dev Allow access only for oracle\r\n    modifier onlyOracle {\r\n        if (oracles[msg.sig][msg.sender]) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyOracleOrOwner {\r\n        if (oracles[msg.sig][msg.sender] || msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function addOracles(\r\n        bytes4[] _signatures, \r\n        address[] _oracles\r\n    ) \r\n    onlyContractOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        require(_signatures.length == _oracles.length);\r\n        bytes4 _sig;\r\n        address _oracle;\r\n        for (uint _idx = 0; _idx < _signatures.length; ++_idx) {\r\n            (_sig, _oracle) = (_signatures[_idx], _oracles[_idx]);\r\n            if (_oracle != 0x0 \r\n                && _sig != bytes4(0) \r\n                && !oracles[_sig][_oracle]\r\n            ) {\r\n                oracles[_sig][_oracle] = true;\r\n                _emitOracleAdded(_sig, _oracle);\r\n            }\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function removeOracles(\r\n        bytes4[] _signatures, \r\n        address[] _oracles\r\n    ) \r\n    onlyContractOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        require(_signatures.length == _oracles.length);\r\n        bytes4 _sig;\r\n        address _oracle;\r\n        for (uint _idx = 0; _idx < _signatures.length; ++_idx) {\r\n            (_sig, _oracle) = (_signatures[_idx], _oracles[_idx]);\r\n            if (_oracle != 0x0 \r\n                && _sig != bytes4(0) \r\n                && oracles[_sig][_oracle]\r\n            ) {\r\n                delete oracles[_sig][_oracle];\r\n                _emitOracleRemoved(_sig, _oracle);\r\n            }\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function _emitOracleAdded(bytes4 _sig, address _oracle) internal {\r\n        OracleAdded(_sig, _oracle);\r\n    }\r\n\r\n    function _emitOracleRemoved(bytes4 _sig, address _oracle) internal {\r\n        OracleRemoved(_sig, _oracle);\r\n    }\r\n\r\n}\r\n\r\n/// @title Provides possibility manage holders? country limits and limits for holders.\r\ncontract DataControllerInterface {\r\n\r\n    /// @notice Checks user is holder.\r\n    /// @param _address - checking address.\r\n    /// @return `true` if _address is registered holder, `false` otherwise.\r\n    function isHolderAddress(address _address) public view returns (bool);\r\n\r\n    function allowance(address _user) public view returns (uint);\r\n\r\n    function changeAllowance(address _holder, uint _value) public returns (uint);\r\n}\r\n\r\n/// @title ServiceController\r\n///\r\n/// Base implementation\r\n/// Serves for managing service instances\r\ncontract ServiceControllerInterface {\r\n\r\n    /// @notice Check target address is service\r\n    /// @param _address target address\r\n    /// @return `true` when an address is a service, `false` otherwise\r\n    function isService(address _address) public view returns (bool);\r\n}\r\n\r\ncontract ATxAssetInterface {\r\n\r\n    DataControllerInterface public dataController;\r\n    ServiceControllerInterface public serviceController;\r\n\r\n    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public returns (bool);\r\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public returns (bool);\r\n    function __approve(address _spender, uint _value, address _sender) public returns (bool);\r\n    function __process(bytes /*_data*/, address /*_sender*/) payable public {\r\n        revert();\r\n    }\r\n}\r\n\r\n/// @title ServiceAllowance.\r\n///\r\n/// Provides a way to delegate operation allowance decision to a service contract\r\ncontract ServiceAllowance {\r\n    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\r\n}\r\n\r\ncontract ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\ncontract Platform {\r\n    mapping(bytes32 => address) public proxies;\r\n    function name(bytes32 _symbol) public view returns (string);\r\n    function setProxy(address _address, bytes32 _symbol) public returns (uint errorCode);\r\n    function isOwner(address _owner, bytes32 _symbol) public view returns (bool);\r\n    function totalSupply(bytes32 _symbol) public view returns (uint);\r\n    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint);\r\n    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint);\r\n    function baseUnit(bytes32 _symbol) public view returns (uint8);\r\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\r\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public returns (uint errorCode);\r\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public returns (uint errorCode);\r\n    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint errorCode);\r\n    function reissueAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\r\n    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint errorCode);\r\n    function isReissuable(bytes32 _symbol) public view returns (bool);\r\n    function changeOwnership(bytes32 _symbol, address _newOwner) public returns (uint errorCode);\r\n}\r\n\r\ncontract ATxAssetProxy is ERC20, Object, ServiceAllowance {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\r\n     */\r\n    event UpgradeProposal(address newVersion);\r\n\r\n    // Current asset implementation contract address.\r\n    address latestVersion;\r\n\r\n    // Assigned platform, immutable.\r\n    Platform public platform;\r\n\r\n    // Assigned symbol, immutable.\r\n    bytes32 public smbl;\r\n\r\n    // Assigned name, immutable.\r\n    string public name;\r\n\r\n    /**\r\n     * Only platform is allowed to call.\r\n     */\r\n    modifier onlyPlatform() {\r\n        if (msg.sender == address(platform)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Only current asset owner is allowed to call.\r\n     */\r\n    modifier onlyAssetOwner() {\r\n        if (platform.isOwner(msg.sender, smbl)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Only asset implementation contract assigned to sender is allowed to call.\r\n     */\r\n    modifier onlyAccess(address _sender) {\r\n        if (getLatestVersion() == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resolves asset implementation contract for the caller and forwards there transaction data,\r\n     * along with the value. This allows for proxy interface growth.\r\n     */\r\n    function() public payable {\r\n        _getAsset().__process.value(msg.value)(msg.data, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Sets platform address, assigns symbol and name.\r\n     *\r\n     * Can be set only once.\r\n     *\r\n     * @param _platform platform contract address.\r\n     * @param _symbol assigned symbol.\r\n     * @param _name assigned name.\r\n     *\r\n     * @return success.\r\n     */\r\n    function init(Platform _platform, string _symbol, string _name) public returns (bool) {\r\n        if (address(platform) != 0x0) {\r\n            return false;\r\n        }\r\n        platform = _platform;\r\n        symbol = _symbol;\r\n        smbl = stringToBytes32(_symbol);\r\n        name = _name;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns asset total supply.\r\n     *\r\n     * @return asset total supply.\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return platform.totalSupply(smbl);\r\n    }\r\n\r\n    /**\r\n     * Returns asset balance for a particular holder.\r\n     *\r\n     * @param _owner holder address.\r\n     *\r\n     * @return holder balance.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return platform.balanceOf(_owner, smbl);\r\n    }\r\n\r\n    /**\r\n     * Returns asset allowance from one holder to another.\r\n     *\r\n     * @param _from holder that allowed spending.\r\n     * @param _spender holder that is allowed to spend.\r\n     *\r\n     * @return holder to spender allowance.\r\n     */\r\n    function allowance(address _from, address _spender) public view returns (uint) {\r\n        return platform.allowance(_from, _spender, smbl);\r\n    }\r\n\r\n    /**\r\n     * Returns asset decimals.\r\n     *\r\n     * @return asset decimals.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return platform.baseUnit(smbl);\r\n    }\r\n\r\n    /**\r\n     * Transfers asset balance from the caller to specified receiver.\r\n     *\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     *\r\n     * @return success.\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool) {\r\n        if (_to != 0x0) {\r\n            return _transferWithReference(_to, _value, \"\");\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfers asset balance from the caller to specified receiver adding specified comment.\r\n     *\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a platform's Transfer event.\r\n     *\r\n     * @return success.\r\n     */\r\n    function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {\r\n        if (_to != 0x0) {\r\n            return _transferWithReference(_to, _value, _reference);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs transfer call on the platform by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a platform's Transfer event.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     */\r\n    function __transferWithReference(address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\r\n        return platform.proxyTransferWithReference(_to, _value, smbl, _reference, _sender) == OK;\r\n    }\r\n\r\n    /**\r\n     * Prforms allowance transfer of asset balance between holders.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     *\r\n     * @return success.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\r\n        if (_to != 0x0) {\r\n            return _getAsset().__transferFromWithReference(_from, _to, _value, \"\", msg.sender);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs allowance transfer call on the platform by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a platform's Transfer event.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     */\r\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) public onlyAccess(_sender) returns (bool) {\r\n        return platform.proxyTransferFromWithReference(_from, _to, _value, smbl, _reference, _sender) == OK;\r\n    }\r\n\r\n    /**\r\n     * Sets asset spending allowance for a specified spender.\r\n     *\r\n     * @param _spender holder address to set allowance to.\r\n     * @param _value amount to allow.\r\n     *\r\n     * @return success.\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        if (_spender != 0x0) {\r\n            return _getAsset().__approve(_spender, _value, msg.sender);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs allowance setting call on the platform by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _spender holder address to set allowance to.\r\n     * @param _value amount to allow.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     */\r\n    function __approve(address _spender, uint _value, address _sender) public onlyAccess(_sender) returns (bool) {\r\n        return platform.proxyApprove(_spender, _value, smbl, _sender) == OK;\r\n    }\r\n\r\n    /**\r\n     * Emits ERC20 Transfer event on this contract.\r\n     *\r\n     * Can only be, and, called by assigned platform when asset transfer happens.\r\n     */\r\n    function emitTransfer(address _from, address _to, uint _value) public onlyPlatform() {\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * Emits ERC20 Approval event on this contract.\r\n     *\r\n     * Can only be, and, called by assigned platform when asset allowance set happens.\r\n     */\r\n    function emitApprove(address _from, address _spender, uint _value) public onlyPlatform() {\r\n        Approval(_from, _spender, _value);\r\n    }\r\n\r\n    /**\r\n     * Returns current asset implementation contract address.\r\n     *\r\n     * @return asset implementation contract address.\r\n     */\r\n    function getLatestVersion() public view returns (address) {\r\n        return latestVersion;\r\n    }\r\n\r\n    /**\r\n     * Propose next asset implementation contract address.\r\n     *\r\n     * Can only be called by current asset owner.\r\n     *\r\n     * Note: freeze-time should not be applied for the initial setup.\r\n     *\r\n     * @param _newVersion asset implementation contract address.\r\n     *\r\n     * @return success.\r\n     */\r\n    function proposeUpgrade(address _newVersion) public onlyAssetOwner returns (bool) {\r\n        // New version address should be other than 0x0.\r\n        if (_newVersion == 0x0) {\r\n            return false;\r\n        }\r\n        \r\n        latestVersion = _newVersion;\r\n\r\n        UpgradeProposal(_newVersion); \r\n        return true;\r\n    }\r\n\r\n    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns asset implementation contract for current caller.\r\n     *\r\n     * @return asset implementation contract.\r\n     */\r\n    function _getAsset() internal view returns (ATxAssetInterface) {\r\n        return ATxAssetInterface(getLatestVersion());\r\n    }\r\n\r\n    /**\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\n     * the caller address.\r\n     *\r\n     * @return success.\r\n     */\r\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns (bool) {\r\n        return _getAsset().__transferWithReference(_to, _value, _reference, msg.sender);\r\n    }\r\n\r\n    function stringToBytes32(string memory source) private pure returns (bytes32 result) {\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n}\r\n\r\ncontract DataControllerEmitter {\r\n\r\n    event CountryCodeAdded(uint _countryCode, uint _countryId, uint _maxHolderCount);\r\n    event CountryCodeChanged(uint _countryCode, uint _countryId, uint _maxHolderCount);\r\n\r\n    event HolderRegistered(bytes32 _externalHolderId, uint _accessIndex, uint _countryCode);\r\n    event HolderAddressAdded(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex);\r\n    event HolderAddressRemoved(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex);\r\n    event HolderOperationalChanged(bytes32 _externalHolderId, bool _operational);\r\n\r\n    event DayLimitChanged(bytes32 _externalHolderId, uint _from, uint _to);\r\n    event MonthLimitChanged(bytes32 _externalHolderId, uint _from, uint _to);\r\n\r\n    event Error(uint _errorCode);\r\n\r\n    function _emitHolderAddressAdded(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex) internal {\r\n        HolderAddressAdded(_externalHolderId, _holderPrototype, _accessIndex);\r\n    }\r\n\r\n    function _emitHolderAddressRemoved(bytes32 _externalHolderId, address _holderPrototype, uint _accessIndex) internal {\r\n        HolderAddressRemoved(_externalHolderId, _holderPrototype, _accessIndex);\r\n    }\r\n\r\n    function _emitHolderRegistered(bytes32 _externalHolderId, uint _accessIndex, uint _countryCode) internal {\r\n        HolderRegistered(_externalHolderId, _accessIndex, _countryCode);\r\n    }\r\n\r\n    function _emitHolderOperationalChanged(bytes32 _externalHolderId, bool _operational) internal {\r\n        HolderOperationalChanged(_externalHolderId, _operational);\r\n    }\r\n\r\n    function _emitCountryCodeAdded(uint _countryCode, uint _countryId, uint _maxHolderCount) internal {\r\n        CountryCodeAdded(_countryCode, _countryId, _maxHolderCount);\r\n    }\r\n\r\n    function _emitCountryCodeChanged(uint _countryCode, uint _countryId, uint _maxHolderCount) internal {\r\n        CountryCodeChanged(_countryCode, _countryId, _maxHolderCount);\r\n    }\r\n\r\n    function _emitDayLimitChanged(bytes32 _externalHolderId, uint _from, uint _to) internal {\r\n        DayLimitChanged(_externalHolderId, _from, _to);\r\n    }\r\n\r\n    function _emitMonthLimitChanged(bytes32 _externalHolderId, uint _from, uint _to) internal {\r\n        MonthLimitChanged(_externalHolderId, _from, _to);\r\n    }\r\n\r\n    function _emitError(uint _errorCode) internal returns (uint) {\r\n        Error(_errorCode);\r\n        return _errorCode;\r\n    }\r\n}\r\n\r\ncontract GroupsAccessManagerEmitter {\r\n\r\n    event UserCreated(address user);\r\n    event UserDeleted(address user);\r\n    event GroupCreated(bytes32 groupName);\r\n    event GroupActivated(bytes32 groupName);\r\n    event GroupDeactivated(bytes32 groupName);\r\n    event UserToGroupAdded(address user, bytes32 groupName);\r\n    event UserFromGroupRemoved(address user, bytes32 groupName);\r\n}\r\n\r\n/// @title Group Access Manager\r\n///\r\n/// Base implementation\r\n/// This contract serves as group manager\r\ncontract GroupsAccessManager is Object, GroupsAccessManagerEmitter {\r\n\r\n    uint constant USER_MANAGER_SCOPE = 111000;\r\n    uint constant USER_MANAGER_MEMBER_ALREADY_EXIST = USER_MANAGER_SCOPE + 1;\r\n    uint constant USER_MANAGER_GROUP_ALREADY_EXIST = USER_MANAGER_SCOPE + 2;\r\n    uint constant USER_MANAGER_OBJECT_ALREADY_SECURED = USER_MANAGER_SCOPE + 3;\r\n    uint constant USER_MANAGER_CONFIRMATION_HAS_COMPLETED = USER_MANAGER_SCOPE + 4;\r\n    uint constant USER_MANAGER_USER_HAS_CONFIRMED = USER_MANAGER_SCOPE + 5;\r\n    uint constant USER_MANAGER_NOT_ENOUGH_GAS = USER_MANAGER_SCOPE + 6;\r\n    uint constant USER_MANAGER_INVALID_INVOCATION = USER_MANAGER_SCOPE + 7;\r\n    uint constant USER_MANAGER_DONE = USER_MANAGER_SCOPE + 11;\r\n    uint constant USER_MANAGER_CANCELLED = USER_MANAGER_SCOPE + 12;\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Member {\r\n        address addr;\r\n        uint groupsCount;\r\n        mapping(bytes32 => uint) groupName2index;\r\n        mapping(uint => uint) index2globalIndex;\r\n    }\r\n\r\n    struct Group {\r\n        bytes32 name;\r\n        uint priority;\r\n        uint membersCount;\r\n        mapping(address => uint) memberAddress2index;\r\n        mapping(uint => uint) index2globalIndex;\r\n    }\r\n\r\n    uint public membersCount;\r\n    mapping(uint => address) index2memberAddress;\r\n    mapping(address => uint) memberAddress2index;\r\n    mapping(address => Member) address2member;\r\n\r\n    uint public groupsCount;\r\n    mapping(uint => bytes32) index2groupName;\r\n    mapping(bytes32 => uint) groupName2index;\r\n    mapping(bytes32 => Group) groupName2group;\r\n    mapping(bytes32 => bool) public groupsBlocked; // if groupName => true, then couldn't be used for confirmation\r\n\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    /// @notice Register user\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _user user address\r\n    ///\r\n    /// @return code\r\n    function registerUser(address _user) external onlyContractOwner returns (uint) {\r\n        require(_user != 0x0);\r\n\r\n        if (isRegisteredUser(_user)) {\r\n            return USER_MANAGER_MEMBER_ALREADY_EXIST;\r\n        }\r\n\r\n        uint _membersCount = membersCount.add(1);\r\n        membersCount = _membersCount;\r\n        memberAddress2index[_user] = _membersCount;\r\n        index2memberAddress[_membersCount] = _user;\r\n        address2member[_user] = Member(_user, 0);\r\n\r\n        UserCreated(_user);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Discard user registration\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _user user address\r\n    ///\r\n    /// @return code\r\n    function unregisterUser(address _user) external onlyContractOwner returns (uint) {\r\n        require(_user != 0x0);\r\n\r\n        uint _memberIndex = memberAddress2index[_user];\r\n        if (_memberIndex == 0 || address2member[_user].groupsCount != 0) {\r\n            return USER_MANAGER_INVALID_INVOCATION;\r\n        }\r\n\r\n        uint _membersCount = membersCount;\r\n        delete memberAddress2index[_user];\r\n        if (_memberIndex != _membersCount) {\r\n            address _lastUser = index2memberAddress[_membersCount];\r\n            index2memberAddress[_memberIndex] = _lastUser;\r\n            memberAddress2index[_lastUser] = _memberIndex;\r\n        }\r\n        delete address2member[_user];\r\n        delete index2memberAddress[_membersCount];\r\n        delete memberAddress2index[_user];\r\n        membersCount = _membersCount.sub(1);\r\n\r\n        UserDeleted(_user);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Create group\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group name\r\n    /// @param _priority group priority\r\n    ///\r\n    /// @return code\r\n    function createGroup(bytes32 _groupName, uint _priority) external onlyContractOwner returns (uint) {\r\n        require(_groupName != bytes32(0));\r\n\r\n        if (isGroupExists(_groupName)) {\r\n            return USER_MANAGER_GROUP_ALREADY_EXIST;\r\n        }\r\n\r\n        uint _groupsCount = groupsCount.add(1);\r\n        groupName2index[_groupName] = _groupsCount;\r\n        index2groupName[_groupsCount] = _groupName;\r\n        groupName2group[_groupName] = Group(_groupName, _priority, 0);\r\n        groupsCount = _groupsCount;\r\n\r\n        GroupCreated(_groupName);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Change group status\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group name\r\n    /// @param _blocked block status\r\n    ///\r\n    /// @return code\r\n    function changeGroupActiveStatus(bytes32 _groupName, bool _blocked) external onlyContractOwner returns (uint) {\r\n        require(isGroupExists(_groupName));\r\n        groupsBlocked[_groupName] = _blocked;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Add users in group\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group name\r\n    /// @param _users user array\r\n    ///\r\n    /// @return code\r\n    function addUsersToGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\r\n        require(isGroupExists(_groupName));\r\n\r\n        Group storage _group = groupName2group[_groupName];\r\n        uint _groupMembersCount = _group.membersCount;\r\n\r\n        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\r\n            address _user = _users[_userIdx];\r\n            uint _memberIndex = memberAddress2index[_user];\r\n            require(_memberIndex != 0);\r\n\r\n            if (_group.memberAddress2index[_user] != 0) {\r\n                continue;\r\n            }\r\n\r\n            _groupMembersCount = _groupMembersCount.add(1);\r\n            _group.memberAddress2index[_user] = _groupMembersCount;\r\n            _group.index2globalIndex[_groupMembersCount] = _memberIndex;\r\n\r\n            _addGroupToMember(_user, _groupName);\r\n\r\n            UserToGroupAdded(_user, _groupName);\r\n        }\r\n        _group.membersCount = _groupMembersCount;\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Remove users in group\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group name\r\n    /// @param _users user array\r\n    ///\r\n    /// @return code\r\n    function removeUsersFromGroup(bytes32 _groupName, address[] _users) external onlyContractOwner returns (uint) {\r\n        require(isGroupExists(_groupName));\r\n\r\n        Group storage _group = groupName2group[_groupName];\r\n        uint _groupMembersCount = _group.membersCount;\r\n\r\n        for (uint _userIdx = 0; _userIdx < _users.length; ++_userIdx) {\r\n            address _user = _users[_userIdx];\r\n            uint _memberIndex = memberAddress2index[_user];\r\n            uint _groupMemberIndex = _group.memberAddress2index[_user];\r\n\r\n            if (_memberIndex == 0 || _groupMemberIndex == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (_groupMemberIndex != _groupMembersCount) {\r\n                uint _lastUserGlobalIndex = _group.index2globalIndex[_groupMembersCount];\r\n                address _lastUser = index2memberAddress[_lastUserGlobalIndex];\r\n                _group.index2globalIndex[_groupMemberIndex] = _lastUserGlobalIndex;\r\n                _group.memberAddress2index[_lastUser] = _groupMemberIndex;\r\n            }\r\n            delete _group.memberAddress2index[_user];\r\n            delete _group.index2globalIndex[_groupMembersCount];\r\n            _groupMembersCount = _groupMembersCount.sub(1);\r\n\r\n            _removeGroupFromMember(_user, _groupName);\r\n\r\n            UserFromGroupRemoved(_user, _groupName);\r\n        }\r\n        _group.membersCount = _groupMembersCount;\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Check is user registered\r\n    ///\r\n    /// @param _user user address\r\n    ///\r\n    /// @return status\r\n    function isRegisteredUser(address _user) public view returns (bool) {\r\n        return memberAddress2index[_user] != 0;\r\n    }\r\n\r\n    /// @notice Check is user in group\r\n    ///\r\n    /// @param _groupName user array\r\n    /// @param _user user array\r\n    ///\r\n    /// @return status\r\n    function isUserInGroup(bytes32 _groupName, address _user) public view returns (bool) {\r\n        return isRegisteredUser(_user) && address2member[_user].groupName2index[_groupName] != 0;\r\n    }\r\n\r\n    /// @notice Check is group exist\r\n    ///\r\n    /// @param _groupName group name\r\n    ///\r\n    /// @return status\r\n    function isGroupExists(bytes32 _groupName) public view returns (bool) {\r\n        return groupName2index[_groupName] != 0;\r\n    }\r\n\r\n    /// @notice Get current group names\r\n    ///\r\n    /// @return group names\r\n    function getGroups() public view returns (bytes32[] _groups) {\r\n        uint _groupsCount = groupsCount;\r\n        _groups = new bytes32[](_groupsCount);\r\n        for (uint _groupIdx = 0; _groupIdx < _groupsCount; ++_groupIdx) {\r\n            _groups[_groupIdx] = index2groupName[_groupIdx + 1];\r\n        }\r\n    }\r\n\r\n    // PRIVATE\r\n\r\n    function _removeGroupFromMember(address _user, bytes32 _groupName) private {\r\n        Member storage _member = address2member[_user];\r\n        uint _memberGroupsCount = _member.groupsCount;\r\n        uint _memberGroupIndex = _member.groupName2index[_groupName];\r\n        if (_memberGroupIndex != _memberGroupsCount) {\r\n            uint _lastGroupGlobalIndex = _member.index2globalIndex[_memberGroupsCount];\r\n            bytes32 _lastGroupName = index2groupName[_lastGroupGlobalIndex];\r\n            _member.index2globalIndex[_memberGroupIndex] = _lastGroupGlobalIndex;\r\n            _member.groupName2index[_lastGroupName] = _memberGroupIndex;\r\n        }\r\n        delete _member.groupName2index[_groupName];\r\n        delete _member.index2globalIndex[_memberGroupsCount];\r\n        _member.groupsCount = _memberGroupsCount.sub(1);\r\n    }\r\n\r\n    function _addGroupToMember(address _user, bytes32 _groupName) private {\r\n        Member storage _member = address2member[_user];\r\n        uint _memberGroupsCount = _member.groupsCount.add(1);\r\n        _member.groupName2index[_groupName] = _memberGroupsCount;\r\n        _member.index2globalIndex[_memberGroupsCount] = groupName2index[_groupName];\r\n        _member.groupsCount = _memberGroupsCount;\r\n    }\r\n}\r\n\r\ncontract PendingManagerEmitter {\r\n\r\n    event PolicyRuleAdded(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName, uint acceptLimit, uint declinesLimit);\r\n    event PolicyRuleRemoved(bytes4 sig, address contractAddress, bytes32 key, bytes32 groupName);\r\n\r\n    event ProtectionTxAdded(bytes32 key, bytes32 sig, uint blockNumber);\r\n    event ProtectionTxAccepted(bytes32 key, address indexed sender, bytes32 groupNameVoted);\r\n    event ProtectionTxDone(bytes32 key);\r\n    event ProtectionTxDeclined(bytes32 key, address indexed sender, bytes32 groupNameVoted);\r\n    event ProtectionTxCancelled(bytes32 key);\r\n    event ProtectionTxVoteRevoked(bytes32 key, address indexed sender, bytes32 groupNameVoted);\r\n    event TxDeleted(bytes32 key);\r\n\r\n    event Error(uint errorCode);\r\n\r\n    function _emitError(uint _errorCode) internal returns (uint) {\r\n        Error(_errorCode);\r\n        return _errorCode;\r\n    }\r\n}\r\n\r\ncontract PendingManagerInterface {\r\n\r\n    function signIn(address _contract) external returns (uint);\r\n    function signOut(address _contract) external returns (uint);\r\n\r\n    function addPolicyRule(\r\n        bytes4 _sig, \r\n        address _contract, \r\n        bytes32 _groupName, \r\n        uint _acceptLimit, \r\n        uint _declineLimit \r\n        ) \r\n        external returns (uint);\r\n        \r\n    function removePolicyRule(\r\n        bytes4 _sig, \r\n        address _contract, \r\n        bytes32 _groupName\r\n        ) \r\n        external returns (uint);\r\n\r\n    function addTx(bytes32 _key, bytes4 _sig, address _contract) external returns (uint);\r\n    function deleteTx(bytes32 _key) external returns (uint);\r\n\r\n    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\r\n    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint);\r\n    function revoke(bytes32 _key) external returns (uint);\r\n\r\n    function hasConfirmedRecord(bytes32 _key) public view returns (uint);\r\n    function getPolicyDetails(bytes4 _sig, address _contract) public view returns (\r\n        bytes32[] _groupNames,\r\n        uint[] _acceptLimits,\r\n        uint[] _declineLimits,\r\n        uint _totalAcceptedLimit,\r\n        uint _totalDeclinedLimit\r\n        );\r\n}\r\n\r\n/// @title PendingManager\r\n///\r\n/// Base implementation\r\n/// This contract serves as pending manager for transaction status\r\ncontract PendingManager is Object, PendingManagerEmitter, PendingManagerInterface {\r\n\r\n    uint constant NO_RECORDS_WERE_FOUND = 4;\r\n    uint constant PENDING_MANAGER_SCOPE = 4000;\r\n    uint constant PENDING_MANAGER_INVALID_INVOCATION = PENDING_MANAGER_SCOPE + 1;\r\n    uint constant PENDING_MANAGER_HASNT_VOTED = PENDING_MANAGER_SCOPE + 2;\r\n    uint constant PENDING_DUPLICATE_TX = PENDING_MANAGER_SCOPE + 3;\r\n    uint constant PENDING_MANAGER_CONFIRMED = PENDING_MANAGER_SCOPE + 4;\r\n    uint constant PENDING_MANAGER_REJECTED = PENDING_MANAGER_SCOPE + 5;\r\n    uint constant PENDING_MANAGER_IN_PROCESS = PENDING_MANAGER_SCOPE + 6;\r\n    uint constant PENDING_MANAGER_TX_DOESNT_EXIST = PENDING_MANAGER_SCOPE + 7;\r\n    uint constant PENDING_MANAGER_TX_WAS_DECLINED = PENDING_MANAGER_SCOPE + 8;\r\n    uint constant PENDING_MANAGER_TX_WAS_NOT_CONFIRMED = PENDING_MANAGER_SCOPE + 9;\r\n    uint constant PENDING_MANAGER_INSUFFICIENT_GAS = PENDING_MANAGER_SCOPE + 10;\r\n    uint constant PENDING_MANAGER_POLICY_NOT_FOUND = PENDING_MANAGER_SCOPE + 11;\r\n\r\n    using SafeMath for uint;\r\n\r\n    enum GuardState {\r\n        Decline, Confirmed, InProcess\r\n    }\r\n\r\n    struct Requirements {\r\n        bytes32 groupName;\r\n        uint acceptLimit;\r\n        uint declineLimit;\r\n    }\r\n\r\n    struct Policy {\r\n        uint groupsCount;\r\n        mapping(uint => Requirements) participatedGroups; // index => globalGroupIndex\r\n        mapping(bytes32 => uint) groupName2index; // groupName => localIndex\r\n        \r\n        uint totalAcceptedLimit;\r\n        uint totalDeclinedLimit;\r\n\r\n        uint securesCount;\r\n        mapping(uint => uint) index2txIndex;\r\n        mapping(uint => uint) txIndex2index;\r\n    }\r\n\r\n    struct Vote {\r\n        bytes32 groupName;\r\n        bool accepted;\r\n    }\r\n\r\n    struct Guard {\r\n        GuardState state;\r\n        uint basePolicyIndex;\r\n\r\n        uint alreadyAccepted;\r\n        uint alreadyDeclined;\r\n        \r\n        mapping(address => Vote) votes; // member address => vote\r\n        mapping(bytes32 => uint) acceptedCount; // groupName => how many from group has already accepted\r\n        mapping(bytes32 => uint) declinedCount; // groupName => how many from group has already declined\r\n    }\r\n\r\n    address public accessManager;\r\n\r\n    mapping(address => bool) public authorized;\r\n\r\n    uint public policiesCount;\r\n    mapping(uint => bytes32) index2PolicyId; // index => policy hash\r\n    mapping(bytes32 => uint) policyId2Index; // policy hash => index\r\n    mapping(bytes32 => Policy) policyId2policy; // policy hash => policy struct\r\n\r\n    uint public txCount;\r\n    mapping(uint => bytes32) index2txKey;\r\n    mapping(bytes32 => uint) txKey2index; // tx key => index\r\n    mapping(bytes32 => Guard) txKey2guard;\r\n\r\n    /// @dev Execution is allowed only by authorized contract\r\n    modifier onlyAuthorized {\r\n        if (authorized[msg.sender] || address(this) == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /// @dev Pending Manager's constructor\r\n    ///\r\n    /// @param _accessManager access manager's address\r\n    function PendingManager(address _accessManager) public {\r\n        require(_accessManager != 0x0);\r\n        accessManager = _accessManager;\r\n    }\r\n\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    /// @notice Update access manager address\r\n    ///\r\n    /// @param _accessManager access manager's address\r\n    function setAccessManager(address _accessManager) external onlyContractOwner returns (uint) {\r\n        require(_accessManager != 0x0);\r\n        accessManager = _accessManager;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Sign in contract\r\n    ///\r\n    /// @param _contract contract's address\r\n    function signIn(address _contract) external onlyContractOwner returns (uint) {\r\n        require(_contract != 0x0);\r\n        authorized[_contract] = true;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Sign out contract\r\n    ///\r\n    /// @param _contract contract's address\r\n    function signOut(address _contract) external onlyContractOwner returns (uint) {\r\n        require(_contract != 0x0);\r\n        delete authorized[_contract];\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Register new policy rule\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _sig target method signature\r\n    /// @param _contract target contract address\r\n    /// @param _groupName group's name\r\n    /// @param _acceptLimit accepted vote limit\r\n    /// @param _declineLimit decline vote limit\r\n    ///\r\n    /// @return code\r\n    function addPolicyRule(\r\n        bytes4 _sig,\r\n        address _contract,\r\n        bytes32 _groupName,\r\n        uint _acceptLimit,\r\n        uint _declineLimit\r\n    )\r\n    onlyContractOwner\r\n    external\r\n    returns (uint)\r\n    {\r\n        require(_sig != 0x0);\r\n        require(_contract != 0x0);\r\n        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\r\n        require(_acceptLimit != 0);\r\n        require(_declineLimit != 0);\r\n\r\n        bytes32 _policyHash = keccak256(_sig, _contract);\r\n        \r\n        if (policyId2Index[_policyHash] == 0) {\r\n            uint _policiesCount = policiesCount.add(1);\r\n            index2PolicyId[_policiesCount] = _policyHash;\r\n            policyId2Index[_policyHash] = _policiesCount;\r\n            policiesCount = _policiesCount;\r\n        }\r\n\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        uint _policyGroupsCount = _policy.groupsCount;\r\n\r\n        if (_policy.groupName2index[_groupName] == 0) {\r\n            _policyGroupsCount += 1;\r\n            _policy.groupName2index[_groupName] = _policyGroupsCount;\r\n            _policy.participatedGroups[_policyGroupsCount].groupName = _groupName;\r\n            _policy.groupsCount = _policyGroupsCount;\r\n        }\r\n\r\n        uint _previousAcceptLimit = _policy.participatedGroups[_policyGroupsCount].acceptLimit;\r\n        uint _previousDeclineLimit = _policy.participatedGroups[_policyGroupsCount].declineLimit;\r\n        _policy.participatedGroups[_policyGroupsCount].acceptLimit = _acceptLimit;\r\n        _policy.participatedGroups[_policyGroupsCount].declineLimit = _declineLimit;\r\n        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_previousAcceptLimit).add(_acceptLimit);\r\n        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_previousDeclineLimit).add(_declineLimit);\r\n\r\n        PolicyRuleAdded(_sig, _contract, _policyHash, _groupName, _acceptLimit, _declineLimit);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Remove policy rule\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _groupName group's name\r\n    ///\r\n    /// @return code\r\n    function removePolicyRule(\r\n        bytes4 _sig,\r\n        address _contract,\r\n        bytes32 _groupName\r\n    ) \r\n    onlyContractOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        require(_sig != bytes4(0));\r\n        require(_contract != 0x0);\r\n        require(GroupsAccessManager(accessManager).isGroupExists(_groupName));\r\n\r\n        bytes32 _policyHash = keccak256(_sig, _contract);\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        uint _policyGroupNameIndex = _policy.groupName2index[_groupName];\r\n\r\n        if (_policyGroupNameIndex == 0) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        uint _policyGroupsCount = _policy.groupsCount;\r\n        if (_policyGroupNameIndex != _policyGroupsCount) {\r\n            Requirements storage _requirements = _policy.participatedGroups[_policyGroupsCount];\r\n            _policy.participatedGroups[_policyGroupNameIndex] = _requirements;\r\n            _policy.groupName2index[_requirements.groupName] = _policyGroupNameIndex;\r\n        }\r\n\r\n        _policy.totalAcceptedLimit = _policy.totalAcceptedLimit.sub(_policy.participatedGroups[_policyGroupsCount].acceptLimit);\r\n        _policy.totalDeclinedLimit = _policy.totalDeclinedLimit.sub(_policy.participatedGroups[_policyGroupsCount].declineLimit);\r\n\r\n        delete _policy.groupName2index[_groupName];\r\n        delete _policy.participatedGroups[_policyGroupsCount];\r\n        _policy.groupsCount = _policyGroupsCount.sub(1);\r\n\r\n        PolicyRuleRemoved(_sig, _contract, _policyHash, _groupName);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Add transaction\r\n    ///\r\n    /// @param _key transaction id\r\n    ///\r\n    /// @return code\r\n    function addTx(bytes32 _key, bytes4 _sig, address _contract) external onlyAuthorized returns (uint) {\r\n        require(_key != bytes32(0));\r\n        require(_sig != bytes4(0));\r\n        require(_contract != 0x0);\r\n\r\n        bytes32 _policyHash = keccak256(_sig, _contract);\r\n        require(isPolicyExist(_policyHash));\r\n\r\n        if (isTxExist(_key)) {\r\n            return _emitError(PENDING_DUPLICATE_TX);\r\n        }\r\n\r\n        if (_policyHash == bytes32(0)) {\r\n            return _emitError(PENDING_MANAGER_POLICY_NOT_FOUND);\r\n        }\r\n\r\n        uint _index = txCount.add(1);\r\n        txCount = _index;\r\n        index2txKey[_index] = _key;\r\n        txKey2index[_key] = _index;\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        _guard.basePolicyIndex = policyId2Index[_policyHash];\r\n        _guard.state = GuardState.InProcess;\r\n\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        uint _counter = _policy.securesCount.add(1);\r\n        _policy.securesCount = _counter;\r\n        _policy.index2txIndex[_counter] = _index;\r\n        _policy.txIndex2index[_index] = _counter;\r\n\r\n        ProtectionTxAdded(_key, _policyHash, block.number);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Delete transaction\r\n    /// @param _key transaction id\r\n    /// @return code\r\n    function deleteTx(bytes32 _key) external onlyContractOwner returns (uint) {\r\n        require(_key != bytes32(0));\r\n\r\n        if (!isTxExist(_key)) {\r\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\r\n        }\r\n\r\n        uint _txsCount = txCount;\r\n        uint _txIndex = txKey2index[_key];\r\n        if (_txIndex != _txsCount) {\r\n            bytes32 _last = index2txKey[txCount];\r\n            index2txKey[_txIndex] = _last;\r\n            txKey2index[_last] = _txIndex;\r\n        }\r\n\r\n        delete txKey2index[_key];\r\n        delete index2txKey[_txsCount];\r\n        txCount = _txsCount.sub(1);\r\n\r\n        uint _basePolicyIndex = txKey2guard[_key].basePolicyIndex;\r\n        Policy storage _policy = policyId2policy[index2PolicyId[_basePolicyIndex]];\r\n        uint _counter = _policy.securesCount;\r\n        uint _policyTxIndex = _policy.txIndex2index[_txIndex];\r\n        if (_policyTxIndex != _counter) {\r\n            uint _movedTxIndex = _policy.index2txIndex[_counter];\r\n            _policy.index2txIndex[_policyTxIndex] = _movedTxIndex;\r\n            _policy.txIndex2index[_movedTxIndex] = _policyTxIndex;\r\n        }\r\n\r\n        delete _policy.index2txIndex[_counter];\r\n        delete _policy.txIndex2index[_txIndex];\r\n        _policy.securesCount = _counter.sub(1);\r\n\r\n        TxDeleted(_key);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Accept transaction\r\n    /// Can be called only by registered user in GroupsAccessManager\r\n    ///\r\n    /// @param _key transaction id\r\n    ///\r\n    /// @return code\r\n    function accept(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\r\n        if (!isTxExist(_key)) {\r\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\r\n        }\r\n\r\n        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        if (_guard.state != GuardState.InProcess) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        if (_guard.votes[msg.sender].groupName != bytes32(0) && _guard.votes[msg.sender].accepted) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\r\n        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\r\n        uint _groupAcceptedVotesCount = _guard.acceptedCount[_votingGroupName];\r\n        if (_groupAcceptedVotesCount == _policy.participatedGroups[_policyGroupIndex].acceptLimit) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        _guard.votes[msg.sender] = Vote(_votingGroupName, true);\r\n        _guard.acceptedCount[_votingGroupName] = _groupAcceptedVotesCount + 1;\r\n        uint _alreadyAcceptedCount = _guard.alreadyAccepted + 1;\r\n        _guard.alreadyAccepted = _alreadyAcceptedCount;\r\n\r\n        ProtectionTxAccepted(_key, msg.sender, _votingGroupName);\r\n\r\n        if (_alreadyAcceptedCount == _policy.totalAcceptedLimit) {\r\n            _guard.state = GuardState.Confirmed;\r\n            ProtectionTxDone(_key);\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Decline transaction\r\n    /// Can be called only by registered user in GroupsAccessManager\r\n    ///\r\n    /// @param _key transaction id\r\n    ///\r\n    /// @return code\r\n    function decline(bytes32 _key, bytes32 _votingGroupName) external returns (uint) {\r\n        if (!isTxExist(_key)) {\r\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\r\n        }\r\n\r\n        if (!GroupsAccessManager(accessManager).isUserInGroup(_votingGroupName, msg.sender)) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        if (_guard.state != GuardState.InProcess) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        if (_guard.votes[msg.sender].groupName != bytes32(0) && !_guard.votes[msg.sender].accepted) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        Policy storage _policy = policyId2policy[index2PolicyId[_guard.basePolicyIndex]];\r\n        uint _policyGroupIndex = _policy.groupName2index[_votingGroupName];\r\n        uint _groupDeclinedVotesCount = _guard.declinedCount[_votingGroupName];\r\n        if (_groupDeclinedVotesCount == _policy.participatedGroups[_policyGroupIndex].declineLimit) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        _guard.votes[msg.sender] = Vote(_votingGroupName, false);\r\n        _guard.declinedCount[_votingGroupName] = _groupDeclinedVotesCount + 1;\r\n        uint _alreadyDeclinedCount = _guard.alreadyDeclined + 1;\r\n        _guard.alreadyDeclined = _alreadyDeclinedCount;\r\n\r\n\r\n        ProtectionTxDeclined(_key, msg.sender, _votingGroupName);\r\n\r\n        if (_alreadyDeclinedCount == _policy.totalDeclinedLimit) {\r\n            _guard.state = GuardState.Decline;\r\n            ProtectionTxCancelled(_key);\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Revoke user votes for transaction\r\n    /// Can be called only by contract owner\r\n    ///\r\n    /// @param _key transaction id\r\n    /// @param _user target user address\r\n    ///\r\n    /// @return code\r\n    function forceRejectVotes(bytes32 _key, address _user) external onlyContractOwner returns (uint) {\r\n        return _revoke(_key, _user);\r\n    }\r\n\r\n    /// @notice Revoke vote for transaction\r\n    /// Can be called only by authorized user\r\n    /// @param _key transaction id\r\n    /// @return code\r\n    function revoke(bytes32 _key) external returns (uint) {\r\n        return _revoke(_key, msg.sender);\r\n    }\r\n\r\n    /// @notice Check transaction status\r\n    /// @param _key transaction id\r\n    /// @return code\r\n    function hasConfirmedRecord(bytes32 _key) public view returns (uint) {\r\n        require(_key != bytes32(0));\r\n\r\n        if (!isTxExist(_key)) {\r\n            return NO_RECORDS_WERE_FOUND;\r\n        }\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        return _guard.state == GuardState.InProcess\r\n        ? PENDING_MANAGER_IN_PROCESS\r\n        : _guard.state == GuardState.Confirmed\r\n        ? OK\r\n        : PENDING_MANAGER_REJECTED;\r\n    }\r\n\r\n\r\n    /// @notice Check policy details\r\n    ///\r\n    /// @return _groupNames group names included in policies\r\n    /// @return _acceptLimits accept limit for group\r\n    /// @return _declineLimits decline limit for group\r\n    function getPolicyDetails(bytes4 _sig, address _contract)\r\n    public\r\n    view\r\n    returns (\r\n        bytes32[] _groupNames,\r\n        uint[] _acceptLimits,\r\n        uint[] _declineLimits,\r\n        uint _totalAcceptedLimit,\r\n        uint _totalDeclinedLimit\r\n    ) {\r\n        require(_sig != bytes4(0));\r\n        require(_contract != 0x0);\r\n        \r\n        bytes32 _policyHash = keccak256(_sig, _contract);\r\n        uint _policyIdx = policyId2Index[_policyHash];\r\n        if (_policyIdx == 0) {\r\n            return;\r\n        }\r\n\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        uint _policyGroupsCount = _policy.groupsCount;\r\n        _groupNames = new bytes32[](_policyGroupsCount);\r\n        _acceptLimits = new uint[](_policyGroupsCount);\r\n        _declineLimits = new uint[](_policyGroupsCount);\r\n\r\n        for (uint _idx = 0; _idx < _policyGroupsCount; ++_idx) {\r\n            Requirements storage _requirements = _policy.participatedGroups[_idx + 1];\r\n            _groupNames[_idx] = _requirements.groupName;\r\n            _acceptLimits[_idx] = _requirements.acceptLimit;\r\n            _declineLimits[_idx] = _requirements.declineLimit;\r\n        }\r\n\r\n        (_totalAcceptedLimit, _totalDeclinedLimit) = (_policy.totalAcceptedLimit, _policy.totalDeclinedLimit);\r\n    }\r\n\r\n    /// @notice Check policy include target group\r\n    /// @param _policyHash policy hash (sig, contract address)\r\n    /// @param _groupName group id\r\n    /// @return bool\r\n    function isGroupInPolicy(bytes32 _policyHash, bytes32 _groupName) public view returns (bool) {\r\n        Policy storage _policy = policyId2policy[_policyHash];\r\n        return _policy.groupName2index[_groupName] != 0;\r\n    }\r\n\r\n    /// @notice Check is policy exist\r\n    /// @param _policyHash policy hash (sig, contract address)\r\n    /// @return bool\r\n    function isPolicyExist(bytes32 _policyHash) public view returns (bool) {\r\n        return policyId2Index[_policyHash] != 0;\r\n    }\r\n\r\n    /// @notice Check is transaction exist\r\n    /// @param _key transaction id\r\n    /// @return bool\r\n    function isTxExist(bytes32 _key) public view returns (bool){\r\n        return txKey2index[_key] != 0;\r\n    }\r\n\r\n    function _updateTxState(Policy storage _policy, Guard storage _guard, uint confirmedAmount, uint declineAmount) private {\r\n        if (declineAmount != 0 && _guard.state != GuardState.Decline) {\r\n            _guard.state = GuardState.Decline;\r\n        } else if (confirmedAmount >= _policy.groupsCount && _guard.state != GuardState.Confirmed) {\r\n            _guard.state = GuardState.Confirmed;\r\n        } else if (_guard.state != GuardState.InProcess) {\r\n            _guard.state = GuardState.InProcess;\r\n        }\r\n    }\r\n\r\n    function _revoke(bytes32 _key, address _user) private returns (uint) {\r\n        require(_key != bytes32(0));\r\n        require(_user != 0x0);\r\n\r\n        if (!isTxExist(_key)) {\r\n            return _emitError(PENDING_MANAGER_TX_DOESNT_EXIST);\r\n        }\r\n\r\n        Guard storage _guard = txKey2guard[_key];\r\n        if (_guard.state != GuardState.InProcess) {\r\n            return _emitError(PENDING_MANAGER_INVALID_INVOCATION);\r\n        }\r\n\r\n        bytes32 _votedGroupName = _guard.votes[_user].groupName;\r\n        if (_votedGroupName == bytes32(0)) {\r\n            return _emitError(PENDING_MANAGER_HASNT_VOTED);\r\n        }\r\n\r\n        bool isAcceptedVote = _guard.votes[_user].accepted;\r\n        if (isAcceptedVote) {\r\n            _guard.acceptedCount[_votedGroupName] = _guard.acceptedCount[_votedGroupName].sub(1);\r\n            _guard.alreadyAccepted = _guard.alreadyAccepted.sub(1);\r\n        } else {\r\n            _guard.declinedCount[_votedGroupName] = _guard.declinedCount[_votedGroupName].sub(1);\r\n            _guard.alreadyDeclined = _guard.alreadyDeclined.sub(1);\r\n\r\n        }\r\n\r\n        delete _guard.votes[_user];\r\n\r\n        ProtectionTxVoteRevoked(_key, _user, _votedGroupName);\r\n        return OK;\r\n    }\r\n}\r\n\r\n/// @title MultiSigAdapter\r\n///\r\n/// Abstract implementation\r\n/// This contract serves as transaction signer\r\ncontract MultiSigAdapter is Object {\r\n\r\n    uint constant MULTISIG_ADDED = 3;\r\n    uint constant NO_RECORDS_WERE_FOUND = 4;\r\n\r\n    modifier isAuthorized {\r\n        if (msg.sender == contractOwner || msg.sender == getPendingManager()) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /// @notice Get pending address\r\n    /// @dev abstract. Needs child implementation\r\n    ///\r\n    /// @return pending address\r\n    function getPendingManager() public view returns (address);\r\n\r\n    /// @notice Sign current transaction and add it to transaction pending queue\r\n    ///\r\n    /// @return code\r\n    function _multisig(bytes32 _args, uint _block) internal returns (uint _code) {\r\n        bytes32 _txHash = _getKey(_args, _block);\r\n        address _manager = getPendingManager();\r\n\r\n        _code = PendingManager(_manager).hasConfirmedRecord(_txHash);\r\n        if (_code != NO_RECORDS_WERE_FOUND) {\r\n            return _code;\r\n        }\r\n\r\n        if (OK != PendingManager(_manager).addTx(_txHash, msg.sig, address(this))) {\r\n            revert();\r\n        }\r\n\r\n        return MULTISIG_ADDED;\r\n    }\r\n\r\n    function _isTxExistWithArgs(bytes32 _args, uint _block) internal view returns (bool) {\r\n        bytes32 _txHash = _getKey(_args, _block);\r\n        address _manager = getPendingManager();\r\n        return PendingManager(_manager).isTxExist(_txHash);\r\n    }\r\n\r\n    function _getKey(bytes32 _args, uint _block) private view returns (bytes32 _txHash) {\r\n        _block = _block != 0 ? _block : block.number;\r\n        _txHash = keccak256(msg.sig, _args, _block);\r\n    }\r\n}\r\n\r\n/// @title ServiceController\r\n///\r\n/// Base implementation\r\n/// Serves for managing service instances\r\ncontract ServiceController is MultiSigAdapter {\r\n\r\n    event Error(uint _errorCode);\r\n\r\n    uint constant SERVICE_CONTROLLER = 350000;\r\n    uint constant SERVICE_CONTROLLER_EMISSION_EXIST = SERVICE_CONTROLLER + 1;\r\n    uint constant SERVICE_CONTROLLER_BURNING_MAN_EXIST = SERVICE_CONTROLLER + 2;\r\n    uint constant SERVICE_CONTROLLER_ALREADY_INITIALIZED = SERVICE_CONTROLLER + 3;\r\n    uint constant SERVICE_CONTROLLER_SERVICE_EXIST = SERVICE_CONTROLLER + 4;\r\n\r\n    address public profiterole;\r\n    address public treasury;\r\n    address public pendingManager;\r\n    address public proxy;\r\n\r\n    uint public sideServicesCount;\r\n    mapping(uint => address) public index2sideService;\r\n    mapping(address => uint) public sideService2index;\r\n    mapping(address => bool) public sideServices;\r\n\r\n    uint public emissionProvidersCount;\r\n    mapping(uint => address) public index2emissionProvider;\r\n    mapping(address => uint) public emissionProvider2index;\r\n    mapping(address => bool) public emissionProviders;\r\n\r\n    uint public burningMansCount;\r\n    mapping(uint => address) public index2burningMan;\r\n    mapping(address => uint) public burningMan2index;\r\n    mapping(address => bool) public burningMans;\r\n\r\n    /// @notice Default ServiceController's constructor\r\n    ///\r\n    /// @param _pendingManager pending manager address\r\n    /// @param _proxy ERC20 proxy address\r\n    /// @param _profiterole profiterole address\r\n    /// @param _treasury treasury address\r\n    function ServiceController(address _pendingManager, address _proxy, address _profiterole, address _treasury) public {\r\n        require(_pendingManager != 0x0);\r\n        require(_proxy != 0x0);\r\n        require(_profiterole != 0x0);\r\n        require(_treasury != 0x0);\r\n        pendingManager = _pendingManager;\r\n        proxy = _proxy;\r\n        profiterole = _profiterole;\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /// @notice Return pending manager address\r\n    ///\r\n    /// @return code\r\n    function getPendingManager() public view returns (address) {\r\n        return pendingManager;\r\n    }\r\n\r\n    /// @notice Add emission provider\r\n    ///\r\n    /// @param _provider emission provider address\r\n    ///\r\n    /// @return code\r\n    function addEmissionProvider(address _provider, uint _block) public returns (uint _code) {\r\n        if (emissionProviders[_provider]) {\r\n            return _emitError(SERVICE_CONTROLLER_EMISSION_EXIST);\r\n        }\r\n        _code = _multisig(keccak256(_provider), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        emissionProviders[_provider] = true;\r\n        uint _count = emissionProvidersCount + 1;\r\n        index2emissionProvider[_count] = _provider;\r\n        emissionProvider2index[_provider] = _count;\r\n        emissionProvidersCount = _count;\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Remove emission provider\r\n    ///\r\n    /// @param _provider emission provider address\r\n    ///\r\n    /// @return code\r\n    function removeEmissionProvider(address _provider, uint _block) public returns (uint _code) {\r\n        _code = _multisig(keccak256(_provider), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        uint _idx = emissionProvider2index[_provider];\r\n        uint _lastIdx = emissionProvidersCount;\r\n        if (_idx != 0) {\r\n            if (_idx != _lastIdx) {\r\n                address _lastEmissionProvider = index2emissionProvider[_lastIdx];\r\n                index2emissionProvider[_idx] = _lastEmissionProvider;\r\n                emissionProvider2index[_lastEmissionProvider] = _idx;\r\n            }\r\n\r\n            delete emissionProvider2index[_provider];\r\n            delete index2emissionProvider[_lastIdx];\r\n            delete emissionProviders[_provider];\r\n            emissionProvidersCount = _lastIdx - 1;\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Add burning man\r\n    ///\r\n    /// @param _burningMan burning man address\r\n    ///\r\n    /// @return code\r\n    function addBurningMan(address _burningMan, uint _block) public returns (uint _code) {\r\n        if (burningMans[_burningMan]) {\r\n            return _emitError(SERVICE_CONTROLLER_BURNING_MAN_EXIST);\r\n        }\r\n\r\n        _code = _multisig(keccak256(_burningMan), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        burningMans[_burningMan] = true;\r\n        uint _count = burningMansCount + 1;\r\n        index2burningMan[_count] = _burningMan;\r\n        burningMan2index[_burningMan] = _count;\r\n        burningMansCount = _count;\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Remove burning man\r\n    ///\r\n    /// @param _burningMan burning man address\r\n    ///\r\n    /// @return code\r\n    function removeBurningMan(address _burningMan, uint _block) public returns (uint _code) {\r\n        _code = _multisig(keccak256(_burningMan), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        uint _idx = burningMan2index[_burningMan];\r\n        uint _lastIdx = burningMansCount;\r\n        if (_idx != 0) {\r\n            if (_idx != _lastIdx) {\r\n                address _lastBurningMan = index2burningMan[_lastIdx];\r\n                index2burningMan[_idx] = _lastBurningMan;\r\n                burningMan2index[_lastBurningMan] = _idx;\r\n            }\r\n            \r\n            delete burningMan2index[_burningMan];\r\n            delete index2burningMan[_lastIdx];\r\n            delete burningMans[_burningMan];\r\n            burningMansCount = _lastIdx - 1;\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Update a profiterole address\r\n    ///\r\n    /// @param _profiterole profiterole address\r\n    ///\r\n    /// @return result code of an operation\r\n    function updateProfiterole(address _profiterole, uint _block) public returns (uint _code) {\r\n        _code = _multisig(keccak256(_profiterole), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        profiterole = _profiterole;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Update a treasury address\r\n    ///\r\n    /// @param _treasury treasury address\r\n    ///\r\n    /// @return result code of an operation\r\n    function updateTreasury(address _treasury, uint _block) public returns (uint _code) {\r\n        _code = _multisig(keccak256(_treasury), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        treasury = _treasury;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Update pending manager address\r\n    ///\r\n    /// @param _pendingManager pending manager address\r\n    ///\r\n    /// @return result code of an operation\r\n    function updatePendingManager(address _pendingManager, uint _block) public returns (uint _code) {\r\n        _code = _multisig(keccak256(_pendingManager), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        pendingManager = _pendingManager;\r\n        return OK;\r\n    }\r\n\r\n    function addSideService(address _service, uint _block) public returns (uint _code) {\r\n        if (sideServices[_service]) {\r\n            return SERVICE_CONTROLLER_SERVICE_EXIST;\r\n        }\r\n        _code = _multisig(keccak256(_service), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        sideServices[_service] = true;\r\n        uint _count = sideServicesCount + 1;\r\n        index2sideService[_count] = _service;\r\n        sideService2index[_service] = _count;\r\n        sideServicesCount = _count;\r\n\r\n        return OK;\r\n    }\r\n\r\n    function removeSideService(address _service, uint _block) public returns (uint _code) {\r\n        _code = _multisig(keccak256(_service), _block);\r\n        if (OK != _code) {\r\n            return _code;\r\n        }\r\n\r\n        uint _idx = sideService2index[_service];\r\n        uint _lastIdx = sideServicesCount;\r\n        if (_idx != 0) {\r\n            if (_idx != _lastIdx) {\r\n                address _lastSideService = index2sideService[_lastIdx];\r\n                index2sideService[_idx] = _lastSideService;\r\n                sideService2index[_lastSideService] = _idx;\r\n            }\r\n            \r\n            delete sideService2index[_service];\r\n            delete index2sideService[_lastIdx];\r\n            delete sideServices[_service];\r\n            sideServicesCount = _lastIdx - 1;\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    function getEmissionProviders()\r\n    public\r\n    view\r\n    returns (address[] _emissionProviders)\r\n    {\r\n        _emissionProviders = new address[](emissionProvidersCount);\r\n        for (uint _idx = 0; _idx < _emissionProviders.length; ++_idx) {\r\n            _emissionProviders[_idx] = index2emissionProvider[_idx + 1];\r\n        }\r\n    }\r\n\r\n    function getBurningMans()\r\n    public\r\n    view\r\n    returns (address[] _burningMans)\r\n    {\r\n        _burningMans = new address[](burningMansCount);\r\n        for (uint _idx = 0; _idx < _burningMans.length; ++_idx) {\r\n            _burningMans[_idx] = index2burningMan[_idx + 1];\r\n        }\r\n    }\r\n\r\n    function getSideServices()\r\n    public\r\n    view\r\n    returns (address[] _sideServices)\r\n    {\r\n        _sideServices = new address[](sideServicesCount);\r\n        for (uint _idx = 0; _idx < _sideServices.length; ++_idx) {\r\n            _sideServices[_idx] = index2sideService[_idx + 1];\r\n        }\r\n    }\r\n\r\n    /// @notice Check target address is service\r\n    ///\r\n    /// @param _address target address\r\n    ///\r\n    /// @return `true` when an address is a service, `false` otherwise\r\n    function isService(address _address) public view returns (bool check) {\r\n        return _address == profiterole ||\r\n            _address == treasury || \r\n            _address == proxy || \r\n            _address == pendingManager || \r\n            emissionProviders[_address] || \r\n            burningMans[_address] ||\r\n            sideServices[_address];\r\n    }\r\n\r\n    function _emitError(uint _errorCode) internal returns (uint) {\r\n        Error(_errorCode);\r\n        return _errorCode;\r\n    }\r\n}\r\n\r\n/// @title Provides possibility manage holders? country limits and limits for holders.\r\ncontract DataController is OracleMethodAdapter, DataControllerEmitter {\r\n\r\n    /* CONSTANTS */\r\n\r\n    uint constant DATA_CONTROLLER = 109000;\r\n    uint constant DATA_CONTROLLER_ERROR = DATA_CONTROLLER + 1;\r\n    uint constant DATA_CONTROLLER_CURRENT_WRONG_LIMIT = DATA_CONTROLLER + 2;\r\n    uint constant DATA_CONTROLLER_WRONG_ALLOWANCE = DATA_CONTROLLER + 3;\r\n    uint constant DATA_CONTROLLER_COUNTRY_CODE_ALREADY_EXISTS = DATA_CONTROLLER + 4;\r\n\r\n    uint constant MAX_TOKEN_HOLDER_NUMBER = 2 ** 256 - 1;\r\n\r\n    using SafeMath for uint;\r\n\r\n    /* STRUCTS */\r\n\r\n    /// @title HoldersData couldn't be public because of internal structures, so needed to provide getters for different parts of _holderData\r\n    struct HoldersData {\r\n        uint countryCode;\r\n        uint sendLimPerDay;\r\n        uint sendLimPerMonth;\r\n        bool operational;\r\n        bytes text;\r\n        uint holderAddressCount;\r\n        mapping(uint => address) index2Address;\r\n        mapping(address => uint) address2Index;\r\n    }\r\n\r\n    struct CountryLimits {\r\n        uint countryCode;\r\n        uint maxTokenHolderNumber;\r\n        uint currentTokenHolderNumber;\r\n    }\r\n\r\n    /* FIELDS */\r\n\r\n    address public withdrawal;\r\n    address assetAddress;\r\n    address public serviceController;\r\n\r\n    mapping(address => uint) public allowance;\r\n\r\n    // Iterable mapping pattern is used for holders.\r\n    /// @dev This is an access address mapping. Many addresses may have access to a single holder.\r\n    uint public holdersCount;\r\n    mapping(uint => HoldersData) holders;\r\n    mapping(address => bytes32) holderAddress2Id;\r\n    mapping(bytes32 => uint) public holderIndex;\r\n\r\n    // This is an access address mapping. Many addresses may have access to a single holder.\r\n    uint public countriesCount;\r\n    mapping(uint => CountryLimits) countryLimitsList;\r\n    mapping(uint => uint) countryIndex;\r\n\r\n    /* MODIFIERS */\r\n\r\n    modifier onlyWithdrawal {\r\n        if (msg.sender != withdrawal) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyAsset {\r\n        if (msg.sender == _getATxToken().getLatestVersion()) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyContractOwner {\r\n        if (msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /// @notice Constructor for _holderData controller.\r\n    /// @param _serviceController service controller\r\n    function DataController(address _serviceController) public {\r\n        require(_serviceController != 0x0);\r\n\r\n        serviceController = _serviceController;\r\n    }\r\n\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    function setWithdraw(address _withdrawal) onlyContractOwner external returns (uint) {\r\n        require(_withdrawal != 0x0);\r\n        withdrawal = _withdrawal;\r\n        return OK;\r\n    }\r\n\r\n    function setServiceController(address _serviceController) \r\n    onlyContractOwner\r\n    external\r\n    returns (uint)\r\n    {\r\n        require(_serviceController != 0x0);\r\n        \r\n        serviceController = _serviceController;\r\n        return OK;\r\n    }\r\n\r\n\r\n    function getPendingManager() public view returns (address) {\r\n        return ServiceController(serviceController).getPendingManager();\r\n    }\r\n\r\n    function getHolderInfo(bytes32 _externalHolderId) public view returns (\r\n        uint _countryCode,\r\n        uint _limPerDay,\r\n        uint _limPerMonth,\r\n        bool _operational,\r\n        bytes _text\r\n    ) {\r\n        HoldersData storage _data = holders[holderIndex[_externalHolderId]];\r\n        return (_data.countryCode, _data.sendLimPerDay, _data.sendLimPerMonth, _data.operational, _data.text);\r\n    }\r\n\r\n    function getHolderAddresses(bytes32 _externalHolderId) public view returns (address[] _addresses) {\r\n        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\r\n        uint _addressesCount = _holderData.holderAddressCount;\r\n        _addresses = new address[](_addressesCount);\r\n        for (uint _holderAddressIdx = 0; _holderAddressIdx < _addressesCount; ++_holderAddressIdx) {\r\n            _addresses[_holderAddressIdx] = _holderData.index2Address[_holderAddressIdx + 1];\r\n        }\r\n    }\r\n\r\n    function getHolderCountryCode(bytes32 _externalHolderId) public view returns (uint) {\r\n        return holders[holderIndex[_externalHolderId]].countryCode;\r\n    }\r\n\r\n    function getHolderExternalIdByAddress(address _address) public view returns (bytes32) {\r\n        return holderAddress2Id[_address];\r\n    }\r\n\r\n    /// @notice Checks user is holder.\r\n    /// @param _address checking address.\r\n    /// @return `true` if _address is registered holder, `false` otherwise.\r\n    function isRegisteredAddress(address _address) public view returns (bool) {\r\n        return holderIndex[holderAddress2Id[_address]] != 0;\r\n    }\r\n\r\n    function isHolderOwnAddress(\r\n        bytes32 _externalHolderId, \r\n        address _address\r\n    ) \r\n    public \r\n    view \r\n    returns (bool) \r\n    {\r\n        uint _holderIndex = holderIndex[_externalHolderId];\r\n        if (_holderIndex == 0) {\r\n            return false;\r\n        }\r\n        return holders[_holderIndex].address2Index[_address] != 0;\r\n    }\r\n\r\n    function getCountryInfo(uint _countryCode) \r\n    public \r\n    view \r\n    returns (\r\n        uint _maxHolderNumber, \r\n        uint _currentHolderCount\r\n    ) {\r\n        CountryLimits storage _data = countryLimitsList[countryIndex[_countryCode]];\r\n        return (_data.maxTokenHolderNumber, _data.currentTokenHolderNumber);\r\n    }\r\n\r\n    function getCountryLimit(uint _countryCode) public view returns (uint limit) {\r\n        uint _index = countryIndex[_countryCode];\r\n        require(_index != 0);\r\n        return countryLimitsList[_index].maxTokenHolderNumber;\r\n    }\r\n\r\n    function addCountryCode(uint _countryCode) onlyContractOwner public returns (uint) {\r\n        var (,_created) = _createCountryId(_countryCode);\r\n        if (!_created) {\r\n            return _emitError(DATA_CONTROLLER_COUNTRY_CODE_ALREADY_EXISTS);\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Returns holder id for the specified address, creates it if needed.\r\n    /// @param _externalHolderId holder address.\r\n    /// @param _countryCode country code.\r\n    /// @return error code.\r\n    function registerHolder(\r\n        bytes32 _externalHolderId, \r\n        address _holderAddress, \r\n        uint _countryCode\r\n    ) \r\n    onlyOracleOrOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        require(_holderAddress != 0x0);\r\n        require(holderIndex[_externalHolderId] == 0);\r\n        uint _holderIndex = holderIndex[holderAddress2Id[_holderAddress]];\r\n        require(_holderIndex == 0);\r\n\r\n        _createCountryId(_countryCode);\r\n        _holderIndex = holdersCount.add(1);\r\n        holdersCount = _holderIndex;\r\n\r\n        HoldersData storage _holderData = holders[_holderIndex];\r\n        _holderData.countryCode = _countryCode;\r\n        _holderData.operational = true;\r\n        _holderData.sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER;\r\n        _holderData.sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER;\r\n        uint _firstAddressIndex = 1;\r\n        _holderData.holderAddressCount = _firstAddressIndex;\r\n        _holderData.address2Index[_holderAddress] = _firstAddressIndex;\r\n        _holderData.index2Address[_firstAddressIndex] = _holderAddress;\r\n        holderIndex[_externalHolderId] = _holderIndex;\r\n        holderAddress2Id[_holderAddress] = _externalHolderId;\r\n\r\n        _emitHolderRegistered(_externalHolderId, _holderIndex, _countryCode);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Adds new address equivalent to holder.\r\n    /// @param _externalHolderId external holder identifier.\r\n    /// @param _newAddress adding address.\r\n    /// @return error code.\r\n    function addHolderAddress(\r\n        bytes32 _externalHolderId, \r\n        address _newAddress\r\n    ) \r\n    onlyOracleOrOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        uint _holderIndex = holderIndex[_externalHolderId];\r\n        require(_holderIndex != 0);\r\n\r\n        uint _newAddressId = holderIndex[holderAddress2Id[_newAddress]];\r\n        require(_newAddressId == 0);\r\n\r\n        HoldersData storage _holderData = holders[_holderIndex];\r\n\r\n        if (_holderData.address2Index[_newAddress] == 0) {\r\n            _holderData.holderAddressCount = _holderData.holderAddressCount.add(1);\r\n            _holderData.address2Index[_newAddress] = _holderData.holderAddressCount;\r\n            _holderData.index2Address[_holderData.holderAddressCount] = _newAddress;\r\n        }\r\n\r\n        holderAddress2Id[_newAddress] = _externalHolderId;\r\n\r\n        _emitHolderAddressAdded(_externalHolderId, _newAddress, _holderIndex);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Remove an address owned by a holder.\r\n    /// @param _externalHolderId external holder identifier.\r\n    /// @param _address removing address.\r\n    /// @return error code.\r\n    function removeHolderAddress(\r\n        bytes32 _externalHolderId, \r\n        address _address\r\n    ) \r\n    onlyOracleOrOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        uint _holderIndex = holderIndex[_externalHolderId];\r\n        require(_holderIndex != 0);\r\n\r\n        HoldersData storage _holderData = holders[_holderIndex];\r\n\r\n        uint _tempIndex = _holderData.address2Index[_address];\r\n        require(_tempIndex != 0);\r\n\r\n        address _lastAddress = _holderData.index2Address[_holderData.holderAddressCount];\r\n        _holderData.address2Index[_lastAddress] = _tempIndex;\r\n        _holderData.index2Address[_tempIndex] = _lastAddress;\r\n        delete _holderData.address2Index[_address];\r\n        _holderData.holderAddressCount = _holderData.holderAddressCount.sub(1);\r\n\r\n        delete holderAddress2Id[_address];\r\n\r\n        _emitHolderAddressRemoved(_externalHolderId, _address, _holderIndex);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Change operational status for holder.\r\n    /// Can be accessed by contract owner or oracle only.\r\n    ///\r\n    /// @param _externalHolderId external holder identifier.\r\n    /// @param _operational operational status.\r\n    ///\r\n    /// @return result code.\r\n    function changeOperational(\r\n        bytes32 _externalHolderId, \r\n        bool _operational\r\n    ) \r\n    onlyOracleOrOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        uint _holderIndex = holderIndex[_externalHolderId];\r\n        require(_holderIndex != 0);\r\n\r\n        holders[_holderIndex].operational = _operational;\r\n\r\n        _emitHolderOperationalChanged(_externalHolderId, _operational);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Changes text for holder.\r\n    /// Can be accessed by contract owner or oracle only.\r\n    ///\r\n    /// @param _externalHolderId external holder identifier.\r\n    /// @param _text changing text.\r\n    ///\r\n    /// @return result code.\r\n    function updateTextForHolder(\r\n        bytes32 _externalHolderId, \r\n        bytes _text\r\n    ) \r\n    onlyOracleOrOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        uint _holderIndex = holderIndex[_externalHolderId];\r\n        require(_holderIndex != 0);\r\n\r\n        holders[_holderIndex].text = _text;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Updates limit per day for holder.\r\n    ///\r\n    /// Can be accessed by contract owner only.\r\n    ///\r\n    /// @param _externalHolderId external holder identifier.\r\n    /// @param _limit limit value.\r\n    ///\r\n    /// @return result code.\r\n    function updateLimitPerDay(\r\n        bytes32 _externalHolderId, \r\n        uint _limit\r\n    ) \r\n    onlyOracleOrOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        uint _holderIndex = holderIndex[_externalHolderId];\r\n        require(_holderIndex != 0);\r\n\r\n        uint _currentLimit = holders[_holderIndex].sendLimPerDay;\r\n        holders[_holderIndex].sendLimPerDay = _limit;\r\n\r\n        _emitDayLimitChanged(_externalHolderId, _currentLimit, _limit);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Updates limit per month for holder.\r\n    /// Can be accessed by contract owner or oracle only.\r\n    ///\r\n    /// @param _externalHolderId external holder identifier.\r\n    /// @param _limit limit value.\r\n    ///\r\n    /// @return result code.\r\n    function updateLimitPerMonth(\r\n        bytes32 _externalHolderId, \r\n        uint _limit\r\n    ) \r\n    onlyOracleOrOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        uint _holderIndex = holderIndex[_externalHolderId];\r\n        require(_holderIndex != 0);\r\n\r\n        uint _currentLimit = holders[_holderIndex].sendLimPerDay;\r\n        holders[_holderIndex].sendLimPerMonth = _limit;\r\n\r\n        _emitMonthLimitChanged(_externalHolderId, _currentLimit, _limit);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Change country limits.\r\n    /// Can be accessed by contract owner or oracle only.\r\n    ///\r\n    /// @param _countryCode country code.\r\n    /// @param _limit limit value.\r\n    ///\r\n    /// @return result code.\r\n    function changeCountryLimit(\r\n        uint _countryCode, \r\n        uint _limit\r\n    ) \r\n    onlyOracleOrOwner \r\n    external \r\n    returns (uint) \r\n    {\r\n        uint _countryIndex = countryIndex[_countryCode];\r\n        require(_countryIndex != 0);\r\n\r\n        uint _currentTokenHolderNumber = countryLimitsList[_countryIndex].currentTokenHolderNumber;\r\n        if (_currentTokenHolderNumber > _limit) {\r\n            return _emitError(DATA_CONTROLLER_CURRENT_WRONG_LIMIT);\r\n        }\r\n\r\n        countryLimitsList[_countryIndex].maxTokenHolderNumber = _limit;\r\n        \r\n        _emitCountryCodeChanged(_countryIndex, _countryCode, _limit);\r\n        return OK;\r\n    }\r\n\r\n    function withdrawFrom(\r\n        address _holderAddress, \r\n        uint _value\r\n    ) \r\n    onlyAsset \r\n    public \r\n    returns (uint) \r\n    {\r\n        bytes32 _externalHolderId = holderAddress2Id[_holderAddress];\r\n        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\r\n        _holderData.sendLimPerDay = _holderData.sendLimPerDay.sub(_value);\r\n        _holderData.sendLimPerMonth = _holderData.sendLimPerMonth.sub(_value);\r\n        return OK;\r\n    }\r\n\r\n    function depositTo(\r\n        address _holderAddress, \r\n        uint _value\r\n    ) \r\n    onlyAsset \r\n    public \r\n    returns (uint) \r\n    {\r\n        bytes32 _externalHolderId = holderAddress2Id[_holderAddress];\r\n        HoldersData storage _holderData = holders[holderIndex[_externalHolderId]];\r\n        _holderData.sendLimPerDay = _holderData.sendLimPerDay.add(_value);\r\n        _holderData.sendLimPerMonth = _holderData.sendLimPerMonth.add(_value);\r\n        return OK;\r\n    }\r\n\r\n    function updateCountryHoldersCount(\r\n        uint _countryCode, \r\n        uint _updatedHolderCount\r\n    ) \r\n    public \r\n    onlyAsset \r\n    returns (uint) \r\n    {\r\n        CountryLimits storage _data = countryLimitsList[countryIndex[_countryCode]];\r\n        assert(_data.maxTokenHolderNumber >= _updatedHolderCount);\r\n        _data.currentTokenHolderNumber = _updatedHolderCount;\r\n        return OK;\r\n    }\r\n\r\n    function changeAllowance(address _from, uint _value) public onlyWithdrawal returns (uint) {\r\n        ATxAssetProxy token = _getATxToken();\r\n        if (token.balanceOf(_from) < _value) {\r\n            return _emitError(DATA_CONTROLLER_WRONG_ALLOWANCE);\r\n        }\r\n        allowance[_from] = _value;\r\n        return OK;\r\n    }\r\n\r\n    function _createCountryId(uint _countryCode) internal returns (uint, bool _created) {\r\n        uint countryId = countryIndex[_countryCode];\r\n        if (countryId == 0) {\r\n            uint _countriesCount = countriesCount;\r\n            countryId = _countriesCount.add(1);\r\n            countriesCount = countryId;\r\n            CountryLimits storage limits = countryLimitsList[countryId];\r\n            limits.countryCode = _countryCode;\r\n            limits.maxTokenHolderNumber = MAX_TOKEN_HOLDER_NUMBER;\r\n\r\n            countryIndex[_countryCode] = countryId;\r\n            _emitCountryCodeAdded(countryIndex[_countryCode], _countryCode, MAX_TOKEN_HOLDER_NUMBER);\r\n\r\n            _created = true;\r\n        }\r\n\r\n        return (countryId, _created);\r\n    }\r\n\r\n    function _getATxToken() private view returns (ATxAssetProxy) {\r\n        ServiceController _serviceController = ServiceController(serviceController);\r\n        return ATxAssetProxy(_serviceController.proxy());\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getPendingManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signatures\",\"type\":\"bytes4[]\"},{\"name\":\"_oracles\",\"type\":\"address[]\"}],\"name\":\"removeOracles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"updateLimitPerMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"name\":\"_operational\",\"type\":\"bool\"}],\"name\":\"changeOperational\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"name\":\"_holderAddress\",\"type\":\"address\"},{\"name\":\"_countryCode\",\"type\":\"uint256\"}],\"name\":\"registerHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"}],\"name\":\"getHolderCountryCode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_countryCode\",\"type\":\"uint256\"}],\"name\":\"addCountryCode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getHolderExternalIdByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"}],\"name\":\"getHolderInfo\",\"outputs\":[{\"name\":\"_countryCode\",\"type\":\"uint256\"},{\"name\":\"_limPerDay\",\"type\":\"uint256\"},{\"name\":\"_limPerMonth\",\"type\":\"uint256\"},{\"name\":\"_operational\",\"type\":\"bool\"},{\"name\":\"_text\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holderAddress\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isHolderOwnAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"name\":\"_text\",\"type\":\"bytes\"}],\"name\":\"updateTextForHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signatures\",\"type\":\"bytes4[]\"},{\"name\":\"_oracles\",\"type\":\"address[]\"}],\"name\":\"addOracles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_countryCode\",\"type\":\"uint256\"}],\"name\":\"getCountryLimit\",\"outputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countriesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_countryCode\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"changeCountryLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_countryCode\",\"type\":\"uint256\"}],\"name\":\"getCountryInfo\",\"outputs\":[{\"name\":\"_maxHolderNumber\",\"type\":\"uint256\"},{\"name\":\"_currentHolderCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"updateLimitPerDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"holderIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeHolderAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serviceController\",\"type\":\"address\"}],\"name\":\"setServiceController\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isRegisteredAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"}],\"name\":\"getHolderAddresses\",\"outputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawal\",\"type\":\"address\"}],\"name\":\"setWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_countryCode\",\"type\":\"uint256\"},{\"name\":\"_updatedHolderCount\",\"type\":\"uint256\"}],\"name\":\"updateCountryHoldersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"addHolderAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracles\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_holderAddress\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_serviceController\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_countryCode\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_countryId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_maxHolderCount\",\"type\":\"uint256\"}],\"name\":\"CountryCodeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_countryCode\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_countryId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_maxHolderCount\",\"type\":\"uint256\"}],\"name\":\"CountryCodeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_accessIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_countryCode\",\"type\":\"uint256\"}],\"name\":\"HolderRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_holderPrototype\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_accessIndex\",\"type\":\"uint256\"}],\"name\":\"HolderAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_holderPrototype\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_accessIndex\",\"type\":\"uint256\"}],\"name\":\"HolderAddressRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_operational\",\"type\":\"bool\"}],\"name\":\"HolderOperationalChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"DayLimitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_externalHolderId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"MonthLimitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_errorCode\",\"type\":\"uint256\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sig\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"OracleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sig\",\"type\":\"bytes4\"},{\"indexed\":false,\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"OracleRemoved\",\"type\":\"event\"}]","ContractName":"DataController","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000874055d651aa52c2d8fac36d467742519768f31c","Library":"","SwarmSource":"bzzr://865f988711fa3f1c1f50d2e3cbf1a7f70bf893f4a54b6fb0a4e3a0d43066bd57"}]}