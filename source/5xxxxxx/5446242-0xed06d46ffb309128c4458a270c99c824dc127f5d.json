{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts/EtherDeltaI.sol\r\n\r\ncontract EtherDeltaI {\r\n\r\n  uint public feeMake; //percentage times (1 ether)\r\n  uint public feeTake; //percentage times (1 ether)\r\n\r\n  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n\r\n  function deposit() payable;\r\n\r\n  function withdraw(uint amount);\r\n\r\n  function depositToken(address token, uint amount);\r\n\r\n  function withdrawToken(address token, uint amount);\r\n\r\n  function balanceOf(address token, address user) constant returns (uint);\r\n\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce);\r\n\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount);\r\n\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool);\r\n\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\r\n\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\r\n\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s);\r\n\r\n}\r\n\r\n// File: contracts/KindMath.sol\r\n\r\n/**\r\n * @title KindMath\r\n * @dev Math operations with safety checks that fail\r\n */\r\nlibrary KindMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/KeyValueStorage.sol\r\n\r\ncontract KeyValueStorage {\r\n\r\n  mapping(address => mapping(bytes32 => uint256)) _uintStorage;\r\n  mapping(address => mapping(bytes32 => address)) _addressStorage;\r\n  mapping(address => mapping(bytes32 => bool)) _boolStorage;\r\n  mapping(address => mapping(bytes32 => bytes32)) _bytes32Storage;\r\n\r\n  /**** Get Methods ***********/\r\n\r\n  function getAddress(bytes32 key) public view returns (address) {\r\n      return _addressStorage[msg.sender][key];\r\n  }\r\n\r\n  function getUint(bytes32 key) public view returns (uint) {\r\n      return _uintStorage[msg.sender][key];\r\n  }\r\n\r\n  function getBool(bytes32 key) public view returns (bool) {\r\n      return _boolStorage[msg.sender][key];\r\n  }\r\n\r\n  function getBytes32(bytes32 key) public view returns (bytes32) {\r\n      return _bytes32Storage[msg.sender][key];\r\n  }\r\n\r\n  /**** Set Methods ***********/\r\n\r\n  function setAddress(bytes32 key, address value) public {\r\n      _addressStorage[msg.sender][key] = value;\r\n  }\r\n\r\n  function setUint(bytes32 key, uint value) public {\r\n      _uintStorage[msg.sender][key] = value;\r\n  }\r\n\r\n  function setBool(bytes32 key, bool value) public {\r\n      _boolStorage[msg.sender][key] = value;\r\n  }\r\n\r\n  function setBytes32(bytes32 key, bytes32 value) public {\r\n      _bytes32Storage[msg.sender][key] = value;\r\n  }\r\n\r\n  /**** Delete Methods ***********/\r\n\r\n  function deleteAddress(bytes32 key) public {\r\n      delete _addressStorage[msg.sender][key];\r\n  }\r\n\r\n  function deleteUint(bytes32 key) public {\r\n      delete _uintStorage[msg.sender][key];\r\n  }\r\n\r\n  function deleteBool(bytes32 key) public {\r\n      delete _boolStorage[msg.sender][key];\r\n  }\r\n\r\n  function deleteBytes32(bytes32 key) public {\r\n      delete _bytes32Storage[msg.sender][key];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/StorageStateful.sol\r\n\r\ncontract StorageStateful {\r\n  KeyValueStorage public keyValueStorage;\r\n}\r\n\r\n// File: contracts/TokenI.sol\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() public returns (uint256);\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) public returns (uint256);\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public returns (uint256);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint256 public decimals;\r\n  string public name;\r\n}\r\n\r\n// File: contracts/EnclavesDEX.sol\r\n\r\ncontract EnclavesDEX is StorageStateful {\r\n  using KindMath for uint256;\r\n\r\n  address public admin; //the admin address\r\n  address public feeAccount; //the account that will receive fees\r\n\r\n  struct EtherDeltaInfo {\r\n    uint256 feeMake;\r\n    uint256 feeTake;\r\n  }\r\n\r\n  EtherDeltaInfo public etherDeltaInfo;\r\n\r\n  uint256 public feeTake; //percentage times 1 ether\r\n  uint256 public feeAmountThreshold; //gasPrice amount under which no fees are charged\r\n\r\n  address public etherDelta;\r\n\r\n  bool public useEIP712 = true;\r\n  bytes32 public tradeABIHash;\r\n  bytes32 public withdrawABIHash;\r\n\r\n  bool freezeTrading;\r\n  bool depositTokenLock;\r\n\r\n  mapping (address => mapping (uint256 => bool)) nonceCheck;\r\n\r\n  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint256)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n\r\n  //Unused here - used in Proxy\r\n  address internal implementation;\r\n  address public proposedImplementation;\r\n  uint256 public proposedTimestamp;\r\n\r\n  event Order(address indexed tokenGet, uint256 amountGet, address indexed tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address indexed user);\r\n  event Cancel(address indexed tokenGet, uint256 amountGet, address indexed tokenGive, uint256 amountGive, uint256 expires, uint256 nonce, address indexed user, uint8 v, bytes32 r, bytes32 s);\r\n  event Trade(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, address indexed get, address indexed give, uint8 exchange);\r\n  event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\r\n  event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);\r\n  event WithdrawPreSigned(address indexed feeToken, uint256 feeValue, address indexed feeReceiver);\r\n  event Rebalance(address indexed dex, address indexed token, uint256 amount);\r\n\r\n  modifier onlyAdmin {\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n\r\n  modifier onlyEtherDelta {\r\n    require(msg.sender == etherDelta);\r\n    _;\r\n  }\r\n\r\n  modifier markTokenDeposit {\r\n    depositTokenLock = true;\r\n    _;\r\n    depositTokenLock = false;\r\n  }\r\n\r\n  modifier inTokenDeposit {\r\n    require(depositTokenLock);\r\n    _;\r\n  }\r\n\r\n  modifier notFrozen {\r\n    require(!freezeTrading);\r\n    _;\r\n  }\r\n\r\n  function setEtherDeltaFees() public onlyAdmin {\r\n    etherDeltaInfo.feeMake = EtherDeltaI(etherDelta).feeMake();\r\n    etherDeltaInfo.feeTake = EtherDeltaI(etherDelta).feeTake();\r\n  }\r\n\r\n  function() public payable onlyEtherDelta {\r\n  }\r\n\r\n  function setTradeABIHash(bytes32 _tradeABIHash) public onlyAdmin {\r\n    tradeABIHash = _tradeABIHash;\r\n  }\r\n\r\n  function setWithdrawABIHash(bytes32 _withdrawABIHash) public onlyAdmin {\r\n    withdrawABIHash = _withdrawABIHash;\r\n  }\r\n\r\n  function setUseEIP712(bool _useEIP712) public onlyAdmin {\r\n    useEIP712 = _useEIP712;\r\n  }\r\n\r\n  function changeAdmin(address _admin) public onlyAdmin {\r\n    admin = _admin;\r\n  }\r\n\r\n  function changeFeeAccount(address _feeAccount) public onlyAdmin {\r\n    require(_feeAccount != address(0));\r\n    feeAccount = _feeAccount;\r\n  }\r\n\r\n  function changeFeeTake(uint256 _feeTake) public onlyAdmin {\r\n    feeTake = _feeTake;\r\n  }\r\n\r\n  function changeFeeAmountThreshold(uint256 _feeAmountThreshold) public onlyAdmin {\r\n    feeAmountThreshold = _feeAmountThreshold;\r\n  }\r\n\r\n  function changeFreezeTrading(bool _freezeTrading) public onlyAdmin {\r\n    freezeTrading = _freezeTrading;\r\n  }\r\n\r\n  function deposit() public payable {\r\n    if (msg.value > 0) {\r\n      tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\r\n      Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\r\n    }\r\n  }\r\n\r\n  function depositEther(uint256 _amount) internal {\r\n    //Will throw if not enough ether sent\r\n    uint256 refund = msg.value.sub(_amount);\r\n    if (_amount != 0) {\r\n      tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(_amount);\r\n      Deposit(address(0), msg.sender, _amount, tokens[address(0)][msg.sender]);\r\n    }\r\n    if (refund > 0) {\r\n      msg.sender.transfer(refund);\r\n    }\r\n  }\r\n\r\n  function depositToken(address _token, uint256 _amount) public markTokenDeposit {\r\n    require(_token != address(0));\r\n    require(Token(_token).transferFrom(msg.sender, address(this), _amount));\r\n    tokens[_token][msg.sender] = tokens[_token][msg.sender].add(_amount);\r\n    Deposit(_token, msg.sender, _amount, tokens[_token][msg.sender]);\r\n  }\r\n\r\n  function depositBoth(address _token, uint256 _amount) public payable {\r\n    depositToken(_token, _amount);\r\n    deposit();\r\n  }\r\n\r\n  function processDeposits(address _token, uint256 _amount) internal {\r\n    //Always need to deal with possible non-zero msg.value\r\n    uint256 etherAmount = 0;\r\n    if ((_token == address(0)) && (tokens[address(0)][msg.sender] < _amount)) {\r\n      etherAmount = _amount.sub(tokens[address(0)][msg.sender]);\r\n    }\r\n    depositEther(etherAmount);\r\n    //Only pull tokens if needed\r\n    if ((_token != address(0)) && (tokens[_token][msg.sender] < _amount)) {\r\n      depositToken(_token, _amount.sub(tokens[_token][msg.sender]));\r\n    }\r\n  }\r\n\r\n  function withdraw(uint256 _amount) public {\r\n    withdrawUser(_amount, msg.sender);\r\n  }\r\n\r\n  function withdrawUser(uint256 _amount, address _user) internal {\r\n    tokens[address(0)][_user] = tokens[address(0)][_user].sub(_amount);\r\n    if (this.balance < _amount) {\r\n      rebalanceEnclaves(address(0), _amount);\r\n    }\r\n    _user.transfer(_amount);\r\n    Withdraw(address(0), _user, _amount, tokens[address(0)][_user]);\r\n  }\r\n\r\n  function withdrawToken(address _token, uint256 _amount) public {\r\n    withdrawTokenUser(_token, _amount, msg.sender);\r\n  }\r\n\r\n  function withdrawTokenUser(address _token, uint256 _amount, address _user) internal {\r\n    require(_token != 0);\r\n    tokens[_token][_user] = tokens[_token][_user].sub(_amount);\r\n    if (Token(_token).balanceOf(address(this)) < _amount) {\r\n      rebalanceEnclaves(_token, _amount);\r\n    }\r\n    require(Token(_token).transfer(_user, _amount));\r\n    Withdraw(_token, _user, _amount, tokens[_token][_user]);\r\n  }\r\n\r\n  function withdrawTokenMulti(address[] _tokens, uint256[] _amounts) public {\r\n    require(_tokens.length == _amounts.length);\r\n    for (uint256 i = 0; i < _tokens.length; i++) {\r\n      withdrawToken(_tokens[i], _amounts[i]);\r\n    }\r\n  }\r\n\r\n  function withdrawBoth(address _token, uint256 _tokenAmount, uint256 _ethAmount) public {\r\n    withdrawToken(_token, _tokenAmount);\r\n    withdraw(_ethAmount);\r\n  }\r\n\r\n  function tokenFallback(address /* _from */, uint256 /* _value */, bytes /* _data */) public view inTokenDeposit {\r\n    //Having this function allows ERC23 tokens to be deposited via the usual approve / transferFrom methods\r\n    //It should only be called whilst a depositToken is occurring\r\n  }\r\n\r\n  function balanceOf(address _token, address _user) public view returns (uint256) {\r\n    return tokens[_token][_user];\r\n  }\r\n\r\n  function order(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce) public {\r\n    bytes32 orderHash = keccak256(address(this), _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    orders[msg.sender][orderHash] = true;\r\n    Order(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, msg.sender);\r\n  }\r\n\r\n  function rebalanceEtherDelta(address _token, uint256 _amount) internal {\r\n    uint256 enclavesBalance;\r\n    if (_token == address(0)) {\r\n      enclavesBalance = this.balance;\r\n      if (enclavesBalance < _amount) {\r\n        _amount = enclavesBalance;\r\n      }\r\n      EtherDeltaI(etherDelta).deposit.value(_amount)();\r\n    } else {\r\n      enclavesBalance = Token(_token).balanceOf(address(this));\r\n      if (enclavesBalance < _amount) {\r\n        _amount = enclavesBalance;\r\n      }\r\n      Token(_token).approve(etherDelta, _amount);\r\n      EtherDeltaI(etherDelta).depositToken(_token, _amount);\r\n    }\r\n    Rebalance(etherDelta, _token, _amount);\r\n  }\r\n\r\n  function rebalanceEnclaves(address _token, uint256 _amount) internal {\r\n    uint256 edBalance = EtherDeltaI(etherDelta).balanceOf(_token, address(this));\r\n    if (edBalance < _amount) {\r\n      _amount = edBalance;\r\n    }\r\n    if (_token == address(0)) {\r\n      EtherDeltaI(etherDelta).withdraw(_amount);\r\n    } else {\r\n      EtherDeltaI(etherDelta).withdrawToken(_token, _amount);\r\n    }\r\n    Rebalance(address(this), _token, _amount);\r\n  }\r\n\r\n  function tradeEtherDelta(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint256 _amount, bool _withdraw) public notFrozen payable returns (uint256) {\r\n    _amount = availableVolumeEtherDelta(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _amount);\r\n    require(_amount > 0);\r\n    _tradeEtherDelta(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount);\r\n    if (_withdraw) {\r\n      if (_tokenGive == address(0)) {\r\n        withdraw(_amountGive.mul(_amount) / _amountGet);\r\n      } else {\r\n        withdrawToken(_tokenGive, _amountGive.mul(_amount) / _amountGet);\r\n      }\r\n    }\r\n    return _amount;\r\n  }\r\n\r\n  //amount is denominated in tokenGet\r\n  function _tradeEtherDelta(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint256 _amount) internal {\r\n    uint256 cost = _amount.add(_amount.mul(etherDeltaInfo.feeTake) / 1 ether);\r\n    processDeposits(_tokenGet, cost);\r\n    tokens[_tokenGet][msg.sender] = tokens[_tokenGet][msg.sender].sub(cost);\r\n    if (EtherDeltaI(etherDelta).balanceOf(_tokenGet, address(this)) < cost) {\r\n      rebalanceEtherDelta(_tokenGet, cost);\r\n    }\r\n    EtherDeltaI(etherDelta).trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount);\r\n    //Reuse cost to avoid \"CompilerError: Stack too deep, try removing local variables.\"\r\n    cost = _amountGive.mul(_amount) / _amountGet;\r\n    tokens[_tokenGive][msg.sender] = tokens[_tokenGive][msg.sender].add(cost);\r\n    Trade(_tokenGet, _amount, _tokenGive, cost, _user, msg.sender, 1);\r\n  }\r\n\r\n  function trade(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint256 _amount, bool _withdraw) public notFrozen payable returns (uint256) {\r\n    uint256 availableVolume;\r\n    //Reuse _r to avoid \"CompilerError: Stack too deep, try removing local variables.\"\r\n    (availableVolume, _r) = availableVolumeEnclaves(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s);\r\n    _amount = (availableVolume < _amount) ? availableVolume : _amount;\r\n    require(_amount > 0);\r\n    _trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _user, _amount, _r);\r\n    if (_withdraw) {\r\n      if (_tokenGive == address(0)) {\r\n        withdraw(_amountGive.mul(_amount) / _amountGet);\r\n      } else {\r\n        withdrawToken(_tokenGive, _amountGive.mul(_amount) / _amountGet);\r\n      }\r\n    }\r\n    return _amount;\r\n  }\r\n\r\n  //_amount is denominated in tokenGet\r\n  function _trade(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, address _user, uint256 _amount, bytes32 _orderHash) internal {\r\n    uint256 ethAmount = (_tokenGet == address(0)) ? _amount : _amountGive.mul(_amount) / _amountGet;\r\n    uint256 feeTakeXfer = (ethAmount <= feeAmountThreshold) ? 0 : _amount.mul(feeTake) / (1 ether);\r\n    uint256 cost = _amount.add(feeTakeXfer);\r\n    processDeposits(_tokenGet, cost);\r\n    tokens[_tokenGet][msg.sender] = tokens[_tokenGet][msg.sender].sub(cost);\r\n    //\r\n    tokens[_tokenGet][_user] = tokens[_tokenGet][_user].add(_amount);\r\n    if (feeTakeXfer > 0) {\r\n      tokens[_tokenGet][feeAccount] = tokens[_tokenGet][feeAccount].add(feeTakeXfer);\r\n    }\r\n    tokens[_tokenGive][_user] = tokens[_tokenGive][_user].sub(_amountGive.mul(_amount) / _amountGet);\r\n    //\r\n    //Reuse cost to avoid \"CompilerError: Stack too deep, try removing local variables.\"\r\n    cost = _amountGive.mul(_amount) / _amountGet;\r\n    tokens[_tokenGive][msg.sender] = tokens[_tokenGive][msg.sender].add(cost);\r\n    orderFills[_user][_orderHash] = orderFills[_user][_orderHash].add(_amount);\r\n    Trade(_tokenGet, _amount, _tokenGive, cost, _user, msg.sender, 0);\r\n  }\r\n\r\n  function checkSig(bytes32 _abiHash, bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s, address _user) public view returns(bool) {\r\n    if (useEIP712) {\r\n      return (ecrecover(keccak256(_abiHash, _hash), _v, _r, _s) == _user);\r\n    } else {\r\n      return (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash), _v, _r, _s) == _user);\r\n    }\r\n  }\r\n\r\n  function availableVolumeEnclaves(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s) public view returns (uint256, bytes32) {\r\n    bytes32 orderHash = keccak256(address(this), _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    if (!(\r\n      (orders[_user][orderHash] || checkSig(tradeABIHash, orderHash, _v, _r, _s, _user)) &&\r\n      block.number <= _expires\r\n    )) return (0, orderHash);\r\n    //Reuse amountGet/Give to avoid \"CompilerError: Stack too deep, try removing local variables.\"\r\n    _amountGive = tokens[_tokenGive][_user].mul(_amountGet) / _amountGive;\r\n    _amountGet = _amountGet.sub(orderFills[_user][orderHash]);\r\n    _amountGet = (_amountGive < _amountGet) ? _amountGive : _amountGet;\r\n    return (_amountGet, orderHash);\r\n  }\r\n\r\n  function availableVolumeEtherDelta(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user, uint256 _amount) public view returns (uint256) {\r\n    if (block.number > _expires) {\r\n      return 0;\r\n    }\r\n    bytes32 orderHash = sha256(etherDelta, _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    //Reuse amountGet/Give to avoid \"CompilerError: Stack too deep, try removing local variables.\"\r\n    _amountGive = EtherDeltaI(etherDelta).tokens(_tokenGive, _user).mul(_amountGet) / _amountGive;\r\n    _amountGet = _amountGet.sub(EtherDeltaI(etherDelta).orderFills(_user, orderHash));\r\n    if (_amountGet > _amountGive) {\r\n      _amountGet = _amountGive;\r\n    }\r\n    if (_amountGet > _amount) {\r\n      _amountGet = _amount;\r\n    }\r\n    return _amountGet;\r\n  }\r\n\r\n  function amountFilled(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, address _user) public view returns(uint256) {\r\n    bytes32 hash = keccak256(address(this), _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    return orderFills[_user][hash];\r\n  }\r\n\r\n  function cancelOrder(address _tokenGet, uint256 _amountGet, address _tokenGive, uint256 _amountGive, uint256 _expires, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public {\r\n    bytes32 hash = keccak256(address(this), _tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce);\r\n    require(orders[msg.sender][hash] || checkSig(tradeABIHash, hash, _v, _r, _s, msg.sender));\r\n    orderFills[msg.sender][hash] = _amountGet;\r\n    Cancel(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, msg.sender, _v, _r, _s);\r\n  }\r\n\r\n  function withdrawPreSigned(address _token, uint256 _value, address _feeToken, uint256 _feeValue, uint256 _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s) public {\r\n    require(nonceCheck[_user][_nonce] == false);\r\n    bytes32 hash = keccak256(address(this), _token, _value, _feeToken, _feeValue, _nonce);\r\n    require(checkSig(withdrawABIHash, hash, _v, _r, _s, _user));\r\n    nonceCheck[_user][_nonce] = true;\r\n    //Debit fee to sender\r\n    tokens[_feeToken][_user] = tokens[_feeToken][_user].sub(_feeValue);\r\n    tokens[_feeToken][msg.sender] = tokens[_feeToken][msg.sender].add(_feeValue);\r\n    if (_token == address(0)) {\r\n      withdrawUser(_value, _user);\r\n    } else {\r\n      withdrawTokenUser(_token, _value, _user);\r\n    }\r\n    WithdrawPreSigned(_feeToken, _feeValue, msg.sender);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenGet\",\"type\":\"address\"},{\"name\":\"_amountGet\",\"type\":\"uint256\"},{\"name\":\"_tokenGive\",\"type\":\"address\"},{\"name\":\"_amountGive\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_withdraw\",\"type\":\"bool\"}],\"name\":\"tradeEtherDelta\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenGet\",\"type\":\"address\"},{\"name\":\"_amountGet\",\"type\":\"uint256\"},{\"name\":\"_tokenGive\",\"type\":\"address\"},{\"name\":\"_amountGive\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"order\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherDeltaInfo\",\"outputs\":[{\"name\":\"feeMake\",\"type\":\"uint256\"},{\"name\":\"feeTake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_useEIP712\",\"type\":\"bool\"}],\"name\":\"setUseEIP712\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenGet\",\"type\":\"address\"},{\"name\":\"_amountGet\",\"type\":\"uint256\"},{\"name\":\"_tokenGive\",\"type\":\"address\"},{\"name\":\"_amountGive\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenGet\",\"type\":\"address\"},{\"name\":\"_amountGet\",\"type\":\"uint256\"},{\"name\":\"_tokenGive\",\"type\":\"address\"},{\"name\":\"_amountGive\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"amountFilled\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeABIHash\",\"type\":\"bytes32\"}],\"name\":\"setTradeABIHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenGet\",\"type\":\"address\"},{\"name\":\"_amountGet\",\"type\":\"uint256\"},{\"name\":\"_tokenGive\",\"type\":\"address\"},{\"name\":\"_amountGive\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"availableVolumeEtherDelta\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_feeToken\",\"type\":\"address\"},{\"name\":\"_feeValue\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"withdrawPreSigned\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBoth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freezeTrading\",\"type\":\"bool\"}],\"name\":\"changeFreezeTrading\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAmountThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"useEIP712\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyValueStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"changeFeeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeTake\",\"type\":\"uint256\"}],\"name\":\"changeFeeTake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeABIHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawBoth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenGet\",\"type\":\"address\"},{\"name\":\"_amountGet\",\"type\":\"uint256\"},{\"name\":\"_tokenGive\",\"type\":\"address\"},{\"name\":\"_amountGive\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"availableVolumeEnclaves\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenGet\",\"type\":\"address\"},{\"name\":\"_amountGet\",\"type\":\"uint256\"},{\"name\":\"_tokenGive\",\"type\":\"address\"},{\"name\":\"_amountGive\",\"type\":\"uint256\"},{\"name\":\"_expires\",\"type\":\"uint256\"},{\"name\":\"_nonce\",\"type\":\"uint256\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_withdraw\",\"type\":\"bool\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeAmountThreshold\",\"type\":\"uint256\"}],\"name\":\"changeFeeAmountThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherDelta\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setEtherDeltaFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawABIHash\",\"type\":\"bytes32\"}],\"name\":\"setWithdrawABIHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"withdrawTokenMulti\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_abiHash\",\"type\":\"bytes32\"},{\"name\":\"_hash\",\"type\":\"bytes32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkSig\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawABIHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Order\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenGet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenGive\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountGive\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"get\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"give\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"exchange\",\"type\":\"uint8\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feeValue\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"WithdrawPreSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dex\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Rebalance\",\"type\":\"event\"}]","ContractName":"EnclavesDEX","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9c5ed813e303cd4688c7eab250a0fc6c64fa2da55047f9a4236617108fab7d1a"}]}