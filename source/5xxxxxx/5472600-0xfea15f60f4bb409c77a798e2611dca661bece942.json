{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\ncontract coinback is usingOraclize {\r\n\r\n    struct betInfo{\r\n        address srcAddress;\r\n        uint betValue;\r\n    }\r\n\r\n    uint POOL_AWARD;                                          //奖池\r\n    uint constant FREE_PERCENT = 1;                          //服务费用比例1%\r\n\r\n    uint32 public oraclizeGas = 200000;\r\n    uint32 constant MAX_RANDOM_NUM = 1000000;                 //最大随机数\r\n    betInfo overBetPlayer;                                    //超过奖池的玩家\r\n    uint32 betId;\r\n    uint32 luckyIndex;\r\n    uint32 public turnId;                                     //期数\r\n    uint   public beginTime;                                  //当期开始时间\r\n    uint   public totalAward;                                 //累计奖励\r\n\r\n    bool public stopContract;                                 //停止合约\r\n    bool public stopBet;                                      //停止投注\r\n    bool public exitOverPlayer;\r\n    address owner;\r\n    mapping(uint32=>betInfo) betMap;\r\n\r\n    event LOG_NewTurn(uint turnNo,uint time,uint totalnum);                                         //新一轮(期号,开始时间,奖池金额)\r\n    event LOG_PlayerBet(address srcAddress,uint betNum,uint turnNo,uint totalnum,uint time);        //投注事件(地址，金额，期号，奖池金额，本期开始时间)\r\n    event LOG_LuckyPLayer(address luckyAddress,uint luckyNum,uint turnNo);                         //中奖事件(中奖地址，奖池金额，期数)\r\n\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notStopContract {\r\n        if (stopContract) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notStopBet {\r\n        if (stopBet) throw;\r\n        _;\r\n    }\r\n\r\n    function coinback(uint initPool){\r\n\r\n        owner = msg.sender;\r\n        POOL_AWARD = initPool;\r\n        turnId = 0;\r\n        stopContract = false;\r\n        exitOverPlayer = false;\r\n        betId = 0;\r\n        startNewTurn();\r\n    }\r\n\r\n    function ()payable {\r\n        bet();\r\n    }\r\n\r\n    function bet() payable\r\n        notStopContract\r\n        notStopBet{\r\n\r\n        uint betValue = msg.value;\r\n        totalAward = address(this).balance;\r\n        if(totalAward > POOL_AWARD)\r\n            totalAward = POOL_AWARD;\r\n\r\n        if(address(this).balance >= POOL_AWARD)\r\n        {\r\n            uint overValue = address(this).balance - POOL_AWARD;\r\n            if(overValue > 0)\r\n            {\r\n                betValue = betValue - overValue;\r\n                overBetPlayer = betInfo({srcAddress:msg.sender,betValue:overValue});\r\n            }\r\n            stopBet = true;\r\n        }\r\n        betMap[betId] = betInfo({srcAddress:msg.sender,betValue:betValue});\r\n        betId++;\r\n\r\n        LOG_PlayerBet(msg.sender,msg.value,turnId,totalAward,beginTime);\r\n\r\n        if(stopBet)\r\n          closeThisTurn();\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result) {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n\r\n        uint randomNum = parseInt(result);\r\n        totalAward = address(this).balance;\r\n        if(totalAward > POOL_AWARD)\r\n            totalAward = POOL_AWARD;\r\n\r\n        uint randomBalance = totalAward*randomNum/MAX_RANDOM_NUM;\r\n        uint32 index = 0;\r\n\r\n        index = getLunckyIndex(randomBalance);\r\n        uint winCoin = totalAward*(100-FREE_PERCENT)/100;\r\n        uint waiterfree = totalAward*FREE_PERCENT/100;\r\n\r\n        LOG_LuckyPLayer(betMap[index].srcAddress,totalAward,turnId);\r\n\r\n        if(!betMap[index].srcAddress.send(winCoin)) throw;\r\n        if(!owner.send(waiterfree)) throw;\r\n\r\n        startNewTurn();\r\n    }\r\n\r\n    function getLunckyIndex(uint randomBalance) private returns(uint32){\r\n\r\n        uint range = 0;\r\n        for(uint32 i =0; i< betId; i++)\r\n        {\r\n            range += betMap[i].betValue;\r\n            if(range >= randomBalance)\r\n            {\r\n                luckyIndex = i;\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function startNewTurn() private{\r\n\r\n        clearBetMap();\r\n        betId = 0;\r\n        if(exitOverPlayer)\r\n        {\r\n            betMap[betId] = overBetPlayer;\r\n            betId++;\r\n            exitOverPlayer = false;\r\n        }\r\n        turnId++;\r\n        beginTime = now;\r\n        totalAward = address(this).balance;\r\n        stopBet = false;\r\n        LOG_NewTurn(turnId,beginTime,totalAward);\r\n    }\r\n\r\n    function clearBetMap() private{\r\n        for(uint32 i=0;i<betId;i++){\r\n            delete betMap[i];\r\n        }\r\n    }\r\n\r\n    function closeThisTurn() private{\r\n        bytes32 oid = oraclize_query(\"URL\",\"https://www.random.org/integers/?num=1&min=1&max=1000000&col=1&base=10&format=plain&rnd=new\",oraclizeGas);\r\n    }\r\n\r\n    function getLunckyInfo() returns(uint32,address,bool){\r\n        return (luckyIndex,betMap[luckyIndex].srcAddress,stopContract);\r\n    }\r\n\r\n    function getOverPLayer() returns(address,uint){\r\n        return (overBetPlayer.srcAddress,overBetPlayer.betValue);\r\n    }\r\n    /***********操作合约**********/\r\n\r\n    function closeTurnByHand(uint32 no) onlyOwner{\r\n        if(turnId != no) throw;\r\n        if(address(this).balance == 0) throw;\r\n        stopBet = true;\r\n        closeThisTurn();\r\n    }\r\n\r\n    function killContract() onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function destroyContract() onlyOwner{\r\n        stopContract = true;\r\n    }\r\n\r\n    function changeOwner(address newOwner) onlyOwner{\r\n        owner = newOwner;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"exitOverPlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getLunckyInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclizeGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getOverPLayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beginTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"no\",\"type\":\"uint32\"}],\"name\":\"closeTurnByHand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"turnId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initPool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"turnNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalnum\",\"type\":\"uint256\"}],\"name\":\"LOG_NewTurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"srcAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"turnNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalnum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LOG_PlayerBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"luckyAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"luckyNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"turnNo\",\"type\":\"uint256\"}],\"name\":\"LOG_LuckyPLayer\",\"type\":\"event\"}]","ContractName":"coinback","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000008ac7230489e80000","Library":"","SwarmSource":"bzzr://dcfeb109ddeff931c2bf3e55bd2978439ae72dbceb965b096bd3d58dc748091d"}]}