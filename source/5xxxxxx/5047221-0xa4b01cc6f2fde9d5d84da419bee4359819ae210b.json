{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract ERC721 {\r\n    // ERC20 compatible functions\r\n    // use variable getter\r\n    // function name() constant returns (string name);\r\n    // function symbol() constant returns (string symbol);\r\n    function totalSupply() public constant returns (uint256);\r\n    function balanceOf(address _owner) public constant returns (uint balance);\r\n    function ownerOf(uint256 _tokenId) public constant returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) public ;\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 tokenId);\r\n    function transfer(address _to, uint256 _tokenId) external ;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    \r\n    // Optional\r\n    // function takeOwnership(uint256 _tokenId) public ;\r\n    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external constant returns (uint tokenId);\r\n    // function tokenMetadata(uint256 _tokenId) public constant returns (string infoUrl);\r\n    \r\n    // Events\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n}\r\n\r\ncontract ERC20 {\r\n    // Get the total token supply\r\n    function totalSupply() public constant returns (uint256 _totalSupply);\r\n \r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n \r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    \r\n    // transfer _value amount of token approved by address _from\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    \r\n    // approve an address with _value amount of tokens\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    // get remaining token approved by _owner to _spender\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n  \r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n \r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract VirtualGift is ERC721 {\r\n    \r\n    // load GTO to Virtual Gift contract, to interact with GTO\r\n    ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\r\n    \r\n    // Gift data\r\n    struct Gift {\r\n        // gift price\r\n        uint256 price;\r\n        // gift description\r\n        string description;\r\n    }\r\n    \r\n    address public owner;\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _GiftId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _GiftId);\r\n    event Creation(address indexed _owner, uint256 indexed GiftId);\r\n    \r\n    string public constant name = \"VirtualGift\";\r\n    string public constant symbol = \"VTG\";\r\n    \r\n    // Gift object storage in array\r\n    Gift[] giftStorage;\r\n    \r\n    // total Gift of an address\r\n    mapping(address => uint256) private balances;\r\n    \r\n    // index of Gift array to Owner\r\n    mapping(uint256 => address) private GiftIndexToOwners;\r\n    \r\n    // Gift exist or not\r\n    mapping(uint256 => bool) private GiftExists;\r\n    \r\n    // mapping from owner and approved address to GiftId\r\n    mapping(address => mapping (address => uint256)) private allowed;\r\n    \r\n    // mapping from owner and index Gift of owner to GiftId\r\n    mapping(address => mapping(uint256 => uint256)) private ownerIndexToGifts;\r\n    \r\n    // Gift metadata\r\n    mapping(uint256 => string) GiftLinks;\r\n\r\n    modifier onlyOwner(){\r\n         require(msg.sender == owner);\r\n         _;\r\n    }\r\n\r\n    modifier onlyGiftOwner(uint256 GiftId){\r\n        require(msg.sender == GiftIndexToOwners[GiftId]);\r\n        _;\r\n    }\r\n    \r\n    modifier validGift(uint256 GiftId){\r\n        require(GiftExists[GiftId]);\r\n        _;\r\n    }\r\n\r\n    /// @dev constructor\r\n    function VirtualGift()\r\n    public{\r\n        owner = msg.sender;\r\n        // save temporaryly new Gift\r\n        Gift memory newGift = Gift({\r\n            price: 0,\r\n            description: \"MYTHICAL\"\r\n        });\r\n        // push to array and return the length is the id of new Gift\r\n        uint256 mythicalGift = giftStorage.push(newGift) - 1; // id = 0\r\n        // mythical Gift is not exist\r\n        GiftExists[mythicalGift] = false;\r\n        // assign url for Gift\r\n        GiftLinks[mythicalGift] = \"mythicalGift\";\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(0, msg.sender, mythicalGift);\r\n        // event create new Gift for msg.sender\r\n        Creation(msg.sender, mythicalGift);\r\n    }\r\n    \r\n    /// @dev this function change GTO address, this mean you can use many token to buy gift\r\n    /// by change GTO address to BNB address\r\n    /// @param newAddress is new address of GTO or another Gift like BNB\r\n    function changeGTOAddress(address newAddress)\r\n    public\r\n    onlyOwner{\r\n        GTO = ERC20(newAddress);\r\n    }\r\n    \r\n    /// @dev return current GTO address\r\n    function getGTOAddress()\r\n    public\r\n    constant\r\n    returns (address) {\r\n        return address(GTO);\r\n    }\r\n    \r\n    /// @dev return total supply of Gift\r\n    /// @return length of Gift storage array, except Gift Zero\r\n    function totalSupply()\r\n    public \r\n    constant\r\n    returns (uint256){\r\n        // exclusive Gift Zero\r\n        return giftStorage.length - 1;\r\n    }\r\n    \r\n    /// @dev allow people to buy Gift\r\n    /// @param GiftId : id of gift user want to buy\r\n    function buy(uint256 GiftId) \r\n    validGift(GiftId)\r\n    public {\r\n        // get old owner of Gift\r\n        address oldowner = ownerOf(GiftId);\r\n        // tell gifto transfer GTO from new owner to oldowner\r\n        // NOTE: new owner MUST approve for Virtual Gift contract to take his balance\r\n        require(GTO.transferFrom(msg.sender, oldowner, giftStorage[GiftId].price) == true);\r\n        // assign new owner for GiftId\r\n        // TODO: old owner should have something to confirm that he want to sell this Gift\r\n        _transfer(oldowner, msg.sender, GiftId);\r\n    }\r\n    \r\n    /// @dev owner send gift to recipient when VG was approved\r\n    /// @param recipient : received gift\r\n    /// @param GiftId : id of gift which recipient want to buy\r\n    function sendGift(address recipient, uint256 GiftId)\r\n    onlyGiftOwner(GiftId)\r\n    validGift(GiftId)\r\n    public {\r\n        // transfer GTO to owner\r\n        // require(GTO.transfer(msg.sender, giftStorage[GiftId].price) == true);\r\n        // transfer gift to recipient\r\n        _transfer(msg.sender, recipient, GiftId);\r\n    }\r\n    \r\n    /// @dev get total Gift of an address\r\n    /// @param _owner to get balance\r\n    /// @return balance of an address\r\n    function balanceOf(address _owner) \r\n    public \r\n    constant \r\n    returns (uint256 balance){\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function isExist(uint256 GiftId)\r\n    public\r\n    constant\r\n    returns(bool){\r\n        return GiftExists[GiftId];\r\n    }\r\n    \r\n    /// @dev get owner of an Gift id\r\n    /// @param _GiftId : id of Gift to get owner\r\n    /// @return owner : owner of an Gift id\r\n    function ownerOf(uint256 _GiftId)\r\n    public\r\n    constant \r\n    returns (address _owner) {\r\n        require(GiftExists[_GiftId]);\r\n        return GiftIndexToOwners[_GiftId];\r\n    }\r\n    \r\n    /// @dev approve Gift id from msg.sender to an address\r\n    /// @param _to : address is approved\r\n    /// @param _GiftId : id of Gift in array\r\n    function approve(address _to, uint256 _GiftId)\r\n    validGift(_GiftId)\r\n    public {\r\n        require(msg.sender == ownerOf(_GiftId));\r\n        require(msg.sender != _to);\r\n        \r\n        allowed[msg.sender][_to] = _GiftId;\r\n        Approval(msg.sender, _to, _GiftId);\r\n    }\r\n    \r\n    /// @dev get id of Gift was approved from owner to spender\r\n    /// @param _owner : address owner of Gift\r\n    /// @param _spender : spender was approved\r\n    /// @return GiftId\r\n    function allowance(address _owner, address _spender) \r\n    public \r\n    constant \r\n    returns (uint256 GiftId) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    /// @dev a spender take owner ship of Gift id, when he was approved\r\n    /// @param _GiftId : id of Gift has being takeOwnership\r\n    function takeOwnership(uint256 _GiftId)\r\n    validGift(_GiftId)\r\n    public {\r\n        // get oldowner of Giftid\r\n        address oldOwner = ownerOf(_GiftId);\r\n        // new owner is msg sender\r\n        address newOwner = msg.sender;\r\n        \r\n        require(newOwner != oldOwner);\r\n        // newOwner must be approved by oldOwner\r\n        require(allowed[oldOwner][newOwner] == _GiftId);\r\n\r\n        // transfer Gift for new owner\r\n        _transfer(oldOwner, newOwner, _GiftId);\r\n\r\n        // delete approve when being done take owner ship\r\n        delete allowed[oldOwner][newOwner];\r\n\r\n        Transfer(oldOwner, newOwner, _GiftId);\r\n    }\r\n    \r\n    /// @dev transfer ownership of a specific Gift to an address.\r\n    /// @param _from : address owner of Giftid\r\n    /// @param _to : address's received\r\n    /// @param _GiftId : Gift id\r\n    function _transfer(address _from, address _to, uint256 _GiftId) \r\n    internal {\r\n        // Since the number of Gift is capped to 2^32 we can't overflow this\r\n        balances[_to]++;\r\n        // transfer ownership\r\n        GiftIndexToOwners[_GiftId] = _to;\r\n        // When creating new Gift _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            balances[_from]--;\r\n        }\r\n        // Emit the transfer event.\r\n        Transfer(_from, _to, _GiftId);\r\n    }\r\n    \r\n    /// @dev transfer ownership of Giftid from msg sender to an address\r\n    /// @param _to : address's received\r\n    /// @param _GiftId : Gift id\r\n    function transfer(address _to, uint256 _GiftId)\r\n    validGift(_GiftId)\r\n    external {\r\n        // not transfer to zero\r\n        require(_to != 0x0);\r\n        // address received different from sender\r\n        require(msg.sender != _to);\r\n        // sender must be owner of Giftid\r\n        require(msg.sender == ownerOf(_GiftId));\r\n        // do not send to Gift contract\r\n        require(_to != address(this));\r\n        \r\n        _transfer(msg.sender, _to, _GiftId);\r\n    }\r\n    \r\n    /// @dev transfer Giftid was approved by _from to _to\r\n    /// @param _from : address owner of Giftid\r\n    /// @param _to : address is received\r\n    /// @param _GiftId : Gift id\r\n    function transferFrom(address _from, address _to, uint256 _GiftId)\r\n    validGift(_GiftId)\r\n    external {\r\n        require(_from == ownerOf(_GiftId));\r\n        // Check for approval and valid ownership\r\n        require(allowance(_from, msg.sender) == _GiftId);\r\n        // address received different from _owner\r\n        require(_from != _to);\r\n        \r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any Gift\r\n        require(_to != address(this));\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _GiftId);\r\n    }\r\n    \r\n    /// @dev Returns a list of all Gift IDs assigned to an address.\r\n    /// @param _owner The owner whose Gift we are interested in.\r\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\r\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\r\n    /// @return ownerGifts : list Gift of owner\r\n    function GiftsOfOwner(address _owner) \r\n    public \r\n    view \r\n    returns(uint256[] ownerGifts) {\r\n        \r\n        uint256 GiftCount = balanceOf(_owner);\r\n        if (GiftCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](GiftCount);\r\n            uint256 total = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            // We count on the fact that all Gift have IDs starting at 1 and increasing\r\n            // sequentially up to the totalCat count.\r\n            uint256 GiftId;\r\n            \r\n            // scan array and filter Gift of owner\r\n            for (GiftId = 0; GiftId <= total; GiftId++) {\r\n                if (GiftIndexToOwners[GiftId] == _owner) {\r\n                    result[resultIndex] = GiftId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n    \r\n    /// @dev Returns a Gift IDs assigned to an address.\r\n    /// @param _owner The owner whose Gift we are interested in.\r\n    /// @param _index to owner Gift list\r\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\r\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\r\n    ///  it is only supported for web3 calls, and\r\n    ///  not contract-to-contract calls.\r\n    function giftOwnerByIndex(address _owner, uint256 _index)\r\n    external\r\n    constant \r\n    returns (uint256 GiftId) {\r\n        uint256[] memory ownerGifts = GiftsOfOwner(_owner);\r\n        return ownerGifts[_index];\r\n    }\r\n    \r\n    /// @dev get Gift metadata (url) from GiftLinks\r\n    /// @param _GiftId : Gift id\r\n    /// @return infoUrl : url of Gift\r\n    function GiftMetadata(uint256 _GiftId)\r\n    public\r\n    constant\r\n    returns (string infoUrl) {\r\n        return GiftLinks[_GiftId];\r\n    }\r\n    \r\n    /// @dev function create new Gift\r\n    /// @param _price : Gift property\r\n    /// @param _description : Gift property\r\n    /// @return GiftId\r\n    function createGift(uint256 _price, string _description, string _url)\r\n    public\r\n    onlyOwner\r\n    returns (uint256) {\r\n        // save temporarily new Gift\r\n        Gift memory newGift = Gift({\r\n            price: _price,\r\n            description: _description\r\n        });\r\n        // push to array and return the length is the id of new Gift\r\n        uint256 newGiftId = giftStorage.push(newGift) - 1;\r\n        // turn on existen\r\n        GiftExists[newGiftId] = true;\r\n        // assin gift url\r\n        GiftLinks[newGiftId] = _url;\r\n        // event create new Gift for msg.sender\r\n        Creation(msg.sender, newGiftId);\r\n        \r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(0, msg.sender, newGiftId);\r\n        \r\n        return newGiftId;\r\n    }\r\n    \r\n    /// @dev get Gift property\r\n    /// @param GiftId : id of Gift\r\n    /// @return properties of Gift\r\n    function getGift(uint256 GiftId)\r\n    public\r\n    constant \r\n    returns (uint256, string){\r\n        if(GiftId > giftStorage.length){\r\n            return (0, \"\");\r\n        }\r\n        Gift memory newGift = giftStorage[GiftId];\r\n        return (newGift.price, newGift.description);\r\n    }\r\n    \r\n    /// @dev change gift properties\r\n    /// @param GiftId : to change\r\n    /// @param _price : new price of gift\r\n    /// @param _description : new description\r\n    /// @param _giftUrl : new url \r\n    function updateGift(uint256 GiftId, uint256 _price, string _description, string _giftUrl)\r\n    public\r\n    onlyOwner {\r\n        // check Gift exist First\r\n        require(GiftExists[GiftId]);\r\n        // setting new properties\r\n        giftStorage[GiftId].price = _price;\r\n        giftStorage[GiftId].description = _description;\r\n        GiftLinks[GiftId] = _giftUrl;\r\n    }\r\n    \r\n    /// @dev remove gift \r\n    /// @param GiftId : gift id to remove\r\n    function removeGift(uint256 GiftId)\r\n    public\r\n    onlyOwner {\r\n        // just setting GiftExists equal to false\r\n        GiftExists[GiftId] = false;\r\n    }\r\n    \r\n    /// @dev withdraw GTO in this contract\r\n    function withdrawGTO()\r\n    onlyOwner\r\n    public {\r\n        GTO.transfer(owner, GTO.balanceOf(address(this)));\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_GiftId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_GiftId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"GiftId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_giftUrl\",\"type\":\"string\"}],\"name\":\"updateGift\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawGTO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"giftOwnerByIndex\",\"outputs\":[{\"name\":\"GiftId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeGTOAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"GiftsOfOwner\",\"outputs\":[{\"name\":\"ownerGifts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_GiftId\",\"type\":\"uint256\"}],\"name\":\"GiftMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_GiftId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"GiftId\",\"type\":\"uint256\"}],\"name\":\"sendGift\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"GiftId\",\"type\":\"uint256\"}],\"name\":\"removeGift\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGTOAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_GiftId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"},{\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"createGift\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_GiftId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"GiftId\",\"type\":\"uint256\"}],\"name\":\"getGift\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"GiftId\",\"type\":\"uint256\"}],\"name\":\"isExist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"GiftId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"GiftId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_GiftId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_GiftId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"GiftId\",\"type\":\"uint256\"}],\"name\":\"Creation\",\"type\":\"event\"}]","ContractName":"VirtualGift","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a2e49411b8b3459abd2801f8b6271c168d85abe5aa91b462fbbc9efdfcd46734"}]}