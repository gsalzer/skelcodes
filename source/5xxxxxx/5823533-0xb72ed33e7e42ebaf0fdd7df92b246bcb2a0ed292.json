{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/// @title ServiceAllowance.\r\n///\r\n/// Provides a way to delegate operation allowance decision to a service contract\r\ncontract ServiceAllowance {\r\n    function isTransferAllowed(address _from, address _to, address _sender, address _token, uint _value) public view returns (bool);\r\n}\r\n\r\n/**\r\n * @title Owned contract with safe ownership pass.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public contractOwner;\r\n\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public pendingContractOwner;\r\n\r\n    function Owned() {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner check modifier\r\n    */\r\n    modifier onlyContractOwner() {\r\n        if (contractOwner == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can call it\r\n     */\r\n    function destroy() onlyContractOwner {\r\n        suicide(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Prepares ownership pass.\r\n     *\r\n     * Can only be called by current owner.\r\n     *\r\n     * @param _to address of the next owner. 0x0 is not allowed.\r\n     *\r\n     * @return success.\r\n     */\r\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\r\n        if (_to  == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Finalize ownership pass.\r\n     *\r\n     * Can only be called by pending owner.\r\n     *\r\n     * @return success.\r\n     */\r\n    function claimContractOwnership() returns(bool) {\r\n        if (pendingContractOwner != msg.sender) {\r\n            return false;\r\n        }\r\n\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\r\n\r\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\r\n        for(uint i=0;i<tokens.length;i++) {\r\n            address token = tokens[i];\r\n            uint balance = ERC20Interface(token).balanceOf(this);\r\n            if(balance != 0)\r\n                ERC20Interface(token).transfer(_to,balance);\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function checkOnlyContractOwner() internal constant returns(uint) {\r\n        if (contractOwner == msg.sender) {\r\n            return OK;\r\n        }\r\n\r\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\r\n    }\r\n}\r\n\r\ncontract OracleContractAdapter is Object {\r\n\r\n    event OracleAdded(address _oracle);\r\n    event OracleRemoved(address _oracle);\r\n\r\n    mapping(address => bool) public oracles;\r\n\r\n    /// @dev Allow access only for oracle\r\n    modifier onlyOracle {\r\n        if (oracles[msg.sender]) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    modifier onlyOracleOrOwner {\r\n        if (oracles[msg.sender] || msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /// @notice Add oracles to whitelist.\r\n    ///\r\n    /// @param _whitelist user list.\r\n    function addOracles(address[] _whitelist) external onlyContractOwner returns (uint)    {\r\n        for (uint _idx = 0; _idx < _whitelist.length; ++_idx) {\r\n            address _oracle = _whitelist[_idx];\r\n            if (!oracles[_oracle]) {\r\n                oracles[_oracle] = true;\r\n                _emitOracleAdded(_oracle);\r\n            }\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Removes oracles from whitelist.\r\n    ///\r\n    /// @param _blacklist user in whitelist.\r\n    function removeOracles(address[] _blacklist) external onlyContractOwner returns (uint)    {\r\n        for (uint _idx = 0; _idx < _blacklist.length; ++_idx) {\r\n            address _oracle = _blacklist[_idx];\r\n            if (oracles[_oracle]) {\r\n                delete oracles[_oracle];\r\n                _emitOracleRemoved(_oracle);\r\n            }\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function _emitOracleAdded(address _oracle) internal {\r\n        OracleAdded(_oracle);\r\n    }\r\n\r\n    function _emitOracleRemoved(address _oracle) internal {\r\n        OracleRemoved(_oracle);\r\n    }\r\n}\r\n\r\ncontract TreasuryEmitter {\r\n    event TreasuryDeposited(bytes32 userKey, uint value, uint lockupDate);\r\n    event TreasuryWithdrawn(bytes32 userKey, uint value);\r\n}\r\n\r\ncontract ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n\r\n\r\n/// @title Treasury contract.\r\n///\r\n/// Treasury for CCs deposits for particular fund with bmc-days calculations.\r\n/// Accept BMC deposits from Continuous Contributors via oracle and\r\n/// calculates bmc-days metric for each CC's role.\r\ncontract Treasury is OracleContractAdapter, ServiceAllowance, TreasuryEmitter {\r\n\r\n    /* ERROR CODES */\r\n\r\n    uint constant PERCENT_PRECISION = 10000;\r\n\r\n    uint constant TREASURY_ERROR_SCOPE = 108000;\r\n    uint constant TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE = TREASURY_ERROR_SCOPE + 1;\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct LockedDeposits {\r\n        uint counter;\r\n        mapping(uint => uint) index2Date;\r\n        mapping(uint => uint) date2deposit;\r\n    }\r\n\r\n    struct Period {\r\n        uint transfersCount;\r\n        uint totalBmcDays;\r\n        uint bmcDaysPerDay;\r\n        uint startDate;\r\n        mapping(bytes32 => uint) user2bmcDays;\r\n        mapping(bytes32 => uint) user2lastTransferIdx;\r\n        mapping(bytes32 => uint) user2balance;\r\n        mapping(uint => uint) transfer2date;\r\n    }\r\n\r\n    /* FIELDS */\r\n\r\n    address token;\r\n    address profiterole;\r\n    uint periodsCount;\r\n\r\n    mapping(uint => Period) periods;\r\n    mapping(uint => uint) periodDate2periodIdx;\r\n    mapping(bytes32 => uint) user2lastPeriodParticipated;\r\n    mapping(bytes32 => LockedDeposits) user2lockedDeposits;\r\n\r\n    /* MODIFIERS */\r\n\r\n    /// @dev Only profiterole contract allowed to invoke guarded functions\r\n    modifier onlyProfiterole {\r\n        require(profiterole == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /* PUBLIC */\r\n    \r\n    function Treasury(address _token) public {\r\n        require(address(_token) != 0x0);\r\n        token = _token;\r\n        periodsCount = 1;\r\n    }\r\n\r\n    function init(address _profiterole) public onlyContractOwner returns (uint) {\r\n        require(_profiterole != 0x0);\r\n        profiterole = _profiterole;\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Do not accept Ether transfers\r\n    function() payable public {\r\n        revert();\r\n    }\r\n\r\n    /* EXTERNAL */\r\n\r\n    /// @notice Deposits tokens on behalf of users\r\n    /// Allowed only for oracle.\r\n    ///\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @param _value amount of tokens to deposit\r\n    /// @param _feeAmount amount of tokens that will be taken from _value as fee\r\n    /// @param _feeAddress destination address for fee transfer\r\n    /// @param _lockupDate lock up date for deposit. Until that date the deposited value couldn't be withdrawn\r\n    ///\r\n    /// @return result code of an operation\r\n    function deposit(bytes32 _userKey, uint _value, uint _feeAmount, address _feeAddress, uint _lockupDate) external onlyOracle returns (uint) {\r\n        require(_userKey != bytes32(0));\r\n        require(_value != 0);\r\n        require(_feeAmount < _value);\r\n\r\n        ERC20 _token = ERC20(token);\r\n        if (_token.allowance(msg.sender, address(this)) < _value) {\r\n            return TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE;\r\n        }\r\n\r\n        uint _depositedAmount = _value - _feeAmount;\r\n        _makeDepositForPeriod(_userKey, _depositedAmount, _lockupDate);\r\n\r\n        uint _periodsCount = periodsCount;\r\n        user2lastPeriodParticipated[_userKey] = _periodsCount;\r\n        delete periods[_periodsCount].startDate;\r\n\r\n        if (!_token.transferFrom(msg.sender, address(this), _value)) {\r\n            revert();\r\n        }\r\n\r\n        if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {\r\n            revert();\r\n        }\r\n\r\n        TreasuryDeposited(_userKey, _depositedAmount, _lockupDate);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Withdraws deposited tokens on behalf of users\r\n    /// Allowed only for oracle\r\n    ///\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @param _value an amount of tokens that is requrested to withdraw\r\n    /// @param _withdrawAddress address to withdraw; should not be 0x0\r\n    /// @param _feeAmount amount of tokens that will be taken from _value as fee\r\n    /// @param _feeAddress destination address for fee transfer\r\n    ///\r\n    /// @return result of an operation\r\n    function withdraw(bytes32 _userKey, uint _value, address _withdrawAddress, uint _feeAmount, address _feeAddress) external onlyOracle returns (uint) {\r\n        require(_userKey != bytes32(0));\r\n        require(_value != 0);\r\n        require(_feeAmount < _value);\r\n\r\n        _makeWithdrawForPeriod(_userKey, _value);\r\n        uint _periodsCount = periodsCount;\r\n        user2lastPeriodParticipated[_userKey] = periodsCount;\r\n        delete periods[_periodsCount].startDate;\r\n\r\n        ERC20 _token = ERC20(token);\r\n        if (!(_feeAddress == 0x0 || _feeAmount == 0 || _token.transfer(_feeAddress, _feeAmount))) {\r\n            revert();\r\n        }\r\n\r\n        uint _withdrawnAmount = _value - _feeAmount;\r\n        if (!_token.transfer(_withdrawAddress, _withdrawnAmount)) {\r\n            revert();\r\n        }\r\n\r\n        TreasuryWithdrawn(_userKey, _withdrawnAmount);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Gets shares (in percents) the user has on provided date\r\n    ///\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @param _date date where period ends\r\n    ///\r\n    /// @return percent from total amount of bmc-days the treasury has on this date.\r\n    /// Use PERCENT_PRECISION to get right precision\r\n    function getSharesPercentForPeriod(bytes32 _userKey, uint _date) public view returns (uint) {\r\n        uint _periodIdx = periodDate2periodIdx[_date];\r\n        if (_date != 0 && _periodIdx == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (_date == 0) {\r\n            _date = now;\r\n            _periodIdx = periodsCount;\r\n        }\r\n\r\n        uint _bmcDays = _getBmcDaysAmountForUser(_userKey, _date, _periodIdx);\r\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(_date, _periodIdx);\r\n        return _totalBmcDeposit != 0 ? _bmcDays * PERCENT_PRECISION / _totalBmcDeposit : 0;\r\n    }\r\n\r\n    /// @notice Gets user balance that is deposited\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @return an amount of tokens deposited on behalf of user\r\n    function getUserBalance(bytes32 _userKey) public view returns (uint) {\r\n        uint _lastPeriodForUser = user2lastPeriodParticipated[_userKey];\r\n        if (_lastPeriodForUser == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (_lastPeriodForUser <= periodsCount.sub(1)) {\r\n            return periods[_lastPeriodForUser].user2balance[_userKey];\r\n        }\r\n\r\n        return periods[periodsCount].user2balance[_userKey];\r\n    }\r\n\r\n    /// @notice Gets amount of locked deposits for user\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @return an amount of tokens locked\r\n    function getLockedUserBalance(bytes32 _userKey) public returns (uint) {\r\n        return _syncLockedDepositsAmount(_userKey);\r\n    }\r\n\r\n    /// @notice Gets list of locked up deposits with dates when they will be available to withdraw\r\n    /// @param _userKey aggregated user key (user ID + role ID)\r\n    /// @return {\r\n    ///     \"_lockupDates\": \"list of lockup dates of deposits\",\r\n    ///     \"_deposits\": \"list of deposits\"\r\n    /// }\r\n    function getLockedUserDeposits(bytes32 _userKey) public view returns (uint[] _lockupDates, uint[] _deposits) {\r\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\r\n        uint _lockedDepositsCounter = _lockedDeposits.counter;\r\n        _lockupDates = new uint[](_lockedDepositsCounter);\r\n        _deposits = new uint[](_lockedDepositsCounter);\r\n\r\n        uint _pointer = 0;\r\n        for (uint _idx = 1; _idx < _lockedDepositsCounter; ++_idx) {\r\n            uint _lockDate = _lockedDeposits.index2Date[_idx];\r\n\r\n            if (_lockDate > now) {\r\n                _lockupDates[_pointer] = _lockDate;\r\n                _deposits[_pointer] = _lockedDeposits.date2deposit[_lockDate];\r\n                ++_pointer;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Gets total amount of bmc-day accumulated due provided date\r\n    /// @param _date date where period ends\r\n    /// @return an amount of bmc-days\r\n    function getTotalBmcDaysAmount(uint _date) public view returns (uint) {\r\n        return _getTotalBmcDaysAmount(_date, periodsCount);\r\n    }\r\n\r\n    /// @notice Makes a checkpoint to start counting a new period\r\n    /// @dev Should be used only by Profiterole contract\r\n    function addDistributionPeriod() public onlyProfiterole returns (uint) {\r\n        uint _periodsCount = periodsCount;\r\n        uint _nextPeriod = _periodsCount.add(1);\r\n        periodDate2periodIdx[now] = _periodsCount;\r\n\r\n        Period storage _previousPeriod = periods[_periodsCount];\r\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(now, _periodsCount);\r\n        periods[_nextPeriod].startDate = now;\r\n        periods[_nextPeriod].bmcDaysPerDay = _previousPeriod.bmcDaysPerDay;\r\n        periods[_nextPeriod].totalBmcDays = _totalBmcDeposit;\r\n        periodsCount = _nextPeriod;\r\n\r\n        return OK;\r\n    }\r\n\r\n    function isTransferAllowed(address, address, address, address, uint) public view returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /* INTERNAL */\r\n\r\n    function _makeDepositForPeriod(bytes32 _userKey, uint _value, uint _lockupDate) internal {\r\n        Period storage _transferPeriod = periods[periodsCount];\r\n\r\n        _transferPeriod.user2bmcDays[_userKey] = _getBmcDaysAmountForUser(_userKey, now, periodsCount);\r\n        _transferPeriod.totalBmcDays = _getTotalBmcDaysAmount(now, periodsCount);\r\n        _transferPeriod.bmcDaysPerDay = _transferPeriod.bmcDaysPerDay.add(_value);\r\n\r\n        uint _userBalance = getUserBalance(_userKey);\r\n        uint _updatedTransfersCount = _transferPeriod.transfersCount.add(1);\r\n        _transferPeriod.transfersCount = _updatedTransfersCount;\r\n        _transferPeriod.transfer2date[_transferPeriod.transfersCount] = now;\r\n        _transferPeriod.user2balance[_userKey] = _userBalance.add(_value);\r\n        _transferPeriod.user2lastTransferIdx[_userKey] = _updatedTransfersCount;\r\n\r\n        _registerLockedDeposits(_userKey, _value, _lockupDate);\r\n    }\r\n\r\n    function _makeWithdrawForPeriod(bytes32 _userKey, uint _value) internal {\r\n        uint _userBalance = getUserBalance(_userKey);\r\n        uint _lockedBalance = _syncLockedDepositsAmount(_userKey);\r\n        require(_userBalance.sub(_lockedBalance) >= _value);\r\n\r\n        uint _periodsCount = periodsCount;\r\n        Period storage _transferPeriod = periods[_periodsCount];\r\n\r\n        _transferPeriod.user2bmcDays[_userKey] = _getBmcDaysAmountForUser(_userKey, now, _periodsCount);\r\n        uint _totalBmcDeposit = _getTotalBmcDaysAmount(now, _periodsCount);\r\n        _transferPeriod.totalBmcDays = _totalBmcDeposit;\r\n        _transferPeriod.bmcDaysPerDay = _transferPeriod.bmcDaysPerDay.sub(_value);\r\n\r\n        uint _updatedTransferCount = _transferPeriod.transfersCount.add(1);\r\n        _transferPeriod.transfer2date[_updatedTransferCount] = now;\r\n        _transferPeriod.user2lastTransferIdx[_userKey] = _updatedTransferCount;\r\n        _transferPeriod.user2balance[_userKey] = _userBalance.sub(_value);\r\n        _transferPeriod.transfersCount = _updatedTransferCount;\r\n    }\r\n\r\n    function _registerLockedDeposits(bytes32 _userKey, uint _amount, uint _lockupDate) internal {\r\n        if (_lockupDate <= now) {\r\n            return;\r\n        }\r\n\r\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\r\n        uint _lockedBalance = _lockedDeposits.date2deposit[_lockupDate];\r\n\r\n        if (_lockedBalance == 0) {\r\n            uint _lockedDepositsCounter = _lockedDeposits.counter.add(1);\r\n            _lockedDeposits.counter = _lockedDepositsCounter;\r\n            _lockedDeposits.index2Date[_lockedDepositsCounter] = _lockupDate;\r\n        }\r\n        _lockedDeposits.date2deposit[_lockupDate] = _lockedBalance.add(_amount);\r\n    }\r\n\r\n    function _syncLockedDepositsAmount(bytes32 _userKey) internal returns (uint _lockedSum) {\r\n        LockedDeposits storage _lockedDeposits = user2lockedDeposits[_userKey];\r\n        uint _lockedDepositsCounter = _lockedDeposits.counter;\r\n\r\n        for (uint _idx = 1; _idx <= _lockedDepositsCounter; ++_idx) {\r\n            uint _lockDate = _lockedDeposits.index2Date[_idx];\r\n\r\n            if (_lockDate <= now) {\r\n                _lockedDeposits.index2Date[_idx] = _lockedDeposits.index2Date[_lockedDepositsCounter];\r\n\r\n                delete _lockedDeposits.index2Date[_lockedDepositsCounter];\r\n                delete _lockedDeposits.date2deposit[_lockDate];\r\n\r\n                _lockedDepositsCounter = _lockedDepositsCounter.sub(1);\r\n                continue;\r\n            }\r\n\r\n            _lockedSum = _lockedSum.add(_lockedDeposits.date2deposit[_lockDate]);\r\n        }\r\n\r\n        _lockedDeposits.counter = _lockedDepositsCounter;\r\n    }\r\n\r\n    function _getBmcDaysAmountForUser(bytes32 _userKey, uint _date, uint _periodIdx) internal view returns (uint) {\r\n        uint _lastPeriodForUserIdx = user2lastPeriodParticipated[_userKey];\r\n        if (_lastPeriodForUserIdx == 0) {\r\n            return 0;\r\n        }\r\n\r\n        Period storage _transferPeriod = _lastPeriodForUserIdx <= _periodIdx ? periods[_lastPeriodForUserIdx] : periods[_periodIdx];\r\n        uint _lastTransferDate = _transferPeriod.transfer2date[_transferPeriod.user2lastTransferIdx[_userKey]];\r\n        // NOTE: It is an intended substraction separation to correctly round dates\r\n        uint _daysLong = (_date / 1 days) - (_lastTransferDate / 1 days);\r\n        uint _bmcDays = _transferPeriod.user2bmcDays[_userKey];\r\n        return _bmcDays.add(_transferPeriod.user2balance[_userKey] * _daysLong);\r\n    }\r\n\r\n    /* PRIVATE */\r\n\r\n    function _getTotalBmcDaysAmount(uint _date, uint _periodIdx) private view returns (uint) {\r\n        Period storage _depositPeriod = periods[_periodIdx];\r\n        uint _transfersCount = _depositPeriod.transfersCount;\r\n        uint _lastRecordedDate = _transfersCount != 0 ? _depositPeriod.transfer2date[_transfersCount] : _depositPeriod.startDate;\r\n\r\n        if (_lastRecordedDate == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // NOTE: It is an intended substraction separation to correctly round dates\r\n        uint _daysLong = (_date / 1 days).sub((_lastRecordedDate / 1 days));\r\n        uint _totalBmcDeposit = _depositPeriod.totalBmcDays.add(_depositPeriod.bmcDaysPerDay.mul(_daysLong));\r\n        return _totalBmcDeposit;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_profiterole\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"},{\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"getSharesPercentForPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelist\",\"type\":\"address[]\"}],\"name\":\"addOracles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blacklist\",\"type\":\"address[]\"}],\"name\":\"removeOracles\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"getTotalBmcDaysAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_withdrawAddress\",\"type\":\"address\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracles\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addDistributionPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"}],\"name\":\"getLockedUserBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"}],\"name\":\"getLockedUserDeposits\",\"outputs\":[{\"name\":\"_lockupDates\",\"type\":\"uint256[]\"},{\"name\":\"_deposits\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userKey\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"name\":\"_feeAddress\",\"type\":\"address\"},{\"name\":\"_lockupDate\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"userKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockupDate\",\"type\":\"uint256\"}],\"name\":\"TreasuryDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"userKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TreasuryWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"OracleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"OracleRemoved\",\"type\":\"event\"}]","ContractName":"Treasury","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000df6ef343350780bf8c3410bf062e0c015b1dd671","Library":"","SwarmSource":"bzzr://543879421ae50f7552f1657a587465813019dab45b2c698cd2bd02c005ab9e7d"}]}