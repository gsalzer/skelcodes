{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract Manager {\r\n    address public ceo;\r\n    address public cfo;\r\n    address public coo;\r\n    address public cao;\r\n\r\n    event OwnershipTransferred(address previousCeo, address newCeo);\r\n    event Pause();\r\n    event Unpause();\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Manager() public {\r\n        coo = msg.sender; \r\n        cfo = 0x7810704C6197aFA95e940eF6F719dF32657AD5af;\r\n        ceo = 0x96C0815aF056c5294Ad368e3FBDb39a1c9Ae4e2B;\r\n        cao = 0xC4888491B404FfD15cA7F599D624b12a9D845725;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceo);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == coo);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCAO() {\r\n        require(msg.sender == cao);\r\n        _;\r\n    }\r\n    \r\n    bool allowTransfer = false;\r\n    \r\n    function changeAllowTransferState() public onlyCOO {\r\n        if (allowTransfer) {\r\n            allowTransfer = false;\r\n        } else {\r\n            allowTransfer = true;\r\n        }\r\n    }\r\n    \r\n    modifier whenTransferAllowed() {\r\n        require(allowTransfer);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newCeo.\r\n    * @param newCeo The address to transfer ownership to.\r\n    */\r\n    function demiseCEO(address newCeo) public onlyCEO {\r\n        require(newCeo != address(0));\r\n        emit OwnershipTransferred(ceo, newCeo);\r\n        ceo = newCeo;\r\n    }\r\n\r\n    function setCFO(address newCfo) public onlyCEO {\r\n        require(newCfo != address(0));\r\n        cfo = newCfo;\r\n    }\r\n\r\n    function setCOO(address newCoo) public onlyCEO {\r\n        require(newCoo != address(0));\r\n        coo = newCoo;\r\n    }\r\n\r\n    function setCAO(address newCao) public onlyCEO {\r\n        require(newCao != address(0));\r\n        cao = newCao;\r\n    }\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyCAO whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyCAO whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n\r\ncontract AlchemyBase is Manager {\r\n\r\n    // Assets of each account\r\n    mapping (address => bytes32[8]) assets;\r\n\r\n    // Event\r\n    event Transfer(address from, address to);\r\n\r\n    // Get all assets of a particular account\r\n    function assetOf(address account) public view returns(bytes32[8]) {\r\n        return assets[account];\r\n    }\r\n\r\n    function _checkAndAdd(bytes32 x, bytes32 y) internal pure returns(bytes32) {\r\n        bytes32 mask = bytes32(255); // 0x11111111\r\n\r\n        bytes32 result;\r\n\r\n        uint maskedX;\r\n        uint maskedY;\r\n        uint maskedResult;\r\n\r\n        for (uint i = 0; i < 31; i++) {\r\n            // Get current mask\r\n            if (i > 0) {\r\n                mask = mask << 8;\r\n            }\r\n\r\n            // Get masked values\r\n            maskedX = uint(x & mask);\r\n            maskedY = uint(y & mask);\r\n            maskedResult = maskedX + maskedY;\r\n\r\n            // Prevent overflow\r\n            require(maskedResult < (2 ** (8 * (i + 1))));\r\n\r\n            // Clear result digits in masked position\r\n            result = (result ^ mask) & result;\r\n\r\n            // Write to result\r\n            result = result | bytes32(maskedResult);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function _checkAndSub(bytes32 x, bytes32 y) internal pure returns(bytes32) {\r\n        bytes32 mask = bytes32(255); // 0x11111111\r\n\r\n        bytes32 result;\r\n\r\n        uint maskedX;\r\n        uint maskedY;\r\n        uint maskedResult;\r\n\r\n        for (uint i = 0; i < 31; i++) {\r\n            // Get current mask\r\n            if (i > 0) {\r\n                mask = mask << 8;\r\n            }\r\n\r\n            // Get masked values\r\n            maskedX = uint(x & mask);\r\n            maskedY = uint(y & mask);\r\n\r\n            // Ensure x >= y\r\n            require(maskedX >= maskedY);\r\n\r\n            // Calculate result\r\n            maskedResult = maskedX - maskedY;\r\n\r\n            // Clear result digits in masked position\r\n            result = (result ^ mask) & result;\r\n\r\n            // Write to result\r\n            result = result | bytes32(maskedResult);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Transfer assets from one account to another\r\n    function transfer(address to, bytes32[8] value) public whenNotPaused whenTransferAllowed {\r\n        // One can not transfer assets to self\r\n        require(msg.sender != to);\r\n        bytes32[8] memory assetFrom = assets[msg.sender];\r\n        bytes32[8] memory assetTo = assets[to];\r\n\r\n        for (uint256 i = 0; i < 8; i++) {\r\n            assetFrom[i] = _checkAndSub(assetFrom[i], value[i]);\r\n            assetTo[i] = _checkAndAdd(assetTo[i], value[i]);\r\n        }\r\n\r\n        assets[msg.sender] = assetFrom;\r\n        assets[to] = assetTo;\r\n\r\n        // Emit the transfer event\r\n        emit Transfer(msg.sender, to);\r\n    }\r\n\r\n    // Withdraw ETH to the owner account. Ownable-->Pausable-->AlchemyBase\r\n    function withdrawETH() external onlyCAO {\r\n        cfo.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\n\r\ncontract AlchemyPatent is AlchemyBase {\r\n\r\n    // patent struct\r\n    struct Patent {\r\n        // current patent owner\r\n        address patentOwner;\r\n        // the time when owner get the patent\r\n        uint256 beginTime;\r\n        // whether this patent is on sale\r\n        bool onSale; \r\n        // the sale price\r\n        uint256 price;\r\n        // last deal price\r\n        uint256 lastPrice;\r\n        // the time when this sale is put on\r\n        uint256 sellTime;\r\n    }\r\n\r\n    // Creator of each kind of asset\r\n    mapping (uint16 => Patent) public patents;\r\n\r\n    // patent fee ratio\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public feeRatio = 9705;\r\n\r\n    uint256 public patentValidTime = 2 days;\r\n    uint256 public patentSaleTimeDelay = 2 hours;\r\n\r\n    // Event\r\n    event RegisterCreator(address account, uint16 kind);\r\n    event SellPatent(uint16 assetId, uint256 sellPrice);\r\n    event ChangePatentSale(uint16 assetId, uint256 newPrice);\r\n    event BuyPatent(uint16 assetId, address buyer);\r\n\r\n    // set the patent fee ratio\r\n    function setPatentFee(uint256 newFeeRatio) external onlyCOO {\r\n        require(newFeeRatio <= 10000);\r\n        feeRatio = newFeeRatio;\r\n    }\r\n\r\n    // sell the patent\r\n    function sellPatent(uint16 assetId, uint256 sellPrice) public whenNotPaused {\r\n        Patent memory patent = patents[assetId];\r\n        require(patent.patentOwner == msg.sender);\r\n        require(sellPrice <= 2 * patent.lastPrice);\r\n        require(!patent.onSale);\r\n\r\n        patent.onSale = true;\r\n        patent.price = sellPrice;\r\n        patent.sellTime = now;\r\n\r\n        patents[assetId] = patent;\r\n\r\n        // Emit the event\r\n        emit SellPatent(assetId, sellPrice);\r\n    }\r\n\r\n    function publicSell(uint16 assetId) public whenNotPaused {\r\n        Patent memory patent = patents[assetId];\r\n        require(patent.patentOwner != address(0));  // this is a valid patent\r\n        require(!patent.onSale);\r\n        require(patent.beginTime + patentValidTime < now);\r\n\r\n        patent.onSale = true;\r\n        patent.price = patent.lastPrice;\r\n        patent.sellTime = now;\r\n\r\n        patents[assetId] = patent;\r\n\r\n        // Emit the event\r\n        emit SellPatent(assetId, patent.lastPrice);\r\n    }\r\n\r\n    // change sell price\r\n    function changePatentSale(uint16 assetId, uint256 newPrice) external whenNotPaused {\r\n        Patent memory patent = patents[assetId];\r\n        require(patent.patentOwner == msg.sender);\r\n        require(newPrice <= 2 * patent.lastPrice);\r\n        require(patent.onSale == true);\r\n\r\n        patent.price = newPrice;\r\n\r\n        patents[assetId] = patent;\r\n\r\n        // Emit the event\r\n        emit ChangePatentSale(assetId, newPrice);\r\n    }\r\n\r\n    // buy patent\r\n    function buyPatent(uint16 assetId) external payable whenNotPaused {\r\n        Patent memory patent = patents[assetId];\r\n        require(patent.patentOwner != address(0));  // this is a valid patent\r\n        require(patent.patentOwner != msg.sender);\r\n        require(patent.onSale);\r\n        require(msg.value >= patent.price);\r\n        require(now >= patent.sellTime + patentSaleTimeDelay);\r\n\r\n        patent.patentOwner.transfer(patent.price / 10000 * feeRatio);\r\n        patent.patentOwner = msg.sender;\r\n        patent.beginTime = now;\r\n        patent.onSale = false;\r\n        patent.lastPrice = patent.price;\r\n\r\n        patents[assetId] = patent;\r\n\r\n        //Emit the event\r\n        emit BuyPatent(assetId, msg.sender);\r\n    }\r\n}\r\n\r\ncontract ChemistryInterface {\r\n    function isChemistry() public pure returns (bool);\r\n\r\n    // function turnOnFurnace(bytes32 x0, bytes32 x1, bytes32 x2, bytes32 x3) public returns (bytes32 r0, bytes32 r1, bytes32 r2, bytes32 r3);\r\n    function turnOnFurnace(uint16[5] inputAssets, uint128 addition) public returns (uint16[5]);\r\n\r\n    function computeCooldownTime(uint128 typeAdd, uint256 baseTime) public returns (uint256);\r\n}\r\n\r\n\r\n\r\ncontract SkinInterface {\r\n    function getActiveSkin(address account) public view returns (uint128);\r\n}\r\n\r\n\r\n\r\ncontract AlchemySynthesize is AlchemyPatent {\r\n\r\n    // Synthesize formula\r\n    ChemistryInterface public chemistry;\r\n    SkinInterface public skinContract;\r\n\r\n    // Cooldown after submit a after submit a transformation request\r\n    uint256[9] public cooldownLevels = [\r\n        5 minutes,\r\n        10 minutes,\r\n        15 minutes,\r\n        20 minutes,\r\n        25 minutes,\r\n        30 minutes,\r\n        35 minutes,\r\n        40 minutes,\r\n        45 minutes\r\n    ];\r\n\r\n    // patent fee for each level \r\n    uint256[9] public pFees = [\r\n        0,\r\n        10 finney,\r\n        15 finney,\r\n        20 finney,\r\n        25 finney,\r\n        30 finney,\r\n        35 finney,\r\n        40 finney,\r\n        45 finney\r\n    ];\r\n\r\n    // alchemy furnace struct\r\n    struct Furnace {\r\n        // the pending assets for synthesize\r\n        uint16[5] pendingAssets;\r\n        // cooldown end time of synthesise\r\n        uint256 cooldownEndTime;\r\n        // whether this furnace is using\r\n        bool inSynthesization;\r\n    }\r\n\r\n    // furnace of each account\r\n    mapping (address => Furnace) public accountsToFurnace;\r\n\r\n    // alchemy level of each asset\r\n    mapping (uint16 => uint256) public assetLevel;\r\n\r\n    // Pre-paid ether for synthesization, will be returned to user if the synthesization failed (minus gas).\r\n    uint256 public prePaidFee = 1000000 * 3000000000; // (1million gas * 3 gwei)\r\n\r\n    bool public isSynthesizeAllowed = false;\r\n\r\n    // When a synthesization request starts, our daemon needs to call getSynthesizationResult() after cooldown.\r\n    // event SynthesizeStart(address account);\r\n    event AutoSynthesize(address account, uint256 cooldownEndTime);\r\n    event SynthesizeSuccess(address account);\r\n\r\n    // Initialize the asset level\r\n    function initializeLevel() public onlyCOO {\r\n        // Level of assets\r\n        uint8[9] memory levelSplits = [4,     // end of level 0. start of level is 0\r\n                                          19,    // end of level 1\r\n                                          46,    // end of level 2\r\n                                          82,    // end of level 3\r\n                                          125,   // end of level 4\r\n                                          156,\r\n                                          180,\r\n                                          195,\r\n                                          198];  // end of level 8\r\n        uint256 currentLevel = 0;\r\n        for (uint8 i = 0; i < 198; i ++) {\r\n            if (i == levelSplits[currentLevel]) {\r\n                currentLevel ++;\r\n            }\r\n            assetLevel[uint16(i)] = currentLevel;\r\n        }\r\n    }\r\n\r\n    function setAssetLevel(uint16 assetId, uint256 level) public onlyCOO {\r\n        assetLevel[assetId] = level;\r\n    }\r\n\r\n    function changeSynthesizeAllowed(bool newState) external onlyCOO {\r\n        isSynthesizeAllowed = newState;\r\n    }\r\n\r\n    // Get furnace information\r\n    function getFurnace(address account) public view returns (uint16[5], uint256, bool) {\r\n        return (accountsToFurnace[account].pendingAssets, accountsToFurnace[account].cooldownEndTime, accountsToFurnace[account].inSynthesization);\r\n    }\r\n\r\n    // Set chemistry science contract address\r\n    function setChemistryAddress(address chemistryAddress) external onlyCOO {\r\n        ChemistryInterface candidateContract = ChemistryInterface(chemistryAddress);\r\n\r\n        require(candidateContract.isChemistry());\r\n\r\n        chemistry = candidateContract;\r\n    }\r\n\r\n    // Set skin contract address\r\n    function setSkinContract(address skinAddress) external onlyCOO {\r\n        skinContract = SkinInterface(skinAddress);\r\n    }\r\n\r\n    // setPrePaidFee: set advance amount, only owner can call this\r\n    function setPrePaidFee(uint256 newPrePaidFee) external onlyCOO {\r\n        prePaidFee = newPrePaidFee;\r\n    }\r\n\r\n    // _isCooldownReady: check whether cooldown period has been passed\r\n    function _isCooldownReady(address account) internal view returns (bool) {\r\n        return (accountsToFurnace[account].cooldownEndTime <= now);\r\n    }\r\n\r\n    // synthesize: call _isCooldownReady, pending assets, fire SynthesizeStart event\r\n    function synthesize(uint16[5] inputAssets) public payable whenNotPaused {\r\n        require(isSynthesizeAllowed == true);\r\n        // Check msg.sender is not in another synthesizing process\r\n        require(accountsToFurnace[msg.sender].inSynthesization == false);\r\n\r\n        // Check whether assets are valid\r\n        bytes32[8] memory asset = assets[msg.sender];\r\n\r\n        bytes32 mask; // 0x11111111\r\n        uint256 maskedValue;\r\n        uint256 count;\r\n        bytes32 _asset;\r\n        uint256 pos;\r\n        uint256 maxLevel = 0;\r\n        uint256 totalFee = 0;\r\n        uint256 _assetLevel;\r\n        Patent memory _patent;\r\n        uint16 currentAsset;\r\n        \r\n        for (uint256 i = 0; i < 5; i++) {\r\n            currentAsset = inputAssets[i];\r\n            if (currentAsset < 248) {\r\n                _asset = asset[currentAsset / 31];\r\n                pos = currentAsset % 31;\r\n                mask = bytes32(255) << (8 * pos);\r\n                maskedValue = uint256(_asset & mask);\r\n\r\n                require(maskedValue >= (uint256(1) << (8*pos)));\r\n                maskedValue -= (uint256(1) << (8*pos));\r\n                _asset = ((_asset ^ mask) & _asset) | bytes32(maskedValue); \r\n                asset[currentAsset / 31] = _asset;\r\n                count += 1;\r\n\r\n                // handle patent fee\r\n                _assetLevel = assetLevel[currentAsset];\r\n                if (_assetLevel > maxLevel) {\r\n                    maxLevel = _assetLevel;\r\n                }\r\n\r\n                if (_assetLevel > 0) {\r\n                    _patent = patents[currentAsset];\r\n                    if (_patent.patentOwner != address(0) && _patent.patentOwner != msg.sender && !_patent.onSale && (_patent.beginTime + patentValidTime > now)) {\r\n                        _patent.patentOwner.transfer(pFees[_assetLevel] / 10000 * feeRatio);\r\n                        totalFee += pFees[_assetLevel];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        require(msg.value >= prePaidFee + totalFee); \r\n\r\n        require(count >= 2 && count <= 5);\r\n\r\n        // Check whether cooldown has ends\r\n        require(_isCooldownReady(msg.sender));\r\n\r\n        uint128 skinType = skinContract.getActiveSkin(msg.sender);\r\n        uint256 _cooldownTime = chemistry.computeCooldownTime(skinType, cooldownLevels[maxLevel]);\r\n\r\n        accountsToFurnace[msg.sender].pendingAssets = inputAssets;\r\n        accountsToFurnace[msg.sender].cooldownEndTime = now + _cooldownTime;\r\n        accountsToFurnace[msg.sender].inSynthesization = true;         \r\n        assets[msg.sender] = asset;\r\n\r\n        // Emit SnthesizeStart event\r\n        // SynthesizeStart(msg.sender);\r\n        emit AutoSynthesize(msg.sender, accountsToFurnace[msg.sender].cooldownEndTime);\r\n    }\r\n\r\n    function getPatentFee(address account, uint16[5] inputAssets) external view returns (uint256) {\r\n\r\n        uint256 totalFee = 0;\r\n        uint256 _assetLevel;\r\n        Patent memory _patent;\r\n        uint16 currentAsset;\r\n        \r\n        for (uint256 i = 0; i < 5; i++) {\r\n            currentAsset = inputAssets[i];\r\n            if (currentAsset < 248) {\r\n\r\n                // handle patent fee\r\n                _assetLevel = assetLevel[currentAsset];\r\n                if (_assetLevel > 0) {\r\n                    _patent = patents[currentAsset];\r\n                    if (_patent.patentOwner != address(0) && _patent.patentOwner != account && !_patent.onSale && (_patent.beginTime + patentValidTime > now)) {\r\n                        totalFee += pFees[_assetLevel];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return totalFee;\r\n    }\r\n\r\n    // getSynthesizationResult: auto synthesize daemin call this. if cooldown time has passed, give final result\r\n    // Anyone can call this function, if they are willing to pay the gas\r\n    function getSynthesizationResult(address account) external whenNotPaused {\r\n\r\n        // Make sure this account is in synthesization\r\n        require(accountsToFurnace[account].inSynthesization);\r\n\r\n        // Make sure the cooldown has ends\r\n        require(_isCooldownReady(account));\r\n\r\n        // Get result using pending assets        \r\n        uint16[5] memory _pendingAssets = accountsToFurnace[account].pendingAssets;\r\n        uint128 skinType = skinContract.getActiveSkin(account);\r\n        uint16[5] memory resultAssets = chemistry.turnOnFurnace(_pendingAssets, skinType);\r\n\r\n        // Write result\r\n        bytes32[8] memory asset = assets[account];\r\n\r\n        bytes32 mask; // 0x11111111\r\n        uint256 maskedValue;\r\n        uint256 j;\r\n        uint256 pos;   \r\n\r\n        for (uint256 i = 0; i < 5; i++) {\r\n            if (resultAssets[i] < 248) {\r\n                j = resultAssets[i] / 31;\r\n                pos = resultAssets[i] % 31;\r\n                mask = bytes32(255) << (8 * pos);\r\n                maskedValue = uint256(asset[j] & mask);\r\n\r\n                require(maskedValue < (uint256(255) << (8*pos)));\r\n                maskedValue += (uint256(1) << (8*pos));\r\n                asset[j] = ((asset[j] ^ mask) & asset[j]) | bytes32(maskedValue); \r\n\r\n                // handle patent\r\n                if (resultAssets[i] > 3 && patents[resultAssets[i]].patentOwner == address(0)) {\r\n                    patents[resultAssets[i]] = Patent({patentOwner: account,\r\n                                                       beginTime: now,\r\n                                                       onSale: false,\r\n                                                       price: 0,\r\n                                                       lastPrice: 10 finney,\r\n                                                       sellTime: 0});\r\n                    // Emit the event\r\n                    emit RegisterCreator(account, resultAssets[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Mark this synthesization as finished\r\n        accountsToFurnace[account].inSynthesization = false;\r\n        assets[account] = asset;\r\n\r\n        emit SynthesizeSuccess(account);\r\n    }\r\n}\r\n\r\ncontract AlchemyMinting is AlchemySynthesize {\r\n\r\n    // Limit the nubmer of zero order assets the owner can create every day\r\n    uint256 public zoDailyLimit = 2500; // we can create 4 * 2500 = 10000 0-order asset each day\r\n    uint256[4] public zoCreated;\r\n    \r\n    // Limit the number each account can buy every day\r\n    mapping(address => bytes32) public accountsBoughtZoAsset;\r\n    mapping(address => uint256) public accountsZoLastRefreshTime;\r\n\r\n    // Price of zero order assets\r\n    uint256 public zoPrice = 1 finney;\r\n\r\n    // Last daily limit refresh time\r\n    uint256 public zoLastRefreshTime = now;\r\n\r\n    // Event\r\n    event BuyZeroOrderAsset(address account, bytes32 values);\r\n\r\n    // To ensure scarcity, we are unable to change the max numbers of zo assets every day.\r\n    // We are only able to modify the price\r\n    function setZoPrice(uint256 newPrice) external onlyCOO {\r\n        zoPrice = newPrice;\r\n    }\r\n\r\n    // Buy zo assets from us\r\n    function buyZoAssets(bytes32 values) external payable whenNotPaused {\r\n        // Check whether we need to refresh the daily limit\r\n        bytes32 history = accountsBoughtZoAsset[msg.sender];\r\n        if (accountsZoLastRefreshTime[msg.sender] == uint256(0)) {\r\n            // This account's first time to buy zo asset, we do not need to clear accountsBoughtZoAsset\r\n            accountsZoLastRefreshTime[msg.sender] = zoLastRefreshTime;\r\n        } else {\r\n            if (accountsZoLastRefreshTime[msg.sender] < zoLastRefreshTime) {\r\n                history = bytes32(0);\r\n                accountsZoLastRefreshTime[msg.sender] = zoLastRefreshTime;\r\n            }\r\n        }\r\n \r\n        uint256 currentCount = 0;\r\n        uint256 count = 0;\r\n\r\n        bytes32 mask = bytes32(255); // 0x11111111\r\n        uint256 maskedValue;\r\n        uint256 maskedResult;\r\n\r\n        bytes32 asset = assets[msg.sender][0];\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            if (i > 0) {\r\n                mask = mask << 8;\r\n            }\r\n            maskedValue = uint256(values & mask);\r\n            currentCount = maskedValue / 2 ** (8 * i);\r\n            count += currentCount;\r\n\r\n            // Check whether this account has bought too many assets\r\n            maskedResult = uint256(history & mask); \r\n            maskedResult += maskedValue;\r\n            require(maskedResult < (2 ** (8 * (i + 1))));\r\n\r\n            // Update account bought history\r\n            history = ((history ^ mask) & history) | bytes32(maskedResult);\r\n\r\n            // Check whether this account will have too many assets\r\n            maskedResult = uint256(asset & mask);\r\n            maskedResult += maskedValue;\r\n            require(maskedResult < (2 ** (8 * (i + 1))));\r\n\r\n            // Update user asset\r\n            asset = ((asset ^ mask) & asset) | bytes32(maskedResult);\r\n\r\n            // Check whether we have enough assets to sell\r\n            require(zoCreated[i] + currentCount <= zoDailyLimit);\r\n\r\n            // Update our creation history\r\n            zoCreated[i] += currentCount;\r\n        }\r\n\r\n        // Ensure this account buy at least one zo asset\r\n        require(count > 0);\r\n\r\n        // Check whether there are enough money for payment\r\n        require(msg.value >= count * zoPrice);\r\n\r\n        // Write updated user asset\r\n        assets[msg.sender][0] = asset;\r\n\r\n        // Write updated history\r\n        accountsBoughtZoAsset[msg.sender] = history;\r\n        \r\n        // Emit BuyZeroOrderAsset event\r\n        emit BuyZeroOrderAsset(msg.sender, values);\r\n\r\n    }\r\n\r\n    // Our daemon will refresh daily limit\r\n    function clearZoDailyLimit() external onlyCOO {\r\n        uint256 nextDay = zoLastRefreshTime + 1 days;\r\n        if (now > nextDay) {\r\n            zoLastRefreshTime = nextDay;\r\n            for (uint256 i = 0; i < 4; i++) {\r\n                zoCreated[i] =0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract AlchemyMarket is AlchemyMinting {\r\n\r\n    // Sale order struct\r\n    struct SaleOrder {\r\n        // Asset id to be sold\r\n        uint64 assetId;\r\n        // Sale amount\r\n        uint64 amount;\r\n        // Desired price\r\n        uint128 desiredPrice;\r\n        // Seller\r\n        address seller; \r\n    }\r\n\r\n    // Max number of sale orders of each account \r\n    uint128 public maxSaleNum = 20;\r\n\r\n    // Cut ratio for a transaction\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public trCut = 275;\r\n\r\n    // Next sale id\r\n    uint256 public nextSaleId = 1;\r\n\r\n    // Sale orders list \r\n    mapping (uint256 => SaleOrder) public saleOrderList;\r\n\r\n    // Sale information of each account\r\n    mapping (address => uint256) public accountToSaleNum;\r\n\r\n    // events\r\n    event PutOnSale(address account, uint256 saleId);\r\n    event WithdrawSale(address account, uint256 saleId);\r\n    event ChangeSale(address account, uint256 saleId);\r\n    event BuyInMarket(address buyer, uint256 saleId, uint256 amount);\r\n    event SaleClear(uint256 saleId);\r\n\r\n    // functions\r\n    function setTrCut(uint256 newCut) public onlyCOO {\r\n        trCut = newCut;\r\n    }\r\n\r\n    // Put asset on sale\r\n    function putOnSale(uint256 assetId, uint256 amount, uint256 price) external whenNotPaused {\r\n        // One account can have no more than maxSaleNum sale orders\r\n        require(accountToSaleNum[msg.sender] < maxSaleNum);\r\n\r\n        // check whether zero order asset is to be sold \r\n        // which is not allowed\r\n        require(assetId > 3 && assetId < 248);\r\n        require(amount > 0 && amount < 256);\r\n\r\n        uint256 assetFloor = assetId / 31;\r\n        uint256 assetPos = assetId - 31 * assetFloor;\r\n        bytes32 allAsset = assets[msg.sender][assetFloor];\r\n\r\n        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\r\n        uint256 maskedValue;\r\n        uint256 maskedResult;\r\n        uint256 addAmount = amount << (8 * assetPos);\r\n\r\n        // check whether there are enough unpending assets to sell\r\n        maskedValue = uint256(allAsset & mask);\r\n        require(addAmount <= maskedValue);\r\n\r\n        // Remove assets to be sold from owner\r\n        maskedResult = maskedValue - addAmount;\r\n        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\r\n\r\n        assets[msg.sender][assetFloor] = allAsset;\r\n\r\n        // Put on sale\r\n        SaleOrder memory saleorder = SaleOrder(\r\n            uint64(assetId),\r\n            uint64(amount),\r\n            uint128(price),\r\n            msg.sender\r\n        );\r\n\r\n        saleOrderList[nextSaleId] = saleorder;\r\n        nextSaleId += 1;\r\n\r\n        accountToSaleNum[msg.sender] += 1;\r\n\r\n        // Emit the Approval event\r\n        emit PutOnSale(msg.sender, nextSaleId-1);\r\n    }\r\n  \r\n    // Withdraw an sale order\r\n    function withdrawSale(uint256 saleId) external whenNotPaused {\r\n        // Can only withdraw self's sale order\r\n        require(saleOrderList[saleId].seller == msg.sender);\r\n\r\n        uint256 assetId = uint256(saleOrderList[saleId].assetId);\r\n        uint256 assetFloor = assetId / 31;\r\n        uint256 assetPos = assetId - 31 * assetFloor;\r\n        bytes32 allAsset = assets[msg.sender][assetFloor];\r\n\r\n        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\r\n        uint256 maskedValue;\r\n        uint256 maskedResult;\r\n        uint256 addAmount = uint256(saleOrderList[saleId].amount) << (8 * assetPos);\r\n\r\n        // check whether this account will have too many assets\r\n        maskedValue = uint256(allAsset & mask);\r\n        require(addAmount + maskedValue < 2**(8 * (assetPos + 1)));\r\n\r\n        // Retransfer asset to be sold from owner\r\n        maskedResult = maskedValue + addAmount;\r\n        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\r\n\r\n        assets[msg.sender][assetFloor] = allAsset;\r\n\r\n        // Delete sale order\r\n        delete saleOrderList[saleId];\r\n\r\n        accountToSaleNum[msg.sender] -= 1;\r\n\r\n        // Emit the cancel event\r\n        emit WithdrawSale(msg.sender, saleId);\r\n    }\r\n \r\n//     // Change sale order\r\n//     function changeSale(uint256 assetId, uint256 amount, uint256 price, uint256 saleId) external whenNotPaused {\r\n//         // Check if msg sender is the seller\r\n//         require(msg.sender == saleOrderList[saleId].seller);\r\n// \r\n//     }\r\n \r\n    // Buy assets in market\r\n    function buyInMarket(uint256 saleId, uint256 amount) external payable whenNotPaused {\r\n        address seller = saleOrderList[saleId].seller;\r\n        // Check whether the saleId is a valid sale order\r\n        require(seller != address(0));\r\n\r\n        // Check the sender isn't the seller\r\n        require(msg.sender != seller);\r\n\r\n        require(saleOrderList[saleId].amount >= uint64(amount));\r\n\r\n        // Check whether pay value is enough\r\n        require(msg.value / saleOrderList[saleId].desiredPrice >= amount);\r\n\r\n        uint256 totalprice = amount * saleOrderList[saleId].desiredPrice;\r\n\r\n        uint64 assetId = saleOrderList[saleId].assetId;\r\n\r\n        uint256 assetFloor = assetId / 31;\r\n        uint256 assetPos = assetId - 31 * assetFloor;\r\n        bytes32 allAsset = assets[msg.sender][assetFloor];\r\n\r\n        bytes32 mask = bytes32(255) << (8 * assetPos); // 0x11111111\r\n        uint256 maskedValue;\r\n        uint256 maskedResult;\r\n        uint256 addAmount = amount << (8 * assetPos);\r\n\r\n        // check whether this account will have too many assets\r\n        maskedValue = uint256(allAsset & mask);\r\n        require(addAmount + maskedValue < 2**(8 * (assetPos + 1)));\r\n\r\n        // Transfer assets to buyer\r\n        maskedResult = maskedValue + addAmount;\r\n        allAsset = ((allAsset ^ mask) & allAsset) | bytes32(maskedResult);\r\n\r\n        assets[msg.sender][assetFloor] = allAsset;\r\n\r\n        saleOrderList[saleId].amount -= uint64(amount);\r\n\r\n        // Cut and then send the proceeds to seller\r\n        uint256 sellerProceeds = totalprice - _computeCut(totalprice);\r\n\r\n        seller.transfer(sellerProceeds);\r\n\r\n        // Emit the buy event\r\n        emit BuyInMarket(msg.sender, saleId, amount);\r\n\r\n        // If the sale has complete, clear this order\r\n        if (saleOrderList[saleId].amount == 0) {\r\n            accountToSaleNum[seller] -= 1;\r\n            delete saleOrderList[saleId];\r\n\r\n            // Emit the clear event\r\n            emit SaleClear(saleId);\r\n        }\r\n    }\r\n\r\n    // Compute the marketCut\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        return _price / 10000 * trCut;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"zoDailyLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"saleId\",\"type\":\"uint256\"}],\"name\":\"withdrawSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chemistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"zoCreated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"putOnSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"saleOrderList\",\"outputs\":[{\"name\":\"assetId\",\"type\":\"uint64\"},{\"name\":\"amount\",\"type\":\"uint64\"},{\"name\":\"desiredPrice\",\"type\":\"uint128\"},{\"name\":\"seller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountToSaleNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFeeRatio\",\"type\":\"uint256\"}],\"name\":\"setPatentFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCoo\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint16\"},{\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"sellPatent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsZoLastRefreshTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"skinAddress\",\"type\":\"address\"}],\"name\":\"setSkinContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cao\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"patentValidTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setZoPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint16\"},{\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"changePatentSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCfo\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getFurnace\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16[5]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSynthesizeAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"saleId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyInMarket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint16\"}],\"name\":\"publicSell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"assetOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[8]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cooldownLevels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prePaidFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"changeSynthesizeAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"bytes32[8]\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsBoughtZoAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"patents\",\"outputs\":[{\"name\":\"patentOwner\",\"type\":\"address\"},{\"name\":\"beginTime\",\"type\":\"uint256\"},{\"name\":\"onSale\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"lastPrice\",\"type\":\"uint256\"},{\"name\":\"sellTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zoPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSaleNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPrePaidFee\",\"type\":\"uint256\"}],\"name\":\"setPrePaidFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"clearZoDailyLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"assetLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inputAssets\",\"type\":\"uint16[5]\"}],\"name\":\"synthesize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSynthesizationResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint16\"}],\"name\":\"buyPatent\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"values\",\"type\":\"bytes32\"}],\"name\":\"buyZoAssets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCao\",\"type\":\"address\"}],\"name\":\"setCAO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeAllowTransferState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"zoLastRefreshTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"patentSaleTimeDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"inputAssets\",\"type\":\"uint16[5]\"}],\"name\":\"getPatentFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCut\",\"type\":\"uint256\"}],\"name\":\"setTrCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSaleId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"chemistryAddress\",\"type\":\"address\"}],\"name\":\"setChemistryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsToFurnace\",\"outputs\":[{\"name\":\"cooldownEndTime\",\"type\":\"uint256\"},{\"name\":\"inSynthesization\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initializeLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint16\"},{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setAssetLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"skinContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCeo\",\"type\":\"address\"}],\"name\":\"demiseCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"saleId\",\"type\":\"uint256\"}],\"name\":\"PutOnSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"saleId\",\"type\":\"uint256\"}],\"name\":\"WithdrawSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"saleId\",\"type\":\"uint256\"}],\"name\":\"ChangeSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"saleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyInMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"saleId\",\"type\":\"uint256\"}],\"name\":\"SaleClear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"values\",\"type\":\"bytes32\"}],\"name\":\"BuyZeroOrderAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"cooldownEndTime\",\"type\":\"uint256\"}],\"name\":\"AutoSynthesize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SynthesizeSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"kind\",\"type\":\"uint16\"}],\"name\":\"RegisterCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"sellPrice\",\"type\":\"uint256\"}],\"name\":\"SellPatent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"ChangePatentSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BuyPatent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousCeo\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCeo\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"}]","ContractName":"AlchemyMarket","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://90461403feb98f085fd250d519ccbd556245d7ac5fc6badf58de1f52b4052c33"}]}