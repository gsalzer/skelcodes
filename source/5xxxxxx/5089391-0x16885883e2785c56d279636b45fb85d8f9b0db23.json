{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) pure internal returns (uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) pure internal returns (uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) pure internal returns (uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0) || (z / x == y));\r\n        return z;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Ownable {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    require (!halted);\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    require (halted);\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title DogezerICOPublicCrowdSale public crowdsale contract\r\n */\r\ncontract DogezerICOPublicCrowdSale is Haltable{\r\n    using SafeMath for uint;\r\n\r\n    string public name = \"Dogezer Public Sale ITO\";\r\n\r\n    address public beneficiary;\r\n\r\n    uint public startTime = 1518699600;\r\n    uint public stopTime = 1520514000;\r\n\r\n    uint public totalTokensAvailableForSale = 9800000000000000;\r\n    uint public preDGZTokensSold = 20699056632305;\r\n    uint public privateSalesTokensSold = 92644444444444;\r\n    uint public tokensAvailableForSale = 0;\r\n    uint public tokensSoldOnPublicRound = 0;\r\n\r\n    StandardToken public tokenReward;\r\n    StandardToken public tokenRewardPreDGZ;\r\n        \r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => uint256) public nonWLBalanceOf;\r\n    mapping(address => uint256) public preBalanceOf;\r\n    mapping(address => bool) public whiteList;\r\n\r\n    event DGZTokensWithdraw(address where, uint amount);\r\n    event DGZTokensSold(address where, uint amount);\r\n    event TokensWithdraw(address where, address token, uint amount);\r\n    event FundsWithdrawal(address where, uint amount);\r\n\r\n    bool[] public yearlyTeamTokensPaid = [false, false, false];\r\n    uint public yearlyTeamAmount= 0;\r\n    bool public bountyPaid = false;\r\n    uint public bountyAmount = 0;\r\n\r\n    bool public crowdsaleClosed = false;\r\n    uint public constant maxPurchaseNonWhiteListed = 10 * 1 ether;\r\n    uint public preDGZtoDGZExchangeRate = 914285714;\r\n\r\n    uint public discountValue5 = 50.0 * 1 ether;\r\n    uint public discountValue10 = 100.0 * 1 ether;\r\n\r\n    uint[] public price1stWeek = [ 5625000, 5343750, 5062500];\r\n    uint[] public price2ndWeek = [ 5940000, 5643000, 5346000];\r\n    uint[] public price3rdWeek = [ 6250000, 5937500, 5625000];\r\n\r\n    \r\n    function DogezerICOPublicCrowdSale(\r\n        address addressOfPreDGZToken,\r\n        address addressOfDGZToken,\r\n        address addressOfBeneficiary\r\n    ) public\r\n    {\r\n        beneficiary = addressOfBeneficiary;\r\n        tokenRewardPreDGZ = StandardToken(addressOfPreDGZToken);\r\n        tokenReward = StandardToken(addressOfDGZToken);\r\n        tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold;\r\n        tokensSoldOnPublicRound = 0;\r\n    }\r\n    \r\n    \r\n    modifier onlyAfterStart() {\r\n        require (now >= startTime);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBeforeEnd() {\r\n        require (now < stopTime);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Main Payable function.\r\n     * @dev In case if purchaser purchases on more than 10 ETH - only send tokens back if a person passed KYC (whitelisted) \r\n     * in other case - funds are being frozen until whitelisting will be done. If price will change before \r\n     * whitelisting is done for person, person will receive tokens basing on the new price, not old price.\r\n     */    \r\n    function () payable stopInEmergency onlyAfterStart onlyBeforeEnd public\r\n    {\r\n        require (crowdsaleClosed == false);\r\n        require (tokensAvailableForSale > tokensSoldOnPublicRound);\r\n        require (msg.value > 500000000000000);\r\n\r\n        if ((balanceOf[msg.sender] + msg.value) > maxPurchaseNonWhiteListed && whiteList[msg.sender] == false) \r\n        {\r\n            \r\n            // DGZ tokens are not being reserved for the purchasers who are not in a whitelist yet.\r\n            nonWLBalanceOf[msg.sender] += msg.value;\r\n        } \r\n        else \r\n        {\r\n            sendTokens(msg.sender, msg.value); \r\n        }\r\n    }\r\n\r\n\r\n    /**     \r\n     * @notice Add multiple addresses to white list to allow purchase for more than 10 ETH. Owned.\r\n     * @dev Automatically send tokens to addresses being whitelisted if they have already send funds before\r\n     * the call of this function. It is recommended to check that addreses being added are VALID and not smartcontracts\r\n     * as problem somewhere in the middle of the loop may cause error which will make all gas to be lost.\r\n     * @param _addresses address[] Pass a bunch of etherium addresses as \r\n     *        [\"0xca35b7d915458ef540ade6068dfe2f44e8fa733c\", \"0x14723a09acff6d2a60dcdf7aa4aff308fddc160c\"] to add to WhiteList\r\n     */        \r\n    function addListToWhiteList (address[] _addresses) public onlyOwner\r\n    {\r\n        for (uint i = 0; i < _addresses.length; i++)\r\n        {\r\n            if (nonWLBalanceOf[_addresses[i]] > 0)\r\n            {\r\n                sendTokens(_addresses[i], nonWLBalanceOf[_addresses[i]]);\r\n                nonWLBalanceOf[_addresses[i]] = 0;\r\n            }\r\n            whiteList[_addresses[i]] = true;\r\n        }\r\n    }\r\n    \r\n    \r\n    /**    \r\n     * @notice Add a single address to white list to allow purchase for more than 10 ETH. Owned.\r\n     * @param _address address An etherium addresses to add to WhiteList\r\n     */    \r\n    function addToWhiteList (address _address) public onlyOwner\r\n    {\r\n        if (nonWLBalanceOf[_address] > 0)\r\n        {\r\n            sendTokens(_address, nonWLBalanceOf[_address]);\r\n            nonWLBalanceOf[_address] = 0;\r\n        }\r\n        whiteList[_address] = true;\r\n    }    \r\n    \r\n    \r\n    /**\r\n     * @notice Finalize sales and sets bounty & yearly paid value. Owned.\r\n     */        \r\n    function finalizeSale () public onlyOwner\r\n    {\r\n        require (crowdsaleClosed == false);\r\n        crowdsaleClosed = true;\r\n        uint totalSold = tokensSoldOnPublicRound + preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 + privateSalesTokensSold;\r\n        bountyAmount = totalSold / 980 * 15;\r\n        yearlyTeamAmount= totalSold / 980 * 5 / 3;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @notice A function to burn unsold DGZ tokens. The ammount would be a parameter, not calculated value to ensure that all of the \r\n     * last moment changes related to KYC processing, such as overdue of KYC documents or delay with confirming of KYC\r\n     * documents which caused purchaser to receive tokens using next period price, are handled. Owned.\r\n     * @param _amount uint Number of tokens to burn\r\n     */        \r\n    function tokenBurn (uint _amount) public onlyOwner\r\n    {\r\n        require (crowdsaleClosed == true);\r\n        tokenReward.transfer(address(0), _amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice A function to withdraw tokens for bounty campaign. Can be called only once. Owned.\r\n     */            \r\n    function bountyTokenWithdrawal () public onlyOwner\r\n    {\r\n        require (crowdsaleClosed == true);\r\n        require (bountyPaid == false);\r\n\r\n        tokenReward.transfer(beneficiary, bountyAmount);\r\n        bountyPaid = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice A function to withdraw team tokens. Allow to withdraw one third of founders share in each yearly\r\n     * after the end of ICO. In total can be called at maximum 3 times. Owned.\r\n     */        \r\n    function yearlyOwnerTokenWithdrawal () public onlyOwner \r\n    {\r\n        require (crowdsaleClosed == true);\r\n        require (\r\n            ((now > stopTime + 1 years) && (yearlyTeamTokensPaid[0] == false))\r\n            || ((now > stopTime + 2 years) && (yearlyTeamTokensPaid[1] == false))\r\n            || ((now > stopTime + 3 years) && (yearlyTeamTokensPaid[2] == false))\r\n        );\r\n\r\n        tokenReward.transfer(beneficiary, yearlyTeamAmount);\r\n\r\n        if (yearlyTeamTokensPaid[0] == false)\r\n            yearlyTeamTokensPaid[0] = true;\r\n        else if (yearlyTeamTokensPaid[1] == false)\r\n            yearlyTeamTokensPaid[1] = true;\r\n        else if (yearlyTeamTokensPaid[2] == false)\r\n            yearlyTeamTokensPaid[2] = true;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @notice A method to exchange preDGZ tokens to DGZ tokens. To use that method, a person first\r\n     * need to call approve method of preDGZ to define how many tokens to convert. Note that function\r\n     * doesn't end with the rest of crowdsale - it may be possible to exchange preDGZ after the end of crowdsale\r\n     * @dev Exchanged preDGZ tokens are automatically burned.\r\n     */        \r\n    function exchangePreDGZTokens() stopInEmergency onlyAfterStart public\r\n    {\r\n        uint tokenAmount = tokenRewardPreDGZ.allowance(msg.sender, this);\r\n        require(tokenAmount > 0);\r\n        require(tokenRewardPreDGZ.transferFrom(msg.sender, address(0), tokenAmount));\r\n        uint amountSendTokens = tokenAmount * preDGZtoDGZExchangeRate  / 100000000;\r\n        preBalanceOf[msg.sender] += tokenAmount;\r\n        tokenReward.transfer(msg.sender, amountSendTokens);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice This function is needed to handled unlikely case when person who owns preDGZ tokens\r\n     * makes a mistake and send them to smartcontract without setting the allowance in advance. In such case\r\n     * conversion of tokens by calling exchangePreDGZTokens is not possible. Ownable.\r\n     * @dev IMPORTANT! Should only be called is Dogezer team is in possesion of preDGZ tokens. \r\n     * @dev Doesn't increment tokensSoldOnPublicRound as these tokens are already accounted as preDGZTokensSold\r\n     * @param _address address Etherium address where to send tokens as a result of conversion.\r\n     * @param preDGZAmount uint Number of preDGZ to convert.\r\n     */        \r\n    function manuallyExchangeContractPreDGZtoDGZ(address _address, uint preDGZAmount) public onlyOwner\r\n    {\r\n        require (_address != address(0));\r\n        require (preDGZAmount > 0);\r\n\r\n        uint amountSendTokens = preDGZAmount * preDGZtoDGZExchangeRate  / 100000000;\r\n        preBalanceOf[_address] += preDGZAmount;\r\n        tokenReward.transfer(_address, amountSendTokens);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Function to define prices for some particular week. Would be utilized if prices are changed. Owned.\r\n     * @dev It is important to apply this function for all of three weeks. The final week should be a week which is active now\r\n     * @param week uint Ordinal number of the week.\r\n     * @param price uint DGZ token price.\r\n     * @param price5 uint DGZ token price with 5% discount.\r\n     * @param price10 uint DGZ token price with 10% discount.\r\n     */        \r\n    function setTokenPrice (uint week, uint price, uint price5, uint price10) public onlyOwner\r\n    {\r\n        require (crowdsaleClosed == false);\r\n        require (week >= 1 && week <= 3);\r\n        if (week == 1)\r\n            price1stWeek = [price, price5, price10];\r\n        else if (week == 2)\r\n            price2ndWeek = [price, price5, price10];\r\n        else if (week == 3)\r\n            price3rdWeek = [price, price5, price10];\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice In case if prices are changed due to some great change in ETH price,\r\n     * this function can be used to change conversion rate for preDGZ owners. Owned.\r\n     * @param rate uint Conversion rate.\r\n     */        \r\n    function setPreDGZtoDgzRate (uint rate) public onlyOwner\r\n    {\r\n        preDGZtoDGZExchangeRate = rate;\r\n        tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Set number of tokens sold on private round. Required to correctly calcualte \r\n     * total numbers of tokens sold at the end. Owned.\r\n     * @param tokens uint Number of tokens sold on private sale.\r\n     */            \r\n    function setPrivateSaleTokensSold (uint tokens) public onlyOwner\r\n    {\r\n        privateSalesTokensSold = tokens;\r\n        tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Internal function which is responsible for sending tokens. Note that \r\n     * discount is determined basing on accumulated sale, but only applied to the current\r\n     * request to send tokens.\r\n     * @param msg_sender address Address of PreDGZ holder who allowed it to exchange.\r\n     * @param msg_value uint Number of DGZ tokens to send.\r\n     */            \r\n    function sendTokens(address msg_sender, uint msg_value) internal\r\n    {\r\n        var prices = price1stWeek;\r\n\r\n        if (now >= startTime + 2 weeks)\r\n            prices = price3rdWeek;\r\n        else if (now >= startTime + 1 weeks)\r\n            prices = price2ndWeek;\r\n\r\n\r\n        uint currentPrice = prices[0];\r\n\r\n        if (balanceOf[msg_sender] + msg_value >= discountValue5)\r\n        {\r\n            currentPrice = prices[1];\r\n            if (balanceOf[msg_sender] + msg_value >= discountValue10)\r\n                currentPrice = prices[2];\r\n        }\r\n\r\n        uint amountSendTokens = msg_value / currentPrice;\r\n\r\n        if (amountSendTokens > (tokensAvailableForSale - tokensSoldOnPublicRound))\r\n        {\r\n            uint tokensAvailable = tokensAvailableForSale - tokensSoldOnPublicRound;\r\n            uint refund = msg_value - (tokensAvailable * currentPrice);\r\n            amountSendTokens = tokensAvailable;\r\n            tokensSoldOnPublicRound += amountSendTokens;            \r\n            msg_sender.transfer(refund);\r\n            balanceOf[msg_sender] += (msg_value - refund);\r\n        }\r\n        else\r\n        {\r\n            tokensSoldOnPublicRound += amountSendTokens;            \r\n            balanceOf[msg_sender] += msg_value;\r\n        }\r\n\r\n        tokenReward.transfer(msg_sender, amountSendTokens);\r\n        DGZTokensSold(msg_sender, amountSendTokens);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Withdraw funds to beneficiary. Owned\r\n     * @param _amount uint Amount funds to withdraw.\r\n     */    \r\n    function fundWithdrawal (uint _amount) public onlyOwner\r\n    {\r\n        require (crowdsaleClosed == true);\r\n        beneficiary.transfer(_amount);\r\n        FundsWithdrawal(beneficiary, _amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Function to process cases when person send more than 10 ETH to smartcontract\r\n     * but never provided KYC data and wants/needs to be refunded. Owned\r\n     * @param _address address Address of refunded person.\r\n     */        \r\n    function refundNonWhitelistedPerson (address _address) public onlyOwner\r\n    {\r\n        uint refundAmount = nonWLBalanceOf[_address];\r\n        nonWLBalanceOf[_address] = 0;\r\n        _address.transfer(refundAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Withdraws DGZ tokens to beneficiary. Would be used to process BTC payments. Owned.\r\n     * @dev increments tokensSoldOnPublicRound, so will cause higher burn rate if called.\r\n     * @param _amount uint Amount of DGZ tokens to withdraw.\r\n     */    \r\n    function tokenWithdrawal (uint _amount) public onlyOwner\r\n    {\r\n        require (crowdsaleClosed == false);\r\n        tokenReward.transfer(beneficiary, _amount);\r\n        tokensSoldOnPublicRound += _amount;\r\n        DGZTokensWithdraw(beneficiary, _amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Withdraws tokens other than DGZ to beneficiary. Owned\r\n     * @dev Generally need this to handle cases when user just transfers preDGZ \r\n     * to the contract by mistake and we need to manually burn then after calling\r\n     * manuallyExchangeContractPreDGZtoDGZ\r\n     * @param _address address Address of tokens to withdraw.\r\n     * @param _amount uint Amount of tokens to withdraw.\r\n     */        \r\n    function anyTokenWithdrawal (address _address, uint _amount) public onlyOwner\r\n    {\r\n        require(_address != address(tokenReward));\r\n\r\n        StandardToken token = StandardToken(_address);\r\n        token.transfer(beneficiary, _amount);\r\n        TokensWithdraw(beneficiary, _address, _amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Changes beneficiary address. Owned.\r\n     * @param _newBeneficiary address Address of new beneficiary.\r\n     */        \r\n    function changeBeneficiary(address _newBeneficiary) public onlyOwner\r\n    {\r\n        if (_newBeneficiary != address(0)) {\r\n            beneficiary = _newBeneficiary;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Reopens closed sale to recalcualte total tokens sold if there are any late deals - such as\r\n     * delayed whitelist processing. Owned.\r\n     */    \r\n    function reopenSale () public onlyOwner\r\n    {\r\n        require (crowdsaleClosed == true);\r\n        crowdsaleClosed = false;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"stopTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preDGZTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"price3rdWeek\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"anyTokenWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangePreDGZTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRewardPreDGZ\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonWLBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"tokenBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preDGZtoDGZExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateSalesTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setPreDGZtoDgzRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addToWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPurchaseNonWhiteListed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"yearlyOwnerTokenWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"preDGZAmount\",\"type\":\"uint256\"}],\"name\":\"manuallyExchangeContractPreDGZtoDGZ\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bountyTokenWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensAvailableForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSoldOnPublicRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setPrivateSaleTokensSold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"price2ndWeek\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"price1stWeek\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"yearlyTeamAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"preBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"addListToWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"refundNonWhitelistedPerson\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discountValue10\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"tokenWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fundWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAvailableForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"week\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"price5\",\"type\":\"uint256\"},{\"name\":\"price10\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"yearlyTeamTokensPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBeneficiary\",\"type\":\"address\"}],\"name\":\"changeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reopenSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discountValue5\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"addressOfPreDGZToken\",\"type\":\"address\"},{\"name\":\"addressOfDGZToken\",\"type\":\"address\"},{\"name\":\"addressOfBeneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"where\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DGZTokensWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"where\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DGZTokensSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"where\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"where\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawal\",\"type\":\"event\"}]","ContractName":"DogezerICOPublicCrowdSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000018aa6e402a0aa22b7f61a5ace68fddc629fe44ec00000000000000000000000084178d97a442cab8b584917cbab6342ab9a1e137000000000000000000000000303364edfeff016b9e14a4fc3f282d1a9c4b00f1","Library":"","SwarmSource":"bzzr://2e3905a120b87c52276b671500991340b9b9e9bc37cb860144ab01595f53f329"}]}