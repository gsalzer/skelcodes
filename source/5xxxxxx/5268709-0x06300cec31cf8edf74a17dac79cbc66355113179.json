{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n// welcome to EtherWild (EthWild)\r\n// game which is a simple coin toss game, you have 50% chance to win.\r\n// you always play against someone else. \r\n// there are two ways to play; the auto-way by just placing a bet (only one allowed)\r\n// this is the standard way to play \r\n// if you place this bet and another one places the same bet, a match occurs and a game is played \r\n// Note: you are allowed to withdraw these bets. If all offers are cancelled 0 eth is in contract. \r\n\r\n// Offers: \r\n// You are allowed to create 16 offers in the game. Other people can find these offers and play with them\r\n// This is doable if you do not like the suggested offers, or simply want to put on more games. \r\n// These are also cancellable. \r\n// If you play someone's offer and send to much, excess is returned. \r\n\r\ncontract EtherWild{\r\n    // GLOBAL SETTINGS //\r\n    uint8 constant MaxOffersPerADDR = 16; // per definition MAX 32 offers due to uint8 size\r\n    uint16 CFee = 500; // FEE / 10000 , only paid per PLAYED TX. Cancel / create offer is no fee, only paid after play\r\n    uint16 HFeePart = 5000; // Part of creator fee -> helper /10000 -> 50%\r\n    \r\n    address Owner;\r\n    address HelpOwner = 0x30B3E09d9A81D6B265A573edC7Cc4C4fBc0B0586;\r\n    \r\n    // SETTING BIT CONFIG: \r\n    // First two bits: Owner choice of offer. 0 means offer is closed (standard) to prevent double-withdrawals.\r\n    // 1: blue / 2: red / 3: enemy choices. (This should not matter after infinite plays)\r\n\r\n    // Third bit: Game also has it's neighbour available. If you create a simple game you are allowed \r\n    // to create an offer too so it is visible (for manual amounts of inputs)\r\n    // This makes sure both items are cancelled if you decide to cancel one \r\n    // Note: two items are cancelled, but double withdrawal is not availabe ;)\r\n    \r\n    // Fourth bit: Max Offers are here 16, fourth bit not used. \r\n    // Fifth - Eight bit: ID of the offer in the offer market. Only available from SimpleGame, saves gas (no for loop necessary).\r\n\r\n\r\n    struct SimpleGame{\r\n        address Owner;   // Creator \r\n        uint8 setting;  // Setting \r\n\r\n    }\r\n    \r\n    struct OfferGame{\r\n\t    uint256 amount;    // fee. \r\n\t    uint8 setting;     // 0-3\r\n        bool SimpleGame; // Could have implemented above\r\n    }\r\n    \r\n    // uint256 is wei paid: note only one offer is available per wei here. \r\n    mapping(uint256 => SimpleGame) public SimpleGameList;\r\n\r\n    // address can store 16 offers. lookup is done via events, saves gas. \r\n    mapping(address => OfferGame[MaxOffersPerADDR]) public OfferGameList;\r\n    \r\n\r\n    // events for both to keep track \r\n    event SimpleGamePlayed(address creator, address target, bool blue, bool cwon, uint256 amount);\r\n    event SimpleGameCreated(address creator, uint256 fee, uint8 setting);\r\n    event SimpleGameCancelled(uint256 fee);\r\n    \r\n        // same events, ID added to allow cancel from UI \r\n    event OfferGameCreated(address creator, uint8 setting, uint256 amount, uint8 id);\r\n    event OfferGameCancelled(address creator, uint8 id);\r\n    event OfferGamePlayed(address creator, address target, bool blue, bool cwon, uint256 amount, uint8 id);\r\n    \r\n    // dont touch pls \r\n    modifier OnlyOwner(){\r\n        if (msg.sender == Owner){\r\n            _;\r\n        }\r\n        else{\r\n            revert();\r\n        }\r\n    }\r\n    \r\n    function EtherWild() public{\r\n        Owner = msg.sender;\r\n\r\n    }\r\n    \r\n    // allows to change dev fee. max is 5%\r\n    function SetDevFee(uint16 tfee) public OnlyOwner{\r\n        require(tfee <= 500);\r\n        CFee = tfee;\r\n    }\r\n    \r\n    // allows to change helper fee. minimum is 10%, max 100%. \r\n    function SetHFee(uint16 hfee) public OnlyOwner {\r\n        require(hfee <= 10000);\r\n        require(hfee >= 1000);\r\n        HFeePart = hfee;\r\n    \r\n    }\r\n    \r\n\r\n    // only used in UI. returns uint so you can see how much games you have uploaded. \r\n    function UserOffers(address who) public view returns(uint8){\r\n        uint8 ids = 0;\r\n        for (uint8 i=0; i<MaxOffersPerADDR; i++){\r\n            if ((OfferGameList[who][i].setting & 3) == 0){\r\n                ids++ ;\r\n            }\r\n        }\r\n        return ids;\r\n    }\r\n    \r\n    // lookups struct into offergamelist. only view. \r\n    function ViewOffer(address who, uint8 id) public view returns (uint256 amt, uint8 setting, bool sgame){\r\n        var Game = OfferGameList[who][id];\r\n        return (Game.amount, Game.setting,Game.SimpleGame);\r\n    }\r\n    \r\n    // create a new offer with setting. note; setting has to be 1,2 or 3.\r\n    // connected to msg.sender.\r\n    function CreateOffer(uint8 setting) public payable{\r\n        require(msg.value>0);\r\n        require(setting>0);\r\n        CreateOffer_internal(setting, false);\r\n    }\r\n    \r\n\r\n    // internal function, necessary to keep track of simple game links \r\n    function CreateOffer_internal(uint8 setting, bool Sgame) internal returns (uint8 id){\r\n        // find id. \r\n        require(setting <= 3);\r\n\r\n        bool found = false;\r\n        id = 0;\r\n        // find available ID .\r\n        for (uint8 i=0; i<MaxOffersPerADDR; i++){\r\n            if (OfferGameList[msg.sender][i].setting == 0){\r\n                id = i;\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        // no place? reject tx. \r\n        // note: also simple tx can be released like this.\r\n        require(found);\r\n        OfferGameList[msg.sender][id] = OfferGame(msg.value, setting, Sgame);\r\n\r\n        emit OfferGameCreated(msg.sender, setting, msg.value, id);\r\n        // \r\n        return id;\r\n    }\r\n    \r\n    // public cancel offer, intern necessary for simple link \r\n    // note: offer cancelled is msg.sender and ID is id (into that array of this address)\r\n    function OfferCancel(uint8 id) public {\r\n        OfferCancel_internal(id, false);\r\n    }\r\n    \r\n    \r\n    function OfferCancel_internal(uint8 id, bool skipSimple) internal {\r\n        var game = OfferGameList[msg.sender][id];\r\n        if (game.setting != 0){\r\n            uint8 setting; \r\n            bool sgame; \r\n            uint8 _notn;\r\n            (setting, sgame, _notn) = DataFromSetting(game.setting);\r\n            // reset to 0. \r\n            game.setting = 0;\r\n            \r\n            emit OfferGameCancelled(msg.sender, id);\r\n            \r\n            // if simple game available cancel it. put true in so no recall to this funciton \r\n            // also true will prevent to withdraw twice. \r\n            if ((!skipSimple) && game.SimpleGame){\r\n                CancelSimpleOffer_internal(game.amount,true);\r\n            }\r\n            \r\n            // not from simple cancel? then withdraw. \r\n            if (!skipSimple){\r\n                msg.sender.transfer(game.amount); // prevent send twice.\r\n            }\r\n        }\r\n        else{\r\n            return;\r\n        }\r\n    }\r\n    \r\n    // play offer game: target address, id, possible setting. \r\n    function OfferPlay(address target, uint8 id, uint8 setting) public payable {\r\n        var Game = OfferGameList[target][id];\r\n        require(Game.setting != 0);\r\n        require(msg.value >= Game.amount);\r\n        \r\n        uint256 excess = msg.value - Game.amount;\r\n        if (excess > 0){\r\n            msg.sender.transfer(excess); // return too much. \r\n        }\r\n        \r\n        uint8 cset;\r\n        bool sgame; \r\n        uint8 _id;\r\n        \r\n        (cset, sgame, id) = DataFromSetting(Game.setting);\r\n        \r\n        bool creatorChoosesBlue = GetSetting(Game.setting, setting);\r\n        bool blue;\r\n        bool creatorwins;\r\n        (blue, creatorwins) = ProcessGame(target, msg.sender, creatorChoosesBlue, Game.amount);\r\n\r\n        \r\n        // announce played. \r\n        emit OfferGamePlayed(target, msg.sender, blue, creatorwins, Game.amount, id);\r\n        // disable offer. \r\n        Game.setting = 0; // disable this offer. \r\n        \r\n        // also sgame? then cancel this too to prevent another cancel on this one \r\n        // otherwise you can always make sure you never lose money. hrm.\r\n        if(sgame){\r\n            // cancel sgame -> true prevents withdraw.\r\n            CancelSimpleOffer_internal(Game.amount, true);\r\n        }\r\n        \r\n    }\r\n    \r\n    // same as offer cancel. \r\n    function CancelSimpleOffer_internal(uint256 fee, bool SkipOffer) internal {\r\n        uint8 setting = SimpleGameList[fee].setting;\r\n        if (setting == 0){\r\n            return;\r\n        }\r\n        if (!(SimpleGameList[fee].Owner == msg.sender)){\r\n            return;\r\n        }\r\n      \r\n        \r\n        bool offer;\r\n        uint8 id;\r\n        \r\n        (setting, offer, id) = DataFromSetting(setting);\r\n        SimpleGameList[fee].setting = 0; // set to zero, prevent recalling.\r\n        // prevent recall if offer available; \r\n        // offer cancel with not withdraw. \r\n        if ((!SkipOffer) && offer){\r\n            OfferCancel_internal(id, true);\r\n        }\r\n        \r\n\r\n        // if first call then withdraw. \r\n       if (!SkipOffer){\r\n            msg.sender.transfer(fee); // prevent send twice. \r\n       }\r\n        \r\n        emit SimpleGameCancelled( fee);\r\n    }\r\n    \r\n    // false = first call for cancel offer, prevent withdraw twice \r\n    // withdraws fee to owner if he owns this one \r\n    function CancelSimpleOffer(uint256 fee) public {\r\n        \r\n       CancelSimpleOffer_internal(fee, false);\r\n    }\r\n    \r\n    //returns if creator wants blue \r\n    // yeah this program has this logic behind it although not necessary. \r\n    function GetSetting(uint8 setting1, uint8 setting2) pure internal returns (bool creatorChoosesBlue){\r\n        if (setting1 == 1){\r\n            return true;\r\n        }\r\n        else if (setting1 == 2){\r\n            return false;\r\n        }\r\n        else{\r\n            if (setting2 == 1){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    // play game with setting, and a bool if you also want to create offer on the side. \r\n    // (all done in one TX)\r\n    function PlaySimpleGame(uint8 setting, bool WantInOffer) payable public {\r\n        require(msg.value > 0);\r\n        require(setting > 0); // do not create cancelled one, otherwise withdraw not possible. \r\n\r\n        var game = (SimpleGameList[msg.value]);\r\n        uint8 id;\r\n        if (game.setting != 0){\r\n            // play game - NOT cancelled. \r\n            // >tfw msg.value is already correct lol no paybacks \r\n            require(game.Owner != msg.sender); // do not play against self, would send fee, unfair.\r\n            \r\n            // process logic\r\n            uint8 cset; \r\n            bool ogame;\r\n            id; \r\n            (cset, ogame, id) = DataFromSetting(game.setting);\r\n            \r\n            bool creatorChoosesBlue = GetSetting(cset, setting);\r\n            bool blue;\r\n            bool creatorwins;\r\n            //actually play and pay in here. \r\n            (blue, creatorwins) = ProcessGame(game.Owner, msg.sender, creatorChoosesBlue, msg.value);\r\n            emit SimpleGamePlayed(game.Owner, msg.sender, blue, creatorwins, msg.value);\r\n            // delete , makes it unable to cancel \r\n            game.setting = 0;\r\n            \r\n            // cancel the offer \r\n            // is called second time: makes sure no withdraw happens. \r\n            if (ogame){\r\n                OfferCancel_internal(id, true);\r\n            }\r\n        }\r\n        else {\r\n            // create a game ! \r\n            //require(setting != 0);\r\n            id = 0;\r\n            if (WantInOffer){\r\n                // also create an offer. costs more gas \r\n                id = CreateOffer_internal(setting, true); // id is returned to track this when cancel. \r\n            }\r\n            \r\n            // convert setting. also checks for setting input <= 3; \r\n            // bit magic \r\n            \r\n            setting = DataToSetting(setting, WantInOffer, id);\r\n            \r\n            // make game, push it in game , emit event \r\n            var myGame = SimpleGame(msg.sender, setting);\r\n            SimpleGameList[msg.value] = myGame;\r\n            emit SimpleGameCreated(msg.sender, msg.value, setting);\r\n        }\r\n    }\r\n    \r\n        // process game \r\n        // NOTE: ADRESSES are added to random to make sure we get different random results \r\n        // for every creator/target pair PER block\r\n        // that should be sufficient, it would be weird if a block only creates same color all time. \r\n    function ProcessGame(address creator, address target, bool creatorWantsBlue, uint256 fee) internal returns (bool blue, bool cWon) {\r\n        uint random = rand(1, creator);\r\n        blue = (random==0);\r\n      //  cWon = (creatorWantsBlue && (blue)) || (!creatorWantsBlue && (!blue)); >tfw retarded \r\n        cWon = (creatorWantsBlue == blue); // check if cwon via logic.\r\n        if (cWon){\r\n            creator.transfer(DoFee(fee*2)); // DoFee returns payment. \r\n        }\r\n        else{\r\n            target.transfer(DoFee(fee*2));\r\n        }\r\n    }\r\n    // random function via blockhas and address addition, timestamp. \r\n    function rand(uint max, address other) constant internal returns (uint result){\r\n        uint add = uint (msg.sender) + uint(other) + uint(block.timestamp);\r\n        uint random_number = addmod(uint (block.blockhash(block.number-1)), add, uint (max + 1)) ;\r\n        return random_number;   \r\n    }\r\n    \r\n    \r\n    \r\n    // pay fee to owners\r\n    // no safemath necessary, will always be fine due to control in limits of fees. \r\n    function DoFee(uint256 amt) internal returns (uint256 left){\r\n        uint256 totalFee = (amt*CFee)/10000; // total fee paid \r\n        uint256 cFee = (totalFee*HFeePart)/10000; // helper fee paid \r\n        uint256 dFee = totalFee - cFee; //dev fee paid \r\n        \r\n        Owner.transfer(dFee); // pay \r\n        HelpOwner.transfer(cFee);\r\n        \r\n        return amt-totalFee; // return excess to be paid \r\n    }\r\n    //function SetFee(uint16) public OnlyOwner;\r\n    //function SetHFee(uint16) public OnlyOwner;\r\n\r\n    // helper \r\n    \r\n    // converts settings to uint8 using multiple bits to store this data.\r\n     function DataToSetting(uint8 setting, bool offer, uint8 id) pure internal returns (uint8 output){\r\n        require(setting <= 3);\r\n\r\n        if (!offer){\r\n            return setting; // no id necessary.\r\n        }\r\n        require(id <= 15);\r\n        uint8 out=setting;\r\n        if (offer){\r\n            out = out + 4; // enable bit 3;\r\n        }\r\n        // shift ID bits 4 bits to right so they are on bit 5 to 8\r\n        uint8 conv_id = id << 4;\r\n        // add bits \r\n        out = out + conv_id; \r\n        return out;\r\n    }\r\n    \r\n    // from setting, 3 data to retrieve above.\r\n    function DataFromSetting(uint8 n) pure internal returns(uint8 set, bool offer, uint8 id){\r\n        // setting simpmly extract first 2 bits. \r\n        set = (n & 3); \r\n        // offer extract 3rd bit and convert it to bool (cannot shift and check due to ID), or might have used MOD 1 \r\n        offer = (bool) ((n & 4)==4); \r\n        // shift n by 4 bits to extract id. throws away first 4 bits, nice.\r\n        id = (n) >> 4;\r\n        \r\n    }\r\n    \r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"ViewOffer\",\"outputs\":[{\"name\":\"amt\",\"type\":\"uint256\"},{\"name\":\"setting\",\"type\":\"uint8\"},{\"name\":\"sgame\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hfee\",\"type\":\"uint16\"}],\"name\":\"SetHFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"CancelSimpleOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"setting\",\"type\":\"uint8\"},{\"name\":\"WantInOffer\",\"type\":\"bool\"}],\"name\":\"PlaySimpleGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SimpleGameList\",\"outputs\":[{\"name\":\"Owner\",\"type\":\"address\"},{\"name\":\"setting\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OfferGameList\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"setting\",\"type\":\"uint8\"},{\"name\":\"SimpleGame\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"OfferCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"UserOffers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"setting\",\"type\":\"uint8\"}],\"name\":\"CreateOffer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tfee\",\"type\":\"uint16\"}],\"name\":\"SetDevFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"setting\",\"type\":\"uint8\"}],\"name\":\"OfferPlay\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"blue\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"cwon\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SimpleGamePlayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"setting\",\"type\":\"uint8\"}],\"name\":\"SimpleGameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SimpleGameCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"setting\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"OfferGameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"OfferGameCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"blue\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"cwon\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"OfferGamePlayed\",\"type\":\"event\"}]","ContractName":"EtherWild","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f14d9055cd5d3e5c0287a0d7b69882bb4a071d4319c5fa2ea27f28f7c8e4224d"}]}