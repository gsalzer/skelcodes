{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract BTCRelay {\r\n\r\n  bool initialized = false;\r\n\r\n  struct Header {\r\n    uint32 version;\r\n    bytes32 prevBlock;\r\n    bytes32 merkleRoot;\r\n    uint32 time;\r\n    uint32 nBits;\r\n    uint32 nonce;\r\n    uint32 height;\r\n  }\r\n\r\n  mapping(bytes32 => Header) public blockHeaders; // Maps block hashes to headers\r\n\r\n  event partialFlip(bytes32 data);\r\n  // storeBlockHeader(header) pareses a length 80 bytes and stores the resulting\r\n  // Header struct in the blockHeaders mapping, where the index is the blockhash\r\n\r\n  function getHeader(bytes32 data) public returns (Header) {\r\n      return blockHeaders[data];\r\n  }\r\n\r\n  // computeMerkle(txHash, txIndex, siblings) computes the Merkle root of the\r\n  // block that the transaction corresponding to txHash was included in.\r\n  function computeMerkle(bytes32 txHash, uint txIndex, bytes32[] siblings) public pure returns (bytes32 merkleRoot){\r\n    merkleRoot = txHash;\r\n    uint256 proofLen = siblings.length;\r\n\r\n    uint256 i = 0;\r\n    while (i < proofLen){\r\n      bytes32 proofHex = siblings[i];\r\n\r\n      uint256 sideOfSibling = txIndex % 2;\r\n\r\n      if (sideOfSibling == 1) {\r\n        merkleRoot = flip32(sha256(sha256(flip32(proofHex), flip32(merkleRoot))));\r\n      }\r\n      else{\r\n        merkleRoot = flip32(sha256(sha256(flip32(merkleRoot), flip32(proofHex))));\r\n      }\r\n\r\n      txIndex = txIndex / 2;\r\n      i = i + 1;\r\n    }\r\n\r\n    return merkleRoot;\r\n  }\r\n\r\n  // Computes the target from the compressed \"bits\" form\r\n  // https://bitcoin.org/en/developer-reference#target-nbits\r\n  function targetFromBits(uint32 nBits) public pure returns (bytes32 target){\r\n    uint exp = uint(nBits) >> 24;\r\n    uint c = uint(nBits) & 0xffffff;\r\n    bytes32 result = bytes32(c * 2**(8*(exp - 3)));\r\n\r\n    return result;}\r\n\r\n  // Converts the input to the opposite endianness\r\n  function flip32(bytes32 le) public pure returns (bytes32 be) {\r\n      be = 0x0;\r\n      for (uint256 i = 0; i < 32; i++){\r\n        be >>= 8;\r\n        be |= le[i];\r\n      }\r\n  }\r\n\r\n  // BTC-style reversed double sha256\r\n  function dblShaFlip(bytes data) public returns (bytes32){\r\n      return flip32(sha256(sha256(data)));\r\n  }\r\n\r\n  // get parent of block\r\n  function getPrevBlock(bytes header) returns (bytes32) {\r\n    bytes32 tmp;\r\n    assembly {\r\n      tmp := mload(add(header, 36))\r\n    }\r\n\r\n    return flip32(bytes32(tmp));\r\n  }\r\n\r\n\r\n  function getTimestamp(bytes header) public constant returns (uint){\r\n    uint tmp;\r\n    assembly {\r\n      tmp := mload(add(header, 100))\r\n    }\r\n    return uint(flip32(bytes32(tmp)) & 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF);\r\n  }\r\n\r\n  function getVersionNo(bytes header) public constant returns (uint){\r\n    uint tmp;\r\n    assembly {\r\n      tmp := mload(add(header, 32))\r\n    }\r\n    return uint(flip32(bytes32(tmp)) & 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF);\r\n  }\r\n\r\n  function getNbits(bytes header) public constant returns (uint){\r\n    uint tmp;\r\n    assembly {\r\n      tmp := mload(add(header, 104))\r\n    }\r\n    return uint(flip32(bytes32(tmp)) & 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF);\r\n  }\r\n\r\n  function getMerkleRoot(bytes header) public constant returns (uint){\r\n    uint tmp;\r\n    assembly {\r\n      tmp := mload(add(header, 68))\r\n    }\r\n    return uint(flip32(bytes32(tmp)));\r\n  }\r\n\r\n  function getNonce(bytes header) public constant returns(uint){\r\n    uint tmp;\r\n    assembly{\r\n      tmp := mload(add(header, 108))\r\n    }\r\n    return uint(flip32(bytes32(tmp)) & 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF);\r\n  }\r\n\r\n  function initChain(bytes header, uint32 height) public {\r\n    uint32 bits = uint32(getNbits(header));\r\n    bytes32 target = targetFromBits(bits);\r\n    bytes32 hash = dblShaFlip(header);\r\n    if (hash <= target){\r\n        uint32 nonce = uint32(getNonce(header));\r\n        bytes32 merkleRoot = bytes32(getMerkleRoot(header));\r\n        uint32 timestamp = uint32(getTimestamp(header));\r\n        uint32 version = uint32(getVersionNo(header));\r\n        bytes32 prevBlock = getPrevBlock(header);\r\n        blockHeaders[hash] = Header(version, prevBlock, merkleRoot, timestamp, bits, nonce, height);\r\n        initialized = true;\r\n    }\r\n  }\r\n\r\n  function storeBlockHeader(bytes header) public returns (uint256){\r\n      bytes32 prevBlock = flip32(getPrevBlock(header));\r\n      Header storage prevBlockHeader = blockHeaders[prevBlock];\r\n      if (prevBlockHeader.version != 0){\r\n        bytes32 hash = dblShaFlip(header);\r\n        if (blockHeaders[hash].version == 0){\r\n            uint32 bits = uint32(getNbits(header));\r\n            bytes32 target = targetFromBits(bits);\r\n            if (hash <= target){\r\n                uint32 nonce = uint32(getNonce(header));\r\n                bytes32 merkleRoot = bytes32(getMerkleRoot(header));\r\n                uint32 timestamp = uint32(getTimestamp(header));\r\n                uint32 version = uint32(getVersionNo(header));\r\n                uint32 height = prevBlockHeader.height + 1;\r\n                blockHeaders[hash] = Header(version, prevBlock, merkleRoot, timestamp, bits, nonce, height);\r\n                return height;\r\n            }\r\n        }\r\n        return 0;\r\n      }\r\n      return 0;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"storeBlockHeader\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"getNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"dblShaFlip\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes\"},{\"name\":\"height\",\"type\":\"uint32\"}],\"name\":\"initChain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"blockHeaders\",\"outputs\":[{\"name\":\"version\",\"type\":\"uint32\"},{\"name\":\"prevBlock\",\"type\":\"bytes32\"},{\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"name\":\"time\",\"type\":\"uint32\"},{\"name\":\"nBits\",\"type\":\"uint32\"},{\"name\":\"nonce\",\"type\":\"uint32\"},{\"name\":\"height\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"getVersionNo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"getHeader\",\"outputs\":[{\"components\":[{\"name\":\"version\",\"type\":\"uint32\"},{\"name\":\"prevBlock\",\"type\":\"bytes32\"},{\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"name\":\"time\",\"type\":\"uint32\"},{\"name\":\"nBits\",\"type\":\"uint32\"},{\"name\":\"nonce\",\"type\":\"uint32\"},{\"name\":\"height\",\"type\":\"uint32\"}],\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"getMerkleRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"txHash\",\"type\":\"bytes32\"},{\"name\":\"txIndex\",\"type\":\"uint256\"},{\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"name\":\"computeMerkle\",\"outputs\":[{\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"le\",\"type\":\"bytes32\"}],\"name\":\"flip32\",\"outputs\":[{\"name\":\"be\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"getPrevBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nBits\",\"type\":\"uint32\"}],\"name\":\"targetFromBits\",\"outputs\":[{\"name\":\"target\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"getNbits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"partialFlip\",\"type\":\"event\"}]","ContractName":"BTCRelay","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://91a306217429f4b3d25c72800038dad108d35f76b80c2bf896a40fdba4f096fa"}]}