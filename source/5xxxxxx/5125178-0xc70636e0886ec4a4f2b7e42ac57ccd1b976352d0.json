{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/// @title Math operations with safety checks\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // require(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function toPower2(uint256 a) internal pure returns (uint256) {\r\n        return mul(a, a);\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        uint256 c = (a + 1) / 2;\r\n        uint256 b = a;\r\n        while (c < b) {\r\n            b = c;\r\n            c = (a / c + c) / 2;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n\r\n/// @title ERC223Receiver Interface\r\n/// @dev Based on the specs form: https://github.com/ethereum/EIPs/issues/223\r\ncontract ERC223Receiver {\r\n    function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\r\n}\r\n\r\n\r\n\r\n/// @title Market Maker Interface.\r\n/// @author Tal Beja.\r\ncontract MarketMaker is ERC223Receiver {\r\n\r\n  function getCurrentPrice() public constant returns (uint _price);\r\n  function change(address _fromToken, uint _amount, address _toToken) public returns (uint _returnAmount);\r\n  function change(address _fromToken, uint _amount, address _toToken, uint _minReturn) public returns (uint _returnAmount);\r\n  function change(address _toToken) public returns (uint _returnAmount);\r\n  function change(address _toToken, uint _minReturn) public returns (uint _returnAmount);\r\n  function quote(address _fromToken, uint _amount, address _toToken) public constant returns (uint _returnAmount);\r\n  function openForPublicTrade() public returns (bool success);\r\n  function isOpenForPublic() public returns (bool success);\r\n\r\n  event Change(address indexed fromToken, uint inAmount, address indexed toToken, uint returnAmount, address indexed account);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title Ellipse Market Maker Interfase\r\n/// @author Tal Beja\r\ncontract IEllipseMarketMaker is MarketMaker {\r\n\r\n    // precision for price representation (as in ether or tokens).\r\n    uint256 public constant PRECISION = 10 ** 18;\r\n\r\n    // The tokens pair.\r\n    ERC20 public token1;\r\n    ERC20 public token2;\r\n\r\n    // The tokens reserves.\r\n    uint256 public R1;\r\n    uint256 public R2;\r\n\r\n    // The tokens full suplly.\r\n    uint256 public S1;\r\n    uint256 public S2;\r\n\r\n    // State flags.\r\n    bool public operational;\r\n    bool public openForPublic;\r\n\r\n    // Library contract address.\r\n    address public mmLib;\r\n\r\n    function supportsToken(address token) public constant returns (bool);\r\n\r\n    function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256);\r\n\r\n    function validateReserves() public view returns (bool);\r\n\r\n    function withdrawExcessReserves() public returns (uint256);\r\n\r\n    function initializeAfterTransfer() public returns (bool);\r\n\r\n    function initializeOnTransfer() public returns (bool);\r\n\r\n    function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256);\r\n}\r\n\r\n\r\n/// @title ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/issues/20)\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n    function balanceOf(address _owner) constant public returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic authorization control functions,\r\n/// this simplifies the implementation of \"user permissions\".\r\n/// @dev Based on OpenZeppelin's Ownable.\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed _by, address indexed _to);\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    /// @dev Constructor sets the original `owner` of the contract to the sender account.\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Reverts if called by any account other than the owner.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerCandidate() {\r\n        require(msg.sender == newOwnerCandidate);\r\n        _;\r\n    }\r\n\r\n    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\r\n    /// @param _newOwnerCandidate address The address to transfer ownership to.\r\n    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\r\n        require(_newOwnerCandidate != address(0));\r\n\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @dev Accept ownership transfer. This method needs to be called by the perviously proposed owner.\r\n    function acceptOwnership() external onlyOwnerCandidate {\r\n        address previousOwner = owner;\r\n\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = address(0);\r\n\r\n        OwnershipTransferred(previousOwner, owner);\r\n    }\r\n}\r\n\r\n\r\n\r\n /// @title Standard ERC223 Token Receiver implementing tokenFallback function and tokenPayable modifier\r\n\r\ncontract Standard223Receiver is ERC223Receiver {\r\n  Tkn tkn;\r\n\r\n  struct Tkn {\r\n    address addr;\r\n    address sender; // the transaction caller\r\n    uint256 value;\r\n  }\r\n\r\n  bool __isTokenFallback;\r\n\r\n  modifier tokenPayable {\r\n    require(__isTokenFallback);\r\n    _;\r\n  }\r\n\r\n  /// @dev Called when the receiver of transfer is contract\r\n  /// @param _sender address the address of tokens sender\r\n  /// @param _value uint256 the amount of tokens to be transferred.\r\n  /// @param _data bytes data that can be attached to the token transation\r\n  function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\r\n    if (!supportsToken(msg.sender)) {\r\n      return false;\r\n    }\r\n\r\n    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\r\n    // Solution: Remove the the data\r\n    tkn = Tkn(msg.sender, _sender, _value);\r\n    __isTokenFallback = true;\r\n    if (!address(this).delegatecall(_data)) {\r\n      __isTokenFallback = false;\r\n      return false;\r\n    }\r\n    // avoid doing an overwrite to .token, which would be more expensive\r\n    // makes accessing .tkn values outside tokenPayable functions unsafe\r\n    __isTokenFallback = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  function supportsToken(address token) public constant returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @title TokenOwnable\r\n/// @dev The TokenOwnable contract adds a onlyTokenOwner modifier as a tokenReceiver with ownable addaptation\r\n\r\ncontract TokenOwnable is Standard223Receiver, Ownable {\r\n    /// @dev Reverts if called by any account other than the owner for token sending.\r\n    modifier onlyTokenOwner() {\r\n        require(tkn.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Ellipse Market Maker Library.\r\n/// @dev market maker, using ellipse equation.\r\n/// @dev for more information read the appendix of the CLN white paper: https://cln.network/pdf/cln_whitepaper.pdf\r\n/// @author Tal Beja.\r\ncontract EllipseMarketMakerLib is TokenOwnable, IEllipseMarketMaker {\r\n  using SafeMath for uint256;\r\n\r\n  // temp reserves\r\n  uint256 private l_R1;\r\n  uint256 private l_R2;\r\n\r\n  modifier notConstructed() {\r\n    require(mmLib == address(0));\r\n    _;\r\n  }\r\n\r\n  /// @dev Reverts if not operational\r\n  modifier isOperational() {\r\n    require(operational);\r\n    _;\r\n  }\r\n\r\n  /// @dev Reverts if operational\r\n  modifier notOperational() {\r\n    require(!operational);\r\n    _;\r\n  }\r\n\r\n  /// @dev Reverts if msg.sender can't trade\r\n  modifier canTrade() {\r\n    require(openForPublic || msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /// @dev Reverts if tkn.sender can't trade\r\n  modifier canTrade223() {\r\n    require (openForPublic || tkn.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /// @dev The Market Maker constructor\r\n  /// @param _mmLib address address of the market making lib contract\r\n  /// @param _token1 address contract of the first token for marker making (CLN)\r\n  /// @param _token2 address contract of the second token for marker making (CC)\r\n  function constructor(address _mmLib, address _token1, address _token2) public onlyOwner notConstructed returns (bool) {\r\n    require(_mmLib != address(0));\r\n    require(_token1 != address(0));\r\n    require(_token2 != address(0));\r\n    require(_token1 != _token2);\r\n\r\n    mmLib = _mmLib;\r\n    token1 = ERC20(_token1);\r\n    token2 = ERC20(_token2);\r\n    R1 = 0;\r\n    R2 = 0;\r\n    S1 = token1.totalSupply();\r\n    S2 = token2.totalSupply();\r\n\r\n    operational = false;\r\n    openForPublic = false;\r\n\r\n    return true;\r\n  }\r\n\r\n  /// @dev open the Market Maker for public trade.\r\n  function openForPublicTrade() public onlyOwner isOperational returns (bool) {\r\n    openForPublic = true;\r\n    return true;\r\n  }\r\n\r\n  /// @dev returns true iff the contract is open for public trade.\r\n  function isOpenForPublic() public onlyOwner returns (bool) {\r\n    return (openForPublic && operational);\r\n  }\r\n\r\n  /// @dev returns true iff token is supperted by this contract (for erc223/677 tokens calls)\r\n  /// @param _token address adress of the contract to check\r\n  function supportsToken(address _token) public constant returns (bool) {\r\n      return (token1 == _token || token2 == _token);\r\n  }\r\n\r\n  /// @dev initialize the contract after transfering all of the tokens form the pair\r\n  function initializeAfterTransfer() public notOperational onlyOwner returns (bool) {\r\n    require(initialize());\r\n    return true;\r\n  }\r\n\r\n  /// @dev initialize the contract during erc223/erc677 transfer of all of the tokens form the pair\r\n  function initializeOnTransfer() public notOperational onlyTokenOwner tokenPayable returns (bool) {\r\n    require(initialize());\r\n    return true;\r\n  }\r\n\r\n  /// @dev initialize the contract.\r\n  function initialize() private returns (bool success) {\r\n    R1 = token1.balanceOf(this);\r\n    R2 = token2.balanceOf(this);\r\n    // one reserve should be full and the second should be empty\r\n    success = ((R1 == 0 && R2 == S2) || (R2 == 0 && R1 == S1));\r\n    if (success) {\r\n      operational = true;\r\n    }\r\n  }\r\n\r\n  /// @dev the price of token1 in terms of token2, represented in 18 decimals.\r\n  function getCurrentPrice() public constant isOperational returns (uint256) {\r\n    return getPrice(R1, R2, S1, S2);\r\n  }\r\n\r\n  /// @dev the price of token1 in terms of token2, represented in 18 decimals.\r\n  /// price = (S1 - R1) / (S2 - R2) * (S2 / S1)^2\r\n  /// @param _R1 uint256 reserve of the first token\r\n  /// @param _R2 uint256 reserve of the second token\r\n  /// @param _S1 uint256 total supply of the first token\r\n  /// @param _S2 uint256 total supply of the second token\r\n  function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256 price) {\r\n    price = PRECISION;\r\n    price = price.mul(_S1.sub(_R1));\r\n    price = price.div(_S2.sub(_R2));\r\n    price = price.mul(_S2);\r\n    price = price.div(_S1);\r\n    price = price.mul(_S2);\r\n    price = price.div(_S1);\r\n  }\r\n\r\n  /// @dev get a quote for exchanging and update temporary reserves.\r\n  /// @param _fromToken the token to sell from\r\n  /// @param _inAmount the amount to sell\r\n  /// @param _toToken the token to buy\r\n  /// @return the return amount of the buying token\r\n  function quoteAndReserves(address _fromToken, uint256 _inAmount, address _toToken) private isOperational returns (uint256 returnAmount) {\r\n    // if buying token2 from token1\r\n    if (token1 == _fromToken && token2 == _toToken) {\r\n      // add buying amount to the temp reserve\r\n      l_R1 = R1.add(_inAmount);\r\n      // calculate the other reserve\r\n      l_R2 = calcReserve(l_R1, S1, S2);\r\n      if (l_R2 > R2) {\r\n        return 0;\r\n      }\r\n      // the returnAmount is the other reserve difference\r\n      returnAmount = R2.sub(l_R2);\r\n    }\r\n    // if buying token1 from token2\r\n    else if (token2 == _fromToken && token1 == _toToken) {\r\n      // add buying amount to the temp reserve\r\n      l_R2 = R2.add(_inAmount);\r\n      // calculate the other reserve\r\n      l_R1 = calcReserve(l_R2, S2, S1);\r\n      if (l_R1 > R1) {\r\n        return 0;\r\n      }\r\n      // the returnAmount is the other reserve difference\r\n      returnAmount = R1.sub(l_R1);\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /// @dev get a quote for exchanging.\r\n  /// @param _fromToken the token to sell from\r\n  /// @param _inAmount the amount to sell\r\n  /// @param _toToken the token to buy\r\n  /// @return the return amount of the buying token\r\n  function quote(address _fromToken, uint256 _inAmount, address _toToken) public constant isOperational returns (uint256 returnAmount) {\r\n    uint256 _R1;\r\n    uint256 _R2;\r\n    // if buying token2 from token1\r\n    if (token1 == _fromToken && token2 == _toToken) {\r\n      // add buying amount to the temp reserve\r\n      _R1 = R1.add(_inAmount);\r\n      // calculate the other reserve\r\n      _R2 = calcReserve(_R1, S1, S2);\r\n      if (_R2 > R2) {\r\n        return 0;\r\n      }\r\n      // the returnAmount is the other reserve difference\r\n      returnAmount = R2.sub(_R2);\r\n    }\r\n    // if buying token1 from token2\r\n    else if (token2 == _fromToken && token1 == _toToken) {\r\n      // add buying amount to the temp reserve\r\n      _R2 = R2.add(_inAmount);\r\n      // calculate the other reserve\r\n      _R1 = calcReserve(_R2, S2, S1);\r\n      if (_R1 > R1) {\r\n        return 0;\r\n      }\r\n      // the returnAmount is the other reserve difference\r\n      returnAmount = R1.sub(_R1);\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /// @dev calculate second reserve from the first reserve and the supllies.\r\n  /// @dev formula: R2 = S2 * (S1 - sqrt(R1 * S1 * 2  - R1 ^ 2)) / S1\r\n  /// @dev the equation is simetric, so by replacing _S1 and _S2 and _R1 with _R2 we can calculate the first reserve from the second reserve\r\n  /// @param _R1 the first reserve\r\n  /// @param _S1 the first total supply\r\n  /// @param _S2 the second total supply\r\n  /// @return _R2 the second reserve\r\n  function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256 _R2) {\r\n    _R2 = _S2\r\n      .mul(\r\n        _S1\r\n        .sub(\r\n          _R1\r\n          .mul(_S1)\r\n          .mul(2)\r\n          .sub(\r\n            _R1\r\n            .toPower2()\r\n          )\r\n          .sqrt()\r\n        )\r\n      )\r\n      .div(_S1);\r\n  }\r\n\r\n  /// @dev change tokens.\r\n  /// @param _fromToken the token to sell from\r\n  /// @param _inAmount the amount to sell\r\n  /// @param _toToken the token to buy\r\n  /// @return the return amount of the buying token\r\n  function change(address _fromToken, uint256 _inAmount, address _toToken) public canTrade returns (uint256 returnAmount) {\r\n    return change(_fromToken, _inAmount, _toToken, 0);\r\n  }\r\n\r\n  /// @dev change tokens.\r\n  /// @param _fromToken the token to sell from\r\n  /// @param _inAmount the amount to sell\r\n  /// @param _toToken the token to buy\r\n  /// @param _minReturn the munimum token to buy\r\n  /// @return the return amount of the buying token\r\n  function change(address _fromToken, uint256 _inAmount, address _toToken, uint256 _minReturn) public canTrade returns (uint256 returnAmount) {\r\n    // pull transfer the selling token\r\n    require(ERC20(_fromToken).transferFrom(msg.sender, this, _inAmount));\r\n    // exchange the token\r\n    returnAmount = exchange(_fromToken, _inAmount, _toToken, _minReturn);\r\n    if (returnAmount == 0) {\r\n      // if no return value revert\r\n      revert();\r\n    }\r\n    // transfer the buying token\r\n    ERC20(_toToken).transfer(msg.sender, returnAmount);\r\n    // validate the reserves\r\n    require(validateReserves());\r\n    Change(_fromToken, _inAmount, _toToken, returnAmount, msg.sender);\r\n  }\r\n\r\n  /// @dev change tokens using erc223\\erc677 transfer.\r\n  /// @param _toToken the token to buy\r\n  /// @return the return amount of the buying token\r\n  function change(address _toToken) public canTrade223 tokenPayable returns (uint256 returnAmount) {\r\n    return change(_toToken, 0);\r\n  }\r\n\r\n  /// @dev change tokens using erc223\\erc677 transfer.\r\n  /// @param _toToken the token to buy\r\n  /// @param _minReturn the munimum token to buy\r\n  /// @return the return amount of the buying token\r\n  function change(address _toToken, uint256 _minReturn) public canTrade223 tokenPayable returns (uint256 returnAmount) {\r\n    // get from token and in amount from the tkn object\r\n    address fromToken = tkn.addr;\r\n    uint256 inAmount = tkn.value;\r\n    // exchange the token\r\n    returnAmount = exchange(fromToken, inAmount, _toToken, _minReturn);\r\n    if (returnAmount == 0) {\r\n      // if no return value revert\r\n      revert();\r\n    }\r\n    // transfer the buying token\r\n    ERC20(_toToken).transfer(tkn.sender, returnAmount);\r\n    // validate the reserves\r\n    require(validateReserves());\r\n    Change(fromToken, inAmount, _toToken, returnAmount, tkn.sender);\r\n  }\r\n\r\n  /// @dev exchange tokens.\r\n  /// @param _fromToken the token to sell from\r\n  /// @param _inAmount the amount to sell\r\n  /// @param _toToken the token to buy\r\n  /// @param _minReturn the munimum token to buy\r\n  /// @return the return amount of the buying token\r\n  function exchange(address _fromToken, uint256 _inAmount, address _toToken, uint256 _minReturn) private returns (uint256 returnAmount) {\r\n    // get quote and update temp reserves\r\n    returnAmount = quoteAndReserves(_fromToken, _inAmount, _toToken);\r\n    // if the return amount is lower than minimum return, don't buy\r\n    if (returnAmount == 0 || returnAmount < _minReturn) {\r\n      return 0;\r\n    }\r\n\r\n    // update reserves from temp values\r\n    updateReserve();\r\n  }\r\n\r\n  /// @dev update token reserves from temp values\r\n  function updateReserve() private {\r\n    R1 = l_R1;\r\n    R2 = l_R2;\r\n  }\r\n\r\n  /// @dev validate that the tokens balances don't goes below reserves\r\n  function validateReserves() public view returns (bool) {\r\n    return (token1.balanceOf(this) >= R1 && token2.balanceOf(this) >= R2);\r\n  }\r\n\r\n  /// @dev allow admin to withraw excess tokens accumulated due to precision\r\n  function withdrawExcessReserves() public onlyOwner returns (uint256 returnAmount) {\r\n    // if there is excess of token 1, transfer it to the owner\r\n    if (token1.balanceOf(this) > R1) {\r\n      returnAmount = returnAmount.add(token1.balanceOf(this).sub(R1));\r\n      token1.transfer(msg.sender, token1.balanceOf(this).sub(R1));\r\n    }\r\n    // if there is excess of token 2, transfer it to the owner\r\n    if (token2.balanceOf(this) > R2) {\r\n      returnAmount = returnAmount.add(token2.balanceOf(this).sub(R2));\r\n      token2.transfer(msg.sender, token2.balanceOf(this).sub(R2));\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"supportsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"requestOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operational\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toToken\",\"type\":\"address\"}],\"name\":\"change\",\"outputs\":[{\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initializeOnTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mmLib\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"S2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_R1\",\"type\":\"uint256\"},{\"name\":\"_S1\",\"type\":\"uint256\"},{\"name\":\"_S2\",\"type\":\"uint256\"}],\"name\":\"calcReserve\",\"outputs\":[{\"name\":\"_R2\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mmLib\",\"type\":\"address\"},{\"name\":\"_token1\",\"type\":\"address\"},{\"name\":\"_token2\",\"type\":\"address\"}],\"name\":\"constructor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validateReserves\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"isOpenForPublic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"S1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawExcessReserves\",\"outputs\":[{\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initializeAfterTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromToken\",\"type\":\"address\"},{\"name\":\"_inAmount\",\"type\":\"uint256\"},{\"name\":\"_toToken\",\"type\":\"address\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"change\",\"outputs\":[{\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fromToken\",\"type\":\"address\"},{\"name\":\"_inAmount\",\"type\":\"uint256\"},{\"name\":\"_toToken\",\"type\":\"address\"}],\"name\":\"quote\",\"outputs\":[{\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"R1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_R1\",\"type\":\"uint256\"},{\"name\":\"_R2\",\"type\":\"uint256\"},{\"name\":\"_S1\",\"type\":\"uint256\"},{\"name\":\"_S2\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromToken\",\"type\":\"address\"},{\"name\":\"_inAmount\",\"type\":\"uint256\"},{\"name\":\"_toToken\",\"type\":\"address\"}],\"name\":\"change\",\"outputs\":[{\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toToken\",\"type\":\"address\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"change\",\"outputs\":[{\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openForPublicTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openForPublic\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"R2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"inAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Change\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EllipseMarketMakerLib","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e07437398c8063256f4539de2815dd3347816cfbdafa1a03c1a21987495774b0"}]}