{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract NeuroChainClausius is Owned, ERC20Interface {\r\n\r\n  // Adding safe calculation methods to uint256\r\n  using SafeMath for uint;\r\n  // Defining balances mapping (ERC20)\r\n  mapping(address => uint256) balances;\r\n  // Defining allowances mapping (ERC20)\r\n  mapping(address => mapping (address => uint256)) allowed;\r\n  // Defining addresses allowed to bypass global freeze\r\n  mapping(address => bool) public freezeBypassing;\r\n  // Defining addresses association between NeuroChain and ETH network\r\n  mapping(address => string) public neuroChainAddresses;\r\n  // Event raised when a NeuroChain address is changed\r\n  event NeuroChainAddressSet(\r\n    address ethAddress,\r\n    string neurochainAddress,\r\n    uint timestamp,\r\n    bool isForcedChange\r\n  );\r\n  // Event raised when trading status is toggled\r\n  event FreezeStatusChanged(\r\n    bool toStatus,\r\n    uint timestamp\r\n  );\r\n  // Token Symbol\r\n  string public symbol = \"NCC\";\r\n  // Token Name\r\n  string public name = \"NeuroChain Clausius\";\r\n  // Token Decimals\r\n  uint8 public decimals = 18;\r\n  // Total supply of token\r\n  uint public _totalSupply = 657440000 * 10**uint(decimals);\r\n  // Current distributed supply\r\n  uint public _circulatingSupply = 0;\r\n  // Global freeze toggle\r\n  bool public tradingLive = false;\r\n  // Address of the Crowdsale Contract\r\n  address public icoContractAddress;\r\n  /**\r\n   * @notice Sending Tokens to an address\r\n   * @param to The receiver address\r\n   * @param tokens The amount of tokens to send (without de decimal part)\r\n   * @return {\"success\": \"If the operation completed successfuly\"}\r\n   */\r\n  function distributeSupply(\r\n    address to,\r\n    uint tokens\r\n  )\r\n  public onlyOwner returns (bool success)\r\n  {\r\n    uint tokenAmount = tokens.mul(10**uint(decimals));\r\n    require(_circulatingSupply.add(tokenAmount) <= _totalSupply);\r\n    _circulatingSupply = _circulatingSupply.add(tokenAmount);\r\n    balances[to] = tokenAmount;\r\n    return true;\r\n  }\r\n  /**\r\n   * @notice Allowing a spender to bypass global frezze\r\n   * @param sender The allowed address\r\n   * @return {\"success\": \"If the operation completed successfuly\"}\r\n   */\r\n  function allowFreezeBypass(\r\n    address sender\r\n  )\r\n  public onlyOwner returns (bool success)\r\n  {\r\n    freezeBypassing[sender] = true;\r\n    return true;\r\n  }\r\n  /**\r\n   * @notice Sets if the trading is live\r\n   * @param isLive Enabling/Disabling trading\r\n   */\r\n  function setTradingStatus(\r\n    bool isLive\r\n  )\r\n  public onlyOwner\r\n  {\r\n    tradingLive = isLive;\r\n    FreezeStatusChanged(tradingLive, block.timestamp);\r\n  }\r\n  // Modifier that requires the trading to be live or\r\n  // allowed to bypass the freeze status\r\n  modifier tokenTradingMustBeLive(address sender) {\r\n    require(tradingLive || freezeBypassing[sender]);\r\n    _;\r\n  }\r\n  /**\r\n   * @notice Sets the ICO Contract Address variable to be used with the\r\n   * `onlyIcoContract` modifier.\r\n   * @param contractAddress The NeuroChainCrowdsale deployed address\r\n   */\r\n  function setIcoContractAddress(\r\n    address contractAddress\r\n  )\r\n  public onlyOwner\r\n  {\r\n    freezeBypassing[contractAddress] = true;\r\n    icoContractAddress = contractAddress;\r\n  }\r\n  // Modifier that requires msg.sender to be Crowdsale Contract\r\n  modifier onlyIcoContract() {\r\n    require(msg.sender == icoContractAddress);\r\n    _;\r\n  }\r\n  /**\r\n   * @notice Permit `msg.sender` to set its NeuroChain Address\r\n   * @param neurochainAddress The NeuroChain Address\r\n   */\r\n  function setNeuroChainAddress(\r\n    string neurochainAddress\r\n  )\r\n  public\r\n  {\r\n    neuroChainAddresses[msg.sender] = neurochainAddress;\r\n    NeuroChainAddressSet(\r\n      msg.sender,\r\n      neurochainAddress,\r\n      block.timestamp,\r\n      false\r\n    );\r\n  }\r\n  /**\r\n   * @notice Force NeuroChain Address to be associated to a\r\n   * standard ERC20 account\r\n   * @dev Can only be called by the ICO Contract\r\n   * @param ethAddress The ETH address to associate\r\n   * @param neurochainAddress The NeuroChain Address\r\n   */\r\n  function forceNeuroChainAddress(\r\n    address ethAddress,\r\n    string neurochainAddress\r\n  )\r\n  public onlyIcoContract\r\n  {\r\n    neuroChainAddresses[ethAddress] = neurochainAddress;\r\n    NeuroChainAddressSet(\r\n      ethAddress,\r\n      neurochainAddress,\r\n      block.timestamp,\r\n      true\r\n    );\r\n  }\r\n  /**\r\n   * @notice Return the total supply of the token\r\n   * @dev This function is part of the ERC20 standard\r\n   * @return The token supply\r\n   */\r\n  function totalSupply() public constant returns (uint) {\r\n    return _totalSupply;\r\n  }\r\n  /**\r\n   * @notice Get the token balance of `tokenOwner`\r\n   * @dev This function is part of the ERC20 standard\r\n   * @param tokenOwner The wallet to get the balance of\r\n   * @return {\"balance\": \"The balance of `tokenOwner`\"}\r\n   */\r\n  function balanceOf(\r\n    address tokenOwner\r\n  )\r\n  public constant returns (uint balance)\r\n  {\r\n    return balances[tokenOwner];\r\n  }\r\n  /**\r\n   * @notice Transfers `tokens` from msg.sender to `to`\r\n   * @dev This function is part of the ERC20 standard\r\n   * @param to The address that receives the tokens\r\n   * @param tokens Token amount to transfer\r\n   * @return {\"success\": \"If the operation completed successfuly\"}\r\n   */\r\n  function transfer(\r\n    address to,\r\n    uint tokens\r\n  )\r\n  public tokenTradingMustBeLive(msg.sender) returns (bool success)\r\n  {\r\n    balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n    balances[to] = balances[to].add(tokens);\r\n    Transfer(msg.sender, to, tokens);\r\n    return true;\r\n  }\r\n  /**\r\n   * @notice Transfer tokens from an address to another\r\n   * through an allowance made beforehand\r\n   * @dev This function is part of the ERC20 standard\r\n   * @param from The address sending the tokens\r\n   * @param to The address recieving the tokens\r\n   * @param tokens Token amount to transfer\r\n   * @return {\"success\": \"If the operation completed successfuly\"}\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint tokens\r\n  )\r\n  public tokenTradingMustBeLive(from) returns (bool success)\r\n  {\r\n    balances[from] = balances[from].sub(tokens);\r\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n    balances[to] = balances[to].add(tokens);\r\n    Transfer(from, to, tokens);\r\n    return true;\r\n  }\r\n  /**\r\n   * @notice Approve an address to send `tokenAmount` tokens to `msg.sender` (make an allowance)\r\n   * @dev This function is part of the ERC20 standard\r\n   * @param spender The allowed address\r\n   * @param tokens The maximum amount allowed to spend\r\n   * @return {\"success\": \"If the operation completed successfuly\"}\r\n   */\r\n  function approve(\r\n    address spender,\r\n    uint tokens\r\n  )\r\n  public returns (bool success)\r\n  {\r\n    allowed[msg.sender][spender] = tokens;\r\n    Approval(msg.sender, spender, tokens);\r\n    return true;\r\n  }\r\n  /**\r\n   * @notice Get the remaining allowance for a spender on a given address\r\n   * @dev This function is part of the ERC20 standard\r\n   * @param tokenOwner The address that owns the tokens\r\n   * @param spender The spender\r\n   * @return {\"remaining\": \"The amount of tokens remaining in the allowance\"}\r\n   */\r\n  function allowance(\r\n    address tokenOwner,\r\n    address spender\r\n  )\r\n  public constant returns (uint remaining)\r\n  {\r\n    return allowed[tokenOwner][spender];\r\n  }\r\n  /**\r\n   * @notice Permits to create an approval on a contract and then call a method\r\n   * on the approved contract right away.\r\n   * @param spender The allowed address\r\n   * @param tokens The maximum amount allowed to spend\r\n   * @param data The data sent back as parameter to the contract (bytes array)\r\n   * @return {\"success\": \"If the operation completed successfuly\"}\r\n   */\r\n  function approveAndCall(\r\n    address spender,\r\n    uint tokens,\r\n    bytes data\r\n  )\r\n  public returns (bool success)\r\n  {\r\n    allowed[msg.sender][spender] = tokens;\r\n    Approval(msg.sender, spender, tokens);\r\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n    return true;\r\n  }\r\n  /**\r\n   * @notice Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract\r\n   * @param tokenAddress The received ERC20 token address\r\n   * @param tokens The amount of ERC20 tokens to withdraw from this contract\r\n   * @return {\"success\": \"If the operation completed successfuly\"}\r\n   */\r\n  function transferAnyERC20Token(\r\n    address tokenAddress,\r\n    uint tokens\r\n  )\r\n  public onlyOwner returns (bool success)\r\n  {\r\n    return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers with 18 decimals, represented as uints (e.g. ether or token values)\r\n    */\r\n    uint constant ETHER_PRECISION = 10 ** 18;\r\n    function ediv(uint x, uint y) internal pure returns (uint z) {\r\n        // Put x to the 36th order of magnitude, so natural division will put it back to the 18th\r\n        // Adding y/2 before putting x back to the 18th order of magnitude is necessary to force the EVM to round up instead of down\r\n        z = add(mul(x, ETHER_PRECISION), y / 2) / y;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"allowFreezeBypass\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingLive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setIcoContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isLive\",\"type\":\"bool\"}],\"name\":\"setTradingStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"neurochainAddress\",\"type\":\"string\"}],\"name\":\"setNeuroChainAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"distributeSupply\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ethAddress\",\"type\":\"address\"},{\"name\":\"neurochainAddress\",\"type\":\"string\"}],\"name\":\"forceNeuroChainAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeBypassing\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_circulatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"neuroChainAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"neurochainAddress\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isForcedChange\",\"type\":\"bool\"}],\"name\":\"NeuroChainAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"toStatus\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FreezeStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NeuroChainClausius","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5a6d6d00881be2eacc6c8e1d7c2f9df679bd51429e2cea0ebc48bbe32dd990cc"}]}