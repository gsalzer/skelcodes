{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title ERC20\r\n * @dev A standard interface for tokens.\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n  \r\n    /// @dev Returns the total token supply\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @dev Returns the account balance of the account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @dev Transfers _value number of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Transfers _value number of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract Fundraiser {\r\n\r\n    event Beginning(\r\n        bytes32 _causeSecret\r\n    );\r\n\r\n    event Participation(\r\n        address _participant,\r\n        bytes32 _message,\r\n        uint256 _entries,\r\n        uint256 _refund\r\n    );\r\n\r\n    event Raise(\r\n        address _participant,\r\n        uint256 _entries,\r\n        uint256 _refund\r\n    );\r\n\r\n    event Revelation(\r\n        bytes32 _causeMessage\r\n    );\r\n\r\n    event Selection(\r\n        address _participant,\r\n        bytes32 _participantMessage,\r\n        bytes32 _causeMessage,\r\n        bytes32 _ownerMessage\r\n    );\r\n\r\n    event Cancellation();\r\n\r\n    event Withdrawal(\r\n        address _address\r\n    );\r\n\r\n    struct Deployment {\r\n        address _cause;\r\n        address _causeWallet;\r\n        uint256 _causeSplit;\r\n        uint256 _participantSplit;\r\n        address _owner;\r\n        address _ownerWallet;\r\n        uint256 _ownerSplit;\r\n        bytes32 _ownerSecret;\r\n        uint256 _valuePerEntry;\r\n        uint256 _deployTime;\r\n        uint256 _endTime;\r\n        uint256 _expireTime;\r\n        uint256 _destructTime;\r\n        uint256 _entropy;\r\n    }\r\n\r\n    struct State {\r\n        bytes32 _causeSecret;\r\n        bytes32 _causeMessage;\r\n        bool _causeWithdrawn;\r\n        address _participant;\r\n        bool _participantWithdrawn;\r\n        bytes32 _ownerMessage;\r\n        bool _ownerWithdrawn;\r\n        bool _cancelled;\r\n        uint256 _participants;\r\n        uint256 _entries;\r\n        uint256 _revealBlockNumber;\r\n        uint256 _revealBlockHash;\r\n    }\r\n\r\n    struct Participant {\r\n        bytes32 _message;\r\n        uint256 _entries;\r\n    }\r\n\r\n    struct Fund {\r\n        address _participant;\r\n        uint256 _entries;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == deployment._owner);\r\n        _;\r\n    }\r\n\r\n    modifier neverOwner() {\r\n        require(msg.sender != deployment._owner);\r\n        require(msg.sender != deployment._ownerWallet);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCause() {\r\n        require(msg.sender == deployment._cause);\r\n        _;\r\n    }\r\n\r\n    modifier neverCause() {\r\n        require(msg.sender != deployment._cause);\r\n        require(msg.sender != deployment._causeWallet);\r\n        _;\r\n    }\r\n\r\n    modifier participationPhase() {\r\n        require(now < deployment._endTime);\r\n        _;\r\n    }\r\n\r\n    modifier recapPhase() {\r\n        require((now >= deployment._endTime) && (now < deployment._expireTime));\r\n        _;\r\n    }\r\n\r\n    modifier destructionPhase() {\r\n        require(now >= deployment._destructTime);\r\n        _;\r\n    }\r\n    \r\n    Deployment public deployment;\r\n    mapping(address => Participant) public participants;\r\n    Fund[] private funds;\r\n    State private _state;\r\n\r\n    function Fundraiser(\r\n        address _cause,\r\n        address _causeWallet,\r\n        uint256 _causeSplit,\r\n        uint256 _participantSplit,\r\n        address _ownerWallet,\r\n        uint256 _ownerSplit,\r\n        bytes32 _ownerSecret,\r\n        uint256 _valuePerEntry,\r\n        uint256 _endTime,\r\n        uint256 _expireTime,\r\n        uint256 _destructTime,\r\n        uint256 _entropy\r\n    ) public {\r\n        require(_cause != 0x0);\r\n        require(_causeWallet != 0x0);\r\n        require(_causeSplit != 0);\r\n        require(_participantSplit != 0);\r\n        require(_ownerWallet != 0x0);\r\n        require(_causeSplit + _participantSplit + _ownerSplit == 1000);\r\n        require(_ownerSecret != 0x0);\r\n        require(_valuePerEntry != 0);\r\n        require(_endTime > now); // participation phase\r\n        require(_expireTime > _endTime); // end phase\r\n        require(_destructTime > _expireTime); // destruct phase\r\n        require(_entropy > 0);\r\n\r\n        // set the deployment\r\n        deployment = Deployment(\r\n            _cause,\r\n            _causeWallet,\r\n            _causeSplit,\r\n            _participantSplit,\r\n            msg.sender,\r\n            _ownerWallet,\r\n            _ownerSplit,\r\n            _ownerSecret,\r\n            _valuePerEntry,\r\n            now,\r\n            _endTime,\r\n            _expireTime,\r\n            _destructTime,\r\n            _entropy\r\n        );\r\n\r\n    }\r\n\r\n    // returns the post-deployment state of the contract\r\n    function state() public view returns (\r\n        bytes32 _causeSecret,\r\n        bytes32 _causeMessage,\r\n        bool _causeWithdrawn,\r\n        address _participant,\r\n        bytes32 _participantMessage,\r\n        bool _participantWithdrawn,\r\n        bytes32 _ownerMessage,\r\n        bool _ownerWithdrawn,\r\n        bool _cancelled,\r\n        uint256 _participants,\r\n        uint256 _entries\r\n    ) {\r\n        _causeSecret = _state._causeSecret;\r\n        _causeMessage = _state._causeMessage;\r\n        _causeWithdrawn = _state._causeWithdrawn;\r\n        _participant = _state._participant;\r\n        _participantMessage = participants[_participant]._message;\r\n        _participantWithdrawn = _state._participantWithdrawn;\r\n        _ownerMessage = _state._ownerMessage;\r\n        _ownerWithdrawn = _state._ownerWithdrawn;\r\n        _cancelled = _state._cancelled;\r\n        _participants = _state._participants;\r\n        _entries = _state._entries;\r\n    }\r\n\r\n    // returns the balance of a cause, selected participant, owner, or participant (refund)\r\n    function balance() public view returns (uint256) {\r\n        // check for fundraiser ended normally\r\n        if (_state._participant != address(0)) {\r\n            // selected, get split\r\n            uint256 _split;\r\n            // determine split based on sender\r\n            if (msg.sender == deployment._cause) {\r\n                if (_state._causeWithdrawn) {\r\n                    return 0;\r\n                }\r\n                _split = deployment._causeSplit;\r\n            } else if (msg.sender == _state._participant) {\r\n                if (_state._participantWithdrawn) {\r\n                    return 0;\r\n                }\r\n                _split = deployment._participantSplit;\r\n            } else if (msg.sender == deployment._owner) {\r\n                if (_state._ownerWithdrawn) {\r\n                    return 0;\r\n                }\r\n                _split = deployment._ownerSplit;\r\n            } else {\r\n                return 0;\r\n            }\r\n            // multiply total entries by split % (non-revealed winnings are forfeited)\r\n            return _state._entries * deployment._valuePerEntry * _split / 1000;\r\n        } else if (_state._cancelled) {\r\n            // value per entry times participant entries == balance\r\n            Participant storage _participant = participants[msg.sender];\r\n            return _participant._entries * deployment._valuePerEntry;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    // called by the cause to begin their fundraiser with their secret\r\n    function begin(bytes32 _secret) public participationPhase onlyCause {\r\n        require(!_state._cancelled); // fundraiser not cancelled\r\n        require(_state._causeSecret == 0x0); // cause has not seeded secret\r\n        require(_secret != 0x0); // secret cannot be zero\r\n\r\n        // seed cause secret, starting the fundraiser\r\n        _state._causeSecret = _secret;\r\n\r\n        // broadcast event\r\n        Beginning(_secret);\r\n    }\r\n\r\n    // participate in this fundraiser by contributing messages and ether for entries\r\n    function participate(bytes32 _message) public participationPhase neverCause neverOwner payable {\r\n        require(!_state._cancelled); // fundraiser not cancelled\r\n        require(_state._causeSecret != 0x0); // cause has seeded secret\r\n        require(_message != 0x0); // message cannot be zero\r\n\r\n        // find and check for no existing participant\r\n        Participant storage _participant = participants[msg.sender];\r\n        require(_participant._message == 0x0);\r\n        require(_participant._entries == 0);\r\n\r\n        // add entries to participant\r\n        var (_entries, _refund) = _raise(_participant);\r\n        // save participant message, increment total participants\r\n        _participant._message = _message;\r\n        _state._participants++;\r\n\r\n        // send out participation update\r\n        Participation(msg.sender, _message, _entries, _refund);\r\n    }\r\n\r\n    // called by participate() and the fallback function for obtaining (additional) entries\r\n    function _raise(Participant storage _participant) private returns (\r\n        uint256 _entries,\r\n        uint256 _refund\r\n    ) {\r\n        // calculate the number of entries from the wei sent\r\n        _entries = msg.value / deployment._valuePerEntry;\r\n        require(_entries >= 1); // ensure we have at least one entry\r\n        // update participant totals\r\n        _participant._entries += _entries;\r\n        _state._entries += _entries;\r\n\r\n        // get previous fund's entries\r\n        uint256 _previousFundEntries = (funds.length > 0) ?\r\n            funds[funds.length - 1]._entries : 0;\r\n        // create and save new fund with cumulative entries\r\n        Fund memory _fund = Fund(msg.sender, _previousFundEntries + _entries);\r\n        funds.push(_fund);\r\n\r\n        // calculate partial entry refund\r\n        _refund = msg.value % deployment._valuePerEntry;\r\n        // refund any excess wei immediately (partial entry)\r\n        if (_refund > 0) {\r\n            msg.sender.transfer(_refund);\r\n        }\r\n    }\r\n\r\n    // fallback function that accepts ether for additional entries after an initial participation\r\n    function () public participationPhase neverCause neverOwner payable {\r\n        require(!_state._cancelled); // fundraiser not cancelled\r\n        require(_state._causeSecret != 0x0); // cause has seeded secret\r\n\r\n        // find existing participant\r\n        Participant storage _participant = participants[msg.sender];\r\n        require(_participant._message != 0x0); // make sure they participated\r\n        // forward to raise\r\n        var (_entries, _refund) = _raise(_participant);\r\n        \r\n        // send raise event\r\n        Raise(msg.sender, _entries, _refund);\r\n    }\r\n\r\n    // called by the cause to reveal their message after the end time but before the end() function\r\n    function reveal(bytes32 _message) public recapPhase onlyCause {\r\n        require(!_state._cancelled); // fundraiser not cancelled\r\n        require(_state._causeMessage == 0x0); // cannot have revealed already\r\n        require(_state._revealBlockNumber == 0); // block number of reveal should not be set\r\n        require(_decode(_state._causeSecret, _message)); // check for valid message\r\n\r\n        // save revealed cause message\r\n        _state._causeMessage = _message;\r\n        // save reveal block number\r\n        _state._revealBlockNumber = block.number;\r\n\r\n        // send reveal event\r\n        Revelation(_message);\r\n    }\r\n\r\n    // determines that validity of a message, given a secret\r\n    function _decode(bytes32 _secret, bytes32 _message) private view returns (bool) {\r\n        return _secret == keccak256(_message, msg.sender);\r\n    }\r\n\r\n    // ends this fundraiser, selects a participant to reward, and allocates funds for the cause, the\r\n    // selected participant, and the contract owner\r\n    function end(bytes32 _message) public recapPhase onlyOwner {\r\n        require(!_state._cancelled); // fundraiser not cancelled\r\n        require(_state._causeMessage != 0x0); // cause must have revealed\r\n        require(_state._revealBlockNumber != 0); // reveal block number must be set\r\n        require(_state._ownerMessage == 0x0); // cannot have ended already\r\n        require(_decode(deployment._ownerSecret, _message)); // check for valid message\r\n        require(block.number > _state._revealBlockNumber); // verify reveal has been mined\r\n\r\n        // get the (cause) reveal blockhash and ensure within 256 blocks (non-zero)\r\n        _state._revealBlockHash = uint256(block.blockhash(_state._revealBlockNumber));\r\n        require(_state._revealBlockHash != 0);\r\n        // save revealed owner message\r\n        _state._ownerMessage = _message;\r\n\r\n        bytes32 _randomNumber;\r\n        address _participant;\r\n        bytes32 _participantMessage;\r\n        // add additional entropy to the random from participant messages\r\n        for (uint256 i = 0; i < deployment._entropy; i++) {\r\n            // calculate the next random\r\n            _randomNumber = keccak256(\r\n                _message,\r\n                _state._causeMessage,\r\n                _state._revealBlockHash,\r\n                _participantMessage\r\n            );\r\n            // calculate next entry and grab corresponding participant\r\n            uint256 _entry = uint256(_randomNumber) % _state._entries;\r\n            _participant = _findParticipant(_entry);\r\n            _participantMessage = participants[_participant]._message;\r\n        }\r\n\r\n        // the final participant receives the reward\r\n        _state._participant = _participant;\r\n        \r\n        // send out select event\r\n        Selection(\r\n            _state._participant,\r\n            _participantMessage,\r\n            _state._causeMessage,\r\n            _message\r\n        );\r\n    }\r\n\r\n    // given an entry number, find the corresponding participant (address)\r\n    function _findParticipant(uint256 _entry) private view returns (address)  {\r\n        uint256 _leftFundIndex = 0;\r\n        uint256 _rightFundIndex = funds.length - 1;\r\n        // loop until participant found\r\n        while (true) {\r\n            // first or last fund (edge cases)\r\n            if (_leftFundIndex == _rightFundIndex) {\r\n                return funds[_leftFundIndex]._participant;\r\n            }\r\n            // get fund indexes for mid & next\r\n            uint256 _midFundIndex =\r\n                _leftFundIndex + ((_rightFundIndex - _leftFundIndex) / 2);\r\n            uint256 _nextFundIndex = _midFundIndex + 1;\r\n            // get mid and next funds\r\n            Fund memory _midFund = funds[_midFundIndex];\r\n            Fund memory _nextFund = funds[_nextFundIndex];\r\n            // binary search\r\n            if (_entry >= _midFund._entries) {\r\n                if (_entry < _nextFund._entries) {\r\n                    // we are in range, participant found\r\n                    return _nextFund._participant;\r\n                }\r\n                // entry is greater, move right\r\n                _leftFundIndex = _nextFundIndex;\r\n            } else {\r\n                // entry is less, move left\r\n                _rightFundIndex = _midFundIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    // called by the cause or Seedom before the end time to cancel the fundraiser, refunding all\r\n    // participants; this function is available to the entire community after the expire time\r\n    function cancel() public {\r\n        require(!_state._cancelled); // fundraiser not already cancelled\r\n        require(_state._participant == address(0)); // selected must not have been chosen\r\n        \r\n        // open cancellation to community if past expire time (but before destruct time)\r\n        if ((msg.sender != deployment._owner) && (msg.sender != deployment._cause)) {\r\n            require((now >= deployment._expireTime) && (now < deployment._destructTime));\r\n        }\r\n\r\n        // immediately set us to cancelled\r\n        _state._cancelled = true;\r\n\r\n        // send out cancellation event\r\n        Cancellation();\r\n    }\r\n\r\n    // used to withdraw funds from the contract from an ended fundraiser or refunds when the\r\n    // fundraiser is cancelled\r\n    function withdraw() public {\r\n        // check for a balance\r\n        uint256 _balance = balance();\r\n        require (_balance > 0); // can only withdraw a balance\r\n\r\n        address _wallet;\r\n        // check for fundraiser ended normally\r\n        if (_state._participant != address(0)) {\r\n\r\n            // determine split based on sender\r\n            if (msg.sender == deployment._cause) {\r\n                _state._causeWithdrawn = true;\r\n                _wallet = deployment._causeWallet;\r\n            } else if (msg.sender == _state._participant) {\r\n                _state._participantWithdrawn = true;\r\n                _wallet = _state._participant;\r\n            } else if (msg.sender == deployment._owner) {\r\n                _state._ownerWithdrawn = true;\r\n                _wallet = deployment._ownerWallet;\r\n            } else {\r\n                revert();\r\n            }\r\n\r\n        } else if (_state._cancelled) {\r\n\r\n            // set participant entries to zero to prevent multiple refunds\r\n            Participant storage _participant = participants[msg.sender];\r\n            _participant._entries = 0;\r\n            _wallet = msg.sender;\r\n\r\n        } else {\r\n            // no selected and not cancelled\r\n            revert();\r\n        }\r\n\r\n        // execute the refund if we have one\r\n        _wallet.transfer(_balance);\r\n        // send withdrawal event\r\n        Withdrawal(msg.sender);\r\n    }\r\n\r\n    // destroy() will be used to clean up old contracts from the network\r\n    function destroy() public destructionPhase onlyOwner {\r\n        // destroy this contract and send remaining funds to owner\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    // recover() allows the owner to recover ERC20 tokens sent to this contract, for later\r\n    // distribution back to their original holders, upon request\r\n    function recover(address _token) public onlyOwner {\r\n        ERC20 _erc20 = ERC20(_token);\r\n        uint256 _balance = _erc20.balanceOf(this);\r\n        require(_erc20.transfer(deployment._owner, _balance));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"_message\",\"type\":\"bytes32\"},{\"name\":\"_entries\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_message\",\"type\":\"bytes32\"}],\"name\":\"participate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployment\",\"outputs\":[{\"name\":\"_cause\",\"type\":\"address\"},{\"name\":\"_causeWallet\",\"type\":\"address\"},{\"name\":\"_causeSplit\",\"type\":\"uint256\"},{\"name\":\"_participantSplit\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ownerWallet\",\"type\":\"address\"},{\"name\":\"_ownerSplit\",\"type\":\"uint256\"},{\"name\":\"_ownerSecret\",\"type\":\"bytes32\"},{\"name\":\"_valuePerEntry\",\"type\":\"uint256\"},{\"name\":\"_deployTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_expireTime\",\"type\":\"uint256\"},{\"name\":\"_destructTime\",\"type\":\"uint256\"},{\"name\":\"_entropy\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_message\",\"type\":\"bytes32\"}],\"name\":\"end\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_message\",\"type\":\"bytes32\"}],\"name\":\"reveal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"begin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"_causeSecret\",\"type\":\"bytes32\"},{\"name\":\"_causeMessage\",\"type\":\"bytes32\"},{\"name\":\"_causeWithdrawn\",\"type\":\"bool\"},{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_participantMessage\",\"type\":\"bytes32\"},{\"name\":\"_participantWithdrawn\",\"type\":\"bool\"},{\"name\":\"_ownerMessage\",\"type\":\"bytes32\"},{\"name\":\"_ownerWithdrawn\",\"type\":\"bool\"},{\"name\":\"_cancelled\",\"type\":\"bool\"},{\"name\":\"_participants\",\"type\":\"uint256\"},{\"name\":\"_entries\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_cause\",\"type\":\"address\"},{\"name\":\"_causeWallet\",\"type\":\"address\"},{\"name\":\"_causeSplit\",\"type\":\"uint256\"},{\"name\":\"_participantSplit\",\"type\":\"uint256\"},{\"name\":\"_ownerWallet\",\"type\":\"address\"},{\"name\":\"_ownerSplit\",\"type\":\"uint256\"},{\"name\":\"_ownerSecret\",\"type\":\"bytes32\"},{\"name\":\"_valuePerEntry\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_expireTime\",\"type\":\"uint256\"},{\"name\":\"_destructTime\",\"type\":\"uint256\"},{\"name\":\"_entropy\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_causeSecret\",\"type\":\"bytes32\"}],\"name\":\"Beginning\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_entries\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_refund\",\"type\":\"uint256\"}],\"name\":\"Participation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_entries\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_refund\",\"type\":\"uint256\"}],\"name\":\"Raise\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_causeMessage\",\"type\":\"bytes32\"}],\"name\":\"Revelation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_participantMessage\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_causeMessage\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_ownerMessage\",\"type\":\"bytes32\"}],\"name\":\"Selection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Cancellation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"Fundraiser","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"000000000000000000000000229f6df0c2966b958a9b8308d65606939153cad50000000000000000000000008f951903c9360345b4e1b536c7f5ae8f88a64e790000000000000000000000000000000000000000000000000000000000000258000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000014fc971fada6791b065d46250ac5ecb30cf246b30000000000000000000000000000000000000000000000000000000000000064ea038474bb96f07d7c3ce411497412553f56d3ac971cf540a5c32ebec640bc14000000000000000000000000000000000000000000000000000a7a0b64a94b80000000000000000000000000000000000000000000000000000000005af51540000000000000000000000000000000000000000000000000000000005af909c0000000000000000000000000000000000000000000000000000000005b7253c00000000000000000000000000000000000000000000000000000000000000008","Library":"","SwarmSource":"bzzr://0df8bc72be862ccc3f9b154db1bfc8cf277802fb021183758929c8556e3b35d9"}]}