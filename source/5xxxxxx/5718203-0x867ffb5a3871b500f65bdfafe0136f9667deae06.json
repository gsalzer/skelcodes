{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Token {\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n}\r\n\r\n/// @title localethereum.com\r\n/// @author localethereum.com\r\ncontract LocalEthereumEscrows {\r\n    /***********************\r\n    +   Global settings   +\r\n    ***********************/\r\n\r\n    // Address of the arbitrator (currently always localethereum staff)\r\n    address public arbitrator;\r\n    // Address of the owner (who can withdraw collected fees)\r\n    address public owner;\r\n    // Address of the relayer (who is allowed to forward signed instructions from parties)\r\n    address public relayer;\r\n    uint32 public requestCancellationMinimumTime;\r\n    // Cumulative balance of collected fees\r\n    uint256 public feesAvailableForWithdraw;\r\n\r\n    /***********************\r\n    +  Instruction types  +\r\n    ***********************/\r\n\r\n    // Called when the buyer marks payment as sent. Locks funds in escrow\r\n    uint8 constant INSTRUCTION_SELLER_CANNOT_CANCEL = 0x01;\r\n    // Buyer cancelling\r\n    uint8 constant INSTRUCTION_BUYER_CANCEL = 0x02;\r\n    // Seller cancelling\r\n    uint8 constant INSTRUCTION_SELLER_CANCEL = 0x03;\r\n    // Seller requesting to cancel. Begins a window for buyer to object\r\n    uint8 constant INSTRUCTION_SELLER_REQUEST_CANCEL = 0x04;\r\n    // Seller releasing funds to the buyer\r\n    uint8 constant INSTRUCTION_RELEASE = 0x05;\r\n    // Either party permitting the arbitrator to resolve a dispute\r\n    uint8 constant INSTRUCTION_RESOLVE = 0x06;\r\n\r\n    /***********************\r\n    +       Events        +\r\n    ***********************/\r\n\r\n    event Created(bytes32 indexed _tradeHash);\r\n    event SellerCancelDisabled(bytes32 indexed _tradeHash);\r\n    event SellerRequestedCancel(bytes32 indexed _tradeHash);\r\n    event CancelledBySeller(bytes32 indexed _tradeHash);\r\n    event CancelledByBuyer(bytes32 indexed _tradeHash);\r\n    event Released(bytes32 indexed _tradeHash);\r\n    event DisputeResolved(bytes32 indexed _tradeHash);\r\n\r\n    struct Escrow {\r\n        // So we know the escrow exists\r\n        bool exists;\r\n        // This is the timestamp in whic hthe seller can cancel the escrow after.\r\n        // It has two special values:\r\n        // 0 : Permanently locked by the buyer (i.e. marked as paid; the seller can never cancel)\r\n        // 1 : The seller can only request to cancel, which will change this value to a timestamp.\r\n        //     This option is avaialble for complex trade terms such as cash-in-person where a\r\n        //     payment window is inappropriate\r\n        uint32 sellerCanCancelAfter;\r\n        // Cumulative cost of gas incurred by the relayer. This amount will be refunded to the owner\r\n        // in the way of fees once the escrow has completed\r\n        uint128 totalGasFeesSpentByRelayer;\r\n    }\r\n\r\n    // Mapping of active trades. The key here is a hash of the trade proprties\r\n    mapping (bytes32 => Escrow) public escrows;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyArbitrator() {\r\n        require(msg.sender == arbitrator, \"Must be arbitrator\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Initialize the contract.\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        arbitrator = msg.sender;\r\n        relayer = msg.sender;\r\n        requestCancellationMinimumTime = 2 hours;\r\n    }\r\n\r\n    /// @notice Create and fund a new escrow.\r\n    /// @param _tradeID The unique ID of the trade, generated by localethereum.com\r\n    /// @param _seller The selling party\r\n    /// @param _buyer The buying party\r\n    /// @param _value The amount of the escrow, exclusive of the fee\r\n    /// @param _fee Localethereum's commission in 1/10000ths\r\n    /// @param _paymentWindowInSeconds The time in seconds from escrow creation that the seller can cancel after\r\n    /// @param _expiry This transaction must be created before this time\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    function createEscrow(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint32 _paymentWindowInSeconds,\r\n        uint32 _expiry,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) payable external {\r\n        // The trade hash is created by tightly-concatenating and hashing properties of the trade.\r\n        // This hash becomes the identifier of the escrow, and hence all these variables must be\r\n        // supplied on future contract calls\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));\r\n        // Require that trade does not already exist\r\n        require(!escrows[_tradeHash].exists, \"Trade already exists\");\r\n        // A signature (v, r and s) must come from localethereum to open an escrow\r\n        bytes32 _invitationHash = keccak256(abi.encodePacked(\r\n            _tradeHash,\r\n            _paymentWindowInSeconds,\r\n            _expiry\r\n        ));\r\n        require(recoverAddress(_invitationHash, _v, _r, _s) == relayer, \"Must be relayer\");\r\n        // These signatures come with an expiry stamp\r\n        require(block.timestamp < _expiry, \"Signature has expired\");\r\n        // Check transaction value against signed _value and make sure is not 0\r\n        require(msg.value == _value && msg.value > 0, \"Incorrect ether sent\");\r\n        uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0\r\n            ? 1\r\n            : uint32(block.timestamp) + _paymentWindowInSeconds;\r\n        // Add the escrow to the public mapping\r\n        escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);\r\n        emit Created(_tradeHash);\r\n    }\r\n\r\n    uint16 constant GAS_doResolveDispute = 36100;\r\n    /// @notice Called by the arbitrator to resolve a dispute. Requires a signature from either party.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @param _buyerPercent What % should be distributed to the buyer (this is usually 0 or 100)\r\n    function resolveDispute(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _buyerPercent\r\n    ) external onlyArbitrator {\r\n        address _signature = recoverAddress(keccak256(abi.encodePacked(\r\n            _tradeID,\r\n            INSTRUCTION_RESOLVE\r\n        )), _v, _r, _s);\r\n        require(_signature == _buyer || _signature == _seller, \"Must be buyer or seller\");\r\n\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        require(_escrow.exists, \"Escrow does not exist\");\r\n        require(_buyerPercent <= 100, \"_buyerPercent must be 100 or lower\");\r\n\r\n        uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + (GAS_doResolveDispute * uint128(tx.gasprice));\r\n        require(_value - _totalFees <= _value, \"Overflow error\"); // Prevent underflow\r\n        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw\r\n\r\n        delete escrows[_tradeHash];\r\n        emit DisputeResolved(_tradeHash);\r\n        if (_buyerPercent > 0)\r\n          _buyer.transfer((_value - _totalFees) * _buyerPercent / 100);\r\n        if (_buyerPercent < 100)\r\n          _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);\r\n    }\r\n\r\n    /// @notice Release ether in escrow to the buyer. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function release(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool){\r\n        require(msg.sender == _seller, \"Must be seller\");\r\n        return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Disable the seller from cancelling (i.e. \"mark as paid\"). Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function disableSellerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _buyer, \"Must be buyer\");\r\n        return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Cancel the escrow as a buyer. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function buyerCancel(\r\n      bytes16 _tradeID,\r\n      address _seller,\r\n      address _buyer,\r\n      uint256 _value,\r\n      uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _buyer, \"Must be buyer\");\r\n        return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Cancel the escrow as a seller. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function sellerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _seller, \"Must be seller\");\r\n        return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Request to cancel as a seller. Direct call option.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return bool\r\n    function sellerRequestCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) external returns (bool) {\r\n        require(msg.sender == _seller, \"Must be seller\");\r\n        return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);\r\n    }\r\n\r\n    /// @notice Relay multiple signed instructions from parties of escrows.\r\n    /// @param _tradeID List of _tradeID values\r\n    /// @param _seller List of _seller values\r\n    /// @param _buyer List of _buyer values\r\n    /// @param _value List of _value values\r\n    /// @param _fee List of _fee values\r\n    /// @param _maximumGasPrice List of _maximumGasPrice values\r\n    /// @param _v List of signature \"v\" components\r\n    /// @param _r List of signature \"r\" components\r\n    /// @param _s List of signature \"s\" components\r\n    /// @param _instructionByte List of _instructionByte values\r\n    /// @return bool List of results\r\n    uint16 constant GAS_batchRelayBaseCost = 28500;\r\n    function batchRelay(\r\n        bytes16[] _tradeID,\r\n        address[] _seller,\r\n        address[] _buyer,\r\n        uint256[] _value,\r\n        uint16[] _fee,\r\n        uint128[] _maximumGasPrice,\r\n        uint8[] _v,\r\n        bytes32[] _r,\r\n        bytes32[] _s,\r\n        uint8[] _instructionByte\r\n    ) public returns (bool[]) {\r\n        bool[] memory _results = new bool[](_tradeID.length);\r\n        uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0);\r\n        for (uint8 i=0; i<_tradeID.length; i++) {\r\n            _results[i] = relay(\r\n                _tradeID[i],\r\n                _seller[i],\r\n                _buyer[i],\r\n                _value[i],\r\n                _fee[i],\r\n                _maximumGasPrice[i],\r\n                _v[i],\r\n                _r[i],\r\n                _s[i],\r\n                _instructionByte[i],\r\n                _additionalGas\r\n            );\r\n        }\r\n        return _results;\r\n    }\r\n\r\n    /// @notice Withdraw fees collected by the contract. Only the owner can call this.\r\n    /// @param _to Address to withdraw fees in to\r\n    /// @param _amount Amount to withdraw\r\n    function withdrawFees(address _to, uint256 _amount) onlyOwner external {\r\n        // This check also prevents underflow\r\n        require(_amount <= feesAvailableForWithdraw, \"Amount is higher than amount available\");\r\n        feesAvailableForWithdraw -= _amount;\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    /// @notice Set the arbitrator to a new address. Only the owner can call this.\r\n    /// @param _newArbitrator Address of the replacement arbitrator\r\n    function setArbitrator(address _newArbitrator) onlyOwner external {\r\n        arbitrator = _newArbitrator;\r\n    }\r\n\r\n    /// @notice Change the owner to a new address. Only the owner can call this.\r\n    /// @param _newOwner Address of the replacement owner\r\n    function setOwner(address _newOwner) onlyOwner external {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /// @notice Change the relayer to a new address. Only the owner can call this.\r\n    /// @param _newRelayer Address of the replacement relayer\r\n    function setRelayer(address _newRelayer) onlyOwner external {\r\n        relayer = _newRelayer;\r\n    }\r\n\r\n    /// @notice Change the requestCancellationMinimumTime. Only the owner can call this.\r\n    /// @param _newRequestCancellationMinimumTime Replacement\r\n    function setRequestCancellationMinimumTime(\r\n        uint32 _newRequestCancellationMinimumTime\r\n    ) onlyOwner external {\r\n        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _transferTo Recipient\r\n    /// @param _value Value\r\n    function transferToken(\r\n        Token _tokenContract,\r\n        address _transferTo,\r\n        uint256 _value\r\n    ) onlyOwner external {\r\n        _tokenContract.transfer(_transferTo, _value);\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _transferTo Recipient\r\n    /// @param _transferFrom Sender\r\n    /// @param _value Value\r\n    function transferTokenFrom(\r\n        Token _tokenContract,\r\n        address _transferTo,\r\n        address _transferFrom,\r\n        uint256 _value\r\n    ) onlyOwner external {\r\n        _tokenContract.transferFrom(_transferTo, _transferFrom, _value);\r\n    }\r\n\r\n    /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.\r\n    /// @param _tokenContract Token contract\r\n    /// @param _spender Spender address\r\n    /// @param _value Value\r\n    function approveToken(\r\n        Token _tokenContract,\r\n        address _spender,\r\n        uint256 _value\r\n    ) onlyOwner external {\r\n        _tokenContract.approve(_spender, _value);\r\n    }\r\n\r\n    /// @notice Relay a signed instruction from a party of an escrow.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _maximumGasPrice Maximum gas price permitted for the relayer (set by the instructor)\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function relay(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _maximumGasPrice,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        uint8 _instructionByte,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        address _relayedSender = getRelayedSender(\r\n            _tradeID,\r\n            _instructionByte,\r\n            _maximumGasPrice,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n        if (_relayedSender == _buyer) {\r\n            // Buyer's instructions:\r\n            if (_instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL) {\r\n                // Disable seller from cancelling\r\n                return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_BUYER_CANCEL) {\r\n                // Cancel\r\n                return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            }\r\n        } else if (_relayedSender == _seller) {\r\n            // Seller's instructions:\r\n            if (_instructionByte == INSTRUCTION_RELEASE) {\r\n                // Release\r\n                return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_SELLER_CANCEL) {\r\n                // Cancel\r\n                return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            } else if (_instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL){\r\n                // Request to cancel\r\n                return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);\r\n            }\r\n        } else {\r\n            require(msg.sender == _seller, \"Unrecognised party\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @notice Increase the amount of gas to be charged later on completion of an escrow\r\n    /// @param _tradeHash Trade hash\r\n    /// @param _gas Gas cost\r\n    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {\r\n        escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);\r\n    }\r\n\r\n    /// @notice Transfer the value of an escrow, minus the fees, minus the gas costs incurred by relay\r\n    /// @param _to Recipient address\r\n    /// @param _value Value of the transfer\r\n    /// @param _totalGasFeesSpentByRelayer Total gas fees spent by the relayer\r\n    /// @param _fee Commission in 1/10000ths\r\n    function transferMinusFees(\r\n        address _to,\r\n        uint256 _value,\r\n        uint128 _totalGasFeesSpentByRelayer,\r\n        uint16 _fee\r\n    ) private {\r\n        uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;\r\n        // Prevent underflow\r\n        if(_value - _totalFees > _value) {\r\n            return;\r\n        }\r\n        // Add fees to the pot for localethereum to withdraw\r\n        feesAvailableForWithdraw += _totalFees;\r\n        _to.transfer(_value - _totalFees);\r\n    }\r\n\r\n    uint16 constant GAS_doRelease = 46588;\r\n    /// @notice Release escrow to the buyer. This completes it and removes it from the mapping.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doRelease(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\r\n            + (msg.sender == relayer\r\n                ? (GAS_doRelease + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit Released(_tradeHash);\r\n        transferMinusFees(_buyer, _value, _gasFees, _fee);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doDisableSellerCancel = 28944;\r\n    /// @notice Prevents the seller from cancelling an escrow. Used to \"mark as paid\" by the buyer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doDisableSellerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) return false;\r\n        if(_escrow.sellerCanCancelAfter == 0) return false;\r\n        escrows[_tradeHash].sellerCanCancelAfter = 0;\r\n        emit SellerCancelDisabled(_tradeHash);\r\n        if (msg.sender == relayer) {\r\n          increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doBuyerCancel = 46255;\r\n    /// @notice Cancels the trade and returns the ether to the seller. Can only be called the buyer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doBuyerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\r\n            + (msg.sender == relayer\r\n                ? (GAS_doBuyerCancel + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit CancelledByBuyer(_tradeHash);\r\n        transferMinusFees(_seller, _value, _gasFees, 0);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doSellerCancel = 46815;\r\n    /// @notice Returns the ether in escrow to the seller. Called by the seller. Sometimes unavailable.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doSellerCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {\r\n            return false;\r\n        }\r\n        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer\r\n            + (msg.sender == relayer\r\n                ? (GAS_doSellerCancel + _additionalGas ) * uint128(tx.gasprice)\r\n                : 0\r\n            );\r\n        delete escrows[_tradeHash];\r\n        emit CancelledBySeller(_tradeHash);\r\n        transferMinusFees(_seller, _value, _gasFees, 0);\r\n        return true;\r\n    }\r\n\r\n    uint16 constant GAS_doSellerRequestCancel = 29507;\r\n    /// @notice Request to cancel. Used if the buyer is unresponsive. Begins a countdown timer.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @param _additionalGas Additional gas to be deducted after this operation\r\n    /// @return bool\r\n    function doSellerRequestCancel(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee,\r\n        uint128 _additionalGas\r\n    ) private returns (bool) {\r\n        // Called on unlimited payment window trades where the buyer is not responding\r\n        Escrow memory _escrow;\r\n        bytes32 _tradeHash;\r\n        (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);\r\n        if (!_escrow.exists) {\r\n            return false;\r\n        }\r\n        if(_escrow.sellerCanCancelAfter != 1) {\r\n            return false;\r\n        }\r\n        escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp)\r\n            + requestCancellationMinimumTime;\r\n        emit SellerRequestedCancel(_tradeHash);\r\n        if (msg.sender == relayer) {\r\n          increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @notice Get the sender of the signed instruction.\r\n    /// @param _tradeID Identifier of the trade\r\n    /// @param _instructionByte Identifier of the instruction\r\n    /// @param _maximumGasPrice Maximum gas price permitted by the sender\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @return address\r\n    function getRelayedSender(\r\n      bytes16 _tradeID,\r\n      uint8 _instructionByte,\r\n      uint128 _maximumGasPrice,\r\n      uint8 _v,\r\n      bytes32 _r,\r\n      bytes32 _s\r\n    ) view private returns (address) {\r\n        bytes32 _hash = keccak256(abi.encodePacked(\r\n            _tradeID,\r\n            _instructionByte,\r\n            _maximumGasPrice\r\n        ));\r\n        if(tx.gasprice > _maximumGasPrice) {\r\n            return;\r\n        }\r\n        return recoverAddress(_hash, _v, _r, _s);\r\n    }\r\n\r\n    /// @notice Hashes the values and returns the matching escrow object and trade hash.\r\n    /// @dev Returns an empty escrow struct and 0 _tradeHash if not found.\r\n    /// @param _tradeID Escrow \"tradeID\" parameter\r\n    /// @param _seller Escrow \"seller\" parameter\r\n    /// @param _buyer Escrow \"buyer\" parameter\r\n    /// @param _value Escrow \"value\" parameter\r\n    /// @param _fee Escrow \"fee parameter\r\n    /// @return Escrow\r\n    function getEscrowAndHash(\r\n        bytes16 _tradeID,\r\n        address _seller,\r\n        address _buyer,\r\n        uint256 _value,\r\n        uint16 _fee\r\n    ) view private returns (Escrow, bytes32) {\r\n        bytes32 _tradeHash = keccak256(abi.encodePacked(\r\n            _tradeID,\r\n            _seller,\r\n            _buyer,\r\n            _value,\r\n            _fee\r\n        ));\r\n        return (escrows[_tradeHash], _tradeHash);\r\n    }\r\n\r\n    /// @notice Returns an empty escrow struct and 0 _tradeHash if not found.\r\n    /// @param _h Data to be hashed\r\n    /// @param _v Signature \"v\" component\r\n    /// @param _r Signature \"r\" component\r\n    /// @param _s Signature \"s\" component\r\n    /// @return address\r\n    function recoverAddress(\r\n        bytes32 _h,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) private pure returns (address) {\r\n        bytes memory _prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));\r\n        return ecrecover(_prefixedHash, _v, _r, _s);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newRequestCancellationMinimumTime\",\"type\":\"uint32\"}],\"name\":\"setRequestCancellationMinimumTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_buyerPercent\",\"type\":\"uint8\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"buyerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"escrows\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"sellerCanCancelAfter\",\"type\":\"uint32\"},{\"name\":\"totalGasFeesSpentByRelayer\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"sellerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"requestCancellationMinimumTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"disableSellerCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRelayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"sellerRequestCancel\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbitrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16[]\"},{\"name\":\"_seller\",\"type\":\"address[]\"},{\"name\":\"_buyer\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"},{\"name\":\"_fee\",\"type\":\"uint16[]\"},{\"name\":\"_maximumGasPrice\",\"type\":\"uint128[]\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"},{\"name\":\"_instructionByte\",\"type\":\"uint8[]\"}],\"name\":\"batchRelay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newArbitrator\",\"type\":\"address\"}],\"name\":\"setArbitrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feesAvailableForWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_transferTo\",\"type\":\"address\"},{\"name\":\"_transferFrom\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokenFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"release\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint16\"},{\"name\":\"_paymentWindowInSeconds\",\"type\":\"uint32\"},{\"name\":\"_expiry\",\"type\":\"uint32\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"createEscrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_transferTo\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerCancelDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"SellerRequestedCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"CancelledBySeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"CancelledByBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tradeHash\",\"type\":\"bytes32\"}],\"name\":\"DisputeResolved\",\"type\":\"event\"}]","ContractName":"LocalEthereumEscrows","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://654333d3912b8c3728a12e74d8df8495a94933ffd9a94d7e32ed95bc0ab7b683"}]}