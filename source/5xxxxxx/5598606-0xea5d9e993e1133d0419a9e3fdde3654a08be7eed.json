{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\nA PennyAuction-like game to win a prize.\r\n\r\nUI: https://www.pennyether.com\r\n\r\nHow it works:\r\n    - An initial prize is held in the Contract\r\n    - Anyone may overthrow the Monarch by paying a small fee.\r\n        - They become the Monarch\r\n        - The \"reign\" timer is reset to N.\r\n        - The prize may be increased or decreased\r\n    - If nobody overthrows the new Monarch in N blocks, the Monarch wins.\r\n\r\nFor fairness, an \"overthrow\" is refunded if:\r\n    - The incorrect amount is sent.\r\n    - The game is already over.\r\n    - The overthrower is already the Monarch.\r\n    - Another overthrow occurred in the same block\r\n        - Note: Here, default gas is used for refund. On failure, fee is kept.\r\n\r\nOther notes:\r\n    - .sendFees(): Sends accrued fees to \"collector\", at any time.\r\n    - .sendPrize(): If game is ended, sends prize to the Monarch.\r\n*/\r\ncontract MonarchyGame {\r\n    // We store values as GWei to reduce storage to 64 bits.\r\n    // int64: 2^63 GWei is ~ 9 billion Ether, so no overflow risk.\r\n    //\r\n    // For blocks, we use uint32, which has a max value of 4.3 billion\r\n    // At a 1 second block time, there's a risk of overflow in 120 years.\r\n    //\r\n    // We put these variables together because they are all written to\r\n    // on each bid. This should save some gas when we write.\r\n    struct Vars {\r\n        // [first 256-bit segment]\r\n        address monarch;        // address of monarch\r\n        uint64 prizeGwei;       // (Gwei) the current prize\r\n        uint32 numOverthrows;   // total number of overthrows\r\n\r\n        // [second 256-bit segment]\r\n        uint32 blockEnded;      // the time at which no further overthrows can occur  \r\n        uint32 prevBlock;       // block of the most recent overthrow\r\n        bool isPaid;            // whether or not the winner has been paid\r\n        bytes23 decree;         // 23 leftover bytes for decree\r\n    }\r\n\r\n    // These values are set on construction and don't change.\r\n    // We store in a struct for gas-efficient reading/writing.\r\n    struct Settings {\r\n        // [first 256-bit segment]\r\n        address collector;       // address that fees get sent to\r\n        uint64 initialPrizeGwei; // (Gwei > 0) amt initially staked\r\n        // [second 256-bit segment]\r\n        uint64 feeGwei;          // (Gwei > 0) cost to become the Monarch\r\n        int64 prizeIncrGwei;     // amount added/removed to prize on overthrow\r\n        uint32 reignBlocks;      // number of blocks Monarch must reign to win\r\n    }\r\n\r\n    Vars vars;\r\n    Settings settings;\r\n    uint constant version = 1;\r\n\r\n    event SendPrizeError(uint time, string msg);\r\n    event Started(uint time, uint initialBlocks);\r\n    event OverthrowOccurred(uint time, address indexed newMonarch, bytes23 decree, address indexed prevMonarch, uint fee);\r\n    event OverthrowRefundSuccess(uint time, string msg, address indexed recipient, uint amount);\r\n    event OverthrowRefundFailure(uint time, string msg, address indexed recipient, uint amount);\r\n    event SendPrizeSuccess(uint time, address indexed redeemer, address indexed recipient, uint amount, uint gasLimit);\r\n    event SendPrizeFailure(uint time, address indexed redeemer, address indexed recipient, uint amount, uint gasLimit);\r\n    event FeesSent(uint time, address indexed collector, uint amount);\r\n\r\n    constructor(\r\n        address _collector,\r\n        uint _initialPrize,\r\n        uint _fee,\r\n        int _prizeIncr,\r\n        uint _reignBlocks,\r\n        uint _initialBlocks\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        require(_initialPrize >= 1e9);                // min value of 1 GWei\r\n        require(_initialPrize < 1e6 * 1e18);          // max value of a million ether\r\n        require(_initialPrize % 1e9 == 0);            // even amount of GWei\r\n        require(_fee >= 1e6);                         // min value of 1 GWei\r\n        require(_fee < 1e6 * 1e18);                   // max value of a million ether\r\n        require(_fee % 1e9 == 0);                     // even amount of GWei\r\n        require(_prizeIncr <= int(_fee));             // max value of _bidPrice\r\n        require(_prizeIncr >= -1*int(_initialPrize)); // min value of -1*initialPrize\r\n        require(_prizeIncr % 1e9 == 0);               // even amount of GWei\r\n        require(_reignBlocks >= 1);                   // minimum of 1 block\r\n        require(_initialBlocks >= 1);                 // minimum of 1 block\r\n        require(msg.value == _initialPrize);          // must've sent the prize amount\r\n\r\n        // Set instance variables. these never change.\r\n        // These can be safely cast to int64 because they are each < 1e24 (see above),\r\n        // 1e24 divided by 1e9 is 1e15. Max int64 val is ~1e19, so plenty of room.\r\n        // For block numbers, uint32 is good up to ~4e12, a long time from now.\r\n        settings.collector = _collector;\r\n        settings.initialPrizeGwei = uint64(_initialPrize / 1e9);\r\n        settings.feeGwei = uint64(_fee / 1e9);\r\n        settings.prizeIncrGwei = int64(_prizeIncr / 1e9);\r\n        settings.reignBlocks = uint32(_reignBlocks);\r\n\r\n        // Initialize the game variables.\r\n        vars.prizeGwei = settings.initialPrizeGwei;\r\n        vars.monarch = _collector;\r\n        vars.prevBlock = uint32(block.number);\r\n        vars.blockEnded = uint32(block.number + _initialBlocks);\r\n\r\n        emit Started(now, _initialBlocks);\r\n    }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** OVERTHROWING *************************************/\r\n    /*************************************************************/\r\n    //\r\n    // Upon new bid, adds fees and increments time and prize.\r\n    //  - Refunds if overthrow is too late, user is already monarch, or incorrect value passed.\r\n    //  - Upon an overthrow-in-same-block, refends previous monarch.\r\n    //\r\n    // Gas Cost: 34k - 50k\r\n    //     Overhead: 25k\r\n    //       - 23k: tx overhead\r\n    //       -  2k: SLOADs, execution\r\n    //     Failure: 34k\r\n    //       - 25k: overhead\r\n    //       -  7k: send refund\r\n    //       -  2k: event: OverthrowRefundSuccess\r\n    //     Clean: 37k\r\n    //       - 25k: overhead\r\n    //       - 10k: update Vars (monarch, numOverthrows, prize, blockEnded, prevBlock, decree)\r\n    //       -  2k: event: OverthrowOccurred\r\n    //     Refund Success: 46k\r\n    //       - 25k: overhead\r\n    //       -  7k: send\r\n    //       - 10k: update Vars (monarch, decree)\r\n    //       -  2k: event: OverthrowRefundSuccess\r\n    //       -  2k: event: OverthrowOccurred\r\n    //     Refund Failure: 50k\r\n    //       - 25k: overhead\r\n    //       - 11k: send failure\r\n    //       - 10k: update Vars (monarch, numOverthrows, prize, decree)\r\n    //       -  2k: event: OverthrowRefundFailure\r\n    //       -  2k: event: OverthrowOccurred\r\n    function()\r\n        public\r\n        payable\r\n    {\r\n        overthrow(0);\r\n    }\r\n\r\n    function overthrow(bytes23 _decree)\r\n        public\r\n        payable\r\n    {\r\n        if (isEnded())\r\n            return errorAndRefund(\"Game has already ended.\");\r\n        if (msg.sender == vars.monarch)\r\n            return errorAndRefund(\"You are already the Monarch.\");\r\n        if (msg.value != fee())\r\n            return errorAndRefund(\"Value sent must match fee.\");\r\n\r\n        // compute new values. hopefully optimizer reads from vars/settings just once.\r\n        int _newPrizeGwei = int(vars.prizeGwei) + settings.prizeIncrGwei;\r\n        uint32 _newBlockEnded = uint32(block.number) + settings.reignBlocks;\r\n        uint32 _newNumOverthrows = vars.numOverthrows + 1;\r\n        address _prevMonarch = vars.monarch;\r\n        bool _isClean = (block.number != vars.prevBlock);\r\n\r\n        // Refund if _newPrize would end up being < 0.\r\n        if (_newPrizeGwei < 0)\r\n            return errorAndRefund(\"Overthrowing would result in a negative prize.\");\r\n\r\n        // Attempt refund, if necessary. Use minimum gas.\r\n        bool _wasRefundSuccess;\r\n        if (!_isClean) {\r\n            _wasRefundSuccess = _prevMonarch.send(msg.value);   \r\n        }\r\n\r\n        // These blocks can be made nicer, but optimizer will\r\n        //  sometimes do two updates instead of one. Seems it is\r\n        //  best to keep if/else trees flat.\r\n        if (_isClean) {\r\n            vars.monarch = msg.sender;\r\n            vars.numOverthrows = _newNumOverthrows;\r\n            vars.prizeGwei = uint64(_newPrizeGwei);\r\n            vars.blockEnded = _newBlockEnded;\r\n            vars.prevBlock = uint32(block.number);\r\n            vars.decree = _decree;\r\n        }\r\n        if (!_isClean && _wasRefundSuccess){\r\n            // when a refund occurs, we just swap winners.\r\n            // overthrow count and prize do not get reset.\r\n            vars.monarch = msg.sender;\r\n            vars.decree = _decree;\r\n        }\r\n        if (!_isClean && !_wasRefundSuccess){\r\n            vars.monarch = msg.sender;   \r\n            vars.prizeGwei = uint64(_newPrizeGwei);\r\n            vars.numOverthrows = _newNumOverthrows;\r\n            vars.decree = _decree;\r\n        }\r\n\r\n        // Emit the proper events.\r\n        if (!_isClean){\r\n            if (_wasRefundSuccess)\r\n                emit OverthrowRefundSuccess(now, \"Another overthrow occurred on the same block.\", _prevMonarch, msg.value);\r\n            else\r\n                emit OverthrowRefundFailure(now, \".send() failed.\", _prevMonarch, msg.value);\r\n        }\r\n        emit OverthrowOccurred(now, msg.sender, _decree, _prevMonarch, msg.value);\r\n    }\r\n        // called from the bidding function above.\r\n        // refunds sender, or throws to revert entire tx.\r\n        function errorAndRefund(string _msg)\r\n            private\r\n        {\r\n            require(msg.sender.call.value(msg.value)());\r\n            emit OverthrowRefundSuccess(now, _msg, msg.sender, msg.value);\r\n        }\r\n\r\n\r\n    /*************************************************************/\r\n    /********** PUBLIC FUNCTIONS *********************************/\r\n    /*************************************************************/\r\n\r\n    // Sends prize to the current winner using _gasLimit (0 is unlimited)\r\n    function sendPrize(uint _gasLimit)\r\n        public\r\n        returns (bool _success, uint _prizeSent)\r\n    {\r\n        // make sure game has ended, and is not paid\r\n        if (!isEnded()) {\r\n            emit SendPrizeError(now, \"The game has not ended.\");\r\n            return (false, 0);\r\n        }\r\n        if (vars.isPaid) {\r\n            emit SendPrizeError(now, \"The prize has already been paid.\");\r\n            return (false, 0);\r\n        }\r\n\r\n        address _winner = vars.monarch;\r\n        uint _prize = prize();\r\n        bool _paySuccessful = false;\r\n\r\n        // attempt to pay winner (use full gas if _gasLimit is 0)\r\n        vars.isPaid = true;\r\n        if (_gasLimit == 0) {\r\n            _paySuccessful = _winner.call.value(_prize)();\r\n        } else {\r\n            _paySuccessful = _winner.call.value(_prize).gas(_gasLimit)();\r\n        }\r\n\r\n        // emit proper event. rollback .isPaid on failure.\r\n        if (_paySuccessful) {\r\n            emit SendPrizeSuccess({\r\n                time: now,\r\n                redeemer: msg.sender,\r\n                recipient: _winner,\r\n                amount: _prize,\r\n                gasLimit: _gasLimit\r\n            });\r\n            return (true, _prize);\r\n        } else {\r\n            vars.isPaid = false;\r\n            emit SendPrizeFailure({\r\n                time: now,\r\n                redeemer: msg.sender,\r\n                recipient: _winner,\r\n                amount: _prize,\r\n                gasLimit: _gasLimit\r\n            });\r\n            return (false, 0);          \r\n        }\r\n    }\r\n    \r\n    // Sends accrued fees to the collector. Callable by anyone.\r\n    function sendFees()\r\n        public\r\n        returns (uint _feesSent)\r\n    {\r\n        _feesSent = fees();\r\n        if (_feesSent == 0) return;\r\n        require(settings.collector.call.value(_feesSent)());\r\n        emit FeesSent(now, settings.collector, _feesSent);\r\n    }\r\n\r\n\r\n\r\n    /*************************************************************/\r\n    /********** PUBLIC VIEWS *************************************/\r\n    /*************************************************************/\r\n\r\n    // Expose all Vars ////////////////////////////////////////\r\n    function monarch() public view returns (address) {\r\n        return vars.monarch;\r\n    }\r\n    function prize() public view returns (uint) {\r\n        return uint(vars.prizeGwei) * 1e9;\r\n    }\r\n    function numOverthrows() public view returns (uint) {\r\n        return vars.numOverthrows;\r\n    }\r\n    function blockEnded() public view returns (uint) {\r\n        return vars.blockEnded;\r\n    }\r\n    function prevBlock() public view returns (uint) {\r\n        return vars.prevBlock;\r\n    }\r\n    function isPaid() public view returns (bool) {\r\n        return vars.isPaid;\r\n    }\r\n    function decree() public view returns (bytes23) {\r\n        return vars.decree;\r\n    }\r\n    ///////////////////////////////////////////////////////////\r\n\r\n    // Expose all Settings //////////////////////////////////////\r\n    function collector() public view returns (address) {\r\n        return settings.collector;\r\n    }\r\n    function initialPrize() public view returns (uint){\r\n        return uint(settings.initialPrizeGwei) * 1e9;\r\n    }\r\n    function fee() public view returns (uint) {\r\n        return uint(settings.feeGwei) * 1e9;\r\n    }\r\n    function prizeIncr() public view returns (int) {\r\n        return int(settings.prizeIncrGwei) * 1e9;\r\n    }\r\n    function reignBlocks() public view returns (uint) {\r\n        return settings.reignBlocks;\r\n    }\r\n    ///////////////////////////////////////////////////////////\r\n\r\n    // The following are computed /////////////////////////////\r\n    function isEnded() public view returns (bool) {\r\n        return block.number > vars.blockEnded;\r\n    }\r\n    function getBlocksRemaining() public view returns (uint) {\r\n        if (isEnded()) return 0;\r\n        return (vars.blockEnded - block.number) + 1;\r\n    }\r\n    function fees() public view returns (uint) {\r\n        uint _balance = address(this).balance;\r\n        return vars.isPaid ? _balance : _balance - prize();\r\n    }\r\n    function totalFees() public view returns (uint) {\r\n        int _feePerOverthrowGwei = int(settings.feeGwei) - settings.prizeIncrGwei;\r\n        return uint(_feePerOverthrowGwei * vars.numOverthrows * 1e9);\r\n    }\r\n    ///////////////////////////////////////////////////////////\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"decree\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes23\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gasLimit\",\"type\":\"uint256\"}],\"name\":\"sendPrize\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"},{\"name\":\"_prizeSent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reignBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeIncr\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlocksRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialPrize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collector\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"monarch\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOverthrows\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_decree\",\"type\":\"bytes23\"}],\"name\":\"overthrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendFees\",\"outputs\":[{\"name\":\"_feesSent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_collector\",\"type\":\"address\"},{\"name\":\"_initialPrize\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_prizeIncr\",\"type\":\"int256\"},{\"name\":\"_reignBlocks\",\"type\":\"uint256\"},{\"name\":\"_initialBlocks\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"SendPrizeError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"initialBlocks\",\"type\":\"uint256\"}],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"newMonarch\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"decree\",\"type\":\"bytes23\"},{\"indexed\":true,\"name\":\"prevMonarch\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"OverthrowOccurred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OverthrowRefundSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OverthrowRefundFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"SendPrizeSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"SendPrizeFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesSent\",\"type\":\"event\"}]","ContractName":"MonarchyGame","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000641e79e4b7c61c24083abe03b40833719699e30100000000000000000000000000000000000000000000000006f05b59d3b2000000000000000000000000000000000000000000000000000000038d7ea4c6800000000000000000000000000000000000000000000000000000038d7ea4c68000000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000001f4","Library":"","SwarmSource":"bzzr://d59d66936b507fdff364af9513ce906f240e226943869e2117835bc12591babc"}]}