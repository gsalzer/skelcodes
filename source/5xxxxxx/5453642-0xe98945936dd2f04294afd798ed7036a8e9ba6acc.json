{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) { return 0; }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract PullPayment {\r\n  using SafeMath for uint256;\r\n  mapping(address => uint256) public payments;\r\n  uint256 public totalPayments;\r\n  function withdrawPayments() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n    require(payment != 0);\r\n    require(this.balance >= payment);\r\n    totalPayments = totalPayments.sub(payment);\r\n    payments[payee] = 0;\r\n    assert(payee.send(payment));\r\n  }\r\n  function asyncSend(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n    totalPayments = totalPayments.add(amount);\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract Destructible is Ownable {\r\n  function Destructible() public payable { }\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n  bool private reentrancy_lock = false;\r\n  modifier nonReentrant() {\r\n    require(!reentrancy_lock);\r\n    reentrancy_lock = true;\r\n    _;\r\n    reentrancy_lock = false;\r\n  }\r\n}\r\n\r\ncontract Map is PullPayment, Destructible, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    \r\n    // STRUCTS\r\n\r\n    struct Transaction {\r\n        string kingdomKey;\r\n        address compensationAddress;\r\n        uint buyingPrice;\r\n        uint compensation;\r\n        uint jackpotContribution;\r\n    }\r\n\r\n    struct Kingdom {\r\n        string title;\r\n        string key;\r\n        uint kingdomTier;\r\n        uint kingdomType;\r\n        uint minimumPrice; \r\n        uint lastTransaction;\r\n        uint transactionCount;\r\n        uint returnPrice;\r\n        address owner;\r\n        bool locked;\r\n    }\r\n\r\n    struct Jackpot {\r\n        address winner;\r\n        uint balance;\r\n    }\r\n\r\n    struct Round {\r\n        Jackpot globalJackpot;\r\n        Jackpot jackpot1;\r\n        Jackpot jackpot2;\r\n        Jackpot jackpot3;\r\n        Jackpot jackpot4;\r\n        Jackpot jackpot5;\r\n\r\n        mapping(string => bool) kingdomsCreated;\r\n        mapping(address => uint) nbKingdoms;\r\n        mapping(address => uint) nbTransactions;\r\n        mapping(address => uint) nbKingdomsType1;\r\n        mapping(address => uint) nbKingdomsType2;\r\n        mapping(address => uint) nbKingdomsType3;\r\n        mapping(address => uint) nbKingdomsType4;\r\n        mapping(address => uint) nbKingdomsType5;\r\n\r\n        uint startTime;\r\n        uint endTime;\r\n\r\n        mapping(string => uint) kingdomsKeys;\r\n    }\r\n\r\n    Kingdom[] public kingdoms;\r\n    Transaction[] public kingdomTransactions;\r\n    uint public currentRound;\r\n    address public bookerAddress;\r\n    \r\n    mapping(uint => Round) rounds;\r\n\r\n    uint constant public ACTION_TAX = 0.02 ether;\r\n    uint constant public STARTING_CLAIM_PRICE_WEI = 0.01 ether;\r\n    uint constant MAXIMUM_CLAIM_PRICE_WEI = 800 ether;\r\n    uint constant KINGDOM_MULTIPLIER = 20;\r\n    uint constant TEAM_COMMISSION_RATIO = 10;\r\n    uint constant JACKPOT_COMMISSION_RATIO = 10;\r\n\r\n    // MODIFIERS\r\n\r\n    modifier onlyForRemainingKingdoms() {\r\n        uint remainingKingdoms = getRemainingKingdoms();\r\n        require(remainingKingdoms > kingdoms.length);\r\n        _;\r\n    }\r\n\r\n    modifier checkKingdomExistence(string key) {\r\n        require(rounds[currentRound].kingdomsCreated[key] == true);\r\n        _;\r\n    }\r\n\r\n    modifier checkIsNotLocked(string kingdomKey) {\r\n        require(kingdoms[rounds[currentRound].kingdomsKeys[kingdomKey]].locked != true);\r\n        _;\r\n    }\r\n\r\n    modifier checkIsClosed() {\r\n        require(now >= rounds[currentRound].endTime);\r\n        _;\r\n    }\r\n\r\n    modifier onlyKingdomOwner(string _key, address _sender) {\r\n        require (kingdoms[rounds[currentRound].kingdomsKeys[_key]].owner == _sender);\r\n        _;\r\n    }\r\n    \r\n    // EVENTS\r\n\r\n    event LandCreatedEvent(string kingdomKey, address monarchAddress);\r\n    event LandPurchasedEvent(string kingdomKey, address monarchAddress);\r\n\r\n    //\r\n    //  CONTRACT CONSTRUCTOR\r\n    //\r\n    function Map(address _bookerAddress) {\r\n        bookerAddress = _bookerAddress;\r\n        currentRound = 1;\r\n        rounds[currentRound] = Round(Jackpot(address(0), 0), Jackpot(address(0), 0), Jackpot(address(0), 0), Jackpot(address(0), 0), Jackpot(address(0), 0), Jackpot(address(0), 0), 0, 0);\r\n        rounds[currentRound].jackpot1 = Jackpot(address(0), 0);\r\n        rounds[currentRound].jackpot2 = Jackpot(address(0), 0);\r\n        rounds[currentRound].jackpot3 = Jackpot(address(0), 0);\r\n        rounds[currentRound].jackpot4 = Jackpot(address(0), 0);\r\n        rounds[currentRound].jackpot5 = Jackpot(address(0), 0);\r\n        rounds[currentRound].startTime = 1523916000;\r\n        rounds[currentRound].endTime = rounds[currentRound].startTime + 7 days;\r\n        rounds[currentRound].globalJackpot = Jackpot(address(0), 0);\r\n     }\r\n\r\n    function () { }\r\n\r\n    function getRemainingKingdoms() public view returns (uint nb) {\r\n        for (uint i = 1; i < 8; i++) {\r\n            if (now < rounds[currentRound].startTime + (i * 24 hours)) {\r\n                uint result = (25 * i);\r\n                if (result > 125) { \r\n                    return 125; \r\n                } else {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setTypedJackpotWinner(address _user, uint _type) internal {\r\n        if (_type == 1) {\r\n            if (rounds[currentRound].jackpot1.winner == address(0)) {\r\n                rounds[currentRound].jackpot1.winner = _user;\r\n            } else if (rounds[currentRound].nbKingdomsType1[_user] >= rounds[currentRound].nbKingdomsType1[rounds[currentRound].jackpot1.winner]) {\r\n                rounds[currentRound].jackpot1.winner = _user;\r\n            }\r\n        } else if (_type == 2) {\r\n            if (rounds[currentRound].jackpot2.winner == address(0)) {\r\n                rounds[currentRound].jackpot2.winner = _user;\r\n            } else if (rounds[currentRound].nbKingdomsType2[_user] >= rounds[currentRound].nbKingdomsType2[rounds[currentRound].jackpot2.winner]) {\r\n                rounds[currentRound].jackpot2.winner = _user;\r\n            }\r\n        } else if (_type == 3) {\r\n            if (rounds[currentRound].jackpot3.winner == address(0)) {\r\n                rounds[currentRound].jackpot3.winner = _user;\r\n            } else if (rounds[currentRound].nbKingdomsType3[_user] >= rounds[currentRound].nbKingdomsType3[rounds[currentRound].jackpot3.winner]) {\r\n                rounds[currentRound].jackpot3.winner = _user;\r\n            }\r\n        } else if (_type == 4) {\r\n            if (rounds[currentRound].jackpot4.winner == address(0)) {\r\n                rounds[currentRound].jackpot4.winner = _user;\r\n            } else if (rounds[currentRound].nbKingdomsType4[_user] >= rounds[currentRound].nbKingdomsType4[rounds[currentRound].jackpot4.winner]) {\r\n                rounds[currentRound].jackpot4.winner = _user;\r\n            }\r\n        } else if (_type == 5) {\r\n            if (rounds[currentRound].jackpot5.winner == address(0)) {\r\n                rounds[currentRound].jackpot5.winner = _user;\r\n            } else if (rounds[currentRound].nbKingdomsType5[_user] >= rounds[currentRound].nbKingdomsType5[rounds[currentRound].jackpot5.winner]) {\r\n                rounds[currentRound].jackpot5.winner = _user;\r\n            }\r\n        }\r\n    }\r\n\r\n    //\r\n    //  This is the main function. It is called to buy a kingdom\r\n    //\r\n    function purchaseKingdom(string _key, string _title, bool _locked) public \r\n    payable \r\n    nonReentrant()\r\n    checkKingdomExistence(_key)\r\n    checkIsNotLocked(_key)\r\n    {\r\n        require(now < rounds[currentRound].endTime);\r\n        Round storage round = rounds[currentRound];\r\n        uint kingdomId = round.kingdomsKeys[_key];\r\n        Kingdom storage kingdom = kingdoms[kingdomId];\r\n        require((kingdom.kingdomTier + 1) < 6);\r\n        uint requiredPrice = kingdom.minimumPrice;\r\n        if (_locked == true) {\r\n            requiredPrice = requiredPrice.add(ACTION_TAX);\r\n        }\r\n\r\n        require (msg.value >= requiredPrice);\r\n        uint jackpotCommission = (msg.value).sub(kingdom.returnPrice);\r\n\r\n        if (kingdom.returnPrice > 0) {\r\n            round.nbKingdoms[kingdom.owner]--;\r\n            if (kingdom.kingdomType == 1) {\r\n                round.nbKingdomsType1[kingdom.owner]--;\r\n            } else if (kingdom.kingdomType == 2) {\r\n                round.nbKingdomsType2[kingdom.owner]--;\r\n            } else if (kingdom.kingdomType == 3) {\r\n                round.nbKingdomsType3[kingdom.owner]--;\r\n            } else if (kingdom.kingdomType == 4) {\r\n                round.nbKingdomsType4[kingdom.owner]--;\r\n            } else if (kingdom.kingdomType == 5) {\r\n                round.nbKingdomsType5[kingdom.owner]--;\r\n            }\r\n            \r\n            compensateLatestMonarch(kingdom.lastTransaction, kingdom.returnPrice);\r\n        }\r\n        \r\n        uint jackpotSplitted = jackpotCommission.mul(50).div(100);\r\n        round.globalJackpot.balance = round.globalJackpot.balance.add(jackpotSplitted);\r\n\r\n        kingdom.kingdomTier++;\r\n        kingdom.title = _title;\r\n\r\n        if (kingdom.kingdomTier == 5) {\r\n            kingdom.returnPrice = 0;\r\n        } else {\r\n            kingdom.returnPrice = kingdom.minimumPrice.mul(2);\r\n            kingdom.minimumPrice = kingdom.minimumPrice.add(kingdom.minimumPrice.mul(2));\r\n        }\r\n\r\n        kingdom.owner = msg.sender;\r\n        kingdom.locked = _locked;\r\n\r\n        uint transactionId = kingdomTransactions.push(Transaction(\"\", msg.sender, msg.value, 0, jackpotSplitted)) - 1;\r\n        kingdomTransactions[transactionId].kingdomKey = _key;\r\n        kingdom.transactionCount++;\r\n        kingdom.lastTransaction = transactionId;\r\n        \r\n        setNewJackpot(kingdom.kingdomType, jackpotSplitted, msg.sender);\r\n        LandPurchasedEvent(_key, msg.sender);\r\n    }\r\n\r\n    function setNewJackpot(uint kingdomType, uint jackpotSplitted, address sender) internal {\r\n        rounds[currentRound].nbTransactions[sender]++;\r\n        rounds[currentRound].nbKingdoms[sender]++;\r\n        if (kingdomType == 1) {\r\n            rounds[currentRound].nbKingdomsType1[sender]++;\r\n            rounds[currentRound].jackpot1.balance = rounds[currentRound].jackpot1.balance.add(jackpotSplitted);\r\n        } else if (kingdomType == 2) {\r\n            rounds[currentRound].nbKingdomsType2[sender]++;\r\n            rounds[currentRound].jackpot2.balance = rounds[currentRound].jackpot2.balance.add(jackpotSplitted);\r\n        } else if (kingdomType == 3) {\r\n            rounds[currentRound].nbKingdomsType3[sender]++;\r\n            rounds[currentRound].jackpot3.balance = rounds[currentRound].jackpot3.balance.add(jackpotSplitted);\r\n        } else if (kingdomType == 4) {\r\n            rounds[currentRound].nbKingdomsType4[sender]++;\r\n            rounds[currentRound].jackpot4.balance = rounds[currentRound].jackpot4.balance.add(jackpotSplitted);\r\n        } else if (kingdomType == 5) {\r\n            rounds[currentRound].nbKingdomsType5[sender]++;\r\n            rounds[currentRound].jackpot5.balance = rounds[currentRound].jackpot5.balance.add(jackpotSplitted);\r\n        }\r\n        setNewWinner(msg.sender, kingdomType);\r\n    }\r\n\r\n    function setLock(string _key, bool _locked) public payable checkKingdomExistence(_key) onlyKingdomOwner(_key, msg.sender) {\r\n        if (_locked == true) { require(msg.value >= ACTION_TAX); }\r\n        kingdoms[rounds[currentRound].kingdomsKeys[_key]].locked = _locked;\r\n        if (msg.value > 0) { asyncSend(bookerAddress, msg.value); }\r\n    }\r\n\r\n    function giveKingdom(address owner, string _key, string _title, uint _type) onlyOwner() public {\r\n        require(_type > 0);\r\n        require(_type < 6);\r\n        require(rounds[currentRound].kingdomsCreated[_key] == false);\r\n        uint kingdomId = kingdoms.push(Kingdom(\"\", \"\", 1, _type, 0, 0, 1, 0.02 ether, address(0), false)) - 1;\r\n        kingdoms[kingdomId].title = _title;\r\n        kingdoms[kingdomId].owner = owner;\r\n        kingdoms[kingdomId].key = _key;\r\n        kingdoms[kingdomId].minimumPrice = 0.03 ether;\r\n        kingdoms[kingdomId].locked = false;\r\n        rounds[currentRound].kingdomsKeys[_key] = kingdomId;\r\n        rounds[currentRound].kingdomsCreated[_key] = true;\r\n        uint transactionId = kingdomTransactions.push(Transaction(\"\", msg.sender, 0.01 ether, 0, 0)) - 1;\r\n        kingdomTransactions[transactionId].kingdomKey = _key;\r\n        kingdoms[kingdomId].lastTransaction = transactionId;\r\n    }\r\n\r\n    //\r\n    //  User can call this function to generate new kingdoms (within the limits of available land)\r\n    //\r\n    function createKingdom(address owner, string _key, string _title, uint _type, bool _locked) onlyForRemainingKingdoms() public payable {\r\n        require(now < rounds[currentRound].endTime);\r\n        require(_type > 0);\r\n        require(_type < 6);\r\n        uint basePrice = STARTING_CLAIM_PRICE_WEI;\r\n        uint requiredPrice = basePrice;\r\n        if (_locked == true) { requiredPrice = requiredPrice.add(ACTION_TAX); }\r\n        require(msg.value >= requiredPrice);\r\n        require(rounds[currentRound].kingdomsCreated[_key] == false);\r\n        uint refundPrice = STARTING_CLAIM_PRICE_WEI.mul(2);\r\n        uint nextMinimumPrice = STARTING_CLAIM_PRICE_WEI.add(refundPrice);\r\n        uint kingdomId = kingdoms.push(Kingdom(\"\", \"\", 1, _type, 0, 0, 1, refundPrice, address(0), false)) - 1;\r\n        \r\n        kingdoms[kingdomId].title = _title;\r\n        kingdoms[kingdomId].owner = owner;\r\n        kingdoms[kingdomId].key = _key;\r\n        kingdoms[kingdomId].minimumPrice = nextMinimumPrice;\r\n        kingdoms[kingdomId].locked = _locked;\r\n\r\n        rounds[currentRound].kingdomsKeys[_key] = kingdomId;\r\n        rounds[currentRound].kingdomsCreated[_key] = true;\r\n        \r\n        asyncSend(bookerAddress, ACTION_TAX);\r\n\r\n        uint jackpotSplitted = basePrice.mul(50).div(100);\r\n        rounds[currentRound].globalJackpot.balance = rounds[currentRound].globalJackpot.balance.add(jackpotSplitted);\r\n\r\n        uint transactionId = kingdomTransactions.push(Transaction(\"\", msg.sender, msg.value, 0, jackpotSplitted)) - 1;\r\n        kingdomTransactions[transactionId].kingdomKey = _key;\r\n        kingdoms[kingdomId].lastTransaction = transactionId;\r\n       \r\n        setNewJackpot(_type, jackpotSplitted, msg.sender);\r\n        LandCreatedEvent(_key, msg.sender);\r\n    }\r\n\r\n    //\r\n    //  Send transaction to compensate the previous owner\r\n    //\r\n    function compensateLatestMonarch(uint lastTransaction, uint compensationWei) internal {\r\n        address compensationAddress = kingdomTransactions[lastTransaction].compensationAddress;\r\n        kingdomTransactions[lastTransaction].compensation = compensationWei;\r\n        asyncSend(compensationAddress, compensationWei);\r\n    }\r\n\r\n    //\r\n    //  This function may be useful to force withdraw if user never come back to get his money\r\n    //\r\n    function forceWithdrawPayments(address payee) public onlyOwner {\r\n        uint256 payment = payments[payee];\r\n        require(payment != 0);\r\n        require(this.balance >= payment);\r\n        totalPayments = totalPayments.sub(payment);\r\n        payments[payee] = 0;\r\n        assert(payee.send(payment));\r\n    }\r\n\r\n    function getStartTime() public view returns (uint startTime) {\r\n        return rounds[currentRound].startTime;\r\n    }\r\n\r\n    function getEndTime() public view returns (uint endTime) {\r\n        return rounds[currentRound].endTime;\r\n    }\r\n    \r\n    function payJackpot(uint _type) public checkIsClosed() {\r\n        Round storage finishedRound = rounds[currentRound];\r\n        if (_type == 1 && finishedRound.jackpot1.winner != address(0) && finishedRound.jackpot1.balance > 0) {\r\n            require(this.balance >= finishedRound.jackpot1.balance);\r\n            uint jackpot1TeamComission = (finishedRound.jackpot1.balance.mul(TEAM_COMMISSION_RATIO)).div(100);\r\n            asyncSend(bookerAddress, jackpot1TeamComission);\r\n            asyncSend(finishedRound.jackpot1.winner, finishedRound.jackpot1.balance.sub(jackpot1TeamComission));\r\n            finishedRound.jackpot1.balance = 0;\r\n        } else if (_type == 2 && finishedRound.jackpot2.winner != address(0) && finishedRound.jackpot2.balance > 0) {\r\n            require(this.balance >= finishedRound.jackpot2.balance);\r\n            uint jackpot2TeamComission = (finishedRound.jackpot2.balance.mul(TEAM_COMMISSION_RATIO)).div(100);\r\n            asyncSend(bookerAddress, jackpot2TeamComission);\r\n            asyncSend(finishedRound.jackpot2.winner, finishedRound.jackpot2.balance.sub(jackpot2TeamComission));\r\n            finishedRound.jackpot2.balance = 0;\r\n        } else if (_type == 3 && finishedRound.jackpot3.winner != address(0) && finishedRound.jackpot3.balance > 0) {\r\n            require(this.balance >= finishedRound.jackpot3.balance);\r\n            uint jackpot3TeamComission = (finishedRound.jackpot3.balance.mul(TEAM_COMMISSION_RATIO)).div(100);\r\n            asyncSend(bookerAddress, jackpot3TeamComission);\r\n            asyncSend(finishedRound.jackpot3.winner, finishedRound.jackpot3.balance.sub(jackpot3TeamComission));\r\n            finishedRound.jackpot3.balance = 0;\r\n        } else if (_type == 4 && finishedRound.jackpot4.winner != address(0) && finishedRound.jackpot4.balance > 0) {\r\n            require(this.balance >= finishedRound.jackpot4.balance);\r\n            uint jackpot4TeamComission = (finishedRound.jackpot4.balance.mul(TEAM_COMMISSION_RATIO)).div(100);\r\n            asyncSend(bookerAddress, jackpot4TeamComission);\r\n            asyncSend(finishedRound.jackpot4.winner, finishedRound.jackpot4.balance.sub(jackpot4TeamComission));\r\n            finishedRound.jackpot4.balance = 0;\r\n        } else if (_type == 5 && finishedRound.jackpot5.winner != address(0) && finishedRound.jackpot5.balance > 0) {\r\n            require(this.balance >= finishedRound.jackpot5.balance);\r\n            uint jackpot5TeamComission = (finishedRound.jackpot5.balance.mul(TEAM_COMMISSION_RATIO)).div(100);\r\n            asyncSend(bookerAddress, jackpot5TeamComission);\r\n            asyncSend(finishedRound.jackpot5.winner, finishedRound.jackpot5.balance.sub(jackpot5TeamComission));\r\n            finishedRound.jackpot5.balance = 0;\r\n        }\r\n\r\n        if (finishedRound.globalJackpot.winner != address(0) && finishedRound.globalJackpot.balance > 0) {\r\n            require(this.balance >= finishedRound.globalJackpot.balance);\r\n            uint globalTeamComission = (finishedRound.globalJackpot.balance.mul(TEAM_COMMISSION_RATIO)).div(100);\r\n            asyncSend(bookerAddress, globalTeamComission);\r\n            asyncSend(finishedRound.globalJackpot.winner, finishedRound.globalJackpot.balance.sub(globalTeamComission));\r\n            finishedRound.globalJackpot.balance = 0;\r\n        }\r\n    }\r\n\r\n    //\r\n    //  After time expiration, owner can call this function to activate the next round of the game\r\n    //\r\n    function activateNextRound(uint _startTime) public checkIsClosed() {\r\n        Round storage finishedRound = rounds[currentRound];\r\n        require(finishedRound.globalJackpot.balance == 0);\r\n        require(finishedRound.jackpot5.balance == 0);\r\n        require(finishedRound.jackpot4.balance == 0);\r\n        require(finishedRound.jackpot3.balance == 0);\r\n        require(finishedRound.jackpot2.balance == 0);\r\n        require(finishedRound.jackpot1.balance == 0);\r\n        currentRound++;\r\n        rounds[currentRound] = Round(Jackpot(address(0), 0), Jackpot(address(0), 0), Jackpot(address(0), 0), Jackpot(address(0), 0), Jackpot(address(0), 0), Jackpot(address(0), 0), 0, 0);\r\n        rounds[currentRound].startTime = _startTime;\r\n        rounds[currentRound].endTime = _startTime + 7 days;\r\n        delete kingdoms;\r\n        delete kingdomTransactions;\r\n    }\r\n\r\n    // GETTER AND SETTER FUNCTIONS\r\n\r\n    function setNewWinner(address _sender, uint _type) internal {\r\n        if (rounds[currentRound].globalJackpot.winner == address(0)) {\r\n            rounds[currentRound].globalJackpot.winner = _sender;\r\n        } else {\r\n            if (rounds[currentRound].nbKingdoms[_sender] == rounds[currentRound].nbKingdoms[rounds[currentRound].globalJackpot.winner]) {\r\n                if (rounds[currentRound].nbTransactions[_sender] > rounds[currentRound].nbTransactions[rounds[currentRound].globalJackpot.winner]) {\r\n                    rounds[currentRound].globalJackpot.winner = _sender;\r\n                }\r\n            } else if (rounds[currentRound].nbKingdoms[_sender] > rounds[currentRound].nbKingdoms[rounds[currentRound].globalJackpot.winner]) {\r\n                rounds[currentRound].globalJackpot.winner = _sender;\r\n            }\r\n        }\r\n        setTypedJackpotWinner(_sender, _type);\r\n    }\r\n\r\n    function getJackpot(uint _nb) public view returns (address winner, uint balance, uint winnerCap) {\r\n        Round storage round = rounds[currentRound];\r\n        if (_nb == 1) {\r\n            return (round.jackpot1.winner, round.jackpot1.balance, round.nbKingdomsType1[round.jackpot1.winner]);\r\n        } else if (_nb == 2) {\r\n            return (round.jackpot2.winner, round.jackpot2.balance, round.nbKingdomsType2[round.jackpot2.winner]);\r\n        } else if (_nb == 3) {\r\n            return (round.jackpot3.winner, round.jackpot3.balance, round.nbKingdomsType3[round.jackpot3.winner]);\r\n        } else if (_nb == 4) {\r\n            return (round.jackpot4.winner, round.jackpot4.balance, round.nbKingdomsType4[round.jackpot4.winner]);\r\n        } else if (_nb == 5) {\r\n            return (round.jackpot5.winner, round.jackpot5.balance, round.nbKingdomsType5[round.jackpot5.winner]);\r\n        } else {\r\n            return (round.globalJackpot.winner, round.globalJackpot.balance, round.nbKingdoms[round.globalJackpot.winner]);\r\n        }\r\n    }\r\n\r\n    function getKingdomCount() public view returns (uint kingdomCount) {\r\n        return kingdoms.length;\r\n    }\r\n\r\n    function getKingdomInformations(string kingdomKey) public view returns (string title, uint minimumPrice, uint lastTransaction, uint transactionCount, address currentOwner, bool locked) {\r\n        uint kingdomId = rounds[currentRound].kingdomsKeys[kingdomKey];\r\n        Kingdom storage kingdom = kingdoms[kingdomId];\r\n        return (kingdom.title, kingdom.minimumPrice, kingdom.lastTransaction, kingdom.transactionCount, kingdom.owner, kingdom.locked);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"string\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"purchaseKingdom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bookerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEndTime\",\"outputs\":[{\"name\":\"endTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nb\",\"type\":\"uint256\"}],\"name\":\"getJackpot\",\"outputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"winnerCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"string\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_type\",\"type\":\"uint256\"},{\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"createKingdom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"forceWithdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"string\"},{\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"setLock\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STARTING_CLAIM_PRICE_WEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"string\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"giveKingdom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKingdomCount\",\"outputs\":[{\"name\":\"kingdomCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kingdoms\",\"outputs\":[{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"key\",\"type\":\"string\"},{\"name\":\"kingdomTier\",\"type\":\"uint256\"},{\"name\":\"kingdomType\",\"type\":\"uint256\"},{\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"name\":\"lastTransaction\",\"type\":\"uint256\"},{\"name\":\"transactionCount\",\"type\":\"uint256\"},{\"name\":\"returnPrice\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"locked\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ACTION_TAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartTime\",\"outputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kingdomTransactions\",\"outputs\":[{\"name\":\"kingdomKey\",\"type\":\"string\"},{\"name\":\"compensationAddress\",\"type\":\"address\"},{\"name\":\"buyingPrice\",\"type\":\"uint256\"},{\"name\":\"compensation\",\"type\":\"uint256\"},{\"name\":\"jackpotContribution\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"payJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"kingdomKey\",\"type\":\"string\"}],\"name\":\"getKingdomInformations\",\"outputs\":[{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"name\":\"lastTransaction\",\"type\":\"uint256\"},{\"name\":\"transactionCount\",\"type\":\"uint256\"},{\"name\":\"currentOwner\",\"type\":\"address\"},{\"name\":\"locked\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingKingdoms\",\"outputs\":[{\"name\":\"nb\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"activateNextRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bookerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"kingdomKey\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"monarchAddress\",\"type\":\"address\"}],\"name\":\"LandCreatedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"kingdomKey\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"monarchAddress\",\"type\":\"address\"}],\"name\":\"LandPurchasedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Map","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008c7d96da59d23b50b9eeefdacf58a5fce62b35b5","Library":"","SwarmSource":"bzzr://fb432e692aa1db2c08e7b7a9835ea06a555c3f82f91f6718432fce84c4cfba8f"}]}