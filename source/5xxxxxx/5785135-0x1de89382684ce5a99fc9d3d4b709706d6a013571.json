{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public admin;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setAdmin(address newAdmin) public onlyOwner {\r\n        require(newAdmin != address(0));\r\n        admin = newAdmin;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    bool public paused = true;\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS paused\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS NOT paused\r\n     */\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract BrokenContract is Pausable {\r\n    /// Set in case the core contract is broken and an upgrade is required\r\n    address public newContractAddress;\r\n\r\n    ///@dev only for serious breaking bug\r\n    function setNewAddress(address _v2Address) external onlyOwner whenPaused {\r\n        //withdraw all balance when contract update\r\n        owner.transfer(address(this).balance);\r\n\r\n        newContractAddress = _v2Address;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    //event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    //function approve(address _to, uint256 _tokenId) public;\r\n    //function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n    //function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n    function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n    function name() public view returns (string _name);\r\n    function symbol() public view returns (string _symbol);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is BrokenContract, ERC721Basic {\r\n    using SafeMath for uint256;\r\n    using AddressUtils for address;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) internal tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    //mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) internal ownedTokensCount;\r\n\r\n    /**\r\n     * @dev Guarantees msg.sender is owner of the given token\r\n     * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n     */\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n     * @param _tokenId uint256 ID of the token to validate\r\n     */\r\n    /*modifier canTransfer(uint256 _tokenId) {\r\n        require(isApprovedOrOwner(msg.sender, _tokenId));\r\n        _;\r\n    }*/\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param _owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownedTokensCount[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param _tokenId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param _tokenId uint256 ID of the token to query the existence of\r\n     * @return whether the token exists\r\n     */\r\n    function exists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * @dev The zero address indicates there is no approved address.\r\n     * @dev There can only be one approved address per token at a given time.\r\n     * @dev Can only be called by the token owner or an approved operator.\r\n     * @param _to address to be approved for the given token ID\r\n     * @param _tokenId uint256 ID of the token to be approved\r\n     */\r\n    /*function approve(address _to, uint256 _tokenId) public whenNotPaused {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_to != owner);\r\n        require(msg.sender == owner);\r\n\r\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n            tokenApprovals[_tokenId] = _to;\r\n            emit Approval(owner, _to, _tokenId);\r\n        }\r\n    }*/\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * @param _tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    /*function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }*/\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * @dev Requires the msg sender to be the owner, approved, or operator\r\n     * @param _from current owner of the token\r\n     * @param _to address to receive the ownership of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    /*function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused canTransfer(_tokenId) {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }*/\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param _spender address of the spender to query\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     *  is an operator of the owner, or is the owner of the token\r\n     */\r\n    function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(_tokenId);\r\n        return _spender == owner/* || getApproved(_tokenId) == _spender*/;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * @dev Reverts if the given token ID already exists\r\n     * @param _to The address that will own the minted token\r\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n     */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to clear current approval of a given token ID\r\n     * @dev Reverts if the given address is not indeed the owner of the token\r\n     * @param _owner owner of the token\r\n     * @param _tokenId uint256 ID of the token to be transferred\r\n     */\r\n    /*function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n            emit Approval(_owner, address(0), _tokenId);\r\n        }\r\n    }*/\r\n\r\n    /**\r\n     * @dev Internal function to add a token ID to the list of a given address\r\n     * @param _to address representing the new owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require(tokenOwner[_tokenId] == address(0));\r\n        tokenOwner[_tokenId] = _to;\r\n        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to remove a token ID from the list of a given address\r\n     * @param _from address representing the previous owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _from);\r\n        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n        tokenOwner[_tokenId] = address(0);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Token is ERC721, ERC721BasicToken {\r\n    // Token name\r\n    string internal name_;\r\n\r\n    // Token symbol\r\n    string internal symbol_;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) internal ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] internal allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n    /**\r\n     * @dev Constructor function\r\n     */\r\n    constructor(string _name, string _symbol) public {\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token name\r\n     * @return string representing the token name\r\n     */\r\n    function name() public view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token symbol\r\n     * @return string representing the token symbol\r\n     */\r\n    function symbol() public view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n     * @param _owner address owning the tokens list to be accessed\r\n     * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n        require(_index < balanceOf(_owner));\r\n        return ownedTokens[_owner][_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of tokens stored by the contract\r\n     * @return uint256 representing the total amount of tokens\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the tokens in this contract\r\n     * @dev Reverts if the index is greater or equal to the total number of tokens\r\n     * @param _index uint256 representing the index to be accessed of the tokens list\r\n     * @return uint256 token ID at the given index of the tokens list\r\n     */\r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        require(_index < totalSupply());\r\n        return allTokens[_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to add a token ID to the list of a given address\r\n     * @param _to address representing the new owner of the given token ID\r\n     * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        super.addTokenTo(_to, _tokenId);\r\n        uint256 length = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n        ownedTokensIndex[_tokenId] = length;\r\n    }\r\n\r\n    /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        super.removeTokenFrom(_from, _tokenId);\r\n\r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        ownedTokens[_from][lastTokenIndex] = 0;\r\n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n        ownedTokens[_from].length--;\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * @dev Reverts if the given token ID already exists\r\n     * @param _to address the beneficiary that will own the minted token\r\n     * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n     */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        super._mint(_to, _tokenId);\r\n\r\n        allTokensIndex[_tokenId] = allTokens.length;\r\n        allTokens.push(_tokenId);\r\n    }\r\n\r\n}\r\n\r\n\r\n///@dev Base game contract. Holds all common structs, events and base variables.\r\ncontract BaseGame is ERC721Token {\r\n    /// EVENTS\r\n    ///@dev the Created event is fired whenever create or clone new fan token\r\n    event NewAccount(address owner, uint tokenId, uint parentTokenId, uint blockNumber);\r\n\r\n    ///@dev the NewForecast event is fired whenever any user create new forecast for game\r\n    event NewForecast(address owner, uint tokenId, uint forecastId, uint _gameId,\r\n        uint _forecastData);\r\n\r\n    /// STRUCTS\r\n    ///@dev Token - main token struct\r\n    struct Token {\r\n        // create block number, for tournament round, and date\r\n        uint createBlockNumber;\r\n\r\n        // parent\r\n        uint parentId;\r\n    }\r\n\r\n    enum Teams { DEF,\r\n        RUS, SAU, EGY, URY,     // group A\r\n        PRT, ESP, MAR, IRN,     // group B\r\n        FRA, AUS, PER, DNK,     // group C\r\n        ARG, ISL, HRV, NGA,     // D\r\n        BRA, CHE, CRI, SRB,     // E\r\n        DEU, MEX, SWE, KOR,     // F\r\n        BEL, PAN, TUN, GBR,     // G\r\n        POL, SEN, COL, JPN      // H\r\n    }\r\n\r\n    ///#dev game changed event\r\n    event GameChanged(uint _gameId, uint64 gameDate, Teams teamA, Teams teamB,\r\n        uint goalA, uint goalB, bool odds, uint shotA, uint shotB);\r\n\r\n\r\n    ///@dev Game info with result, index = official game id\r\n    struct Game {\r\n        // timestamp game date\r\n        uint64 gameDate;\r\n\r\n        // id teamA and teamB\r\n        Teams teamA;\r\n        Teams teamB;\r\n\r\n        // count of total goal\r\n        uint goalA;\r\n        uint goalB;\r\n\r\n        // game overweight / true - A / false - B\r\n        bool odds;\r\n\r\n        // total blows on target\r\n        uint shotA;\r\n        uint shotB;\r\n\r\n        // list of ID forecast's\r\n        uint[] forecasts;\r\n    }\r\n\r\n    ///@dev Forecast - fan forecast to game\r\n    struct Forecast {\r\n        // bits forecast for game from fan\r\n        uint gameId;\r\n        uint forecastBlockNumber;\r\n\r\n        uint forecastData;\r\n    }\r\n\r\n    /// STORAGE\r\n    ///@dev array of token fans\r\n    Token[] tokens;\r\n\r\n    ///@dev array of game from, 0 - invalid, index - official ID of game\r\n    // http://welcome2018.com/matches/#\r\n    //Game[65] games;\r\n    mapping (uint => Game) games;\r\n\r\n    ///@dev array of forecast for game from fans\r\n    Forecast[] forecasts;\r\n\r\n    ///@dev forecast -> token\r\n    mapping (uint => uint) internal forecastToToken;\r\n\r\n    ///@dev token -> forecast's\r\n    mapping (uint => uint[]) internal tokenForecasts;\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor(string _name, string _symbol) ERC721Token(_name, _symbol) public {}\r\n\r\n    /// METHOD's\r\n    ///@dev create new token\r\n    function _createToken(uint _parentId, address _owner) internal whenNotPaused\r\n    returns (uint) {\r\n        Token memory _token = Token({\r\n            createBlockNumber: block.number,\r\n            parentId: _parentId\r\n            });\r\n        uint newTokenId = tokens.push(_token) - 1;\r\n\r\n        emit NewAccount(_owner, newTokenId, uint(_token.parentId), uint(_token.createBlockNumber));\r\n        _mint(_owner, newTokenId);\r\n        return newTokenId;\r\n    }\r\n\r\n    ///@dev Create new forecast\r\n    function _createForecast(uint _tokenId, uint _gameId, uint _forecastData) internal whenNotPaused returns (uint) {\r\n        require(_tokenId < tokens.length);\r\n\r\n        Forecast memory newForecast = Forecast({\r\n            gameId: _gameId,\r\n            forecastBlockNumber: block.number,\r\n            forecastData: _forecastData\r\n            });\r\n\r\n        uint newForecastId = forecasts.push(newForecast) - 1;\r\n\r\n        forecastToToken[newForecastId] = _tokenId;\r\n        tokenForecasts[_tokenId].push(newForecastId);\r\n        games[_gameId].forecasts.push(newForecastId);\r\n\r\n        //fire forecast!\r\n        emit NewForecast(tokenOwner[_tokenId], _tokenId, newForecastId, _gameId, _forecastData);\r\n        return newForecastId;\r\n    }    \r\n}\r\n\r\n\r\ncontract BaseGameLogic is BaseGame {\r\n\r\n    ///@dev prize fund count\r\n    uint public prizeFund = 0;\r\n    ///@dev payment for create new Token\r\n    uint public basePrice = 21 finney;\r\n    ///@dev cut game on each clone operation, measured in basis points (1/100 of a percent).\r\n\r\n    /// values 0 - 10 000 -> 0 - 100%\r\n    uint public gameCloneFee = 7000;         /// % game fee (contract + prizeFund)\r\n    uint public priceFactor = 10000;         /// %% calculate price (increase/decrease)\r\n    uint public prizeFundFactor = 5000;      /// %% prizeFund\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor(string _name, string _symbol) BaseGame(_name, _symbol) public {}\r\n\r\n    ///@dev increase prize fund\r\n    function _addToFund(uint _val, bool isAll) internal whenNotPaused {\r\n        if(isAll) {\r\n            prizeFund = prizeFund.add(_val);\r\n        } else {\r\n            prizeFund = prizeFund.add(_val.mul(prizeFundFactor).div(10000));\r\n        }\r\n    }\r\n\r\n    ///@dev create new Token\r\n    function createAccount() external payable whenNotPaused returns (uint) {\r\n        require(msg.value >= basePrice);\r\n\r\n        ///todo: return excess funds\r\n        _addToFund(msg.value, false);\r\n        return _createToken(0, msg.sender);\r\n    }\r\n\r\n    ///@dev buy clone of token\r\n    function cloneAccount(uint _tokenId) external payable whenNotPaused returns (uint) {\r\n        require(exists(_tokenId));\r\n\r\n        uint tokenPrice = calculateTokenPrice(_tokenId);\r\n        require(msg.value >= tokenPrice);\r\n\r\n        /// create clone\r\n        uint newToken = _createToken( _tokenId, msg.sender);\r\n\r\n        /// calculate game fee\r\n        //uint gameFee = _calculateGameFee(tokenPrice);\r\n        uint gameFee = tokenPrice.mul(gameCloneFee).div(10000);\r\n        /// increase prizeFund\r\n        _addToFund(gameFee, false);\r\n        /// send income to token owner\r\n        uint ownerProceed = tokenPrice.sub(gameFee);\r\n        address tokenOwnerAddress = tokenOwner[_tokenId];\r\n        tokenOwnerAddress.transfer(ownerProceed);\r\n\r\n        return newToken;\r\n    }\r\n\r\n\r\n    ///@dev create forecast, check game stop\r\n    function createForecast(uint _tokenId, uint _gameId,\r\n        uint8 _goalA, uint8 _goalB, bool _odds, uint8 _shotA, uint8 _shotB)\r\n    external whenNotPaused onlyOwnerOf(_tokenId) returns (uint){\r\n        require(exists(_tokenId));\r\n        require(block.timestamp < games[_gameId].gameDate);\r\n\r\n        uint _forecastData = toForecastData(_goalA, _goalB, _odds, _shotA, _shotB);\r\n        return _createForecast(_tokenId, _gameId, _forecastData);\r\n\r\n        //check exist forecast from this token/account\r\n        /* uint forecastId = 0;\r\n        uint _forecastCount = tokenForecasts[_tokenId].length;\r\n        uint _testForecastId;\r\n        for (uint _forecastIndex = 0; _forecastIndex < _forecastCount; _forecastIndex++) {\r\n            _testForecastId = tokenForecasts[_tokenId][_forecastIndex];\r\n            if(forecasts[_testForecastId].gameId == _gameId) {\r\n                forecastId = _testForecastId;\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint _forecastData = toForecastData(_goalA, _goalB, _odds, _shotA, _shotB);\r\n\r\n        if(forecastId > 0) {\r\n            return _editForecast(forecastId, _forecastData);\r\n        } else {\r\n            return _createForecast(_tokenId, _gameId, _forecastData);\r\n        } */\r\n    }\r\n\r\n    ///@dev get list of token\r\n    function tokensOfOwner(address _owner) public view returns(uint[] ownerTokens) {\r\n        uint tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint[](0);\r\n        } else {\r\n            uint[] memory result = new uint[](tokenCount);\r\n            uint totalToken = totalSupply();\r\n            uint resultIndex = 0;\r\n\r\n            uint _tokenId;\r\n            for (_tokenId = 1; _tokenId <= totalToken; _tokenId++) {\r\n                if (tokenOwner[_tokenId] == _owner) {\r\n                    result[resultIndex] = _tokenId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    ///@dev get list of forecast by token\r\n    function forecastOfToken(uint _tokenId) public view returns(uint[]) {\r\n        uint forecastCount = tokenForecasts[_tokenId].length;\r\n\r\n        if (forecastCount == 0) {\r\n            // Return an empty array\r\n            return new uint[](0);\r\n        } else {\r\n            uint[] memory result = new uint[](forecastCount);\r\n            uint resultIndex;\r\n            for (resultIndex = 0; resultIndex < forecastCount; resultIndex++) {\r\n                result[resultIndex] = tokenForecasts[_tokenId][resultIndex];\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    ///@dev get info by game\r\n    function gameInfo(uint _gameId) external view returns(\r\n        uint64 gameDate, Teams teamA, Teams teamB, uint goalA, uint gaolB,\r\n        bool odds, uint shotA, uint shotB, uint forecastCount\r\n    ){\r\n        gameDate = games[_gameId].gameDate;\r\n        teamA = games[_gameId].teamA;\r\n        teamB = games[_gameId].teamB;\r\n        goalA = games[_gameId].goalA;\r\n        gaolB = games[_gameId].goalB;\r\n        odds = games[_gameId].odds;\r\n        shotA = games[_gameId].shotA;\r\n        shotB = games[_gameId].shotB;\r\n        forecastCount = games[_gameId].forecasts.length;\r\n    }\r\n\r\n    ///@dev get info by forecast\r\n    function forecastInfo(uint _fId) external view\r\n        returns(uint gameId, uint f) {\r\n        gameId = forecasts[_fId].gameId;\r\n        f = forecasts[_fId].forecastData;\r\n    }\r\n\r\n    function tokenInfo(uint _tokenId) external view\r\n        returns(uint createBlockNumber, uint parentId, uint forecast, uint score, uint price) {\r\n\r\n        createBlockNumber = tokens[_tokenId].createBlockNumber;\r\n        parentId = tokens[_tokenId].parentId;\r\n        price = calculateTokenPrice(_tokenId);\r\n        forecast = getForecastCount(_tokenId, block.number, false);\r\n        score = getScore(_tokenId);\r\n    }\r\n\r\n    ///@dev calculate token price\r\n    function calculateTokenPrice(uint _tokenId) public view returns(uint) {\r\n        require(exists(_tokenId));\r\n        /// token price = (forecast count + 1) * basePrice * priceFactor / 10000\r\n        uint forecastCount = getForecastCount(_tokenId, block.number, true);\r\n        return (forecastCount.add(1)).mul(basePrice).mul(priceFactor).div(10000);\r\n    }\r\n\r\n    ///@dev get forecast count by tokenID\r\n    function getForecastCount(uint _tokenId, uint _blockNumber, bool isReleased) public view returns(uint) {\r\n        require(exists(_tokenId));\r\n\r\n        uint forecastCount = 0 ;\r\n\r\n        uint index = 0;\r\n        uint count = tokenForecasts[_tokenId].length;\r\n        for (index = 0; index < count; index++) {\r\n            //game's ended\r\n            if(forecasts[tokenForecasts[_tokenId][index]].forecastBlockNumber < _blockNumber){\r\n                if(isReleased) {\r\n                    if (games[forecasts[tokenForecasts[_tokenId][index]].gameId].gameDate < block.timestamp) {\r\n                        forecastCount = forecastCount + 1;\r\n                    }\r\n                } else {\r\n                    forecastCount = forecastCount + 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        /// if token are cloned, calculate parent forecast score\r\n        if(tokens[_tokenId].parentId != 0){\r\n            forecastCount = forecastCount.add(getForecastCount(tokens[_tokenId].parentId,\r\n                tokens[_tokenId].createBlockNumber, isReleased));\r\n        }\r\n        return forecastCount;\r\n    }\r\n\r\n    ///@dev calculate score by fan's forecasts\r\n    function getScore(uint _tokenId) public view returns (uint){\r\n        uint[] memory _gameForecast = new uint[](65);\r\n        return getScore(_tokenId, block.number, _gameForecast);\r\n    }\r\n\r\n    ///@dev calculate score by fan's forecast to a specific block number\r\n    function getScore(uint _tokenId, uint _blockNumber, uint[] _gameForecast) public view returns (uint){\r\n        uint score = 0;\r\n\r\n        /// find all forecasts and calculate forecast score\r\n        uint[] memory _forecasts = forecastOfToken(_tokenId);\r\n        if (_forecasts.length > 0){\r\n            uint256 _index;\r\n            for(_index = _forecasts.length - 1; _index >= 0 && _index < _forecasts.length ; _index--){\r\n                /// check:\r\n                ///     forecastBlockNumber < current block number\r\n                ///     one forecast for one game (last)\r\n                if(forecasts[_forecasts[_index]].forecastBlockNumber < _blockNumber &&\r\n                    _gameForecast[forecasts[_forecasts[_index]].gameId] == 0 &&\r\n                    block.timestamp > games[forecasts[_forecasts[_index]].gameId].gameDate\r\n                ){\r\n                    score = score.add(calculateScore(\r\n                            forecasts[_forecasts[_index]].gameId,\r\n                            forecasts[_forecasts[_index]].forecastData\r\n                        ));\r\n                    _gameForecast[forecasts[_forecasts[_index]].gameId] = forecasts[_forecasts[_index]].forecastBlockNumber;\r\n                }\r\n            }\r\n        }\r\n\r\n        /// if token are cloned, calculate parent forecast score\r\n        if(tokens[_tokenId].parentId != 0){\r\n            score = score.add(getScore(tokens[_tokenId].parentId, tokens[_tokenId].createBlockNumber, _gameForecast));\r\n        }\r\n        return score;\r\n    }\r\n\r\n    /// get forecast score\r\n    function getForecastScore(uint256 _forecastId) external view returns (uint256) {\r\n        require(_forecastId < forecasts.length);\r\n\r\n        return calculateScore(\r\n            forecasts[_forecastId].gameId,\r\n            forecasts[_forecastId].forecastData\r\n        );\r\n    }\r\n\r\n    ///@dev calculate score by game forecast (only for games that have ended)\r\n    function calculateScore(uint256 _gameId, uint d)\r\n    public view returns (uint256){\r\n        require(block.timestamp > games[_gameId].gameDate);\r\n\r\n        uint256 _shotB = (d & 0xff);\r\n        d = d >> 8;\r\n        uint256 _shotA = (d & 0xff);\r\n        d = d >> 8;\r\n        uint odds8 = (d & 0xff);\r\n        bool _odds = odds8 == 1 ? true: false;\r\n        d = d >> 8;\r\n        uint256 _goalB = (d & 0xff);\r\n        d = d >> 8;\r\n        uint256 _goalA = (d & 0xff);\r\n        d = d >> 8;\r\n\r\n        Game memory cGame = games[_gameId];\r\n\r\n        uint256 _score = 0;\r\n        bool isDoubleScore = true;\r\n        if(cGame.shotA == _shotA) {\r\n            _score = _score.add(1);\r\n        } else {\r\n            isDoubleScore = false;\r\n        }\r\n        if(cGame.shotB == _shotB) {\r\n            _score = _score.add(1);\r\n        } else {\r\n            isDoubleScore = false;\r\n        }\r\n        if(cGame.odds == _odds) {\r\n            _score = _score.add(1);\r\n        } else {\r\n            isDoubleScore = false;\r\n        }\r\n\r\n        /// total goal count's\r\n        if((cGame.goalA + cGame.goalB) == (_goalA + _goalB)) {\r\n            _score = _score.add(2);\r\n        } else {\r\n            isDoubleScore = false;\r\n        }\r\n\r\n        /// exact match score\r\n        if(cGame.goalA == _goalA && cGame.goalB == _goalB) {\r\n            _score = _score.add(3);\r\n        } else {\r\n            isDoubleScore = false;\r\n        }\r\n\r\n        if( ((cGame.goalA > cGame.goalB) && (_goalA > _goalB)) ||\r\n            ((cGame.goalA < cGame.goalB) && (_goalA < _goalB)) ||\r\n            ((cGame.goalA == cGame.goalB) && (_goalA == _goalB))) {\r\n            _score = _score.add(1);\r\n        } else {\r\n            isDoubleScore = false;\r\n        }\r\n\r\n        /// double if all win\r\n        if(isDoubleScore) {\r\n            _score = _score.mul(2);\r\n        }\r\n        return _score;\r\n    }\r\n\r\n    /// admin logic\r\n    ///@dev set new base Price for create token\r\n    function setBasePrice(uint256 _val) external onlyAdmin {\r\n        require(_val > 0);\r\n        basePrice = _val;\r\n    }\r\n\r\n    ///@dev change fee for clone token\r\n    function setGameCloneFee(uint256 _val) external onlyAdmin {\r\n        require(_val <= 10000);\r\n        gameCloneFee = _val;\r\n    }\r\n\r\n    ///@dev change fee for clone token\r\n    function setPrizeFundFactor(uint256 _val) external onlyAdmin {\r\n        require(_val <= 10000);\r\n        prizeFundFactor = _val;\r\n    }\r\n\r\n    ///@dev change fee for clone token\r\n    function setPriceFactor(uint256 _val) external onlyAdmin {\r\n        priceFactor = _val;\r\n    }\r\n\r\n    ///@dev game info edit\r\n    function gameEdit(uint256 _gameId, uint64 gameDate,\r\n        Teams teamA, Teams teamB)\r\n    external onlyAdmin {\r\n        games[_gameId].gameDate = gameDate;\r\n        games[_gameId].teamA = teamA;\r\n        games[_gameId].teamB = teamB;\r\n\r\n        emit GameChanged(_gameId, games[_gameId].gameDate, games[_gameId].teamA, games[_gameId].teamB,\r\n            0, 0, true, 0, 0);\r\n    }\r\n\r\n    function gameResult(uint256 _gameId, uint256 goalA, uint256 goalB, bool odds, uint256 shotA, uint256 shotB)\r\n    external onlyAdmin {\r\n        games[_gameId].goalA = goalA;\r\n        games[_gameId].goalB = goalB;\r\n        games[_gameId].odds = odds;\r\n        games[_gameId].shotA = shotA;\r\n        games[_gameId].shotB = shotB;\r\n\r\n        emit GameChanged(_gameId, games[_gameId].gameDate, games[_gameId].teamA, games[_gameId].teamB,\r\n            goalA, goalB, odds, shotA, shotB);\r\n    }\r\n\r\n    function toForecastData(uint8 _goalA, uint8 _goalB, bool _odds, uint8 _shotA, uint8 _shotB)\r\n    pure internal returns (uint) {\r\n        uint forecastData;\r\n        forecastData = forecastData << 8 | _goalA;\r\n        forecastData = forecastData << 8 | _goalB;\r\n        uint8 odds8 = _odds ? 1 : 0;\r\n        forecastData = forecastData << 8 | odds8;\r\n        forecastData = forecastData << 8 | _shotA;\r\n        forecastData = forecastData << 8 | _shotB;\r\n\r\n        return forecastData;\r\n    }\r\n}\r\n\r\n\r\ncontract HWCIntegration is BaseGameLogic {\r\n\r\n    event NewHWCRegister(address owner, string aD, string aW);\r\n\r\n    constructor(string _name, string _symbol) BaseGameLogic(_name, _symbol) public {}\r\n\r\n    struct HWCInfo {\r\n        string aDeposit;\r\n        string aWithdraw;\r\n        uint deposit;\r\n        uint index1;        // index + 1\r\n    }\r\n\r\n    uint public cHWCtoEth = 0;\r\n    uint256 public prizeFundHWC = 0;\r\n\r\n    // address => hwc address\r\n    mapping (address => HWCInfo) hwcAddress;\r\n    address[] hwcAddressList;\r\n\r\n    function _addToFundHWC(uint256 _val) internal whenNotPaused {\r\n        prizeFundHWC = prizeFundHWC.add(_val.mul(prizeFundFactor).div(10000));\r\n    }\r\n\r\n    function registerHWCDep(string _a) public {\r\n        require(bytes(_a).length == 34);\r\n        hwcAddress[msg.sender].aDeposit = _a;\r\n\r\n        if(hwcAddress[msg.sender].index1 == 0){\r\n            hwcAddress[msg.sender].index1 = hwcAddressList.push(msg.sender);\r\n        }\r\n\r\n        emit NewHWCRegister(msg.sender, _a, '');\r\n    }\r\n\r\n    function registerHWCWit(string _a) public {\r\n        require(bytes(_a).length == 34);\r\n        hwcAddress[msg.sender].aWithdraw = _a;\r\n\r\n        if(hwcAddress[msg.sender].index1 == 0){\r\n            hwcAddress[msg.sender].index1 = hwcAddressList.push(msg.sender);\r\n        }\r\n\r\n        emit NewHWCRegister(msg.sender, '', _a);\r\n    }\r\n\r\n    function getHWCAddressCount() public view returns (uint){\r\n        return hwcAddressList.length;\r\n    }\r\n\r\n    function getHWCAddressByIndex(uint _index) public view returns (string aDeposit, string aWithdraw, uint d) {\r\n        require(_index < hwcAddressList.length);\r\n        return getHWCAddress(hwcAddressList[_index]);\r\n    }\r\n\r\n    function getHWCAddress(address _val) public view returns (string aDeposit, string aWithdraw, uint d) {\r\n        aDeposit = hwcAddress[_val].aDeposit;\r\n        aWithdraw = hwcAddress[_val].aWithdraw;\r\n        d = hwcAddress[_val].deposit;\r\n    }\r\n\r\n    function setHWCDeposit(address _user, uint _val) external onlyAdmin {\r\n        hwcAddress[_user].deposit = _val;\r\n    }\r\n\r\n    function createTokenByHWC(address _userTo, uint256 _parentId) external onlyAdmin whenNotPaused returns (uint) {\r\n        //convert eth to hwc\r\n        uint256 tokenPrice = basePrice.div(1e10).mul(cHWCtoEth);\r\n        if(_parentId > 0) {\r\n            tokenPrice = calculateTokenPrice(_parentId);\r\n            tokenPrice = tokenPrice.div(1e10).mul(cHWCtoEth);\r\n            //uint256 gameFee = _calculateGameFee(tokenPrice);\r\n            uint gameFee = tokenPrice.mul(gameCloneFee).div(10000);\r\n            _addToFundHWC(gameFee);\r\n\r\n            uint256 ownerProceed = tokenPrice.sub(gameFee);\r\n            address tokenOwnerAddress = tokenOwner[_parentId];\r\n\r\n            hwcAddress[tokenOwnerAddress].deposit = hwcAddress[tokenOwnerAddress].deposit + ownerProceed;\r\n        } else {\r\n            _addToFundHWC(tokenPrice);\r\n        }\r\n\r\n        return _createToken(_parentId, _userTo);\r\n    }\r\n\r\n    function setCourse(uint _val) external onlyAdmin {\r\n        cHWCtoEth = _val;\r\n    }\r\n}\r\n\r\n\r\ncontract SolutionGame is HWCIntegration {\r\n\r\n    ///@dev winner token list\r\n    uint256 countWinnerPlace;\r\n    //place -> %%% ( 100% - 10000)\r\n    mapping (uint256 => uint256) internal prizeDistribution;\r\n    //place -> prize\r\n    mapping (uint256 => uint256) internal prizesByPlace;\r\n    mapping (uint256 => uint256) internal scoreByPlace;\r\n    //token -> prize\r\n    mapping (uint => uint) winnerMap;\r\n    uint[] winnerList;\r\n\r\n    mapping (uint256 => uint256) internal prizesByPlaceHWC;\r\n\r\n    bool isWinnerTime = false;\r\n\r\n    modifier whenWinnerTime() {\r\n        require(isWinnerTime);\r\n        _;\r\n    }\r\n\r\n    constructor(string _name, string _symbol) HWCIntegration(_name, _symbol) public {\r\n        countWinnerPlace = 0;      //top 10!\r\n    }\r\n\r\n    /// @notice No tipping!\r\n    /// @dev Reject all Ether from being sent here, unless it's from one of the\r\n    ///  two auction contracts. (Hopefully, we can prevent user accidents.)\r\n    function() external payable {\r\n        _addToFund(msg.value, true);\r\n    }\r\n\r\n    function setWinnerTimeStatus(bool _status) external onlyOwner {\r\n        isWinnerTime = _status;\r\n    }\r\n\r\n    // @dev withdraw balance without prizeFund\r\n    function withdrawBalance() external onlyOwner {\r\n        owner.transfer(address(this).balance.sub(prizeFund));\r\n    }\r\n\r\n    /// @dev set count winner place / top1/top5/top10 etc\r\n    function setCountWinnerPlace(uint256 _val) external onlyOwner {\r\n        countWinnerPlace = _val;\r\n    }\r\n\r\n    /// @dev set the distribution of the prize by place\r\n    function setWinnerPlaceDistribution(uint256 place, uint256 _val) external onlyOwner {\r\n        require(place <= countWinnerPlace);\r\n        require(_val <= 10000);\r\n\r\n        uint256 testVal = 0;\r\n        uint256 index;\r\n        for (index = 1; index <= countWinnerPlace; index ++) {\r\n            if(index != place) {\r\n                testVal = testVal + prizeDistribution[index];\r\n            }\r\n        }\r\n\r\n        testVal = testVal + _val;\r\n        require(testVal <= 10000);\r\n        prizeDistribution[place] = _val;\r\n    }\r\n\r\n    ///@dev method for manual add/edit winner list and winner count\r\n    /// only after final\r\n    function setCountWinnerByPlace(uint256 place, uint256 _winnerCount, uint256 _winnerScore) public onlyOwner whenPaused {\r\n        require(_winnerCount > 0);\r\n        require(place <= countWinnerPlace);\r\n        prizesByPlace[place] = prizeFund.mul(prizeDistribution[place]).div(10000).div(_winnerCount);\r\n        prizesByPlaceHWC[place] = prizeFundHWC.mul(prizeDistribution[place]).div(10000).div(_winnerCount);\r\n        scoreByPlace[place] = _winnerScore;\r\n    }\r\n\r\n    function checkIsWinner(uint _tokenId) public view whenPaused onlyOwnerOf(_tokenId)\r\n    returns (uint place) {\r\n        place = 0;\r\n        uint score = getScore(_tokenId);\r\n        for(uint index = 1; index <= countWinnerPlace; index ++) {\r\n            if (score == scoreByPlace[index]) {\r\n                // token - winner\r\n                place = index;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getMyPrize() external whenWinnerTime {\r\n        uint[] memory tokenList = tokensOfOwner(msg.sender);\r\n\r\n        for(uint index = 0; index < tokenList.length; index ++) {\r\n            getPrizeByToken(tokenList[index]);\r\n        }\r\n    }\r\n\r\n    function getPrizeByToken(uint _tokenId) public whenWinnerTime onlyOwnerOf(_tokenId) {\r\n        uint place = checkIsWinner(_tokenId);\r\n        require (place > 0);\r\n\r\n        uint prize = prizesByPlace[place];\r\n        if(prize > 0) {\r\n            if(winnerMap[_tokenId] == 0) {\r\n                winnerMap[_tokenId] = prize;\r\n                winnerList.push(_tokenId);\r\n\r\n                address _owner = tokenOwner[_tokenId];\r\n                if(_owner != address(0)){\r\n                    //for hwc integration\r\n                    uint hwcPrize = prizesByPlaceHWC[place];\r\n                    hwcAddress[_owner].deposit = hwcAddress[_owner].deposit + hwcPrize;\r\n\r\n                    _owner.transfer(prize);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getWinnerList() external view onlyAdmin returns (uint[]) {\r\n        return winnerList;\r\n    }\r\n\r\n    function getWinnerInfo(uint _tokenId) external view onlyAdmin returns (uint){\r\n        return winnerMap[_tokenId];\r\n    }\r\n\r\n    function getResultTable(uint _start, uint _count) external view returns (uint[]) {\r\n        uint[] memory results = new uint[](_count);\r\n        for(uint index = _start; index < tokens.length && index < (_start + _count); index++) {\r\n            results[(index - _start)] = getScore(index);\r\n        }\r\n        return results;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"calculateTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setCourse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"place\",\"type\":\"uint256\"},{\"name\":\"_winnerCount\",\"type\":\"uint256\"},{\"name\":\"_winnerScore\",\"type\":\"uint256\"}],\"name\":\"setCountWinnerByPlace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"isReleased\",\"type\":\"bool\"}],\"name\":\"getForecastCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"calculateScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"place\",\"type\":\"uint256\"},{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setWinnerPlaceDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cHWCtoEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userTo\",\"type\":\"address\"},{\"name\":\"_parentId\",\"type\":\"uint256\"}],\"name\":\"createTokenByHWC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"}],\"name\":\"registerHWCDep\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHWCAddressCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getResultTable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"gameDate\",\"type\":\"uint64\"},{\"name\":\"teamA\",\"type\":\"uint8\"},{\"name\":\"teamB\",\"type\":\"uint8\"}],\"name\":\"gameEdit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setWinnerTimeStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setPrizeFundFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"_gameForecast\",\"type\":\"uint256[]\"}],\"name\":\"getScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"forecastOfToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_fId\",\"type\":\"uint256\"}],\"name\":\"forecastInfo\",\"outputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"f\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setCountWinnerPlace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getWinnerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeFundHWC\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinnerList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_goalA\",\"type\":\"uint8\"},{\"name\":\"_goalB\",\"type\":\"uint8\"},{\"name\":\"_odds\",\"type\":\"bool\"},{\"name\":\"_shotA\",\"type\":\"uint8\"},{\"name\":\"_shotB\",\"type\":\"uint8\"}],\"name\":\"createForecast\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_forecastId\",\"type\":\"uint256\"}],\"name\":\"getForecastScore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getHWCAddressByIndex\",\"outputs\":[{\"name\":\"aDeposit\",\"type\":\"string\"},{\"name\":\"aWithdraw\",\"type\":\"string\"},{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"gameInfo\",\"outputs\":[{\"name\":\"gameDate\",\"type\":\"uint64\"},{\"name\":\"teamA\",\"type\":\"uint8\"},{\"name\":\"teamB\",\"type\":\"uint8\"},{\"name\":\"goalA\",\"type\":\"uint256\"},{\"name\":\"gaolB\",\"type\":\"uint256\"},{\"name\":\"odds\",\"type\":\"bool\"},{\"name\":\"shotA\",\"type\":\"uint256\"},{\"name\":\"shotB\",\"type\":\"uint256\"},{\"name\":\"forecastCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"}],\"name\":\"registerHWCWit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cloneAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameCloneFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenInfo\",\"outputs\":[{\"name\":\"createBlockNumber\",\"type\":\"uint256\"},{\"name\":\"parentId\",\"type\":\"uint256\"},{\"name\":\"forecast\",\"type\":\"uint256\"},{\"name\":\"score\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setHWCDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setBasePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPrizeByToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_val\",\"type\":\"address\"}],\"name\":\"getHWCAddress\",\"outputs\":[{\"name\":\"aDeposit\",\"type\":\"string\"},{\"name\":\"aWithdraw\",\"type\":\"string\"},{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"goalA\",\"type\":\"uint256\"},{\"name\":\"goalB\",\"type\":\"uint256\"},{\"name\":\"odds\",\"type\":\"bool\"},{\"name\":\"shotA\",\"type\":\"uint256\"},{\"name\":\"shotB\",\"type\":\"uint256\"}],\"name\":\"gameResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setGameCloneFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"checkIsWinner\",\"outputs\":[{\"name\":\"place\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeFundFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setPriceFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizeFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"aD\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"aW\",\"type\":\"string\"}],\"name\":\"NewHWCRegister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"parentTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"NewAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"forecastId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_forecastData\",\"type\":\"uint256\"}],\"name\":\"NewForecast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gameDate\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"teamA\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"teamB\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"goalA\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"goalB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"odds\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"shotA\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"shotB\",\"type\":\"uint256\"}],\"name\":\"GameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"SolutionGame","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b23574347616d653230313800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035743470000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://7575bc51e55a1da6c0280801093ce623b080b77f600dce2de949fb93f0a73b2b"}]}