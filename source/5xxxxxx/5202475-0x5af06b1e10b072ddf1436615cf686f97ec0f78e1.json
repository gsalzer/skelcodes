{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n\r\ncontract UnilotPrizeCalculator {\r\n    //Calculation constants\r\n    uint64  constant accuracy                   = 1000000000000000000;\r\n    uint8  constant MAX_X_FOR_Y                = 195;  // 19.5\r\n\r\n    uint8  constant minPrizeCoeficent          = 1;\r\n    uint8  constant percentOfWinners           = 5;    // 5%\r\n    uint8  constant percentOfFixedPrizeWinners = 20;   // 20%\r\n\r\n    uint8  constant gameCommision              = 0;   // 0%\r\n    uint8  constant bonusGameCommision         = 0;   // 0%\r\n    uint8  constant tokenHolerGameCommision    = 0;    // 0%\r\n    // End Calculation constants\r\n\r\n    event Debug(uint);\r\n\r\n    function getPrizeAmount(uint totalAmount)\r\n        public\r\n        pure\r\n        returns (uint result)\r\n    {\r\n        uint totalCommision = gameCommision\r\n                            + bonusGameCommision\r\n                            + tokenHolerGameCommision;\r\n\r\n        //Calculation is odd on purpose.  It is a sort of ceiling effect to\r\n        // maximize amount of prize\r\n        result = ( totalAmount - ( ( totalAmount * totalCommision) / 100) );\r\n\r\n        return result;\r\n    }\r\n\r\n    function getNumWinners(uint numPlayers)\r\n        public\r\n        pure\r\n        returns (uint16 numWinners, uint16 numFixedAmountWinners)\r\n    {\r\n        // Calculation is odd on purpose. It is a sort of ceiling effect to\r\n        // maximize number of winners\r\n        uint16 totaNumlWinners = uint16( numPlayers - ( (numPlayers * ( 100 - percentOfWinners ) ) / 100 ) );\r\n\r\n\r\n        numFixedAmountWinners = uint16( (totaNumlWinners * percentOfFixedPrizeWinners) / 100 );\r\n        numWinners = uint16( totaNumlWinners - numFixedAmountWinners );\r\n\r\n        return (numWinners, numFixedAmountWinners);\r\n    }\r\n\r\n    function calcaultePrizes(uint bet, uint numPlayers)\r\n        public\r\n        pure\r\n        returns (uint[50] memory prizes)\r\n    {\r\n        var (numWinners, numFixedAmountWinners) = getNumWinners(numPlayers);\r\n\r\n        require( uint(numWinners + numFixedAmountWinners) <= prizes.length );\r\n\r\n        uint[] memory y = new uint[]((numWinners - 1));\r\n        uint z = 0; // Sum of all Y values\r\n\r\n        if ( numWinners == 1 ) {\r\n            prizes[0] = getPrizeAmount(uint(bet*numPlayers));\r\n\r\n            return prizes;\r\n        } else if ( numWinners < 1 ) {\r\n            return prizes;\r\n        }\r\n\r\n        for (uint i = 0; i < y.length; i++) {\r\n            y[i] = formula( (calculateStep(numWinners) * i) );\r\n            z += y[i];\r\n        }\r\n\r\n        bool stop = false;\r\n\r\n        for (i = 0; i < 10; i++) {\r\n            uint[5] memory chunk = distributePrizeCalculation(\r\n                i, z, y, numPlayers, bet);\r\n\r\n            for ( uint j = 0; j < chunk.length; j++ ) {\r\n                if ( ( (i * chunk.length) + j ) >= ( numWinners + numFixedAmountWinners ) ) {\r\n                    stop = true;\r\n                    break;\r\n                }\r\n\r\n                prizes[ (i * chunk.length) + j ] = chunk[j];\r\n            }\r\n\r\n            if ( stop ) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return prizes;\r\n    }\r\n\r\n    function distributePrizeCalculation (uint chunkNumber, uint z, uint[] memory y, uint totalNumPlayers, uint bet)\r\n        private\r\n        pure\r\n        returns (uint[5] memory prizes)\r\n    {\r\n        var(numWinners, numFixedAmountWinners) = getNumWinners(totalNumPlayers);\r\n        uint prizeAmountForDeligation = getPrizeAmount( (totalNumPlayers * bet) );\r\n        prizeAmountForDeligation -= uint( ( bet * minPrizeCoeficent ) * uint( numWinners + numFixedAmountWinners ) );\r\n\r\n        uint mainWinnerBaseAmount = ( (prizeAmountForDeligation * accuracy) / ( ( ( z * accuracy ) / ( 2 * y[0] ) ) + ( 1 * accuracy ) ) );\r\n        uint undeligatedAmount    = prizeAmountForDeligation;\r\n\r\n        uint startPoint = chunkNumber * prizes.length;\r\n\r\n        for ( uint i = 0; i < prizes.length; i++ ) {\r\n            if ( i >= uint(numWinners + numFixedAmountWinners) ) {\r\n                break;\r\n            }\r\n            prizes[ i ] = (bet * minPrizeCoeficent);\r\n            uint extraPrize = 0;\r\n\r\n            if ( i == ( numWinners - 1 ) ) {\r\n                extraPrize = undeligatedAmount;\r\n            } else if ( i == 0 && chunkNumber == 0 ) {\r\n                extraPrize = mainWinnerBaseAmount;\r\n            } else if ( ( startPoint + i ) < numWinners ) {\r\n                extraPrize = ( ( y[ ( startPoint + i ) - 1 ] * (prizeAmountForDeligation - mainWinnerBaseAmount) ) / z);\r\n            }\r\n\r\n            prizes[ i ] += extraPrize;\r\n            undeligatedAmount -= extraPrize;\r\n        }\r\n\r\n        return prizes;\r\n    }\r\n\r\n    function formula(uint x)\r\n        public\r\n        pure\r\n        returns (uint y)\r\n    {\r\n        y = ( (1 * accuracy**2) / (x + (5*accuracy/10))) - ((5 * accuracy) / 100);\r\n\r\n        return y;\r\n    }\r\n\r\n    function calculateStep(uint numWinners)\r\n        public\r\n        pure\r\n        returns(uint step)\r\n    {\r\n        step = ( MAX_X_FOR_Y * accuracy / 10 ) / numWinners;\r\n\r\n        return step;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"formula\",\"outputs\":[{\"name\":\"y\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"numWinners\",\"type\":\"uint256\"}],\"name\":\"calculateStep\",\"outputs\":[{\"name\":\"step\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bet\",\"type\":\"uint256\"},{\"name\":\"numPlayers\",\"type\":\"uint256\"}],\"name\":\"calcaultePrizes\",\"outputs\":[{\"name\":\"prizes\",\"type\":\"uint256[50]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"numPlayers\",\"type\":\"uint256\"}],\"name\":\"getNumWinners\",\"outputs\":[{\"name\":\"numWinners\",\"type\":\"uint16\"},{\"name\":\"numFixedAmountWinners\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"getPrizeAmount\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Debug\",\"type\":\"event\"}]","ContractName":"UnilotPrizeCalculator","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0a27c602ea3b71a0cb3d08718a24a877b56ff763417934e60c28174a012a0617"}]}