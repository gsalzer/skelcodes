{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * Manager that stores permitted addresses \r\n */\r\ncontract PermissionManager is Ownable {\r\n    mapping (address => bool) permittedAddresses;\r\n\r\n    function addAddress(address newAddress) public onlyOwner {\r\n        permittedAddresses[newAddress] = true;\r\n    }\r\n\r\n    function removeAddress(address remAddress) public onlyOwner {\r\n        permittedAddresses[remAddress] = false;\r\n    }\r\n\r\n    function isPermitted(address pAddress) public view returns(bool) {\r\n        if (permittedAddresses[pAddress]) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract Registry is Ownable {\r\n\r\n  struct ContributorData {\r\n    bool isActive;\r\n    uint contributionETH;\r\n    uint contributionUSD;\r\n    uint tokensIssued;\r\n    uint quoteUSD;\r\n    uint contributionRNTB;\r\n  }\r\n  mapping(address => ContributorData) public contributorList;\r\n  mapping(uint => address) private contributorIndexes;\r\n\r\n  uint private nextContributorIndex;\r\n\r\n  /* Permission manager contract */\r\n  PermissionManager public permissionManager;\r\n\r\n  bool public completed;\r\n\r\n  modifier onlyPermitted() {\r\n    require(permissionManager.isPermitted(msg.sender));\r\n    _;\r\n  }\r\n\r\n  event ContributionAdded(address _contributor, uint overallEth, uint overallUSD, uint overallToken, uint quote);\r\n  event ContributionEdited(address _contributor, uint overallEth, uint overallUSD,  uint overallToken, uint quote);\r\n  function Registry(address pManager) public {\r\n    permissionManager = PermissionManager(pManager); \r\n    completed = false;\r\n  }\r\n\r\n  function setPermissionManager(address _permadr) public onlyOwner {\r\n    require(_permadr != 0x0);\r\n    permissionManager = PermissionManager(_permadr);\r\n  }\r\n\r\n  function isActiveContributor(address contributor) public view returns(bool) {\r\n    return contributorList[contributor].isActive;\r\n  }\r\n\r\n  function removeContribution(address contributor) public onlyPermitted {\r\n    contributorList[contributor].isActive = false;\r\n  }\r\n\r\n  function setCompleted(bool compl) public onlyPermitted {\r\n    completed = compl;\r\n  }\r\n\r\n  function addContribution(address _contributor, uint _amount, uint _amusd, uint _tokens, uint _quote ) public onlyPermitted {\r\n    \r\n    if (contributorList[_contributor].isActive == false) {\r\n        contributorList[_contributor].isActive = true;\r\n        contributorList[_contributor].contributionETH = _amount;\r\n        contributorList[_contributor].contributionUSD = _amusd;\r\n        contributorList[_contributor].tokensIssued = _tokens;\r\n        contributorList[_contributor].quoteUSD = _quote;\r\n\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex++;\r\n    } else {\r\n      contributorList[_contributor].contributionETH += _amount;\r\n      contributorList[_contributor].contributionUSD += _amusd;\r\n      contributorList[_contributor].tokensIssued += _tokens;\r\n      contributorList[_contributor].quoteUSD = _quote;\r\n    }\r\n    ContributionAdded(_contributor, contributorList[_contributor].contributionETH, contributorList[_contributor].contributionUSD, contributorList[_contributor].tokensIssued, contributorList[_contributor].quoteUSD);\r\n  }\r\n\r\n  function editContribution(address _contributor, uint _amount, uint _amusd, uint _tokens, uint _quote) public onlyPermitted {\r\n    if (contributorList[_contributor].isActive == true) {\r\n        contributorList[_contributor].contributionETH = _amount;\r\n        contributorList[_contributor].contributionUSD = _amusd;\r\n        contributorList[_contributor].tokensIssued = _tokens;\r\n        contributorList[_contributor].quoteUSD = _quote;\r\n    }\r\n     ContributionEdited(_contributor, contributorList[_contributor].contributionETH, contributorList[_contributor].contributionUSD, contributorList[_contributor].tokensIssued, contributorList[_contributor].quoteUSD);\r\n  }\r\n\r\n  function addContributor(address _contributor, uint _amount, uint _amusd, uint _tokens, uint _quote) public onlyPermitted {\r\n    contributorList[_contributor].isActive = true;\r\n    contributorList[_contributor].contributionETH = _amount;\r\n    contributorList[_contributor].contributionUSD = _amusd;\r\n    contributorList[_contributor].tokensIssued = _tokens;\r\n    contributorList[_contributor].quoteUSD = _quote;\r\n    contributorIndexes[nextContributorIndex] = _contributor;\r\n    nextContributorIndex++;\r\n    ContributionAdded(_contributor, contributorList[_contributor].contributionETH, contributorList[_contributor].contributionUSD, contributorList[_contributor].tokensIssued, contributorList[_contributor].quoteUSD);\r\n \r\n  }\r\n\r\n  function getContributionETH(address _contributor) public view returns (uint) {\r\n      return contributorList[_contributor].contributionETH;\r\n  }\r\n\r\n  function getContributionUSD(address _contributor) public view returns (uint) {\r\n      return contributorList[_contributor].contributionUSD;\r\n  }\r\n\r\n  function getContributionRNTB(address _contributor) public view returns (uint) {\r\n      return contributorList[_contributor].contributionRNTB;\r\n  }\r\n\r\n  function getContributionTokens(address _contributor) public view returns (uint) {\r\n      return contributorList[_contributor].tokensIssued;\r\n  }\r\n\r\n  function addRNTBContribution(address _contributor, uint _amount) public onlyPermitted {\r\n    if (contributorList[_contributor].isActive == false) {\r\n        contributorList[_contributor].isActive = true;\r\n        contributorList[_contributor].contributionRNTB = _amount;\r\n        contributorIndexes[nextContributorIndex] = _contributor;\r\n        nextContributorIndex++;\r\n    } else {\r\n      contributorList[_contributor].contributionETH += _amount;\r\n    }\r\n  }\r\n\r\n  function getContributorByIndex(uint index) public view  returns (address) {\r\n      return contributorIndexes[index];\r\n  }\r\n\r\n  function getContributorAmount() public view returns(uint) {\r\n      return nextContributorIndex;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contract that will work with ERC223 tokens.\r\n */\r\n \r\ncontract ERC223ReceivingContract {\r\n\r\n  struct TKN {\r\n    address sender;\r\n    uint value;\r\n    bytes data;\r\n    bytes4 sig;\r\n  }\r\n\r\n  /**\r\n   * @dev Standard ERC223 function that will handle incoming token transfers.\r\n   *\r\n   * @param _from  Token sender address.\r\n   * @param _value Amount of tokens.\r\n   * @param _data  Transaction metadata.\r\n   */\r\n  function tokenFallback(address _from, uint _value, bytes _data) public pure {\r\n    TKN memory tkn;\r\n    tkn.sender = _from;\r\n    tkn.value = _value;\r\n    tkn.data = _data;\r\n    if(_data.length > 0) {\r\n      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\r\n      tkn.sig = bytes4(u);\r\n    }\r\n\r\n    /* tkn variable is analogue of msg variable of Ether transaction\r\n    *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\r\n    *  tkn.value the number of tokens that were sent   (analogue of msg.value)\r\n    *  tkn.data is data of token transaction   (analogue of msg.data)\r\n    *  tkn.sig is 4 bytes signature of function\r\n    *  if data of token transaction is a function execution\r\n    */\r\n  }\r\n\r\n}\r\n\r\ncontract ERC223Interface {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) public view returns (uint);\r\n  function allowedAddressesOf(address who) public view returns (bool);\r\n  function getTotalSupply() public view returns (uint);\r\n\r\n  function transfer(address to, uint value) public returns (bool ok);\r\n  function transfer(address to, uint value, bytes data) public returns (bool ok);\r\n  function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n  event TransferContract(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\n/**\r\n * @title Unity Token is ERC223 token.\r\n * @author Vladimir Kovalchuk\r\n */\r\n\r\ncontract UnityToken is ERC223Interface {\r\n  using SafeMath for uint;\r\n\r\n  string public constant name = \"Unity Token\";\r\n  string public constant symbol = \"UNT\";\r\n  uint8 public constant decimals = 18;\r\n\r\n\r\n  /* The supply is initially 100UNT to the precision of 18 decimals */\r\n  uint public constant INITIAL_SUPPLY = 100000 * (10 ** uint(decimals));\r\n\r\n  mapping(address => uint) balances; // List of user balances.\r\n  mapping(address => bool) allowedAddresses;\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function addAllowed(address newAddress) public onlyOwner {\r\n    allowedAddresses[newAddress] = true;\r\n  }\r\n\r\n  function removeAllowed(address remAddress) public onlyOwner {\r\n    allowedAddresses[remAddress] = false;\r\n  }\r\n\r\n\r\n  address public owner;\r\n\r\n  /* Constructor initializes the owner's balance and the supply  */\r\n  function UnityToken() public {\r\n    owner = msg.sender;\r\n    totalSupply = INITIAL_SUPPLY;\r\n    balances[owner] = INITIAL_SUPPLY;\r\n  }\r\n\r\n  function getTotalSupply() public view returns (uint) {\r\n    return totalSupply;\r\n  }\r\n\r\n  // Function that is called when a user or another contract wants to transfer funds .\r\n  function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {\r\n    if (isContract(_to)) {\r\n      require(allowedAddresses[_to]);\r\n      if (balanceOf(msg.sender) < _value)\r\n        revert();\r\n\r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      balances[_to] = balances[_to].add(_value);\r\n      assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\r\n      TransferContract(msg.sender, _to, _value, _data);\r\n      return true;\r\n    }\r\n    else {\r\n      return transferToAddress(_to, _value, _data);\r\n    }\r\n  }\r\n\r\n\r\n  // Function that is called when a user or another contract wants to transfer funds .\r\n  function transfer(address _to, uint _value, bytes _data) public returns (bool success) {\r\n\r\n    if (isContract(_to)) {\r\n      return transferToContract(_to, _value, _data);\r\n    } else {\r\n      return transferToAddress(_to, _value, _data);\r\n    }\r\n  }\r\n\r\n  // Standard function transfer similar to ERC20 transfer with no _data .\r\n  // Added due to backwards compatibility reasons .\r\n  function transfer(address _to, uint _value) public returns (bool success) {\r\n    //standard function transfer similar to ERC20 transfer with no _data\r\n    //added due to backwards compatibility reasons\r\n    bytes memory empty;\r\n    if (isContract(_to)) {\r\n      return transferToContract(_to, _value, empty);\r\n    }\r\n    else {\r\n      return transferToAddress(_to, _value, empty);\r\n    }\r\n  }\r\n\r\n  //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n  function isContract(address _addr) private view returns (bool is_contract) {\r\n    uint length;\r\n    assembly {\r\n    //retrieve the size of the code on target address, this needs assembly\r\n      length := extcodesize(_addr)\r\n    }\r\n    return (length > 0);\r\n  }\r\n\r\n  //function that is called when transaction target is an address\r\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\r\n    if (balanceOf(msg.sender) < _value)\r\n      revert();\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n  //function that is called when transaction target is a contract\r\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\r\n    require(allowedAddresses[_to]);\r\n    if (balanceOf(msg.sender) < _value)\r\n      revert();\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n    receiver.tokenFallback(msg.sender, _value, _data);\r\n    TransferContract(msg.sender, _to, _value, _data);\r\n    return true;\r\n  }\r\n\r\n\r\n  function balanceOf(address _owner) public view returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function allowedAddressesOf(address _owner) public view returns (bool allowed) {\r\n    return allowedAddresses[_owner];\r\n  }\r\n}\r\n\r\n/**\r\n * @title Hold  contract.\r\n * @author Vladimir Kovalchuk\r\n */\r\ncontract Hold is Ownable {\r\n\r\n    uint8 stages = 5;\r\n    uint8 public percentage;\r\n    uint8 public currentStage;\r\n    uint public initialBalance;\r\n    uint public withdrawed;\r\n    \r\n    address public multisig;\r\n    Registry registry;\r\n\r\n    PermissionManager public permissionManager;\r\n    uint nextContributorToTransferEth;\r\n    address public observer;\r\n    uint dateDeployed;\r\n    mapping(address => bool) private hasWithdrawedEth;\r\n\r\n    event InitialBalanceChanged(uint balance);\r\n    event EthReleased(uint ethreleased);\r\n    event EthRefunded(address contributor, uint ethrefunded);\r\n    event StageChanged(uint8 newStage);\r\n    event EthReturnedToOwner(address owner, uint balance);\r\n\r\n    modifier onlyPermitted() {\r\n        require(permissionManager.isPermitted(msg.sender) || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyObserver() {\r\n        require(msg.sender == observer || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function Hold(address _multisig, uint cap, address pm, address registryAddress, address observerAddr) public {\r\n        percentage = 100 / stages;\r\n        currentStage = 0;\r\n        multisig = _multisig;\r\n        initialBalance = cap;\r\n        dateDeployed = now;\r\n        permissionManager = PermissionManager(pm);\r\n        registry = Registry(registryAddress);\r\n        observer = observerAddr;\r\n    }\r\n\r\n    function setPermissionManager(address _permadr) public onlyOwner {\r\n        require(_permadr != 0x0);\r\n        permissionManager = PermissionManager(_permadr);\r\n    }\r\n\r\n    function setObserver(address observerAddr) public onlyOwner {\r\n        require(observerAddr != 0x0);\r\n        observer = observerAddr;\r\n    }\r\n\r\n    function setInitialBalance(uint inBal) public {\r\n        initialBalance = inBal;\r\n        InitialBalanceChanged(inBal);\r\n    }\r\n\r\n    function releaseAllETH() onlyPermitted public {\r\n        uint balReleased = getBalanceReleased();\r\n        require(balReleased > 0);\r\n        require(this.balance >= balReleased);\r\n        multisig.transfer(balReleased);\r\n        withdrawed += balReleased;\r\n        EthReleased(balReleased);\r\n    }\r\n\r\n    function releaseETH(uint n) onlyPermitted public {\r\n        require(this.balance >= n);\r\n        require(getBalanceReleased() >= n);\r\n        multisig.transfer(n);\r\n        withdrawed += n;\r\n        EthReleased(n);\r\n    } \r\n\r\n    function getBalance() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function changeStageAndReleaseETH() public onlyObserver {\r\n        uint8 newStage = currentStage + 1;\r\n        require(newStage <= stages);\r\n        currentStage = newStage;\r\n        StageChanged(newStage);\r\n        releaseAllETH();\r\n    }\r\n\r\n    function changeStage() public onlyObserver {\r\n        uint8 newStage = currentStage + 1;\r\n        require(newStage <= stages);\r\n        currentStage = newStage;\r\n        StageChanged(newStage);\r\n    }\r\n\r\n    function getBalanceReleased() public view returns (uint) {\r\n        return initialBalance * percentage * currentStage / 100 - withdrawed ;\r\n    }\r\n\r\n    function returnETHByOwner() public onlyOwner {\r\n        require(now > dateDeployed + 183 days);\r\n        uint balance = getBalance();\r\n        owner.transfer(getBalance());\r\n        EthReturnedToOwner(owner, balance);\r\n    }\r\n\r\n    function refund(uint _numberOfReturns) public onlyOwner {\r\n        require(_numberOfReturns > 0);\r\n        address currentParticipantAddress;\r\n\r\n        for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\r\n            currentParticipantAddress = registry.getContributorByIndex(nextContributorToTransferEth);\r\n            if (currentParticipantAddress == 0x0) \r\n                return;\r\n\r\n            if (!hasWithdrawedEth[currentParticipantAddress]) {\r\n                uint EthAmount = registry.getContributionETH(currentParticipantAddress);\r\n                EthAmount -=  EthAmount * (percentage / 100 * currentStage);\r\n\r\n                currentParticipantAddress.transfer(EthAmount);\r\n                EthRefunded(currentParticipantAddress, EthAmount);\r\n                hasWithdrawedEth[currentParticipantAddress] = true;\r\n            }\r\n            nextContributorToTransferEth += 1;\r\n        }\r\n        \r\n    }  \r\n\r\n    function() public payable {\r\n\r\n    }\r\n\r\n  function getWithdrawed(address contrib) public onlyPermitted view returns (bool) {\r\n    return hasWithdrawedEth[contrib];\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"returnETHByOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeStageAndReleaseETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contrib\",\"type\":\"address\"}],\"name\":\"getWithdrawed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseAllETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_permadr\",\"type\":\"address\"}],\"name\":\"setPermissionManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"observerAddr\",\"type\":\"address\"}],\"name\":\"setObserver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalanceReleased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"permissionManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"observer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inBal\",\"type\":\"uint256\"}],\"name\":\"setInitialBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"releaseETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multisig\",\"type\":\"address\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"pm\",\"type\":\"address\"},{\"name\":\"registryAddress\",\"type\":\"address\"},{\"name\":\"observerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"InitialBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ethreleased\",\"type\":\"uint256\"}],\"name\":\"EthReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethrefunded\",\"type\":\"uint256\"}],\"name\":\"EthRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newStage\",\"type\":\"uint8\"}],\"name\":\"StageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"EthReturnedToOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Hold","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000e24abc38f5dac3ca2da4be616a222b45b3858fb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000934a5e149b57d5f8eb5962732a861406926ba45b000000000000000000000000fd98d04b4935ad0e477f3fb41e0f61adc76475300000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://6ad16dc1d634a4d92589db00657b0b1511c4eaf919c0c64223f2dac658bffa8b"}]}