{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this ether.\r\n * @notice Ether can still be send to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n*/\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  function HasNoEther() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    assert(owner.send(this.balance));\r\n  }\r\n}\r\n\r\n// File: contracts/StoreManager.sol\r\n\r\ninterface StoreInterface {\r\n\r\n  function getAppNickname()\r\n  external\r\n  constant returns (bytes32);\r\n\r\n\r\n  function getAppId()\r\n  external\r\n  constant returns (uint);\r\n\r\n\r\n  function getAddressLastUpdate(\r\n    address _address\r\n  )\r\n  external\r\n  constant returns (uint);\r\n\r\n\r\n  function isUpgradable(\r\n    address _address,\r\n    string _uid\r\n  )\r\n  public\r\n  constant returns (bool);\r\n\r\n\r\n  function isUid(\r\n    string _uid\r\n  )\r\n  public\r\n  view\r\n  returns (bool);\r\n\r\n\r\n  function setIdentity(\r\n    address _address,\r\n    string _uid\r\n  )\r\n  external;\r\n\r\n\r\n  function unsetIdentity(\r\n    address _address\r\n  )\r\n  external;\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title StoreManager\r\n * @author Francesco Sullo <francesco@sullo.co>\r\n * @dev Sets and removes tweedentities in the store,\r\n * adding more logic to the simple logic of the store\r\n */\r\n\r\n\r\ncontract StoreManager\r\nis Pausable, HasNoEther\r\n{\r\n\r\n  string public fromVersion = \"1.0.0\";\r\n\r\n  struct Store {\r\n    StoreInterface store;\r\n    address addr;\r\n    bool active;\r\n  }\r\n\r\n  mapping(uint => Store) private __stores;\r\n  uint public totalStores;\r\n\r\n  mapping(uint => bytes32) public appNicknames32;\r\n  mapping(uint => string) public appNicknames;\r\n  mapping(string => uint) private __appIds;\r\n\r\n  address public claimer;\r\n  address public newClaimer;\r\n  mapping(address => bool) public customerService;\r\n  address[] private __customerServiceAddress;\r\n\r\n  uint public upgradable = 0;\r\n  uint public notUpgradableInStore = 1;\r\n  uint public addressNotUpgradable = 2;\r\n\r\n  uint public minimumTimeBeforeUpdate = 1 hours;\r\n\r\n\r\n\r\n  // events\r\n\r\n\r\n  event StoreSet(\r\n    string appNickname,\r\n    address indexed addr\r\n  );\r\n\r\n\r\n  event ClaimerSet(\r\n    address indexed claimer,\r\n    bool isNew\r\n  );\r\n\r\n\r\n  event StoreActive(\r\n    string appNickname,\r\n    address indexed store,\r\n    bool active\r\n  );\r\n\r\n\r\n  event ClaimerSwitch(\r\n    address indexed oldClaimer,\r\n    address indexed newClaimer\r\n  );\r\n\r\n\r\n  event CustomerServiceSet(\r\n    address indexed addr\r\n  );\r\n\r\n\r\n  event IdentityNotUpgradable(\r\n    string appNickname,\r\n    address indexed addr,\r\n    string uid\r\n  );\r\n\r\n\r\n  event MinimumTimeBeforeUpdateChanged(\r\n    uint _newMinimumTime\r\n  );\r\n\r\n  // config\r\n\r\n\r\n  /**\r\n   * @dev Sets a store to be used by the manager\r\n   * @param _appNickname The nickname of the app for which the store's been configured\r\n   * @param _address The address of the store\r\n   */\r\n  function setAStore(\r\n    string _appNickname,\r\n    address _address\r\n  )\r\n  public\r\n  onlyOwner\r\n  {\r\n    require(bytes(_appNickname).length > 0);\r\n    bytes32 _appNickname32 = keccak256(_appNickname);\r\n    require(_address != address(0));\r\n    StoreInterface _store = StoreInterface(_address);\r\n    require(_store.getAppNickname() == _appNickname32);\r\n    uint _appId = _store.getAppId();\r\n    require(appNicknames32[_appId] == 0x0);\r\n    appNicknames32[_appId] = _appNickname32;\r\n    appNicknames[_appId] = _appNickname;\r\n    __appIds[_appNickname] = _appId;\r\n\r\n    __stores[_appId] = Store(\r\n      _store,\r\n      _address,\r\n      true\r\n    );\r\n    totalStores++;\r\n    StoreSet(_appNickname, _address);\r\n    StoreActive(_appNickname, _address, true);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Sets the claimer which will verify the ownership and call to set a tweedentity\r\n   * @param _address Address of the claimer\r\n   */\r\n  function setClaimer(\r\n    address _address\r\n  )\r\n  public\r\n  onlyOwner\r\n  {\r\n    require(_address != address(0));\r\n    claimer = _address;\r\n    ClaimerSet(_address, false);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Sets a new claimer during updates\r\n   * @param _address Address of the new claimer\r\n   */\r\n  function setNewClaimer(\r\n    address _address\r\n  )\r\n  public\r\n  onlyOwner\r\n  {\r\n    require(_address != address(0) && claimer != address(0));\r\n    newClaimer = _address;\r\n    ClaimerSet(_address, true);\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Sets new manager\r\n  */\r\n  function switchClaimerAndRemoveOldOne()\r\n  external\r\n  onlyOwner\r\n  {\r\n    require(newClaimer != address(0));\r\n    ClaimerSwitch(claimer, newClaimer);\r\n    claimer = newClaimer;\r\n    newClaimer = address(0);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Sets a wallet as customer service to perform emergency removal of wrong, abused, squatted tweedentities (due, for example, to hacking of the Twitter account)\r\n   * @param _address The customer service wallet\r\n   * @param _status The status (true is set, false is unset)\r\n   */\r\n  function setCustomerService(\r\n    address _address,\r\n    bool _status\r\n  )\r\n  public\r\n  onlyOwner\r\n  {\r\n    require(_address != address(0));\r\n    customerService[_address] = _status;\r\n    bool found;\r\n    for (uint i = 0; i < __customerServiceAddress.length; i++) {\r\n      if (__customerServiceAddress[i] == _address) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n    if (!found) {\r\n      __customerServiceAddress.push(_address);\r\n    }\r\n    CustomerServiceSet(_address);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev Unable/disable a store\r\n   * @param _appNickname The store to be enabled/disabled\r\n   * @param _active A bool to unable (true) or disable (false)\r\n   */\r\n  function activateStore(\r\n    string _appNickname,\r\n    bool _active\r\n  )\r\n  public\r\n  onlyOwner\r\n  {\r\n    uint _appId = __appIds[_appNickname];\r\n    require(__stores[_appId].active != _active);\r\n    __stores[_appId] = Store(\r\n      __stores[_appId].store,\r\n      __stores[_appId].addr,\r\n      _active\r\n    );\r\n    StoreActive(_appNickname, __stores[_appId].addr, _active);\r\n  }\r\n\r\n\r\n\r\n  //modifiers\r\n\r\n\r\n  modifier onlyClaimer() {\r\n    require(msg.sender == claimer || (newClaimer != address(0) && msg.sender == newClaimer));\r\n    _;\r\n  }\r\n\r\n\r\n  modifier onlyCustomerService() {\r\n    require(msg.sender == owner || customerService[msg.sender] == true);\r\n    _;\r\n  }\r\n\r\n\r\n  modifier whenStoreSet(\r\n    uint _appId\r\n  ) {\r\n    require(appNicknames32[_appId] != 0x0);\r\n    _;\r\n  }\r\n\r\n\r\n\r\n  // internal getters\r\n\r\n\r\n  function __getStore(\r\n    uint _appId\r\n  )\r\n  internal\r\n  constant returns (StoreInterface)\r\n  {\r\n    return __stores[_appId].store;\r\n  }\r\n\r\n\r\n\r\n  // helpers\r\n\r\n\r\n  function isAddressUpgradable(\r\n    StoreInterface _store,\r\n    address _address\r\n  )\r\n  internal\r\n  constant returns (bool)\r\n  {\r\n    uint lastUpdate = _store.getAddressLastUpdate(_address);\r\n    return lastUpdate == 0 || now >= lastUpdate + minimumTimeBeforeUpdate;\r\n  }\r\n\r\n\r\n  function isUpgradable(\r\n    StoreInterface _store,\r\n    address _address,\r\n    string _uid\r\n  )\r\n  internal\r\n  constant returns (bool)\r\n  {\r\n    if (!_store.isUpgradable(_address, _uid) || !isAddressUpgradable(_store, _address)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n  // getters\r\n\r\n\r\n  /**\r\n   * @dev Gets the app-id associated to a nickname\r\n   * @param _appNickname The nickname of a configured app\r\n   */\r\n  function getAppId(\r\n    string _appNickname\r\n  )\r\n  external\r\n  constant returns (uint) {\r\n    return __appIds[_appNickname];\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows other contracts to check if a store is set\r\n   * @param _appNickname The nickname of a configured app\r\n   */\r\n  function isStoreSet(\r\n    string _appNickname\r\n  )\r\n  public\r\n  constant returns (bool){\r\n    return __appIds[_appNickname] != 0;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows other contracts to check if a store is active\r\n   * @param _appId The id of a configured app\r\n   */\r\n  function isStoreActive(\r\n    uint _appId\r\n  )\r\n  public\r\n  constant returns (bool){\r\n    return __stores[_appId].active;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Return a numeric code about the upgradability of a couple wallet-uid in a certain app\r\n   * @param _appId The id of the app\r\n   * @param _address The address of the wallet\r\n   * @param _uid The user-id\r\n   */\r\n  function getUpgradability(\r\n    uint _appId,\r\n    address _address,\r\n    string _uid\r\n  )\r\n  external\r\n  constant returns (uint)\r\n  {\r\n    StoreInterface _store = __getStore(_appId);\r\n    if (!_store.isUpgradable(_address, _uid)) {\r\n      return notUpgradableInStore;\r\n    } else if (!isAddressUpgradable(_store, _address)) {\r\n      return addressNotUpgradable;\r\n    } else {\r\n      return upgradable;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Returns the address of a store\r\n   * @param _appNickname The app nickname\r\n   */\r\n  function getStoreAddress(\r\n    string _appNickname\r\n  )\r\n  external\r\n  constant returns (address) {\r\n    return __stores[__appIds[_appNickname]].addr;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Returns the address of a store\r\n   * @param _appId The app id\r\n   */\r\n  function getStoreAddressById(\r\n    uint _appId\r\n  )\r\n  external\r\n  constant returns (address) {\r\n    return __stores[_appId].addr;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Returns the address of any customerService account\r\n   */\r\n  function getCustomerServiceAddress()\r\n  external\r\n  constant returns (address[]) {\r\n    return __customerServiceAddress;\r\n  }\r\n\r\n\r\n\r\n  // primary methods\r\n\r\n\r\n  /**\r\n   * @dev Sets a new identity\r\n   * @param _appId The id of the app\r\n   * @param _address The address of the wallet\r\n   * @param _uid The user-id\r\n   */\r\n  function setIdentity(\r\n    uint _appId,\r\n    address _address,\r\n    string _uid\r\n  )\r\n  external\r\n  onlyClaimer\r\n  whenStoreSet(_appId)\r\n  whenNotPaused\r\n  {\r\n    require(_address != address(0));\r\n\r\n    StoreInterface _store = __getStore(_appId);\r\n    require(_store.isUid(_uid));\r\n\r\n    if (isUpgradable(_store, _address, _uid)) {\r\n      _store.setIdentity(_address, _uid);\r\n    } else {\r\n      IdentityNotUpgradable(appNicknames[_appId], _address, _uid);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Unsets an existent identity\r\n   * @param _appId The id of the app\r\n   * @param _address The address of the wallet\r\n   */\r\n  function unsetIdentity(\r\n    uint _appId,\r\n    address _address\r\n  )\r\n  external\r\n  onlyCustomerService\r\n  whenStoreSet(_appId)\r\n  whenNotPaused\r\n  {\r\n    StoreInterface _store = __getStore(_appId);\r\n    _store.unsetIdentity(_address);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allow the sender to unset its existent identity\r\n   * @param _appId The id of the app\r\n   */\r\n  function unsetMyIdentity(\r\n    uint _appId\r\n  )\r\n  external\r\n  whenStoreSet(_appId)\r\n  whenNotPaused\r\n  {\r\n    StoreInterface _store = __getStore(_appId);\r\n    _store.unsetIdentity(msg.sender);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Update the minimum time before allowing a wallet to update its data\r\n   * @param _newMinimumTime The new minimum time in seconds\r\n   */\r\n  function changeMinimumTimeBeforeUpdate(\r\n    uint _newMinimumTime\r\n  )\r\n  external\r\n  onlyOwner\r\n  {\r\n    minimumTimeBeforeUpdate = _newMinimumTime;\r\n    MinimumTimeBeforeUpdateChanged(_newMinimumTime);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_appNickname\",\"type\":\"string\"}],\"name\":\"isStoreSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"notUpgradableInStore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStores\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_appId\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"unsetIdentity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_appNickname\",\"type\":\"string\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"activateStore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressNotUpgradable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"customerService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumTimeBeforeUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_appNickname\",\"type\":\"string\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAStore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fromVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_appId\",\"type\":\"uint256\"}],\"name\":\"unsetMyIdentity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setNewClaimer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinimumTime\",\"type\":\"uint256\"}],\"name\":\"changeMinimumTimeBeforeUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_appId\",\"type\":\"uint256\"}],\"name\":\"getStoreAddressById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"switchClaimerAndRemoveOldOne\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_appId\",\"type\":\"uint256\"}],\"name\":\"isStoreActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_appNickname\",\"type\":\"string\"}],\"name\":\"getStoreAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setCustomerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_appNickname\",\"type\":\"string\"}],\"name\":\"getAppId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_appId\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_uid\",\"type\":\"string\"}],\"name\":\"setIdentity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"appNicknames32\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCustomerServiceAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setClaimer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newClaimer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_appId\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_uid\",\"type\":\"string\"}],\"name\":\"getUpgradability\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"appNicknames\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"appNickname\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"StoreSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isNew\",\"type\":\"bool\"}],\"name\":\"ClaimerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"appNickname\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"store\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"StoreActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldClaimer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newClaimer\",\"type\":\"address\"}],\"name\":\"ClaimerSwitch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"CustomerServiceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"appNickname\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uid\",\"type\":\"string\"}],\"name\":\"IdentityNotUpgradable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newMinimumTime\",\"type\":\"uint256\"}],\"name\":\"MinimumTimeBeforeUpdateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"StoreManager","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://06300b05699e40800c0f9f489458b862d4d7eb86e4304de59ecaa8481f402088"}]}