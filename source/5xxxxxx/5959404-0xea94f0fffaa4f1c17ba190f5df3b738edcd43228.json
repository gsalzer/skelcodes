{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/interface/IArbitrage.sol\r\n\r\n/*\r\n\r\n  Copyright 2018 Contra Labs Inc.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n \r\n\r\ninterface IArbitrage {\r\n    function executeArbitrage(\r\n      address token,\r\n      uint256 amount,\r\n      address dest,\r\n      bytes data\r\n    )\r\n      external\r\n      returns (bool);\r\n}\r\n\r\n// File: contracts/interface/IBank.sol\r\n\r\n/*\r\n\r\n  Copyright 2018 Contra Labs Inc.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ncontract IBank {\r\n    function totalSupplyOf(address token) public view returns (uint256 balance);\r\n    function borrowFor(address token, address borrower, uint256 amount) public;\r\n    function repay(address token, uint256 amount) external payable;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/FlashLender.sol\r\n\r\n/*\r\n\r\n  Copyright 2018 Contra Labs Inc.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// @title FlashLender: Borrow from the bank and enforce repayment by the end of transaction execution.\r\n// @author Rich McAteer <rich@marble.org>, Max Wolff <max@marble.org>\r\ncontract FlashLender is ReentrancyGuard, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public version = '0.1';\r\n    address public bank;\r\n    uint256 public fee;\r\n    \r\n    /**\r\n    * @dev Verify that the borrowed tokens are returned to the bank plus a fee by the end of transaction execution.\r\n    * @param token Address of the token to for arbitrage. 0x0 for Ether.\r\n    * @param amount Amount borrowed.\r\n    */\r\n    modifier isArbitrage(address token, uint256 amount) {\r\n        uint256 balance = IBank(bank).totalSupplyOf(token);\r\n        uint256 feeAmount = amount.mul(fee).div(10 ** 18); \r\n        _;\r\n        require(IBank(bank).totalSupplyOf(token) >= (balance.add(feeAmount)));\r\n    }\r\n\r\n    constructor(address _bank, uint256 _fee) public {\r\n        bank = _bank;\r\n        fee = _fee;\r\n    }\r\n\r\n    /**\r\n    * @dev Borrow from the bank on behalf of an arbitrage contract and execute the arbitrage contract's callback function.\r\n    * @param token Address of the token to borrow. 0x0 for Ether.\r\n    * @param amount Amount to borrow.\r\n    * @param dest Address of the account to receive arbitrage profits.\r\n    * @param data The data to execute the arbitrage trade.\r\n    */\r\n    function borrow(\r\n        address token,\r\n        uint256 amount,\r\n        address dest,\r\n        bytes data\r\n    )\r\n        external\r\n        nonReentrant\r\n        isArbitrage(token, amount)\r\n        returns (bool)\r\n    {\r\n        // Borrow from the bank and send to the arbitrageur.\r\n        IBank(bank).borrowFor(token, msg.sender, amount);\r\n        // Call the arbitrageur's execute arbitrage method.\r\n        return IArbitrage(msg.sender).executeArbitrage(token, amount, dest, data);\r\n    }\r\n\r\n    /**\r\n    * @dev Allow the owner to set the bank address.\r\n    * @param _bank Address of the bank.\r\n    */\r\n    function setBank(address _bank) external onlyOwner {\r\n        bank = _bank;\r\n    }\r\n\r\n    /**\r\n    * @dev Allow the owner to set the fee.\r\n    * @param _fee Fee to borrow, as a percentage of principal borrowed. 18 decimals of precision (e.g., 10^18 = 100% fee).\r\n    */\r\n    function setFee(uint256 _fee) external onlyOwner {\r\n        fee = _fee;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/example/ExternalCall.sol\r\n\r\n/*\r\n\r\n  Copyright 2018 Contra Labs Inc.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract ExternalCall {\r\n    // Source: https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol\r\n    // call has been separated into its own function in order to take advantage\r\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\r\n        bool result;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\r\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/example/Arbitrage.sol\r\n\r\n/*\r\n\r\n  Copyright 2018 Contra Labs Inc.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// @title Arbitrage: Borrow Ether or ERC20 tokens to execute an arbitrage opportunity.\r\n// @author Rich McAteer <rich@marble.org>, Max Wolff <max@marble.org>\r\ncontract Arbitrage is IArbitrage, ExternalCall {\r\n    using SafeMath for uint256;\r\n\r\n    address public lender;\r\n    address public tradeExecutor;\r\n    address constant public ETH = 0x0;\r\n    uint256 constant public MAX_UINT = 2 ** 256 - 1;\r\n\r\n    modifier onlyLender() {\r\n        require(msg.sender == lender);\r\n        _;\r\n    }\r\n\r\n    constructor(address _lender, address _tradeExecutor) public {\r\n        lender = _lender;\r\n        tradeExecutor = _tradeExecutor; \r\n    }\r\n\r\n    // Receive ETH from bank.\r\n    function () payable public {}\r\n\r\n    /**\r\n    * @dev Borrow from flash lender to execute arbitrage trade. \r\n    * @param token Address of the token to borrow. 0x0 for Ether.\r\n    * @param amount Amount to borrow.\r\n    * @param dest Address of the account to receive arbitrage profits.\r\n    * @param data The data to execute the arbitrage trade.\r\n    */\r\n    function submitTrade(address token, uint256 amount, address dest, bytes data) external {\r\n        FlashLender(lender).borrow(token, amount, dest, data);\r\n    }\r\n\r\n    /**\r\n    * @dev Callback from flash lender. Executes arbitrage trade.\r\n    * @param token Address of the borrowed token. 0x0 for Ether.\r\n    * @param amount Amount borrowed.\r\n    * @param dest Address of the account to receive arbitrage profits.\r\n    * @param data The data to execute the arbitrage trade.\r\n    */\r\n    function executeArbitrage(\r\n        address token,\r\n        uint256 amount,\r\n        address dest,\r\n        bytes data\r\n    )\r\n        external\r\n        onlyLender \r\n        returns (bool)\r\n    {\r\n        uint256 value = 0;\r\n        if (token == ETH) {\r\n            value = amount;\r\n        } else {\r\n            // Send tokens to Trade Executor\r\n            ERC20(token).transfer(tradeExecutor, amount);\r\n        }\r\n\r\n        // Execute the trades.\r\n        external_call(tradeExecutor, value, data.length, data);\r\n\r\n        // Determine the amount to repay.\r\n        uint256 repayAmount = getRepayAmount(amount);\r\n\r\n        address bank = FlashLender(lender).bank();\r\n\r\n        // Repay the bank and collect remaining profits.\r\n        if (token == ETH) {\r\n            IBank(bank).repay.value(repayAmount)(token, repayAmount);\r\n            dest.transfer(address(this).balance);\r\n        } else {\r\n            if (ERC20(token).allowance(this, bank) < repayAmount) {\r\n                ERC20(token).approve(bank, MAX_UINT);\r\n            }\r\n            IBank(bank).repay(token, repayAmount);\r\n            uint256 balance = ERC20(token).balanceOf(this);\r\n            require(ERC20(token).transfer(dest, balance));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** \r\n    * @dev Calculate the amount owed after borrowing.\r\n    * @param amount Amount used to calculate repayment amount.\r\n    */ \r\n    function getRepayAmount(uint256 amount) public view returns (uint256) {\r\n        uint256 fee = FlashLender(lender).fee();\r\n        uint256 feeAmount = amount.mul(fee).div(10 ** 18);\r\n        return amount.add(feeAmount);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getRepayAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeArbitrage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeExecutor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_UINT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"submitTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_lender\",\"type\":\"address\"},{\"name\":\"_tradeExecutor\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Arbitrage","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"5000000","ConstructorArguments":"00000000000000000000000057d586906cb1b995dfce24730906f59d60490ff600000000000000000000000066c16e9524e4143c63fca51a2cbe3cc18944c794","Library":"","SwarmSource":"bzzr://7d50cac878dbd51a3a4f12c10f286266a62dcc9f8876c6fc857a5d61b3f02ff9"}]}