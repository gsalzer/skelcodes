{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() external constant returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) external constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _old, uint256 _new) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    constructor () internal {\r\n    }\r\n}\r\n\r\nlibrary RingList {\r\n\r\n    address constant NULL = 0x0;\r\n    address constant HEAD = 0x0;\r\n    bool constant PREV = false;\r\n    bool constant NEXT = true;\r\n\r\n    struct LinkedList{\r\n        mapping (address => mapping (bool => address)) list;\r\n    }\r\n\r\n    /// @dev returns true if the list exists\r\n    /// @param self stored linked list from contract\r\n    function listExists(LinkedList storage self)\r\n    internal\r\n    view returns (bool)\r\n    {\r\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\r\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns true if the node exists\r\n    /// @param self stored linked list from contract\r\n    /// @param _node a node to search for\r\n    function nodeExists(LinkedList storage self, address _node)\r\n    internal\r\n    view returns (bool)\r\n    {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the number of elements in the list\r\n    /// @param self stored linked list from contract\r\n    function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) {\r\n        bool exists;\r\n        address i;\r\n        (exists,i) = getAdjacent(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            (exists,i) = getAdjacent(self, i, NEXT);\r\n            numElements++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /// @dev Returns the links of a node as a tuple\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to get\r\n    function getNode(LinkedList storage self, address _node)\r\n    internal view returns (bool, address, address)\r\n    {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0x0,0x0);\r\n        } else {\r\n            return (true,self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the link of a node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to step from\r\n    /// @param _direction direction to step in\r\n    function getAdjacent(LinkedList storage self, address _node, bool _direction)\r\n    internal view returns (bool, address)\r\n    {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0x0);\r\n        } else {\r\n            return (true,self.list[_node][_direction]);\r\n        }\r\n    }\r\n\r\n    /// @dev Can be used before `insert` to build an ordered list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node an existing node to search from, e.g. HEAD.\r\n    /// @param _value value to seek\r\n    /// @param _direction direction to seek in\r\n    //  @return next first node beyond '_node' in direction `_direction`\r\n    function getSortedSpot(LinkedList storage self, address _node, address _value, bool _direction)\r\n    internal view returns (address)\r\n    {\r\n        if (sizeOf(self) == 0) { return 0x0; }\r\n        require((_node == 0x0) || nodeExists(self,_node));\r\n        bool exists;\r\n        address next;\r\n        (exists,next) = getAdjacent(self, _node, _direction);\r\n        while  ((next != 0x0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\r\n        return next;\r\n    }\r\n\r\n    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n    /// @param self stored linked list from contract\r\n    /// @param _node first node for linking\r\n    /// @param _link  node to link to in the _direction\r\n    function createLink(LinkedList storage self, address _node, address _link, bool _direction) internal  {\r\n        self.list[_link][!_direction] = _node;\r\n        self.list[_node][_direction] = _link;\r\n    }\r\n\r\n    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node existing node\r\n    /// @param _new  new node to insert\r\n    /// @param _direction direction to insert node in\r\n    function insert(LinkedList storage self, address _node, address _new, bool _direction) internal returns (bool) {\r\n        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\r\n            address c = self.list[_node][_direction];\r\n            createLink(self, _node, _new, _direction);\r\n            createLink(self, _new, c, _direction);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev removes an entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node node to remove from the list\r\n    function remove(LinkedList storage self, address _node) internal returns (address) {\r\n        if ((_node == NULL) || (!nodeExists(self,_node))) { return 0x0; }\r\n        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n        return _node;\r\n    }\r\n\r\n    /// @dev pushes an enrty to the head of the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node new entry to push to the head\r\n    /// @param _direction push to the head (NEXT) or tail (PREV)\r\n    function push(LinkedList storage self, address _node, bool _direction) internal  {\r\n        insert(self, HEAD, _node, _direction);\r\n    }\r\n\r\n    /// @dev pops the first entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _direction pop from the head (NEXT) or the tail (PREV)\r\n    function pop(LinkedList storage self, bool _direction) internal returns (address) {\r\n        bool exists;\r\n        address adj;\r\n\r\n        (exists,adj) = getAdjacent(self, HEAD, _direction);\r\n\r\n        return remove(self, adj);\r\n    }\r\n}\r\n\r\ncontract UmkaToken is ERC20 {\r\n    using SafeMath for uint256;\r\n    using RingList for RingList.LinkedList;\r\n\r\n    address public owner;\r\n\r\n    bool    public              paused         = false;\r\n    bool    public              contractEnable = true;\r\n\r\n    uint256 private             summarySupply;\r\n\r\n    string  public              name = \"\";\r\n    string  public              symbol = \"\";\r\n    uint8   public              decimals = 0;\r\n\r\n    mapping(address => uint256)                      private   accounts;\r\n    mapping(address => string)                       private   umkaAddresses;\r\n    mapping(address => mapping (address => uint256)) private   allowed;\r\n    mapping(address => uint8)                        private   group;\r\n    mapping(bytes32 => uint256)                      private   distribution;\r\n\r\n    RingList.LinkedList                              private   holders;\r\n\r\n    struct groupPolicy {\r\n        uint8 _default;\r\n        uint8 _backend;\r\n        uint8 _admin;\r\n        uint8 _migration;\r\n        uint8 _subowner;\r\n        uint8 _owner;\r\n    }\r\n\r\n    groupPolicy public currentState = groupPolicy(0, 3, 4, 9, 2, 9);\r\n\r\n    event EvGroupChanged(address _address, uint8 _oldgroup, uint8 _newgroup);\r\n    event EvMigration(address _address, uint256 _balance, uint256 _secret);\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    constructor (string _name, string _symbol, uint8 _decimals, uint256 _startTokens) public {\r\n        owner = msg.sender;\r\n\r\n        group[owner] = currentState._owner;\r\n\r\n        accounts[msg.sender]  = _startTokens;\r\n\r\n        holders.push(msg.sender, true);\r\n        summarySupply    = _startTokens;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        emit Transfer(address(0x0), msg.sender, _startTokens);\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    modifier minGroup(int _require) {\r\n        require(group[msg.sender] >= _require);\r\n        _;\r\n    }\r\n\r\n    modifier onlyGroup(int _require) {\r\n        require(group[msg.sender] == _require);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused || group[msg.sender] >= currentState._backend);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function servicePause() minGroup(currentState._admin) whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function serviceUnpause() minGroup(currentState._admin) whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n    function serviceGroupChange(address _address, uint8 _group) minGroup(currentState._admin) external returns(uint8) {\r\n        require(_address != address(0));\r\n\r\n        uint8 old = group[_address];\r\n        if(old <= currentState._admin) {\r\n            group[_address] = _group;\r\n            emit EvGroupChanged(_address, old, _group);\r\n        }\r\n        return group[_address];\r\n    }\r\n\r\n    function serviceTransferOwnership(address newOwner) minGroup(currentState._owner) external {\r\n        require(newOwner != address(0));\r\n\r\n        group[newOwner] = currentState._subowner;\r\n        group[msg.sender] = currentState._subowner;\r\n        emit EvGroupChanged(newOwner, currentState._owner, currentState._subowner);\r\n    }\r\n\r\n    function serviceClaimOwnership() onlyGroup(currentState._subowner) external {\r\n        address temp = owner;\r\n        uint256 value = accounts[owner];\r\n\r\n        accounts[owner] = accounts[owner].sub(value);\r\n        holders.remove(owner);\r\n        accounts[msg.sender] = accounts[msg.sender].add(value);\r\n        holders.push(msg.sender, true);\r\n\r\n        owner = msg.sender;\r\n\r\n        delete group[temp];\r\n        group[msg.sender] = currentState._owner;\r\n\r\n        emit EvGroupChanged(msg.sender, currentState._subowner, currentState._owner);\r\n        emit Transfer(temp, owner, value);\r\n    }\r\n\r\n    function serviceIncreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) {\r\n        require(_who != address(0));\r\n        require(_value > 0);\r\n\r\n        accounts[_who] = accounts[_who].add(_value);\r\n        summarySupply = summarySupply.add(_value);\r\n        holders.push(_who, true);\r\n        emit Transfer(address(0), _who, _value);\r\n        return true;\r\n    }\r\n\r\n    function serviceDecreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) {\r\n        require(_who != address(0));\r\n        require(_value > 0);\r\n        require(accounts[_who] >= _value);\r\n\r\n        accounts[_who] = accounts[_who].sub(_value);\r\n        summarySupply = summarySupply.sub(_value);\r\n        if(accounts[_who] == 0){\r\n            holders.remove(_who);\r\n        }\r\n        emit Transfer(_who, address(0), _value);\r\n        return true;\r\n    }\r\n\r\n    function serviceRedirect(address _from, address _to, uint256 _value) minGroup(currentState._admin) external returns(bool){\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(accounts[_from] >= _value);\r\n        require(_from != _to);\r\n\r\n        accounts[_from] = accounts[_from].sub(_value);\r\n        if(accounts[_from] == 0){\r\n            holders.remove(_from);\r\n        }\r\n        accounts[_to] = accounts[_to].add(_value);\r\n        holders.push(_to, true);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function serviceTokensBurn(address _address) external minGroup(currentState._admin) returns(uint256 balance) {\r\n        require(_address != address(0));\r\n        require(accounts[_address] > 0);\r\n\r\n        uint256 sum = accounts[_address];\r\n        accounts[_address] = 0;\r\n        summarySupply = summarySupply.sub(sum);\r\n        holders.remove(_address);\r\n        emit Transfer(_address, address(0), sum);\r\n        return accounts[_address];\r\n    }\r\n\r\n    function serviceTrasferToDist(bytes32 _to, uint256 _value) external minGroup(currentState._admin) {\r\n        require(_value > 0);\r\n        require(accounts[owner] >= _value);\r\n\r\n        distribution[_to] = distribution[_to].add(_value);\r\n        accounts[owner] = accounts[owner].sub(_value);\r\n        emit Transfer(owner, address(0), _value);\r\n    }\r\n\r\n    function serviceTrasferFromDist(bytes32 _from, address _to, uint256 _value) external minGroup(currentState._backend) {\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(distribution[_from] >= _value);\r\n\r\n        accounts[_to] = accounts[_to].add(_value);\r\n        holders.push(_to, true);\r\n        distribution[_from] = distribution[_from].sub(_value);\r\n        emit Transfer(address(0), _to, _value);\r\n    }\r\n\r\n    function getGroup(address _check) external constant returns(uint8 _group) {\r\n        return group[_check];\r\n    }\r\n\r\n    function getBalanceOfDist(bytes32 _of) external constant returns(uint256){\r\n        return distribution[_of];\r\n    }\r\n\r\n    function getHoldersLength() external constant returns(uint256){\r\n        return holders.sizeOf();\r\n    }\r\n\r\n    function getHolderLink(address _holder) external constant returns(bool, address, address){\r\n        return holders.getNode(_holder);\r\n    }\r\n\r\n    function getUmkaAddress(address _who) external constant returns(string umkaAddress){\r\n        return umkaAddresses[_who];\r\n    }\r\n\r\n    function setUmkaAddress(string _umka) minGroup(currentState._default) whenNotPaused external{\r\n        umkaAddresses[msg.sender] = _umka;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\r\n        require(_to != address(0));\r\n        require (accounts[msg.sender] >= _value);\r\n\r\n        accounts[msg.sender] = accounts[msg.sender].sub(_value);\r\n        if(accounts[msg.sender] == 0){\r\n            holders.remove(msg.sender);\r\n        }\r\n        accounts[_to] = accounts[_to].add(_value);\r\n        holders.push(_to, true);\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_from != address(0));\r\n        require(_value <= accounts[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        accounts[_from] = accounts[_from].sub(_value);\r\n        if(accounts[_from] == 0){\r\n            holders.remove(_from);\r\n        }\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        accounts[_to] = accounts[_to].add(_value);\r\n        holders.push(_to, true);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _old, uint256 _new) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\r\n        require (_old == allowed[msg.sender][_spender]);\r\n        require(_spender != address(0));\r\n\r\n        allowed[msg.sender][_spender] = _new;\r\n        emit Approval(msg.sender, _spender, _new);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) external constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function balanceOf(address _owner) external constant returns (uint256 balance) {\r\n        if (_owner == address(0))\r\n            return accounts[msg.sender];\r\n        return accounts[_owner];\r\n    }\r\n\r\n    function totalSupply() external constant returns (uint256 _totalSupply) {\r\n        _totalSupply = summarySupply;\r\n    }\r\n\r\n    function destroy() minGroup(currentState._owner) external {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    function settingsSwitchState() external minGroup(currentState._owner) returns (bool state) {\r\n\r\n        if(contractEnable) {\r\n            currentState._default = 9;\r\n            currentState._migration = 0;\r\n            contractEnable = false;\r\n        } else {\r\n            currentState._default = 0;\r\n            currentState._migration = 9;\r\n            contractEnable = true;\r\n        }\r\n\r\n        return contractEnable;\r\n    }\r\n\r\n    function userMigration(uint256 _secrect) external minGroup(currentState._migration) returns (bool successful) {\r\n        uint256 balance = accounts[msg.sender];\r\n\r\n        require (balance > 0);\r\n\r\n        accounts[msg.sender] = accounts[msg.sender].sub(balance);\r\n        holders.remove(msg.sender);\r\n        accounts[owner] = accounts[owner].add(balance);\r\n        holders.push(owner, true);\r\n        emit EvMigration(msg.sender, balance, _secrect);\r\n        emit Transfer(msg.sender, owner, balance);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"serviceDecreaseBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"_default\",\"type\":\"uint8\"},{\"name\":\"_backend\",\"type\":\"uint8\"},{\"name\":\"_admin\",\"type\":\"uint8\"},{\"name\":\"_migration\",\"type\":\"uint8\"},{\"name\":\"_subowner\",\"type\":\"uint8\"},{\"name\":\"_owner\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secrect\",\"type\":\"uint256\"}],\"name\":\"userMigration\",\"outputs\":[{\"name\":\"successful\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"bytes32\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"serviceTrasferFromDist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"settingsSwitchState\",\"outputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_umka\",\"type\":\"string\"}],\"name\":\"setUmkaAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"serviceTrasferToDist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_old\",\"type\":\"uint256\"},{\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_check\",\"type\":\"address\"}],\"name\":\"getGroup\",\"outputs\":[{\"name\":\"_group\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_group\",\"type\":\"uint8\"}],\"name\":\"serviceGroupChange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"serviceClaimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"serviceUnpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"serviceRedirect\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"serviceTransferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"serviceIncreaseBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"getUmkaAddress\",\"outputs\":[{\"name\":\"umkaAddress\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractEnable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHoldersLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"serviceTokensBurn\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getHolderLink\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_of\",\"type\":\"bytes32\"}],\"name\":\"getBalanceOfDist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"servicePause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_startTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldgroup\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_newgroup\",\"type\":\"uint8\"}],\"name\":\"EvGroupChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_secret\",\"type\":\"uint256\"}],\"name\":\"EvMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"UmkaToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000001a3185c50000000000000000000000000000000000000000000000000000000000000000004554d4b41000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004554d4b4100000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://4afa9d8d852ba07165de5fe066e1be1646fd38180a354be040d331b769a79f77"}]}