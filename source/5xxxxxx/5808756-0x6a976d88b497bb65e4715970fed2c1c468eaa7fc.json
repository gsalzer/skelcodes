{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\n//\r\n// AddressWars\r\n// (http://beta.addresswars.io/)\r\n// Public Beta\r\n//\r\n//\r\n//     .d8888b.                                    .d8888b.          \r\n//    d88P  Y88b                                  d88P  Y88b         \r\n//    888    888                                  888    888         \r\n//    888    888888  888     888  888.d8888b      888    888888  888 \r\n//    888    888`Y8bd8P'     888  88888K          888    888`Y8bd8P' \r\n//    888    888  X88K       Y88  88P\"Y8888b.     888    888  X88K   \r\n//    Y88b  d88P.d8\"\"8b.      Y8bd8P      X88     Y88b  d88P.d8\"\"8b. \r\n//     \"Y8888P\" 888  888       Y88P   88888P'      \"Y8888P\" 888  888 \r\n//\r\n//\r\n// ******************************\r\n//  Welcome to AddressWars Beta!\r\n// ******************************\r\n//\r\n// This contract is currently in a state of being tested and bug hunted,\r\n// as this is the beta, there will be no fees for enlisting or wagering.\r\n// This will encourage anyone to come and try out AddressWars for free\r\n// before deciding to play the live version (when released) as well as\r\n// making it so that the contract is tested to the fullest ability before\r\n// the live version is deployed. The website is currently under development\r\n// and will be continually improved as time goes on, once the live version\r\n// is deployed, you can access it's contract and data through the root url\r\n// (https://addresswars.io/) and there will always be a copy of the website\r\n// on a subdomain that you can visit in order to view and interact with this\r\n// contract at any time in the future.\r\n//\r\n// This contract is pushing the limits of the current Ethereum blockchain as\r\n// there are quite a lot of variables that it needs to keep track of as well\r\n// as being able to handle the statistical generation of key numbers. As a\r\n// result, the estimated gas cost to deploy this contract is 7.5M whereas\r\n// the current block gas limit is only 8M so this contract will take up\r\n// almost a whole block! Another problem with complex contracts is the fact\r\n// that there is a 16 local variable limit per function and in a few cases,\r\n// the functions needed access to a lot more than that so a lot of filtering\r\n// functions have been developed to handle the calculation internally then\r\n// simply return the useful parts.\r\n//\r\n//\r\n// **************************\r\n//  How to play AddressWars!\r\n// **************************\r\n//\r\n// Enlisting\r\n// In order to start playing AddressWars, you must first have an Ethereum\r\n// wallet address which you can issue transactions from but only non-contract \r\n// addresses (ie addresses where you can issue a transaction directly) can play.\r\n// From here, you can simply call the enlist() function and send the relevant\r\n// fee (in the beta it's 0 ETH, for the live it will be 0.01 ETH). After the\r\n// transaction succeeds, you will have your very own, randomly generated\r\n// address card that you can now put up for wager or use to attempt to claim\r\n// other address cards with!\r\n//\r\n// Wagering\r\n// You can choose to wager any card you own assuming you are not already \r\n// wagering a copy of that card. For your own address, you can provide a\r\n// maximum of 10 other copies to any other addresses (by either transferring \r\n// or wagering), once 10 copies of your own address are circulating, you will\r\n// no longer be able to transfer or wager your own address (although you can\r\n// still use it to claim other addresses). It is important to note that there\r\n// is no way to 'destroy' a copy of a card in circulation and your own address\r\n// card cannot be transferred back to you (and you can't attempt to claim your\r\n// own address card).\r\n// To wager a card, simply call the wagerCardForAmount() function and send\r\n// the relevant fee (in the beta it's 0 ETH, for the live it will be 0.005 ETH)\r\n// as well as the address of the card you wish to wager and the amount you are\r\n// willing to wager it for (in wei). From this point, any other address can\r\n// attempt to claim the address card you listed but the card that will be put up\r\n// for claim will be the one with the lowest claim price (this may not be yours \r\n// at the time but as soon as a successful claim happens and you are the next\r\n// cheapest price, the next time someone attempts to claim that address, you\r\n// will receive the wager and your card may be claimed and taken from you).\r\n//\r\n// Claiming\r\n// Assuming your address has already enlisted, you are free to attempt to\r\n// claim any card that has a current wager on it. You can only store up to\r\n// 8 unique card addresses (your own address + 7 others) in your inventory\r\n// and you cannot claim if you are already at this limit (unless you already own\r\n// that card). You can claim as many copies of a card you own as you like but you\r\n// can only get rid of them by wagering off one at a time. As mentioned above,\r\n// the claim contender will be the owner of the cheapest claim wager. You cannot \r\n// claim a card if you are the current claim contender or if the card address is \r\n// the same as your address (ie you enlisted and got that card).\r\n// To attempt to claim, you need to first assemble an army of 3 address cards\r\n// (these cards don't have to be unique but you do have to own them) and send the \r\n// current cheapest wager price to the attemptToClaimCard() function. This function  \r\n// will do all of the calculation work for you and determine if you managed to claim\r\n// the card or not. The first thing that happens is the contract randomly picks \r\n// your claim contenders cards ensuring that at least one of the cards is the card\r\n// address you are attempting to claim and the rest are from their inventory.\r\n// After this point, all of the complex maths happens and the final attack\r\n// and defence numbers will be calculated based on all of the cards types,\r\n// modifiers and the base attack and defence stats.\r\n// From here it's simply a matter of determining how many hits got through\r\n// on both claimer and claim contender, it's calculated as follows;\r\n// opponentsHits = yourCard[attack] - opponentsCard[defence]\r\n//  ^ will be 0 if opponentsCard[defence] > yourCard[attack]\r\n// This is totalled up for both the claimer and the claim contender and the\r\n// one with the least amount of hits wins!\r\n//\r\n// Claim Outcomes\r\n// There are 3 situations that can result from a claim attempt;\r\n// 1. The total hits for both the claimer and the claim contender are equal\r\n//    - this means that you have drawn with your opponent, the wager will\r\n//      then be distributed;\r\n//      98% -> the claimer (you get most of the wager back)\r\n//      2% -> the dev\r\n// 2. The claimer has more hits than the claim contender\r\n//    - this means that you have lost against your opponent as they ended\r\n//      up taking less hits than you, the wager will then be distributed;\r\n//      98% -> the claim contender (they get most of the wager)\r\n//      2% -> the dev\r\n// 3. The claimer has less hits than the claim contender\r\n//    - this means that you have succeeded in claiming the card and hence\r\n//      that card address will be transferred from the claim contender\r\n//      to the claimer. in this case, both claimer and claim contender\r\n//      receive a portion of the wager as follow;\r\n//      50% -> the claimer (you get half of the wager back)\r\n//      48% -> the claim contender (they get about half of the wager)\r\n//      2% -> the dev\r\n//\r\n// Transferring\r\n// You are free to transfer any card you own to another address that has\r\n// already enlisted. Upon transfer, only one copy of the card will be removed\r\n// from your inventory so if you have multiple copies of that card, it will\r\n// not be completely removed from your inventory. If you only had one copy\r\n// though, that address will be removed from your inventory and you will\r\n// be able to claim/receive another address in its place.\r\n// There are some restrictions when transferring a card; \r\n//   1. you cannot be currently wagering the card\r\n//   2. the address you are transferring to must already be enlisted\r\n//   3. the address you are transferring the card to must have less than \r\n//      8 unique cards already (or they must already own the card)\r\n//   4. you cannot transfer a card back to it's original address\r\n//   5. if you are gifting your own address card, the claim limit will apply\r\n//      and if 10 copies already exist, you will not be able to gift your card.\r\n//\r\n// Withdrawing\r\n// All ETH transferred to the contract will stay in there until an\r\n// address wishes to withdraw from their account. Balances are tracked\r\n// per address and you can either withdraw an amount (assuming you have\r\n// a balance higher than that amount) or you can just withdraw it all.\r\n// For both of these cases there will be no fees associated with withdrawing\r\n// from the contract and after you choose to withdraw, your balance will\r\n// update accordingly.\r\n//\r\n//\r\n// Have fun and good luck claiming!\r\n//\r\n\r\n\r\ncontract AddressWarsBeta {\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  //  Constants\r\n\r\n\r\n  // dev\r\n  address public dev;\r\n  uint256 constant devTax = 2; // 2% of all wagers\r\n\r\n  // fees\r\n  // in the live version the;\r\n  // enlistingFee will be 0.01 ether and the\r\n  // wageringFee will be 0.005 ether\r\n  uint256 constant enlistingFee = 0;\r\n  uint256 constant wageringFee = 0;\r\n\r\n  // limits\r\n\r\n  // the claim limit represents how many times an address can\r\n  // wager/trasnfer their own address. in this case the limit\r\n  // is set to 10 which means there can only ever be 10 other\r\n  // copies of your address out there. once you have wagered\r\n  // all 10 copies, you will no longer be able to wager your\r\n  // own address card (although you can still use it in play).\r\n  uint256 constant CLAIM_LIMIT = 10;\r\n\r\n  // this will limit how many unique addresses you can own at\r\n  // one time. you can own multiple copies of a unique address\r\n  // but you can only own a total of 8 unique addresses (your\r\n  // own address + 7 others) at a time. you can choose to wager\r\n  // any address but if you wager one, the current claim price is the\r\n  // lowest price offered from all owners. upon a successful claim,\r\n  // one copy will transfer from your inventory and if you have no\r\n  // copies remaining, it will remove that address card and you will\r\n  // have another free slot.\r\n  uint256 constant MAX_UNIQUE_CARDS_PER_ADDRESS = 8;\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  //  Statistical Variables\r\n\r\n\r\n  // this is used to calculate all of the statistics and random choices\r\n  // within AddressWars\r\n  // see the shuffleSeed() and querySeed() methods for more information.\r\n  uint256 private _seed;\r\n\r\n  // the type will determine a cards bonus numbers;\r\n  // normal cards do not get any type advantage bonuses\r\n  // fire gets 1.25x att and def when versing nature\r\n  // water gets 1.25x att and def when versing fire\r\n  // nature gets 1.25x att and def when versing water\r\n  // *type advantages are applied after all modifiers\r\n  // that use addition are calculated\r\n  enum TYPE { NORMAL, FIRE, WATER, NATURE }\r\n  uint256[] private typeChances = [ 6, 7, 7, 7 ];\r\n  uint256 constant typeSum = 27;\r\n\r\n  // the modifier will act like a bonus for your card(s)\r\n  // NONE: no bonus will be applied\r\n  // ALL_: if all cards are of the same type, they all get\r\n  //       bonus att/def/att+def numbers\r\n  // V_: if a versing card is of a certain type, your card\r\n  //     will get bonus att/def numbers\r\n  // V_SWAP: this will swap the versing cards att and def\r\n  //         numbers after they've been modified by any\r\n  //         other active modifiers\r\n  // R_V: your card resists the type advantages of the versing card,\r\n  //      normal type cards cannot receive this modifier\r\n  // A_I: your cards type advantage increases from 1.25x to 1.5x,\r\n  //      normal type cards cannot receive this modifier\r\n  enum MODIFIER {\r\n    NONE,\r\n    ALL_ATT, ALL_DEF, ALL_ATT_DEF,\r\n    V_ATT, V_DEF,\r\n    V_SWAP,\r\n    R_V,\r\n    A_I\r\n  }\r\n  uint256[] private modifierChances = [\r\n    55,\r\n    5, 6, 1,\r\n    12, 14,\r\n    3,\r\n    7,\r\n    4\r\n  ];\r\n  uint256 constant modifierSum = 107;\r\n\r\n  // below are the chances for the bonus stats of the modifiers,\r\n  // the seed will first choose a value between 0 and the sum, it will\r\n  // then cumulatively count up until it reaches the index with the\r\n  // matched roll\r\n  // for example;\r\n  // if your data was = [ 2, 3, 4, 2, 1 ], your cumulative total is 12,\r\n  // from there a number will be rolled and it will add up all the values\r\n  // until the cumulative total is greater than the number rolled\r\n  // if we rolled a 9, 2(0) + 3(1) + 4(2) + 2(3) = 11 > 9 so the index\r\n  // you matched in this case would be 3\r\n  // the final value will be;\r\n  // bonusMinimum + indexOf(cumulativeRoll)\r\n  uint256 constant cardBonusMinimum = 1;\r\n  uint256[] private modifierAttBonusChances = [ 2, 5, 8, 7, 3, 2, 1, 1 ]; // range: 1 - 8\r\n  uint256 constant modifierAttBonusSum = 29;\r\n  uint256[] private modifierDefBonusChances = [ 2, 3, 6, 8, 6, 5, 3, 2, 1, 1 ];  // range: 1 - 10\r\n  uint256 constant modifierDefBonusSum = 37;\r\n\r\n  // below are the distribution of the attack and defence numbers,\r\n  // in general, the attack average should be slightly higher than the\r\n  // defence average and defence should have a wider spread of values \r\n  // compared to attack which should be a tighter set of numbers\r\n  // the final value will be;\r\n  // cardMinimum + indexOf(cumulativeRoll)\r\n  uint256 constant cardAttackMinimum = 10;\r\n  uint256[] private cardAttackChances = [ 2, 2, 3, 5, 8, 9, 15, 17, 13, 11, 6, 5, 3, 2, 1, 1 ]; // range: 10 - 25\r\n  uint256 constant cardAttackSum = 103;\r\n  uint256 constant cardDefenceMinimum = 5;\r\n  uint256[] private cardDefenceChances = [ 1, 1, 2, 3, 5, 6, 11, 15, 19, 14, 12, 11, 9, 8, 7, 6, 5, 4, 3, 2, 2, 2, 2, 1, 1, 1 ]; // range: 5 - 30\r\n  uint256 constant cardDefenceSum = 153;\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  //  Registry Variables\r\n\r\n\r\n  // overall address card tracking\r\n  mapping (address => bool) _exists;\r\n  mapping (address => uint256) _indexOf;\r\n  mapping (address => address[]) _ownersOf;\r\n  mapping (address => uint256[]) _ownersClaimPriceOf;\r\n  struct AddressCard {\r\n      address _cardAddress;\r\n      uint8 _cardType;\r\n      uint8 _cardModifier;\r\n      uint8 _modifierPrimarayVal;\r\n      uint8 _modifierSecondaryVal;\r\n      uint8 _attack;\r\n      uint8 _defence;\r\n      uint8 _claimed;\r\n      uint8 _forClaim;\r\n      uint256 _lowestPrice;\r\n      address _claimContender;\r\n  }\r\n  AddressCard[] private _addressCards;\r\n\r\n  // owner and balance tracking\r\n  mapping (address => uint256) _balanceOf;\r\n  mapping (address => address[]) _cardsOf;\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  //  Events\r\n\r\n\r\n  event AddressDidEnlist(\r\n    address enlistedAddress);\r\n  event AddressCardWasWagered(\r\n    address addressCard, \r\n    address owner, \r\n    uint256 wagerAmount);\r\n  event AddressCardWagerWasCancelled(\r\n    address addressCard, \r\n    address owner);\r\n  event AddressCardWasTransferred(\r\n    address addressCard, \r\n    address fromAddress, \r\n    address toAddress);\r\n  event ClaimAttempt(\r\n    bool wasSuccessful, \r\n    address addressCard, \r\n    address claimer, \r\n    address claimContender, \r\n    address[3] claimerChoices, \r\n    address[3] claimContenderChoices, \r\n    uint256[3][2] allFinalAttackValues,\r\n    uint256[3][2] allFinalDefenceValues);\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  //  Main Functions\r\n\r\n\r\n  // start up the contract!\r\n  function AddressWarsBeta() public {\r\n\r\n    // set our dev\r\n    dev = msg.sender;\r\n    // now use the dev address as the initial seed mix\r\n    shuffleSeed(uint256(dev));\r\n\r\n  }\r\n\r\n  // any non-contract address can call this function and begin playing AddressWars!\r\n  // please note that as there are a lot of write to storage operations, this function\r\n  // will be quite expensive in terms of gas so keep that in mind when sending your\r\n  // transaction to the network!\r\n  // 350k gas should be enough to handle all of the storage operations but MetaMask\r\n  // will give a good estimate when you initialize the transaction\r\n  // in order to enlist in AddressWars, you must first pay the enlistingFee (free for beta!)\r\n  function enlist() public payable {\r\n\r\n    require(cardAddressExists(msg.sender) == false);\r\n    require(msg.value == enlistingFee);\r\n    require(msg.sender == tx.origin); // this prevents contracts from enlisting,\r\n    // only normal addresses (ie ones that can send a request) can play AddressWars.\r\n\r\n    // first shuffle the main seed with the sender address as input\r\n    uint256 tmpSeed = tmpShuffleSeed(_seed, uint256(msg.sender));\r\n    uint256 tmpModulus;\r\n    // from this point on, tmpSeed will shuffle every time tmpQuerySeed()\r\n    // is called. it is used recursively so it will mutate upon each\r\n    // call of that function and finally at the end we will update\r\n    // the overall seed to save on gas fees\r\n\r\n    // now we can query the different attributes of the card\r\n    // first lets determine the card type\r\n    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\r\n    uint256 cardType = cumulativeIndexOf(typeChances, tmpModulus);\r\n\r\n    // now to get the modifier\r\n    // special logic to handle normal type cards\r\n    uint256 adjustedModifierSum = modifierSum;\r\n    if (cardType == uint256(TYPE.NORMAL)) {\r\n      // normal cards cannot have the advantage increase modifier (the last in the array)\r\n      adjustedModifierSum -= modifierChances[modifierChances.length - 1];\r\n      // normal cards cannot have the resistance versing modifier (second last in the array)\r\n      adjustedModifierSum -= modifierChances[modifierChances.length - 2];\r\n    }\r\n    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, adjustedModifierSum);\r\n    uint256 cardModifier = cumulativeIndexOf(modifierChances, tmpModulus);\r\n\r\n    // now we need to find our attack and defence values\r\n    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardAttackSum);\r\n    uint256 cardAttack = cardAttackMinimum + cumulativeIndexOf(cardAttackChances, tmpModulus);\r\n    (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardDefenceSum);\r\n    uint256 cardDefence = cardDefenceMinimum + cumulativeIndexOf(cardDefenceChances, tmpModulus);\r\n\r\n    // finally handle our modifier values\r\n    uint256 primaryModifierVal = 0;\r\n    uint256 secondaryModifierVal = 0;\r\n    uint256 bonusAttackPenalty = 0;\r\n    uint256 bonusDefencePenalty = 0;\r\n    // handle the logic of our modifiers\r\n    if (cardModifier == uint256(MODIFIER.ALL_ATT)) { // all of the same type attack bonus\r\n\r\n      // the primary modifier value will hold our attack bonus\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\r\n      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\r\n      // now for the attack penalty\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\r\n      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\r\n      // penalty is doubled\r\n      bonusAttackPenalty *= 2;\r\n\r\n    } else if (cardModifier == uint256(MODIFIER.ALL_DEF)) { // all of the same type defence bonus\r\n\r\n      // the primary modifier value will hold our defence bonus\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\r\n      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\r\n      // now for the defence penalty\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\r\n      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\r\n      // penalty is doubled\r\n      bonusDefencePenalty *= 2;\r\n\r\n    } else if (cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) { // all of the same type attack and defence bonus\r\n\r\n      // the primary modifier value will hold our attack bonus\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\r\n      primaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\r\n      // now for the attack penalty\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\r\n      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\r\n      // penalty is doubled\r\n      bonusAttackPenalty *= 2;\r\n\r\n      // the secondary modifier value will hold our defence bonus\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\r\n      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\r\n      // now for the defence penalty\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\r\n      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\r\n      // penalty is doubled\r\n      bonusDefencePenalty *= 2;\r\n\r\n    } else if (cardModifier == uint256(MODIFIER.V_ATT)) { // versing a certain type attack bonus\r\n\r\n      // the primary modifier value will hold type we need to verse in order to get our bonus\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\r\n      primaryModifierVal = cumulativeIndexOf(typeChances, tmpModulus);\r\n\r\n      // the secondary modifier value will hold our attack bonus\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\r\n      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\r\n      // now for the attack penalty\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierAttBonusSum);\r\n      bonusAttackPenalty = cardBonusMinimum + cumulativeIndexOf(modifierAttBonusChances, tmpModulus);\r\n\r\n    } else if (cardModifier == uint256(MODIFIER.V_DEF)) { // versing a certain type defence bonus\r\n\r\n      // the primary modifier value will hold type we need to verse in order to get our bonus\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, typeSum);\r\n      primaryModifierVal = cumulativeIndexOf(typeChances, tmpModulus);\r\n\r\n      // the secondary modifier value will hold our defence bonus\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\r\n      secondaryModifierVal = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\r\n      // now for the defence penalty\r\n      (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, modifierDefBonusSum);\r\n      bonusDefencePenalty = cardBonusMinimum + cumulativeIndexOf(modifierDefBonusChances, tmpModulus);\r\n\r\n    }\r\n\r\n    // now apply the penalties\r\n    if (bonusAttackPenalty >= cardAttack) {\r\n      cardAttack = 0;\r\n    } else {\r\n      cardAttack -= bonusAttackPenalty;\r\n    }\r\n    if (bonusDefencePenalty >= cardDefence) {\r\n      cardDefence = 0;\r\n    } else {\r\n      cardDefence -= bonusDefencePenalty;\r\n    }\r\n\r\n\r\n    // now to add it to the registry\r\n    _exists[msg.sender] = true;\r\n    _indexOf[msg.sender] = uint256(_addressCards.length);\r\n    _ownersOf[msg.sender] = [ msg.sender ];\r\n    _ownersClaimPriceOf[msg.sender] = [ uint256(0) ];\r\n    _addressCards.push(AddressCard({\r\n      _cardAddress: msg.sender,\r\n      _cardType: uint8(cardType),\r\n      _cardModifier: uint8(cardModifier),\r\n      _modifierPrimarayVal: uint8(primaryModifierVal),\r\n      _modifierSecondaryVal: uint8(secondaryModifierVal),\r\n      _attack: uint8(cardAttack),\r\n      _defence: uint8(cardDefence),\r\n      _claimed: uint8(0),\r\n      _forClaim: uint8(0),\r\n      _lowestPrice: uint256(0),\r\n      _claimContender: address(0)\r\n    }));\r\n\r\n    // ...and now start your own collection!\r\n    _cardsOf[msg.sender] = [ msg.sender ];\r\n\r\n    // dev receives the enlisting fee\r\n    _balanceOf[dev] = SafeMath.add(_balanceOf[dev], enlistingFee);\r\n\r\n    // finally we need to update the main seed and as we initially started with\r\n    // the current main seed, tmpSeed will be the current representation of the seed\r\n    _seed = tmpSeed;\r\n\r\n    // now that we're done, it's time to log the event\r\n    AddressDidEnlist(msg.sender);\r\n\r\n  }\r\n\r\n  // this is where you can wager one of your addresses for a certain amount.\r\n  // any other player can then attempt to claim your address off you, if the\r\n  // address is your own address, you will simply give them a copy (limited to 10\r\n  // total copies) but otherwise the player will take that address off you if they\r\n  // are successful.\r\n  // here's what can happen when you wager;\r\n  // 1. if an opponent is successful in claiming your card, they will receive 50%\r\n  //    of the wager amount back, the dev gets 2% and you get 48%\r\n  // 2. if an opponent is unsuccessful in claiming your card, you will receive\r\n  //    98% of the wager amount and the dev will get 2%\r\n  // 3. if an opponent is draws with you when claiming your card, they will receive\r\n  //    98% of the wager amount back and the dev will get 2%\r\n  // your wager will remain available for anyone to claim up until either you cancel\r\n  // the wager or an opponent is successful in claiming your card\r\n  // in order to wager in AddressWars, you must first pay the wageringFee (free for beta!)\r\n  function wagerCardForAmount(address cardAddress, uint256 amount) public payable {\r\n\r\n    require(amount > 0);\r\n\r\n    require(cardAddressExists(msg.sender));\r\n    require(msg.value == wageringFee);\r\n\r\n    uint256 firstMatchedIndex;\r\n    bool isAlreadyWagered;\r\n    (firstMatchedIndex, isAlreadyWagered, , , ) = getOwnerOfCardsCheapestWager(msg.sender, cardAddress);\r\n    // calling the above method will automatically reinforce the check that the cardAddress exists\r\n    // as well as the sender actually owning the card\r\n    // we cannot wager a card if we are already wagering it\r\n    require(isAlreadyWagered == false);\r\n    // double check to make sure the card is actually owned by the sender\r\n    require(msg.sender == _ownersOf[cardAddress][firstMatchedIndex]);\r\n\r\n    AddressCard memory addressCardForWager = _addressCards[_indexOf[cardAddress]];\r\n    if (msg.sender == cardAddress) {\r\n      // we need to enforce the claim limit if you are the initial owner\r\n      require(addressCardForWager._claimed < CLAIM_LIMIT);\r\n    }\r\n\r\n    // now write the new data\r\n    _ownersClaimPriceOf[cardAddress][firstMatchedIndex] = amount;\r\n\r\n    // now update our statistics\r\n    updateCardStatistics(cardAddress);\r\n\r\n    // dev receives the wagering fee\r\n    _balanceOf[dev] = SafeMath.add(_balanceOf[dev], wageringFee);\r\n\r\n    // now that we're done, it's time to log the event\r\n    AddressCardWasWagered(cardAddress, msg.sender, amount);\r\n\r\n  }\r\n\r\n  function cancelWagerOfCard(address cardAddress) public {\r\n\r\n    require(cardAddressExists(msg.sender));\r\n\r\n    uint256 firstMatchedIndex;\r\n    bool isAlreadyWagered;\r\n    (firstMatchedIndex, isAlreadyWagered, , , ) = getOwnerOfCardsCheapestWager(msg.sender, cardAddress);\r\n    // calling the above method will automatically reinforce the check that the cardAddress exists\r\n    // as well as the owner actually owning the card\r\n    // we can only cancel a wager if there already is one\r\n    require(isAlreadyWagered);\r\n    // double check to make sure the card is actually owned by the sender\r\n    require(msg.sender == _ownersOf[cardAddress][firstMatchedIndex]);\r\n\r\n    // now write the new data\r\n    _ownersClaimPriceOf[cardAddress][firstMatchedIndex] = 0;\r\n\r\n    // now update our statistics\r\n    updateCardStatistics(cardAddress);\r\n\r\n    // now that we're done, it's time to log the event\r\n    AddressCardWagerWasCancelled(cardAddress, msg.sender);\r\n\r\n  }\r\n\r\n  // this is the main battle function of the contract, it takes the card address you\r\n  // wish to claim as well as your card choices as input. a lot of complex calculations\r\n  // happen within this function and in the end, a result will be determined on whether\r\n  // you won the claim or not. at the end, an event will be logged with all of the information\r\n  // about what happened in the battle including the final result, the contenders,\r\n  // the card choices (yours and your opponenets) as well as the final attack and defence numbers.\r\n  // this function will revert if the msg.value does not match the current minimum claim value\r\n  // of the card address you are attempting to claim.\r\n  function attemptToClaimCard(address cardAddress, address[3] choices) public payable {\r\n\r\n    // a lot of the functionality of attemptToClaimCard() is calculated in other methods as\r\n    // there is only a 16 local variable limit per method and we need a lot more than that\r\n\r\n    // see ownerCanClaimCard() below, this ensures we can actually claim the card we are after\r\n    // by running through various requirement checks\r\n    address claimContender;\r\n    uint256 claimContenderIndex;\r\n    (claimContender, claimContenderIndex) = ownerCanClaimCard(msg.sender, cardAddress, choices, msg.value);\r\n\r\n    address[3] memory opponentCardChoices = generateCardsFromClaimForOpponent(cardAddress, claimContender);\r\n\r\n    uint256[3][2] memory allFinalAttackFigures;\r\n    uint256[3][2] memory allFinalDefenceFigures;\r\n    (allFinalAttackFigures, allFinalDefenceFigures) = calculateAdjustedFiguresForBattle(choices, opponentCardChoices);\r\n    // after this point we have all of the modified attack and defence figures\r\n    // in the arrays above. the way the winner is determined is by counting \r\n    // how many attack points get through in total for each card, this is\r\n    // calculated by simply doing;\r\n    // opponentsHits = yourCard[attack] - opponentsCard[defence]\r\n    // if the defence of the opposing card is greater than the attack value,\r\n    // no hits will be taken.\r\n    // at the end, all hits are added up and the winner is the one with\r\n    // the least total amount of hits, if it is a draw, the wager will be\r\n    // returned to the sender (minus the dev fee)\r\n    uint256[2] memory totalHits = [ uint256(0), uint256(0) ];\r\n    for (uint256 i = 0; i < 3; i++) {\r\n      // start with the opponent attack to you\r\n      totalHits[0] += (allFinalAttackFigures[1][i] > allFinalDefenceFigures[0][i] ? allFinalAttackFigures[1][i] - allFinalDefenceFigures[0][i] : 0);\r\n      // then your attack to the opponent\r\n      totalHits[1] += (allFinalAttackFigures[0][i] > allFinalDefenceFigures[1][i] ? allFinalAttackFigures[0][i] - allFinalDefenceFigures[1][i] : 0);\r\n    }\r\n\r\n    // before we process the outcome, we should log the event.\r\n    // order is important here as we should log a successful \r\n    // claim attempt then a transfer (if that's what happens)\r\n    // instead of the other way around\r\n    ClaimAttempt(\r\n      totalHits[0] < totalHits[1], // it was successful if we had less hits than the opponent\r\n      cardAddress,\r\n      msg.sender,\r\n      claimContender,\r\n      choices,\r\n      opponentCardChoices,\r\n      allFinalAttackFigures,\r\n      allFinalDefenceFigures\r\n      );\r\n\r\n    // handle the outcomes\r\n    uint256 tmpAmount;\r\n    if (totalHits[0] == totalHits[1]) { // we have a draw\r\n\r\n      // hand out the dev tax\r\n      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\r\n      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\r\n      // now we return the rest to the sender\r\n      _balanceOf[msg.sender] = SafeMath.add(_balanceOf[msg.sender], SafeMath.sub(msg.value, tmpAmount)); // 98%\r\n\r\n    } else if (totalHits[0] > totalHits[1]) { // we have more hits so we were unsuccessful\r\n\r\n      // hand out the dev tax\r\n      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\r\n      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\r\n      // now we give the rest to the claim contender\r\n      _balanceOf[claimContender] = SafeMath.add(_balanceOf[claimContender], SafeMath.sub(msg.value, tmpAmount)); // 98%\r\n\r\n    } else { // this means we have less hits than the opponent so we were successful in our claim!\r\n\r\n      // hand out the dev tax\r\n      tmpAmount = SafeMath.div(SafeMath.mul(msg.value, devTax), 100); // 2%\r\n      _balanceOf[dev] = SafeMath.add(_balanceOf[dev], tmpAmount);\r\n      // return half to the sender\r\n      _balanceOf[msg.sender] = SafeMath.add(_balanceOf[msg.sender], SafeMath.div(msg.value, 2)); // 50%\r\n      // and now the remainder goes to the claim contender\r\n      _balanceOf[claimContender] = SafeMath.add(_balanceOf[claimContender], SafeMath.sub(SafeMath.div(msg.value, 2), tmpAmount)); // 48%\r\n\r\n      // finally transfer the ownership of the card from the claim contender to the sender but\r\n      // first we need to make sure to cancel the wager\r\n      _ownersClaimPriceOf[cardAddress][claimContenderIndex] = 0;\r\n      transferCard(cardAddress, claimContender, msg.sender);\r\n\r\n      // now update our statistics\r\n      updateCardStatistics(cardAddress);\r\n\r\n    }\r\n\r\n  }\r\n\r\n  function transferCardTo(address cardAddress, address toAddress) public {\r\n\r\n    // you can view this internal method below for more details.\r\n    // all of the requirements around transferring a card are\r\n    // tested within the transferCard() method.\r\n    // you are free to gift your own address card to anyone\r\n    // (assuming there are less than 10 copies circulating).\r\n    transferCard(cardAddress, msg.sender, toAddress);\r\n\r\n  }\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  //  Wallet Functions\r\n\r\n\r\n  function withdrawAmount(uint256 amount) public {\r\n\r\n    require(amount > 0);\r\n\r\n    address sender = msg.sender;\r\n    uint256 balance = _balanceOf[sender];\r\n    \r\n    require(amount <= balance);\r\n    // transfer and update the balances\r\n    _balanceOf[sender] = SafeMath.sub(_balanceOf[sender], amount);\r\n    sender.transfer(amount);\r\n\r\n  }\r\n\r\n  function withdrawAll() public {\r\n\r\n    address sender = msg.sender;\r\n    uint256 balance = _balanceOf[sender];\r\n\r\n    require(balance > 0);\r\n    // transfer and update the balances\r\n    _balanceOf[sender] = 0;\r\n    sender.transfer(balance);\r\n\r\n  }\r\n\r\n  function getBalanceOfSender() public view returns (uint256) {\r\n    return _balanceOf[msg.sender];\r\n  }\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  //  Helper Functions\r\n\r\n\r\n  function tmpShuffleSeed(uint256 tmpSeed, uint256 mix) public view returns (uint256) {\r\n\r\n    // really mix it up!\r\n    uint256 newTmpSeed = tmpSeed;\r\n    uint256 currentTime = now;\r\n    uint256 timeMix = currentTime + mix;\r\n    // in this instance, overflow is ok as we are just shuffling around the bits\r\n    // first lets square the seed\r\n    newTmpSeed *= newTmpSeed;\r\n    // now add our time and mix\r\n    newTmpSeed += timeMix;\r\n    // multiply by the time\r\n    newTmpSeed *= currentTime;\r\n    // now add our mix\r\n    newTmpSeed += mix;\r\n    // and finally multiply by the time and mix\r\n    newTmpSeed *= timeMix;\r\n\r\n    return newTmpSeed;\r\n\r\n  }\r\n\r\n  function shuffleSeed(uint256 mix) private {\r\n\r\n    // set our seed based on our last seed\r\n    _seed = tmpShuffleSeed(_seed, mix);\r\n  \r\n  }\r\n\r\n  function tmpQuerySeed(uint256 tmpSeed, uint256 modulus) public view returns (uint256 tmpShuffledSeed, uint256 result) {\r\n\r\n    require(modulus > 0);\r\n\r\n    // get our answer\r\n    uint256 response = tmpSeed % modulus;\r\n\r\n    // now we want to re-mix our seed based off our response\r\n    uint256 mix = response + 1; // non-zero\r\n    mix *= modulus;\r\n    mix += response;\r\n    mix *= modulus;\r\n\r\n    // now return it\r\n    return (tmpShuffleSeed(tmpSeed, mix), response);\r\n\r\n  }\r\n\r\n  function querySeed(uint256 modulus) private returns (uint256) {\r\n\r\n    require(modulus > 0);\r\n\r\n    uint256 tmpSeed;\r\n    uint256 response;\r\n    (tmpSeed, response) = tmpQuerySeed(_seed, modulus);\r\n\r\n    // tmpSeed will now represent the suffled version of our last seed\r\n    _seed = tmpSeed;\r\n\r\n    // now return it\r\n    return response;\r\n\r\n  }\r\n\r\n  function cumulativeIndexOf(uint256[] array, uint256 target) private pure returns (uint256) {\r\n\r\n    bool hasFound = false;\r\n    uint256 index;\r\n    uint256 cumulativeTotal = 0;\r\n    for (uint256 i = 0; i < array.length; i++) {\r\n      cumulativeTotal += array[i];\r\n      if (cumulativeTotal > target) {\r\n        hasFound = true;\r\n        index = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    require(hasFound);\r\n    return index;\r\n\r\n  }\r\n\r\n  function cardAddressExists(address cardAddress) public view returns (bool) {\r\n    return _exists[cardAddress];\r\n  }\r\n\r\n  function indexOfCardAddress(address cardAddress) public view returns (uint256) {\r\n    require(cardAddressExists(cardAddress));\r\n    return _indexOf[cardAddress];\r\n  }\r\n\r\n  function ownerCountOfCard(address owner, address cardAddress) public view returns (uint256) {\r\n\r\n    // both card addresses need to exist in order to own cards\r\n    require(cardAddressExists(owner));\r\n    require(cardAddressExists(cardAddress));\r\n\r\n    // check if it's your own address\r\n    if (owner == cardAddress) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 ownerCount = 0;\r\n    address[] memory owners = _ownersOf[cardAddress];\r\n    for (uint256 i = 0; i < owners.length; i++) {\r\n      if (owner == owners[i]) {\r\n        ownerCount++;\r\n      }\r\n    }\r\n\r\n    return ownerCount;\r\n\r\n  }\r\n\r\n  function ownerHasCard(address owner, address cardAddress) public view returns (bool doesOwn, uint256[] indexes) {\r\n\r\n    // both card addresses need to exist in order to own cards\r\n    require(cardAddressExists(owner));\r\n    require(cardAddressExists(cardAddress));\r\n\r\n    uint256[] memory ownerIndexes = new uint256[](ownerCountOfCard(owner, cardAddress));\r\n    // check if it's your own address\r\n    if (owner == cardAddress) {\r\n      return (true, ownerIndexes);\r\n    }\r\n\r\n    if (ownerIndexes.length > 0) {\r\n      uint256 currentIndex = 0;\r\n      address[] memory owners = _ownersOf[cardAddress];\r\n      for (uint256 i = 0; i < owners.length; i++) {\r\n        if (owner == owners[i]) {\r\n          ownerIndexes[currentIndex] = i;\r\n          currentIndex++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // this owner may own multiple copies of the card and so an array of indexes are returned\r\n    // if the owner does not own the card, it will return (false, [])\r\n    return (ownerIndexes.length > 0, ownerIndexes);\r\n\r\n  }\r\n\r\n  function ownerHasCardSimple(address owner, address cardAddress) private view returns (bool) {\r\n\r\n    bool doesOwn;\r\n    (doesOwn, ) = ownerHasCard(owner, cardAddress);\r\n    return doesOwn;\r\n\r\n  }\r\n\r\n  function ownerCanClaimCard(address owner, address cardAddress, address[3] choices, uint256 amount) private view returns (address currentClaimContender, uint256 claimContenderIndex) {\r\n\r\n    // you cannot claim back your own address cards\r\n    require(owner != cardAddress);\r\n    require(cardAddressExists(owner));\r\n    require(ownerHasCardSimple(owner, cardAddress) || _cardsOf[owner].length < MAX_UNIQUE_CARDS_PER_ADDRESS);\r\n\r\n\r\n    uint256 cheapestIndex;\r\n    bool canClaim;\r\n    address claimContender;\r\n    uint256 lowestClaimPrice;\r\n    (cheapestIndex, canClaim, claimContender, lowestClaimPrice, ) = getCheapestCardWager(cardAddress);\r\n    // make sure we can actually claim it and that we are paying the correct amount\r\n    require(canClaim);\r\n    require(amount == lowestClaimPrice);\r\n    // we also need to check that the sender is not the current claim contender\r\n    require(owner != claimContender);\r\n\r\n    // now check if we own all of our choices\r\n    for (uint256 i = 0; i < choices.length; i++) {\r\n      require(ownerHasCardSimple(owner, choices[i])); // if one is not owned, it will trigger a revert\r\n    }\r\n\r\n    // if no requires have been triggered by this point it means we are able to claim the card\r\n    // now return the claim contender and their index\r\n    return (claimContender, cheapestIndex);\r\n\r\n  }\r\n\r\n  function generateCardsFromClaimForOpponent(address cardAddress, address opponentAddress) private returns (address[3]) {\r\n\r\n    require(cardAddressExists(cardAddress));\r\n    require(cardAddressExists(opponentAddress));\r\n    require(ownerHasCardSimple(opponentAddress, cardAddress));\r\n\r\n    // generate the opponents cards from their own inventory\r\n    // it is important to note that at least 1 of their choices\r\n    // needs to be the card you are attempting to claim\r\n    address[] memory cardsOfOpponent = _cardsOf[opponentAddress];\r\n    address[3] memory opponentCardChoices;\r\n    uint256 tmpSeed = tmpShuffleSeed(_seed, uint256(opponentAddress));\r\n    uint256 tmpModulus;\r\n    uint256 indexOfClaimableCard;\r\n    (tmpSeed, indexOfClaimableCard) = tmpQuerySeed(tmpSeed, 3); // 0, 1 or 2\r\n    for (uint256 i = 0; i < 3; i++) {\r\n      if (i == indexOfClaimableCard) {\r\n        opponentCardChoices[i] = cardAddress;\r\n      } else {\r\n        (tmpSeed, tmpModulus) = tmpQuerySeed(tmpSeed, cardsOfOpponent.length);\r\n        opponentCardChoices[i] = cardsOfOpponent[tmpModulus];        \r\n      }\r\n    }\r\n\r\n    // finally we need to update the main seed and as we initially started with\r\n    // the current main seed, tmpSeed will be the current representation of the seed\r\n    _seed = tmpSeed;\r\n\r\n    return opponentCardChoices;\r\n\r\n  }\r\n\r\n  function updateCardStatistics(address cardAddress) private {\r\n\r\n    AddressCard storage addressCardClaimed = _addressCards[_indexOf[cardAddress]];\r\n    address claimContender;\r\n    uint256 lowestClaimPrice;\r\n    uint256 wagerCount;\r\n    ( , , claimContender, lowestClaimPrice, wagerCount) = getCheapestCardWager(cardAddress);\r\n    addressCardClaimed._forClaim = uint8(wagerCount);\r\n    addressCardClaimed._lowestPrice = lowestClaimPrice;\r\n    addressCardClaimed._claimContender = claimContender;\r\n\r\n  }\r\n\r\n  function transferCard(address cardAddress, address fromAddress, address toAddress) private {\r\n\r\n    require(toAddress != fromAddress);\r\n    require(cardAddressExists(cardAddress));\r\n    require(cardAddressExists(fromAddress));\r\n    uint256 firstMatchedIndex;\r\n    bool isWagered;\r\n    (firstMatchedIndex, isWagered, , , ) = getOwnerOfCardsCheapestWager(fromAddress, cardAddress);\r\n    require(isWagered == false); // you cannot transfer a card if it's currently wagered\r\n\r\n    require(cardAddressExists(toAddress));\r\n    require(toAddress != cardAddress); // can't transfer a card to it's original address\r\n    require(ownerHasCardSimple(toAddress, cardAddress) || _cardsOf[toAddress].length < MAX_UNIQUE_CARDS_PER_ADDRESS);\r\n\r\n    // firstly, if toAddress doesn't have a copy we need to add one\r\n    if (!ownerHasCardSimple(toAddress, cardAddress)) {\r\n      _cardsOf[toAddress].push(cardAddress);\r\n    } \r\n\r\n    // now check whether the fromAddress is just our original card\r\n    // address, if this is the case, they are free to transfer out\r\n    // one of their cards assuming the claim limit is not yet reached\r\n    if (fromAddress == cardAddress) { // the card is being claimed/gifted\r\n\r\n      AddressCard storage addressCardClaimed = _addressCards[_indexOf[cardAddress]];\r\n      require(addressCardClaimed._claimed < CLAIM_LIMIT);\r\n\r\n      // we need to push new data to our arrays\r\n      _ownersOf[cardAddress].push(toAddress);\r\n      _ownersClaimPriceOf[cardAddress].push(uint256(0));\r\n\r\n      // now update the claimed count in the registry\r\n      addressCardClaimed._claimed = uint8(_ownersOf[cardAddress].length - 1); // we exclude the original address\r\n\r\n    } else {\r\n\r\n      // firstly we need to cache the current index from our fromAddress' _cardsOf\r\n      uint256 cardIndexOfSender = getCardIndexOfOwner(cardAddress, fromAddress);\r\n\r\n      // now just update the address at the firstMatchedIndex\r\n      _ownersOf[cardAddress][firstMatchedIndex] = toAddress;\r\n\r\n      // finally check if our fromAddress has any copies of the card left\r\n      if (!ownerHasCardSimple(fromAddress, cardAddress)) {\r\n\r\n        // if not delete that card from their inventory and make room in the array\r\n        for (uint256 i = cardIndexOfSender; i < _cardsOf[fromAddress].length - 1; i++) {\r\n          // shuffle the next value over\r\n          _cardsOf[fromAddress][i] = _cardsOf[fromAddress][i + 1];\r\n        }\r\n        // now decrease the length\r\n        _cardsOf[fromAddress].length--;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    // now that we're done, it's time to log the event\r\n    AddressCardWasTransferred(cardAddress, fromAddress, toAddress);\r\n\r\n  }\r\n\r\n  function calculateAdjustedFiguresForBattle(address[3] yourChoices, address[3] opponentsChoices) private view returns (uint256[3][2] allAdjustedAttackFigures, uint256[3][2] allAdjustedDefenceFigures) {\r\n\r\n    // [0] is yours, [1] is your opponents\r\n    AddressCard[3][2] memory allCards;\r\n    uint256[3][2] memory allAttackFigures;\r\n    uint256[3][2] memory allDefenceFigures;\r\n    bool[2] memory allOfSameType = [ true, true ];\r\n    uint256[2] memory cumulativeAttackBonuses = [ uint256(0), uint256(0) ];\r\n    uint256[2] memory cumulativeDefenceBonuses = [ uint256(0), uint256(0) ];\r\n\r\n    for (uint256 i = 0; i < 3; i++) {\r\n      // cache your cards\r\n      require(_exists[yourChoices[i]]);\r\n      allCards[0][i] = _addressCards[_indexOf[yourChoices[i]]];\r\n      allAttackFigures[0][i] = allCards[0][i]._attack;\r\n      allDefenceFigures[0][i] = allCards[0][i]._defence;\r\n\r\n      // cache your opponents cards\r\n      require(_exists[opponentsChoices[i]]);\r\n      allCards[1][i] = _addressCards[_indexOf[opponentsChoices[i]]];\r\n      allAttackFigures[1][i] = allCards[1][i]._attack;\r\n      allDefenceFigures[1][i] = allCards[1][i]._defence;\r\n    }\r\n\r\n    // for the next part, order is quite important as we want the\r\n    // addition to happen first and then the multiplication to happen \r\n    // at the very end for the type advantages/resistances\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    // the first modifiers that needs to be applied is the\r\n    // ALL_ATT, ALL_DEF and the ALL_ATT_DEF mod\r\n    // if all 3 of the chosen cards match the same type\r\n    // and if at least one of them have the ALL_ATT, ALL_DEF\r\n    // or ALL_ATT_DEF modifier, all of the cards will receive\r\n    // the cumulative bonus for att/def/att+def\r\n    for (i = 0; i < 3; i++) {\r\n\r\n      // start with your cards      \r\n      // compare to see if the types are the same as the previous one\r\n      if (i > 0 && allCards[0][i]._cardType != allCards[0][i - 1]._cardType) {\r\n        allOfSameType[0] = false;\r\n      }\r\n      // next count up all the modifier values for a total possible bonus\r\n      if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_ATT)) { // all attack\r\n        // for the ALL_ATT modifier, the additional attack bonus is\r\n        // stored in the primary value\r\n        cumulativeAttackBonuses[0] += allCards[0][i]._modifierPrimarayVal;\r\n      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_DEF)) { // all defence\r\n        // for the ALL_DEF modifier, the additional defence bonus is\r\n        // stored in the primary value\r\n        cumulativeDefenceBonuses[0] += allCards[0][i]._modifierPrimarayVal;\r\n      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) { // all attack + defence\r\n        // for the ALL_ATT_DEF modifier, the additional attack bonus is\r\n        // stored in the primary value and the additional defence bonus is\r\n        // stored in the secondary value\r\n        cumulativeAttackBonuses[0] += allCards[0][i]._modifierPrimarayVal;\r\n        cumulativeDefenceBonuses[0] += allCards[0][i]._modifierSecondaryVal;\r\n      }\r\n      \r\n      // now do the same for your opponent\r\n      if (i > 0 && allCards[1][i]._cardType != allCards[1][i - 1]._cardType) {\r\n        allOfSameType[1] = false;\r\n      }\r\n      if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_ATT)) {\r\n        cumulativeAttackBonuses[1] += allCards[1][i]._modifierPrimarayVal;\r\n      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_DEF)) {\r\n        cumulativeDefenceBonuses[1] += allCards[1][i]._modifierPrimarayVal;\r\n      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.ALL_ATT_DEF)) {\r\n        cumulativeAttackBonuses[1] += allCards[1][i]._modifierPrimarayVal;\r\n        cumulativeDefenceBonuses[1] += allCards[1][i]._modifierSecondaryVal;\r\n      }\r\n\r\n    }\r\n    // we void our bonus if they aren't all of the type\r\n    if (!allOfSameType[0]) {\r\n      cumulativeAttackBonuses[0] = 0;\r\n      cumulativeDefenceBonuses[0] = 0;\r\n    }\r\n    if (!allOfSameType[1]) {\r\n      cumulativeAttackBonuses[1] = 0;\r\n      cumulativeDefenceBonuses[1] = 0;\r\n    }\r\n    // now add the bonus figures to the initial attack numbers, they will be 0\r\n    // if they either weren't all of the same type or if no cards actually had\r\n    // the ALL_ modifier\r\n    for (i = 0; i < 3; i++) {\r\n      // for your cards\r\n      allAttackFigures[0][i] += cumulativeAttackBonuses[0];\r\n      allDefenceFigures[0][i] += cumulativeDefenceBonuses[0];\r\n\r\n      // ...and your opponents cards\r\n      allAttackFigures[1][i] += cumulativeAttackBonuses[1];\r\n      allDefenceFigures[1][i] += cumulativeDefenceBonuses[1]; \r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    // the second modifier that needs to be applied is the V_ATT\r\n    // or the V_DEF mod\r\n    // if the versing card matches the same type listed in the\r\n    // primaryModifierVal, that card will receive the bonus in\r\n    // secondaryModifierVal for att/def\r\n    for (i = 0; i < 3; i++) {\r\n\r\n      // start with your cards      \r\n      if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_ATT)) { // versing attack\r\n        // check if the versing cards type matches the primary value\r\n        if (allCards[1][i]._cardType == allCards[0][i]._modifierPrimarayVal) {\r\n          // add the attack bonus (amount is held in the secondary value)\r\n          allAttackFigures[0][i] += allCards[0][i]._modifierSecondaryVal;\r\n        }\r\n      } else if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_DEF)) { // versing defence\r\n        // check if the versing cards type matches the primary value\r\n        if (allCards[1][i]._cardType == allCards[0][i]._modifierPrimarayVal) {\r\n          // add the defence bonus (amount is held in the secondary value)\r\n          allDefenceFigures[0][i] += allCards[0][i]._modifierSecondaryVal;\r\n        }\r\n      }\r\n\r\n      // now do the same for your opponent\r\n      if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_ATT)) {\r\n        if (allCards[0][i]._cardType == allCards[1][i]._modifierPrimarayVal) {\r\n          allAttackFigures[1][i] += allCards[1][i]._modifierSecondaryVal;\r\n        }\r\n      } else if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_DEF)) {\r\n        if (allCards[0][i]._cardType == allCards[1][i]._modifierPrimarayVal) {\r\n          allDefenceFigures[1][i] += allCards[1][i]._modifierSecondaryVal;\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    // the third modifier that needs to be applied is the type\r\n    // advantage numbers as well as applying R_V (resists versing\r\n    // cards type advantage) and A_I (increases your cards advantage)\r\n    for (i = 0; i < 3; i++) {\r\n\r\n      // start with your cards\r\n      // first check if the card we're versing resists our type advantage\r\n      if (allCards[1][i]._cardModifier != uint256(MODIFIER.R_V)) {\r\n        // test all the possible combinations of advantages\r\n        if (\r\n          // fire vs nature\r\n          (allCards[0][i]._cardType == uint256(TYPE.FIRE) && allCards[1][i]._cardType == uint256(TYPE.NATURE)) ||\r\n          // water vs fire\r\n          (allCards[0][i]._cardType == uint256(TYPE.WATER) && allCards[1][i]._cardType == uint256(TYPE.FIRE)) ||\r\n          // nature vs water\r\n          (allCards[0][i]._cardType == uint256(TYPE.NATURE) && allCards[1][i]._cardType == uint256(TYPE.WATER))\r\n          ) {\r\n\r\n          // now check if your card has a type advantage increase modifier\r\n          if (allCards[0][i]._cardModifier != uint256(MODIFIER.A_I)) {\r\n            allAttackFigures[0][i] = SafeMath.div(SafeMath.mul(allAttackFigures[0][i], 3), 2); // x1.5\r\n            allDefenceFigures[0][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[0][i], 3), 2); // x1.5\r\n          } else {\r\n            allAttackFigures[0][i] = SafeMath.div(SafeMath.mul(allAttackFigures[0][i], 5), 4); // x1.25\r\n            allDefenceFigures[0][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[0][i], 5), 4); // x1.25\r\n          }\r\n        }\r\n      }\r\n\r\n      // now do the same for your opponent\r\n      if (allCards[0][i]._cardModifier != uint256(MODIFIER.R_V)) {\r\n        if (\r\n          (allCards[1][i]._cardType == uint256(TYPE.FIRE) && allCards[0][i]._cardType == uint256(TYPE.NATURE)) ||\r\n          (allCards[1][i]._cardType == uint256(TYPE.WATER) && allCards[0][i]._cardType == uint256(TYPE.FIRE)) ||\r\n          (allCards[1][i]._cardType == uint256(TYPE.NATURE) && allCards[0][i]._cardType == uint256(TYPE.WATER))\r\n          ) {\r\n          if (allCards[1][i]._cardModifier != uint256(MODIFIER.A_I)) {\r\n            allAttackFigures[1][i] = SafeMath.div(SafeMath.mul(allAttackFigures[1][i], 3), 2); // x1.5\r\n            allDefenceFigures[1][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[1][i], 3), 2); // x1.5\r\n          } else {\r\n            allAttackFigures[1][i] = SafeMath.div(SafeMath.mul(allAttackFigures[1][i], 5), 4); // x1.25\r\n            allDefenceFigures[1][i] = SafeMath.div(SafeMath.mul(allDefenceFigures[1][i], 5), 4); // x1.25\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    // the final modifier that needs to be applied is the V_SWAP mod\r\n    // if your card has this modifier, it will swap the final attack\r\n    // and defence numbers of your card\r\n    uint256 tmp;\r\n    for (i = 0; i < 3; i++) {\r\n\r\n      // start with your cards\r\n      // check if the versing card has the V_SWAP modifier\r\n      if (allCards[1][i]._cardModifier == uint256(MODIFIER.V_SWAP)) {\r\n        tmp = allAttackFigures[0][i];\r\n        allAttackFigures[0][i] = allDefenceFigures[0][i];\r\n        allDefenceFigures[0][i] = tmp;\r\n      }\r\n      // ...and your opponents cards\r\n      if (allCards[0][i]._cardModifier == uint256(MODIFIER.V_SWAP)) {\r\n        tmp = allAttackFigures[1][i];\r\n        allAttackFigures[1][i] = allDefenceFigures[1][i];\r\n        allDefenceFigures[1][i] = tmp;\r\n      }\r\n\r\n    }\r\n\r\n    // we're all done!\r\n    return (allAttackFigures, allDefenceFigures);\r\n\r\n  }\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  //  Getter Functions\r\n\r\n\r\n  function getCard(address cardAddress) public view returns (uint256 cardIndex, uint256 cardType, uint256 cardModifier, uint256 cardModifierPrimaryVal, uint256 cardModifierSecondaryVal, uint256 attack, uint256 defence, uint256 claimed, uint256 forClaim, uint256 lowestPrice, address claimContender) {\r\n\r\n    require(cardAddressExists(cardAddress));\r\n\r\n    uint256 index = _indexOf[cardAddress];\r\n    AddressCard memory addressCard = _addressCards[index];\r\n    return (\r\n        index,\r\n        uint256(addressCard._cardType),\r\n        uint256(addressCard._cardModifier),\r\n        uint256(addressCard._modifierPrimarayVal),\r\n        uint256(addressCard._modifierSecondaryVal),\r\n        uint256(addressCard._attack),\r\n        uint256(addressCard._defence),\r\n        uint256(addressCard._claimed),\r\n        uint256(addressCard._forClaim),\r\n        uint256(addressCard._lowestPrice),\r\n        address(addressCard._claimContender)\r\n      );\r\n\r\n  }\r\n\r\n  function getCheapestCardWager(address cardAddress) public view returns (uint256 cheapestIndex, bool isClaimable, address claimContender, uint256 claimPrice, uint256 wagerCount) {\r\n\r\n    require(cardAddressExists(cardAddress));\r\n\r\n    uint256 cheapestSale = 0;\r\n    uint256 indexOfCheapestSale = 0;\r\n    uint256 totalWagers = 0;\r\n    uint256[] memory allOwnersClaimPrice = _ownersClaimPriceOf[cardAddress];\r\n    for (uint256 i = 0; i < allOwnersClaimPrice.length; i++) {\r\n      uint256 priceAtIndex = allOwnersClaimPrice[i];\r\n      if (priceAtIndex != 0) {\r\n        totalWagers++;\r\n        if (cheapestSale == 0 || priceAtIndex < cheapestSale) {\r\n          cheapestSale = priceAtIndex;\r\n          indexOfCheapestSale = i;\r\n        }\r\n      }\r\n    }\r\n\r\n    return (\r\n        indexOfCheapestSale,\r\n        (cheapestSale > 0),\r\n        (cheapestSale > 0 ? _ownersOf[cardAddress][indexOfCheapestSale] : address(0)),\r\n        cheapestSale,\r\n        totalWagers\r\n      );\r\n\r\n  }\r\n\r\n  function getOwnerOfCardsCheapestWager(address owner, address cardAddress) public view returns (uint256 cheapestIndex, bool isSelling, uint256 claimPrice, uint256 priceRank, uint256 outOf) {\r\n\r\n    bool doesOwn;\r\n    uint256[] memory indexes;\r\n    (doesOwn, indexes) = ownerHasCard(owner, cardAddress);\r\n    require(doesOwn);\r\n\r\n    uint256[] memory allOwnersClaimPrice = _ownersClaimPriceOf[cardAddress];\r\n    uint256 cheapestSale = 0;\r\n    uint256 indexOfCheapestSale = 0; // this will handle the case of owner == cardAddress\r\n    if (indexes.length > 0) {\r\n      indexOfCheapestSale = indexes[0]; // defaults to the first index matched\r\n    } else { // also will handle the case of owner == cardAddress\r\n      cheapestSale = allOwnersClaimPrice[0];\r\n    }\r\n\r\n    for (uint256 i = 0; i < indexes.length; i++) {\r\n      if (allOwnersClaimPrice[indexes[i]] != 0 && (cheapestSale == 0 || allOwnersClaimPrice[indexes[i]] < cheapestSale)) {\r\n        cheapestSale = allOwnersClaimPrice[indexes[i]];\r\n        indexOfCheapestSale = indexes[i];\r\n      }\r\n    }\r\n\r\n    uint256 saleRank = 0;\r\n    uint256 totalWagers = 0;\r\n    if (cheapestSale > 0) {\r\n      saleRank = 1;\r\n      for (i = 0; i < allOwnersClaimPrice.length; i++) {\r\n        if (allOwnersClaimPrice[i] != 0) {\r\n          totalWagers++;\r\n          if (allOwnersClaimPrice[i] < cheapestSale) {\r\n            saleRank++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return (\r\n        indexOfCheapestSale,\r\n        (cheapestSale > 0),\r\n        cheapestSale,\r\n        saleRank,\r\n        totalWagers\r\n      );\r\n\r\n  }\r\n\r\n  function getCardIndexOfOwner(address cardAddress, address owner) public view returns (uint256) {\r\n\r\n    require(cardAddressExists(cardAddress));\r\n    require(cardAddressExists(owner));\r\n    require(ownerHasCardSimple(owner, cardAddress));\r\n\r\n    uint256 matchedIndex;\r\n    address[] memory cardsOfOwner = _cardsOf[owner];\r\n    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\r\n      if (cardsOfOwner[i] == cardAddress) {\r\n        matchedIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return matchedIndex;\r\n\r\n  }\r\n  \r\n  function getTotalUniqueCards() public view returns (uint256) {\r\n    return _addressCards.length;\r\n  }\r\n  \r\n  function getAllCardsAddress() public view returns (bytes20[]) {\r\n\r\n    bytes20[] memory allCardsAddress = new bytes20[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsAddress[i] = bytes20(addressCard._cardAddress);\r\n    }\r\n    return allCardsAddress;\r\n\r\n  }\r\n\r\n  function getAllCardsType() public view returns (bytes1[]) {\r\n\r\n    bytes1[] memory allCardsType = new bytes1[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsType[i] = bytes1(addressCard._cardType);\r\n    }\r\n    return allCardsType;\r\n\r\n  }\r\n\r\n  function getAllCardsModifier() public view returns (bytes1[]) {\r\n\r\n    bytes1[] memory allCardsModifier = new bytes1[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsModifier[i] = bytes1(addressCard._cardModifier);\r\n    }\r\n    return allCardsModifier;\r\n\r\n  }\r\n\r\n  function getAllCardsModifierPrimaryVal() public view returns (bytes1[]) {\r\n\r\n    bytes1[] memory allCardsModifierPrimaryVal = new bytes1[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsModifierPrimaryVal[i] = bytes1(addressCard._modifierPrimarayVal);\r\n    }\r\n    return allCardsModifierPrimaryVal;\r\n\r\n  }\r\n\r\n  function getAllCardsModifierSecondaryVal() public view returns (bytes1[]) {\r\n\r\n    bytes1[] memory allCardsModifierSecondaryVal = new bytes1[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsModifierSecondaryVal[i] = bytes1(addressCard._modifierSecondaryVal);\r\n    }\r\n    return allCardsModifierSecondaryVal;\r\n\r\n  }\r\n\r\n  function getAllCardsAttack() public view returns (bytes1[]) {\r\n\r\n    bytes1[] memory allCardsAttack = new bytes1[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsAttack[i] = bytes1(addressCard._attack);\r\n    }\r\n    return allCardsAttack;\r\n\r\n  }\r\n\r\n  function getAllCardsDefence() public view returns (bytes1[]) {\r\n\r\n    bytes1[] memory allCardsDefence = new bytes1[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsDefence[i] = bytes1(addressCard._defence);\r\n    }\r\n    return allCardsDefence;\r\n\r\n  }\r\n\r\n  function getAllCardsClaimed() public view returns (bytes1[]) {\r\n\r\n    bytes1[] memory allCardsClaimed = new bytes1[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsClaimed[i] = bytes1(addressCard._claimed);\r\n    }\r\n    return allCardsClaimed;\r\n\r\n  }\r\n\r\n  function getAllCardsForClaim() public view returns (bytes1[]) {\r\n\r\n    bytes1[] memory allCardsForClaim = new bytes1[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsForClaim[i] = bytes1(addressCard._forClaim);\r\n    }\r\n    return allCardsForClaim;\r\n\r\n  }\r\n\r\n  function getAllCardsLowestPrice() public view returns (bytes32[]) {\r\n\r\n    bytes32[] memory allCardsLowestPrice = new bytes32[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsLowestPrice[i] = bytes32(addressCard._lowestPrice);\r\n    }\r\n    return allCardsLowestPrice;\r\n\r\n  }\r\n\r\n  function getAllCardsClaimContender() public view returns (bytes4[]) {\r\n\r\n    // returns the indexes of the claim contender\r\n    bytes4[] memory allCardsClaimContender = new bytes4[](_addressCards.length);\r\n    for (uint256 i = 0; i < _addressCards.length; i++) {\r\n      AddressCard memory addressCard = _addressCards[i];\r\n      allCardsClaimContender[i] = bytes4(_indexOf[addressCard._claimContender]);\r\n    }\r\n    return allCardsClaimContender;\r\n\r\n  }\r\n\r\n  function getAllOwnersOfCard(address cardAddress) public view returns (bytes4[]) {\r\n    \r\n    require(cardAddressExists(cardAddress));\r\n\r\n    // returns the indexes of the owners\r\n    address[] memory ownersOfCardAddress = _ownersOf[cardAddress];\r\n    bytes4[] memory allOwners = new bytes4[](ownersOfCardAddress.length);\r\n    for (uint256 i = 0; i < ownersOfCardAddress.length; i++) {\r\n      allOwners[i] = bytes4(_indexOf[ownersOfCardAddress[i]]);\r\n    }\r\n    return allOwners;\r\n\r\n  }\r\n\r\n  function getAllOwnersClaimPriceOfCard(address cardAddress) public view returns (bytes32[]) {\r\n    \r\n    require(cardAddressExists(cardAddress));\r\n\r\n    uint256[] memory ownersClaimPriceOfCardAddress = _ownersClaimPriceOf[cardAddress];\r\n    bytes32[] memory allOwnersClaimPrice = new bytes32[](ownersClaimPriceOfCardAddress.length);\r\n    for (uint256 i = 0; i < ownersClaimPriceOfCardAddress.length; i++) {\r\n      allOwnersClaimPrice[i] = bytes32(ownersClaimPriceOfCardAddress[i]);\r\n    }\r\n    return allOwnersClaimPrice;\r\n\r\n  }\r\n\r\n  function getAllCardAddressesOfOwner(address owner) public view returns (bytes4[]) {\r\n    \r\n    require(cardAddressExists(owner));\r\n\r\n    // returns the indexes of the cards owned\r\n    address[] memory cardsOfOwner = _cardsOf[owner];\r\n    bytes4[] memory allCardAddresses = new bytes4[](cardsOfOwner.length);\r\n    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\r\n      allCardAddresses[i] = bytes4(_indexOf[cardsOfOwner[i]]);\r\n    }\r\n    return allCardAddresses;\r\n\r\n  }\r\n\r\n  function getAllCardAddressesCountOfOwner(address owner) public view returns (bytes1[]) {\r\n    \r\n    require(cardAddressExists(owner));\r\n\r\n    address[] memory cardsOfOwner = _cardsOf[owner];\r\n    bytes1[] memory allCardAddressesCount = new bytes1[](cardsOfOwner.length);\r\n    for (uint256 i = 0; i < cardsOfOwner.length; i++) {\r\n      allCardAddressesCount[i] = bytes1(ownerCountOfCard(owner, cardsOfOwner[i]));\r\n    }\r\n    return allCardAddressesCount;\r\n\r\n  }\r\n\r\n\r\n  //////////////////////////////////////////////////////////////////////\r\n  \r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (ie if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"ownerHasCard\",\"outputs\":[{\"name\":\"doesOwn\",\"type\":\"bool\"},{\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tmpSeed\",\"type\":\"uint256\"},{\"name\":\"mix\",\"type\":\"uint256\"}],\"name\":\"tmpShuffleSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"cancelWagerOfCard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wagerCardForAmount\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsType\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsLowestPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAllCardAddressesOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsForClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enlist\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"getCheapestCardWager\",\"outputs\":[{\"name\":\"cheapestIndex\",\"type\":\"uint256\"},{\"name\":\"isClaimable\",\"type\":\"bool\"},{\"name\":\"claimContender\",\"type\":\"address\"},{\"name\":\"claimPrice\",\"type\":\"uint256\"},{\"name\":\"wagerCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalUniqueCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tmpSeed\",\"type\":\"uint256\"},{\"name\":\"modulus\",\"type\":\"uint256\"}],\"name\":\"tmpQuerySeed\",\"outputs\":[{\"name\":\"tmpShuffledSeed\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsAttack\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"getAllOwnersOfCard\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsModifier\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAllCardAddressesCountOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getCardIndexOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsModifierPrimaryVal\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsDefence\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"getOwnerOfCardsCheapestWager\",\"outputs\":[{\"name\":\"cheapestIndex\",\"type\":\"uint256\"},{\"name\":\"isSelling\",\"type\":\"bool\"},{\"name\":\"claimPrice\",\"type\":\"uint256\"},{\"name\":\"priceRank\",\"type\":\"uint256\"},{\"name\":\"outOf\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"getAllOwnersClaimPriceOfCard\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"},{\"name\":\"choices\",\"type\":\"address[3]\"}],\"name\":\"attemptToClaimCard\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsModifierSecondaryVal\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"cardAddressExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"},{\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"transferCardTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalanceOfSender\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"ownerCountOfCard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsClaimContender\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"getCard\",\"outputs\":[{\"name\":\"cardIndex\",\"type\":\"uint256\"},{\"name\":\"cardType\",\"type\":\"uint256\"},{\"name\":\"cardModifier\",\"type\":\"uint256\"},{\"name\":\"cardModifierPrimaryVal\",\"type\":\"uint256\"},{\"name\":\"cardModifierSecondaryVal\",\"type\":\"uint256\"},{\"name\":\"attack\",\"type\":\"uint256\"},{\"name\":\"defence\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"uint256\"},{\"name\":\"forClaim\",\"type\":\"uint256\"},{\"name\":\"lowestPrice\",\"type\":\"uint256\"},{\"name\":\"claimContender\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllCardsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes20[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"cardAddress\",\"type\":\"address\"}],\"name\":\"indexOfCardAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"enlistedAddress\",\"type\":\"address\"}],\"name\":\"AddressDidEnlist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addressCard\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wagerAmount\",\"type\":\"uint256\"}],\"name\":\"AddressCardWasWagered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addressCard\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AddressCardWagerWasCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addressCard\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"AddressCardWasTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wasSuccessful\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"addressCard\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"claimContender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"claimerChoices\",\"type\":\"address[3]\"},{\"indexed\":false,\"name\":\"claimContenderChoices\",\"type\":\"address[3]\"},{\"indexed\":false,\"name\":\"allFinalAttackValues\",\"type\":\"uint256[3][2]\"},{\"indexed\":false,\"name\":\"allFinalDefenceValues\",\"type\":\"uint256[3][2]\"}],\"name\":\"ClaimAttempt\",\"type\":\"event\"}]","ContractName":"AddressWarsBeta","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b480d5e4d57d74a36d2ac2ce9129561de063052641a29242393cb194aab9381c"}]}