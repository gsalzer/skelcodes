{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Token name: KT\r\n * Interface: ERC721\r\n * This token is established by Krypital Group LLC, mainly used as a gift for Krypital supporters.\r\n * Total supply of KTs is set to 2100.\r\n * A KT holder can either hold it as a souvenir (leave message on the message board), or play the game by merging/decomposing tokens.\r\n */\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/**\r\n * @title safemath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary safemath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ownable\r\n * @dev The ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor () public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract erc721 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function transfer(address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function takeOwnership(uint256 _tokenId) public;\r\n}\r\n\r\n\r\n/**\r\n *  @title KTaccess\r\n *  @author Yihan -- CyberMiles\r\n *  @dev This contract is for regulating the owners' addr.\r\n *  Inherited by KTfactory.\r\n */\r\ncontract KTaccess is ownable{\r\n    address public o1Address;\r\n    address public o2Address;\r\n    address public o3Address;\r\n    \r\n    modifier onlyOLevel() {\r\n        require(\r\n            msg.sender == o1Address ||\r\n            msg.sender == o2Address ||\r\n            msg.sender == o3Address ||\r\n            msg.sender == owner\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setO1(address _newAddr) external onlyOLevel {\r\n        require(_newAddr != address(0));\r\n\r\n        o1Address = _newAddr;\r\n    }\r\n\r\n    function setO2(address _newAddr) external onlyOLevel {\r\n        require(_newAddr != address(0));\r\n\r\n        o2Address = _newAddr;\r\n    }\r\n    \r\n    function setO3(address _newAddr) external onlyOLevel {\r\n        require(_newAddr != address(0));\r\n\r\n        o3Address = _newAddr;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title KTfactory\r\n * @author Yihan -- CyberMiles\r\n * @dev This main contract for creating KTs.\r\n * \r\n * A KT, which is the token issued by Krypital, has the following properties: \r\n * an officail note that can be created only by the contract owner;\r\n * a personal note that can be modified by the current owner of the token;\r\n * a bool value indicating if the token is currently frozen by Krypital;\r\n * a gene which is a hashed value that changes when mutate (merge or decompose). This is for some future interesting apps :D \r\n * level, namely, the level of the token. Apparently higher is better :D\r\n * id, the key used to map to the associated KT.\r\n * \r\n */\r\n\r\ncontract KTfactory is ownable, KTaccess {\r\n\r\n  using safemath for uint256;\r\n\r\n  uint256 public maxId;\r\n\r\n  uint256 public initial_supply;\r\n\r\n  uint256 public curr_number;\r\n\r\n  event NewKT(string note, uint256 gene, uint256 level, uint256 tokenId);\r\n  event UpdateNote(string newNote, uint256 tokenId);\r\n  event PauseToken(uint256 tokenId);\r\n  event UnpauseToken(uint256 tokenId);\r\n\r\n  struct KT {\r\n    string officialNote;\r\n    string personalNote;\r\n    bool paused;\r\n    uint256 gene;\r\n    uint256 level;\r\n    uint256 id;\r\n  }\r\n\r\n  mapping (uint256 => KT) public KTs;\r\n\r\n  mapping (uint => address) public KTToOwner;\r\n  mapping (address => uint) ownerKTCount;\r\n\r\n  modifier onlyOwnerOf(uint token_id) {\r\n    require(msg.sender == KTToOwner[token_id]);\r\n    _;\r\n  }\r\n\r\n  modifier whenNotFrozen(uint token_id) {\r\n    require(KTs[token_id].paused == false);\r\n    _;\r\n  }\r\n\r\n  modifier withinTotal() {\r\n    require(curr_number<= initial_supply);\r\n    _;\r\n  }\r\n\r\n  modifier hasKT(uint token_id) {\r\n    require(KTs[token_id].id != 0);\r\n    _;\r\n  }\r\n    \r\n    /**\r\n     * @dev The constructor. Sets the initial supply and some other global variables.\r\n     * That's right, Krypital will only issue 2100 tokens in total. It also means the total number of KTs will not exceed this number!\r\n     */\r\n  constructor() public {\r\n    initial_supply = 2100;\r\n    maxId=0;\r\n    curr_number=0;\r\n  }\r\n\r\n    /**\r\n     * @dev The creator of KTs. Only done by Krypital.\r\n     * @param oNote - the official, special note left only by Krypital!\r\n     */\r\n  function _createKT(string oNote) public onlyOLevel withinTotal {\r\n    uint thisId = maxId + 1;\r\n    string pNote;\r\n    uint256 thisGene = uint256(keccak256(oNote));\r\n    \r\n    KT memory thisKT = KT({\r\n        officialNote: oNote, \r\n        personalNote: pNote, \r\n        paused: false, \r\n        gene: thisGene, \r\n        level: 1, \r\n        id: thisId\r\n    });\r\n    \r\n    KTs[thisId] = thisKT;\r\n    maxId = maxId + 1;\r\n    curr_number = curr_number + 1;\r\n    KTToOwner[thisId] = msg.sender;\r\n    ownerKTCount[msg.sender]++;\r\n    emit NewKT(oNote, thisGene, 1, thisId);\r\n  }\r\n    \r\n    /**\r\n     * @dev This method is for editing your personal note!\r\n     * @param note - the note you want the old one to be replaced by\r\n     * @param token_id - just token id\r\n     */\r\n  function _editPersonalNote(string note, uint token_id) public onlyOwnerOf(token_id) hasKT(token_id){\r\n    KT storage currKT = KTs[token_id];\r\n    currKT.personalNote = note;\r\n    emit UpdateNote(note, token_id);\r\n  }\r\n    \r\n    /**\r\n     * @dev Pauses a token, done by Krypital\r\n     * When a token is paused by Krypital, the owner of the token can still update the personal note but the ownership cannot be transferred.\r\n     * @param token_id - just token id\r\n     */\r\n  function pauseToken(uint token_id) public onlyOLevel hasKT(token_id){\r\n    KT storage currKT = KTs[token_id];\r\n    currKT.paused = true;\r\n    emit PauseToken(token_id);\r\n  }\r\n  \r\n  /**\r\n   * @dev Unpauses a token, done by Krypital\r\n   * @param token_id - just token id\r\n   */\r\n  function unpauseToken(uint token_id) public onlyOLevel hasKT(token_id){\r\n    KT storage currKT = KTs[token_id];\r\n    currKT.paused = false;\r\n    emit UnpauseToken(token_id);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title KT\r\n * @author Yihan -- CyberMiles\r\n * @dev This contract is the contract regulating the transfer, decomposition, merging mechanism amaong the tokens.\r\n */\r\ncontract KT is KTfactory, erc721 {\r\n\r\n  using safemath for uint256;\r\n\r\n  mapping (uint => address) KTApprovals;\r\n  \r\n  /**\r\n   * @dev The modifer to regulate a KT's decomposability.\r\n   * A level 1 KT is not decomposable.\r\n   * @param token_id - simply token id.\r\n   */\r\n  modifier decomposeAllowed(uint token_id){\r\n    require(KTs[token_id].level > 1);\r\n    _;\r\n  }\r\n\r\n  event Decompose(uint256 tokenId);\r\n  event Merge(uint256 tokenId1, uint256 tokenId2);\r\n\r\n    /**\r\n     * @dev This is for getting the ether back to the contract owner's account. Just in case someone generous sends the creator some ethers :P\r\n     */\r\n  function withdraw() external onlyOwner {\r\n    owner.transfer(this.balance);\r\n  }\r\n\r\n    /**\r\n     * @dev For checking how many tokens you own.\r\n     * @param _owner - the owner's addr\r\n     */\r\n  function balanceOf(address _owner) public view returns(uint256) {\r\n    return ownerKTCount[_owner];\r\n  }\r\n    \r\n    /**\r\n     * @dev For checking the owner of the given token.\r\n     * @param _tokenId - just token id\r\n     */\r\n  function ownerOf(uint256 _tokenId) public view returns(address) {\r\n    return KTToOwner[_tokenId];\r\n  }\r\n\r\n    /**\r\n     * @dev the private helper function for transfering ownership.\r\n     * @param _from - current KT owner\r\n     * @param _to - new KT owner\r\n     * @param _tokenId - just token id\r\n     */\r\n  function _transfer(address _from, address _to, uint256 _tokenId) private hasKT(_tokenId) {\r\n    ownerKTCount[_to] = ownerKTCount[_to].add(1);\r\n    ownerKTCount[msg.sender] = ownerKTCount[msg.sender].sub(1);\r\n    KTToOwner[_tokenId] = _to;\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n    /**\r\n     * @dev This method can be called if you are the token owner and you want to transfer the token to someone else.\r\n     * @param _to - new KT owner\r\n     * @param _tokenId - just token id\r\n     */\r\n  function transfer(address _to, uint256 _tokenId) public whenNotFrozen(_tokenId) onlyOwnerOf(_tokenId) hasKT(_tokenId){\r\n    require(_to != address(0));\r\n    _transfer(msg.sender, _to, _tokenId);\r\n  }\r\n    \r\n    /**\r\n     * @dev An approved user can 'claim' a token of another user.\r\n     * @param _to - new KT owner\r\n     * @param _tokenId - just token id\r\n     */\r\n  function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) hasKT(_tokenId) {\r\n    require(_to != address(0));\r\n    KTApprovals[_tokenId] = _to;\r\n    emit Approval(msg.sender, _to, _tokenId);\r\n  }\r\n    \r\n    /**\r\n     * @dev The user to be approved must be approved by the current token holder.\r\n     * @param _tokenId - just token id\r\n     */\r\n  function takeOwnership(uint256 _tokenId) public whenNotFrozen(_tokenId) hasKT(_tokenId){\r\n    require(KTApprovals[_tokenId] == msg.sender);\r\n    address owner = ownerOf(_tokenId);\r\n    _transfer(owner, msg.sender, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev This method is for decomposing (or split) a token. Only can be done by token holder when token is not frozen.\r\n   * Note: one of the tokens will take the original token's place, that is, the old ID will actually map to a new token!\r\n   * Level down by 1!!! A level 1 token cannot be decomposed.\r\n   * The genes of the two new born tokens will be both identical to the old token.\r\n   * Notes of the two new tokens are identical to the original token.\r\n   */\r\n  function decompose(uint256 token_id) public whenNotFrozen(token_id) onlyOwnerOf(token_id) decomposeAllowed(token_id) hasKT(token_id) withinTotal{\r\n    KT storage decomposed = KTs[token_id];\r\n    decomposed.level = decomposed.level-1;\r\n    decomposed.gene = decomposed.gene/2;\r\n\r\n    KT memory newKT = KT({\r\n      officialNote: decomposed.officialNote,\r\n      personalNote: decomposed.personalNote,\r\n      paused: false,\r\n      gene: decomposed.gene,\r\n      level: decomposed.level,\r\n      id: maxId.add(1)\r\n    });\r\n    \r\n    maxId=maxId.add(1);\r\n    curr_number=curr_number.add(1);\r\n    KTs[maxId]=newKT;\r\n    KTToOwner[maxId]=KTToOwner[token_id];\r\n    ownerKTCount[msg.sender]=ownerKTCount[msg.sender].add(1);\r\n\r\n    emit Decompose(token_id);\r\n  }\r\n\r\n    /**\r\n     * @dev This function is for merging 2 tokens. Only tokens with the same levels can be merge. A user can only choose to merge from his own tokens.\r\n     * After merging, id and official note are merged to the previous token passed in the args.\r\n     * NOTE that the notes associated with the second token will be wiped out! Use with your caution.\r\n     * Level up by 1!!!\r\n     * New gene = (gene1 + gene2) / 2\r\n     * @param id1 - the ID to the 1st token, this ID will remain after merging.\r\n     * @param id2 - the ID of the 2nd token, this ID will map to nothing after merging!!\r\n     */\r\n  function merge(uint256 id1, uint256 id2) public hasKT(id1) hasKT(id2) whenNotFrozen(id1) whenNotFrozen(id2) onlyOwnerOf(id1) onlyOwnerOf(id2){\r\n    require(KTs[id1].level == KTs[id2].level);\r\n    KT storage token1 = KTs[id1];\r\n    token1.gene = (token1.gene + KTs[id2].gene) / 2;\r\n    token1.level = (token1.level).add(1);\r\n\r\n    KT memory toDelete = KT ({\r\n      officialNote: \"\",\r\n      personalNote: \"\",\r\n      paused: false,\r\n      gene: 0,\r\n      level: 0,\r\n      id: 0\r\n    });\r\n\r\n    KTs[id2] = toDelete;\r\n    curr_number = curr_number.sub(1);\r\n    KTToOwner[id2] = address(0);\r\n    ownerKTCount[msg.sender] = ownerKTCount[msg.sender].sub(1);\r\n\r\n    emit Merge(id1, id2);\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"o3Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"setO1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initial_supply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"KTToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"o2Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"setO2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"KTs\",\"outputs\":[{\"name\":\"officialNote\",\"type\":\"string\"},{\"name\":\"personalNote\",\"type\":\"string\"},{\"name\":\"paused\",\"type\":\"bool\"},{\"name\":\"gene\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"unpauseToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oNote\",\"type\":\"string\"}],\"name\":\"_createKT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"note\",\"type\":\"string\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"_editPersonalNote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddr\",\"type\":\"address\"}],\"name\":\"setO3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id1\",\"type\":\"uint256\"},{\"name\":\"id2\",\"type\":\"uint256\"}],\"name\":\"merge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"decompose\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"o1Address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curr_number\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"pauseToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Decompose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenId2\",\"type\":\"uint256\"}],\"name\":\"Merge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"note\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"gene\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NewKT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newNote\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"UpdateNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PauseToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"UnpauseToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"KT","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e638026d083b731cd925adf74e8d5d86518002c3d00f4b0d0bf4306e2b72ce61"}]}