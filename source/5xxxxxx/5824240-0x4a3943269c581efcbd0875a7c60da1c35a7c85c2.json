{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSExec {\r\n    function tryExec( address target, bytes calldata, uint value)\r\n             internal\r\n             returns (bool call_ret)\r\n    {\r\n        return target.call.value(value)(calldata);\r\n    }\r\n    function exec( address target, bytes calldata, uint value)\r\n             internal\r\n    {\r\n        if(!tryExec(target, calldata, value)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    // Convenience aliases\r\n    function exec( address t, bytes c )\r\n        internal\r\n    {\r\n        exec(t, c, 0);\r\n    }\r\n    function exec( address t, uint256 v )\r\n        internal\r\n    {\r\n        bytes memory c; exec(t, c, v);\r\n    }\r\n    function tryExec( address t, bytes c )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return tryExec(t, c, 0);\r\n    }\r\n    function tryExec( address t, uint256 v )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        bytes memory c; return tryExec(t, c, v);\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSGroup is DSExec, DSNote {\r\n    address[]  public  members;\r\n    uint       public  quorum;\r\n    uint       public  window;\r\n    uint       public  actionCount;\r\n\r\n    mapping (uint => Action)                     public  actions;\r\n    mapping (uint => mapping (address => bool))  public  confirmedBy;\r\n    mapping (address => bool)                    public  isMember;\r\n\r\n    // Legacy events\r\n    event Proposed   (uint id, bytes calldata);\r\n    event Confirmed  (uint id, address member);\r\n    event Triggered  (uint id);\r\n\r\n    struct Action {\r\n        address  target;\r\n        bytes    calldata;\r\n        uint     value;\r\n\r\n        uint     confirmations;\r\n        uint     deadline;\r\n        bool     triggered;\r\n    }\r\n\r\n    function DSGroup(\r\n        address[]  members_,\r\n        uint       quorum_,\r\n        uint       window_\r\n    ) {\r\n        members  = members_;\r\n        quorum   = quorum_;\r\n        window   = window_;\r\n\r\n        for (uint i = 0; i < members.length; i++) {\r\n            isMember[members[i]] = true;\r\n        }\r\n    }\r\n\r\n    function memberCount() constant returns (uint) {\r\n        return members.length;\r\n    }\r\n\r\n    function target(uint id) constant returns (address) {\r\n        return actions[id].target;\r\n    }\r\n    function calldata(uint id) constant returns (bytes) {\r\n        return actions[id].calldata;\r\n    }\r\n    function value(uint id) constant returns (uint) {\r\n        return actions[id].value;\r\n    }\r\n\r\n    function confirmations(uint id) constant returns (uint) {\r\n        return actions[id].confirmations;\r\n    }\r\n    function deadline(uint id) constant returns (uint) {\r\n        return actions[id].deadline;\r\n    }\r\n    function triggered(uint id) constant returns (bool) {\r\n        return actions[id].triggered;\r\n    }\r\n\r\n    function confirmed(uint id) constant returns (bool) {\r\n        return confirmations(id) >= quorum;\r\n    }\r\n    function expired(uint id) constant returns (bool) {\r\n        return now > deadline(id);\r\n    }\r\n\r\n    function deposit() note payable {\r\n    }\r\n\r\n    function propose(\r\n        address  target,\r\n        bytes    calldata,\r\n        uint     value\r\n    ) onlyMembers note returns (uint id) {\r\n        id = ++actionCount;\r\n\r\n        actions[id].target    = target;\r\n        actions[id].calldata  = calldata;\r\n        actions[id].value     = value;\r\n        actions[id].deadline  = now + window;\r\n\r\n        Proposed(id, calldata);\r\n    }\r\n\r\n    function confirm(uint id) onlyMembers onlyActive(id) note {\r\n        assert(!confirmedBy[id][msg.sender]);\r\n\r\n        confirmedBy[id][msg.sender] = true;\r\n        actions[id].confirmations++;\r\n\r\n        Confirmed(id, msg.sender);\r\n    }\r\n\r\n    function trigger(uint id) onlyMembers onlyActive(id) note {\r\n        assert(confirmed(id));\r\n\r\n        actions[id].triggered = true;\r\n        exec(actions[id].target, actions[id].calldata, actions[id].value);\r\n\r\n        Triggered(id);\r\n    }\r\n\r\n    modifier onlyMembers {\r\n        assert(isMember[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyActive(uint id) {\r\n        assert(!expired(id));\r\n        assert(!triggered(id));\r\n        _;\r\n    }\r\n\r\n    //------------------------------------------------------------------\r\n    // Legacy functions\r\n    //------------------------------------------------------------------\r\n\r\n    function getInfo() constant returns (\r\n        uint  quorum_,\r\n        uint  memberCount,\r\n        uint  window_,\r\n        uint  actionCount_\r\n    ) {\r\n        return (quorum, members.length, window, actionCount);\r\n    }\r\n\r\n    function getActionStatus(uint id) constant returns (\r\n        uint     confirmations,\r\n        uint     deadline,\r\n        bool     triggered,\r\n        address  target,\r\n        uint     value\r\n    ) {\r\n        return (\r\n            actions[id].confirmations,\r\n            actions[id].deadline,\r\n            actions[id].triggered,\r\n            actions[id].target,\r\n            actions[id].value\r\n        );\r\n    }\r\n}\r\n\r\ncontract DSGroupFactory is DSNote {\r\n    mapping (address => bool)  public  isGroup;\r\n\r\n    function newGroup(\r\n        address[]  members,\r\n        uint       quorum,\r\n        uint       window\r\n    ) note returns (DSGroup group) {\r\n        group = new DSGroup(members, quorum, window);\r\n        isGroup[group] = true;\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(s));\r\n    }\r\n\r\n}\r\n\r\ncontract WETH9_ {\r\n    string public name     = \"Wrapped Ether\";\r\n    string public symbol   = \"WETH\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function() public payable {\r\n        deposit();\r\n    }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface FundInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PortfolioContent(address[] assets, uint[] holdings, uint[] prices);\r\n    event RequestUpdated(uint id);\r\n    event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);\r\n    event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);\r\n    event ErrorMessage(string errorMessage);\r\n\r\n    // EXTERNAL METHODS\r\n    // Compliance by Investor\r\n    function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external;\r\n    function executeRequest(uint requestId) external;\r\n    function cancelRequest(uint requestId) external;\r\n    function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);\r\n    // Administration by Manager\r\n    function enableInvestment(address[] ofAssets) external;\r\n    function disableInvestment(address[] ofAssets) external;\r\n    function shutDown() external;\r\n\r\n    // PUBLIC METHODS\r\n    function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);\r\n    function calcSharePriceAndAllocateFees() public returns (uint);\r\n\r\n\r\n    // PUBLIC VIEW METHODS\r\n    // Get general information\r\n    function getModules() view returns (address, address, address);\r\n    function getLastRequestId() view returns (uint);\r\n    function getManager() view returns (address);\r\n\r\n    // Get accounting information\r\n    function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);\r\n    function calcSharePrice() view returns (uint);\r\n}\r\n\r\ninterface AssetInterface {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    // Events\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n\r\n    //ERC 223\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\r\n\r\n    // ERC 20\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    // PUBLIC VIEW METHODS\r\n    function balanceOf(address _owner) view public returns (uint balance);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract Asset is DSMath, ERC20Interface {\r\n\r\n    // DATA STRUCTURES\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public _totalSupply;\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    /// @notice Restriction: An account can only use this function to send to itself\r\n    /// @dev Allows for an approved third party to transfer tokens from one\r\n    /// address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n        // require(_to == msg.sender); // can only use transferFrom to send to self\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(_spender != address(0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @dev Returns number of allowed tokens that a spender can transfer on\r\n    /// behalf of a token owner.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    /// @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by the given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns balance of owner.\r\n    function balanceOf(address _owner) constant public returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function totalSupply() view public returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ninterface SharesInterface {\r\n\r\n    event Created(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n    event Annihilated(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\r\n\r\n    // VIEW METHODS\r\n\r\n    function getName() view returns (bytes32);\r\n    function getSymbol() view returns (bytes8);\r\n    function getDecimals() view returns (uint);\r\n    function getCreationTime() view returns (uint);\r\n    function toSmallestShareUnit(uint quantity) view returns (uint);\r\n    function toWholeShareUnit(uint quantity) view returns (uint);\r\n\r\n}\r\n\r\ncontract Shares is SharesInterface, Asset {\r\n\r\n    // FIELDS\r\n\r\n    // Constructor fields\r\n    bytes32 public name;\r\n    bytes8 public symbol;\r\n    uint public decimal;\r\n    uint public creationTime;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param _name Name these shares\r\n    /// @param _symbol Symbol of shares\r\n    /// @param _decimal Amount of decimals sharePrice is denominated in, defined to be equal as deciamls in REFERENCE_ASSET contract\r\n    /// @param _creationTime Timestamp of share creation\r\n    function Shares(bytes32 _name, bytes8 _symbol, uint _decimal, uint _creationTime) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimal = _decimal;\r\n        creationTime = _creationTime;\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getName() view returns (bytes32) { return name; }\r\n    function getSymbol() view returns (bytes8) { return symbol; }\r\n    function getDecimals() view returns (uint) { return decimal; }\r\n    function getCreationTime() view returns (uint) { return creationTime; }\r\n    function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }\r\n    function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @param recipient Address the new shares should be sent to\r\n    /// @param shareQuantity Number of shares to be created\r\n    function createShares(address recipient, uint shareQuantity) internal {\r\n        _totalSupply = add(_totalSupply, shareQuantity);\r\n        balances[recipient] = add(balances[recipient], shareQuantity);\r\n        emit Created(msg.sender, now, shareQuantity);\r\n        emit Transfer(address(0), recipient, shareQuantity);\r\n    }\r\n\r\n    /// @param recipient Address the new shares should be taken from when destroyed\r\n    /// @param shareQuantity Number of shares to be annihilated\r\n    function annihilateShares(address recipient, uint shareQuantity) internal {\r\n        _totalSupply = sub(_totalSupply, shareQuantity);\r\n        balances[recipient] = sub(balances[recipient], shareQuantity);\r\n        emit Annihilated(msg.sender, now, shareQuantity);\r\n        emit Transfer(recipient, address(0), shareQuantity);\r\n    }\r\n}\r\n\r\ninterface ComplianceInterface {\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks whether investment is permitted for a participant\r\n    /// @param ofParticipant Address requesting to invest in a Melon fund\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    /// @return Whether identity is eligible to invest in a Melon fund.\r\n    function isInvestmentPermitted(\r\n        address ofParticipant,\r\n        uint256 giveQuantity,\r\n        uint256 shareQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks whether redemption is permitted for a participant\r\n    /// @param ofParticipant Address requesting to redeem from a Melon fund\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 offered to redeem\r\n    /// @param receiveQuantity Quantity of Melon token times 10 ** 18 requested to receive for shareQuantity\r\n    /// @return Whether identity is eligible to redeem from a Melon fund.\r\n    function isRedemptionPermitted(\r\n        address ofParticipant,\r\n        uint256 shareQuantity,\r\n        uint256 receiveQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ncontract DBC {\r\n\r\n    // MODIFIERS\r\n\r\n    modifier pre_cond(bool condition) {\r\n        require(condition);\r\n        _;\r\n    }\r\n\r\n    modifier post_cond(bool condition) {\r\n        _;\r\n        assert(condition);\r\n    }\r\n\r\n    modifier invariant(bool condition) {\r\n        require(condition);\r\n        _;\r\n        assert(condition);\r\n    }\r\n}\r\n\r\ncontract Owned is DBC {\r\n\r\n    // FIELDS\r\n\r\n    address public owner;\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    function isOwner() internal returns (bool) { return msg.sender == owner; }\r\n\r\n}\r\n\r\ncontract Fund is DSMath, DBC, Owned, Shares, FundInterface {\r\n\r\n    event OrderUpdated(address exchange, bytes32 orderId, UpdateType updateType);\r\n\r\n    // TYPES\r\n\r\n    struct Modules { // Describes all modular parts, standardised through an interface\r\n        CanonicalPriceFeed pricefeed; // Provides all external data\r\n        ComplianceInterface compliance; // Boolean functions regarding invest/redeem\r\n        RiskMgmtInterface riskmgmt; // Boolean functions regarding make/take orders\r\n    }\r\n\r\n    struct Calculations { // List of internal calculations\r\n        uint gav; // Gross asset value\r\n        uint managementFee; // Time based fee\r\n        uint performanceFee; // Performance based fee measured against QUOTE_ASSET\r\n        uint unclaimedFees; // Fees not yet allocated to the fund manager\r\n        uint nav; // Net asset value\r\n        uint highWaterMark; // A record of best all-time fund performance\r\n        uint totalSupply; // Total supply of shares\r\n        uint timestamp; // Time when calculations are performed in seconds\r\n    }\r\n\r\n    enum UpdateType { make, take, cancel }\r\n    enum RequestStatus { active, cancelled, executed }\r\n    struct Request { // Describes and logs whenever asset enter and leave fund due to Participants\r\n        address participant; // Participant in Melon fund requesting investment or redemption\r\n        RequestStatus status; // Enum: active, cancelled, executed; Status of request\r\n        address requestAsset; // Address of the asset being requested\r\n        uint shareQuantity; // Quantity of Melon fund shares\r\n        uint giveQuantity; // Quantity in Melon asset to give to Melon fund to receive shareQuantity\r\n        uint receiveQuantity; // Quantity in Melon asset to receive from Melon fund for given shareQuantity\r\n        uint timestamp;     // Time of request creation in seconds\r\n        uint atUpdateId;    // Pricefeed updateId when this request was created\r\n    }\r\n\r\n    struct Exchange {\r\n        address exchange;\r\n        address exchangeAdapter;\r\n        bool takesCustody;  // exchange takes custody before making order\r\n    }\r\n\r\n    struct OpenMakeOrder {\r\n        uint id; // Order Id from exchange\r\n        uint expiresAt; // Timestamp when the order expires\r\n    }\r\n\r\n    struct Order { // Describes an order event (make or take order)\r\n        address exchangeAddress; // address of the exchange this order is on\r\n        bytes32 orderId; // Id as returned from exchange\r\n        UpdateType updateType; // Enum: make, take (cancel should be ignored)\r\n        address makerAsset; // Order maker's asset\r\n        address takerAsset; // Order taker's asset\r\n        uint makerQuantity; // Quantity of makerAsset to be traded\r\n        uint takerQuantity; // Quantity of takerAsset to be traded\r\n        uint timestamp; // Time of order creation in seconds\r\n        uint fillTakerQuantity; // Quantity of takerAsset to be filled\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // Constant fields\r\n    uint public constant MAX_FUND_ASSETS = 20; // Max ownable assets by the fund supported by gas limits\r\n    uint public constant ORDER_EXPIRATION_TIME = 86400; // Make order expiration time (1 day)\r\n    // Constructor fields\r\n    uint public MANAGEMENT_FEE_RATE; // Fee rate in QUOTE_ASSET per managed seconds in WAD\r\n    uint public PERFORMANCE_FEE_RATE; // Fee rate in QUOTE_ASSET per delta improvement in WAD\r\n    address public VERSION; // Address of Version contract\r\n    Asset public QUOTE_ASSET; // QUOTE asset as ERC20 contract\r\n    // Methods fields\r\n    Modules public modules; // Struct which holds all the initialised module instances\r\n    Exchange[] public exchanges; // Array containing exchanges this fund supports\r\n    Calculations public atLastUnclaimedFeeAllocation; // Calculation results at last allocateUnclaimedFees() call\r\n    Order[] public orders;  // append-only list of makes/takes from this fund\r\n    mapping (address => mapping(address => OpenMakeOrder)) public exchangesToOpenMakeOrders; // exchangeIndex to: asset to open make orders\r\n    bool public isShutDown; // Security feature, if yes than investing, managing, allocateUnclaimedFees gets blocked\r\n    Request[] public requests; // All the requests this fund received from participants\r\n    mapping (address => bool) public isInvestAllowed; // If false, fund rejects investments from the key asset\r\n    address[] public ownedAssets; // List of all assets owned by the fund or for which the fund has open make orders\r\n    mapping (address => bool) public isInAssetList; // Mapping from asset to whether the asset exists in ownedAssets\r\n    mapping (address => bool) public isInOpenMakeOrder; // Mapping from asset to whether the asset is in a open make order as buy asset\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Should only be called via Version.setupFund(..)\r\n    /// @param withName human-readable descriptive name (not necessarily unique)\r\n    /// @param ofQuoteAsset Asset against which mgmt and performance fee is measured against and which can be used to invest using this single asset\r\n    /// @param ofManagementFee A time based fee expressed, given in a number which is divided by 1 WAD\r\n    /// @param ofPerformanceFee A time performance based fee, performance relative to ofQuoteAsset, given in a number which is divided by 1 WAD\r\n    /// @param ofCompliance Address of compliance module\r\n    /// @param ofRiskMgmt Address of risk management module\r\n    /// @param ofPriceFeed Address of price feed module\r\n    /// @param ofExchanges Addresses of exchange on which this fund can trade\r\n    /// @param ofDefaultAssets Addresses of assets to enable invest for (quote asset is already enabled)\r\n    /// @return Deployed Fund with manager set as ofManager\r\n    function Fund(\r\n        address ofManager,\r\n        bytes32 withName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address ofPriceFeed,\r\n        address[] ofExchanges,\r\n        address[] ofDefaultAssets\r\n    )\r\n        Shares(withName, \"MLNF\", 18, now)\r\n    {\r\n        require(ofManagementFee < 10 ** 18); // Require management fee to be less than 100 percent\r\n        require(ofPerformanceFee < 10 ** 18); // Require performance fee to be less than 100 percent\r\n        isInvestAllowed[ofQuoteAsset] = true;\r\n        owner = ofManager;\r\n        MANAGEMENT_FEE_RATE = ofManagementFee; // 1 percent is expressed as 0.01 * 10 ** 18\r\n        PERFORMANCE_FEE_RATE = ofPerformanceFee; // 1 percent is expressed as 0.01 * 10 ** 18\r\n        VERSION = msg.sender;\r\n        modules.compliance = ComplianceInterface(ofCompliance);\r\n        modules.riskmgmt = RiskMgmtInterface(ofRiskMgmt);\r\n        modules.pricefeed = CanonicalPriceFeed(ofPriceFeed);\r\n        // Bridged to Melon exchange interface by exchangeAdapter library\r\n        for (uint i = 0; i < ofExchanges.length; ++i) {\r\n            require(modules.pricefeed.exchangeIsRegistered(ofExchanges[i]));\r\n            var (ofExchangeAdapter, takesCustody, ) = modules.pricefeed.getExchangeInformation(ofExchanges[i]);\r\n            exchanges.push(Exchange({\r\n                exchange: ofExchanges[i],\r\n                exchangeAdapter: ofExchangeAdapter,\r\n                takesCustody: takesCustody\r\n            }));\r\n        }\r\n        QUOTE_ASSET = Asset(ofQuoteAsset);\r\n        // Quote Asset always in owned assets list\r\n        ownedAssets.push(ofQuoteAsset);\r\n        isInAssetList[ofQuoteAsset] = true;\r\n        require(address(QUOTE_ASSET) == modules.pricefeed.getQuoteAsset()); // Sanity check\r\n        for (uint j = 0; j < ofDefaultAssets.length; j++) {\r\n            require(modules.pricefeed.assetIsRegistered(ofDefaultAssets[j]));\r\n            isInvestAllowed[ofDefaultAssets[j]] = true;\r\n        }\r\n        atLastUnclaimedFeeAllocation = Calculations({\r\n            gav: 0,\r\n            managementFee: 0,\r\n            performanceFee: 0,\r\n            unclaimedFees: 0,\r\n            nav: 0,\r\n            highWaterMark: 10 ** getDecimals(),\r\n            totalSupply: _totalSupply,\r\n            timestamp: now\r\n        });\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    // EXTERNAL : ADMINISTRATION\r\n\r\n    /// @notice Enable investment in specified assets\r\n    /// @param ofAssets Array of assets to enable investment in\r\n    function enableInvestment(address[] ofAssets)\r\n        external\r\n        pre_cond(isOwner())\r\n    {\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            require(modules.pricefeed.assetIsRegistered(ofAssets[i]));\r\n            isInvestAllowed[ofAssets[i]] = true;\r\n        }\r\n    }\r\n\r\n    /// @notice Disable investment in specified assets\r\n    /// @param ofAssets Array of assets to disable investment in\r\n    function disableInvestment(address[] ofAssets)\r\n        external\r\n        pre_cond(isOwner())\r\n    {\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            isInvestAllowed[ofAssets[i]] = false;\r\n        }\r\n    }\r\n\r\n    function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }\r\n\r\n    // EXTERNAL : PARTICIPATION\r\n\r\n    /// @notice Give melon tokens to receive shares of this fund\r\n    /// @dev Recommended to give some leeway in prices to account for possibly slightly changing prices\r\n    /// @param giveQuantity Quantity of Melon token times 10 ** 18 offered to receive shareQuantity\r\n    /// @param shareQuantity Quantity of shares times 10 ** 18 requested to be received\r\n    /// @param investmentAsset Address of asset to invest in\r\n    function requestInvestment(\r\n        uint giveQuantity,\r\n        uint shareQuantity,\r\n        address investmentAsset\r\n    )\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(isInvestAllowed[investmentAsset]) // investment using investmentAsset has not been deactivated by the Manager\r\n        pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))    // Compliance Module: Investment permitted\r\n    {\r\n        requests.push(Request({\r\n            participant: msg.sender,\r\n            status: RequestStatus.active,\r\n            requestAsset: investmentAsset,\r\n            shareQuantity: shareQuantity,\r\n            giveQuantity: giveQuantity,\r\n            receiveQuantity: shareQuantity,\r\n            timestamp: now,\r\n            atUpdateId: modules.pricefeed.getLastUpdateId()\r\n        }));\r\n\r\n        emit RequestUpdated(getLastRequestId());\r\n    }\r\n\r\n    /// @notice Executes active investment and redemption requests, in a way that minimises information advantages of investor\r\n    /// @dev Distributes melon and shares according to the request\r\n    /// @param id Index of request to be executed\r\n    /// @dev Active investment or redemption request executed\r\n    function executeRequest(uint id)\r\n        external\r\n        pre_cond(!isShutDown)\r\n        pre_cond(requests[id].status == RequestStatus.active)\r\n        pre_cond(\r\n            _totalSupply == 0 ||\r\n            (\r\n                now >= add(requests[id].timestamp, modules.pricefeed.getInterval()) &&\r\n                modules.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)\r\n            )\r\n        )   // PriceFeed Module: Wait at least one interval time and two updates before continuing (unless it is the first investment)\r\n\r\n    {\r\n        Request request = requests[id];\r\n        var (isRecent, , ) =\r\n            modules.pricefeed.getPriceInfo(address(request.requestAsset));\r\n        require(isRecent);\r\n\r\n        // sharePrice quoted in QUOTE_ASSET and multiplied by 10 ** fundDecimals\r\n        uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees())); // By definition quoteDecimals == fundDecimals\r\n        if (request.requestAsset != address(QUOTE_ASSET)) {\r\n            var (isPriceRecent, invertedRequestAssetPrice, requestAssetDecimal) = modules.pricefeed.getInvertedPriceInfo(request.requestAsset);\r\n            if (!isPriceRecent) {\r\n                revert();\r\n            }\r\n            costQuantity = mul(costQuantity, invertedRequestAssetPrice) / 10 ** requestAssetDecimal;\r\n        }\r\n\r\n        if (\r\n            isInvestAllowed[request.requestAsset] &&\r\n            costQuantity <= request.giveQuantity\r\n        ) {\r\n            request.status = RequestStatus.executed;\r\n            require(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity)); // Allocate Value\r\n            createShares(request.participant, request.shareQuantity); // Accounting\r\n            if (!isInAssetList[request.requestAsset]) {\r\n                ownedAssets.push(request.requestAsset);\r\n                isInAssetList[request.requestAsset] = true;\r\n            }\r\n        } else {\r\n            revert(); // Invalid Request or invalid giveQuantity / receiveQuantity\r\n        }\r\n    }\r\n\r\n    /// @notice Cancels active investment and redemption requests\r\n    /// @param id Index of request to be executed\r\n    function cancelRequest(uint id)\r\n        external\r\n        pre_cond(requests[id].status == RequestStatus.active) // Request is active\r\n        pre_cond(requests[id].participant == msg.sender || isShutDown) // Either request creator or fund is shut down\r\n    {\r\n        requests[id].status = RequestStatus.cancelled;\r\n    }\r\n\r\n    /// @notice Redeems by allocating an ownership percentage of each asset to the participant\r\n    /// @dev Independent of running price feed!\r\n    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for individual assets\r\n    /// @return Whether all assets sent to shareholder or not\r\n    function redeemAllOwnedAssets(uint shareQuantity)\r\n        external\r\n        returns (bool success)\r\n    {\r\n        return emergencyRedeem(shareQuantity, ownedAssets);\r\n    }\r\n\r\n    // EXTERNAL : MANAGING\r\n\r\n    /// @notice Universal method for calling exchange functions through adapters\r\n    /// @notice See adapter contracts for parameters needed for each exchange\r\n    /// @param exchangeIndex Index of the exchange in the \"exchanges\" array\r\n    /// @param method Signature of the adapter method to call (as per ABI spec)\r\n    /// @param orderAddresses [0] Order maker\r\n    /// @param orderAddresses [1] Order taker\r\n    /// @param orderAddresses [2] Order maker asset\r\n    /// @param orderAddresses [3] Order taker asset\r\n    /// @param orderAddresses [4] Fee recipient\r\n    /// @param orderValues [0] Maker token quantity\r\n    /// @param orderValues [1] Taker token quantity\r\n    /// @param orderValues [2] Maker fee\r\n    /// @param orderValues [3] Taker fee\r\n    /// @param orderValues [4] Timestamp (seconds)\r\n    /// @param orderValues [5] Salt/nonce\r\n    /// @param orderValues [6] Fill amount: amount of taker token to be traded\r\n    /// @param orderValues [7] Dexy signature mode\r\n    /// @param identifier Order identifier\r\n    /// @param v ECDSA recovery id\r\n    /// @param r ECDSA signature output r\r\n    /// @param s ECDSA signature output s\r\n    function callOnExchange(\r\n        uint exchangeIndex,\r\n        bytes4 method,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        external\r\n    {\r\n        require(modules.pricefeed.exchangeMethodIsAllowed(\r\n            exchanges[exchangeIndex].exchange, method\r\n        ));\r\n        require((exchanges[exchangeIndex].exchangeAdapter).delegatecall(\r\n            method, exchanges[exchangeIndex].exchange,\r\n            orderAddresses, orderValues, identifier, v, r, s\r\n        ));\r\n    }\r\n\r\n    function addOpenMakeOrder(\r\n        address ofExchange,\r\n        address ofSellAsset,\r\n        uint orderId\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        isInOpenMakeOrder[ofSellAsset] = true;\r\n        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].id = orderId;\r\n        exchangesToOpenMakeOrders[ofExchange][ofSellAsset].expiresAt = add(now, ORDER_EXPIRATION_TIME);\r\n    }\r\n\r\n    function removeOpenMakeOrder(\r\n        address ofExchange,\r\n        address ofSellAsset\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        delete exchangesToOpenMakeOrders[ofExchange][ofSellAsset];\r\n    }\r\n\r\n    function orderUpdateHook(\r\n        address ofExchange,\r\n        bytes32 orderId,\r\n        UpdateType updateType,\r\n        address[2] orderAddresses, // makerAsset, takerAsset\r\n        uint[3] orderValues        // makerQuantity, takerQuantity, fillTakerQuantity (take only)\r\n    )\r\n        pre_cond(msg.sender == address(this))\r\n    {\r\n        // only save make/take\r\n        if (updateType == UpdateType.make || updateType == UpdateType.take) {\r\n            orders.push(Order({\r\n                exchangeAddress: ofExchange,\r\n                orderId: orderId,\r\n                updateType: updateType,\r\n                makerAsset: orderAddresses[0],\r\n                takerAsset: orderAddresses[1],\r\n                makerQuantity: orderValues[0],\r\n                takerQuantity: orderValues[1],\r\n                timestamp: block.timestamp,\r\n                fillTakerQuantity: orderValues[2]\r\n            }));\r\n        }\r\n        emit OrderUpdated(ofExchange, orderId, updateType);\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    // PUBLIC METHODS : ACCOUNTING\r\n\r\n    /// @notice Calculates gross asset value of the fund\r\n    /// @dev Decimals in assets must be equal to decimals in PriceFeed for all entries in AssetRegistrar\r\n    /// @dev Assumes that module.pricefeed.getPriceInfo(..) returns recent prices\r\n    /// @return gav Gross asset value quoted in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcGav() returns (uint gav) {\r\n        // prices quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        uint[] memory allAssetHoldings = new uint[](ownedAssets.length);\r\n        uint[] memory allAssetPrices = new uint[](ownedAssets.length);\r\n        address[] memory tempOwnedAssets;\r\n        tempOwnedAssets = ownedAssets;\r\n        delete ownedAssets;\r\n        for (uint i = 0; i < tempOwnedAssets.length; ++i) {\r\n            address ofAsset = tempOwnedAssets[i];\r\n            // assetHoldings formatting: mul(exchangeHoldings, 10 ** assetDecimal)\r\n            uint assetHoldings = add(\r\n                uint(AssetInterface(ofAsset).balanceOf(address(this))), // asset base units held by fund\r\n                quantityHeldInCustodyOfExchange(ofAsset)\r\n            );\r\n            // assetPrice formatting: mul(exchangePrice, 10 ** assetDecimal)\r\n            var (isRecent, assetPrice, assetDecimals) = modules.pricefeed.getPriceInfo(ofAsset);\r\n            if (!isRecent) {\r\n                revert();\r\n            }\r\n            allAssetHoldings[i] = assetHoldings;\r\n            allAssetPrices[i] = assetPrice;\r\n            // gav as sum of mul(assetHoldings, assetPrice) with formatting: mul(mul(exchangeHoldings, exchangePrice), 10 ** shareDecimals)\r\n            gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));   // Sum up product of asset holdings of this vault and asset prices\r\n            if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || isInOpenMakeOrder[ofAsset]) { // Check if asset holdings is not zero or is address(QUOTE_ASSET) or in open make order\r\n                ownedAssets.push(ofAsset);\r\n            } else {\r\n                isInAssetList[ofAsset] = false; // Remove from ownedAssets if asset holdings are zero\r\n            }\r\n        }\r\n        emit PortfolioContent(tempOwnedAssets, allAssetHoldings, allAssetPrices);\r\n    }\r\n\r\n    /// @notice Add an asset to the list that this fund owns\r\n    function addAssetToOwnedAssets (address ofAsset)\r\n        public\r\n        pre_cond(isOwner() || msg.sender == address(this))\r\n    {\r\n        isInOpenMakeOrder[ofAsset] = true;\r\n        if (!isInAssetList[ofAsset]) {\r\n            ownedAssets.push(ofAsset);\r\n            isInAssetList[ofAsset] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Calculates unclaimed fees of the fund manager\r\n    @param gav Gross asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    @return {\r\n      \"managementFees\": \"A time (seconds) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\",\r\n      \"performanceFees\": \"A performance (rise of sharePrice measured in QUOTE_ASSET) based fee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\",\r\n      \"unclaimedfees\": \"The sum of both managementfee and performancefee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\"\r\n    }\r\n    */\r\n    function calcUnclaimedFees(uint gav)\r\n        view\r\n        returns (\r\n            uint managementFee,\r\n            uint performanceFee,\r\n            uint unclaimedFees)\r\n    {\r\n        // Management fee calculation\r\n        uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);\r\n        uint gavPercentage = mul(timePassed, gav) / (1 years);\r\n        managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);\r\n\r\n        // Performance fee calculation\r\n        // Handle potential division through zero by defining a default value\r\n        uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), _totalSupply) : toSmallestShareUnit(1);\r\n        if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {\r\n            uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);\r\n            uint investmentProfits = wmul(gainInSharePrice, _totalSupply);\r\n            performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);\r\n        }\r\n\r\n        // Sum of all FEES\r\n        unclaimedFees = add(managementFee, performanceFee);\r\n    }\r\n\r\n    /// @notice Calculates the Net asset value of this fund\r\n    /// @param gav Gross asset value of this fund in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @param unclaimedFees The sum of both managementFee and performanceFee in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @return nav Net asset value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcNav(uint gav, uint unclaimedFees)\r\n        view\r\n        returns (uint nav)\r\n    {\r\n        nav = sub(gav, unclaimedFees);\r\n    }\r\n\r\n    /// @notice Calculates the share price of the fund\r\n    /// @dev Convention for valuePerShare (== sharePrice) formatting: mul(totalValue / numShares, 10 ** decimal), to avoid floating numbers\r\n    /// @dev Non-zero share supply; value denominated in [base unit of melonAsset]\r\n    /// @param totalValue the total value in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    /// @param numShares the number of shares multiplied by 10 ** shareDecimals\r\n    /// @return valuePerShare Share price denominated in QUOTE_ASSET and multiplied by 10 ** shareDecimals\r\n    function calcValuePerShare(uint totalValue, uint numShares)\r\n        view\r\n        pre_cond(numShares > 0)\r\n        returns (uint valuePerShare)\r\n    {\r\n        valuePerShare = toSmallestShareUnit(totalValue) / numShares;\r\n    }\r\n\r\n    /**\r\n    @notice Calculates essential fund metrics\r\n    @return {\r\n      \"gav\": \"Gross asset value of this fund denominated in [base unit of melonAsset]\",\r\n      \"managementFee\": \"A time (seconds) based fee\",\r\n      \"performanceFee\": \"A performance (rise of sharePrice measured in QUOTE_ASSET) based fee\",\r\n      \"unclaimedFees\": \"The sum of both managementFee and performanceFee denominated in [base unit of melonAsset]\",\r\n      \"feesShareQuantity\": \"The number of shares to be given as fees to the manager\",\r\n      \"nav\": \"Net asset value denominated in [base unit of melonAsset]\",\r\n      \"sharePrice\": \"Share price denominated in [base unit of melonAsset]\"\r\n    }\r\n    */\r\n    function performCalculations()\r\n        view\r\n        returns (\r\n            uint gav,\r\n            uint managementFee,\r\n            uint performanceFee,\r\n            uint unclaimedFees,\r\n            uint feesShareQuantity,\r\n            uint nav,\r\n            uint sharePrice\r\n        )\r\n    {\r\n        gav = calcGav(); // Reflects value independent of fees\r\n        (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);\r\n        nav = calcNav(gav, unclaimedFees);\r\n\r\n        // The value of unclaimedFees measured in shares of this fund at current value\r\n        feesShareQuantity = (gav == 0) ? 0 : mul(_totalSupply, unclaimedFees) / gav;\r\n        // The total share supply including the value of unclaimedFees, measured in shares of this fund\r\n        uint totalSupplyAccountingForFees = add(_totalSupply, feesShareQuantity);\r\n        sharePrice = _totalSupply > 0 ? calcValuePerShare(gav, totalSupplyAccountingForFees) : toSmallestShareUnit(1); // Handle potential division through zero by defining a default value\r\n    }\r\n\r\n    /// @notice Converts unclaimed fees of the manager into fund shares\r\n    /// @return sharePrice Share price denominated in [base unit of melonAsset]\r\n    function calcSharePriceAndAllocateFees() public returns (uint)\r\n    {\r\n        var (\r\n            gav,\r\n            managementFee,\r\n            performanceFee,\r\n            unclaimedFees,\r\n            feesShareQuantity,\r\n            nav,\r\n            sharePrice\r\n        ) = performCalculations();\r\n\r\n        createShares(owner, feesShareQuantity); // Updates _totalSupply by creating shares allocated to manager\r\n\r\n        // Update Calculations\r\n        uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;\r\n        atLastUnclaimedFeeAllocation = Calculations({\r\n            gav: gav,\r\n            managementFee: managementFee,\r\n            performanceFee: performanceFee,\r\n            unclaimedFees: unclaimedFees,\r\n            nav: nav,\r\n            highWaterMark: highWaterMark,\r\n            totalSupply: _totalSupply,\r\n            timestamp: now\r\n        });\r\n\r\n        emit FeesConverted(now, feesShareQuantity, unclaimedFees);\r\n        emit CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, _totalSupply);\r\n\r\n        return sharePrice;\r\n    }\r\n\r\n    // PUBLIC : REDEEMING\r\n\r\n    /// @notice Redeems by allocating an ownership percentage only of requestedAssets to the participant\r\n    /// @dev This works, but with loops, so only up to a certain number of assets (right now the max is 4)\r\n    /// @dev Independent of running price feed! Note: if requestedAssets != ownedAssets then participant misses out on some owned value\r\n    /// @param shareQuantity Number of shares owned by the participant, which the participant would like to redeem for a slice of assets\r\n    /// @param requestedAssets List of addresses that consitute a subset of ownedAssets.\r\n    /// @return Whether all assets sent to shareholder or not\r\n    function emergencyRedeem(uint shareQuantity, address[] requestedAssets)\r\n        public\r\n        pre_cond(balances[msg.sender] >= shareQuantity)  // sender owns enough shares\r\n        returns (bool)\r\n    {\r\n        address ofAsset;\r\n        uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\r\n        address[] memory redeemedAssets = new address[](requestedAssets.length);\r\n\r\n        // Check whether enough assets held by fund\r\n        for (uint i = 0; i < requestedAssets.length; ++i) {\r\n            ofAsset = requestedAssets[i];\r\n            require(isInAssetList[ofAsset]);\r\n            for (uint j = 0; j < redeemedAssets.length; j++) {\r\n                if (ofAsset == redeemedAssets[j]) {\r\n                    revert();\r\n                }\r\n            }\r\n            redeemedAssets[i] = ofAsset;\r\n            uint assetHoldings = add(\r\n                uint(AssetInterface(ofAsset).balanceOf(address(this))),\r\n                quantityHeldInCustodyOfExchange(ofAsset)\r\n            );\r\n\r\n            if (assetHoldings == 0) continue;\r\n\r\n            // participant's ownership percentage of asset holdings\r\n            ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / _totalSupply;\r\n\r\n            // CRITICAL ERR: Not enough fund asset balance for owed ownershipQuantitiy, eg in case of unreturned asset quantity at address(exchanges[i].exchange) address\r\n            if (uint(AssetInterface(ofAsset).balanceOf(address(this))) < ownershipQuantities[i]) {\r\n                isShutDown = true;\r\n                emit ErrorMessage(\"CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy\");\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Annihilate shares before external calls to prevent reentrancy\r\n        annihilateShares(msg.sender, shareQuantity);\r\n\r\n        // Transfer ownershipQuantity of Assets\r\n        for (uint k = 0; k < requestedAssets.length; ++k) {\r\n            // Failed to send owed ownershipQuantity from fund to participant\r\n            ofAsset = requestedAssets[k];\r\n            if (ownershipQuantities[k] == 0) {\r\n                continue;\r\n            } else if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[k])) {\r\n                revert();\r\n            }\r\n        }\r\n        emit Redeemed(msg.sender, now, shareQuantity);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC : FEES\r\n\r\n    /// @dev Quantity of asset held in exchange according to associated order id\r\n    /// @param ofAsset Address of asset\r\n    /// @return Quantity of input asset held in exchange\r\n    function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {\r\n        uint totalSellQuantity;     // quantity in custody across exchanges\r\n        uint totalSellQuantityInApprove; // quantity of asset in approve (allowance) but not custody of exchange\r\n        for (uint i; i < exchanges.length; i++) {\r\n            if (exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id == 0) {\r\n                continue;\r\n            }\r\n            var (sellAsset, , sellQuantity, ) = GenericExchangeInterface(exchanges[i].exchangeAdapter).getOrder(exchanges[i].exchange, exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id);\r\n            if (sellQuantity == 0) {    // remove id if remaining sell quantity zero (closed)\r\n                delete exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset];\r\n            }\r\n            totalSellQuantity = add(totalSellQuantity, sellQuantity);\r\n            if (!exchanges[i].takesCustody) {\r\n                totalSellQuantityInApprove += sellQuantity;\r\n            }\r\n        }\r\n        if (totalSellQuantity == 0) {\r\n            isInOpenMakeOrder[sellAsset] = false;\r\n        }\r\n        return sub(totalSellQuantity, totalSellQuantityInApprove); // Since quantity in approve is not actually in custody\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Calculates sharePrice denominated in [base unit of melonAsset]\r\n    /// @return sharePrice Share price denominated in [base unit of melonAsset]\r\n    function calcSharePrice() view returns (uint sharePrice) {\r\n        (, , , , , sharePrice) = performCalculations();\r\n        return sharePrice;\r\n    }\r\n\r\n    function getModules() view returns (address, address, address) {\r\n        return (\r\n            address(modules.pricefeed),\r\n            address(modules.compliance),\r\n            address(modules.riskmgmt)\r\n        );\r\n    }\r\n\r\n    function getLastRequestId() view returns (uint) { return requests.length - 1; }\r\n    function getLastOrderIndex() view returns (uint) { return orders.length - 1; }\r\n    function getManager() view returns (address) { return owner; }\r\n    function getOwnedAssetsLength() view returns (uint) { return ownedAssets.length; }\r\n    function getExchangeInfo() view returns (address[], address[], bool[]) {\r\n        address[] memory ofExchanges = new address[](exchanges.length);\r\n        address[] memory ofAdapters = new address[](exchanges.length);\r\n        bool[] memory takesCustody = new bool[](exchanges.length);\r\n        for (uint i = 0; i < exchanges.length; i++) {\r\n            ofExchanges[i] = exchanges[i].exchange;\r\n            ofAdapters[i] = exchanges[i].exchangeAdapter;\r\n            takesCustody[i] = exchanges[i].takesCustody;\r\n        }\r\n        return (ofExchanges, ofAdapters, takesCustody);\r\n    }\r\n    function orderExpired(address ofExchange, address ofAsset) view returns (bool) {\r\n        uint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;\r\n        require(expiryTime > 0);\r\n        return block.timestamp >= expiryTime;\r\n    }\r\n    function getOpenOrderInfo(address ofExchange, address ofAsset) view returns (uint, uint) {\r\n        OpenMakeOrder order = exchangesToOpenMakeOrders[ofExchange][ofAsset];\r\n        return (order.id, order.expiresAt);\r\n    }\r\n}\r\n\r\ninterface GenericExchangeInterface {\r\n\r\n    // EVENTS\r\n\r\n    event OrderUpdated(uint id);\r\n\r\n    // METHODS\r\n    // EXTERNAL METHODS\r\n\r\n    function makeOrder(\r\n        address onExchange,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) external returns (uint);\r\n    function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);\r\n    function cancelOrder(address onExchange, uint id) external returns (bool);\r\n\r\n\r\n    // PUBLIC METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function isApproveOnly() view returns (bool);\r\n    function getLastOrderId(address onExchange) view returns (uint);\r\n    function isActive(address onExchange, uint id) view returns (bool);\r\n    function getOwner(address onExchange, uint id) view returns (address);\r\n    function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);\r\n    function getTimestamp(address onExchange, uint id) view returns (uint);\r\n\r\n}\r\n\r\ninterface ExchangeAdapterInterface {\r\n    function makeOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n\r\n    function takeOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n\r\n    function cancelOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n}\r\n\r\ncontract ZeroExV1Adapter is ExchangeAdapterInterface, DSMath, DBC {\r\n\r\n    //  METHODS\r\n\r\n    //  PUBLIC METHODS\r\n\r\n    /// @notice Make order not implemented for smart contracts in this exchange version\r\n    function makeOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) {\r\n        revert();\r\n    }\r\n\r\n    // Responsibilities of takeOrder are:\r\n    // - check sender\r\n    // - check fund not shut down\r\n    // - check not buying own fund tokens\r\n    // - check price exists for asset pair\r\n    // - check price is recent\r\n    // - check price passes risk management\r\n    // - approve funds to be traded (if necessary)\r\n    // - take order from the exchange\r\n    // - check order was taken (if possible)\r\n    // - place asset in ownedAssets if not already tracked\r\n    /// @notice Takes an active order on the selected exchange\r\n    /// @dev These orders are expected to settle immediately\r\n    /// @param targetExchange Address of the exchange\r\n    /// @param orderAddresses [0] Order maker\r\n    /// @param orderAddresses [1] Order taker\r\n    /// @param orderAddresses [2] Order maker asset\r\n    /// @param orderAddresses [3] Order taker asset\r\n    /// @param orderAddresses [4] Fee recipient\r\n    /// @param orderValues [0] Maker token quantity\r\n    /// @param orderValues [1] Taker token quantity\r\n    /// @param orderValues [2] Maker fee\r\n    /// @param orderValues [3] Taker fee\r\n    /// @param orderValues [4] Expiration timestamp in seconds\r\n    /// @param orderValues [5] Salt\r\n    /// @param orderValues [6] Fill amount : amount of taker token to fill\r\n    /// @param v ECDSA recovery id\r\n    /// @param r ECDSA signature output r\r\n    /// @param s ECDSA signature output s\r\n    function takeOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) {\r\n        require(Fund(address(this)).owner() == msg.sender);\r\n        require(!Fund(address(this)).isShutDown());\r\n\r\n        Token makerAsset = Token(orderAddresses[2]);\r\n        Token takerAsset = Token(orderAddresses[3]);\r\n        uint maxMakerQuantity = orderValues[0];\r\n        uint maxTakerQuantity = orderValues[1];\r\n        uint fillTakerQuantity = orderValues[6];\r\n        uint fillMakerQuantity = mul(fillTakerQuantity, maxMakerQuantity) / maxTakerQuantity;\r\n\r\n        require(takeOrderPermitted(fillTakerQuantity, takerAsset, fillMakerQuantity, makerAsset));\r\n        require(takerAsset.approve(Exchange(targetExchange).TOKEN_TRANSFER_PROXY_CONTRACT(), fillTakerQuantity));\r\n        uint filledAmount = executeFill(targetExchange, orderAddresses, orderValues, fillTakerQuantity, v, r, s);\r\n        require(filledAmount == fillTakerQuantity);\r\n        require(\r\n            Fund(address(this)).isInAssetList(makerAsset) ||\r\n            Fund(address(this)).getOwnedAssetsLength() < Fund(address(this)).MAX_FUND_ASSETS()\r\n        );\r\n\r\n        Fund(address(this)).addAssetToOwnedAssets(makerAsset);\r\n        Fund(address(this)).orderUpdateHook(\r\n            targetExchange,\r\n            bytes32(identifier),\r\n            Fund.UpdateType.take,\r\n            [address(makerAsset), address(takerAsset)],\r\n            [maxMakerQuantity, maxTakerQuantity, fillTakerQuantity]\r\n        );\r\n    }\r\n\r\n    /// @notice Cancel is not implemented on exchange for smart contracts\r\n    function cancelOrder(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        bytes32 identifier,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) {\r\n        revert();\r\n    }\r\n\r\n    // TODO: delete this function if possible\r\n    function getLastOrderId(address targetExchange)\r\n        view\r\n        returns (uint)\r\n    {\r\n        revert();\r\n    }\r\n\r\n    // TODO: delete this function if possible\r\n    function getOrder(address targetExchange, uint id)\r\n        view\r\n        returns (address, address, uint, uint)\r\n    {\r\n        revert();\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @dev needed to avoid stack too deep error\r\n    function executeFill(\r\n        address targetExchange,\r\n        address[5] orderAddresses,\r\n        uint[8] orderValues,\r\n        uint fillTakerQuantity,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    )\r\n        internal\r\n        returns (uint)\r\n    {\r\n        uint takerFee = orderValues[3];\r\n        if (takerFee > 0) {\r\n            Token zeroExToken = Token(Exchange(targetExchange).ZRX_TOKEN_CONTRACT());\r\n            require(zeroExToken.approve(Exchange(targetExchange).TOKEN_TRANSFER_PROXY_CONTRACT(), takerFee));\r\n        }\r\n\r\n        return Exchange(targetExchange).fillOrder(\r\n            orderAddresses,\r\n            [\r\n                orderValues[0], orderValues[1], orderValues[2],\r\n                orderValues[3], orderValues[4], orderValues[5]\r\n            ],\r\n            fillTakerQuantity,\r\n            false,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n    // VIEW METHODS\r\n\r\n    /// @dev needed to avoid stack too deep error\r\n    function takeOrderPermitted(\r\n        uint takerQuantity,\r\n        Token takerAsset,\r\n        uint makerQuantity,\r\n        Token makerAsset\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(takerAsset != address(this) && makerAsset != address(this));\r\n        require(address(makerAsset) != address(takerAsset));\r\n        // require(fillTakerQuantity <= maxTakerQuantity);\r\n        var (pricefeed, , riskmgmt) = Fund(address(this)).modules();\r\n        require(pricefeed.existsPriceOnAssetPair(takerAsset, makerAsset));\r\n        var (isRecent, referencePrice, ) = pricefeed.getReferencePriceInfo(takerAsset, makerAsset);\r\n        require(isRecent);\r\n        uint orderPrice = pricefeed.getOrderPriceInfo(\r\n            takerAsset,\r\n            makerAsset,\r\n            takerQuantity,\r\n            makerQuantity\r\n        );\r\n        return(\r\n            riskmgmt.isTakePermitted(\r\n                orderPrice,\r\n                referencePrice,\r\n                takerAsset,\r\n                makerAsset,\r\n                takerQuantity,\r\n                makerQuantity\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract TokenTransferProxy is Ownable {\r\n\r\n    /// @dev Only authorized addresses can invoke functions with this modifier.\r\n    modifier onlyAuthorized {\r\n        require(authorized[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier targetAuthorized(address target) {\r\n        require(authorized[target]);\r\n        _;\r\n    }\r\n\r\n    modifier targetNotAuthorized(address target) {\r\n        require(!authorized[target]);\r\n        _;\r\n    }\r\n\r\n    mapping (address => bool) public authorized;\r\n    address[] public authorities;\r\n\r\n    event LogAuthorizedAddressAdded(address indexed target, address indexed caller);\r\n    event LogAuthorizedAddressRemoved(address indexed target, address indexed caller);\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n\r\n    /// @dev Authorizes an address.\r\n    /// @param target Address to authorize.\r\n    function addAuthorizedAddress(address target)\r\n        public\r\n        onlyOwner\r\n        targetNotAuthorized(target)\r\n    {\r\n        authorized[target] = true;\r\n        authorities.push(target);\r\n        LogAuthorizedAddressAdded(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Removes authorizion of an address.\r\n    /// @param target Address to remove authorization from.\r\n    function removeAuthorizedAddress(address target)\r\n        public\r\n        onlyOwner\r\n        targetAuthorized(target)\r\n    {\r\n        delete authorized[target];\r\n        for (uint i = 0; i < authorities.length; i++) {\r\n            if (authorities[i] == target) {\r\n                authorities[i] = authorities[authorities.length - 1];\r\n                authorities.length -= 1;\r\n                break;\r\n            }\r\n        }\r\n        LogAuthorizedAddressRemoved(target, msg.sender);\r\n    }\r\n\r\n    /// @dev Calls into ERC20 Token contract, invoking transferFrom.\r\n    /// @param token Address of token to transfer.\r\n    /// @param from Address to transfer token from.\r\n    /// @param to Address to transfer token to.\r\n    /// @param value Amount of token to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value)\r\n        public\r\n        onlyAuthorized\r\n        returns (bool)\r\n    {\r\n        return Token(token).transferFrom(from, to, value);\r\n    }\r\n\r\n    /*\r\n     * Public constant functions\r\n     */\r\n\r\n    /// @dev Gets all authorized addresses.\r\n    /// @return Array of authorized addresses.\r\n    function getAuthorizedAddresses()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return authorities;\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal constant returns (uint256) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal constant returns (uint256) {\r\n        uint c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal constant returns (uint256) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract Exchange is SafeMath {\r\n\r\n    // Error Codes\r\n    enum Errors {\r\n        ORDER_EXPIRED,                    // Order has already expired\r\n        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\r\n        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\r\n        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\r\n    }\r\n\r\n    string constant public VERSION = \"1.0.0\";\r\n    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\r\n\r\n    address public ZRX_TOKEN_CONTRACT;\r\n    address public TOKEN_TRANSFER_PROXY_CONTRACT;\r\n\r\n    // Mappings of orderHash => amounts of takerTokenAmount filled or cancelled.\r\n    mapping (bytes32 => uint) public filled;\r\n    mapping (bytes32 => uint) public cancelled;\r\n\r\n    event LogFill(\r\n        address indexed maker,\r\n        address taker,\r\n        address indexed feeRecipient,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint filledMakerTokenAmount,\r\n        uint filledTakerTokenAmount,\r\n        uint paidMakerFee,\r\n        uint paidTakerFee,\r\n        bytes32 indexed tokens, // keccak256(makerToken, takerToken), allows subscribing to a token pair\r\n        bytes32 orderHash\r\n    );\r\n\r\n    event LogCancel(\r\n        address indexed maker,\r\n        address indexed feeRecipient,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint cancelledMakerTokenAmount,\r\n        uint cancelledTakerTokenAmount,\r\n        bytes32 indexed tokens,\r\n        bytes32 orderHash\r\n    );\r\n\r\n    event LogError(uint8 indexed errorId, bytes32 indexed orderHash);\r\n\r\n    struct Order {\r\n        address maker;\r\n        address taker;\r\n        address makerToken;\r\n        address takerToken;\r\n        address feeRecipient;\r\n        uint makerTokenAmount;\r\n        uint takerTokenAmount;\r\n        uint makerFee;\r\n        uint takerFee;\r\n        uint expirationTimestampInSec;\r\n        bytes32 orderHash;\r\n    }\r\n\r\n    function Exchange(address _zrxToken, address _tokenTransferProxy) {\r\n        ZRX_TOKEN_CONTRACT = _zrxToken;\r\n        TOKEN_TRANSFER_PROXY_CONTRACT = _tokenTransferProxy;\r\n    }\r\n\r\n    /*\r\n    * Core exchange functions\r\n    */\r\n\r\n    /// @dev Fills the input order.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\r\n    /// @param v ECDSA signature parameter v.\r\n    /// @param r ECDSA signature parameters r.\r\n    /// @param s ECDSA signature parameters s.\r\n    /// @return Total amount of takerToken filled in trade.\r\n    function fillOrder(\r\n          address[5] orderAddresses,\r\n          uint[6] orderValues,\r\n          uint fillTakerTokenAmount,\r\n          bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n          uint8 v,\r\n          bytes32 r,\r\n          bytes32 s)\r\n          public\r\n          returns (uint filledTakerTokenAmount)\r\n    {\r\n        Order memory order = Order({\r\n            maker: orderAddresses[0],\r\n            taker: orderAddresses[1],\r\n            makerToken: orderAddresses[2],\r\n            takerToken: orderAddresses[3],\r\n            feeRecipient: orderAddresses[4],\r\n            makerTokenAmount: orderValues[0],\r\n            takerTokenAmount: orderValues[1],\r\n            makerFee: orderValues[2],\r\n            takerFee: orderValues[3],\r\n            expirationTimestampInSec: orderValues[4],\r\n            orderHash: getOrderHash(orderAddresses, orderValues)\r\n        });\r\n\r\n        require(order.taker == address(0) || order.taker == msg.sender);\r\n        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && fillTakerTokenAmount > 0);\r\n        require(isValidSignature(\r\n            order.maker,\r\n            order.orderHash,\r\n            v,\r\n            r,\r\n            s\r\n        ));\r\n\r\n        if (block.timestamp >= order.expirationTimestampInSec) {\r\n            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\r\n            return 0;\r\n        }\r\n\r\n        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\r\n        filledTakerTokenAmount = min256(fillTakerTokenAmount, remainingTakerTokenAmount);\r\n        if (filledTakerTokenAmount == 0) {\r\n            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\r\n            return 0;\r\n        }\r\n\r\n        if (isRoundingError(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount)) {\r\n            LogError(uint8(Errors.ROUNDING_ERROR_TOO_LARGE), order.orderHash);\r\n            return 0;\r\n        }\r\n\r\n        if (!shouldThrowOnInsufficientBalanceOrAllowance && !isTransferable(order, filledTakerTokenAmount)) {\r\n            LogError(uint8(Errors.INSUFFICIENT_BALANCE_OR_ALLOWANCE), order.orderHash);\r\n            return 0;\r\n        }\r\n\r\n        uint filledMakerTokenAmount = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\r\n        uint paidMakerFee;\r\n        uint paidTakerFee;\r\n        filled[order.orderHash] = safeAdd(filled[order.orderHash], filledTakerTokenAmount);\r\n        require(transferViaTokenTransferProxy(\r\n            order.makerToken,\r\n            order.maker,\r\n            msg.sender,\r\n            filledMakerTokenAmount\r\n        ));\r\n        require(transferViaTokenTransferProxy(\r\n            order.takerToken,\r\n            msg.sender,\r\n            order.maker,\r\n            filledTakerTokenAmount\r\n        ));\r\n        if (order.feeRecipient != address(0)) {\r\n            if (order.makerFee > 0) {\r\n                paidMakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.makerFee);\r\n                require(transferViaTokenTransferProxy(\r\n                    ZRX_TOKEN_CONTRACT,\r\n                    order.maker,\r\n                    order.feeRecipient,\r\n                    paidMakerFee\r\n                ));\r\n            }\r\n            if (order.takerFee > 0) {\r\n                paidTakerFee = getPartialAmount(filledTakerTokenAmount, order.takerTokenAmount, order.takerFee);\r\n                require(transferViaTokenTransferProxy(\r\n                    ZRX_TOKEN_CONTRACT,\r\n                    msg.sender,\r\n                    order.feeRecipient,\r\n                    paidTakerFee\r\n                ));\r\n            }\r\n        }\r\n\r\n        LogFill(\r\n            order.maker,\r\n            msg.sender,\r\n            order.feeRecipient,\r\n            order.makerToken,\r\n            order.takerToken,\r\n            filledMakerTokenAmount,\r\n            filledTakerTokenAmount,\r\n            paidMakerFee,\r\n            paidTakerFee,\r\n            keccak256(order.makerToken, order.takerToken),\r\n            order.orderHash\r\n        );\r\n        return filledTakerTokenAmount;\r\n    }\r\n\r\n    /// @dev Cancels the input order.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\r\n    /// @return Amount of takerToken cancelled.\r\n    function cancelOrder(\r\n        address[5] orderAddresses,\r\n        uint[6] orderValues,\r\n        uint cancelTakerTokenAmount)\r\n        public\r\n        returns (uint)\r\n    {\r\n        Order memory order = Order({\r\n            maker: orderAddresses[0],\r\n            taker: orderAddresses[1],\r\n            makerToken: orderAddresses[2],\r\n            takerToken: orderAddresses[3],\r\n            feeRecipient: orderAddresses[4],\r\n            makerTokenAmount: orderValues[0],\r\n            takerTokenAmount: orderValues[1],\r\n            makerFee: orderValues[2],\r\n            takerFee: orderValues[3],\r\n            expirationTimestampInSec: orderValues[4],\r\n            orderHash: getOrderHash(orderAddresses, orderValues)\r\n        });\r\n\r\n        require(order.maker == msg.sender);\r\n        require(order.makerTokenAmount > 0 && order.takerTokenAmount > 0 && cancelTakerTokenAmount > 0);\r\n\r\n        if (block.timestamp >= order.expirationTimestampInSec) {\r\n            LogError(uint8(Errors.ORDER_EXPIRED), order.orderHash);\r\n            return 0;\r\n        }\r\n\r\n        uint remainingTakerTokenAmount = safeSub(order.takerTokenAmount, getUnavailableTakerTokenAmount(order.orderHash));\r\n        uint cancelledTakerTokenAmount = min256(cancelTakerTokenAmount, remainingTakerTokenAmount);\r\n        if (cancelledTakerTokenAmount == 0) {\r\n            LogError(uint8(Errors.ORDER_FULLY_FILLED_OR_CANCELLED), order.orderHash);\r\n            return 0;\r\n        }\r\n\r\n        cancelled[order.orderHash] = safeAdd(cancelled[order.orderHash], cancelledTakerTokenAmount);\r\n\r\n        LogCancel(\r\n            order.maker,\r\n            order.feeRecipient,\r\n            order.makerToken,\r\n            order.takerToken,\r\n            getPartialAmount(cancelledTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount),\r\n            cancelledTakerTokenAmount,\r\n            keccak256(order.makerToken, order.takerToken),\r\n            order.orderHash\r\n        );\r\n        return cancelledTakerTokenAmount;\r\n    }\r\n\r\n    /*\r\n    * Wrapper functions\r\n    */\r\n\r\n    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n    /// @param v ECDSA signature parameter v.\r\n    /// @param r ECDSA signature parameters r.\r\n    /// @param s ECDSA signature parameters s.\r\n    function fillOrKillOrder(\r\n        address[5] orderAddresses,\r\n        uint[6] orderValues,\r\n        uint fillTakerTokenAmount,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n    {\r\n        require(fillOrder(\r\n            orderAddresses,\r\n            orderValues,\r\n            fillTakerTokenAmount,\r\n            false,\r\n            v,\r\n            r,\r\n            s\r\n        ) == fillTakerTokenAmount);\r\n    }\r\n\r\n    /// @dev Synchronously executes multiple fill orders in a single transaction.\r\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n    /// @param orderValues Array of uint arrays containing individual order values.\r\n    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\r\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\r\n    /// @param v Array ECDSA signature v parameters.\r\n    /// @param r Array of ECDSA signature r parameters.\r\n    /// @param s Array of ECDSA signature s parameters.\r\n    function batchFillOrders(\r\n        address[5][] orderAddresses,\r\n        uint[6][] orderValues,\r\n        uint[] fillTakerTokenAmounts,\r\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n        uint8[] v,\r\n        bytes32[] r,\r\n        bytes32[] s)\r\n        public\r\n    {\r\n        for (uint i = 0; i < orderAddresses.length; i++) {\r\n            fillOrder(\r\n                orderAddresses[i],\r\n                orderValues[i],\r\n                fillTakerTokenAmounts[i],\r\n                shouldThrowOnInsufficientBalanceOrAllowance,\r\n                v[i],\r\n                r[i],\r\n                s[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\r\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n    /// @param orderValues Array of uint arrays containing individual order values.\r\n    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\r\n    /// @param v Array ECDSA signature v parameters.\r\n    /// @param r Array of ECDSA signature r parameters.\r\n    /// @param s Array of ECDSA signature s parameters.\r\n    function batchFillOrKillOrders(\r\n        address[5][] orderAddresses,\r\n        uint[6][] orderValues,\r\n        uint[] fillTakerTokenAmounts,\r\n        uint8[] v,\r\n        bytes32[] r,\r\n        bytes32[] s)\r\n        public\r\n    {\r\n        for (uint i = 0; i < orderAddresses.length; i++) {\r\n            fillOrKillOrder(\r\n                orderAddresses[i],\r\n                orderValues[i],\r\n                fillTakerTokenAmounts[i],\r\n                v[i],\r\n                r[i],\r\n                s[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\r\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n    /// @param orderValues Array of uint arrays containing individual order values.\r\n    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\r\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\r\n    /// @param v Array ECDSA signature v parameters.\r\n    /// @param r Array of ECDSA signature r parameters.\r\n    /// @param s Array of ECDSA signature s parameters.\r\n    /// @return Total amount of fillTakerTokenAmount filled in orders.\r\n    function fillOrdersUpTo(\r\n        address[5][] orderAddresses,\r\n        uint[6][] orderValues,\r\n        uint fillTakerTokenAmount,\r\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n        uint8[] v,\r\n        bytes32[] r,\r\n        bytes32[] s)\r\n        public\r\n        returns (uint)\r\n    {\r\n        uint filledTakerTokenAmount = 0;\r\n        for (uint i = 0; i < orderAddresses.length; i++) {\r\n            require(orderAddresses[i][3] == orderAddresses[0][3]); // takerToken must be the same for each order\r\n            filledTakerTokenAmount = safeAdd(filledTakerTokenAmount, fillOrder(\r\n                orderAddresses[i],\r\n                orderValues[i],\r\n                safeSub(fillTakerTokenAmount, filledTakerTokenAmount),\r\n                shouldThrowOnInsufficientBalanceOrAllowance,\r\n                v[i],\r\n                r[i],\r\n                s[i]\r\n            ));\r\n            if (filledTakerTokenAmount == fillTakerTokenAmount) break;\r\n        }\r\n        return filledTakerTokenAmount;\r\n    }\r\n\r\n    /// @dev Synchronously cancels multiple orders in a single transaction.\r\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n    /// @param orderValues Array of uint arrays containing individual order values.\r\n    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\r\n    function batchCancelOrders(\r\n        address[5][] orderAddresses,\r\n        uint[6][] orderValues,\r\n        uint[] cancelTakerTokenAmounts)\r\n        public\r\n    {\r\n        for (uint i = 0; i < orderAddresses.length; i++) {\r\n            cancelOrder(\r\n                orderAddresses[i],\r\n                orderValues[i],\r\n                cancelTakerTokenAmounts[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /*\r\n    * Constant public functions\r\n    */\r\n\r\n    /// @dev Calculates Keccak-256 hash of order with specified parameters.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @return Keccak-256 hash of order.\r\n    function getOrderHash(address[5] orderAddresses, uint[6] orderValues)\r\n        public\r\n        constant\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            address(this),\r\n            orderAddresses[0], // maker\r\n            orderAddresses[1], // taker\r\n            orderAddresses[2], // makerToken\r\n            orderAddresses[3], // takerToken\r\n            orderAddresses[4], // feeRecipient\r\n            orderValues[0],    // makerTokenAmount\r\n            orderValues[1],    // takerTokenAmount\r\n            orderValues[2],    // makerFee\r\n            orderValues[3],    // takerFee\r\n            orderValues[4],    // expirationTimestampInSec\r\n            orderValues[5]     // salt\r\n        );\r\n    }\r\n\r\n    /// @dev Verifies that an order signature is valid.\r\n    /// @param signer address of signer.\r\n    /// @param hash Signed Keccak-256 hash.\r\n    /// @param v ECDSA signature parameter v.\r\n    /// @param r ECDSA signature parameters r.\r\n    /// @param s ECDSA signature parameters s.\r\n    /// @return Validity of order signature.\r\n    function isValidSignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return signer == ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n    /// @dev Checks if rounding error > 0.1%.\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to multiply with numerator/denominator.\r\n    /// @return Rounding error is present.\r\n    function isRoundingError(uint numerator, uint denominator, uint target)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint remainder = mulmod(target, numerator, denominator);\r\n        if (remainder == 0) return false; // No rounding error.\r\n\r\n        uint errPercentageTimes1000000 = safeDiv(\r\n            safeMul(remainder, 1000000),\r\n            safeMul(numerator, target)\r\n        );\r\n        return errPercentageTimes1000000 > 1000;\r\n    }\r\n\r\n    /// @dev Calculates partial value given a numerator and denominator.\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to calculate partial of.\r\n    /// @return Partial value of target.\r\n    function getPartialAmount(uint numerator, uint denominator, uint target)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return safeDiv(safeMul(numerator, target), denominator);\r\n    }\r\n\r\n    /// @dev Calculates the sum of values already filled and cancelled for a given order.\r\n    /// @param orderHash The Keccak-256 hash of the given order.\r\n    /// @return Sum of values already filled and cancelled.\r\n    function getUnavailableTakerTokenAmount(bytes32 orderHash)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return safeAdd(filled[orderHash], cancelled[orderHash]);\r\n    }\r\n\r\n\r\n    /*\r\n    * Internal functions\r\n    */\r\n\r\n    /// @dev Transfers a token using TokenTransferProxy transferFrom function.\r\n    /// @param token Address of token to transferFrom.\r\n    /// @param from Address transfering token.\r\n    /// @param to Address receiving token.\r\n    /// @param value Amount of token to transfer.\r\n    /// @return Success of token transfer.\r\n    function transferViaTokenTransferProxy(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return TokenTransferProxy(TOKEN_TRANSFER_PROXY_CONTRACT).transferFrom(token, from, to, value);\r\n    }\r\n\r\n    /// @dev Checks if any order transfers will fail.\r\n    /// @param order Order struct of params that will be checked.\r\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n    /// @return Predicted result of transfers.\r\n    function isTransferable(Order order, uint fillTakerTokenAmount)\r\n        internal\r\n        constant  // The called token contracts may attempt to change state, but will not be able to due to gas limits on getBalance and getAllowance.\r\n        returns (bool)\r\n    {\r\n        address taker = msg.sender;\r\n        uint fillMakerTokenAmount = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerTokenAmount);\r\n\r\n        if (order.feeRecipient != address(0)) {\r\n            bool isMakerTokenZRX = order.makerToken == ZRX_TOKEN_CONTRACT;\r\n            bool isTakerTokenZRX = order.takerToken == ZRX_TOKEN_CONTRACT;\r\n            uint paidMakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.makerFee);\r\n            uint paidTakerFee = getPartialAmount(fillTakerTokenAmount, order.takerTokenAmount, order.takerFee);\r\n            uint requiredMakerZRX = isMakerTokenZRX ? safeAdd(fillMakerTokenAmount, paidMakerFee) : paidMakerFee;\r\n            uint requiredTakerZRX = isTakerTokenZRX ? safeAdd(fillTakerTokenAmount, paidTakerFee) : paidTakerFee;\r\n\r\n            if (   getBalance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\r\n                || getAllowance(ZRX_TOKEN_CONTRACT, order.maker) < requiredMakerZRX\r\n                || getBalance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\r\n                || getAllowance(ZRX_TOKEN_CONTRACT, taker) < requiredTakerZRX\r\n            ) return false;\r\n\r\n            if (!isMakerTokenZRX && (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount // Don't double check makerToken if ZRX\r\n                                     || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount)\r\n            ) return false;\r\n            if (!isTakerTokenZRX && (   getBalance(order.takerToken, taker) < fillTakerTokenAmount // Don't double check takerToken if ZRX\r\n                                     || getAllowance(order.takerToken, taker) < fillTakerTokenAmount)\r\n            ) return false;\r\n        } else if (   getBalance(order.makerToken, order.maker) < fillMakerTokenAmount\r\n                   || getAllowance(order.makerToken, order.maker) < fillMakerTokenAmount\r\n                   || getBalance(order.takerToken, taker) < fillTakerTokenAmount\r\n                   || getAllowance(order.takerToken, taker) < fillTakerTokenAmount\r\n        ) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Get token balance of an address.\r\n    /// @param token Address of token.\r\n    /// @param owner Address of owner.\r\n    /// @return Token balance of owner.\r\n    function getBalance(address token, address owner)\r\n        internal\r\n        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\r\n        returns (uint)\r\n    {\r\n        return Token(token).balanceOf.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner); // Limit gas to prevent reentrancy\r\n    }\r\n\r\n    /// @dev Get allowance of token given to TokenTransferProxy by an address.\r\n    /// @param token Address of token.\r\n    /// @param owner Address of owner.\r\n    /// @return Allowance of token given to TokenTransferProxy by owner.\r\n    function getAllowance(address token, address owner)\r\n        internal\r\n        constant  // The called token contract may attempt to change state, but will not be able to due to an added gas limit.\r\n        returns (uint)\r\n    {\r\n        return Token(token).allowance.gas(EXTERNAL_QUERY_GAS_LIMIT)(owner, TOKEN_TRANSFER_PROXY_CONTRACT); // Limit gas to prevent reentrancy\r\n    }\r\n}\r\n\r\ncontract CanonicalRegistrar is DSThing, DBC {\r\n\r\n    // TYPES\r\n\r\n    struct Asset {\r\n        bool exists; // True if asset is registered here\r\n        bytes32 name; // Human-readable name of the Asset as in ERC223 token standard\r\n        bytes8 symbol; // Human-readable symbol of the Asset as in ERC223 token standard\r\n        uint decimals; // Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\r\n        string url; // URL for additional information of Asset\r\n        string ipfsHash; // Same as url but for ipfs\r\n        address breakIn; // Break in contract on destination chain\r\n        address breakOut; // Break out contract on this chain; A way to leave\r\n        uint[] standards; // compliance with standards like ERC20, ERC223, ERC777, etc. (the uint is the standard number)\r\n        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->Asset` as much as possible. I.e. name same concepts with the same functionSignature.\r\n        uint price; // Price of asset quoted against `QUOTE_ASSET` * 10 ** decimals\r\n        uint timestamp; // Timestamp of last price update of this asset\r\n    }\r\n\r\n    struct Exchange {\r\n        bool exists;\r\n        address adapter; // adapter contract for this exchange\r\n        // One-time note: takesCustody is inverse case of isApproveOnly\r\n        bool takesCustody; // True in case of exchange implementation which requires  are approved when an order is made instead of transfer\r\n        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->ExchangeAdapter` as much as possible. I.e. name same concepts with the same functionSignature.\r\n    }\r\n    // TODO: populate each field here\r\n    // TODO: add whitelistFunction function\r\n\r\n    // FIELDS\r\n\r\n    // Methods fields\r\n    mapping (address => Asset) public assetInformation;\r\n    address[] public registeredAssets;\r\n\r\n    mapping (address => Exchange) public exchangeInformation;\r\n    address[] public registeredExchanges;\r\n\r\n    // METHODS\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @notice Registers an Asset information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofAsset is registered\r\n    /// @param ofAsset Address of asset to be registered\r\n    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputDecimals Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputUrl Url for extended information of the asset\r\n    /// @param inputIpfsHash Same as url but for ipfs\r\n    /// @param breakInBreakOut Address of break in and break out contracts on destination chain\r\n    /// @param inputStandards Integers of EIP standards this asset adheres to\r\n    /// @param inputFunctionSignatures Function signatures for whitelisted asset functions\r\n    function registerAsset(\r\n        address ofAsset,\r\n        bytes32 inputName,\r\n        bytes8 inputSymbol,\r\n        uint inputDecimals,\r\n        string inputUrl,\r\n        string inputIpfsHash,\r\n        address[2] breakInBreakOut,\r\n        uint[] inputStandards,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(!assetInformation[ofAsset].exists)\r\n    {\r\n        assetInformation[ofAsset].exists = true;\r\n        registeredAssets.push(ofAsset);\r\n        updateAsset(\r\n            ofAsset,\r\n            inputName,\r\n            inputSymbol,\r\n            inputDecimals,\r\n            inputUrl,\r\n            inputIpfsHash,\r\n            breakInBreakOut,\r\n            inputStandards,\r\n            inputFunctionSignatures\r\n        );\r\n        assert(assetInformation[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Register an exchange information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofExchange is registered\r\n    /// @param ofExchange Address of the exchange\r\n    /// @param ofExchangeAdapter Address of exchange adapter for this exchange\r\n    /// @param inputTakesCustody Whether this exchange takes custody of tokens before trading\r\n    /// @param inputFunctionSignatures Function signatures for whitelisted exchange functions\r\n    function registerExchange(\r\n        address ofExchange,\r\n        address ofExchangeAdapter,\r\n        bool inputTakesCustody,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(!exchangeInformation[ofExchange].exists)\r\n    {\r\n        exchangeInformation[ofExchange].exists = true;\r\n        registeredExchanges.push(ofExchange);\r\n        updateExchange(\r\n            ofExchange,\r\n            ofExchangeAdapter,\r\n            inputTakesCustody,\r\n            inputFunctionSignatures\r\n        );\r\n        assert(exchangeInformation[ofExchange].exists);\r\n    }\r\n\r\n    /// @notice Updates description information of a registered Asset\r\n    /// @dev Pre: Owner can change an existing entry\r\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\r\n    /// @param ofAsset Address of the asset to be updated\r\n    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputUrl Url for extended information of the asset\r\n    /// @param inputIpfsHash Same as url but for ipfs\r\n    function updateAsset(\r\n        address ofAsset,\r\n        bytes32 inputName,\r\n        bytes8 inputSymbol,\r\n        uint inputDecimals,\r\n        string inputUrl,\r\n        string inputIpfsHash,\r\n        address[2] ofBreakInBreakOut,\r\n        uint[] inputStandards,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(assetInformation[ofAsset].exists)\r\n    {\r\n        Asset asset = assetInformation[ofAsset];\r\n        asset.name = inputName;\r\n        asset.symbol = inputSymbol;\r\n        asset.decimals = inputDecimals;\r\n        asset.url = inputUrl;\r\n        asset.ipfsHash = inputIpfsHash;\r\n        asset.breakIn = ofBreakInBreakOut[0];\r\n        asset.breakOut = ofBreakInBreakOut[1];\r\n        asset.standards = inputStandards;\r\n        asset.functionSignatures = inputFunctionSignatures;\r\n    }\r\n\r\n    function updateExchange(\r\n        address ofExchange,\r\n        address ofExchangeAdapter,\r\n        bool inputTakesCustody,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(exchangeInformation[ofExchange].exists)\r\n    {\r\n        Exchange exchange = exchangeInformation[ofExchange];\r\n        exchange.adapter = ofExchangeAdapter;\r\n        exchange.takesCustody = inputTakesCustody;\r\n        exchange.functionSignatures = inputFunctionSignatures;\r\n    }\r\n\r\n    // TODO: check max size of array before remaking this becomes untenable\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofAsset address for which specific information is requested\r\n    function removeAsset(\r\n        address ofAsset,\r\n        uint assetIndex\r\n    )\r\n        auth\r\n        pre_cond(assetInformation[ofAsset].exists)\r\n    {\r\n        require(registeredAssets[assetIndex] == ofAsset);\r\n        delete assetInformation[ofAsset]; // Sets exists boolean to false\r\n        delete registeredAssets[assetIndex];\r\n        for (uint i = assetIndex; i < registeredAssets.length-1; i++) {\r\n            registeredAssets[i] = registeredAssets[i+1];\r\n        }\r\n        registeredAssets.length--;\r\n        assert(!assetInformation[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofExchange address for which specific information is requested\r\n    /// @param exchangeIndex index of the exchange in array\r\n    function removeExchange(\r\n        address ofExchange,\r\n        uint exchangeIndex\r\n    )\r\n        auth\r\n        pre_cond(exchangeInformation[ofExchange].exists)\r\n    {\r\n        require(registeredExchanges[exchangeIndex] == ofExchange);\r\n        delete exchangeInformation[ofExchange];\r\n        delete registeredExchanges[exchangeIndex];\r\n        for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {\r\n            registeredExchanges[i] = registeredExchanges[i+1];\r\n        }\r\n        registeredExchanges.length--;\r\n        assert(!exchangeInformation[ofExchange].exists);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // get asset specific information\r\n    function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }\r\n    function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }\r\n    function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }\r\n    function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }\r\n    function getRegisteredAssets() view returns (address[]) { return registeredAssets; }\r\n    function assetMethodIsAllowed(\r\n        address ofAsset, bytes4 querySignature\r\n    )\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == querySignature) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // get exchange-specific information\r\n    function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }\r\n    function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }\r\n    function getExchangeInformation(address ofExchange)\r\n        view\r\n        returns (address, bool)\r\n    {\r\n        Exchange exchange = exchangeInformation[ofExchange];\r\n        return (\r\n            exchange.adapter,\r\n            exchange.takesCustody\r\n        );\r\n    }\r\n    function getExchangeFunctionSignatures(address ofExchange)\r\n        view\r\n        returns (bytes4[])\r\n    {\r\n        return exchangeInformation[ofExchange].functionSignatures;\r\n    }\r\n    function exchangeMethodIsAllowed(\r\n        address ofExchange, bytes4 querySignature\r\n    )\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == querySignature) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\ninterface SimplePriceFeedInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PriceUpdated(bytes32 hash);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function update(address[] ofAssets, uint[] newPrices) external;\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get price feed operation specific information\r\n    function getQuoteAsset() view returns (address);\r\n    function getLastUpdateId() view returns (uint);\r\n    // Get asset specific information as updated in price feed\r\n    function getPrice(address ofAsset) view returns (uint price, uint timestamp);\r\n    function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);\r\n}\r\n\r\ncontract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {\r\n\r\n    // TYPES\r\n    struct Data {\r\n        uint price;\r\n        uint timestamp;\r\n    }\r\n\r\n    // FIELDS\r\n    mapping(address => Data) public assetsToPrices;\r\n\r\n    // Constructor fields\r\n    address public QUOTE_ASSET; // Asset of a portfolio against which all other assets are priced\r\n\r\n    // Contract-level variables\r\n    uint public updateId;        // Update counter for this pricefeed; used as a check during investment\r\n    CanonicalRegistrar public registrar;\r\n    CanonicalPriceFeed public superFeed;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param ofRegistrar Address of canonical registrar\r\n    /// @param ofSuperFeed Address of superfeed\r\n    function SimplePriceFeed(\r\n        address ofRegistrar,\r\n        address ofQuoteAsset,\r\n        address ofSuperFeed\r\n    ) {\r\n        registrar = CanonicalRegistrar(ofRegistrar);\r\n        QUOTE_ASSET = ofQuoteAsset;\r\n        superFeed = CanonicalPriceFeed(ofSuperFeed);\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    /// @param newPrices list of prices for each of the assets\r\n    function update(address[] ofAssets, uint[] newPrices)\r\n        external\r\n        auth\r\n    {\r\n        _updatePrices(ofAssets, newPrices);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get pricefeed specific information\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    /**\r\n    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\r\n    @dev Asset has been registered\r\n    @param ofAsset Asset for which price should be returned\r\n    @return {\r\n      \"price\": \"Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers\",\r\n      \"timestamp\": \"When the asset's price was updated\"\r\n    }\r\n    */\r\n    function getPrice(address ofAsset)\r\n        view\r\n        returns (uint price, uint timestamp)\r\n    {\r\n        Data data = assetsToPrices[ofAsset];\r\n        return (data.price, data.timestamp);\r\n    }\r\n\r\n    /**\r\n    @notice Price of a registered asset in format (bool areRecent, uint[] prices, uint[] decimals)\r\n    @dev Convention for price formatting: mul(price, 10 ** decimal), to avoid floating numbers\r\n    @param ofAssets Assets for which prices should be returned\r\n    @return {\r\n        \"prices\":       \"Array of prices\",\r\n        \"timestamps\":   \"Array of timestamps\",\r\n    }\r\n    */\r\n    function getPrices(address[] ofAssets)\r\n        view\r\n        returns (uint[], uint[])\r\n    {\r\n        uint[] memory prices = new uint[](ofAssets.length);\r\n        uint[] memory timestamps = new uint[](ofAssets.length);\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            var (price, timestamp) = getPrice(ofAssets[i]);\r\n            prices[i] = price;\r\n            timestamps[i] = timestamp;\r\n        }\r\n        return (prices, timestamps);\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @dev Internal so that feeds inheriting this one are not obligated to have an exposed update(...) method, but can still perform updates\r\n    function _updatePrices(address[] ofAssets, uint[] newPrices)\r\n        internal\r\n        pre_cond(ofAssets.length == newPrices.length)\r\n    {\r\n        updateId++;\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            require(registrar.assetIsRegistered(ofAssets[i]));\r\n            require(assetsToPrices[ofAssets[i]].timestamp != now); // prevent two updates in one block\r\n            assetsToPrices[ofAssets[i]].timestamp = now;\r\n            assetsToPrices[ofAssets[i]].price = newPrices[i];\r\n        }\r\n        emit PriceUpdated(keccak256(ofAssets, newPrices));\r\n    }\r\n}\r\n\r\ncontract StakingPriceFeed is SimplePriceFeed {\r\n\r\n    OperatorStaking public stakingContract;\r\n    AssetInterface public stakingToken;\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param ofRegistrar Address of canonical registrar\r\n    /// @param ofSuperFeed Address of superfeed\r\n    function StakingPriceFeed(\r\n        address ofRegistrar,\r\n        address ofQuoteAsset,\r\n        address ofSuperFeed\r\n    )\r\n        SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)\r\n    {\r\n        stakingContract = OperatorStaking(ofSuperFeed); // canonical feed *is* staking contract\r\n        stakingToken = AssetInterface(stakingContract.stakingToken());\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @param amount Number of tokens to stake for this feed\r\n    /// @param data Data may be needed for some future applications (can be empty for now)\r\n    function depositStake(uint amount, bytes data)\r\n        external\r\n        auth\r\n    {\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n        require(stakingToken.approve(stakingContract, amount));\r\n        stakingContract.stake(amount, data);\r\n    }\r\n\r\n    /// @param amount Number of tokens to unstake for this feed\r\n    /// @param data Data may be needed for some future applications (can be empty for now)\r\n    function unstake(uint amount, bytes data) {\r\n        stakingContract.unstake(amount, data);\r\n    }\r\n\r\n    function withdrawStake()\r\n        external\r\n        auth\r\n    {\r\n        uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));\r\n        stakingContract.withdrawStake();\r\n        require(stakingToken.transfer(msg.sender, amountToWithdraw));\r\n    }\r\n}\r\n\r\ninterface RiskMgmtInterface {\r\n\r\n    // METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks if the makeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If makeOrder is permitted\r\n    function isMakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks if the takeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If takeOrder is permitted\r\n    function isTakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ncontract OperatorStaking is DBC {\r\n\r\n    // EVENTS\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event StakeBurned(address indexed user, uint256 amount, bytes data);\r\n\r\n    // TYPES\r\n\r\n    struct StakeData {\r\n        uint amount;\r\n        address staker;\r\n    }\r\n\r\n    // Circular linked list\r\n    struct Node {\r\n        StakeData data;\r\n        uint prev;\r\n        uint next;\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // INTERNAL FIELDS\r\n    Node[] internal stakeNodes; // Sorted circular linked list nodes containing stake data (Built on top https://programtheblockchain.com/posts/2018/03/30/storage-patterns-doubly-linked-list/)\r\n\r\n    // PUBLIC FIELDS\r\n    uint public minimumStake;\r\n    uint public numOperators;\r\n    uint public withdrawalDelay;\r\n    mapping (address => bool) public isRanked;\r\n    mapping (address => uint) public latestUnstakeTime;\r\n    mapping (address => uint) public stakeToWithdraw;\r\n    mapping (address => uint) public stakedAmounts;\r\n    uint public numStakers; // Current number of stakers (Needed because of array holes)\r\n    AssetInterface public stakingToken;\r\n\r\n    // TODO: consider renaming \"operator\" depending on how this is implemented\r\n    //  (i.e. is pricefeed staking itself?)\r\n    function OperatorStaking(\r\n        AssetInterface _stakingToken,\r\n        uint _minimumStake,\r\n        uint _numOperators,\r\n        uint _withdrawalDelay\r\n    )\r\n        public\r\n    {\r\n        require(address(_stakingToken) != address(0));\r\n        stakingToken = _stakingToken;\r\n        minimumStake = _minimumStake;\r\n        numOperators = _numOperators;\r\n        withdrawalDelay = _withdrawalDelay;\r\n        StakeData memory temp = StakeData({ amount: 0, staker: address(0) });\r\n        stakeNodes.push(Node(temp, 0, 0));\r\n    }\r\n\r\n    // METHODS : STAKING\r\n\r\n    function stake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n        pre_cond(amount >= minimumStake)\r\n    {\r\n        uint tailNodeId = stakeNodes[0].prev;\r\n        stakedAmounts[msg.sender] += amount;\r\n        updateStakerRanking(msg.sender);\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n\r\n    function unstake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n    {\r\n        uint preStake = stakedAmounts[msg.sender];\r\n        uint postStake = preStake - amount;\r\n        require(postStake >= minimumStake || postStake == 0);\r\n        require(stakedAmounts[msg.sender] >= amount);\r\n        latestUnstakeTime[msg.sender] = block.timestamp;\r\n        stakedAmounts[msg.sender] -= amount;\r\n        stakeToWithdraw[msg.sender] += amount;\r\n        updateStakerRanking(msg.sender);\r\n        emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);\r\n    }\r\n\r\n    function withdrawStake()\r\n        public\r\n        pre_cond(stakeToWithdraw[msg.sender] > 0)\r\n        pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)\r\n    {\r\n        uint amount = stakeToWithdraw[msg.sender];\r\n        stakeToWithdraw[msg.sender] = 0;\r\n        require(stakingToken.transfer(msg.sender, amount));\r\n    }\r\n\r\n    // VIEW FUNCTIONS\r\n\r\n    function isValidNode(uint id) view returns (bool) {\r\n        // 0 is a sentinel and therefore invalid.\r\n        // A valid node is the head or has a previous node.\r\n        return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);\r\n    }\r\n\r\n    function searchNode(address staker) view returns (uint) {\r\n        uint current = stakeNodes[0].next;\r\n        while (isValidNode(current)) {\r\n            if (staker == stakeNodes[current].data.staker) {\r\n                return current;\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function isOperator(address user) view returns (bool) {\r\n        address[] memory operators = getOperators();\r\n        for (uint i; i < operators.length; i++) {\r\n            if (operators[i] == user) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getOperators()\r\n        view\r\n        returns (address[])\r\n    {\r\n        uint arrLength = (numOperators > numStakers) ?\r\n            numStakers :\r\n            numOperators;\r\n        address[] memory operators = new address[](arrLength);\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < arrLength; i++) {\r\n            operators[i] = stakeNodes[current].data.staker;\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return operators;\r\n    }\r\n\r\n    function getStakersAndAmounts()\r\n        view\r\n        returns (address[], uint[])\r\n    {\r\n        address[] memory stakers = new address[](numStakers);\r\n        uint[] memory amounts = new uint[](numStakers);\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < numStakers; i++) {\r\n            stakers[i] = stakeNodes[current].data.staker;\r\n            amounts[i] = stakeNodes[current].data.amount;\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return (stakers, amounts);\r\n    }\r\n\r\n    function totalStakedFor(address user)\r\n        view\r\n        returns (uint)\r\n    {\r\n        return stakedAmounts[user];\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    // DOUBLY-LINKED LIST\r\n\r\n    function insertNodeSorted(uint amount, address staker) internal returns (uint) {\r\n        uint current = stakeNodes[0].next;\r\n        if (current == 0) return insertNodeAfter(0, amount, staker);\r\n        while (isValidNode(current)) {\r\n            if (amount > stakeNodes[current].data.amount) {\r\n                break;\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return insertNodeBefore(current, amount, staker);\r\n    }\r\n\r\n    function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {\r\n\r\n        // 0 is allowed here to insert at the beginning.\r\n        require(id == 0 || isValidNode(id));\r\n\r\n        Node storage node = stakeNodes[id];\r\n\r\n        stakeNodes.push(Node({\r\n            data: StakeData(amount, staker),\r\n            prev: id,\r\n            next: node.next\r\n        }));\r\n\r\n        newID = stakeNodes.length - 1;\r\n\r\n        stakeNodes[node.next].prev = newID;\r\n        node.next = newID;\r\n        numStakers++;\r\n    }\r\n\r\n    function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {\r\n        return insertNodeAfter(stakeNodes[id].prev, amount, staker);\r\n    }\r\n\r\n    function removeNode(uint id) internal {\r\n        require(isValidNode(id));\r\n\r\n        Node storage node = stakeNodes[id];\r\n\r\n        stakeNodes[node.next].prev = node.prev;\r\n        stakeNodes[node.prev].next = node.next;\r\n\r\n        delete stakeNodes[id];\r\n        numStakers--;\r\n    }\r\n\r\n    // UPDATING OPERATORS\r\n\r\n    function updateStakerRanking(address _staker) internal {\r\n        uint newStakedAmount = stakedAmounts[_staker];\r\n        if (newStakedAmount == 0) {\r\n            isRanked[_staker] = false;\r\n            removeStakerFromArray(_staker);\r\n        } else if (isRanked[_staker]) {\r\n            removeStakerFromArray(_staker);\r\n            insertNodeSorted(newStakedAmount, _staker);\r\n        } else {\r\n            isRanked[_staker] = true;\r\n            insertNodeSorted(newStakedAmount, _staker);\r\n        }\r\n    }\r\n\r\n    function removeStakerFromArray(address _staker) internal {\r\n        uint id = searchNode(_staker);\r\n        require(id > 0);\r\n        removeNode(id);\r\n    }\r\n\r\n}\r\n\r\ncontract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {\r\n\r\n    // EVENTS\r\n    event SetupPriceFeed(address ofPriceFeed);\r\n\r\n    struct HistoricalPrices {\r\n        address[] assets;\r\n        uint[] prices;\r\n        uint timestamp;\r\n    }\r\n\r\n    // FIELDS\r\n    bool public updatesAreAllowed = true;\r\n    uint public minimumPriceCount = 1;\r\n    uint public VALIDITY;\r\n    uint public INTERVAL;\r\n    mapping (address => bool) public isStakingFeed; // If the Staking Feed has been created through this contract\r\n    HistoricalPrices[] public priceHistory;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Define and register a quote asset against which all prices are measured/based against\r\n    /// @param ofStakingAsset Address of staking asset (may or may not be quoteAsset)\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param quoteAssetName Name of quote asset\r\n    /// @param quoteAssetSymbol Symbol for quote asset\r\n    /// @param quoteAssetDecimals Decimal places for quote asset\r\n    /// @param quoteAssetUrl URL related to quote asset\r\n    /// @param quoteAssetIpfsHash IPFS hash associated with quote asset\r\n    /// @param quoteAssetBreakInBreakOut Break-in/break-out for quote asset on destination chain\r\n    /// @param quoteAssetStandards EIP standards quote asset adheres to\r\n    /// @param quoteAssetFunctionSignatures Whitelisted functions of quote asset contract\r\n    // /// @param interval Number of seconds between pricefeed updates (this interval is not enforced on-chain, but should be followed by the datafeed maintainer)\r\n    // /// @param validity Number of seconds that datafeed update information is valid for\r\n    /// @param ofGovernance Address of contract governing the Canonical PriceFeed\r\n    function CanonicalPriceFeed(\r\n        address ofStakingAsset,\r\n        address ofQuoteAsset, // Inital entry in asset registrar contract is Melon (QUOTE_ASSET)\r\n        bytes32 quoteAssetName,\r\n        bytes8 quoteAssetSymbol,\r\n        uint quoteAssetDecimals,\r\n        string quoteAssetUrl,\r\n        string quoteAssetIpfsHash,\r\n        address[2] quoteAssetBreakInBreakOut,\r\n        uint[] quoteAssetStandards,\r\n        bytes4[] quoteAssetFunctionSignatures,\r\n        uint[2] updateInfo, // interval, validity\r\n        uint[3] stakingInfo, // minStake, numOperators, unstakeDelay\r\n        address ofGovernance\r\n    )\r\n        OperatorStaking(\r\n            AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]\r\n        )\r\n        SimplePriceFeed(address(this), ofQuoteAsset, address(0))\r\n    {\r\n        registerAsset(\r\n            ofQuoteAsset,\r\n            quoteAssetName,\r\n            quoteAssetSymbol,\r\n            quoteAssetDecimals,\r\n            quoteAssetUrl,\r\n            quoteAssetIpfsHash,\r\n            quoteAssetBreakInBreakOut,\r\n            quoteAssetStandards,\r\n            quoteAssetFunctionSignatures\r\n        );\r\n        INTERVAL = updateInfo[0];\r\n        VALIDITY = updateInfo[1];\r\n        setOwner(ofGovernance);\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @notice Create a new StakingPriceFeed\r\n    function setupStakingPriceFeed() external {\r\n        address ofStakingPriceFeed = new StakingPriceFeed(\r\n            address(this),\r\n            stakingToken,\r\n            address(this)\r\n        );\r\n        isStakingFeed[ofStakingPriceFeed] = true;\r\n        StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);\r\n        emit SetupPriceFeed(ofStakingPriceFeed);\r\n    }\r\n\r\n    /// @dev override inherited update function to prevent manual update from authority\r\n    function update() external { revert(); }\r\n\r\n    /// @dev Burn state for a pricefeed operator\r\n    /// @param user Address of pricefeed operator to burn the stake from\r\n    function burnStake(address user)\r\n        external\r\n        auth\r\n    {\r\n        uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);\r\n        stakedAmounts[user] = 0;\r\n        stakeToWithdraw[user] = 0;\r\n        updateStakerRanking(user);\r\n        emit StakeBurned(user, totalToBurn, \"\");\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    // STAKING\r\n\r\n    function stake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n        pre_cond(isStakingFeed[msg.sender])\r\n    {\r\n        OperatorStaking.stake(amount, data);\r\n    }\r\n\r\n    // function stakeFor(\r\n    //     address user,\r\n    //     uint amount,\r\n    //     bytes data\r\n    // )\r\n    //     public\r\n    //     pre_cond(isStakingFeed[user])\r\n    // {\r\n\r\n    //     OperatorStaking.stakeFor(user, amount, data);\r\n    // }\r\n\r\n    // AGGREGATION\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    function collectAndUpdate(address[] ofAssets)\r\n        public\r\n        auth\r\n        pre_cond(updatesAreAllowed)\r\n    {\r\n        uint[] memory newPrices = pricesToCommit(ofAssets);\r\n        priceHistory.push(\r\n            HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})\r\n        );\r\n        _updatePrices(ofAssets, newPrices);\r\n    }\r\n\r\n    function pricesToCommit(address[] ofAssets)\r\n        view\r\n        returns (uint[])\r\n    {\r\n        address[] memory operators = getOperators();\r\n        uint[] memory newPrices = new uint[](ofAssets.length);\r\n        for (uint i = 0; i < ofAssets.length; i++) {\r\n            uint[] memory assetPrices = new uint[](operators.length);\r\n            for (uint j = 0; j < operators.length; j++) {\r\n                SimplePriceFeed feed = SimplePriceFeed(operators[j]);\r\n                var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);\r\n                if (now > add(timestamp, VALIDITY)) {\r\n                    continue; // leaves a zero in the array (dealt with later)\r\n                }\r\n                assetPrices[j] = price;\r\n            }\r\n            newPrices[i] = medianize(assetPrices);\r\n        }\r\n        return newPrices;\r\n    }\r\n\r\n    /// @dev from MakerDao medianizer contract\r\n    function medianize(uint[] unsorted)\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint numValidEntries;\r\n        for (uint i = 0; i < unsorted.length; i++) {\r\n            if (unsorted[i] != 0) {\r\n                numValidEntries++;\r\n            }\r\n        }\r\n        if (numValidEntries < minimumPriceCount) {\r\n            revert();\r\n        }\r\n        uint counter;\r\n        uint[] memory out = new uint[](numValidEntries);\r\n        for (uint j = 0; j < unsorted.length; j++) {\r\n            uint item = unsorted[j];\r\n            if (item != 0) {    // skip zero (invalid) entries\r\n                if (counter == 0 || item >= out[counter - 1]) {\r\n                    out[counter] = item;  // item is larger than last in array (we are home)\r\n                } else {\r\n                    uint k = 0;\r\n                    while (item >= out[k]) {\r\n                        k++;  // get to where element belongs (between smaller and larger items)\r\n                    }\r\n                    for (uint l = counter; l > k; l--) {\r\n                        out[l] = out[l - 1];    // bump larger elements rightward to leave slot\r\n                    }\r\n                    out[k] = item;\r\n                }\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        uint value;\r\n        if (counter % 2 == 0) {\r\n            uint value1 = uint(out[(counter / 2) - 1]);\r\n            uint value2 = uint(out[(counter / 2)]);\r\n            value = add(value1, value2) / 2;\r\n        } else {\r\n            value = out[(counter - 1) / 2];\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }\r\n    function enableUpdates() auth { updatesAreAllowed = true; }\r\n    function disableUpdates() auth { updatesAreAllowed = false; }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // FEED INFORMATION\r\n\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getInterval() view returns (uint) { return INTERVAL; }\r\n    function getValidity() view returns (uint) { return VALIDITY; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    // PRICES\r\n\r\n    /// @notice Whether price of asset has been updated less than VALIDITY seconds ago\r\n    /// @param ofAsset Asset in registrar\r\n    /// @return isRecent Price information ofAsset is recent\r\n    function hasRecentPrice(address ofAsset)\r\n        view\r\n        pre_cond(assetIsRegistered(ofAsset))\r\n        returns (bool isRecent)\r\n    {\r\n        var ( , timestamp) = getPrice(ofAsset);\r\n        return (sub(now, timestamp) <= VALIDITY);\r\n    }\r\n\r\n    /// @notice Whether prices of assets have been updated less than VALIDITY seconds ago\r\n    /// @param ofAssets All assets in registrar\r\n    /// @return isRecent Price information ofAssets array is recent\r\n    function hasRecentPrices(address[] ofAssets)\r\n        view\r\n        returns (bool areRecent)\r\n    {\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            if (!hasRecentPrice(ofAssets[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getPriceInfo(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint price, uint assetDecimals)\r\n    {\r\n        isRecent = hasRecentPrice(ofAsset);\r\n        (price, ) = getPrice(ofAsset);\r\n        assetDecimals = getDecimals(ofAsset);\r\n    }\r\n\r\n    /**\r\n    @notice Gets inverted price of an asset\r\n    @dev Asset has been initialised and its price is non-zero\r\n    @dev Existing price ofAssets quoted in QUOTE_ASSET (convention)\r\n    @param ofAsset Asset for which inverted price should be return\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"invertedPrice\": \"Price based (instead of quoted) against QUOTE_ASSET\",\r\n        \"assetDecimals\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getInvertedPriceInfo(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint invertedPrice, uint assetDecimals)\r\n    {\r\n        uint inputPrice;\r\n        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);\r\n\r\n        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\r\n        uint quoteDecimals = getDecimals(QUOTE_ASSET);\r\n\r\n        return (\r\n            isRecent,\r\n            mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,\r\n            quoteDecimals   // TODO: check on this; shouldn't it be assetDecimals?\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice Gets reference price of an asset pair\r\n    @dev One of the address is equal to quote asset\r\n    @dev either ofBase == QUOTE_ASSET or ofQuote == QUOTE_ASSET\r\n    @param ofBase Address of base asset\r\n    @param ofQuote Address of quote asset\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"referencePrice\": \"Reference price\",\r\n        \"decimal\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getReferencePriceInfo(address ofBase, address ofQuote)\r\n        view\r\n        returns (bool isRecent, uint referencePrice, uint decimal)\r\n    {\r\n        if (getQuoteAsset() == ofQuote) {\r\n            (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);\r\n        } else if (getQuoteAsset() == ofBase) {\r\n            (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);\r\n        } else {\r\n            revert(); // no suitable reference price available\r\n        }\r\n    }\r\n\r\n    /// @notice Gets price of Order\r\n    /// @param sellAsset Address of the asset to be sold\r\n    /// @param buyAsset Address of the asset to be bought\r\n    /// @param sellQuantity Quantity in base units being sold of sellAsset\r\n    /// @param buyQuantity Quantity in base units being bought of buyAsset\r\n    /// @return orderPrice Price as determined by an order\r\n    function getOrderPriceInfo(\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        view\r\n        returns (uint orderPrice)\r\n    {\r\n        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\r\n    }\r\n\r\n    /// @notice Checks whether data exists for a given asset pair\r\n    /// @dev Prices are only upated against QUOTE_ASSET\r\n    /// @param sellAsset Asset for which check to be done if data exists\r\n    /// @param buyAsset Asset for which check to be done if data exists\r\n    /// @return Whether assets exist for given asset pair\r\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\r\n        view\r\n        returns (bool isExistent)\r\n    {\r\n        return\r\n            hasRecentPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            hasRecentPrice(buyAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) && // One asset must be QUOTE_ASSET\r\n            (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET); // Pair must consists of diffrent assets\r\n    }\r\n\r\n    /// @return Sparse array of addresses of owned pricefeeds\r\n    function getPriceFeedsByOwner(address _owner)\r\n        view\r\n        returns(address[])\r\n    {\r\n        address[] memory ofPriceFeeds = new address[](numStakers);\r\n        if (numStakers == 0) return ofPriceFeeds;\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < numStakers; i++) {\r\n            StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);\r\n            if (stakingFeed.owner() == _owner) {\r\n                ofPriceFeeds[i] = address(stakingFeed);\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return ofPriceFeeds;\r\n    }\r\n\r\n    function getHistoryLength() returns (uint) { return priceHistory.length; }\r\n\r\n    function getHistoryAt(uint id) returns (address[], uint[], uint) {\r\n        address[] memory assets = priceHistory[id].assets;\r\n        uint[] memory prices = priceHistory[id].prices;\r\n        uint timestamp = priceHistory[id].timestamp;\r\n        return (assets, prices, timestamp);\r\n    }\r\n}\r\n\r\ninterface VersionInterface {\r\n\r\n    // EVENTS\r\n\r\n    event FundUpdated(uint id);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function shutDown() external;\r\n\r\n    function setupFund(\r\n        bytes32 ofFundName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address[] ofExchanges,\r\n        address[] ofDefaultAssets,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n    function shutDownFund(address ofFund);\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getNativeAsset() view returns (address);\r\n    function getFundById(uint withId) view returns (address);\r\n    function getLastFundId() view returns (uint);\r\n    function getFundByManager(address ofManager) view returns (address);\r\n    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"},{\"name\":\"orderAddresses\",\"type\":\"address[5]\"},{\"name\":\"orderValues\",\"type\":\"uint256[8]\"},{\"name\":\"identifier\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"},{\"name\":\"orderAddresses\",\"type\":\"address[5]\"},{\"name\":\"orderValues\",\"type\":\"uint256[8]\"},{\"name\":\"identifier\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"makeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"}],\"name\":\"getLastOrderId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"targetExchange\",\"type\":\"address\"},{\"name\":\"orderAddresses\",\"type\":\"address[5]\"},{\"name\":\"orderValues\",\"type\":\"uint256[8]\"},{\"name\":\"identifier\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"takeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ZeroExV1Adapter","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d7218bbb1e7a1a3b02fecd42ff74e6854d798db9918f3ef330c3e670b979578b"}]}