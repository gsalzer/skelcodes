{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract DomainAuction {\r\n    address public owner;\r\n\r\n    struct Bid {\r\n        uint timestamp;\r\n        address bidder;\r\n        uint amount;\r\n        string url;\r\n    }\r\n\r\n    struct WinningBid {\r\n        uint winTimestamp;\r\n        uint bidTimestamp;\r\n        address bidder;\r\n        uint bidAmount;\r\n        string url;\r\n    }\r\n\r\n    Bid public highestBid;\r\n\r\n    WinningBid public winningBid;\r\n\r\n    event BidLog(uint timestamp, address bidder, uint amount, string url);\r\n    event WinningBidLog(uint winTimestamp, uint bidTimestamp, address bidder, uint amount, string url);\r\n    event Refund(uint timestamp, address bidder, uint amount);\r\n\r\n    ///////////////////////////////////\r\n\r\n    function placeBid(string url) public payable {\r\n        require(msg.value >= ((highestBid.amount * 11) / 10));\r\n        Bid memory newBid = Bid(now, msg.sender, msg.value, url);\r\n\r\n        // Refund the current highest bid.\r\n        // Do not refund anything on the first `placeBid` call.\r\n        if (highestBid.bidder != 0) {\r\n            refundBid(highestBid);\r\n        }\r\n\r\n        // Update the highest bid and log the event\r\n        highestBid = newBid;\r\n        emit BidLog(newBid.timestamp, newBid.bidder, newBid.amount, newBid.url);\r\n    }\r\n\r\n    // This might fail if the bidder is trying some contract bullshit, but they do this\r\n    // at their own risk. It won't fail if the bidder is a non-contract address.\r\n    // It is very important to use `send` instead of `transfer`. Otherwise this could fail\r\n    // and this contract could get hijacked.\r\n    // See https://ethereum.stackexchange.com/questions/19341/address-send-vs-address-transfer-best-practice-usage\r\n    function refundBid(Bid bid) private {\r\n        bid.bidder.send(bid.amount);\r\n        emit Refund(now, bid.bidder, bid.amount);\r\n    }\r\n\r\n    // This will need to be triggered externally every x days\r\n    function pickWinner() public payable {\r\n        require(msg.sender == owner);\r\n\r\n        if (winningBid.bidTimestamp != highestBid.timestamp) {\r\n          // Have to store the new winning bid in memory in order to emit it as part\r\n          // of an event. Can't emit an event straight from a stored variable.\r\n          WinningBid memory newWinningBid = WinningBid(now, highestBid.timestamp, highestBid.bidder, highestBid.amount, highestBid.url);\r\n          winningBid = newWinningBid;\r\n          emit WinningBidLog(\r\n              newWinningBid.winTimestamp,\r\n              newWinningBid.bidTimestamp,\r\n              newWinningBid.bidder,\r\n              newWinningBid.bidAmount,\r\n              newWinningBid.url\r\n          );\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////\r\n\r\n    constructor() public payable {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function withdraw() public {\r\n        if (msg.sender == owner) owner.send(address(this).balance);\r\n    }\r\n\r\n    function kill() public {\r\n        if (msg.sender == owner) selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pickWinner\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningBid\",\"outputs\":[{\"name\":\"winTimestamp\",\"type\":\"uint256\"},{\"name\":\"bidTimestamp\",\"type\":\"uint256\"},{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highestBid\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"url\",\"type\":\"string\"}],\"name\":\"placeBid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"url\",\"type\":\"string\"}],\"name\":\"BidLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bidTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"url\",\"type\":\"string\"}],\"name\":\"WinningBidLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"DomainAuction","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://921c877b8634aa8b79e7f2b3deebdeed47ce78f4bec730666bf12727b53dbf2b"}]}