{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n// The frontend for this smart contract is a dApp hosted at\r\n// https://hire.kohweijie.com\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n// The frontend for this smart contract is a dApp hosted at\r\n// https://hire.kohweijie.com\r\ncontract HireMe is Ownable {\r\n    struct Bid { // Data structure representing an individual bid\r\n        bool exists;         // 0. Whether the bid exists\r\n        uint id;             // 1. The ID of the bid.\r\n        uint timestamp;      // 2. The timestamp of when the bid was made\r\n        address bidder;      // 3. The address of the bidder\r\n        uint amount;         // 4. The amount of ETH in the bid\r\n        string email;        // 5. The bidder's email address\r\n        string organisation; // 6. The bidder's organisation\r\n    }\r\n\r\n    event BidMade(uint indexed id, address indexed bidder, uint indexed amount);\r\n    event Reclaimed(address indexed bidder, uint indexed amount);\r\n    event Donated(uint indexed amount);\r\n\r\n    Bid[] public bids; // Array of all bids\r\n    uint[] public bidIds; // Array of all bid IDs\r\n\r\n    // Constants which govern the bid prices and auction duration\r\n    uint private constant MIN_BID = 1 ether;\r\n    uint private constant BID_STEP = 0.01 ether;\r\n    uint private constant INITIAL_BIDS = 4;\r\n\r\n    uint private constant EXPIRY_DAYS_BEFORE = 7 days;\r\n    uint private constant EXPIRY_DAYS_AFTER = 3 days;\r\n\r\n    // For development only\r\n    //uint private constant EXPIRY_DAYS_BEFORE = 10 minutes;\r\n    //uint private constant EXPIRY_DAYS_AFTER = 10 minutes;\r\n\r\n    // SHA256 checksum of https://github.com/weijiekoh/hireme/blob/master/AUTHOR.asc\r\n    // See the bottom of this file for the contents of AUTHOR.asc\r\n    string public constant AUTHORSIGHASH = \"8c8b82a2d83a33cb0f45f5f6b22b45c1955f08fc54e7ab4d9e76fb76843c4918\";\r\n\r\n    // Whether the donate() function has been called\r\n    bool public donated = false;\r\n\r\n    // Whether the manuallyEndAuction() function has been called\r\n    bool public manuallyEnded = false;\r\n\r\n    // Tracks the total amount of ETH currently residing in the contract\r\n    // balance per address.\r\n    mapping (address => uint) public addressBalance;\r\n\r\n    // The Internet Archive's ETH donation address\r\n    address public charityAddress = 0x635599b0ab4b5c6B1392e0a2D1d69cF7d1ddDF02;\r\n\r\n    // Only the contract owner may end this contract, and may do so only if\r\n    // there are 0 bids.\r\n    function manuallyEndAuction () public onlyOwner {\r\n        require(manuallyEnded == false);\r\n        require(bids.length == 0);\r\n\r\n        manuallyEnded = true;\r\n    }\r\n\r\n    // Place a bid.\r\n    function bid(string _email, string _organisation) public payable {\r\n        address _bidder = msg.sender;\r\n        uint _amount = msg.value;\r\n        uint _id = bids.length;\r\n\r\n        // The auction must not be over\r\n        require(!hasExpired() && !manuallyEnded);\r\n\r\n        // The bidder must be neither the contract owner nor the charity\r\n        // donation address\r\n        require(_bidder != owner && _bidder != charityAddress);\r\n\r\n        // The bidder address, email, and organisation must valid\r\n        require(_bidder != address(0));\r\n        require(bytes(_email).length > 0);\r\n        require(bytes(_organisation).length > 0);\r\n\r\n        // Make sure the amount bid is more than the rolling minimum bid\r\n        require(_amount >= calcCurrentMinBid());\r\n\r\n        // Update the state with the new bid\r\n        bids.push(Bid(true, _id, now, _bidder, _amount, _email, _organisation));\r\n        bidIds.push(_id);\r\n\r\n        // Add to, not replace, the state variable which tracks the total\r\n        // amount paid per address, because a bidder may make multiple bids\r\n        addressBalance[_bidder] = SafeMath.add(addressBalance[_bidder], _amount);\r\n\r\n        // Emit the event\r\n        BidMade(_id, _bidder, _amount);\r\n    }\r\n\r\n    function reclaim () public {\r\n        address _caller = msg.sender;\r\n        uint _amount = calcAmtReclaimable(_caller);\r\n\r\n        // There must be at least 2 bids. Note that if there is only 1 bid and\r\n        // that bid is the winning bid, it cannot be reclaimed.\r\n        require(bids.length >= 2);\r\n\r\n        // The auction must not have been manually ended\r\n        require(!manuallyEnded);\r\n\r\n        // Make sure the amount to reclaim is more than 0\r\n        require(_amount > 0);\r\n\r\n        // Subtract the amount to be reclaimed from the state variable which\r\n        // tracks the total amount paid per address\r\n        uint _newTotal = SafeMath.sub(addressBalance[_caller], _amount);\r\n\r\n        // The amount must not be negative, or the contract is buggy\r\n        assert(_newTotal >= 0);\r\n\r\n        // Update the state to prevent double-spending\r\n        addressBalance[_caller] = _newTotal;\r\n\r\n        // Make the transfer\r\n        _caller.transfer(_amount);\r\n\r\n        // Emit the event\r\n        Reclaimed(_caller, _amount);\r\n    }\r\n\r\n    function donate () public {\r\n        // donate() can only be called once\r\n        assert(donated == false);\r\n\r\n        // Only the contract owner or the charity address may send the funds to\r\n        // charityAddress\r\n        require(msg.sender == owner || msg.sender == charityAddress);\r\n\r\n        // The auction must be over\r\n        require(hasExpired());\r\n\r\n        // If the auction has been manually ended at this point, the contract\r\n        // is buggy\r\n        assert(!manuallyEnded);\r\n\r\n        // There must be at least 1 bid, or the contract is buggy\r\n        assert(bids.length > 0);\r\n\r\n        // Calculate the amount to donate\r\n        uint _amount;\r\n        if (bids.length == 1) {\r\n            // If there is only 1 bid, transfer that amount\r\n            _amount = bids[0].amount;\r\n        } else {\r\n            // If there is more than 1 bid, transfer the second highest bid\r\n            _amount = bids[SafeMath.sub(bids.length, 2)].amount;\r\n        }\r\n\r\n        // The amount to be donated must be more than 0, or this contract is\r\n        // buggy\r\n        assert(_amount > 0);\r\n\r\n        // Prevent double-donating\r\n        donated = true;\r\n\r\n        // Transfer the winning bid amount to charity\r\n        charityAddress.transfer(_amount);\r\n        Donated(_amount);\r\n    }\r\n\r\n    function calcCurrentMinBid () public view returns (uint) {\r\n        if (bids.length == 0) {\r\n            return MIN_BID;\r\n        } else {\r\n            uint _lastBidId = SafeMath.sub(bids.length, 1);\r\n            uint _lastBidAmt = bids[_lastBidId].amount;\r\n            return SafeMath.add(_lastBidAmt, BID_STEP);\r\n        }\r\n    }\r\n\r\n    function calcAmtReclaimable (address _bidder) public view returns (uint) {\r\n        // This function calculates the amount that _bidder can get back.\r\n\r\n        // A. if the auction is over, and _bidder is the winner, they should\r\n        // get back the total amount bid minus the second highest bid.\r\n\r\n        // B. if the auction is not over, and _bidder is not the current\r\n        // winner, they should get back the total they had bid\r\n\r\n        // C. if the auction is ongoing, and _bidder is the current winner,\r\n        // they should get back the total amount they had bid minus the top\r\n        // bid.\r\n\r\n        // D. if the auction is ongoing, and _bidder is not the current winner,\r\n        // they should get back the total amount they had bid.\r\n\r\n        uint _totalAmt = addressBalance[_bidder];\r\n\r\n        if (bids.length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (bids[SafeMath.sub(bids.length, 1)].bidder == _bidder) {\r\n            // If the bidder is the current winner\r\n            if (hasExpired()) { // scenario A\r\n                uint _secondPrice = bids[SafeMath.sub(bids.length, 2)].amount;\r\n                return SafeMath.sub(_totalAmt, _secondPrice);\r\n\r\n            } else { // scenario C\r\n                uint _highestPrice = bids[SafeMath.sub(bids.length, 1)].amount;\r\n                return SafeMath.sub(_totalAmt, _highestPrice);\r\n            }\r\n\r\n        } else { // scenarios B and D\r\n            // If the bidder is not the current winner\r\n            return _totalAmt;\r\n        }\r\n    }\r\n\r\n    function getBidIds () public view returns (uint[]) {\r\n        return bidIds;\r\n    }\r\n\r\n    // Calcuate the timestamp after which the auction will expire\r\n    function expiryTimestamp () public view returns (uint) {\r\n        uint _numBids = bids.length;\r\n\r\n        // There is no expiry if there are no bids\r\n        require(_numBids > 0);\r\n\r\n        // The timestamp of the most recent bid\r\n        uint _lastBidTimestamp = bids[SafeMath.sub(_numBids, 1)].timestamp;\r\n\r\n        if (_numBids <= INITIAL_BIDS) {\r\n            return SafeMath.add(_lastBidTimestamp, EXPIRY_DAYS_BEFORE);\r\n        } else {\r\n            return SafeMath.add(_lastBidTimestamp, EXPIRY_DAYS_AFTER);\r\n        }\r\n    }\r\n\r\n    function hasExpired () public view returns (bool) {\r\n        uint _numBids = bids.length;\r\n\r\n        // The auction cannot expire if there are no bids\r\n        if (_numBids == 0) {\r\n            return false;\r\n        } else {\r\n            // Compare with the current time\r\n            return now >= this.expiryTimestamp();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Contents of AUTHOR.asc and AUTHOR (remove the backslashes which preface each\r\n// line)\r\n\r\n// AUTHOR.asc:\r\n//-----BEGIN PGP SIGNATURE-----\r\n//\r\n//iQIzBAABCAAdBQJak6eBFhxjb250YWN0QGtvaHdlaWppZS5jb20ACgkQkNtDYXzM\r\n//FjKytA/+JF75jH+d/9nEitJKRcsrFgadVjMwNjUt1B7IvoZJqpHj9BSHtKhsVEI5\r\n//iME24rgbr3YRXLi7GbQS+Ovyf3Ks7BHCA/t12PWOVm9zRBEswojZIg1UjTqtYboS\r\n//0xrnrY8A71g1RX/jN4uCQ9FohRMAPzTTV9Gt6XDpB9Uzk0HBkUOpVHPnqxSerzbp\r\n//fSwTCzLgcsTKUJYfeOQMuSwTTXc/btJss82WQpK76xdi5+4hp3tjyZZuY7ruj60N\r\n//g9f9pHafsWRujMhmX0G8btjK/7/cJL/KbFFafb3sA7Xes0uoUbs+pQXTvuMBx2g5\r\n//1/BH63aHXdZC2/767JyR18gZN6PnwsZt7i8CowvDcGMni5f0la4O53HCZEGaHYFf\r\n//IKnJX4LhEJEezcflqSgxm1y7hlUFqC1T7janL0s4rCxoW7iPgNlii62vSzg0TTwH\r\n//9L6v8aYwWgAwfma2o3XWMCjA/K/BIfWd2w+1ex/gvTVCefOxz1zEPdjhWh89fopb\r\n//ydxV4fllXLXoB2wmv305E4eryq4lX40w9WxO7Dxq3yU+fmK8BaXLsjUf4fT9AU1m\r\n//VEo3ndjFXkSELwqTQalxod41j4rYxS6SyxOj6R3/3ejbJIL0kzwKuDlZIkj8Xsfx\r\n//o2b+QtKANMwC2KRZQBnNdnF2XVOCEFW1XZykWPW6FR1iYS6WEJ0=\r\n//=J3JJ\r\n//-----END PGP SIGNATURE-----\r\n\r\n// AUTHOR:\r\n//Koh Wei Jie <contact@kohweijie.com>","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"bidder\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"email\",\"type\":\"string\"},{\"name\":\"organisation\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manuallyEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasExpired\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_email\",\"type\":\"string\"},{\"name\":\"_organisation\",\"type\":\"string\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expiryTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"charityAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calcCurrentMinBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bidder\",\"type\":\"address\"}],\"name\":\"calcAmtReclaimable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manuallyEndAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBidIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bidIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTHORSIGHASH\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BidMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reclaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Donated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"HireMe","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1eb1bb80a3d0bdc3265169c0d6ff48165adf58b26fc38d49afcbf34db71389ae"}]}