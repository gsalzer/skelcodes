{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\nlibrary Bonus {\r\n    uint256 constant pointMultiplier = 1e18; //100% = 1*10^18 points\r\n\r\n    function getBonusFactor(uint256 soldToUser)\r\n    internal pure returns (uint256 factor)\r\n    {\r\n        uint256 tokenSold = soldToUser / pointMultiplier;\r\n        //compare whole coins\r\n\r\n        //yes, this is spaghetti code, to avoid complex formulas which would need 3 different sections anyways.\r\n        if (tokenSold >= 100000) {\r\n            return 100;\r\n        }\r\n        //0.5% less per 10000 tokens\r\n        if (tokenSold >= 90000) {\r\n            return 95;\r\n        }\r\n        if (tokenSold >= 80000) {\r\n            return 90;\r\n        }\r\n        if (tokenSold >= 70000) {\r\n            return 85;\r\n        }\r\n        if (tokenSold >= 60000) {\r\n            return 80;\r\n        }\r\n        if (tokenSold >= 50000) {\r\n            return 75;\r\n        }\r\n        if (tokenSold >= 40000) {\r\n            return 70;\r\n        }\r\n        if (tokenSold >= 30000) {\r\n            return 65;\r\n        }\r\n        if (tokenSold >= 20000) {\r\n            return 60;\r\n        }\r\n        if (tokenSold >= 10000) {\r\n            return 55;\r\n        }\r\n        //switch to 0.5% per 1000 tokens\r\n        if (tokenSold >= 9000) {\r\n            return 50;\r\n        }\r\n        if (tokenSold >= 8000) {\r\n            return 45;\r\n        }\r\n        if (tokenSold >= 7000) {\r\n            return 40;\r\n        }\r\n        if (tokenSold >= 6000) {\r\n            return 35;\r\n        }\r\n        if (tokenSold >= 5000) {\r\n            return 30;\r\n        }\r\n        if (tokenSold >= 4000) {\r\n            return 25;\r\n        }\r\n        //switch to 0.5% per 500 tokens\r\n        if (tokenSold >= 3000) {\r\n            return 20;\r\n        }\r\n        if (tokenSold >= 2500) {\r\n            return 15;\r\n        }\r\n        if (tokenSold >= 2000) {\r\n            return 10;\r\n        }\r\n        if (tokenSold >= 1500) {\r\n            return 5;\r\n        }\r\n        //less than 1500 -> 0 volume-dependant bonus\r\n        return 0;\r\n    }\r\n\r\n}\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) constant returns (uint256);\r\n    function transfer(address to, uint256 value) returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) returns (bool);\r\n    function approve(address spender, uint256 value) returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amout of tokens to be transfered\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract CrwdToken is StandardToken {\r\n\r\n    // data structures\r\n    enum States {\r\n        Initial, // deployment time\r\n        ValuationSet,\r\n        Ico, // whitelist addresses, accept funds, update balances\r\n        Underfunded, // ICO time finished and minimal amount not raised\r\n        Operational, // production phase\r\n        Paused         // for contract upgrades\r\n    }\r\n\r\n    mapping(address => uint256) public ethPossibleRefunds;\r\n\r\n    uint256 public soldTokens;\r\n\r\n    string public constant name = \"Crwdtoken\";\r\n\r\n    string public constant symbol = \"CRWD\";\r\n\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping(address => bool) public whitelist;\r\n\r\n    address public teamTimeLock;\r\n    address public devTimeLock;\r\n    address public countryTimeLock;\r\n\r\n    address public miscNotLocked;\r\n\r\n    address public stateControl;\r\n\r\n    address public whitelistControl;\r\n\r\n    address public withdrawControl;\r\n\r\n    address public tokenAssignmentControl;\r\n\r\n    States public state;\r\n\r\n    uint256 public weiICOMinimum;\r\n\r\n    uint256 public weiICOMaximum;\r\n\r\n    uint256 public silencePeriod;\r\n\r\n    uint256 public startAcceptingFundsBlock;\r\n\r\n    uint256 public endBlock;\r\n\r\n    uint256 public ETH_CRWDTOKEN; //number of tokens per ETH\r\n\r\n    uint256 constant pointMultiplier = 1e18; //100% = 1*10^18 points\r\n\r\n    uint256 public constant maxTotalSupply = 45000000 * pointMultiplier;\r\n\r\n    uint256 public constant percentForSale = 50;\r\n\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    bool public bonusPhase = false;\r\n\r\n\r\n    //this creates the contract and stores the owner. it also passes in 3 addresses to be used later during the lifetime of the contract.\r\n    function CrwdToken(\r\n        address _stateControl\r\n    , address _whitelistControl\r\n    , address _withdrawControl\r\n    , address _tokenAssignmentControl\r\n    , address _notLocked //15%\r\n    , address _lockedTeam //15%\r\n    , address _lockedDev //10%\r\n    , address _lockedCountry //10%\r\n    ) {\r\n        stateControl = _stateControl;\r\n        whitelistControl = _whitelistControl;\r\n        withdrawControl = _withdrawControl;\r\n        tokenAssignmentControl = _tokenAssignmentControl;\r\n        moveToState(States.Initial);\r\n        weiICOMinimum = 0;\r\n        //to be overridden\r\n        weiICOMaximum = 0;\r\n        endBlock = 0;\r\n        ETH_CRWDTOKEN = 0;\r\n        totalSupply = 0;\r\n        soldTokens = 0;\r\n        uint releaseTime = now + 9 * 31 days;\r\n        teamTimeLock = address(new CrwdTimelock(this, _lockedTeam, releaseTime));\r\n        devTimeLock = address(new CrwdTimelock(this, _lockedDev, releaseTime));\r\n        countryTimeLock = address(new CrwdTimelock(this, _lockedCountry, releaseTime));\r\n        miscNotLocked = _notLocked;\r\n    }\r\n\r\n    event Whitelisted(address addr);\r\n\r\n    event StateTransition(States oldState, States newState);\r\n\r\n    modifier onlyWhitelist() {\r\n        require(msg.sender == whitelistControl);\r\n        _;\r\n    }\r\n\r\n    modifier onlyStateControl() {\r\n        require(msg.sender == stateControl);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenAssignmentControl() {\r\n        require(msg.sender == tokenAssignmentControl);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWithdraw() {\r\n        require(msg.sender == withdrawControl);\r\n        _;\r\n    }\r\n\r\n    modifier requireState(States _requiredState) {\r\n        require(state == _requiredState);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    BEGIN ICO functions\r\n    */\r\n\r\n    //this is the main funding function, it updates the balances of tokens during the ICO.\r\n    //no particular incentive schemes have been implemented here\r\n    //it is only accessible during the \"ICO\" phase.\r\n    function() payable\r\n    requireState(States.Ico)\r\n    {\r\n        require(whitelist[msg.sender] == true);\r\n        require(this.balance <= weiICOMaximum);\r\n        //note that msg.value is already included in this.balance\r\n        require(block.number < endBlock);\r\n        require(block.number >= startAcceptingFundsBlock);\r\n\r\n        uint256 basisTokens = msg.value.mul(ETH_CRWDTOKEN);\r\n        uint256 soldToTuserWithBonus = addBonus(basisTokens);\r\n\r\n        issueTokensToUser(msg.sender, soldToTuserWithBonus);\r\n        ethPossibleRefunds[msg.sender] = ethPossibleRefunds[msg.sender].add(msg.value);\r\n    }\r\n\r\n    function issueTokensToUser(address beneficiary, uint256 amount)\r\n    internal\r\n    {\r\n        balances[beneficiary] = balances[beneficiary].add(amount);\r\n        soldTokens = soldTokens.add(amount);\r\n        totalSupply = totalSupply.add(amount.mul(100).div(percentForSale));\r\n        Mint(beneficiary, amount);\r\n        Transfer(0x0, beneficiary, amount);\r\n    }\r\n\r\n    function issuePercentToReserve(address beneficiary, uint256 percentOfSold)\r\n    internal\r\n    {\r\n        uint256 amount = totalSupply.mul(percentOfSold).div(100);\r\n        balances[beneficiary] = balances[beneficiary].add(amount);\r\n        Mint(beneficiary, amount);\r\n        Transfer(0x0, beneficiary, amount);\r\n    }\r\n\r\n    function addBonus(uint256 basisTokens)\r\n    public constant\r\n    returns (uint256 resultingTokens)\r\n    {\r\n        //if pre-sale is not active no bonus calculation\r\n        if (!bonusPhase) return basisTokens;\r\n        //percentages are integer numbers as per mill (promille) so we can accurately calculate 0.5% = 5. 100% = 1000\r\n        uint256 perMillBonus = getPhaseBonus();\r\n        //no bonus if investment amount < 1000 tokens\r\n        if (basisTokens >= pointMultiplier.mul(1000)) {\r\n            perMillBonus += Bonus.getBonusFactor(basisTokens);\r\n        }\r\n        //100% + bonus % times original amount divided by 100%.\r\n        return basisTokens.mul(per_mill + perMillBonus).div(per_mill);\r\n    }\r\n\r\n    uint256 constant per_mill = 1000;\r\n\r\n    function setBonusPhase(bool _isBonusPhase)\r\n    onlyStateControl\r\n        //phases are controlled manually through the state control key\r\n    {\r\n        bonusPhase = _isBonusPhase;\r\n    }\r\n\r\n    function getPhaseBonus()\r\n    internal\r\n    constant\r\n    returns (uint256 factor)\r\n    {\r\n        if (bonusPhase) {//20%\r\n            return 200;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\n    function moveToState(States _newState)\r\n    internal\r\n    {\r\n        StateTransition(state, _newState);\r\n        state = _newState;\r\n    }\r\n    // ICO contract configuration function\r\n    // newEthICOMinimum is the minimum amount of funds to raise\r\n    // newEthICOMaximum is the maximum amount of funds to raise\r\n    // silencePeriod is a number of blocks to wait after starting the ICO. No funds are accepted during the silence period. It can be set to zero.\r\n    // newEndBlock is the absolute block number at which the ICO must stop. It must be set after now + silence period.\r\n    function updateEthICOThresholds(uint256 _newWeiICOMinimum, uint256 _newWeiICOMaximum, uint256 _silencePeriod, uint256 _newEndBlock)\r\n    onlyStateControl\r\n    {\r\n        require(state == States.Initial || state == States.ValuationSet);\r\n        require(_newWeiICOMaximum > _newWeiICOMinimum);\r\n        require(block.number + silencePeriod < _newEndBlock);\r\n        require(block.number < _newEndBlock);\r\n        weiICOMinimum = _newWeiICOMinimum;\r\n        weiICOMaximum = _newWeiICOMaximum;\r\n        silencePeriod = _silencePeriod;\r\n        endBlock = _newEndBlock;\r\n        // initial conversion rate of ETH_CRWDTOKEN set now, this is used during the Ico phase.\r\n        ETH_CRWDTOKEN = maxTotalSupply.mul(percentForSale).div(100).div(weiICOMaximum);\r\n        // check pointMultiplier\r\n        moveToState(States.ValuationSet);\r\n    }\r\n\r\n    function startICO()\r\n    onlyStateControl\r\n    requireState(States.ValuationSet)\r\n    {\r\n        require(block.number < endBlock);\r\n        require(block.number + silencePeriod < endBlock);\r\n        startAcceptingFundsBlock = block.number + silencePeriod;\r\n        moveToState(States.Ico);\r\n    }\r\n\r\n    function addPresaleAmount(address beneficiary, uint256 amount)\r\n    onlyTokenAssignmentControl\r\n    {\r\n        require(state == States.ValuationSet || state == States.Ico);\r\n        issueTokensToUser(beneficiary, amount);\r\n    }\r\n\r\n\r\n    function endICO()\r\n    onlyStateControl\r\n    requireState(States.Ico)\r\n    {\r\n        if (this.balance < weiICOMinimum) {\r\n            moveToState(States.Underfunded);\r\n        }\r\n        else {\r\n            burnAndFinish();\r\n            moveToState(States.Operational);\r\n        }\r\n    }\r\n\r\n    function anyoneEndICO()\r\n    requireState(States.Ico)\r\n    {\r\n        require(block.number > endBlock);\r\n        if (this.balance < weiICOMinimum) {\r\n            moveToState(States.Underfunded);\r\n        }\r\n        else {\r\n            burnAndFinish();\r\n            moveToState(States.Operational);\r\n        }\r\n    }\r\n\r\n    function burnAndFinish()\r\n    internal\r\n    {\r\n        issuePercentToReserve(teamTimeLock, 15);\r\n        issuePercentToReserve(devTimeLock, 10);\r\n        issuePercentToReserve(countryTimeLock, 10);\r\n        issuePercentToReserve(miscNotLocked, 15);\r\n\r\n        totalSupply = soldTokens\r\n        .add(balances[teamTimeLock])\r\n        .add(balances[devTimeLock])\r\n        .add(balances[countryTimeLock])\r\n        .add(balances[miscNotLocked]);\r\n\r\n        mintingFinished = true;\r\n        MintFinished();\r\n    }\r\n\r\n    function addToWhitelist(address _whitelisted)\r\n    onlyWhitelist\r\n        //    requireState(States.Ico)\r\n    {\r\n        whitelist[_whitelisted] = true;\r\n        Whitelisted(_whitelisted);\r\n    }\r\n\r\n\r\n    //emergency pause for the ICO\r\n    function pause()\r\n    onlyStateControl\r\n    requireState(States.Ico)\r\n    {\r\n        moveToState(States.Paused);\r\n    }\r\n\r\n    //in case we want to completely abort\r\n    function abort()\r\n    onlyStateControl\r\n    requireState(States.Paused)\r\n    {\r\n        moveToState(States.Underfunded);\r\n    }\r\n\r\n    //un-pause\r\n    function resumeICO()\r\n    onlyStateControl\r\n    requireState(States.Paused)\r\n    {\r\n        moveToState(States.Ico);\r\n    }\r\n\r\n    //in case of a failed/aborted ICO every investor can get back their money\r\n    function requestRefund()\r\n    requireState(States.Underfunded)\r\n    {\r\n        require(ethPossibleRefunds[msg.sender] > 0);\r\n        //there is no need for updateAccount(msg.sender) since the token never became active.\r\n        uint256 payout = ethPossibleRefunds[msg.sender];\r\n        //reverse calculate the amount to pay out\r\n        ethPossibleRefunds[msg.sender] = 0;\r\n        msg.sender.transfer(payout);\r\n    }\r\n\r\n    //after the ico has run its course, the withdraw account can drain funds bit-by-bit as needed.\r\n    function requestPayout(uint _amount)\r\n    onlyWithdraw //very important!\r\n    requireState(States.Operational)\r\n    {\r\n        msg.sender.transfer(_amount);\r\n    }\r\n\r\n    //if this contract gets a balance in some other ERC20 contract - or even iself - then we can rescue it.\r\n    function rescueToken(ERC20Basic _foreignToken, address _to)\r\n    onlyTokenAssignmentControl\r\n    requireState(States.Operational)\r\n    {\r\n        _foreignToken.transfer(_to, _foreignToken.balanceOf(this));\r\n    }\r\n    /**\r\n    END ICO functions\r\n    */\r\n\r\n    /**\r\n    BEGIN ERC20 functions\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n    requireState(States.Operational)\r\n    returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    requireState(States.Operational)\r\n    returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function balanceOf(address _account)\r\n    constant\r\n    returns (uint256 balance) {\r\n        return balances[_account];\r\n    }\r\n\r\n    /**\r\n    END ERC20 functions\r\n    */\r\n}\r\ncontract CrwdTimelock {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public balances;\r\n\r\n    uint256 public assignedBalance;\r\n    // beneficiary of tokens after they are released\r\n    address public controller;\r\n\r\n    // timestamp when token release is enabled\r\n    uint public releaseTime;\r\n\r\n    CrwdToken token;\r\n\r\n    function CrwdTimelock(CrwdToken _token, address _controller, uint _releaseTime) {\r\n        require(_releaseTime > now);\r\n        token = _token;\r\n        controller = _controller;\r\n        releaseTime = _releaseTime;\r\n    }\r\n\r\n    function assignToBeneficiary(address _beneficiary, uint256 _amount){\r\n        require(msg.sender == controller);\r\n        assignedBalance = assignedBalance.sub(balances[_beneficiary]);\r\n        //todo test that this rolls back correctly!\r\n        //balanceOf(this) will be 0 until the Operational Phase has been reached, no need for explicit check\r\n        require(token.balanceOf(this) >= assignedBalance.add(_amount));\r\n        balances[_beneficiary] = _amount;\r\n        //balance is set, not added, gives _controller the power to set any balance, even 0\r\n        assignedBalance = assignedBalance.add(balances[_beneficiary]);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens held by timelock to beneficiary.\r\n     */\r\n    function release(address _beneficiary) {\r\n        require(now >= releaseTime);\r\n        uint amount = balances[_beneficiary];\r\n        require(amount > 0);\r\n        token.transfer(_beneficiary, amount);\r\n        assignedBalance = assignedBalance.sub(amount);\r\n        balances[_beneficiary] = 0;\r\n\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"stateControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"basisTokens\",\"type\":\"uint256\"}],\"name\":\"addBonus\",\"outputs\":[{\"name\":\"resultingTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isBonusPhase\",\"type\":\"bool\"}],\"name\":\"setBonusPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"anyoneEndICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"abort\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTimeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"silencePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_foreignToken\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miscNotLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countryTimeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTimeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWeiICOMinimum\",\"type\":\"uint256\"},{\"name\":\"_newWeiICOMaximum\",\"type\":\"uint256\"},{\"name\":\"_silencePeriod\",\"type\":\"uint256\"},{\"name\":\"_newEndBlock\",\"type\":\"uint256\"}],\"name\":\"updateEthICOThresholds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startAcceptingFundsBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAssignmentControl\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addPresaleAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiICOMaximum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_CRWDTOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelisted\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiICOMinimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethPossibleRefunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_stateControl\",\"type\":\"address\"},{\"name\":\"_whitelistControl\",\"type\":\"address\"},{\"name\":\"_withdrawControl\",\"type\":\"address\"},{\"name\":\"_tokenAssignmentControl\",\"type\":\"address\"},{\"name\":\"_notLocked\",\"type\":\"address\"},{\"name\":\"_lockedTeam\",\"type\":\"address\"},{\"name\":\"_lockedDev\",\"type\":\"address\"},{\"name\":\"_lockedCountry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"StateTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CrwdToken","CompilerVersion":"v0.4.11+commit.68ef5810","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002b1039ba7b4d74f9191c7b927731bca2d68dc4520000000000000000000000004b674786aa1f8db532bbeec694669b3ac1fecd1d0000000000000000000000004f0f6b683f7f69bfae06070eef683ea6cd5127420000000000000000000000005bc58ca727e06b18ebfb2fc19b267c779559b88c000000000000000000000000ffb1b027b11f828dab871ca2956850d5dd64d75f00000000000000000000000028498532576f230c6498cd048ec7fab0f69ce8f9000000000000000000000000863d58fa0e4fc8ed0f88146799af5b06feff9e2a000000000000000000000000576ef9cd51d9adb8295f105eeabbb326d1503ff0","Library":"","SwarmSource":"bzzr://14e81b2f579550288db0528c7f69a079bb54a2e36ad2b6df5fee90327d4ecdb7"}]}