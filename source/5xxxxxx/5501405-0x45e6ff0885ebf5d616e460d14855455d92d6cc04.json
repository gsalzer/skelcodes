{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath64 {\r\n  function mul(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    uint64 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint64 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    uint64 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title VestingERC20\r\n * @dev VestingERC20 is a contract for managing vesting of ERC20 Token.\r\n * @dev The tokens are unlocked continuously to the vester.\r\n * @dev The contract host the tokens that are locked for the vester.\r\n */\r\ncontract VestingERC20 {\r\n    using SafeMath for uint256;\r\n    using SafeMath64 for uint64;\r\n\r\n    struct Grant {\r\n        uint256 vestedAmount;\r\n        uint64 startTime;\r\n        uint64 cliffTime;\r\n        uint64 endTime;\r\n        uint256 withdrawnAmount;\r\n    }\r\n\r\n    // list of the grants (token => granter => vester => Grant).\r\n    mapping(address => mapping(address => mapping(address => Grant))) public grantPerTokenGranterVester;\r\n\r\n    // Ledger of the tokens hodled (this not a typo ;) ) in this contract (token => user => balance).\r\n    mapping(address => mapping(address => uint256)) private balancePerPersonPerToken;\r\n\r\n\r\n    event NewGrant(address granter, address vester, address token, uint256 vestedAmount, uint64 startTime, uint64 cliffTime, uint64 endTime);\r\n    event GrantRevoked(address granter, address vester, address token);\r\n    event Deposit(address token, address granter, uint amount, uint balance);\r\n    event TokenReleased(address token, address granter, address vester, uint amount);\r\n    event Withdraw(address token, address user, uint amount);\r\n\r\n    /**\r\n     * @dev Create a vesting to an ethereum address.\r\n     *\r\n     * If there is not enough tokens available on the contract, an exception is thrown.\r\n     *\r\n     * @param _token The ERC20 token contract address.\r\n     * @param _vester The address where the token will be sent.\r\n     * @param _vestedAmount The amount of tokens to be sent during the vesting period.\r\n     * @param _startTime The time when the vesting starts.\r\n     * @param _grantPeriod The period of the grant in sec.\r\n     * @param _cliffPeriod The period in sec during which time the tokens cannot be withraw.\r\n     */\r\n    function createVesting(\r\n        address _token, \r\n        address _vester,  \r\n        uint256 _vestedAmount,\r\n        uint64 _startTime,\r\n        uint64 _grantPeriod,\r\n        uint64 _cliffPeriod) \r\n        external\r\n    {\r\n        require(_token != 0);\r\n        require(_vester != 0);\r\n        require(_cliffPeriod <= _grantPeriod);\r\n        require(_vestedAmount != 0);\r\n        require(_grantPeriod==0 || _vestedAmount * _grantPeriod >= _vestedAmount); // no overflow allow here! (to make getBalanceVestingInternal safe).\r\n\r\n        // verify that there is not already a grant between the addresses for this specific contract.\r\n        require(grantPerTokenGranterVester[_token][msg.sender][_vester].vestedAmount==0);\r\n\r\n        var cliffTime = _startTime.add(_cliffPeriod);\r\n        var endTime = _startTime.add(_grantPeriod);\r\n\r\n        grantPerTokenGranterVester[_token][msg.sender][_vester] = Grant(_vestedAmount, _startTime, cliffTime, endTime, 0);\r\n\r\n        // update the balance\r\n        balancePerPersonPerToken[_token][msg.sender] = balancePerPersonPerToken[_token][msg.sender].sub(_vestedAmount);\r\n\r\n        NewGrant(msg.sender, _vester, _token, _vestedAmount, _startTime, cliffTime, endTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Revoke a vesting\r\n     *\r\n     * The vesting is deleted and the tokens already released are sent to the vester.\r\n     *\r\n     * @param _token The address of the token.\r\n     * @param _vester The address of the vester.\r\n     */\r\n    function revokeVesting(address _token, address _vester) \r\n        external\r\n    {\r\n        require(_token != 0);\r\n        require(_vester != 0);\r\n\r\n        Grant storage _grant = grantPerTokenGranterVester[_token][msg.sender][_vester];\r\n\r\n        // verify if the grant exists\r\n        require(_grant.vestedAmount!=0);\r\n\r\n        // send token available\r\n        sendTokenReleasedToBalanceInternal(_token, msg.sender, _vester);\r\n\r\n        // unlock the tokens reserved for this grant\r\n        balancePerPersonPerToken[_token][msg.sender] = \r\n            balancePerPersonPerToken[_token][msg.sender].add(\r\n                _grant.vestedAmount.sub(_grant.withdrawnAmount)\r\n            );\r\n\r\n        // delete the grants\r\n        delete grantPerTokenGranterVester[_token][msg.sender][_vester];\r\n\r\n        GrantRevoked(msg.sender, _vester, _token);\r\n    }\r\n\r\n    /**\r\n     * @dev Send the released token to the user balance and eventually withdraw\r\n     *\r\n     * Put the tokens released to the user balance.\r\n     * If _doWithdraw is true, send the whole balance to the user.\r\n\r\n     * @param _token The address of the token.\r\n     * @param _granter The address of the granter.\r\n     * @param _doWithdraw bool, true to withdraw in the same time.\r\n     */\r\n    function releaseGrant(address _token, address _granter, bool _doWithdraw) \r\n        external\r\n    {\r\n        // send token to the vester\r\n        sendTokenReleasedToBalanceInternal(_token, _granter, msg.sender);\r\n\r\n        if(_doWithdraw) {\r\n            withdraw(_token);           \r\n        }\r\n\r\n        // delete grant if fully withdrawn\r\n        Grant storage _grant = grantPerTokenGranterVester[_token][_granter][msg.sender];\r\n        if(_grant.vestedAmount == _grant.withdrawnAmount) \r\n        {\r\n            delete grantPerTokenGranterVester[_token][_granter][msg.sender];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw tokens avaibable\r\n     *\r\n     * The tokens are sent to msg.sender and his balancePerPersonPerToken is updated to zero.\r\n     * If there is the token transfer fail, the transaction is revert.\r\n     *\r\n     * @param _token The address of the token.\r\n     */\r\n    function withdraw(address _token) \r\n        public\r\n    {\r\n        uint amountToSend = balancePerPersonPerToken[_token][msg.sender];\r\n        balancePerPersonPerToken[_token][msg.sender] = 0;\r\n        Withdraw(_token, msg.sender, amountToSend);\r\n        require(ERC20(_token).transfer(msg.sender, amountToSend));\r\n    }\r\n\r\n    /**\r\n     * @dev Send the token released to the balance address\r\n     *\r\n     * The token released for the address are sent and his withdrawnAmount are updated.\r\n     * If there is nothing the send, return false.\r\n     * \r\n     * @param _token The address of the token.\r\n     * @param _granter The address of the granter.\r\n     * @param _vester The address of the vester.\r\n     * @return true if tokens have been sent.\r\n     */\r\n    function sendTokenReleasedToBalanceInternal(address _token, address _granter, address _vester) \r\n        internal\r\n    {\r\n        Grant storage _grant = grantPerTokenGranterVester[_token][_granter][_vester];\r\n        uint256 amountToSend = getBalanceVestingInternal(_grant);\r\n\r\n        // update withdrawnAmount\r\n        _grant.withdrawnAmount = _grant.withdrawnAmount.add(amountToSend);\r\n\r\n        TokenReleased(_token, _granter, _vester, amountToSend);\r\n\r\n        // send tokens to the vester's balance\r\n        balancePerPersonPerToken[_token][_vester] = balancePerPersonPerToken[_token][_vester].add(amountToSend); \r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the amount of tokens released for a grant\r\n     * \r\n     * @param _grant Grant information.\r\n     * @return the number of tokens released.\r\n     */\r\n    function getBalanceVestingInternal(Grant _grant)\r\n        internal\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        if(now < _grant.cliffTime) \r\n        {\r\n            // the grant didn't start \r\n            return 0;\r\n        }\r\n        else if(now >= _grant.endTime)\r\n        {\r\n            // after the end of the grant release everything\r\n            return _grant.vestedAmount.sub(_grant.withdrawnAmount);\r\n        }\r\n        else\r\n        {\r\n            //  token available = vestedAmount * (now - startTime) / (endTime - startTime)  - withdrawnAmount\r\n            //  => in other words : (number_of_token_granted_per_second * second_since_grant_started) - amount_already_withdraw\r\n            return _grant.vestedAmount.mul( \r\n                        now.sub(_grant.startTime)\r\n                    ).div(\r\n                        _grant.endTime.sub(_grant.startTime) \r\n                    ).sub(_grant.withdrawnAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the amount of tokens released for a vesting\r\n     * \r\n     * @param _token The address of the token.\r\n     * @param _granter The address of the granter.\r\n     * @param _vester The address of the vester.\r\n     * @return the number of tokens available.\r\n     */\r\n    function getVestingBalance(address _token, address _granter, address _vester) \r\n        external\r\n        constant \r\n        returns(uint256) \r\n    {\r\n        Grant memory _grant = grantPerTokenGranterVester[_token][_granter][_vester];\r\n        return getBalanceVestingInternal(_grant);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the token balance of the contract\r\n     * \r\n     * @param _token The address of the token.\r\n     * @param _user The address of the user.\r\n     * @return the balance of tokens on the contract for _user.\r\n     */\r\n    function getContractBalance(address _token, address _user) \r\n        external\r\n        constant \r\n        returns(uint256) \r\n    {\r\n        return balancePerPersonPerToken[_token][_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Make a deposit of tokens on the contract\r\n     *\r\n     * Before using this function the user needs to do a token allowance from the user to the contract.\r\n     *\r\n     * @param _token The address of the token.\r\n     * @param _amount Amount of token to deposit.\r\n     * \r\n     * @return the balance of tokens on the contract for msg.sender.\r\n     */\r\n    function deposit(address _token, uint256 _amount) \r\n        external\r\n        returns(uint256) \r\n    {\r\n        require(_token!=0);\r\n        require(ERC20(_token).transferFrom(msg.sender, this, _amount));\r\n        balancePerPersonPerToken[_token][msg.sender] = balancePerPersonPerToken[_token][msg.sender].add(_amount);\r\n        Deposit(_token, msg.sender, _amount, balancePerPersonPerToken[_token][msg.sender]);\r\n\r\n        return balancePerPersonPerToken[_token][msg.sender];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_vester\",\"type\":\"address\"},{\"name\":\"_vestedAmount\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint64\"},{\"name\":\"_grantPeriod\",\"type\":\"uint64\"},{\"name\":\"_cliffPeriod\",\"type\":\"uint64\"}],\"name\":\"createVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_granter\",\"type\":\"address\"},{\"name\":\"_vester\",\"type\":\"address\"}],\"name\":\"getVestingBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"grantPerTokenGranterVester\",\"outputs\":[{\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint64\"},{\"name\":\"cliffTime\",\"type\":\"uint64\"},{\"name\":\"endTime\",\"type\":\"uint64\"},{\"name\":\"withdrawnAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_vester\",\"type\":\"address\"}],\"name\":\"revokeVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_granter\",\"type\":\"address\"},{\"name\":\"_doWithdraw\",\"type\":\"bool\"}],\"name\":\"releaseGrant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"granter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"cliffTime\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint64\"}],\"name\":\"NewGrant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"granter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"GrantRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"granter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"granter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"vester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"VestingERC20","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e4390e1d40e4a063b5f28d565ac0886c8660b755fdfd76c2c02bcbbf486cd817"}]}