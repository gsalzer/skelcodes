{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n * @title MerkleProof\r\n * @dev Merkle proof verification\r\n * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\nlibrary MerkleProof {\r\n  /*\r\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\r\n   * and each pair of pre-images is sorted.\r\n   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\r\n   * @param _root Merkle root\r\n   * @param _leaf Leaf of Merkle tree\r\n   */\r\n  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\r\n    // Check if proof length is a multiple of 32\r\n    if (_proof.length % 32 != 0) return false;\r\n\r\n    bytes32 proofElement;\r\n    bytes32 computedHash = _leaf;\r\n\r\n    for (uint256 i = 32; i <= _proof.length; i += 32) {\r\n      assembly {\r\n        // Load the current element of the proof\r\n        proofElement := mload(add(_proof, i))\r\n      }\r\n\r\n      if (computedHash < proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(computedHash, proofElement);\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(proofElement, computedHash);\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == _root;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nlibrary JobLib {\r\n    using SafeMath for uint256;\r\n    // Prefix hashed with message hash when a signature is produced by the eth_sign RPC call\r\n    string constant PERSONAL_HASH_PREFIX = \"\\u0019Ethereum Signed Message:\\n32\";\r\n    // # of bytes used to store a video profile identifier as a utf8 encoded string\r\n    // Video profile identifier is currently stored as bytes4(keccak256(PROFILE_NAME))\r\n    // We use 2 * 4 = 8 bytes because we store the bytes in a utf8 encoded string so\r\n    // the identifiers can be easily parsed off-chain\r\n    uint8 constant VIDEO_PROFILE_SIZE = 8;\r\n\r\n    /*\r\n     * @dev Checks if a transcoding options string is valid\r\n     * A transcoding options string is composed of video profile ids so its length\r\n     * must be a multiple of VIDEO_PROFILE_SIZE\r\n     * @param _transcodingOptions Transcoding options string\r\n     */\r\n    function validTranscodingOptions(string _transcodingOptions) public pure returns (bool) {\r\n        uint256 transcodingOptionsLength = bytes(_transcodingOptions).length;\r\n        return transcodingOptionsLength > 0 && transcodingOptionsLength % VIDEO_PROFILE_SIZE == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Computes the amount of fees given total segments, total number of profiles and price per segment\r\n     * @param _totalSegments # of segments\r\n     * @param _transcodingOptions String containing video profiles for a job\r\n     * @param _pricePerSegment Price in LPT base units per segment\r\n     */\r\n    function calcFees(uint256 _totalSegments, string _transcodingOptions, uint256 _pricePerSegment) public pure returns (uint256) {\r\n        // Calculate total profiles defined in the transcoding options string\r\n        uint256 totalProfiles = bytes(_transcodingOptions).length.div(VIDEO_PROFILE_SIZE);\r\n        return _totalSegments.mul(totalProfiles).mul(_pricePerSegment);\r\n    }\r\n\r\n    /*\r\n     * Computes whether a segment is eligible for verification based on the last call to claimWork()\r\n     * @param _segmentNumber Sequence number of segment in stream\r\n     * @param _segmentRange Range of segments claimed\r\n     * @param _challengeBlock Block afer the block when claimWork() was called\r\n     * @param _challengeBlockHash Block hash of challenge block\r\n     * @param _verificationRate Rate at which a particular segment should be verified\r\n     */\r\n    function shouldVerifySegment(\r\n        uint256 _segmentNumber,\r\n        uint256[2] _segmentRange,\r\n        uint256 _challengeBlock,\r\n        bytes32 _challengeBlockHash,\r\n        uint64 _verificationRate\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // Segment must be in segment range\r\n        if (_segmentNumber < _segmentRange[0] || _segmentNumber > _segmentRange[1]) {\r\n            return false;\r\n        }\r\n\r\n        // Use block hash and block number of the block after a claim to determine if a segment\r\n        // should be verified\r\n        if (uint256(keccak256(_challengeBlock, _challengeBlockHash, _segmentNumber)) % _verificationRate == 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if a segment was signed by a broadcaster address\r\n     * @param _streamId Stream ID for the segment\r\n     * @param _segmentNumber Sequence number of segment in the stream\r\n     * @param _dataHash Hash of segment data\r\n     * @param _broadcasterSig Broadcaster signature over h(streamId, segmentNumber, dataHash)\r\n     * @param _broadcaster Broadcaster address\r\n     */\r\n    function validateBroadcasterSig(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes _broadcasterSig,\r\n        address _broadcaster\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return ECRecovery.recover(personalSegmentHash(_streamId, _segmentNumber, _dataHash), _broadcasterSig) == _broadcaster;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if a transcode receipt hash was included in a committed merkle root\r\n     * @param _streamId StreamID for the segment\r\n     * @param _segmentNumber Sequence number of segment in the stream\r\n     * @param _dataHash Hash of segment data\r\n     * @param _transcodedDataHash Hash of transcoded segment data\r\n     * @param _broadcasterSig Broadcaster signature over h(streamId, segmentNumber, dataHash)\r\n     * @param _broadcaster Broadcaster address\r\n     */\r\n    function validateReceipt(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes32 _transcodedDataHash,\r\n        bytes _broadcasterSig,\r\n        bytes _proof,\r\n        bytes32 _claimRoot\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return MerkleProof.verifyProof(_proof, _claimRoot, transcodeReceiptHash(_streamId, _segmentNumber, _dataHash, _transcodedDataHash, _broadcasterSig));\r\n    }\r\n\r\n    /*\r\n     * Compute the hash of a segment\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addressed storage hash of segment data\r\n     */\r\n    function segmentHash(string _streamId, uint256 _segmentNumber, bytes32 _dataHash) public pure returns (bytes32) {\r\n        return keccak256(_streamId, _segmentNumber, _dataHash);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute the personal segment hash of a segment. Hashes the concatentation of the personal hash prefix and the segment hash\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addrssed storage hash of segment data\r\n     */\r\n    function personalSegmentHash(string _streamId, uint256 _segmentNumber, bytes32 _dataHash) public pure returns (bytes32) {\r\n        bytes memory prefixBytes = bytes(PERSONAL_HASH_PREFIX);\r\n\r\n        return keccak256(prefixBytes, segmentHash(_streamId, _segmentNumber, _dataHash));\r\n    }\r\n\r\n    /*\r\n     * Compute the hash of a transcode receipt\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addressed storage hash of segment data\r\n     * @param _transcodedDataHash Content-addressed storage hash of transcoded segment data\r\n     * @param _broadcasterSig Broadcaster's signature over segment\r\n     */\r\n    function transcodeReceiptHash(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes32 _transcodedDataHash,\r\n        bytes _broadcasterSig\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(_streamId, _segmentNumber, _dataHash, _transcodedDataHash, _broadcasterSig);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"string\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"},{\"name\":\"_dataHash\",\"type\":\"bytes32\"}],\"name\":\"segmentHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"string\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"},{\"name\":\"_dataHash\",\"type\":\"bytes32\"},{\"name\":\"_transcodedDataHash\",\"type\":\"bytes32\"},{\"name\":\"_broadcasterSig\",\"type\":\"bytes\"}],\"name\":\"transcodeReceiptHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"string\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"},{\"name\":\"_dataHash\",\"type\":\"bytes32\"},{\"name\":\"_transcodedDataHash\",\"type\":\"bytes32\"},{\"name\":\"_broadcasterSig\",\"type\":\"bytes\"},{\"name\":\"_proof\",\"type\":\"bytes\"},{\"name\":\"_claimRoot\",\"type\":\"bytes32\"}],\"name\":\"validateReceipt\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_transcodingOptions\",\"type\":\"string\"}],\"name\":\"validTranscodingOptions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"string\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"},{\"name\":\"_dataHash\",\"type\":\"bytes32\"},{\"name\":\"_broadcasterSig\",\"type\":\"bytes\"},{\"name\":\"_broadcaster\",\"type\":\"address\"}],\"name\":\"validateBroadcasterSig\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_segmentNumber\",\"type\":\"uint256\"},{\"name\":\"_segmentRange\",\"type\":\"uint256[2]\"},{\"name\":\"_challengeBlock\",\"type\":\"uint256\"},{\"name\":\"_challengeBlockHash\",\"type\":\"bytes32\"},{\"name\":\"_verificationRate\",\"type\":\"uint64\"}],\"name\":\"shouldVerifySegment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_totalSegments\",\"type\":\"uint256\"},{\"name\":\"_transcodingOptions\",\"type\":\"string\"},{\"name\":\"_pricePerSegment\",\"type\":\"uint256\"}],\"name\":\"calcFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_streamId\",\"type\":\"string\"},{\"name\":\"_segmentNumber\",\"type\":\"uint256\"},{\"name\":\"_dataHash\",\"type\":\"bytes32\"}],\"name\":\"personalSegmentHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"JobLib","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"MerkleProof:289ba1701c2f088cf0faf8b3705246331cb8a839;ECRecovery:d8e8328501e9645d16cf49539efc04f734606ee4","SwarmSource":"bzzr://8843aaf35017ec6b3681c7fc313ad05bc5425e376505e0a81290b8554d9117a1"}]}