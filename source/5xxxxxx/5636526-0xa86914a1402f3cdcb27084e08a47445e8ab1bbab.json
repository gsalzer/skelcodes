{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\ncontract owned {\r\n    address public owner;\r\n    bool public ownershipTransferAllowed = false;\r\n\r\n    function constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function allowTransferOwnership(bool flag ) public onlyOwner {\r\n      ownershipTransferAllowed = flag;\r\n    }\r\n \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require( newOwner != 0x0 );                                             // not to 0x0\r\n        require( ownershipTransferAllowed );                                 \r\n        owner = newOwner;\r\n        ownershipTransferAllowed = false;\r\n    }\r\n}\r\n\r\ncontract ECR20HoneycombToken is owned {\r\n    // Public variables of the token\r\n    string public name = \"Honeycomb\";\r\n    string public symbol = \"COMB\";\r\n    uint8 public decimals = 18;\r\n    \r\n    // used for buyPrice\r\n    uint256 private tokenFactor = 10 ** uint256(decimals);\r\n    uint256 private initialBuyPrice = 3141592650000000000000;                   // PI Token per Finney\r\n    uint256 private buyConst1 = 10000 * tokenFactor;                            // Faktor for buy price calculation\r\n    uint256 private buyConst2 = 4;                                              // Faktor for buy price calculation\r\n    \r\n    uint256 public minimumPayout = 1000000000000000;\t\t\t\t\t\t\t// minimal payout initially to 0.001 ether\r\n       \r\n    uint256 public totalSupply;                                                 // total number of issued tokent\r\n\r\n\t// price token are sold/bought\r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * Constructor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function ECR20HoneycombToken() public {\r\n        totalSupply = 1048576 * tokenFactor;                                    // token total created\r\n        balanceOf[msg.sender] = totalSupply;                                    // Give the creator all initial tokens\r\n        owner = msg.sender;\t\t\t                                            // assign ownership of contract to initial coin holder\r\n        emit Transfer(0, owner, totalSupply);                                   // notify event owner\r\n        _transfer(owner, this, totalSupply - (16384*tokenFactor));              // transfer token to contract\r\n        _setPrices(_newPrice(balanceOf[this]));                                 // set prices according to token left\r\n    }\r\n    /**\r\n     * Calculate new price based on a new token left\r\n     * \r\n     * @param tokenLeft new token left on contract after transaction\r\n    **/\r\n    function _newPrice(uint256 tokenLeft) internal view returns (uint256 newPrice) {\r\n        newPrice = initialBuyPrice \r\n            * ( tokenLeft * buyConst1 )\r\n            / ( totalSupply*buyConst1 + totalSupply*tokenLeft/buyConst2 - tokenLeft*tokenLeft/buyConst2 ); \r\n        return newPrice;\r\n    }\r\n\r\n    function _setPrices(uint256 newPrice) internal {\r\n        buyPrice = newPrice;\r\n        sellPrice = buyPrice * 141421356 / 100000000;                           // sellPrice is sqrt(2) higher\r\n    }\r\n\r\n\t/**\r\n\t * Called when token are bought by sending ether\r\n\t * \r\n\t * @return amount amount of token bought\r\n\t **/\r\n\tfunction buy() payable public returns (uint256 amountToken){\r\n        amountToken = msg.value * buyPrice / tokenFactor;                       // calculates the amount of token\r\n        uint256 newPrice = _newPrice(balanceOf[this] - amountToken);            // calc new price after transfer\r\n        require( (2*newPrice) > sellPrice);                                     // check whether new price is not lower than sqrt(2) of old one\r\n        _transfer(this, msg.sender, amountToken);                               // transfer token from contract to buyer\r\n        _setPrices( newPrice );                                                 // update prices after transfer\r\n        return amountToken;\r\n    }\r\n\r\n    /**\r\n      Fallback function\r\n    **/\r\n\tfunction () payable public {\r\n\t    buy();\r\n    }\r\n\r\n    /**\r\n     * Sell token back to contract\r\n     * \r\n     * @param amountToken The amount of token in wei \r\n     * \r\n     * @return eth to receive in wei\r\n     **/\r\n    function sell(uint256 amountToken) public returns (uint256 revenue){\r\n        revenue = amountToken * tokenFactor / sellPrice;                        // calulate the revenue in Wei\r\n        require( revenue >= minimumPayout );\t\t\t\t\t\t\t\t\t// check whether selling get more ether than the minimum payout\r\n        uint256 newPrice = _newPrice(balanceOf[this] + amountToken);            // calc new price after transfer\r\n        require( newPrice < sellPrice );                                        // check whether new price is more than sell price\r\n        _transfer(msg.sender, this, amountToken);                               // transfer token back to contract\r\n        _setPrices( newPrice );                                                 // update prices after transfer\r\n        msg.sender.transfer(revenue);                                           // send ether to seller\r\n        return revenue;\r\n    }\r\n\t\t\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public {\r\n        if ( _to  == address(this) )\r\n        {\r\n          sell(_value);                                                         // sending token to a contract means selling them\r\n        }\r\n        else\r\n        {\r\n          _transfer(msg.sender, _to, _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` on behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n\t/**\r\n     * set minimumPayout price\r\n     * \r\n     * @param amount minimumPayout amount in Wei\r\n     */\r\n\t\tfunction setMinimumPayout(uint256 amount) public onlyOwner {\r\n\t\tminimumPayout = amount;\r\n    }\r\n\t\t\r\n\t/**\r\n     * save ether to owner account\r\n     * \r\n     * @param amount amount in Wei\r\n     */\r\n\t\tfunction save(uint256 amount) public onlyOwner {\r\n        require( amount >= minimumPayout );\t\r\n        owner.transfer( amount);\r\n    }\r\n\t\t\r\n\t/**\r\n     * Give back token to contract bypassing selling from owner account\r\n     * \r\n     * @param amount amount of token in wei\r\n     */\r\n\t\tfunction restore(uint256 amount) public onlyOwner {\r\n        uint256 newPrice = _newPrice(balanceOf[this] + amount);                 // calc new price after transfer\r\n        _transfer(owner, this, amount );                                        // transfer token back to contract\r\n        _setPrices( newPrice );                                                 // update prices after transfer\r\n    }\r\n\t\t\r\n\t/**\r\n     * Internal transfer, can be called only by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(_to != 0x0);\r\n        // Check if the sender has enough\r\n        require(balanceOf[_from] >= _value);\r\n        // Check for overflows\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        // Subtract from the sender\r\n        balanceOf[_from] -= _value;\r\n        // Add the same to the recipient\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"save\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMinimumPayout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"constructor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"restore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"amountToken\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"allowTransferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownershipTransferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountToken\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"revenue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"ECR20HoneycombToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d7b66eb55223e707ea2bdb8d57ddd274aaf1cbe7f2e51a0b9cba310dd2fe2b9c"}]}