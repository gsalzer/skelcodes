{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract CrowdsaleLimit {\r\n  using SafeMath for uint256;\r\n\r\n  // the UNIX timestamp start date of the crowdsale\r\n  uint public startsAt;\r\n  // the UNIX timestamp end date of the crowdsale\r\n  uint public endsAt;\r\n  // setting the max token \r\n  uint public TOKEN_MAX;\r\n  // seting the wei value for one token in presale stage\r\n  uint public PRESALE_TOKEN_IN_WEI = 9 finney;\r\n  // total eth fund in presale stage\r\n  uint public presale_eth_fund= 0;\r\n  \r\n  // seting the wei value for one token in crowdsale stage\r\n  uint public CROWDSALE_TOKEN_IN_WEI = 10 finney;  \r\n  \r\n  // seting the max fund of presale with eth\r\n  uint public PRESALE_ETH_IN_WEI_FUND_MAX = 0 ether; \r\n  // seting the min fund of crowdsale with eth\r\n  uint public CROWDSALE_ETH_IN_WEI_FUND_MIN = 100 ether;\r\n  // seting the max fund of crowdsale with eth\r\n  uint public CROWDSALE_ETH_IN_WEI_FUND_MAX = 1000 ether;\r\n  // seting the min acceptable invest with eth\r\n  uint public CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = 100 finney;   //0.1 ether\r\n  // seting the gasprice to limit big buyer, default to disable\r\n  uint public CROWDSALE_GASPRICE_IN_WEI_MAX = 0;\r\n \r\n  // total eth fund\r\n  uint public crowdsale_eth_fund= 0;\r\n  // total eth refund\r\n  uint public crowdsale_eth_refund = 0;\r\n   \r\n  // setting team list and set percentage of tokens\r\n  mapping(address => uint) public team_addresses_token_percentage;\r\n  mapping(uint => address) public team_addresses_idx;\r\n  uint public team_address_count= 0;\r\n  uint public team_token_percentage_total= 0;\r\n  uint public team_token_percentage_max= 0;\r\n    \r\n  event EndsAtChanged(uint newEndsAt);\r\n  event AddTeamAddress(address addr, uint release_time, uint token_percentage);\r\n  event Refund(address investor, uint weiAmount);\r\n    \r\n  // limitation of buying tokens\r\n  modifier allowCrowdsaleAmountLimit(){\t\r\n\tif (msg.value == 0) revert();\r\n\tif (msg.value < CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN) revert();\r\n\tif((crowdsale_eth_fund.add(msg.value)) > CROWDSALE_ETH_IN_WEI_FUND_MAX) revert();\r\n\tif((CROWDSALE_GASPRICE_IN_WEI_MAX > 0) && (tx.gasprice > CROWDSALE_GASPRICE_IN_WEI_MAX)) revert();\r\n\t_;\r\n  }  \r\n   \r\n  function CrowdsaleLimit(uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max) {\r\n\trequire(_start != 0);\r\n\trequire(_end != 0);\r\n\trequire(_start < _end);\r\n\t\r\n\tif( (_presale_token_in_wei == 0) ||\r\n\t    (_crowdsale_token_in_wei == 0) ||\r\n\t\t(_crowdsale_eth_inwei_fund_min == 0) ||\r\n\t\t(_crowdsale_eth_inwei_fund_max == 0) ||\r\n\t\t(_crowdsale_eth_inwei_accepted_min == 0) ||\r\n\t\t(_team_token_percentage_max >= 100))  //example 20%=20\r\n\t\trevert();\r\n\t\t\r\n\tstartsAt = _start;\r\n    endsAt = _end;\r\n\t\r\n\tTOKEN_MAX = _token_max;\r\n\t\t\r\n\tPRESALE_TOKEN_IN_WEI = _presale_token_in_wei;\r\n\t\r\n\tCROWDSALE_TOKEN_IN_WEI = _crowdsale_token_in_wei;\t\r\n\tPRESALE_ETH_IN_WEI_FUND_MAX = _presale_eth_inwei_fund_max;\r\n\tCROWDSALE_ETH_IN_WEI_FUND_MIN = _crowdsale_eth_inwei_fund_min;\r\n\tCROWDSALE_ETH_IN_WEI_FUND_MAX = _crowdsale_eth_inwei_fund_max;\r\n\tCROWDSALE_ETH_IN_WEI_ACCEPTED_MIN = _crowdsale_eth_inwei_accepted_min;\r\n\tCROWDSALE_GASPRICE_IN_WEI_MAX = _crowdsale_gasprice_inwei_max;\r\n\t\r\n\tteam_token_percentage_max= _team_token_percentage_max;\r\n  }\r\n    \r\n  // caculate amount of token in presale stage\r\n  function calculateTokenPresale(uint value, uint decimals) /*internal*/ public constant returns (uint) {\r\n    uint multiplier = 10 ** decimals;\r\n    return value.mul(multiplier).div(PRESALE_TOKEN_IN_WEI);\r\n  }\r\n  \r\n  // caculate amount of token in crowdsale stage\r\n  function calculateTokenCrowsale(uint value, uint decimals) /*internal*/ public constant returns (uint) {\r\n    uint multiplier = 10 ** decimals;\r\n    return value.mul(multiplier).div(CROWDSALE_TOKEN_IN_WEI);\r\n  }\r\n  \r\n  // check if the goal is reached\r\n  function isMinimumGoalReached() public constant returns (bool) {\r\n    return crowdsale_eth_fund >= CROWDSALE_ETH_IN_WEI_FUND_MIN;\r\n  }\r\n  \r\n  // add new team percentage of tokens\r\n  function addTeamAddressInternal(address addr, uint release_time, uint token_percentage) internal {\r\n\tif((team_token_percentage_total.add(token_percentage)) > team_token_percentage_max) revert();\r\n\tif((team_token_percentage_total.add(token_percentage)) > 100) revert();\r\n\tif(team_addresses_token_percentage[addr] != 0) revert();\r\n\t\r\n\tteam_addresses_token_percentage[addr]= token_percentage;\r\n\tteam_addresses_idx[team_address_count]= addr;\r\n\tteam_address_count++;\r\n\t\r\n\tteam_token_percentage_total = team_token_percentage_total.add(token_percentage);\r\n\r\n\tAddTeamAddress(addr, release_time, token_percentage);\r\n  }\r\n   \r\n  // @return true if crowdsale event has ended\r\n  function hasEnded() public constant returns (bool) {\r\n    return now > endsAt;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    require(newOwner != address(0));      \r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Haltable is Ownable {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    if (halted) revert();\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!halted) revert();\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\ncontract Crowdsale is CrowdsaleLimit, Haltable {\r\n  using SafeMath for uint256;\r\n\r\n  CrowdsaleToken public token;\r\n  \r\n  /* tokens will be transfered from this address */\r\n  address public multisigWallet;\r\n    \r\n  /** How much ETH each address has invested to this crowdsale */\r\n  mapping (address => uint256) public investedAmountOf;\r\n\r\n  /** How much tokens this crowdsale has credited for each investor address */\r\n  mapping (address => uint256) public tokenAmountOf;\r\n  \r\n  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\r\n  mapping (address => bool) public presaleWhitelist;\r\n  \r\n  bool public whitelist_enable= true;\r\n  \r\n  /* the number of tokens already sold through this contract*/\r\n  uint public tokensSold = 0;\r\n  \r\n  /* How many distinct addresses have invested */\r\n  uint public investorCount = 0;\r\n  \r\n  /* How much wei we have returned back to the contract after a failed crowdfund. */\r\n  uint public loadedRefund = 0;\r\n  \r\n  /* Has this crowdsale been finalized */\r\n  bool public finalized;\r\n  \r\n  enum State{Unknown, PreFunding, Funding, Success, Failure, Finalized, Refunding}\r\n    \r\n  // A new investment was made\r\n  event Invested(address investor, uint weiAmount, uint tokenAmount);\r\n  \r\n  // Address early participation whitelist status changed\r\n  event Whitelisted(address addr, bool status);\r\n  \r\n  event createTeamTokenEvent(address addr, uint tokens);\r\n  \r\n  event Finalized();\r\n  \r\n  /** Modified allowing execution only if the crowdsale is currently running.  */\r\n  modifier inState(State state) {\r\n    if(getState() != state) revert();\r\n    _;\r\n  }\r\n\r\n  function Crowdsale(address _token, address _multisigWallet, uint _start, uint _end, uint _token_max, uint _presale_token_in_wei, uint _crowdsale_token_in_wei, uint _presale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_fund_min, uint _crowdsale_eth_inwei_fund_max, uint _crowdsale_eth_inwei_accepted_min, uint _crowdsale_gasprice_inwei_max, uint _team_token_percentage_max, bool _whitelist_enable) \r\n           CrowdsaleLimit(_start, _end, _token_max, _presale_token_in_wei, _crowdsale_token_in_wei, _presale_eth_inwei_fund_max, _crowdsale_eth_inwei_fund_min, _crowdsale_eth_inwei_fund_max, _crowdsale_eth_inwei_accepted_min, _crowdsale_gasprice_inwei_max, _team_token_percentage_max)\r\n  {\r\n    require(_token != 0x0);\r\n    require(_multisigWallet != 0x0);\r\n\t\r\n\ttoken = CrowdsaleToken(_token);\t\r\n\tmultisigWallet = _multisigWallet;\r\n\t\r\n\twhitelist_enable= _whitelist_enable;\r\n  }\r\n  \r\n  /* Crowdfund state machine management. */\r\n  function getState() public constant returns (State) {\r\n    if(finalized) return State.Finalized;\r\n    else if (now < startsAt) return State.PreFunding;\r\n    else if (now <= endsAt && !isMinimumGoalReached()) return State.Funding;\r\n    else if (isMinimumGoalReached()) return State.Success;\r\n    else if (!isMinimumGoalReached() && crowdsale_eth_fund > 0 && loadedRefund >= crowdsale_eth_fund) return State.Refunding;\r\n    else return State.Failure;\r\n  }\r\n   \r\n  /**\r\n   * Allow addresses to do early participation.\r\n   *\r\n   * TODO: Fix spelling error in the name\r\n   */\r\n  function setPresaleWhitelist(address addr, bool status) onlyOwner inState(State.PreFunding) {\r\n\trequire(whitelist_enable==true);\r\n\r\n    presaleWhitelist[addr] = status;\r\n    Whitelisted(addr, status);\r\n  }\r\n  \r\n  //add new team percentage of tokens and lock their release time\r\n  function addTeamAddress(address addr, uint release_time, uint token_percentage) onlyOwner inState(State.PreFunding) external {\r\n\tsuper.addTeamAddressInternal(addr, release_time, token_percentage);\r\n\ttoken.addLockAddress(addr, release_time);  //not use delegatecall\r\n  }\r\n  \r\n  //generate team tokens in accordance with percentage of total issue tokens, not preallocate\r\n  function createTeamTokenByPercentage() onlyOwner internal {\r\n\t//uint total= token.totalSupply();\r\n\tuint total= tokensSold;\r\n\t\r\n\t//uint tokens= total.mul(100).div(100-team_token_percentage_total).sub(total);\r\n\tuint tokens= total.mul(team_token_percentage_total).div(100-team_token_percentage_total);\r\n\t\r\n\tfor(uint i=0; i<team_address_count; i++) {\r\n\t\taddress addr= team_addresses_idx[i];\r\n\t\tif(addr==0x0) continue;\r\n\t\t\r\n\t\tuint ntoken= tokens.mul(team_addresses_token_percentage[addr]).div(team_token_percentage_total);\r\n\t\ttoken.mint(addr, ntoken);\t\t\r\n\t\tcreateTeamTokenEvent(addr, ntoken);\r\n\t}\r\n  }\r\n  \r\n  // fallback function can be used to buy tokens\r\n  function () stopInEmergency allowCrowdsaleAmountLimit payable {\r\n\trequire(msg.sender != 0x0);\r\n    buyTokensCrowdsale(msg.sender);\r\n  }\r\n\r\n  // low level token purchase function\r\n  function buyTokensCrowdsale(address receiver) internal /*stopInEmergency allowCrowdsaleAmountLimit payable*/ {\r\n\tuint256 weiAmount = msg.value;\r\n\tuint256 tokenAmount= 0;\r\n\t\r\n\tif(getState() == State.PreFunding) {\r\n\t\tif(whitelist_enable==true) {\r\n\t\t\tif(!presaleWhitelist[receiver]) {\r\n\t\t\t\trevert();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif((PRESALE_ETH_IN_WEI_FUND_MAX > 0) && ((presale_eth_fund.add(weiAmount)) > PRESALE_ETH_IN_WEI_FUND_MAX)) revert();\t\t\r\n\t\t\r\n\t\ttokenAmount = calculateTokenPresale(weiAmount, token.decimals());\r\n\t\tpresale_eth_fund = presale_eth_fund.add(weiAmount);\r\n\t}\r\n\telse if((getState() == State.Funding) || (getState() == State.Success)) {\r\n\t\ttokenAmount = calculateTokenCrowsale(weiAmount, token.decimals());\r\n\t\t\r\n    } else {\r\n      // Unwanted state\r\n      revert();\r\n    }\r\n\t\r\n\tif(tokenAmount == 0) {\r\n\t\trevert();\r\n\t}\t\r\n\t\r\n\tif(investedAmountOf[receiver] == 0) {\r\n       investorCount++;\r\n    }\r\n    \r\n\t// Update investor\r\n    investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\r\n    tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\r\n\t\r\n    // Update totals\r\n\tcrowdsale_eth_fund = crowdsale_eth_fund.add(weiAmount);\r\n\ttokensSold = tokensSold.add(tokenAmount);\r\n\t\r\n\tif((TOKEN_MAX > 0) && (tokensSold > TOKEN_MAX)) revert();\r\n\r\n    token.mint(receiver, tokenAmount);\r\n\r\n    if(!multisigWallet.send(weiAmount)) revert();\r\n\t\r\n\t// Tell us invest was success\r\n    Invested(receiver, weiAmount, tokenAmount);\r\n  }\r\n \r\n  /**\r\n   * Allow load refunds back on the contract for the refunding.\r\n   *\r\n   * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\r\n   */\r\n  function loadRefund() public payable inState(State.Failure) {\r\n    if(msg.value == 0) revert();\r\n    loadedRefund = loadedRefund.add(msg.value);\r\n  }\r\n  \r\n  /**\r\n   * Investors can claim refund.\r\n   *\r\n   * Note that any refunds from proxy buyers should be handled separately,\r\n   * and not through this contract.\r\n   */\r\n  function refund() public inState(State.Refunding) {\r\n    uint256 weiValue = investedAmountOf[msg.sender];\r\n    if (weiValue == 0) revert();\r\n    investedAmountOf[msg.sender] = 0;\r\n    crowdsale_eth_refund = crowdsale_eth_refund.add(weiValue);\r\n    Refund(msg.sender, weiValue);\r\n    if (!msg.sender.send(weiValue)) revert();\r\n  }\r\n  \r\n  function setEndsAt(uint time) onlyOwner {\r\n    if(now > time) {\r\n      revert();\r\n    }\r\n\r\n    endsAt = time;\r\n    EndsAtChanged(endsAt);\r\n  }\r\n  \r\n  // should be called after crowdsale ends, to do\r\n  // some extra finalization work\r\n  function doFinalize() public inState(State.Success) onlyOwner stopInEmergency {\r\n    \r\n\tif(finalized) {\r\n      revert();\r\n    }\r\n\r\n\tcreateTeamTokenByPercentage();\r\n    token.finishMinting();\t\r\n        \r\n    finalized = true;\r\n\tFinalized();\r\n  }\r\n  \r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n  bool public mintingFinished = false;\r\n  \r\n  /** List of agents that are allowed to create new tokens */\r\n  mapping (address => bool) public mintAgents;\r\n\r\n  event MintingAgentChanged(address addr, bool state  );\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  modifier onlyMintAgent() {\r\n    // Only crowdsale contracts are allowed to mint new tokens\r\n    if(!mintAgents[msg.sender]) {\r\n        revert();\r\n    }\r\n    _;\r\n  }\r\n  \r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n  \r\n  /**\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\n   */\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n    mintAgents[addr] = state;\r\n    MintingAgentChanged(addr, state);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will recieve the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(address _to, uint256 _amount) onlyMintAgent canMint public returns (bool) {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n\t\r\n\tTransfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyMintAgent public returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n  /* The finalizer contract that allows unlift the transfer limits on this token */\r\n  address public releaseAgent;\r\n\r\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\r\n  bool public released = false;\r\n\r\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\r\n  mapping (address => bool) public transferAgents;\r\n  \r\n  //dtco : time lock with specific address\r\n  mapping(address => uint) public lock_addresses;\r\n  \r\n  event AddLockAddress(address addr, uint lock_time);  \r\n\r\n  /**\r\n   * Limit token transfer until the crowdsale is over.\r\n   *\r\n   */\r\n  modifier canTransfer(address _sender) {\r\n\r\n    if(!released) {\r\n        if(!transferAgents[_sender]) {\r\n            revert();\r\n        }\r\n    }\r\n\telse {\r\n\t\t//check time lock with team\r\n\t\tif(now < lock_addresses[_sender]) {\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n    _;\r\n  }\r\n  \r\n  function ReleasableToken() {\r\n\treleaseAgent = msg.sender;\r\n  }\r\n  \r\n  //lock new team release time\r\n  function addLockAddressInternal(address addr, uint lock_time) inReleaseState(false) internal {\r\n\tif(addr == 0x0) revert();\r\n\tlock_addresses[addr]= lock_time;\r\n\tAddLockAddress(addr, lock_time);\r\n  }\r\n  \r\n  \r\n  /**\r\n   * Set the contract that can call release and make the token transferable.\r\n   *\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\n   */\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n\r\n    // We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n    releaseAgent = addr;\r\n  }\r\n\r\n  /**\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\n   */\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n    transferAgents[addr] = state;\r\n  }\r\n  \r\n  /** The function can be called only by a whitelisted release agent. */\r\n  modifier onlyReleaseAgent() {\r\n    if(msg.sender != releaseAgent) {\r\n        revert();\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * One way function to release the tokens to the wild.\r\n   *\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\n   */\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    released = true;\r\n  }\r\n\r\n  /** The function can be called only before or after the tokens have been releasesd */\r\n  modifier inReleaseState(bool releaseState) {\r\n    if(releaseState != released) {\r\n        revert();\r\n    }\r\n    _;\r\n  }  \r\n\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\n    // Call StandardToken.transfer()\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\n    // Call StandardToken.transferForm()\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken {\r\n\r\n  string public name;\r\n\r\n  string public symbol;\r\n\r\n  uint public decimals;\r\n    \r\n  /**\r\n   * Construct the token.\r\n   *\r\n   * @param _name Token name\r\n   * @param _symbol Token symbol - should be all caps\r\n   * @param _initialSupply How many tokens we start with\r\n   * @param _decimals Number of decimal places\r\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\r\n   */\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) {\r\n\r\n    owner = msg.sender;\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    totalSupply_ = _initialSupply;\r\n\r\n    decimals = _decimals;\r\n\r\n    balances[owner] = totalSupply_;\r\n\r\n    if(totalSupply_ > 0) {\r\n      Mint(owner, totalSupply_);\r\n    }\r\n\r\n    // No more new supply allowed after the token creation\r\n    if(!_mintable) {\r\n      mintingFinished = true;\r\n      if(totalSupply_ == 0) {\r\n        revert(); // Cannot create a token without supply and no minting\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\n   */\r\n   \r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    mintingFinished = true;\r\n    super.releaseTokenTransfer();\r\n  }\r\n  \r\n  //lock team address by crowdsale\r\n  function addLockAddress(address addr, uint lock_time) onlyMintAgent inReleaseState(false) public {\r\n\tsuper.addLockAddressInternal(addr, lock_time);\r\n  }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_TOKEN_IN_WEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doFinalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"team_addresses_idx\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale_eth_refund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"team_addresses_token_percentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team_address_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setEndsAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPresaleWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"calculateTokenCrowsale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loadedRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinimumGoalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"loadRefund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale_eth_fund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"calculateTokenPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team_token_percentage_max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenAmountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CROWDSALE_ETH_IN_WEI_FUND_MIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"release_time\",\"type\":\"uint256\"},{\"name\":\"token_percentage\",\"type\":\"uint256\"}],\"name\":\"addTeamAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CROWDSALE_ETH_IN_WEI_ACCEPTED_MIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist_enable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"team_token_percentage_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CROWDSALE_GASPRICE_IN_WEI_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CROWDSALE_ETH_IN_WEI_FUND_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_ETH_IN_WEI_FUND_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presale_eth_fund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CROWDSALE_TOKEN_IN_WEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"presaleWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_multisigWallet\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_end\",\"type\":\"uint256\"},{\"name\":\"_token_max\",\"type\":\"uint256\"},{\"name\":\"_presale_token_in_wei\",\"type\":\"uint256\"},{\"name\":\"_crowdsale_token_in_wei\",\"type\":\"uint256\"},{\"name\":\"_presale_eth_inwei_fund_max\",\"type\":\"uint256\"},{\"name\":\"_crowdsale_eth_inwei_fund_min\",\"type\":\"uint256\"},{\"name\":\"_crowdsale_eth_inwei_fund_max\",\"type\":\"uint256\"},{\"name\":\"_crowdsale_eth_inwei_accepted_min\",\"type\":\"uint256\"},{\"name\":\"_crowdsale_gasprice_inwei_max\",\"type\":\"uint256\"},{\"name\":\"_team_token_percentage_max\",\"type\":\"uint256\"},{\"name\":\"_whitelist_enable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"createTeamTokenEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newEndsAt\",\"type\":\"uint256\"}],\"name\":\"EndsAtChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"release_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"token_percentage\",\"type\":\"uint256\"}],\"name\":\"AddTeamAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000eb4756db5f0b9276c938e2537bb90593fc583d64000000000000000000000000ddddc059eb9b0f2714967865cb6701ca04feb3bb000000000000000000000000000000000000000000000000000000005b4be000000000000000000000000000000000000000000000000000000000005b74be80000000000000000000000000000000000000000000000000008caffd7d1b0000000000000000000000000000000000000000000000000000000103db0a81db6d00000000000000000000000000000000000000000000000000012f2a36ecd555000000000000000000000000000000000000000000000f3f20b8dfa69d00000000000000000000000000000000000000000000000000043c33c1937564800000000000000000000000000000000000000000000000001969368974c05b000000000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://19d156661486520302c3d749f111f9a4e7793c2da4a99d4caf3a5e409a330642"}]}