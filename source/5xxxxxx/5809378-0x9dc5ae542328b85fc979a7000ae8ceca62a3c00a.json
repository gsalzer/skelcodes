{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Registrar\r\n */\r\ncontract Registrar {\r\n\taddress private contractOwner;\r\n\tbool public paused;\r\n\r\n\tstruct Manifest {\r\n\t\taddress registrant;\r\n\t\tbytes32 name;\r\n\t\tuint256 version;\r\n\t\tuint256 index;\r\n\t\tbytes32 hashTypeName;\r\n\t\tstring checksum;\r\n\t\tuint256 createdOn;\r\n\t}\r\n\t\r\n\tstruct HashType {\r\n\t    bytes32 name;\r\n\t    bool active;\r\n\t}\r\n\t\r\n\tuint256 public numHashTypes;\r\n\tmapping(bytes32 => Manifest) private manifests;\r\n\tmapping(address => bytes32[]) private registrantManifests;\r\n\tmapping(bytes32 => bytes32[]) private registrantNameManifests;\r\n\tmapping(bytes32 => uint256) private registrantNameVersionCount;\r\n\tmapping(bytes32 => uint256) public hashTypeIdLookup;\r\n\tmapping(uint256 => HashType) public hashTypes;\r\n\t\r\n\t /**\r\n\t  * @dev Log when a manifest registration is successful\r\n\t  */\r\n\tevent LogManifest(address indexed registrant, bytes32 indexed name, uint256 indexed version, bytes32 hashTypeName, string checksum);\r\n\r\n    /**\r\n\t * @dev Checks if contractOwner addresss is calling\r\n\t */\r\n\tmodifier onlyContractOwner {\r\n\t\trequire(msg.sender == contractOwner);\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n\t * @dev Checks if contract is active\r\n\t */\r\n\tmodifier contractIsActive {\r\n\t\trequire(paused == false);\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev Checks if the values provided for this manifest are valid\r\n     */\r\n    modifier manifestIsValid(bytes32 name, bytes32 hashTypeName, string checksum, address registrant) {\r\n        require(name != bytes32(0x0) && \r\n            hashTypes[hashTypeIdLookup[hashTypeName]].active == true &&\r\n            bytes(checksum).length != 0 &&\r\n            registrant != address(0x0) &&\r\n            manifests[keccak256(abi.encodePacked(registrant, name, nextVersion(registrant, name)))].name == bytes32(0x0)\r\n            );\r\n        _;\r\n    }\r\n    \r\n\t/**\r\n\t * Constructor\r\n     */\r\n\tconstructor() public {\r\n\t\tcontractOwner = msg.sender;\r\n\t\taddHashType('sha256');\r\n\t}\r\n\r\n    /******************************************/\r\n    /*           OWNER ONLY METHODS           */\r\n    /******************************************/\r\n    \r\n    /**\r\n     * @dev Allows contractOwner to add hashType\r\n     * @param _name The value to be added\r\n     */\r\n    function addHashType(bytes32 _name) public onlyContractOwner {\r\n        require(hashTypeIdLookup[_name] == 0);\r\n        numHashTypes++;\r\n        hashTypeIdLookup[_name] = numHashTypes;\r\n        HashType storage _hashType = hashTypes[numHashTypes];\r\n        \r\n        // Store info about this hashType\r\n        _hashType.name = _name;\r\n        _hashType.active = true;\r\n    }\r\n    \r\n\t/**\r\n\t * @dev Allows contractOwner to activate/deactivate hashType\r\n\t * @param _name The name of the hashType\r\n\t * @param _active The value to be set\r\n\t */\r\n\tfunction setActiveHashType(bytes32 _name, bool _active) public onlyContractOwner {\r\n        require(hashTypeIdLookup[_name] > 0);\r\n        hashTypes[hashTypeIdLookup[_name]].active = _active;\r\n\t}\r\n\r\n    /**\r\n     * @dev Allows contractOwner to pause the contract\r\n     * @param _paused The value to be set\r\n     */\r\n\tfunction setPaused(bool _paused) public onlyContractOwner {\r\n\t\tpaused = _paused;\r\n\t}\r\n    \r\n    /**\r\n\t * @dev Allows contractOwner to kill the contract\r\n\t */\r\n    function kill() public onlyContractOwner {\r\n\t\tselfdestruct(contractOwner);\r\n\t}\r\n\r\n    /******************************************/\r\n    /*            PUBLIC METHODS              */\r\n    /******************************************/\r\n\t/**\r\n\t * @dev Function to determine the next version value of a manifest\r\n\t * @param _registrant The registrant address of the manifest\r\n\t * @param _name The name of the manifest\r\n\t * @return The next version value\r\n\t */\r\n\tfunction nextVersion(address _registrant, bytes32 _name) public view returns (uint256) {\r\n\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\r\n\t    return (registrantNameVersionCount[registrantNameIndex] + 1);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Function to register a manifest\r\n\t * @param _name The name of the manifest\r\n\t * @param _hashTypeName The hashType of the manifest\r\n\t * @param _checksum The checksum of the manifest\r\n\t */\r\n\tfunction register(bytes32 _name, bytes32 _hashTypeName, string _checksum) public \r\n\t    contractIsActive\r\n\t    manifestIsValid(_name, _hashTypeName, _checksum, msg.sender) {\r\n\r\n\t    // Generate registrant name index\r\n\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(msg.sender, _name));\r\n\t    \r\n\t    // Increment the version for this manifest\r\n\t    registrantNameVersionCount[registrantNameIndex]++;\r\n\t    \r\n\t    // Generate ID for this manifest\r\n\t    bytes32 manifestId = keccak256(abi.encodePacked(msg.sender, _name, registrantNameVersionCount[registrantNameIndex]));\r\n\t    \r\n        Manifest storage _manifest = manifests[manifestId];\r\n        \r\n        // Store info about this manifest\r\n        _manifest.registrant = msg.sender;\r\n        _manifest.name = _name;\r\n        _manifest.version = registrantNameVersionCount[registrantNameIndex];\r\n        _manifest.index = registrantNameManifests[registrantNameIndex].length;\r\n        _manifest.hashTypeName = _hashTypeName;\r\n        _manifest.checksum = _checksum;\r\n        _manifest.createdOn = now;\r\n        \r\n        registrantManifests[msg.sender].push(manifestId);\r\n        registrantNameManifests[registrantNameIndex].push(manifestId);\r\n\r\n\t    emit LogManifest(msg.sender, _manifest.name, _manifest.version, _manifest.hashTypeName, _manifest.checksum);\r\n\t}\r\n\r\n    /**\r\n     * @dev Function to get a manifest registration based on registrant address, manifest name and version\r\n     * @param _registrant The registrant address of the manifest\r\n     * @param _name The name of the manifest\r\n     * @param _version The version of the manifest\r\n     * @return The registrant address of the manifest\r\n     * @return The name of the manifest\r\n     * @return The version of the manifest\r\n     * @return The index of this manifest in registrantNameManifests\r\n     * @return The hashTypeName of the manifest\r\n     * @return The checksum of the manifest\r\n     * @return The created on date of the manifest\r\n     */\r\n\tfunction getManifest(address _registrant, bytes32 _name, uint256 _version) public view \r\n\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\r\n\t        \r\n\t    bytes32 manifestId = keccak256(abi.encodePacked(_registrant, _name, _version));\r\n\t    require(manifests[manifestId].name != bytes32(0x0));\r\n\r\n\t    Manifest memory _manifest = manifests[manifestId];\r\n\t    return (\r\n\t        _manifest.registrant,\r\n\t        _manifest.name,\r\n\t        _manifest.version,\r\n\t        _manifest.index,\r\n\t        _manifest.hashTypeName,\r\n\t        _manifest.checksum,\r\n\t        _manifest.createdOn\r\n\t   );\r\n\t}\r\n\r\n    /**\r\n     * @dev Function to get a manifest registration based on manifestId\r\n     * @param _manifestId The registration ID of the manifest\r\n     * @return The registrant address of the manifest\r\n     * @return The name of the manifest\r\n     * @return The version of the manifest\r\n     * @return The index of this manifest in registrantNameManifests\r\n     * @return The hashTypeName of the manifest\r\n     * @return The checksum of the manifest\r\n     * @return The created on date of the manifest\r\n     */\r\n\tfunction getManifestById(bytes32 _manifestId) public view\r\n\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\r\n\t    require(manifests[_manifestId].name != bytes32(0x0));\r\n\r\n\t    Manifest memory _manifest = manifests[_manifestId];\r\n\t    return (\r\n\t        _manifest.registrant,\r\n\t        _manifest.name,\r\n\t        _manifest.version,\r\n\t        _manifest.index,\r\n\t        _manifest.hashTypeName,\r\n\t        _manifest.checksum,\r\n\t        _manifest.createdOn\r\n\t   );\r\n\t}\r\n\r\n    /**\r\n     * @dev Function to get the latest manifest registration based on registrant address and manifest name\r\n     * @param _registrant The registrant address of the manifest\r\n     * @param _name The name of the manifest\r\n     * @return The registrant address of the manifest\r\n     * @return The name of the manifest\r\n     * @return The version of the manifest\r\n     * @return The index of this manifest in registrantNameManifests\r\n     * @return The hashTypeName of the manifest\r\n     * @return The checksum of the manifest\r\n     * @return The created on date of the manifest\r\n     */\r\n\tfunction getLatestManifestByName(address _registrant, bytes32 _name) public view\r\n\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\r\n\t        \r\n\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\r\n\t    require(registrantNameManifests[registrantNameIndex].length > 0);\r\n\t    \r\n\t    bytes32 manifestId = registrantNameManifests[registrantNameIndex][registrantNameManifests[registrantNameIndex].length - 1];\r\n\t    Manifest memory _manifest = manifests[manifestId];\r\n\r\n\t    return (\r\n\t        _manifest.registrant,\r\n\t        _manifest.name,\r\n\t        _manifest.version,\r\n\t        _manifest.index,\r\n\t        _manifest.hashTypeName,\r\n\t        _manifest.checksum,\r\n\t        _manifest.createdOn\r\n\t   );\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Function to get the latest manifest registration based on registrant address\r\n     * @param _registrant The registrant address of the manifest\r\n     * @return The registrant address of the manifest\r\n     * @return The name of the manifest\r\n     * @return The version of the manifest\r\n     * @return The index of this manifest in registrantNameManifests\r\n     * @return The hashTypeName of the manifest\r\n     * @return The checksum of the manifest\r\n     * @return The created on date of the manifest\r\n     */\r\n\tfunction getLatestManifest(address _registrant) public view\r\n\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\r\n\t    require(registrantManifests[_registrant].length > 0);\r\n\t    \r\n\t    bytes32 manifestId = registrantManifests[_registrant][registrantManifests[_registrant].length - 1];\r\n\t    Manifest memory _manifest = manifests[manifestId];\r\n\r\n\t    return (\r\n\t        _manifest.registrant,\r\n\t        _manifest.name,\r\n\t        _manifest.version,\r\n\t        _manifest.index,\r\n\t        _manifest.hashTypeName,\r\n\t        _manifest.checksum,\r\n\t        _manifest.createdOn\r\n\t   );\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Function to get a list of manifest Ids based on registrant address\r\n     * @param _registrant The registrant address of the manifest\r\n     * @return Array of manifestIds\r\n     */\r\n\tfunction getManifestIdsByRegistrant(address _registrant) public view returns (bytes32[]) {\r\n\t    return registrantManifests[_registrant];\r\n\t}\r\n\r\n    /**\r\n     * @dev Function to get a list of manifest Ids based on registrant address and manifest name\r\n     * @param _registrant The registrant address of the manifest\r\n     * @param _name The name of the manifest\r\n     * @return Array of registrationsIds\r\n     */\r\n\tfunction getManifestIdsByName(address _registrant, bytes32 _name) public view returns (bytes32[]) {\r\n\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\r\n\t    return registrantNameManifests[registrantNameIndex];\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Function to get manifest Id based on registrant address, manifest name and version\r\n     * @param _registrant The registrant address of the manifest\r\n     * @param _name The name of the manifest\r\n     * @param _version The version of the manifest\r\n     * @return The manifestId of the manifest\r\n     */\r\n\tfunction getManifestId(address _registrant, bytes32 _name, uint256 _version) public view returns (bytes32) {\r\n\t    bytes32 manifestId = keccak256(abi.encodePacked(_registrant, _name, _version));\r\n\t    require(manifests[manifestId].name != bytes32(0x0));\r\n\t    return manifestId;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"}],\"name\":\"getLatestManifest\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_hashTypeName\",\"type\":\"bytes32\"},{\"name\":\"_checksum\",\"type\":\"string\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numHashTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"}],\"name\":\"getManifestIdsByRegistrant\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"getLatestManifestByName\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashTypeIdLookup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"getManifestId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"getManifestIdsByName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setActiveHashType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"nextVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_registrant\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"getManifest\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_manifestId\",\"type\":\"bytes32\"}],\"name\":\"getManifestById\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"addHashType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hashTypes\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"registrant\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hashTypeName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"checksum\",\"type\":\"string\"}],\"name\":\"LogManifest\",\"type\":\"event\"}]","ContractName":"Registrar","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7055e827551a2bdfb6ad2ff51f387eb1dd079738cd35a55e59d1f804af5002bc"}]}