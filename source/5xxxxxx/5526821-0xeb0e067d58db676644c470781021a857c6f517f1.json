{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract MultiOwnable {\r\n\r\n    mapping(address => bool) public isOwner;\r\n    address[] public ownerHistory;\r\n    uint8 public ownerCount;\r\n\r\n    event OwnerAddedEvent(address indexed _newOwner);\r\n    event OwnerRemovedEvent(address indexed _oldOwner);\r\n\r\n    function MultiOwnable() public {\r\n        // Add default owner\r\n        address owner = msg.sender;\r\n        ownerHistory.push(owner);\r\n        isOwner[owner] = true;\r\n        ownerCount++;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function ownerHistoryCount() public view returns (uint) {\r\n        return ownerHistory.length;\r\n    }\r\n\r\n    /** Add extra owner. */\r\n    function addOwner(address owner) onlyOwner public {\r\n        require(owner != address(0));\r\n        require(!isOwner[owner]);\r\n        ownerHistory.push(owner);\r\n        isOwner[owner] = true;\r\n        ownerCount++;\r\n        OwnerAddedEvent(owner);\r\n    }\r\n\r\n    /** Remove extra owner. */\r\n    function removeOwner(address owner) onlyOwner public {\r\n\r\n        // This check is neccessary to prevent a situation where all owners \r\n        // are accidentally removed, because we do not want an ownable contract \r\n        // to become an orphan.\r\n        require(ownerCount > 1);\r\n\r\n        require(isOwner[owner]);\r\n        isOwner[owner] = false;\r\n        ownerCount--;\r\n        OwnerRemovedEvent(owner);\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n\r\n    bool public paused;\r\n\r\n    modifier ifNotPaused {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier ifPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    // Called by the owner on emergency, triggers paused state\r\n    function pause() external onlyOwner ifNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    // Called by the owner on end of emergency, returns to normal state\r\n    function resume() external onlyOwner ifPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract StandardToken is ERC20 {\r\n\r\n    using SafeMath for uint;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns number of allowed tokens for given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract CommonToken is StandardToken, MultiOwnable {\r\n\r\n    string public constant name = 'White Rabbit Token';\r\n    string public constant symbol = 'WRT';\r\n    uint8 public constant decimals = 18;\r\n\r\n    // The main account that holds all tokens from the time token created and during all tokensales.\r\n    address public seller;\r\n\r\n    // saleLimit (e18) Maximum amount of tokens for sale across all tokensales.\r\n    // Reserved tokens formula: 16% Team + 6% Partners + 5% Advisory Board + 15% WR reserve 1 = 42%\r\n    // For sale formula: 40% for sale + 1.5% Bounty + 16.5% WR reserve 2 = 58%\r\n    uint256 public constant saleLimit = 110200000 ether;\r\n\r\n    // Next fields are for stats:\r\n    uint256 public tokensSold; // (e18) Number of tokens sold through all tiers or tokensales.\r\n    uint256 public totalSales; // Total number of sales (including external sales) made through all tiers or tokensales.\r\n\r\n    // Lock the transfer functions during tokensales to prevent price speculations.\r\n    bool public locked = true;\r\n\r\n    event SellEvent(address indexed _seller, address indexed _buyer, uint256 _value);\r\n    event ChangeSellerEvent(address indexed _oldSeller, address indexed _newSeller);\r\n    event Burn(address indexed _burner, uint256 _value);\r\n    event Unlock();\r\n\r\n    function CommonToken(\r\n        address _seller\r\n    ) MultiOwnable() public {\r\n\r\n        require(_seller != 0);\r\n        seller = _seller;\r\n\r\n        totalSupply = 190000000 ether;\r\n        balances[seller] = totalSupply;\r\n        Transfer(0x0, seller, totalSupply);\r\n    }\r\n\r\n    modifier ifUnlocked() {\r\n        require(isOwner[msg.sender] || !locked);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * An address can become a new seller only in case it has no tokens.\r\n     * This is required to prevent stealing of tokens  from newSeller via \r\n     * 2 calls of this function.\r\n     */\r\n    function changeSeller(address newSeller) onlyOwner public returns (bool) {\r\n        require(newSeller != address(0));\r\n        require(seller != newSeller);\r\n\r\n        // To prevent stealing of tokens from newSeller via 2 calls of changeSeller:\r\n        require(balances[newSeller] == 0);\r\n\r\n        address oldSeller = seller;\r\n        uint256 unsoldTokens = balances[oldSeller];\r\n        balances[oldSeller] = 0;\r\n        balances[newSeller] = unsoldTokens;\r\n        Transfer(oldSeller, newSeller, unsoldTokens);\r\n\r\n        seller = newSeller;\r\n        ChangeSellerEvent(oldSeller, newSeller);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * User-friendly alternative to sell() function.\r\n     */\r\n    function sellNoDecimals(address _to, uint256 _value) public returns (bool) {\r\n        return sell(_to, _value * 1e18);\r\n    }\r\n\r\n    function sell(address _to, uint256 _value) onlyOwner public returns (bool) {\r\n\r\n        // Check that we are not out of limit and still can sell tokens:\r\n        if (saleLimit > 0) require(tokensSold.add(_value) <= saleLimit);\r\n\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(_value <= balances[seller]);\r\n\r\n        balances[seller] = balances[seller].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(seller, _to, _value);\r\n\r\n        totalSales++;\r\n        tokensSold = tokensSold.add(_value);\r\n        SellEvent(seller, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) ifUnlocked public returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) ifUnlocked public returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool) {\r\n        require(_value > 0);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Transfer(msg.sender, 0x0, _value);\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /** Can be called once by super owner. */\r\n    function unlock() onlyOwner public {\r\n        require(locked);\r\n        locked = false;\r\n        Unlock();\r\n    }\r\n}\r\n\r\ncontract CommonWhitelist is MultiOwnable {\r\n\r\n    mapping(address => bool) public isAllowed;\r\n\r\n    // Historical array of wallet that have bben added to whitelist,\r\n    // even if some addresses have been removed later such wallet still remaining\r\n    // in the history. This is Solidity optimization for work with large arrays.\r\n    address[] public history;\r\n\r\n    event AddedEvent(address indexed wallet);\r\n    event RemovedEvent(address indexed wallet);\r\n\r\n    function CommonWhitelist() MultiOwnable() public {}\r\n\r\n    function historyCount() public view returns (uint) {\r\n        return history.length;\r\n    }\r\n\r\n    function add(address _wallet) internal {\r\n        require(_wallet != address(0));\r\n        require(!isAllowed[_wallet]);\r\n\r\n        history.push(_wallet);\r\n        isAllowed[_wallet] = true;\r\n        AddedEvent(_wallet);\r\n    }\r\n\r\n    function addMany(address[] _wallets) public onlyOwner {\r\n        for (uint i = 0; i < _wallets.length; i++) {\r\n            add(_wallets[i]);\r\n        }\r\n    }\r\n\r\n    function remove(address _wallet) internal {\r\n        require(isAllowed[_wallet]);\r\n\r\n        isAllowed[_wallet] = false;\r\n        RemovedEvent(_wallet);\r\n    }\r\n\r\n    function removeMany(address[] _wallets) public onlyOwner {\r\n        for (uint i = 0; i < _wallets.length; i++) {\r\n            remove(_wallets[i]);\r\n        }\r\n    }\r\n}\r\n\r\n//---------------------------------------------------------------\r\n// Wings contracts: Start\r\n// DO NOT CHANGE the next contracts. They were copied from Wings \r\n// and left unformated.\r\n\r\ncontract HasManager {\r\n    address public manager;\r\n\r\n    modifier onlyManager {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    function transferManager(address _newManager) public onlyManager() {\r\n        require(_newManager != address(0));\r\n        manager = _newManager;\r\n    }\r\n}\r\n\r\n// Crowdsale contracts interface\r\ncontract ICrowdsaleProcessor is Ownable, HasManager {\r\n    modifier whenCrowdsaleAlive() {\r\n        require(isActive());\r\n        _;\r\n    }\r\n\r\n    modifier whenCrowdsaleFailed() {\r\n        require(isFailed());\r\n        _;\r\n    }\r\n\r\n    modifier whenCrowdsaleSuccessful() {\r\n        require(isSuccessful());\r\n        _;\r\n    }\r\n\r\n    modifier hasntStopped() {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n\r\n    modifier hasBeenStopped() {\r\n        require(stopped);\r\n        _;\r\n    }\r\n\r\n    modifier hasntStarted() {\r\n        require(!started);\r\n        _;\r\n    }\r\n\r\n    modifier hasBeenStarted() {\r\n        require(started);\r\n        _;\r\n    }\r\n\r\n    // Minimal acceptable hard cap\r\n    uint256 constant public MIN_HARD_CAP = 1 ether;\r\n\r\n    // Minimal acceptable duration of crowdsale\r\n    uint256 constant public MIN_CROWDSALE_TIME = 3 days;\r\n\r\n    // Maximal acceptable duration of crowdsale\r\n    uint256 constant public MAX_CROWDSALE_TIME = 50 days;\r\n\r\n    // Becomes true when timeframe is assigned\r\n    bool public started;\r\n\r\n    // Becomes true if cancelled by owner\r\n    bool public stopped;\r\n\r\n    // Total collected Ethereum: must be updated every time tokens has been sold\r\n    uint256 public totalCollected;\r\n\r\n    // Total amount of project's token sold: must be updated every time tokens has been sold\r\n    uint256 public totalSold;\r\n\r\n    // Crowdsale minimal goal, must be greater or equal to Forecasting min amount\r\n    uint256 public minimalGoal;\r\n\r\n    // Crowdsale hard cap, must be less or equal to Forecasting max amount\r\n    uint256 public hardCap;\r\n\r\n    // Crowdsale duration in seconds.\r\n    // Accepted range is MIN_CROWDSALE_TIME..MAX_CROWDSALE_TIME.\r\n    uint256 public duration;\r\n\r\n    // Start timestamp of crowdsale, absolute UTC time\r\n    uint256 public startTimestamp;\r\n\r\n    // End timestamp of crowdsale, absolute UTC time\r\n    uint256 public endTimestamp;\r\n\r\n    // Allows to transfer some ETH into the contract without selling tokens\r\n    function deposit() public payable {}\r\n\r\n    // Returns address of crowdsale token, must be ERC20 compilant\r\n    function getToken() public returns (address);\r\n\r\n    // Transfers ETH rewards amount (if ETH rewards is configured) to Forecasting contract\r\n    function mintETHRewards(address _contract, uint256 _amount) public onlyManager();\r\n\r\n    // Mints token Rewards to Forecasting contract\r\n    function mintTokenRewards(address _contract, uint256 _amount) public onlyManager();\r\n\r\n    // Releases tokens (transfers crowdsale token from mintable to transferrable state)\r\n    function releaseTokens() public onlyManager() hasntStopped() whenCrowdsaleSuccessful();\r\n\r\n    // Stops crowdsale. Called by CrowdsaleController, the latter is called by owner.\r\n    // Crowdsale may be stopped any time before it finishes.\r\n    function stop() public onlyManager() hasntStopped();\r\n\r\n    // Validates parameters and starts crowdsale\r\n    function start(uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress)\r\n    public onlyManager() hasntStarted() hasntStopped();\r\n\r\n    // Is crowdsale failed (completed, but minimal goal wasn't reached)\r\n    function isFailed() public constant returns (bool);\r\n\r\n    // Is crowdsale active (i.e. the token can be sold)\r\n    function isActive() public constant returns (bool);\r\n\r\n    // Is crowdsale completed successfully\r\n    function isSuccessful() public constant returns (bool);\r\n}\r\n\r\n// Basic crowdsale implementation both for regualt and 3rdparty Crowdsale contracts\r\ncontract BasicCrowdsale is ICrowdsaleProcessor {\r\n    event CROWDSALE_START(uint256 startTimestamp, uint256 endTimestamp, address fundingAddress);\r\n\r\n    // Where to transfer collected ETH\r\n    address public fundingAddress;\r\n\r\n    // Ctor.\r\n    function BasicCrowdsale(\r\n        address _owner,\r\n        address _manager\r\n    )\r\n    public\r\n    {\r\n        owner = _owner;\r\n        manager = _manager;\r\n    }\r\n\r\n    // called by CrowdsaleController to transfer reward part of ETH\r\n    // collected by successful crowdsale to Forecasting contract.\r\n    // This call is made upon closing successful crowdfunding process\r\n    // iff agreed ETH reward part is not zero\r\n    function mintETHRewards(\r\n        address _contract, // Forecasting contract\r\n        uint256 _amount     // agreed part of totalCollected which is intended for rewards\r\n    )\r\n    public\r\n    onlyManager() // manager is CrowdsaleController instance\r\n    {\r\n        require(_contract.call.value(_amount)());\r\n    }\r\n\r\n    // cancels crowdsale\r\n    function stop() public onlyManager() hasntStopped() {\r\n        // we can stop only not started and not completed crowdsale\r\n        if (started) {\r\n            require(!isFailed());\r\n            require(!isSuccessful());\r\n        }\r\n        stopped = true;\r\n    }\r\n\r\n    // called by CrowdsaleController to setup start and end time of crowdfunding process\r\n    // as well as funding address (where to transfer ETH upon successful crowdsale)\r\n    function start(\r\n        uint256 _startTimestamp,\r\n        uint256 _endTimestamp,\r\n        address _fundingAddress\r\n    )\r\n    public\r\n    onlyManager() // manager is CrowdsaleController instance\r\n    hasntStarted() // not yet started\r\n    hasntStopped() // crowdsale wasn't cancelled\r\n    {\r\n        require(_fundingAddress != address(0));\r\n\r\n        // start time must not be earlier than current time\r\n        require(_startTimestamp >= block.timestamp);\r\n\r\n        // range must be sane\r\n        require(_endTimestamp > _startTimestamp);\r\n        duration = _endTimestamp - _startTimestamp;\r\n\r\n        // duration must fit constraints\r\n        require(duration >= MIN_CROWDSALE_TIME && duration <= MAX_CROWDSALE_TIME);\r\n\r\n        startTimestamp = _startTimestamp;\r\n        endTimestamp = _endTimestamp;\r\n        fundingAddress = _fundingAddress;\r\n\r\n        // now crowdsale is considered started, even if the current time is before startTimestamp\r\n        started = true;\r\n\r\n        CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress);\r\n    }\r\n\r\n    // must return true if crowdsale is over, but it failed\r\n    function isFailed()\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        return (\r\n        // it was started\r\n        started &&\r\n\r\n        // crowdsale period has finished\r\n        block.timestamp >= endTimestamp &&\r\n\r\n        // but collected ETH is below the required minimum\r\n        totalCollected < minimalGoal\r\n        );\r\n    }\r\n\r\n    // must return true if crowdsale is active (i.e. the token can be bought)\r\n    function isActive()\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        return (\r\n        // it was started\r\n        started &&\r\n\r\n        // hard cap wasn't reached yet\r\n        totalCollected < hardCap &&\r\n\r\n        // and current time is within the crowdfunding period\r\n        block.timestamp >= startTimestamp &&\r\n        block.timestamp < endTimestamp\r\n        );\r\n    }\r\n\r\n    // must return true if crowdsale completed successfully\r\n    function isSuccessful()\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        return (\r\n        // either the hard cap is collected\r\n        totalCollected >= hardCap ||\r\n\r\n        // ...or the crowdfunding period is over, but the minimum has been reached\r\n        (block.timestamp >= endTimestamp && totalCollected >= minimalGoal)\r\n        );\r\n    }\r\n}\r\n\r\n// Minimal crowdsale token for custom contracts\r\ncontract IWingsController {\r\n    uint256 public ethRewardPart;\r\n    uint256 public tokenRewardPart;\r\n}\r\n\r\n/*\r\n  Implements custom crowdsale as bridge\r\n*/\r\ncontract Bridge is BasicCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyCrowdsale() {\r\n        require(msg.sender == crowdsaleAddress);\r\n        _;\r\n    }\r\n\r\n    // Crowdsale token\r\n    StandardToken token;\r\n\r\n    // Address of crowdsale\r\n    address public crowdsaleAddress;\r\n\r\n    // is crowdsale completed\r\n    bool public completed;\r\n\r\n    // Ctor. In this example, minimalGoal, hardCap, and price are not changeable.\r\n    // In more complex cases, those parameters may be changed until start() is called.\r\n    function Bridge(\r\n        uint256 _minimalGoal,\r\n        uint256 _hardCap,\r\n        address _token,\r\n        address _crowdsaleAddress\r\n    )\r\n    public\r\n        // simplest case where manager==owner. See onlyOwner() and onlyManager() modifiers\r\n        // before functions to figure out the cases in which those addresses should differ\r\n    BasicCrowdsale(msg.sender, msg.sender)\r\n    {\r\n        // just setup them once...\r\n        minimalGoal = _minimalGoal;\r\n        hardCap = _hardCap;\r\n        crowdsaleAddress = _crowdsaleAddress;\r\n        token = StandardToken(_token);\r\n    }\r\n\r\n    // Here goes ICrowdsaleProcessor implementation\r\n\r\n    // returns address of crowdsale token. The token must be ERC20-compliant\r\n    function getToken()\r\n    public\r\n    returns (address)\r\n    {\r\n        return address(token);\r\n    }\r\n\r\n    // called by CrowdsaleController to transfer reward part of\r\n    // tokens sold by successful crowdsale to Forecasting contract.\r\n    // This call is made upon closing successful crowdfunding process.\r\n    function mintTokenRewards(\r\n        address _contract, // Forecasting contract\r\n        uint256 _amount     // agreed part of totalSold which is intended for rewards\r\n    )\r\n    public\r\n    onlyManager() // manager is CrowdsaleController instance\r\n    {\r\n        // crowdsale token is mintable in this example, tokens are created here\r\n        token.transfer(_contract, _amount);\r\n    }\r\n\r\n    // transfers crowdsale token from mintable to transferrable state\r\n    function releaseTokens()\r\n    public\r\n    onlyManager() // manager is CrowdsaleController instance\r\n    hasntStopped() // crowdsale wasn't cancelled\r\n    whenCrowdsaleSuccessful() // crowdsale was successful\r\n    {\r\n        // empty for bridge\r\n    }\r\n\r\n    // Here go crowdsale process itself and token manipulations\r\n\r\n    // default function allows for ETH transfers to the contract\r\n    function() payable public {\r\n    }\r\n\r\n    function notifySale(uint256 _ethAmount, uint256 _tokensAmount) public\r\n    hasBeenStarted() // crowdsale started\r\n    hasntStopped() // wasn't cancelled by owner\r\n    whenCrowdsaleAlive() // in active state\r\n    onlyCrowdsale() // can do only crowdsale\r\n    {\r\n        totalCollected = totalCollected.add(_ethAmount);\r\n        totalSold = totalSold.add(_tokensAmount);\r\n    }\r\n\r\n    // finish collecting data\r\n    function finish() public\r\n    hasntStopped()\r\n    hasBeenStarted()\r\n    whenCrowdsaleAlive()\r\n    onlyCrowdsale()\r\n    {\r\n        completed = true;\r\n    }\r\n\r\n    // project's owner withdraws ETH funds to the funding address upon successful crowdsale\r\n    function withdraw(\r\n        uint256 _amount // can be done partially\r\n    )\r\n    public\r\n    onlyOwner() // project's owner\r\n    hasntStopped() // crowdsale wasn't cancelled\r\n    whenCrowdsaleSuccessful() // crowdsale completed successfully\r\n    {\r\n        // nothing to withdraw\r\n    }\r\n\r\n    // backers refund their ETH if the crowdsale was cancelled or has failed\r\n    function refund()\r\n    public\r\n    {\r\n        // nothing to refund\r\n    }\r\n\r\n    // called by CrowdsaleController to setup start and end time of crowdfunding process\r\n    // as well as funding address (where to transfer ETH upon successful crowdsale)\r\n    function start(\r\n        uint256 _startTimestamp,\r\n        uint256 _endTimestamp,\r\n        address _fundingAddress\r\n    )\r\n    public\r\n    onlyManager() // manager is CrowdsaleController instance\r\n    hasntStarted() // not yet started\r\n    hasntStopped() // crowdsale wasn't cancelled\r\n    {\r\n        // just start crowdsale\r\n        started = true;\r\n\r\n        CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress);\r\n    }\r\n\r\n    // must return true if crowdsale is over, but it failed\r\n    function isFailed()\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        return (\r\n        false\r\n        );\r\n    }\r\n\r\n    // must return true if crowdsale is active (i.e. the token can be bought)\r\n    function isActive()\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        return (\r\n        // we remove timelines\r\n        started && !completed\r\n        );\r\n    }\r\n\r\n    // must return true if crowdsale completed successfully\r\n    function isSuccessful()\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        return (\r\n        completed\r\n        );\r\n    }\r\n\r\n    function calculateRewards() public view returns (uint256, uint256) {\r\n        uint256 tokenRewardPart = IWingsController(manager).tokenRewardPart();\r\n        uint256 ethRewardPart = IWingsController(manager).ethRewardPart();\r\n\r\n        uint256 tokenReward = totalSold.mul(tokenRewardPart) / 1000000;\r\n        bool hasEthReward = (ethRewardPart != 0);\r\n\r\n        uint256 ethReward = 0;\r\n        if (hasEthReward) {\r\n            ethReward = totalCollected.mul(ethRewardPart) / 1000000;\r\n        }\r\n\r\n        return (ethReward, tokenReward);\r\n    }\r\n}\r\n\r\ncontract Connector is Ownable {\r\n    modifier bridgeInitialized() {\r\n        require(address(bridge) != address(0x0));\r\n        _;\r\n    }\r\n\r\n    Bridge public bridge;\r\n\r\n    function changeBridge(address _bridge) public onlyOwner {\r\n        require(_bridge != address(0x0));\r\n        bridge = Bridge(_bridge);\r\n    }\r\n\r\n    function notifySale(uint256 _ethAmount, uint256 _tokenAmount) internal bridgeInitialized {\r\n        bridge.notifySale(_ethAmount, _tokenAmount);\r\n    }\r\n\r\n    function closeBridge() internal bridgeInitialized {\r\n        bridge.finish();\r\n    }\r\n}\r\n\r\n// Wings contracts: End\r\n//---------------------------------------------------------------\r\n\r\ncontract CommonTokensale is Connector, Pausable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    CommonToken public token;         // Token contract reference.\r\n    CommonWhitelist public whitelist; // Whitelist contract reference.\r\n\r\n    address public beneficiary;       // Address that will receive ETH raised during this tokensale.\r\n    address public bsWallet = 0x8D5bd2aBa04A07Bfa0cc976C73eD45B23cC6D6a2;\r\n\r\n    bool public whitelistEnabled = true;\r\n\r\n    uint public constant preSaleMinPaymentWei = 5 ether;    // Hint: Set to lower amount (ex. 0.001 ETH) for tests.\r\n    uint public constant mainSaleMinPaymentWei = 0.05 ether; // Hint: Set to lower amount (ex. 0.001 ETH) for tests.\r\n\r\n    uint public defaultTokensPerWei = 4750; // TODO To be determined based on ETH to USD price at the date of sale.\r\n    uint public tokensPerWei5;\r\n    uint public tokensPerWei7;\r\n    uint public tokensPerWei10;\r\n    uint public tokensPerWei15;\r\n    uint public tokensPerWei20;\r\n\r\n    uint public minCapWei = 3200 ether;  // TODO  2m USD. Recalculate based on ETH to USD price at the date of tokensale.\r\n    uint public maxCapWei = 16000 ether; // TODO 10m USD. Recalculate based on ETH to USD price at the date of tokensale.\r\n\r\n    uint public constant startTime = 1525701600; // May 7, 2018 2:00:00 PM\r\n    uint public constant preSaleEndTime = 1526306400; // May 14, 2018 2:00:00 PM\r\n    uint public constant mainSaleStartTime = 1526392800; // May 15, 2018 2:00:00 PM\r\n    uint public constant endTime = 1528639200; // June 10, 2018 2:00:00 PM\r\n\r\n    // At main sale bonuses will be available only during the first 48 hours.\r\n    uint public mainSaleBonusEndTime;\r\n\r\n    // In case min (soft) cap is not reached, token buyers will be able to \r\n    // refund their contributions during one month after sale is finished.\r\n    uint public refundDeadlineTime;\r\n\r\n    // Stats for current tokensale:\r\n\r\n    uint public totalTokensSold;  // Total amount of tokens sold during this tokensale.\r\n    uint public totalWeiReceived; // Total amount of wei received during this tokensale.\r\n    uint public totalWeiRefunded; // Total amount of wei refunded if min (soft) cap is not reached.\r\n\r\n    // This mapping stores info on how many ETH (wei) have been sent to this tokensale from specific address.\r\n    mapping(address => uint256) public buyerToSentWei;\r\n\r\n    mapping(bytes32 => bool) public calledOnce;\r\n\r\n    event ChangeBeneficiaryEvent(address indexed _oldAddress, address indexed _newAddress);\r\n    event ChangeWhitelistEvent(address indexed _oldAddress, address indexed _newAddress);\r\n    event ReceiveEthEvent(address indexed _buyer, uint256 _amountWei);\r\n    event RefundEthEvent(address indexed _buyer, uint256 _amountWei);\r\n\r\n    function CommonTokensale(\r\n        address _token,\r\n        address _whitelist,\r\n        address _beneficiary\r\n    ) public Connector() {\r\n        require(_token != 0);\r\n        require(_whitelist != 0);\r\n        require(_beneficiary != 0);\r\n\r\n        token = CommonToken(_token);\r\n        whitelist = CommonWhitelist(_whitelist);\r\n        beneficiary = _beneficiary;\r\n\r\n        mainSaleBonusEndTime = mainSaleStartTime + 48 hours;\r\n        refundDeadlineTime = endTime + 30 days;\r\n\r\n        recalcBonuses();\r\n    }\r\n\r\n    modifier canBeCalledOnce(bytes32 _flag) {\r\n        require(!calledOnce[_flag]);\r\n        calledOnce[_flag] = true;\r\n        _;\r\n    }\r\n\r\n    function updateMinCapEthOnce(uint _amountInEth) public onlyOwner canBeCalledOnce(\"updateMinCapEth\") {\r\n        minCapWei = _amountInEth * 1e18;\r\n        // Convert ETH to Wei and update a min cap.\r\n    }\r\n\r\n    function updateMaxCapEthOnce(uint _amountInEth) public onlyOwner canBeCalledOnce(\"updateMaxCapEth\") {\r\n        maxCapWei = _amountInEth * 1e18;\r\n        // Convert ETH to Wei and update a max cap.\r\n    }\r\n\r\n    function updateTokensPerEthOnce(uint _amountInEth) public onlyOwner canBeCalledOnce(\"updateTokensPerEth\") {\r\n        defaultTokensPerWei = _amountInEth;\r\n        recalcBonuses();\r\n    }\r\n\r\n    function setBeneficiary(address _beneficiary) public onlyOwner {\r\n        require(_beneficiary != 0);\r\n        ChangeBeneficiaryEvent(beneficiary, _beneficiary);\r\n        beneficiary = _beneficiary;\r\n    }\r\n\r\n    function setWhitelist(address _whitelist) public onlyOwner {\r\n        require(_whitelist != 0);\r\n        ChangeWhitelistEvent(whitelist, _whitelist);\r\n        whitelist = CommonWhitelist(_whitelist);\r\n    }\r\n\r\n    function setWhitelistEnabled(bool _enabled) public onlyOwner {\r\n        whitelistEnabled = _enabled;\r\n    }\r\n\r\n    /** The fallback function corresponds to a donation in ETH. */\r\n    function() public payable {\r\n        sellTokensForEth(msg.sender, msg.value);\r\n    }\r\n\r\n    function sellTokensForEth(\r\n        address _buyer,\r\n        uint256 _amountWei\r\n    ) ifNotPaused internal {\r\n\r\n        // Check that buyer is in whitelist onlist if whitelist check is enabled.\r\n        if (whitelistEnabled) require(whitelist.isAllowed(_buyer));\r\n\r\n        require(canAcceptPayment(_amountWei));\r\n        require(totalWeiReceived < maxCapWei);\r\n\r\n        uint256 newTotalReceived = totalWeiReceived.add(_amountWei);\r\n\r\n        // Don't sell anything above the hard cap\r\n        if (newTotalReceived > maxCapWei) {\r\n            uint refundWei = newTotalReceived.sub(maxCapWei);\r\n            _amountWei = _amountWei.sub(refundWei);\r\n\r\n            // We need to check payment amount once more such as we updated \r\n            // (reduced) it in this if-clause.\r\n            require(canAcceptPayment(_amountWei));\r\n\r\n            // Send the ETH part which exceeds the hard cap back to the buyer:\r\n            _buyer.transfer(refundWei);\r\n        }\r\n\r\n        uint tokensE18 = weiToTokens(_amountWei);\r\n        // Transfer tokens to buyer.\r\n        token.sell(_buyer, tokensE18);\r\n\r\n        // 0.75% of sold tokens go to BS account:\r\n        uint bsTokens = tokensE18.mul(75).div(10000);\r\n        token.sell(bsWallet, bsTokens);\r\n\r\n        // Update total stats:\r\n        totalTokensSold = totalTokensSold.add(tokensE18).add(bsTokens);\r\n        totalWeiReceived = totalWeiReceived.add(_amountWei);\r\n        buyerToSentWei[_buyer] = buyerToSentWei[_buyer].add(_amountWei);\r\n        ReceiveEthEvent(_buyer, _amountWei);\r\n\r\n        // Notify Wings about successful sale of tokens:\r\n        notifySale(_amountWei, tokensE18.add(bsTokens));\r\n    }\r\n\r\n    function recalcBonuses() internal {\r\n        tokensPerWei5 = tokensPerWeiPlusBonus(5);\r\n        tokensPerWei7 = tokensPerWeiPlusBonus(7);\r\n        tokensPerWei10 = tokensPerWeiPlusBonus(10);\r\n        tokensPerWei15 = tokensPerWeiPlusBonus(15);\r\n        tokensPerWei20 = tokensPerWeiPlusBonus(20);\r\n    }\r\n\r\n    function tokensPerWeiPlusBonus(uint _per) public view returns (uint) {\r\n        return defaultTokensPerWei.add(\r\n            amountPercentage(defaultTokensPerWei, _per)\r\n        );\r\n    }\r\n\r\n    function amountPercentage(uint _amount, uint _per) public pure returns (uint) {\r\n        return _amount.mul(_per).div(100);\r\n    }\r\n\r\n    /** Calc how much tokens you can buy at current time. */\r\n    function weiToTokens(uint _amountWei) public view returns (uint) {\r\n        return _amountWei.mul(tokensPerWei(_amountWei));\r\n    }\r\n\r\n    function tokensPerWei(uint _amountWei) public view returns (uint256) {\r\n        // Presale bonuses:\r\n        if (isPreSaleTime()) {\r\n            if (5 ether <= _amountWei && _amountWei < 10 ether) return tokensPerWei10;\r\n            if (_amountWei < 20 ether) return tokensPerWei15;\r\n            if (20 ether <= _amountWei) return tokensPerWei20;\r\n        }\r\n        // Main sale bonues:\r\n        if (isMainSaleBonusTime()) {\r\n            if (0.05 ether <= _amountWei && _amountWei < 10 ether) return tokensPerWei5;\r\n            if (_amountWei < 20 ether) return tokensPerWei7;\r\n            if (20 ether <= _amountWei) return tokensPerWei10;\r\n        }\r\n        return defaultTokensPerWei;\r\n    }\r\n\r\n    function canAcceptPayment(uint _amountWei) public view returns (bool) {\r\n        if (isPreSaleTime()) return _amountWei >= preSaleMinPaymentWei;\r\n        if (isMainSaleTime()) return _amountWei >= mainSaleMinPaymentWei;\r\n        return false;\r\n    }\r\n\r\n    function isPreSaleTime() public view returns (bool) {\r\n        return startTime <= now && now <= preSaleEndTime;\r\n    }\r\n\r\n    function isMainSaleBonusTime() public view returns (bool) {\r\n        return mainSaleStartTime <= now && now <= mainSaleBonusEndTime;\r\n    }\r\n\r\n    function isMainSaleTime() public view returns (bool) {\r\n        return mainSaleStartTime <= now && now <= endTime;\r\n    }\r\n\r\n    function isFinishedSuccessfully() public view returns (bool) {\r\n        return totalWeiReceived >= minCapWei && now > endTime;\r\n    }\r\n\r\n    /** \r\n     * During tokensale it will be possible to withdraw only in two cases:\r\n     * min cap reached OR refund period expired.\r\n     */\r\n    function canWithdraw() public view returns (bool) {\r\n        return totalWeiReceived >= minCapWei || now > refundDeadlineTime;\r\n    }\r\n\r\n    /** \r\n     * This method allows to withdraw to any arbitrary ETH address. \r\n     * This approach gives more flexibility.\r\n     */\r\n    function withdraw(address _to, uint256 _amount) public {\r\n        require(canWithdraw());\r\n        require(msg.sender == beneficiary);\r\n        require(_amount <= this.balance);\r\n\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    function withdraw(address _to) public {\r\n        withdraw(_to, this.balance);\r\n    }\r\n\r\n    /** \r\n     * It will be possible to refund only if min (soft) cap is not reached and \r\n     * refund requested during 30 days after tokensale finished.\r\n     */\r\n    function canRefund() public view returns (bool) {\r\n        return totalWeiReceived < minCapWei && endTime < now && now <= refundDeadlineTime;\r\n    }\r\n\r\n    function refund() public {\r\n        require(canRefund());\r\n\r\n        address buyer = msg.sender;\r\n        uint amount = buyerToSentWei[buyer];\r\n        require(amount > 0);\r\n\r\n        RefundEthEvent(buyer, amount);\r\n        buyerToSentWei[buyer] = 0;\r\n        totalWeiRefunded = totalWeiRefunded.add(amount);\r\n        buyer.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * If there is ETH rewards and all ETH already withdrawn but contract \r\n     * needs to pay for transfering transactions. \r\n     */\r\n    function deposit() public payable {\r\n        require(isFinishedSuccessfully());\r\n    }\r\n\r\n    /** \r\n     * This function should be called only once only after \r\n     * successfully finished tokensale. Once - because Wings bridge \r\n     * will be closed at the end of this function call.\r\n     */\r\n    function sendWingsRewardsOnce() public onlyOwner canBeCalledOnce(\"sendWingsRewards\") {\r\n        require(isFinishedSuccessfully());\r\n\r\n        uint256 ethReward = 0;\r\n        uint256 tokenReward = 0;\r\n\r\n        (ethReward, tokenReward) = bridge.calculateRewards();\r\n\r\n        if (ethReward > 0) {\r\n            bridge.transfer(ethReward);\r\n        }\r\n\r\n        if (tokenReward > 0) {\r\n            token.sell(bridge, tokenReward);\r\n        }\r\n\r\n        // Close Wings bridge\r\n        closeBridge();\r\n    }\r\n}\r\n\r\n\r\n// >> Start:\r\n// >> EXAMPLE: How to deploy Token, Whitelist and Tokensale.\r\n\r\n// token = new CommonToken(\r\n//     0x123 // TODO Set seller address\r\n// );\r\n// whitelist = new CommonWhitelist();\r\n// tokensale = new Tokensale(\r\n//     token,\r\n//     whitelist,\r\n//     0x123 // TODO Set beneficiary address\r\n// );\r\n// token.addOwner(tokensale);\r\n\r\n// << EXAMPLE: How to deploy Token, Whitelist and Tokensale.\r\n// << End\r\n\r\n\r\n// TODO After Tokensale deployed, call token.addOwner(address_of_deployed_tokensale)\r\ncontract ProdTokensale is CommonTokensale {\r\n    function ProdTokensale() CommonTokensale(\r\n        0x123, // TODO Set token address\r\n        0x123, // TODO Set whitelist address\r\n        0x123  // TODO Set beneficiary address\r\n    ) public {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CROWDSALE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintETHRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_CROWDSALE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_HARD_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"name\":\"_tokensAmount\",\"type\":\"uint256\"}],\"name\":\"notifySale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"completed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTimestamp\",\"type\":\"uint256\"},{\"name\":\"_endTimestamp\",\"type\":\"uint256\"},{\"name\":\"_fundingAddress\",\"type\":\"address\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTokenRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"transferManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSuccessful\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFailed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_minimalGoal\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundingAddress\",\"type\":\"address\"}],\"name\":\"CROWDSALE_START\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Bridge","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000f557ae02978e74aab75009cb354e7e1570afa59e000000000000000000000000ddabca696af8608452b3451b7d70fff57d0ca3e7","Library":"","SwarmSource":"bzzr://7fd723e9b0376011c1268d93dad5d32e4a891107837bf6c54fa26f287d797c68"}]}