{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract LIMITED_42 {\r\n\r\n    struct PatternOBJ {\r\n        address owner;\r\n        string message;\r\n        string data;\r\n    }\r\n\r\n    mapping(address => bytes32[]) public Patterns;\r\n    mapping(bytes32 => PatternOBJ) public Pattern;\r\n\r\n    string public info = \"\";\r\n\r\n    address private constant emergency_admin = 0x59ab67D9BA5a748591bB79Ce223606A8C2892E6d;\r\n    address private constant first_admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\r\n    address private admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\r\n\r\n\r\n    /**************************************************************************\r\n    * modifiers\r\n    ***************************************************************************/\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    /**************************************************************************\r\n    * functionS\r\n    ***************************************************************************/\r\n\r\n    function checkPatternExistance (bytes32 patternid) public view\r\n    returns(bool)\r\n    {\r\n      if(Pattern[patternid].owner == address(0)){\r\n        return false;\r\n      }else{\r\n        return true;\r\n      }\r\n    }\r\n\r\n    function createPattern(bytes32 patternid, string dataMixed, address newowner, string message)\r\n        onlyAdmin\r\n        public\r\n        returns(string)\r\n    {\r\n      //CONVERT DATA to UPPERCASE\r\n      string memory data = toUpper(dataMixed);\r\n\r\n      //FIRST CHECK IF PATTERNID AND DATA HASH MATCH!!!\r\n      require(keccak256(abi.encodePacked(data)) == patternid);\r\n\r\n      //no ownerless Pattern // also possible to gift Pattern\r\n      require(newowner != address(0));\r\n\r\n      //check EXISTANCE\r\n      if(Pattern[patternid].owner == address(0)){\r\n          //IF DOENST EXIST\r\n\r\n          //create pattern at coresponding id\r\n          Pattern[patternid].owner = newowner;\r\n          Pattern[patternid].message = message;\r\n          Pattern[patternid].data = data;\r\n\r\n          addPatternUserIndex(newowner,patternid);\r\n\r\n          return \"ok\";\r\n\r\n      }else{\r\n          //must be for sale\r\n          return \"error:exists\";\r\n      }\r\n\r\n    }\r\n    function transferPattern(bytes32 patternid,address newowner,string message, uint8 v, bytes32 r, bytes32 s)\r\n      public\r\n      returns(string)\r\n    {\r\n      // just so we have somthing\r\n      address oldowner = admin;\r\n\r\n      //check that pattern in question has an owner\r\n      require(Pattern[patternid].owner != address(0));\r\n\r\n      //check that newowner is not no one\r\n      require(newowner != address(0));\r\n\r\n      //check if sender iis owner\r\n      if(Pattern[patternid].owner == msg.sender){\r\n        //if sender iiis owner\r\n        oldowner = msg.sender;\r\n      }else{\r\n        // anyone else need to supply a new address signed by the old owner\r\n\r\n        //generate the h for the new address\r\n        bytes32 h = prefixedHash2(newowner);\r\n        //check if eveything adds up.\r\n        require(ecrecover(h, v, r, s) == Pattern[patternid].owner);\r\n        oldowner = Pattern[patternid].owner;\r\n      }\r\n\r\n      //remove reference from old owner mapping\r\n      removePatternUserIndex(oldowner,patternid);\r\n\r\n      //update pattern owner and message\r\n      Pattern[patternid].owner = newowner;\r\n      Pattern[patternid].message = message;\r\n      //add reference to owner map\r\n      addPatternUserIndex(newowner,patternid);\r\n\r\n      return \"ok\";\r\n\r\n    }\r\n\r\n    function changeMessage(bytes32 patternid,string message, uint8 v, bytes32 r, bytes32 s)\r\n      public\r\n      returns(string)\r\n    {\r\n      // just so we have somthing\r\n      address owner = admin;\r\n\r\n      //check that pattern in question has an owner\r\n      require(Pattern[patternid].owner != address(0));\r\n\r\n      //check if sender iis owner\r\n      if(Pattern[patternid].owner == msg.sender){\r\n        //if sender iiis owner\r\n        owner = msg.sender;\r\n      }else{\r\n        // anyone else need to supply a new address signed by the old owner\r\n\r\n        //generate the h for the new address\r\n        bytes32 h = prefixedHash(message);\r\n        owner = ecrecover(h, v, r, s);\r\n      }\r\n\r\n      require(Pattern[patternid].owner == owner);\r\n\r\n      Pattern[patternid].message = message;\r\n\r\n      return \"ok\";\r\n\r\n    }\r\n\r\n    function verifyOwner(bytes32 patternid, address owner, uint8 v, bytes32 r, bytes32 s)\r\n      public\r\n      view\r\n      returns(bool)\r\n    {\r\n      //check that pattern in question has an owner\r\n      require(Pattern[patternid].owner != address(0));\r\n\r\n      //resolve owner address from signature\r\n      bytes32 h = prefixedHash2(owner);\r\n      address owner2 = ecrecover(h, v, r, s);\r\n\r\n      require(owner2 == owner);\r\n\r\n      //check if owner actually owns item in question\r\n      if(Pattern[patternid].owner == owner2){\r\n        return true;\r\n      }else{\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function prefixedHash(string message)\r\n      private\r\n      pure\r\n      returns (bytes32)\r\n    {\r\n        bytes32 h = keccak256(abi.encodePacked(message));\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\r\n    }\r\n\r\n    function prefixedHash2(address message)\r\n      private\r\n      pure\r\n      returns (bytes32)\r\n    {\r\n        bytes32 h = keccak256(abi.encodePacked(message));\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\r\n    }\r\n\r\n\r\n    function addPatternUserIndex(address account, bytes32 patternid)\r\n      private\r\n    {\r\n        Patterns[account].push(patternid);\r\n    }\r\n\r\n    function removePatternUserIndex(address account, bytes32 patternid)\r\n      private\r\n    {\r\n      require(Pattern[patternid].owner == account);\r\n      for (uint i = 0; i<Patterns[account].length; i++){\r\n          if(Patterns[account][i] == patternid){\r\n              //replace with last entry\r\n              Patterns[account][i] = Patterns[account][Patterns[account].length-1];\r\n              //delete last\r\n              delete Patterns[account][Patterns[account].length-1];\r\n              //shorten array\r\n              Patterns[account].length--;\r\n          }\r\n      }\r\n    }\r\n\r\n    function userHasPattern(address account)\r\n      public\r\n      view\r\n      returns(bool)\r\n    {\r\n      if(Patterns[account].length >=1 )\r\n      {\r\n        return true;\r\n      }else{\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function emergency(address newa, uint8 v, bytes32 r, bytes32 s, uint8 v2, bytes32 r2, bytes32 s2)\r\n      public\r\n    {\r\n      //generate hashes\r\n      bytes32 h = prefixedHash2(newa);\r\n\r\n      //check if admin and emergency_admin signed the messages\r\n      require(ecrecover(h, v, r, s)==admin);\r\n      require(ecrecover(h, v2, r2, s2)==emergency_admin);\r\n      //set new admin\r\n      admin = newa;\r\n    }\r\n\r\n    function changeInfo(string newinfo)\r\n      public\r\n      onlyAdmin\r\n    {\r\n      //only admin can call this.\r\n      //require(msg.sender == admin); used modifier\r\n\r\n      info = newinfo;\r\n    }\r\n\r\n\r\n    function toUpper(string str)\r\n      pure\r\n      private\r\n      returns (string)\r\n    {\r\n      bytes memory bStr = bytes(str);\r\n      bytes memory bLower = new bytes(bStr.length);\r\n      for (uint i = 0; i < bStr.length; i++) {\r\n        // lowercase character...\r\n        if ((bStr[i] >= 65+32) && (bStr[i] <= 90+32)) {\r\n          // So we remove 32 to make it uppercase\r\n          bLower[i] = bytes1(int(bStr[i]) - 32);\r\n        } else {\r\n          bLower[i] = bStr[i];\r\n        }\r\n      }\r\n      return string(bLower);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newa\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"v2\",\"type\":\"uint8\"},{\"name\":\"r2\",\"type\":\"bytes32\"},{\"name\":\"s2\",\"type\":\"bytes32\"}],\"name\":\"emergency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newinfo\",\"type\":\"string\"}],\"name\":\"changeInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"info\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userHasPattern\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Patterns\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"patternid\",\"type\":\"bytes32\"},{\"name\":\"newowner\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"string\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"transferPattern\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"patternid\",\"type\":\"bytes32\"},{\"name\":\"message\",\"type\":\"string\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"changeMessage\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"patternid\",\"type\":\"bytes32\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"verifyOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"patternid\",\"type\":\"bytes32\"},{\"name\":\"dataMixed\",\"type\":\"string\"},{\"name\":\"newowner\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"createPattern\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Pattern\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"message\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"patternid\",\"type\":\"bytes32\"}],\"name\":\"checkPatternExistance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LIMITED_42","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ec2b0324b08a2bbb3b10b3e2f625424e3af89aac08fa9f7fa324998af791870e"}]}