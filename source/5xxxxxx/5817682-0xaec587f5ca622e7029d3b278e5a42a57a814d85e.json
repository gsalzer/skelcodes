{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ninterface IAffiliateList {\r\n    /**\r\n     * @dev Sets the given address as an affiliate.\r\n     *      If the address is not currently an affiliate, startTimestamp is required\r\n     *      and endTimestamp is optional.\r\n     *      If the address is already registered as an affiliate, both values are optional.\r\n     * @param startTimestamp Timestamp when the address became/becomes an affiliate.\r\n     * @param endTimestamp Timestamp when the address will no longer be an affiliate.\r\n     */\r\n    function set(address addr, uint startTimestamp, uint endTimestamp) external;\r\n\r\n    /**\r\n     * @dev Retrieves the start and end timestamps for the given address.\r\n     *      It is sufficient to check the start value to determine if the address\r\n     *      is an affiliate (start will be greater than zero).\r\n     */\r\n    function get(address addr) external view returns (uint start, uint end);\r\n\r\n    /**\r\n     * @dev Returns true if the address is, was, or will be an affiliate at the given time.\r\n     */\r\n    function inListAsOf(address addr, uint time) external view returns (bool);\r\n}\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract IInvestorList {\r\n    string public constant ROLE_REGD = \"regd\";\r\n    string public constant ROLE_REGCF = \"regcf\";\r\n    string public constant ROLE_REGS = \"regs\";\r\n    string public constant ROLE_UNKNOWN = \"unknown\";\r\n\r\n    function inList(address addr) public view returns (bool);\r\n    function addAddress(address addr, string role) public;\r\n    function getRole(address addr) public view returns (string);\r\n    function hasRole(address addr, string role) public view returns (bool);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the 2-step process of changing ownership. The new owner\r\n     * must then call `acceptOwnership()`.\r\n     */\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Completes the process of transferring ownership to a new owner.\r\n     */\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n            newOwner = 0;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract AffiliateList is Ownable, IAffiliateList {\r\n    event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);\r\n    event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);\r\n\r\n    mapping (address => uint) public affiliateStart;\r\n    mapping (address => uint) public affiliateEnd;\r\n\r\n    function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {\r\n        require(addr != address(0));\r\n\r\n        uint existingStart = affiliateStart[addr];\r\n\r\n        if(existingStart == 0) {\r\n            // this is a new address\r\n\r\n            require(startTimestamp != 0);\r\n            affiliateStart[addr] = startTimestamp;\r\n\r\n            if(endTimestamp != 0) {\r\n                require(endTimestamp > startTimestamp);\r\n                affiliateEnd[addr] = endTimestamp;\r\n            }\r\n\r\n            emit AffiliateAdded(addr, startTimestamp, endTimestamp);\r\n        }\r\n        else {\r\n            // this address was previously registered\r\n\r\n            if(startTimestamp == 0) {\r\n                // don't update the start timestamp\r\n\r\n                if(endTimestamp == 0) {\r\n                    affiliateStart[addr] = 0;\r\n                    affiliateEnd[addr] = 0;\r\n                }\r\n                else {\r\n                    require(endTimestamp > existingStart);\r\n                }\r\n            }\r\n            else {\r\n                // update the start timestamp\r\n                affiliateStart[addr] = startTimestamp;\r\n\r\n                if(endTimestamp != 0) {\r\n                    require(endTimestamp > startTimestamp);\r\n                }\r\n            }\r\n            affiliateEnd[addr] = endTimestamp;\r\n\r\n            emit AffiliateUpdated(addr, startTimestamp, endTimestamp);\r\n        }\r\n    }\r\n\r\n    function get(address addr) public view returns (uint start, uint end) {\r\n        return (affiliateStart[addr], affiliateEnd[addr]);\r\n    }\r\n\r\n    function inListAsOf(address addr, uint time) public view returns (bool) {\r\n        uint start;\r\n        uint end;\r\n        (start, end) = get(addr);\r\n        if(start == 0) {\r\n            return false;\r\n        }\r\n        if(time < start) {\r\n            return false;\r\n        }\r\n        if(end != 0 && time >= end) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract InvestorList is Ownable, IInvestorList {\r\n    event AddressAdded(address addr, string role);\r\n    event AddressRemoved(address addr, string role);\r\n\r\n    mapping (address => string) internal investorList;\r\n\r\n    /**\r\n     * @dev Throws if called by any account that's not investorListed.\r\n     * @param role string\r\n     */\r\n    modifier validRole(string role) {\r\n        require(\r\n            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||\r\n            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||\r\n            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||\r\n            keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter to determine if address is in investorList.\r\n     * @param addr address\r\n     * @return true if the address was added to the investorList, false if the address was already in the investorList\r\n     */\r\n    function inList(address addr)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (bytes(investorList[addr]).length != 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for address role if address is in list.\r\n     * @param addr address\r\n     * @return string for address role\r\n     */\r\n    function getRole(address addr)\r\n        public\r\n        view\r\n        returns (string)\r\n    {\r\n        require(inList(addr));\r\n        return investorList[addr];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a boolean indicating if the given address is in the list\r\n     *      with the given role.\r\n     * @param addr address to check\r\n     * @param role role to check\r\n     * @ return boolean for whether the address is in the list with the role\r\n     */\r\n    function hasRole(address addr, string role)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));\r\n    }\r\n\r\n    /**\r\n     * @dev Add single address to the investorList.\r\n     * @param addr address\r\n     * @param role string\r\n     */\r\n    function addAddress(address addr, string role)\r\n        onlyOwner\r\n        validRole(role)\r\n        public\r\n    {\r\n        investorList[addr] = role;\r\n        emit AddressAdded(addr, role);\r\n    }\r\n\r\n    /**\r\n     * @dev Add multiple addresses to the investorList.\r\n     * @param addrs addresses\r\n     * @param role string\r\n     */\r\n    function addAddresses(address[] addrs, string role)\r\n        onlyOwner\r\n        validRole(role)\r\n        public\r\n    {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            addAddress(addrs[i], role);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Remove single address from the investorList.\r\n     * @param addr address\r\n     */\r\n    function removeAddress(address addr)\r\n        onlyOwner\r\n        public\r\n    {\r\n        // removeRole(addr, ROLE_WHITELISTED);\r\n        require(inList(addr));\r\n        string memory role = investorList[addr];\r\n        investorList[addr] = \"\";\r\n        emit AddressRemoved(addr, role);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove multiple addresses from the investorList.\r\n     * @param addrs addresses\r\n     */\r\n    function removeAddresses(address[] addrs)\r\n        onlyOwner\r\n        public\r\n    {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            if (inList(addrs[i])) {\r\n                removeAddress(addrs[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ISecurityController {\r\n    function balanceOf(address _a) public view returns (uint);\r\n    function totalSupply() public view returns (uint);\r\n\r\n    function isTransferAuthorized(address _from, address _to) public view returns (bool);\r\n    function setTransferAuthorized(address from, address to, uint expiry) public;\r\n\r\n    function transfer(address _from, address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint);\r\n    function approve(address _owner, address _spender, uint _value) public returns (bool success);\r\n    function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);\r\n    function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);\r\n\r\n    function burn(address _owner, uint _amount) public;\r\n    function ledgerTransfer(address from, address to, uint val) public;\r\n    function setLedger(address _ledger) public;\r\n    function setSale(address _sale) public;\r\n    function setToken(address _token) public;\r\n    function setAffiliateList(address _affiliateList) public;\r\n}\r\n\r\ncontract SecurityController is ISecurityController, Ownable {\r\n    ISecurityLedger public ledger;\r\n    ISecurityToken public token;\r\n    ISecuritySale public sale;\r\n    IInvestorList public investorList;\r\n    ITransferAuthorizations public transferAuthorizations;\r\n    IAffiliateList public affiliateList;\r\n\r\n    uint public lockoutPeriod = 10 * 60 * 60; // length in seconds of the lockout period\r\n\r\n    // restrict who can grant transfer authorizations\r\n    mapping(address => bool) public transferAuthPermission;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function setTransferAuthorized(address from, address to, uint expiry) public {\r\n        // Must be called from address in the transferAuthPermission mapping\r\n        require(transferAuthPermission[msg.sender]);\r\n\r\n        // don't allow 'from' to be zero\r\n        require(from != 0);\r\n\r\n        // verify expiry is in future, but not more than 30 days\r\n        if(expiry > 0) {\r\n            require(expiry > block.timestamp);\r\n            require(expiry <= (block.timestamp + 30 days));\r\n        }\r\n\r\n        transferAuthorizations.set(from, to, expiry);\r\n    }\r\n\r\n    // functions below this line are onlyOwner\r\n\r\n    function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {\r\n        lockoutPeriod = _lockoutPeriod;\r\n    }\r\n\r\n    function setToken(address _token) public onlyOwner {\r\n        token = ISecurityToken(_token);\r\n    }\r\n\r\n    function setLedger(address _ledger) public onlyOwner {\r\n        ledger = ISecurityLedger(_ledger);\r\n    }\r\n\r\n    function setSale(address _sale) public onlyOwner {\r\n        sale = ISecuritySale(_sale);\r\n    }\r\n\r\n    function setInvestorList(address _investorList) public onlyOwner {\r\n        investorList = IInvestorList(_investorList);\r\n    }\r\n\r\n    function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {\r\n        transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\r\n    }\r\n\r\n    function setAffiliateList(address _affiliateList) public onlyOwner {\r\n        affiliateList = IAffiliateList(_affiliateList);\r\n    }\r\n\r\n    function setDependencies(address _token, address _ledger, address _sale,\r\n        address _investorList, address _transferAuthorizations, address _affiliateList)\r\n        public onlyOwner\r\n    {\r\n        token = ISecurityToken(_token);\r\n        ledger = ISecurityLedger(_ledger);\r\n        sale = ISecuritySale(_sale);\r\n        investorList = IInvestorList(_investorList);\r\n        transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\r\n        affiliateList = IAffiliateList(_affiliateList);\r\n    }\r\n\r\n    function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {\r\n        require(agent != address(0));\r\n        transferAuthPermission[agent] = hasPermission;\r\n    }\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == address(token));\r\n        _;\r\n    }\r\n\r\n    modifier onlyLedger() {\r\n        require(msg.sender == address(ledger));\r\n        _;\r\n    }\r\n\r\n    // public functions\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return ledger.totalSupply();\r\n    }\r\n\r\n    function balanceOf(address _a) public view returns (uint) {\r\n        return ledger.balanceOf(_a);\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint) {\r\n        return ledger.allowance(_owner, _spender);\r\n    }\r\n\r\n    function isTransferAuthorized(address _from, address _to) public view returns (bool) {\r\n        // A `from` address could have both an allowance for the `to` address\r\n        // and a global allowance (to the zero address). We pick the maximum\r\n        // of the two.\r\n\r\n        uint expiry = transferAuthorizations.get(_from, _to);\r\n        uint globalExpiry = transferAuthorizations.get(_from, 0);\r\n        if(globalExpiry > expiry) {\r\n            expiry = globalExpiry;\r\n        }\r\n\r\n        return expiry > block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Determines whether the given transfer is possible. Returns multiple\r\n     *      boolean flags specifying how the transfer must occur.\r\n     *      This is kept public to provide for testing and subclasses overriding behavior.\r\n     * @param _from Address the tokens are being transferred from\r\n     * @param _to Address the tokens are being transferred to\r\n     * @param _value Number of tokens that would be transferred\r\n     * @param lockoutTime A point in time, specified in epoch time, that specifies\r\n     *                    the lockout period (typically 1 year before now).\r\n     * @return canTransfer Whether the transfer can occur at all.\r\n     * @return useLockoutTime Whether the lockoutTime should be used to determine which tokens to transfer.\r\n     * @return newTokensAreRestricted Whether the transferred tokens should be marked as restricted.\r\n     * @return preservePurchaseDate Whether the purchase date on the tokens should be preserved, or reset to 'now'.\r\n     */\r\n    function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)\r\n        public\r\n        returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {\r\n\r\n        // DEFAULT BEHAVIOR:\r\n        //\r\n        // If there exists a Transfer Agent authorization, allow transfer regardless\r\n        //\r\n        // All transfers from an affiliate must be authorized by Transfer Agent\r\n        //   - tokens become restricted\r\n        //\r\n        // From Reg S to Reg S: allowable, regardless of holding period\r\n        //\r\n        // otherwise must meet holding period\r\n\r\n        // presently this isn't used, so always setting to false to avoid warning\r\n        preservePurchaseDate = false;\r\n\r\n        bool transferIsAuthorized = isTransferAuthorized(_from, _to);\r\n\r\n        bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);\r\n        bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);\r\n\r\n        if(transferIsAuthorized) {\r\n            canTransfer = true;\r\n            if(fromIsAffiliate || toIsAffiliate) {\r\n                newTokensAreRestricted = true;\r\n            }\r\n            // useLockoutTime will remain false\r\n            // preservePurchaseDate will remain false\r\n        }\r\n        else if(!fromIsAffiliate) {\r\n            // see if both are Reg S\r\n            if(investorList.hasRole(_from, investorList.ROLE_REGS())\r\n                && investorList.hasRole(_to, investorList.ROLE_REGS())) {\r\n                canTransfer = true;\r\n                // newTokensAreRestricted will remain false\r\n                // useLockoutTime will remain false\r\n                // preservePurchaseDate will remain false\r\n            }\r\n            else {\r\n                if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {\r\n                    canTransfer = true;\r\n                    useLockoutTime = true;\r\n                    // newTokensAreRestricted will remain false\r\n                    // preservePurchaseDate will remain false\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // functions below this line are onlyLedger\r\n\r\n    // let the ledger send transfer events (the most obvious case\r\n    // is when we mint directly to the ledger and need the Transfer()\r\n    // events to appear in the token)\r\n    function ledgerTransfer(address from, address to, uint val) public onlyLedger {\r\n        token.controllerTransfer(from, to, val);\r\n    }\r\n\r\n    // functions below this line are onlyToken\r\n\r\n    function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\r\n        uint lockoutTime = block.timestamp - lockoutPeriod;\r\n        bool canTransfer;\r\n        bool useLockoutTime;\r\n        bool newTokensAreRestricted;\r\n        bool preservePurchaseDate;\r\n        (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\r\n            = checkTransfer(_from, _to, _value, lockoutTime);\r\n\r\n        if(!canTransfer) {\r\n            return false;\r\n        }\r\n\r\n        uint overrideLockoutTime = lockoutTime;\r\n        if(!useLockoutTime) {\r\n            overrideLockoutTime = 0;\r\n        }\r\n\r\n        return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\r\n    }\r\n\r\n    function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\r\n        uint lockoutTime = block.timestamp - lockoutPeriod;\r\n        bool canTransfer;\r\n        bool useLockoutTime;\r\n        bool newTokensAreRestricted;\r\n        bool preservePurchaseDate;\r\n        (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\r\n            = checkTransfer(_from, _to, _value, lockoutTime);\r\n\r\n        if(!canTransfer) {\r\n            return false;\r\n        }\r\n\r\n        uint overrideLockoutTime = lockoutTime;\r\n        if(!useLockoutTime) {\r\n            overrideLockoutTime = 0;\r\n        }\r\n\r\n        return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\r\n    }\r\n\r\n    function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {\r\n        return ledger.approve(_owner, _spender, _value);\r\n    }\r\n\r\n    function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {\r\n        return ledger.increaseApproval(_owner, _spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {\r\n        return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\r\n    }\r\n\r\n    function burn(address _owner, uint _amount) public onlyToken {\r\n        ledger.burn(_owner, _amount);\r\n    }\r\n}\r\n\r\ninterface ISecurityLedger {\r\n    function balanceOf(address _a) external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);\r\n    function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\r\n    function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint);\r\n    function approve(address _owner, address _spender, uint _value) external returns (bool success);\r\n    function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);\r\n    function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);\r\n\r\n    function burn(address _owner, uint _amount) external;\r\n    function setController(address _controller) external;\r\n}\r\n\r\ncontract SecurityLedger is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct TokenLot {\r\n        uint amount;\r\n        uint purchaseDate;\r\n        bool restricted;\r\n    }\r\n    mapping(address => TokenLot[]) public tokenLotsOf;\r\n\r\n    SecurityController public controller;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    uint public totalSupply;\r\n    uint public mintingNonce;\r\n    bool public mintingStopped;\r\n\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    // functions below this line are onlyOwner\r\n\r\n    function setController(address _controller) public onlyOwner {\r\n        controller = SecurityController(_controller);\r\n    }\r\n\r\n    function stopMinting() public onlyOwner {\r\n        mintingStopped = true;\r\n    }\r\n\r\n    //TODO: not sure if this function should stay long term\r\n    function mint(address addr, uint value, uint timestamp) public onlyOwner {\r\n        require(!mintingStopped);\r\n\r\n        uint time = timestamp;\r\n        if(time == 0) {\r\n            time = block.timestamp;\r\n        }\r\n\r\n        balanceOf[addr] = balanceOf[addr].add(value);\r\n        tokenLotsOf[addr].push(TokenLot(value, time, true));\r\n        controller.ledgerTransfer(0, addr, value);\r\n        totalSupply = totalSupply.add(value);\r\n    }\r\n\r\n    function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\r\n        require(!mintingStopped);\r\n        if (nonce != mintingNonce) return;\r\n        mintingNonce = mintingNonce.add(1);\r\n        uint256 lomask = (1 << 96) - 1;\r\n        uint created = 0;\r\n\r\n        uint time = timestamp;\r\n        if(time == 0) {\r\n            time = block.timestamp;\r\n        }\r\n\r\n        for (uint i = 0; i < bits.length; i++) {\r\n            address addr = address(bits[i]>>96);\r\n            uint value = bits[i] & lomask;\r\n            balanceOf[addr] = balanceOf[addr].add(value);\r\n            tokenLotsOf[addr].push(TokenLot(value, time, true));\r\n            controller.ledgerTransfer(0, addr, value);\r\n            created = created.add(value);\r\n        }\r\n        totalSupply = totalSupply.add(created);\r\n    }\r\n\r\n    // send received tokens to anyone\r\n    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\r\n        ERC20Basic t = ERC20Basic(token);\r\n        require(t.transfer(sender, amount));\r\n    }\r\n\r\n    // functions below this line are onlyController\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == address(controller));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Walks through the list of TokenLots for the given address, attempting to find\r\n     *      `amount` tokens that can be transferred. It uses the given `lockoutTime` if\r\n     *      the supplied value is not zero. If `removeTokens` is true the tokens are\r\n     *      actually removed from the address, otherwise this function acts as a dry run.\r\n     *      The value returned is the actual number of transferrable tokens found, up to\r\n     *      the maximum value of `amount`.\r\n     */\r\n    function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,\r\n        bool newTokensAreRestricted, bool preservePurchaseDate)\r\n        internal returns (uint numTransferrableTokens)\r\n    {\r\n        TokenLot[] storage fromTokenLots = tokenLotsOf[from];\r\n        for(uint i=0; i<fromTokenLots.length; i++) {\r\n            TokenLot storage lot = fromTokenLots[i];\r\n            uint lotAmount = lot.amount;\r\n\r\n            // skip if there are no available tokens\r\n            if(lotAmount == 0) {\r\n                continue;\r\n            }\r\n\r\n            if(lockoutTime > 0) {\r\n                // skip if it is more recent than the lockout period AND it's restricted\r\n                if(lot.restricted && lot.purchaseDate > lockoutTime) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            uint remaining = amount.sub(numTransferrableTokens);\r\n\r\n            if(lotAmount >= remaining) {\r\n                numTransferrableTokens = numTransferrableTokens.add(remaining);\r\n                if(removeTokens) {\r\n                    lot.amount = lotAmount.sub(remaining);\r\n                    if(to != address(0)) {\r\n                        if(preservePurchaseDate) {\r\n                            tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));\r\n                        }\r\n                        else {\r\n                            tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n            // If we're here, then amount in this lot is not yet enough.\r\n            // Take all of it.\r\n            numTransferrableTokens = numTransferrableTokens.add(lotAmount);\r\n            if(removeTokens) {\r\n                lot.amount = 0;\r\n                if(to != address(0)) {\r\n                    if(preservePurchaseDate) {\r\n                        tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));\r\n                    }\r\n                    else {\r\n                        tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {\r\n        return walkTokenLots(from, to, amount, lockoutTime, false, false, false);\r\n    }\r\n\r\n    function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\r\n        if (balanceOf[_from] < _value) return false;\r\n\r\n        // ensure number of tokens removed from TokenLots is as expected\r\n        uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\r\n        require(tokensTransferred == _value);\r\n\r\n        // adjust balances\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\r\n        if (balanceOf[_from] < _value) return false;\r\n\r\n        // ensure there is enough allowance\r\n        uint allowed = allowance[_from][_spender];\r\n        if (allowed < _value) return false;\r\n\r\n        // ensure number of tokens removed from TokenLots is as expected\r\n        uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\r\n        require(tokensTransferred == _value);\r\n\r\n        // adjust balances\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n\r\n        allowance[_from][_spender] = allowed.sub(_value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {\r\n        // require user to set to zero before resetting to nonzero\r\n        if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\r\n            return false;\r\n        }\r\n\r\n        allowance[_owner][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {\r\n        uint oldValue = allowance[_owner][_spender];\r\n        allowance[_owner][_spender] = oldValue.add(_addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {\r\n        uint oldValue = allowance[_owner][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowance[_owner][_spender] = 0;\r\n        } else {\r\n            allowance[_owner][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function burn(address _owner, uint _amount) public onlyController {\r\n        require(balanceOf[_owner] >= _amount);\r\n\r\n        balanceOf[_owner] = balanceOf[_owner].sub(_amount);\r\n\r\n        // remove tokens from TokenLots\r\n        // (i.e. transfer them to 0)\r\n        walkTokenLots(_owner, address(0), _amount, 0, true, false, false);\r\n\r\n        totalSupply = totalSupply.sub(_amount);\r\n    }\r\n}\r\n\r\ninterface ISecuritySale {\r\n    function setLive(bool newLiveness) external;\r\n    function setInvestorList(address _investorList) external;\r\n}\r\n\r\ncontract SecuritySale is Ownable {\r\n\r\n    bool public live;        // sale is live right now\r\n    IInvestorList public investorList; // approved contributors\r\n\r\n    event SaleLive(bool liveness);\r\n    event EtherIn(address from, uint amount);\r\n    event StartSale();\r\n    event EndSale();\r\n\r\n    constructor() public {\r\n        live = false;\r\n    }\r\n\r\n    function setInvestorList(address _investorList) public onlyOwner {\r\n        investorList = IInvestorList(_investorList);\r\n    }\r\n\r\n    function () public payable {\r\n        require(live);\r\n        require(investorList.inList(msg.sender));\r\n        emit EtherIn(msg.sender, msg.value);\r\n    }\r\n\r\n    // set liveness\r\n    function setLive(bool newLiveness) public onlyOwner {\r\n        if(live && !newLiveness) {\r\n            live = false;\r\n            emit EndSale();\r\n        }\r\n        else if(!live && newLiveness) {\r\n            live = true;\r\n            emit StartSale();\r\n        }\r\n    }\r\n\r\n    // withdraw all of the Ether to owner\r\n    function withdraw() public onlyOwner {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    // withdraw some of the Ether to owner\r\n    function withdrawSome(uint value) public onlyOwner {\r\n        require(value <= address(this).balance);\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    // withdraw tokens to owner\r\n    function withdrawTokens(address token) public onlyOwner {\r\n        ERC20Basic t = ERC20Basic(token);\r\n        require(t.transfer(msg.sender, t.balanceOf(this)));\r\n    }\r\n\r\n    // send received tokens to anyone\r\n    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\r\n        ERC20Basic t = ERC20Basic(token);\r\n        require(t.transfer(sender, amount));\r\n    }\r\n}\r\n\r\ninterface ISecurityToken {\r\n    function balanceOf(address addr) external view returns(uint);\r\n    function transfer(address to, uint amount) external returns(bool);\r\n    function controllerTransfer(address _from, address _to, uint _value) external;\r\n}\r\n\r\ncontract SecurityToken is Ownable{\r\n    using SafeMath for uint256;\r\n\r\n    ISecurityController public controller;\r\n    // these public fields are set once in constructor\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    constructor(string _name, string  _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    // functions below this line are onlyOwner\r\n\r\n    function setName(string _name) public onlyOwner {\r\n        name = _name;\r\n    }\r\n\r\n    function setSymbol(string _symbol) public onlyOwner {\r\n        symbol = _symbol;\r\n    }\r\n    \r\n    function setController(address _c) public onlyOwner {\r\n        controller = ISecurityController(_c);\r\n    }\r\n\r\n    // send received tokens to anyone\r\n    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\r\n        ERC20Basic t = ERC20Basic(token);\r\n        require(t.transfer(sender, amount));\r\n    }\r\n\r\n    // functions below this line are public\r\n\r\n    function balanceOf(address a) public view returns (uint) {\r\n        return controller.balanceOf(a);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return controller.totalSupply();\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint) {\r\n        return controller.allowance(_owner, _spender);\r\n    }\r\n\r\n    function burn(uint _amount) public {\r\n        controller.burn(msg.sender, _amount);\r\n        emit Transfer(msg.sender, 0x0, _amount);\r\n    }\r\n\r\n    // functions below this line are onlyPayloadSize\r\n\r\n    // TODO: investigate this security optimization more\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length >= numwords.mul(32).add(4));\r\n        _;\r\n    }\r\n\r\n    function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {\r\n        return controller.isTransferAuthorized(_from, _to);\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {\r\n        if (controller.transfer(msg.sender, _to, _value)) {\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {\r\n        if (controller.transferFrom(msg.sender, _from, _to, _value)) {\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {\r\n        if (controller.approve(msg.sender, _spender, _value)) {\r\n            emit Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {\r\n        if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {\r\n            uint newval = controller.allowance(msg.sender, _spender);\r\n            emit Approval(msg.sender, _spender, newval);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {\r\n        if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {\r\n            uint newval = controller.allowance(msg.sender, _spender);\r\n            emit Approval(msg.sender, _spender, newval);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // functions below this line are onlyController\r\n\r\n    modifier onlyController() {\r\n        assert(msg.sender == address(controller));\r\n        _;\r\n    }\r\n\r\n    function controllerTransfer(address _from, address _to, uint _value) public onlyController {\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function controllerApprove(address _owner, address _spender, uint _value) public onlyController {\r\n        emit Approval(_owner, _spender, _value);\r\n    }\r\n}\r\n\r\ninterface ITransferAuthorizations {\r\n    function setController(address _controller) external;\r\n    function get(address from, address to) external view returns (uint);\r\n    function set(address from, address to, uint expiry) external;\r\n}\r\n\r\ncontract TransferAuthorizations is Ownable, ITransferAuthorizations {\r\n\r\n    /**\r\n     * @dev The first key is the `from` address. The second key is the `to` address.\r\n     *      The uint value of the mapping is the epoch time (seconds since 1/1/1970)\r\n     *      of the expiration of the approved transfer.\r\n     */\r\n    mapping(address => mapping(address => uint)) public authorizations;\r\n\r\n    /**\r\n     * @dev This controller is the only contract allowed to call the `set` function.\r\n     */\r\n    address public controller;\r\n\r\n    event TransferAuthorizationSet(address from, address to, uint expiry);\r\n\r\n    function setController(address _controller) public onlyOwner {\r\n        controller = _controller;\r\n    }\r\n\r\n    modifier onlyController() {\r\n        assert(msg.sender == controller);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the authorization for a transfer to occur between the 'from' and\r\n     *      'to' addresses, to expire at the 'expiry' time.\r\n     * @param from The address from which funds would be transferred.\r\n     * @param to The address to which funds would be transferred. This can be\r\n     *           the zero address to allow transfers to any address.\r\n     * @param expiry The epoch time (seconds since 1/1/1970) at which point this\r\n     *               authorization will no longer be valid.\r\n     */\r\n    function set(address from, address to, uint expiry) public onlyController {\r\n        require(from != 0);\r\n        authorizations[from][to] = expiry;\r\n        emit TransferAuthorizationSet(from, to, expiry);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the expiration time for the transfer authorization between the\r\n     *      given addresses. Returns 0 if not allowed.\r\n     * @param from The address from which funds would be transferred.\r\n     * @param to The address to which funds would be transferred. This can be\r\n     *           the zero address to allow transfers to any address.\r\n     */\r\n    function get(address from, address to) public view returns (uint) {\r\n        return authorizations[from][to];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendReceivedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"controllerApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_c\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"controllerTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"isTransferAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SecurityToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c50757a7a6c6520546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003707a7a0000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://a8d5cd62310723b4a6a60d9fef7c15dd9581034961037d5549dd3b43cac6e77c"}]}