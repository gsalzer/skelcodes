{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * SpaceWar\r\n * ETH Idle Game\r\n * spacewar.etherfun.net\r\n */\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n}\r\n\r\nlibrary NumericSequence\r\n{\r\n    using SafeMath for uint256;\r\n    function sumOfN(uint256 basePrice, uint256 pricePerLevel, uint256 owned, uint256 count) internal pure returns (uint256 price)\r\n    {\r\n        require(count > 0);\r\n\r\n        price = 0;\r\n        price += SafeMath.mul((basePrice + pricePerLevel * owned), count);\r\n        price += pricePerLevel * (count.mul((count-1))) / 2;\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------\r\ncontract SpaceWar  {\r\n    using NumericSequence for uint;\r\n    using SafeMath for uint;\r\n\r\n    struct MinerData\r\n    {\r\n        uint256[9]   spaces; // space types and their upgrades\r\n        uint8[3]     hasUpgrade;\r\n        uint256      money;\r\n        uint256      lastUpdateTime;\r\n        uint256      premamentMineBonusPct;\r\n        uint256      unclaimedPot;\r\n        uint256      lastPotClaimIndex;\r\n    }\r\n\r\n    struct SpaceData\r\n    {\r\n        uint256 basePrice;\r\n        uint256 baseOutput;\r\n        uint256 pricePerLevel;\r\n        uint256 priceInETH;\r\n        uint256 limit;\r\n    }\r\n\r\n    struct BoostData\r\n    {\r\n        uint256 percentBonus;\r\n        uint256 priceInWEI;\r\n    }\r\n\r\n    struct PVPData\r\n    {\r\n        uint256[6] troops;\r\n        uint256    immunityTime;\r\n        uint256    exhaustTime;\r\n    }\r\n\r\n    struct TroopData\r\n    {\r\n        uint256 attackPower;\r\n        uint256 defensePower;\r\n        uint256 priceGold;\r\n        uint256 priceETH;\r\n    }\r\n\r\n    uint8 private constant NUMBER_OF_RIG_TYPES = 9;\r\n    SpaceData[9]  private spaceData;\r\n\r\n    uint8 private constant NUMBER_OF_UPGRADES = 3;\r\n    BoostData[3] private boostData;\r\n\r\n    uint8 private constant NUMBER_OF_TROOPS = 6;\r\n    uint8 private constant ATTACKER_START_IDX = 0;\r\n    uint8 private constant ATTACKER_END_IDX = 3;\r\n    uint8 private constant DEFENDER_START_IDX = 3;\r\n    uint8 private constant DEFENDER_END_IDX = 6;\r\n    TroopData[6] private troopData;\r\n\r\n    // honey pot variables\r\n    uint256 private honeyPotAmount;\r\n    uint256 private honeyPotSharePct; // 90%\r\n    uint256 private jackPot;\r\n    uint256 private devFund;\r\n    uint256 private nextPotDistributionTime;\r\n    mapping(address => mapping(uint256 => uint256)) private minerICOPerCycle;\r\n    uint256[] private honeyPotPerCycle;\r\n    uint256[] private globalICOPerCycle;\r\n    uint256 private cycleCount;\r\n\r\n    //booster info\r\n    uint256 private constant NUMBER_OF_BOOSTERS = 5;\r\n    uint256 private boosterIndex;\r\n    uint256 private nextBoosterPrice;\r\n    address[5] private boosterHolders;\r\n\r\n    mapping(address => MinerData) private miners;\r\n    mapping(address => PVPData)   private pvpMap;\r\n    mapping(uint256 => address)   private indexes;\r\n    uint256 private topindex;\r\n\r\n    address private owner;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function SpaceWar() public {\r\n        owner = msg.sender;\r\n\r\n        //                   price,           prod.     upgrade,        priceETH, limit\r\n        spaceData[0] = SpaceData(500,             1,        5,               0,          999);\r\n        spaceData[1] = SpaceData(50000,           10,       500,             0,          999);\r\n        spaceData[2] = SpaceData(5000000,         100,      50000,           0,          999);\r\n        spaceData[3] = SpaceData(80000000,        1000,     800000,          0,          999);\r\n        spaceData[4] = SpaceData(500000000,       20000,    5000000,         0.01 ether, 999);\r\n        spaceData[5] = SpaceData(10000000000,     100000,   100000000,       0,          999);\r\n        spaceData[6] = SpaceData(100000000000,    1000000,  1000000000,      0,          999);\r\n        spaceData[7] = SpaceData(1000000000000,   50000000, 10000000000,     0.1 ether,  999);\r\n        spaceData[8] = SpaceData(10000000000000,  100000000,100000000000,    0,          999);\r\n\r\n        boostData[0] = BoostData(30,  0.01 ether);\r\n        boostData[1] = BoostData(50,  0.1 ether);\r\n        boostData[2] = BoostData(100, 1 ether);\r\n\r\n        topindex = 0;\r\n        honeyPotAmount = 0;\r\n        devFund = 0;\r\n        jackPot = 0;\r\n        nextPotDistributionTime = block.timestamp;\r\n        honeyPotSharePct = 90;\r\n\r\n        // has to be set to a value\r\n        boosterHolders[0] = owner;\r\n        boosterHolders[1] = owner;\r\n        boosterHolders[2] = owner;\r\n        boosterHolders[3] = owner;\r\n        boosterHolders[4] = owner;\r\n\r\n        boosterIndex = 0;\r\n        nextBoosterPrice = 0.1 ether;\r\n\r\n        //pvp\r\n        troopData[0] = TroopData(10,     0,      100000,   0);\r\n        troopData[1] = TroopData(1000,   0,      80000000, 0);\r\n        troopData[2] = TroopData(100000, 0,      1000000000,   0.01 ether);\r\n        troopData[3] = TroopData(0,      15,     100000,   0);\r\n        troopData[4] = TroopData(0,      1500,   80000000, 0);\r\n        troopData[5] = TroopData(0,      150000, 1000000000,   0.01 ether);\r\n\r\n        honeyPotPerCycle.push(0);\r\n        globalICOPerCycle.push(1);\r\n        cycleCount = 0;\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Data access functions\r\n    //--------------------------------------------------------------------------\r\n    function GetMinerData(address minerAddr) public constant returns\r\n        (uint256 money, uint256 lastupdate, uint256 prodPerSec,\r\n         uint256[9] spaces, uint[3] upgrades, uint256 unclaimedPot, bool hasBooster, uint256 unconfirmedMoney)\r\n    {\r\n        uint8 i = 0;\r\n\r\n        money = miners[minerAddr].money;\r\n        lastupdate = miners[minerAddr].lastUpdateTime;\r\n        prodPerSec = GetProductionPerSecond(minerAddr);\r\n\r\n        for(i = 0; i < NUMBER_OF_RIG_TYPES; ++i)\r\n        {\r\n            spaces[i] = miners[minerAddr].spaces[i];\r\n        }\r\n\r\n        for(i = 0; i < NUMBER_OF_UPGRADES; ++i)\r\n        {\r\n            upgrades[i] = miners[minerAddr].hasUpgrade[i];\r\n        }\r\n\r\n        unclaimedPot = miners[minerAddr].unclaimedPot;\r\n        hasBooster = HasBooster(minerAddr);\r\n\r\n        unconfirmedMoney = money + (prodPerSec * (now - lastupdate));\r\n    }\r\n\r\n    function GetTotalMinerCount() public constant returns (uint256 count)\r\n    {\r\n        count = topindex;\r\n    }\r\n\r\n    function GetMinerAt(uint256 idx) public constant returns (address minerAddr)\r\n    {\r\n        require(idx < topindex);\r\n        minerAddr = indexes[idx];\r\n    }\r\n\r\n    function GetPotInfo() public constant returns (uint256 _honeyPotAmount, uint256 _devFunds, uint256 _jackPot, uint256 _nextDistributionTime)\r\n    {\r\n        _honeyPotAmount = honeyPotAmount;\r\n        _devFunds = devFund;\r\n        _jackPot = jackPot;\r\n        _nextDistributionTime = nextPotDistributionTime;\r\n    }\r\n\r\n    function GetProductionPerSecond(address minerAddr) public constant returns (uint256 personalProduction)\r\n    {\r\n        MinerData storage m = miners[minerAddr];\r\n\r\n        personalProduction = 0;\r\n        uint256 productionSpeed = 100 + m.premamentMineBonusPct;\r\n\r\n        if(HasBooster(minerAddr)) // 100% bonus\r\n            productionSpeed += 100;\r\n\r\n        for(uint8 j = 0; j < NUMBER_OF_RIG_TYPES; ++j)\r\n        {\r\n            personalProduction += m.spaces[j] * spaceData[j].baseOutput;\r\n        }\r\n\r\n        personalProduction = personalProduction * productionSpeed / 100;\r\n    }\r\n\r\n    function GetGlobalProduction() public constant returns (uint256 globalMoney, uint256 globalHashRate)\r\n    {\r\n        globalMoney = 0;\r\n        globalHashRate = 0;\r\n        uint i = 0;\r\n        for(i = 0; i < topindex; ++i)\r\n        {\r\n            MinerData storage m = miners[indexes[i]];\r\n            globalMoney += m.money;\r\n            globalHashRate += GetProductionPerSecond(indexes[i]);\r\n        }\r\n    }\r\n\r\n    function GetBoosterData() public constant returns (address[5] _boosterHolders, uint256 currentPrice, uint256 currentIndex)\r\n    {\r\n        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\r\n        {\r\n            _boosterHolders[i] = boosterHolders[i];\r\n        }\r\n        currentPrice = nextBoosterPrice;\r\n        currentIndex = boosterIndex;\r\n    }\r\n\r\n    function HasBooster(address addr) public constant returns (bool hasBoost)\r\n    {\r\n        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\r\n        {\r\n           if(boosterHolders[i] == addr)\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function GetPVPData(address addr) public constant returns (uint256 attackpower, uint256 defensepower, uint256 immunityTime, uint256 exhaustTime,\r\n    uint256[6] troops)\r\n    {\r\n        PVPData storage a = pvpMap[addr];\r\n\r\n        immunityTime = a.immunityTime;\r\n        exhaustTime = a.exhaustTime;\r\n\r\n        attackpower = 0;\r\n        defensepower = 0;\r\n        for(uint i = 0; i < NUMBER_OF_TROOPS; ++i)\r\n        {\r\n            attackpower  += a.troops[i] * troopData[i].attackPower;\r\n            defensepower += a.troops[i] * troopData[i].defensePower;\r\n\r\n            troops[i] = a.troops[i];\r\n        }\r\n    }\r\n\r\n    function GetCurrentICOCycle() public constant returns (uint256)\r\n    {\r\n        return cycleCount;\r\n    }\r\n\r\n    function GetICOData(uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOPot)\r\n    {\r\n        require(idx <= cycleCount);\r\n        ICOFund = globalICOPerCycle[idx];\r\n        if(idx < cycleCount)\r\n        {\r\n            ICOPot = honeyPotPerCycle[idx];\r\n        } else\r\n        {\r\n            ICOPot =  honeyPotAmount / 10; // actual day estimate\r\n        }\r\n    }\r\n\r\n    function GetMinerICOData(address miner, uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOShare, uint256 lastClaimIndex)\r\n    {\r\n        require(idx <= cycleCount);\r\n        ICOFund = minerICOPerCycle[miner][idx];\r\n        if(idx < cycleCount)\r\n        {\r\n            ICOShare = (honeyPotPerCycle[idx] * minerICOPerCycle[miner][idx]) / globalICOPerCycle[idx];\r\n        } else\r\n        {\r\n            ICOShare = (honeyPotAmount / 10) * minerICOPerCycle[miner][idx] / globalICOPerCycle[idx];\r\n        }\r\n        lastClaimIndex = miners[miner].lastPotClaimIndex;\r\n    }\r\n\r\n    function GetMinerUnclaimedICOShare(address miner) public constant returns (uint256 unclaimedPot)\r\n    {\r\n        MinerData storage m = miners[miner];\r\n\r\n        require(m.lastUpdateTime != 0);\r\n        require(m.lastPotClaimIndex < cycleCount);\r\n\r\n        uint256 i = m.lastPotClaimIndex;\r\n        uint256 limit = cycleCount;\r\n\r\n        if((limit - i) > 30) // more than 30 iterations(days) afk\r\n            limit = i + 30;\r\n\r\n        unclaimedPot = 0;\r\n        for(; i < cycleCount; ++i)\r\n        {\r\n            if(minerICOPerCycle[miner][i] > 0)\r\n                unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[miner][i]) / globalICOPerCycle[i];\r\n        }\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // SpaceWars game handler functions\r\n    // -------------------------------------------------------------------------\r\n    function StartNewMiner() external\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime == 0);\r\n\r\n        miners[msg.sender].lastUpdateTime = block.timestamp;\r\n        miners[msg.sender].money = 0;\r\n        miners[msg.sender].spaces[0] = 1;\r\n        miners[msg.sender].unclaimedPot = 0;\r\n        miners[msg.sender].lastPotClaimIndex = cycleCount;\r\n\r\n        pvpMap[msg.sender].immunityTime = block.timestamp + 14400;\r\n        pvpMap[msg.sender].exhaustTime  = block.timestamp;\r\n\r\n        indexes[topindex] = msg.sender;\r\n        ++topindex;\r\n    }\r\n\r\n    function UpgradeSpace(uint8 spaceIdx, uint16 count) external\r\n    {\r\n        require(spaceIdx < NUMBER_OF_RIG_TYPES);\r\n        require(count > 0);\r\n        require(count <= 999);\r\n        require(spaceData[spaceIdx].priceInETH == 0);\r\n        MinerData storage m = miners[msg.sender];\r\n\r\n        require(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count));\r\n\r\n        UpdateMoney();\r\n\r\n        // the base of geometrical sequence\r\n        uint256 price = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice, spaceData[spaceIdx].pricePerLevel, m.spaces[spaceIdx], count);\r\n\r\n        require(m.money >= price);\r\n\r\n        m.spaces[spaceIdx] = m.spaces[spaceIdx] + count;\r\n\r\n        if(m.spaces[spaceIdx] > spaceData[spaceIdx].limit)\r\n            m.spaces[spaceIdx] = spaceData[spaceIdx].limit;\r\n\r\n        m.money -= price;\r\n    }\r\n\r\n    function UpgradeSpaceETH(uint8 spaceIdx, uint256 count) external payable\r\n    {\r\n        require(spaceIdx < NUMBER_OF_RIG_TYPES);\r\n        require(count > 0);\r\n        require(count <= 999);\r\n        require(spaceData[spaceIdx].priceInETH > 0);\r\n\r\n        MinerData storage m = miners[msg.sender];\r\n\r\n        require(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count));\r\n\r\n        uint256 price = (spaceData[spaceIdx].priceInETH).mul(count);\r\n\r\n        uint256 priceCoin = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice, spaceData[spaceIdx].pricePerLevel, m.spaces[spaceIdx], count);\r\n\r\n        UpdateMoney();\r\n        require(msg.value >= price);\r\n        require(m.money >= priceCoin);\r\n\r\n        BuyHandler(msg.value);\r\n\r\n        m.spaces[spaceIdx] = m.spaces[spaceIdx] + count;\r\n\r\n        if(m.spaces[spaceIdx] > spaceData[spaceIdx].limit)\r\n            m.spaces[spaceIdx] = spaceData[spaceIdx].limit;\r\n\r\n        m.money -= priceCoin;\r\n    }\r\n\r\n    function UpdateMoney() private\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(block.timestamp >= miners[msg.sender].lastUpdateTime);\r\n\r\n        MinerData storage m = miners[msg.sender];\r\n        uint256 diff = block.timestamp - m.lastUpdateTime;\r\n        uint256 revenue = GetProductionPerSecond(msg.sender);\r\n\r\n        m.lastUpdateTime = block.timestamp;\r\n        if(revenue > 0)\r\n        {\r\n            revenue *= diff;\r\n\r\n            m.money += revenue;\r\n        }\r\n    }\r\n\r\n    function UpdateMoneyAt(address addr) private\r\n    {\r\n        require(miners[addr].lastUpdateTime != 0);\r\n        require(block.timestamp >= miners[addr].lastUpdateTime);\r\n\r\n        MinerData storage m = miners[addr];\r\n        uint256 diff = block.timestamp - m.lastUpdateTime;\r\n        uint256 revenue = GetProductionPerSecond(addr);\r\n\r\n        m.lastUpdateTime = block.timestamp;\r\n        if(revenue > 0)\r\n        {\r\n            revenue *= diff;\r\n\r\n            m.money += revenue;\r\n        }\r\n    }\r\n\r\n    function BuyUpgrade(uint256 idx) external payable\r\n    {\r\n        require(idx < NUMBER_OF_UPGRADES);\r\n        require(msg.value >= boostData[idx].priceInWEI);\r\n        require(miners[msg.sender].hasUpgrade[idx] == 0);\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n\r\n        BuyHandler(msg.value);\r\n\r\n        UpdateMoney();\r\n\r\n        miners[msg.sender].hasUpgrade[idx] = 1;\r\n        miners[msg.sender].premamentMineBonusPct +=  boostData[idx].percentBonus;\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // BOOSTER handlers\r\n    //--------------------------------------------------------------------------\r\n    function BuyBooster() external payable\r\n    {\r\n        require(msg.value >= nextBoosterPrice);\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n\r\n        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\r\n            if(boosterHolders[i] == msg.sender)\r\n                revert();\r\n\r\n        address beneficiary = boosterHolders[boosterIndex];\r\n\r\n        MinerData storage m = miners[beneficiary];\r\n\r\n        // 20% interest after 5 buys\r\n        m.unclaimedPot += (msg.value * 9403) / 10000;\r\n\r\n        // distribute the rest\r\n        honeyPotAmount += (msg.value * 597) / 20000;\r\n        devFund += (msg.value * 597) / 20000;\r\n\r\n        // increase price by 5%\r\n        nextBoosterPrice += nextBoosterPrice / 20;\r\n\r\n        UpdateMoney();\r\n        UpdateMoneyAt(beneficiary);\r\n\r\n        // transfer ownership\r\n        boosterHolders[boosterIndex] = msg.sender;\r\n\r\n        // increase booster index\r\n        boosterIndex += 1;\r\n        if(boosterIndex >= 5)\r\n            boosterIndex = 0;\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // PVP handler\r\n    //--------------------------------------------------------------------------\r\n    // 0 for attacker 1 for defender\r\n    function BuyTroop(uint256 idx, uint256 count) external payable\r\n    {\r\n        require(idx < NUMBER_OF_TROOPS);\r\n        require(count > 0);\r\n        require(count <= 1000);\r\n\r\n        PVPData storage pvp = pvpMap[msg.sender];\r\n        MinerData storage m = miners[msg.sender];\r\n\r\n        uint256 owned = pvp.troops[idx];\r\n\r\n        uint256 priceGold = NumericSequence.sumOfN(troopData[idx].priceGold, troopData[idx].priceGold / 100, owned, count);\r\n        uint256 priceETH = (troopData[idx].priceETH).mul(count);\r\n\r\n        UpdateMoney();\r\n\r\n        require(m.money >= priceGold);\r\n        require(msg.value >= priceETH);\r\n\r\n        if(priceGold > 0)\r\n            m.money -= priceGold;\r\n\r\n        if(msg.value > 0)\r\n            BuyHandler(msg.value);\r\n\r\n        pvp.troops[idx] += count;\r\n    }\r\n\r\n    function Attack(address defenderAddr) external\r\n    {\r\n        require(msg.sender != defenderAddr);\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(miners[defenderAddr].lastUpdateTime != 0);\r\n\r\n        PVPData storage attacker = pvpMap[msg.sender];\r\n        PVPData storage defender = pvpMap[defenderAddr];\r\n        uint i = 0;\r\n        uint256 count = 0;\r\n\r\n        require(block.timestamp > attacker.exhaustTime);\r\n        require(block.timestamp > defender.immunityTime);\r\n\r\n        // the aggressor loses immunity\r\n        if(attacker.immunityTime > block.timestamp)\r\n            attacker.immunityTime = block.timestamp - 1;\r\n\r\n        attacker.exhaustTime = block.timestamp + 3600;\r\n\r\n        uint256 attackpower = 0;\r\n        uint256 defensepower = 0;\r\n        for(i = 0; i < ATTACKER_END_IDX; ++i)\r\n        {\r\n            attackpower  += attacker.troops[i] * troopData[i].attackPower;\r\n            defensepower += defender.troops[i + DEFENDER_START_IDX] * troopData[i + DEFENDER_START_IDX].defensePower;\r\n        }\r\n\r\n        if(attackpower > defensepower)\r\n        {\r\n            if(defender.immunityTime < block.timestamp + 14400)\r\n                defender.immunityTime = block.timestamp + 14400;\r\n\r\n            UpdateMoneyAt(defenderAddr);\r\n\r\n            MinerData storage m = miners[defenderAddr];\r\n            MinerData storage m2 = miners[msg.sender];\r\n            uint256 moneyStolen = m.money / 2;\r\n\r\n            for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)\r\n            {\r\n                defender.troops[i] = defender.troops[i]/2;\r\n            }\r\n\r\n            for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)\r\n            {\r\n                if(troopData[i].attackPower > 0)\r\n                {\r\n                    count = attacker.troops[i];\r\n\r\n                    // if the troops overpower the total defense power only a fraction is lost\r\n                    if((count * troopData[i].attackPower) > defensepower)\r\n                        {\r\n                            count = count * defensepower / attackpower / 2;\r\n                        }\r\n                    else\r\n                         {\r\n                             count =  count/2;\r\n                         }\r\n                    attacker.troops[i] = SafeMath.sub(attacker.troops[i],count);\r\n                    defensepower -= count * troopData[i].attackPower;\r\n                }\r\n            }\r\n\r\n            m.money -= moneyStolen;\r\n            m2.money += moneyStolen;\r\n        } else\r\n        {\r\n            for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)\r\n            {\r\n                attacker.troops[i] = attacker.troops[i] / 2;\r\n            }\r\n\r\n            for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)\r\n            {\r\n                if(troopData[i].defensePower > 0)\r\n                {\r\n                    count = defender.troops[i];\r\n\r\n                    // if the troops overpower the total defense power only a fraction is lost\r\n                    if((count * troopData[i].defensePower) > attackpower)\r\n                        count = count * attackpower / defensepower / 2;\r\n\r\n                    defender.troops[i] -= count;\r\n                    attackpower -= count * troopData[i].defensePower;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // ICO/Pot share functions\r\n    //--------------------------------------------------------------------------\r\n    function ReleaseICO() external\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(nextPotDistributionTime <= block.timestamp);\r\n        require(honeyPotAmount > 0);\r\n        require(globalICOPerCycle[cycleCount] > 0);\r\n\r\n        nextPotDistributionTime = block.timestamp + 86400;\r\n\r\n        honeyPotPerCycle[cycleCount] = honeyPotAmount / 10; // 10% of the pot\r\n\r\n        honeyPotAmount -= honeyPotAmount / 10;\r\n\r\n        honeyPotPerCycle.push(0);\r\n        globalICOPerCycle.push(0);\r\n        cycleCount = cycleCount + 1;\r\n\r\n        MinerData storage jakpotWinner = miners[msg.sender];\r\n        jakpotWinner.unclaimedPot += jackPot;\r\n        jackPot = 0;\r\n    }\r\n\r\n    function FundICO(uint amount) external\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(amount > 0);\r\n\r\n        MinerData storage m = miners[msg.sender];\r\n\r\n        UpdateMoney();\r\n\r\n        require(m.money >= amount);\r\n\r\n        m.money = (m.money).sub(amount);\r\n\r\n        globalICOPerCycle[cycleCount] = globalICOPerCycle[cycleCount].add(uint(amount));\r\n        minerICOPerCycle[msg.sender][cycleCount] = minerICOPerCycle[msg.sender][cycleCount].add(uint(amount));\r\n    }\r\n\r\n    function WithdrawICOEarnings() external\r\n    {\r\n        MinerData storage m = miners[msg.sender];\r\n\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(miners[msg.sender].lastPotClaimIndex < cycleCount);\r\n\r\n        uint256 i = m.lastPotClaimIndex;\r\n        uint256 limit = cycleCount;\r\n\r\n        if((limit - i) > 30) // more than 30 iterations(days) afk\r\n            limit = i + 30;\r\n\r\n        m.lastPotClaimIndex = limit;\r\n        for(; i < cycleCount; ++i)\r\n        {\r\n            if(minerICOPerCycle[msg.sender][i] > 0)\r\n                m.unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[msg.sender][i]) / globalICOPerCycle[i];\r\n        }\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // ETH handler functions\r\n    //--------------------------------------------------------------------------\r\n    function BuyHandler(uint amount) private\r\n    {\r\n        // add 90% to honeyPot\r\n        honeyPotAmount += (amount * honeyPotSharePct) / 100;\r\n        jackPot += amount / 100;\r\n        devFund += (amount * (100-(honeyPotSharePct+1))) / 100;\r\n    }\r\n\r\n    function WithdrawPotShare() public\r\n    {\r\n        MinerData storage m = miners[msg.sender];\r\n\r\n        require(m.unclaimedPot > 0);\r\n        require(m.lastUpdateTime != 0);\r\n\r\n        uint256 amntToSend = m.unclaimedPot;\r\n        m.unclaimedPot = 0;\r\n\r\n        if(msg.sender.send(amntToSend))\r\n        {\r\n            m.unclaimedPot = 0;\r\n        }\r\n    }\r\n\r\n    function WithdrawDevFunds() public\r\n    {\r\n        require(msg.sender == owner);\r\n\r\n        if(owner.send(devFund))\r\n        {\r\n            devFund = 0;\r\n        }\r\n    }\r\n\r\n    // fallback payment to pot\r\n    function() public payable {\r\n         devFund += msg.value;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"BuyUpgrade\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"name\":\"GetProductionPerSecond\",\"outputs\":[{\"name\":\"personalProduction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawPotShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"GetMinerUnclaimedICOShare\",\"outputs\":[{\"name\":\"unclaimedPot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spaceIdx\",\"type\":\"uint8\"},{\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"UpgradeSpace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetGlobalProduction\",\"outputs\":[{\"name\":\"globalMoney\",\"type\":\"uint256\"},{\"name\":\"globalHashRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"GetPVPData\",\"outputs\":[{\"name\":\"attackpower\",\"type\":\"uint256\"},{\"name\":\"defensepower\",\"type\":\"uint256\"},{\"name\":\"immunityTime\",\"type\":\"uint256\"},{\"name\":\"exhaustTime\",\"type\":\"uint256\"},{\"name\":\"troops\",\"type\":\"uint256[6]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetPotInfo\",\"outputs\":[{\"name\":\"_honeyPotAmount\",\"type\":\"uint256\"},{\"name\":\"_devFunds\",\"type\":\"uint256\"},{\"name\":\"_jackPot\",\"type\":\"uint256\"},{\"name\":\"_nextDistributionTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spaceIdx\",\"type\":\"uint8\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"UpgradeSpaceETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawDevFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetTotalMinerCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetCurrentICOCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"HasBooster\",\"outputs\":[{\"name\":\"hasBoost\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"},{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetMinerICOData\",\"outputs\":[{\"name\":\"ICOFund\",\"type\":\"uint256\"},{\"name\":\"ICOShare\",\"type\":\"uint256\"},{\"name\":\"lastClaimIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"BuyTroop\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"defenderAddr\",\"type\":\"address\"}],\"name\":\"Attack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetBoosterData\",\"outputs\":[{\"name\":\"_boosterHolders\",\"type\":\"address[5]\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"currentIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetICOData\",\"outputs\":[{\"name\":\"ICOFund\",\"type\":\"uint256\"},{\"name\":\"ICOPot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"name\":\"GetMinerData\",\"outputs\":[{\"name\":\"money\",\"type\":\"uint256\"},{\"name\":\"lastupdate\",\"type\":\"uint256\"},{\"name\":\"prodPerSec\",\"type\":\"uint256\"},{\"name\":\"spaces\",\"type\":\"uint256[9]\"},{\"name\":\"upgrades\",\"type\":\"uint256[3]\"},{\"name\":\"unclaimedPot\",\"type\":\"uint256\"},{\"name\":\"hasBooster\",\"type\":\"bool\"},{\"name\":\"unconfirmedMoney\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetMinerAt\",\"outputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawICOEarnings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ReleaseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"StartNewMiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"BuyBooster\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"SpaceWar","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bf78e7d2a135c37536670e981f529019a0f860768ccb0135b9c3d174b49ab8e9"}]}