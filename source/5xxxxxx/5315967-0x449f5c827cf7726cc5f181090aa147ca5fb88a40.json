{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your assets.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n  /// @notice Count NFTs tracked by this contract\r\n  /// @return A count of valid NFTs tracked by this contract, where each one of\r\n  ///  them has an assigned and queryable owner not equal to the zero address\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /// @notice Enumerate valid NFTs\r\n  /// @dev Throws if `_index` >= `totalSupply()`.\r\n  /// @param _index A counter less than `totalSupply()`\r\n  /// @return The token identifier for the `_index`th NFT,\r\n  ///  (sort order not specified)\r\n  function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n  /// @notice Enumerate NFTs assigned to an owner\r\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  ///  `_owner` is the zero address, representing invalid NFTs.\r\n  /// @param _owner An address where we are interested in NFTs owned by them\r\n  /// @param _index A counter less than `balanceOf(_owner)`\r\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  ///   (sort order not specified)\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address \r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\ncontract Ownable {\r\n    address private owner;\r\n\r\n    event LogOwnerChange(address _owner);\r\n\r\n    // Modify method to only allow calls from the owner of the contract.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Replace the contract owner with a new owner.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _owner : address\r\n     *     The address to replace the current owner with.\r\n     */\r\n    function replaceOwner(address _owner) external onlyOwner {\r\n        owner = _owner;\r\n\r\n        LogOwnerChange(_owner);\r\n    }\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    // Mapping of a contract address to its position in the list of active\r\n    // contracts. This allows an O(1) look-up of the contract address compared\r\n    // to a linear search within an array.\r\n    mapping(address => uint256) private contractIndices;\r\n\r\n    // The list of contracts that are allowed to call the contract-restricted\r\n    // methods of contracts that extend this `Controllable` contract.\r\n    address[] private contracts;\r\n\r\n    /**\r\n     * Modify method to only allow calls from active contract addresses.\r\n     *\r\n     * Notes\r\n     * -----\r\n     * The zero address is considered an inactive address, as it is impossible\r\n     * for users to send a call from that address.\r\n     */\r\n    modifier onlyActiveContracts() {\r\n        require(contractIndices[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    function Controllable() public Ownable() {\r\n        // The zeroth index of the list of active contracts is occupied by the\r\n        // zero address to ensure that an index of zero can be used to indicate\r\n        // that the contract address is inactive.\r\n        contracts.push(address(0));\r\n    }\r\n\r\n    /**\r\n     * Add a contract address to the list of active contracts.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _address : address\r\n     *     The contract address to add to the list of active contracts.\r\n     */\r\n    function activateContract(address _address) external onlyOwner {\r\n        require(contractIndices[_address] == 0);\r\n\r\n        contracts.push(_address);\r\n\r\n        // The index of the newly added contract is equal to the length of the\r\n        // array of active contracts minus one, as Solidity is a zero-based\r\n        // language.\r\n        contractIndices[_address] = contracts.length - 1;\r\n    }\r\n\r\n    /**\r\n     * Remove a contract address from the list of active contracts.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _address : address\r\n     *     The contract address to remove from the list of active contracts.\r\n     */\r\n    function deactivateContract(address _address) external onlyOwner {\r\n        require(contractIndices[_address] != 0);\r\n\r\n        // Get the last contract in the array of active contracts. This address\r\n        // will be used to overwrite the address that will be removed.\r\n        address lastActiveContract = contracts[contracts.length - 1];\r\n\r\n        // Overwrite the address that is to be removed with the value of the\r\n        // last contract in the list. There is a possibility that these are the\r\n        // same values, in which case nothing happens.\r\n        contracts[contractIndices[_address]] = lastActiveContract;\r\n\r\n        // Reduce the contracts array size by one, as the last contract address\r\n        // will have been successfully moved.\r\n        contracts.length--;\r\n\r\n        // Set the address mapping to zero, effectively rendering the contract\r\n        // banned from calling this contract.\r\n        contractIndices[_address] = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the list of active contracts for this contract.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * address[]\r\n     *     The list of contract addresses that are allowed to call the\r\n     *     contract-restricted methods of this contract.\r\n     */\r\n    function getActiveContracts() external view returns (address[]) {\r\n        return contracts;\r\n    }\r\n}\r\n\r\nlibrary Tools {\r\n    /**\r\n     * Concatenate two strings.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * stringLeft : string\r\n     *     A string to concatenate with another string. This is the left part.\r\n     * stringRight : string\r\n     *     A string to concatenate with another string. This is the right part.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * string\r\n     *     The resulting string from concatenating the two given strings.\r\n     */\r\n    function concatenate(\r\n        string stringLeft,\r\n        string stringRight\r\n    )\r\n        internal\r\n        pure\r\n        returns (string)\r\n    {\r\n        // Get byte representations of both strings to allow for one-by-one\r\n        // character iteration.\r\n        bytes memory stringLeftBytes = bytes(stringLeft);\r\n        bytes memory stringRightBytes = bytes(stringRight);\r\n\r\n        // Initialize new string holder with the appropriate number of bytes to\r\n        // hold the concatenated string.\r\n        string memory resultString = new string(\r\n            stringLeftBytes.length + stringRightBytes.length\r\n        );\r\n\r\n        // Get a bytes representation of the result string to allow for direct\r\n        // modification.\r\n        bytes memory resultBytes = bytes(resultString);\r\n\r\n        // Initialize a number to hold the current index of the result string\r\n        // to assign a character to.\r\n        uint k = 0;\r\n\r\n        // First loop over the left string, and afterwards over the right\r\n        // string to assign each character to its proper location in the new\r\n        // string.\r\n        for (uint i = 0; i < stringLeftBytes.length; i++) {\r\n            resultBytes[k++] = stringLeftBytes[i];\r\n        }\r\n\r\n        for (i = 0; i < stringRightBytes.length; i++) {\r\n            resultBytes[k++] = stringRightBytes[i];\r\n        }\r\n\r\n        return string(resultBytes);\r\n    }\r\n\r\n    /**\r\n     * Convert 256-bit unsigned integer into a 32 bytes structure.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * value : uint256\r\n     *     The unsigned integer to convert to bytes32.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bytes32\r\n     *     The bytes32 representation of the given unsigned integer.\r\n     */\r\n    function uint256ToBytes32(uint256 value) internal pure returns (bytes32) {\r\n        if (value == 0) {\r\n            return '0';\r\n        }\r\n\r\n        bytes32 resultBytes;\r\n\r\n        while (value > 0) {\r\n            resultBytes = bytes32(uint(resultBytes) / (2 ** 8));\r\n            resultBytes |= bytes32(((value % 10) + 48) * 2 ** (8 * 31));\r\n            value /= 10;\r\n        }\r\n\r\n        return resultBytes;\r\n    }\r\n\r\n    /**\r\n     * Convert bytes32 data structure into a string.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * data : bytes32\r\n     *     The bytes to convert to a string.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * string\r\n     *     The string representation of given bytes.\r\n     *\r\n     * Notes\r\n     * -----\r\n     * This method is right-padded with zero bytes.\r\n     */\r\n    function bytes32ToString(bytes32 data) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n\r\n        for (uint i = 0; i < 32; i++) {\r\n            bytes1 char = bytes1(bytes32(uint256(data) * 2 ** (8 * i)));\r\n\r\n            if (char != 0) {\r\n                bytesString[i] = char;\r\n            }\r\n        }\r\n\r\n        return string(bytesString);\r\n    }\r\n}\r\n\r\n/**\r\n * Partial interface of former ownership contract.\r\n *\r\n * This interface is used to perform the migration of tokens, from the former\r\n * ownership contract to the current version. The inclusion of the entire\r\n * contract is too bulky, hence the partial interface.\r\n */\r\ninterface PartialOwnership {\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n/**\r\n * Ethergotchi Ownership Contract\r\n *\r\n * This contract governs the \"non-fungible tokens\" (NFTs) that represent the\r\n * various Ethergotchi owned by players within Aethia.\r\n *\r\n * The NFTs are implemented according to the standard described in EIP-721 as\r\n * it was on March 19th, 2018.\r\n *\r\n * In addition to the mentioned specification, a method was added to create new\r\n * tokens: `add(uint256 _tokenId, address _owner)`. This method can *only* be\r\n * called by activated Aethia game contracts.\r\n *\r\n * For more information on Aethia and/or Ethergotchi, visit the following\r\n * website: https://aethia.co\r\n */\r\ncontract EthergotchiOwnershipV2 is\r\n    Controllable,\r\n    ERC721,\r\n    ERC721Enumerable,\r\n    ERC721Metadata\r\n{\r\n    // Direct mapping to keep track of token owners.\r\n    mapping(uint256 => address) private ownerByTokenId;\r\n\r\n    // Mapping that keeps track of all tokens owned by a specific address. This\r\n    // allows for iteration by owner, and is implemented to be able to comply\r\n    // with the enumeration methods described in the ERC721Enumerable interface.\r\n    mapping(address => uint256[]) private tokenIdsByOwner;\r\n\r\n    // Mapping that keeps track of a token\"s position in an owner\"s list of\r\n    // tokens. This allows for constant time look-ups within the list, instead\r\n    // of needing to iterate the list of tokens.\r\n    mapping(uint256 => uint256) private ownerTokenIndexByTokenId;\r\n\r\n    // Mapping that keeps track of addresses that are approved to make a\r\n    // transfer of a token. Approval can only be given to a single address, but\r\n    // can be overridden for modification or retraction purposes.\r\n    mapping(uint256 => address) private approvedTransfers;\r\n\r\n    // Mapping that keeps track of operators that are allowed to perform\r\n    // actions on behalf of another address. An address is allowed to set more\r\n    // than one operator. Operators can perform all actions on behalf on an\r\n    // address, *except* for setting a different operator.\r\n    mapping(address => mapping(address => bool)) private operators;\r\n\r\n    // Total number of tokens governed by this contract. This allows for the\r\n    // enumeration of all tokens, provided that tokens are created with their\r\n    // identifiers being numbers, incremented by one.\r\n    uint256 private totalTokens;\r\n\r\n    // The ERC-165 identifier of the ERC-165 interface. This contract\r\n    // implements the `supportsInterface` method to check whether other types\r\n    // of standard interfaces are supported.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(\r\n        keccak256(\"supportsInterface(bytes4)\")\r\n    );\r\n\r\n    // The ERC-165 identifier of the ERC-721 interface. This contract\r\n    // implements all methods of the ERC-721 Enumerable interface, and uses\r\n    // this identifier to supply the correct answer to a call to\r\n    // `supportsInterface`.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(\r\n        keccak256(\"balanceOf(address)\") ^\r\n        keccak256(\"ownerOf(uint256)\") ^\r\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\") ^\r\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\r\n        keccak256(\"transferFrom(address,address,uint256)\") ^\r\n        keccak256(\"approve(address,uint256)\") ^\r\n        keccak256(\"setApprovalForAll(address,bool)\") ^\r\n        keccak256(\"getApproved(uint256)\") ^\r\n        keccak256(\"isApprovedForAll(address,address)\")\r\n    );\r\n\r\n    // The ERC-165 identifier of the ERC-721 Enumerable interface. This\r\n    // contract implements all methods of the ERC-721 Enumerable interface, and\r\n    // uses this identifier to supply the correct answer to a call to\r\n    // `supportsInterface`.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC721_ENUMERABLE = bytes4(\r\n        keccak256(\"totalSupply()\") ^\r\n        keccak256(\"tokenByIndex(uint256)\") ^\r\n        keccak256(\"tokenOfOwnerByIndex(address,uint256)\")\r\n    );\r\n\r\n    // The ERC-165 identifier of the ERC-721 Metadata interface. This contract\r\n    // implements all methods of the ERC-721 Metadata interface, and uses the\r\n    // identifier to supply the correct answer to a `supportsInterface` call.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC721_METADATA = bytes4(\r\n        keccak256(\"name()\") ^\r\n        keccak256(\"symbol()\") ^\r\n        keccak256(\"tokenURI(uint256)\")\r\n    );\r\n\r\n    // The ERC-165 identifier of the ERC-721 Token Receiver interface. This\r\n    // is not implemented by this contract, but is used to identify the\r\n    // response given by the receiving contracts, if the `safeTransferFrom`\r\n    // method is used.\r\n    bytes4 private constant INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER = bytes4(\r\n        keccak256(\"onERC721Received(address,uint256,bytes)\")\r\n    );\r\n\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    /**\r\n     * Modify method to only allow calls if the token is valid.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Ethergotchi are valid if they are owned by an address that is not the\r\n     * zero address.\r\n     */\r\n    modifier onlyValidToken(uint256 _tokenId) {\r\n        require(ownerByTokenId[_tokenId] != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Modify method to only allow transfers from authorized callers.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method also adds a few checks against common transfer beneficiary\r\n     * mistakes to prevent a subset of unintended transfers that cannot be\r\n     * reverted.\r\n     */\r\n    modifier onlyValidTransfers(address _from, address _to, uint256 _tokenId) {\r\n        // Get owner of the token. This is used to check against various cases\r\n        // where the caller is allowed to transfer the token.\r\n        address tokenOwner = ownerByTokenId[_tokenId];\r\n\r\n        // Check whether the caller is allowed to transfer the token with given\r\n        // identifier. The caller is allowed to perform the transfer in any of\r\n        // the following cases:\r\n        //  1. the caller is the owner of the token;\r\n        //  2. the caller is approved by the owner of the token to transfer\r\n        //     that specific token; or\r\n        //  3. the caller is approved as operator by the owner of the token, in\r\n        //     which case the caller is approved to perform any action on\r\n        //     behalf of the owner.\r\n        require(\r\n            msg.sender == tokenOwner ||\r\n            msg.sender == approvedTransfers[_tokenId] ||\r\n            operators[tokenOwner][msg.sender]\r\n        );\r\n\r\n        // Check against accidental transfers to the common \"wrong\" addresses.\r\n        // This includes the zero address, this ownership contract address, and\r\n        // \"non-transfers\" where the same address is filled in for both `_from`\r\n        // and `_to`.\r\n        require(\r\n            _to != address(0) &&\r\n            _to != address(this) &&\r\n            _to != _from\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Ethergotchi ownership contract constructor\r\n     *\r\n     * At the time of contract construction, an Ethergotchi is artificially\r\n     * constructed to ensure that Ethergotchi are numbered starting from one.\r\n     */\r\n    function EthergotchiOwnershipV2(\r\n        address _formerContract\r\n    )\r\n        public\r\n        Controllable()\r\n    {\r\n        ownerByTokenId[0] = address(0);\r\n        tokenIdsByOwner[address(0)].push(0);\r\n        ownerTokenIndexByTokenId[0] = 0;\r\n\r\n        // The migration index is initialized to 1 as the zeroth token need not\r\n        // be migrated; it is already created during the construction of this\r\n        // contract.\r\n        migrationIndex = 1;\r\n        formerContract = PartialOwnership(_formerContract);\r\n    }\r\n\r\n    /**\r\n     * Add new token into circulation.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to add into circulation.\r\n     * _owner : address\r\n     *     The address of the owner who receives the newly added token.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method can only be called by active game contracts. Game contracts\r\n     * are added and modified manually. These additions and modifications\r\n     * always trigger an event for audit purposes.\r\n     */\r\n    function add(\r\n        uint256 _tokenId,\r\n        address _owner\r\n    )\r\n        external\r\n        onlyActiveContracts\r\n    {\r\n        // Safety checks to prevent contracts from calling this method without\r\n        // setting the proper arguments.\r\n        require(_tokenId != 0 && _owner != address(0));\r\n\r\n        _add(_tokenId, _owner);\r\n\r\n        // As per the standard, transfers of newly created tokens should always\r\n        // originate from the zero address.\r\n        Transfer(address(0), _owner, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Check whether contract supports given interface.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * interfaceID : bytes4\r\n     *     The four-bytes representation of an interface of which to check\r\n     *     whether this contract supports it.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bool\r\n     *     True if given interface is supported, else False.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * It is expected that the `bytes4` values of interfaces are generated by\r\n     * calling XOR on all function signatures of the interface.\r\n     *\r\n     * Technically more interfaces are supported, as some interfaces may be\r\n     * subsets of the supported interfaces. This check is only to be used to\r\n     * verify whether \"standard interfaces\" are supported.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceID\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            interfaceID == INTERFACE_SIGNATURE_ERC165 ||\r\n            interfaceID == INTERFACE_SIGNATURE_ERC721 ||\r\n            interfaceID == INTERFACE_SIGNATURE_ERC721_METADATA ||\r\n            interfaceID == INTERFACE_SIGNATURE_ERC721_ENUMERABLE\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the name of the token this contract governs ownership of.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This is the collective name of the token. Individual tokens may be named\r\n     * differently by their owners.\r\n     */\r\n    function name() external pure returns (string) {\r\n        return \"Ethergotchi\";\r\n    }\r\n\r\n    /**\r\n     * Get the symbol of the token this contract governs ownership of.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This symbol has been explicitly changed to `ETHERGOTCHI` from `GOTCHI`\r\n     * in the `PHOENIX` patch of Aethia to prevent confusion with older tokens.\r\n     */\r\n    function symbol() external pure returns (string) {\r\n        return \"ETHERGOTCHI\";\r\n    }\r\n\r\n    /**\r\n     * Get the URI pointing to a JSON file with metadata for a given token.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to get the URI for.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * string\r\n     *     The URI pointing to a JSON file with metadata for the token with\r\n     *     given identifier.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method returns a string that may contain more than one null-byte,\r\n     * because the conversion method is not ideal.\r\n     */\r\n    function tokenURI(uint256 _tokenId) external view returns (string) {\r\n        bytes32 tokenIdBytes = Tools.uint256ToBytes32(_tokenId);\r\n\r\n        return Tools.concatenate(\r\n            \"https://aethia.co/ethergotchi/\",\r\n            Tools.bytes32ToString(tokenIdBytes)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the number of tokens assigned to given owner.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _owner : address\r\n     *     The address of the owner of which to get the number of owned tokens\r\n     *     of.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The number of tokens owned by given owner.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Tokens owned by the zero address are considered invalid, as described in\r\n     * the EIP 721 standard, and queries regarding the zero address will result\r\n     * in the transaction being rejected.\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n\r\n        return tokenIdsByOwner[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * Get the address of the owner of given token.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token of which to get the owner\"s address.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * address\r\n     *     The address of the owner of given token.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Tokens owned by the zero address are considered invalid, as described in\r\n     * the EIP 721 standard, and queries regarding the zero address will result\r\n     * in the transaction being rejected.\r\n     */\r\n    function ownerOf(uint256 _tokenId) external view returns (address) {\r\n        // Store the owner in a temporary variable to avoid having to do the\r\n        // lookup twice.\r\n        address _owner = ownerByTokenId[_tokenId];\r\n\r\n        require(_owner != address(0));\r\n\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * Transfer the ownership of given token from one address to another.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _from : address\r\n     *     The benefactor address to transfer the given token from.\r\n     * _to : address\r\n     *     The beneficiary address to transfer the given token to.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to transfer.\r\n     * data : bytes\r\n     *     Non-specified data to send along the transfer towards the `to`\r\n     *     address that can be processed.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method performs a check to determine whether the receiving party is\r\n     * a smart contract by calling the `_isContract` method. This works until\r\n     * the `Serenity` update of Ethereum is deployed.\r\n     */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes data\r\n    )\r\n        external\r\n        onlyValidToken(_tokenId)\r\n    {\r\n        // Call the internal `_safeTransferFrom` method to avoid duplicating\r\n        // the transfer code.\r\n        _safeTransferFrom(_from, _to, _tokenId, data);\r\n    }\r\n\r\n    /**\r\n     * Transfer the ownership of given token from one address to another.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _from : address\r\n     *     The benefactor address to transfer the given token from.\r\n     * _to : address\r\n     *     The beneficiary address to transfer the given token to.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to transfer.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method does exactly the same as calling the `safeTransferFrom`\r\n     * method with the `data` parameter set to an empty bytes value:\r\n     *  `safeTransferFrom(_from, _to, _tokenId, \"\")`\r\n     */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        onlyValidToken(_tokenId)\r\n    {\r\n        // Call the internal `_safeTransferFrom` method to avoid duplicating\r\n        // the transfer code.\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * Transfer the ownership of given token from one address to another.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _from : address\r\n     *     The benefactor address to transfer the given token from.\r\n     * _to : address\r\n     *     The beneficiary address to transfer the given token to.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to transfer.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method performs a few rudimentary checks to determine whether the\r\n     * receiving party can actually receive the token. However, it is still up\r\n     * to the caller to ensure this is actually the case.\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        onlyValidToken(_tokenId)\r\n        onlyValidTransfers(_from, _to, _tokenId)\r\n    {\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Approve the given address for the transfer of the given token.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _approved : address\r\n     *     The address to approve. Approval allows the address to transfer the\r\n     *     given token to a different address.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to give transfer approval for.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * There is no specific method to revoke approvals, but the approval is\r\n     * removed after the transfer has been completed. Additionally the owner\r\n     * or operator may call the method with the zero address as `_approved` to\r\n     * effectively revoke the approval.\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external {\r\n        address _owner = ownerByTokenId[_tokenId];\r\n\r\n        // Approval can only be given by the owner or an operator approved by\r\n        // the owner.\r\n        require(msg.sender == _owner || operators[_owner][msg.sender]);\r\n\r\n        // Set address as approved for transfer. It can be the case that the\r\n        // address was already set (e.g. this method was called twice in a row)\r\n        // in which case this does not change anything.\r\n        approvedTransfers[_tokenId] = _approved;\r\n\r\n        Approval(msg.sender, _approved, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Set approval for a third-party to manage all tokens of the caller.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _operator : address\r\n     *     The address to set the operator status for.\r\n     * _approved : bool\r\n     *     The operator status. True if the given address should be allowed to\r\n     *     act on behalf of the caller, else False.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * There is no duplicate checking done out of simplicity. Callers are thus\r\n     * able to set the same address as operator a multitude of times, even if\r\n     * it does not change the actual state of the system.\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        operators[msg.sender][_operator] = _approved;\r\n\r\n        ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * Get approved address for given token.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token of which to get the approved address of.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * address\r\n     *     The address that is allowed to initiate a transfer of the given\r\n     *     token.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Technically this method could be implemented without the method modifier\r\n     * as the network guarantees that the address mapping is initiated with all\r\n     * addresses set to the zero address. The requirement is implemented to\r\n     * comply with the standard as described in EIP-721.\r\n     */\r\n    function getApproved(\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        onlyValidToken(_tokenId)\r\n        returns (address)\r\n    {\r\n        return approvedTransfers[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * Check whether an address is an authorized operator of another address.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _owner : address\r\n     *     The address of which to check whether it has approved the other\r\n     *     address to act as operator.\r\n     * _operator : address\r\n     *     The address of which to check whether it has been approved to act\r\n     *     as operator on behalf of `_owner`.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bool\r\n     *     True if `_operator` is approved for all actions on behalf of\r\n     *     `_owner`.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method cannot fail, as the Ethereum network guarantees that all\r\n     * address mappings exist and are set to the zero address by default.\r\n     */\r\n    function isApprovedForAll(\r\n        address _owner,\r\n        address _operator\r\n    )\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return operators[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * Get the total number of tokens currently in circulation.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The total number of tokens currently in circulation.\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n\r\n    /**\r\n     * Get token identifier by index.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _index : uint256\r\n     *     The index of the token to get the identifier of.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The identifier of the token at given index.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Ethergotchi tokens are incrementally numbered starting from zero, and\r\n     * always go up by one. The index of the token is thus equivalent to its\r\n     * identifier.\r\n     */\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < totalTokens);\r\n\r\n        return _index;\r\n    }\r\n\r\n    /**\r\n     * Get token of owner by index.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _owner : address\r\n     *     The address of the owner of which to get the token of.\r\n     * _index : uint256\r\n     *     The index of the token in the given owner\"s list of token.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The identifier of the token at given index of an owner\"s list of\r\n     *     tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_index < tokenIdsByOwner[_owner].length);\r\n\r\n        return tokenIdsByOwner[_owner][_index];\r\n    }\r\n\r\n    /**\r\n     * Check whether given address is a smart contract.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _address : address\r\n     *     The address of which to check whether it is a contract.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bool\r\n     *     True if given address is a contract, else False.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method works as long as the `Serenity` update of Ethereum has not\r\n     * been deployed. At the time of writing, contracts cannot set their code\r\n     * size to zero, nor can \"normal\" addresses set their code size to anything\r\n     * non-zero. With `Serenity` the idea will be that each and every address\r\n     * is an contract, effectively rendering this method.\r\n     */\r\n    function _isContract(address _address) internal view returns (bool) {\r\n        uint size;\r\n\r\n        assembly {\r\n            size := extcodesize(_address)\r\n        }\r\n\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * Transfer the ownership of given token from one address to another.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _from : address\r\n     *     The benefactor address to transfer the given token from.\r\n     * _to : address\r\n     *     The beneficiary address to transfer the given token to.\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to transfer.\r\n     * data : bytes\r\n     *     Non-specified data to send along the transfer towards the `to`\r\n     *     address that can be processed.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method performs a check to determine whether the receiving party is\r\n     * a smart contract by calling the `_isContract` method. This works until\r\n     * the `Serenity` update of Ethereum is deployed.\r\n     */\r\n    function _safeTransferFrom(\r\n        address _from, \r\n        address _to, \r\n        uint256 _tokenId,\r\n        bytes data\r\n    )\r\n        internal\r\n        onlyValidTransfers(_from, _to, _tokenId)\r\n    {\r\n        // Call the method that performs the actual transfer. All common cases\r\n        // of \"wrong\" transfers have already been checked at this point. The\r\n        // internal transfer method does no checking.\r\n        _transfer(_to, _tokenId);\r\n\r\n        // Check whether the receiving party is a contract, and if so, call\r\n        // the `onERC721Received` method as defined in the ERC-721 standard.\r\n        if (_isContract(_to)) {\r\n\r\n            // Assume the receiving party has implemented ERC721TokenReceiver,\r\n            // as otherwise the \"unsafe\" `transferFrom` method should have been\r\n            // called instead.\r\n            ERC721TokenReceiver _receiver = ERC721TokenReceiver(_to);\r\n\r\n            // The response returned by `onERC721Received` of the receiving\r\n            // contract\"s `on *must* be equal to the magic number defined by\r\n            // the ERC-165 signature of `ERC721TokenReceiver`. If this is not\r\n            // the case, the transaction will be reverted.\r\n            require(\r\n                _receiver.onERC721Received(\r\n                    address(this),\r\n                    _tokenId,\r\n                    data\r\n                ) == INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfer token to new owner.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _to : address\r\n     *     The address of the owner-to-be of given token.\r\n     * _tokenId : _tokenId\r\n     *     The identifier of the token that is to be transferred.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method performs no safety checks as it can only be called within\r\n     * the controlled environment of this contract.\r\n     */\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        // Get current owner of the token. It is technically possible that the\r\n        // owner is the same address as the address to which the token is to be\r\n        // sent to. In this case the token will be moved to the end of the list\r\n        // of tokens owned by this address.\r\n        address _from = ownerByTokenId[_tokenId];\r\n\r\n        // There are two possible scenarios for transfers when it comes to the\r\n        // removal of the token from the side that currently owns the token:\r\n        //  1: the owner has two or more tokens; or\r\n        //  2: the owner has one token.\r\n        if (tokenIdsByOwner[_from].length > 1) {\r\n\r\n            // Get the index of the token that has to be removed from the list\r\n            // of tokens owned by the current owner.\r\n            uint256 tokenIndexToDelete = ownerTokenIndexByTokenId[_tokenId];\r\n\r\n            // To keep the list of tokens without gaps, and thus reducing the\r\n            // gas cost associated with interacting with the list, the last\r\n            // token in the owner\"s list of tokens is moved to fill the gap\r\n            // created by removing the token.\r\n            uint256 tokenIndexToMove = tokenIdsByOwner[_from].length - 1;\r\n\r\n            // Overwrite the token that is to be removed with the token that\r\n            // was at the end of the list. It is possible that both are one and\r\n            // the same, in which case nothing happens.\r\n            tokenIdsByOwner[_from][tokenIndexToDelete] =\r\n                tokenIdsByOwner[_from][tokenIndexToMove];\r\n        }\r\n\r\n        // Remove the last item in the list of tokens owned by the current\r\n        // owner. This item has either already been copied to the location of\r\n        // the token that is to be transferred, or is the only token of this\r\n        // owner in which case the list of tokens owned by this owner is now\r\n        // empty.\r\n        tokenIdsByOwner[_from].length--;\r\n\r\n        // Add the token to the list of tokens owned by `_to`. Items are always\r\n        // added to the very end of the list. This makes the token index of the\r\n        // new token within the owner\"s list of tokens equal to the length of\r\n        // the list minus one as Solidity is a zero-based language. This token\r\n        // index is then set for this token identifier.\r\n        tokenIdsByOwner[_to].push(_tokenId);\r\n        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_to].length - 1;\r\n\r\n        // Set the direct ownership information of the token to the new owner\r\n        // after all other ownership-related mappings have been updated to make\r\n        // sure the \"side\" data is correct.\r\n        ownerByTokenId[_tokenId] = _to;\r\n\r\n        // Remove the approved address of this token. It may be the case there\r\n        // was no approved address, in which case nothing changes.\r\n        approvedTransfers[_tokenId] = address(0);\r\n\r\n        // Log the transfer event onto the blockchain to leave behind an audit\r\n        // trail of all transfers that have taken place.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * Add new token into circulation.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _tokenId : uint256\r\n     *     The identifier of the token to add into circulation.\r\n     * _owner : address\r\n     *     The address of the owner who receives the newly added token.\r\n     */\r\n    function _add(uint256 _tokenId, address _owner) internal {\r\n        // Ensure the token does not already exist, and prevent duplicate calls\r\n        // using the same identifier.\r\n        require(ownerByTokenId[_tokenId] == address(0));\r\n\r\n        // Update the direct ownership mapping, by setting the owner of the\r\n        // token identifier to `_owner`, and adding the token to the list of\r\n        // tokens owned by `_owner`. Arrays are always initialized to empty\r\n        // versions of of their specific type, thus ensuring that the `push`\r\n        // method will not fail.\r\n        ownerByTokenId[_tokenId] = _owner;\r\n        tokenIdsByOwner[_owner].push(_tokenId);\r\n\r\n        // Update the mapping that keeps track of a token\"s index within the\r\n        // list of tokens owned by each owner. At the time of addition a token\r\n        // is always added to the end of the list, and will thus always equal\r\n        // the number of tokens already in the list, minus one, because the\r\n        // arrays within Solidity are zero-based.\r\n        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_owner].length - 1;\r\n\r\n        totalTokens += 1;\r\n    }\r\n\r\n    /*********************************************/\r\n    /** MIGRATION state variables and functions **/\r\n    /*********************************************/\r\n\r\n    // This number is used to keep track of how many tokens have been migrated.\r\n    // The number cannot exceed the number of tokens that were assigned to\r\n    // owners in the previous Ownership contract.\r\n    uint256 public migrationIndex;\r\n\r\n    // The previous token ownership contract.\r\n    PartialOwnership private formerContract;\r\n\r\n    /**\r\n     * Migrate data from the former Ethergotchi ownership contract.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _count : uint256\r\n     *     The number of tokens to migrate in a single transaction.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method is limited in use to ensure no 'malicious' calls are made.\r\n     * Additionally, this method writes to a contract state variable to keep\r\n     * track of how many tokens have been migrated.\r\n     */\r\n    function migrate(uint256 _count) external onlyOwner {\r\n        // Ensure that the migrate function can *only* be called in a specific\r\n        // time period. This period ranges from Saturday, March 24th, 00:00:00\r\n        // UTC until Sunday, March 25th, 23:59:59 UTC.\r\n        require(1521849600 <= now && now <= 1522022399);\r\n\r\n        // Get the maximum number of tokens handed out by the previous\r\n        // ownership contract.\r\n        uint256 formerTokenCount = formerContract.totalSupply();\r\n\r\n        // The index to stop the migration at for this transaction.\r\n        uint256 endIndex = migrationIndex + _count;\r\n\r\n        // It is possible that the final transaction has a higher end index\r\n        // than there are a number of tokens. In this case, the end index is\r\n        // reduced to ensure no non-existent tokens are migrated.\r\n        if (endIndex >= formerTokenCount) {\r\n            endIndex = formerTokenCount;\r\n        }\r\n\r\n        // Loop through the token identifiers to migrate in this transaction.\r\n        // Token identifiers are equivalent to their 'index', as identifiers\r\n        // start at zero (with the zeroth token being owned by the zero\r\n        // address), and are incremented by one for each new token.\r\n        for (uint256 i = migrationIndex; i < endIndex; i++) {\r\n            address tokenOwner;\r\n\r\n            // There was a malicious account that acquired over 400 eggs via\r\n            // referral codes, which breaks the terms of use. The acquired egg\r\n            // numbers ranged from identifier 1247 up until 1688, excluding\r\n            // 1296, 1297, 1479, 1492, 1550, 1551, and 1555. This was found by\r\n            // looking at activity on the pick-up contract, and tracing it back\r\n            // to the following address:\r\n            //  `0c7a911ac29ea1e3b1d438f98f8bc053131dcaf52`\r\n            if (_isExcluded(i)) {\r\n                tokenOwner = address(0);\r\n            } else {\r\n                tokenOwner = formerContract.ownerOf(i);\r\n            }\r\n\r\n            // Assign the token to the same address that owned it in the\r\n            // previous ownership contract.\r\n            _add(i, tokenOwner);\r\n\r\n            // Log the token transfer. In this case where the token is 'newly'\r\n            // created, but actually transferred from a previous contract, the\r\n            // `_from` address is set to the previous contract address, to\r\n            // signify a migration.\r\n            Transfer(address(formerContract), tokenOwner, i);\r\n        }\r\n\r\n        // Set the new migration index to where the current transaction ended\r\n        // its migration.\r\n        migrationIndex = endIndex;\r\n    }\r\n\r\n    /**\r\n     * Check if Ethergotchi should be excluded from migration.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * _gotchiId : uint256\r\n     *     The identifier of the Ethergotchi of which to check the exclusion\r\n     *     status.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * bool\r\n     *     True if the Ethergotchi should be excluded from the migration, else\r\n     *     False.\r\n     */\r\n    function _isExcluded(uint256 _gotchiId) internal pure returns (bool) {\r\n        return\r\n            1247 <= _gotchiId && _gotchiId <= 1688 &&\r\n            _gotchiId != 1296 &&\r\n            _gotchiId != 1297 &&\r\n            _gotchiId != 1479 &&\r\n            _gotchiId != 1492 &&\r\n            _gotchiId != 1550 &&\r\n            _gotchiId != 1551 &&\r\n            _gotchiId != 1555;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getActiveContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"deactivateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"activateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"replaceOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_formerContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"LogOwnerChange\",\"type\":\"event\"}]","ContractName":"EthergotchiOwnershipV2","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000025d466f0e7da4ec2f7201309e5416951d1e241a2","Library":"","SwarmSource":"bzzr://acd2f88c4266d21dc364824757dc3445dbd6bc4c15a90199e46a73d2a53ea2cf"}]}