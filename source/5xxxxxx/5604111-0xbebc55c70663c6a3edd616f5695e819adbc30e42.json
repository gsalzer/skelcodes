{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n///////////////////////////////\r\n//By f.antonio.akel@gmail.com//\r\n///////////////////////////////\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n/*\r\n    Bancor Converter interface\r\n*/\r\ncontract IBancorConverter{\r\n\r\n    function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256);\r\n\tfunction quickConvert(address[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\r\n\r\n}\r\n/*\r\n    Bancor Quick Converter interface\r\n*/\r\ncontract IBancorQuickConverter {\r\n    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\r\n    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256);\r\n    function convertForPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256);\r\n}\r\n\r\n/*\r\n    Bancor Gas tools interface\r\n*/\r\ncontract IBancorGasPriceLimit {\r\n    function gasPrice() public view returns (uint256) {}\r\n    function validateGasPrice(uint256) public view;\r\n}\r\n\r\n/*\r\n    EIP228 Token Converter interface\r\n*/\r\ncontract ITokenConverter {\r\n    function convertibleTokenCount() public view returns (uint16);\r\n    function convertibleToken(uint16 _tokenIndex) public view returns (address);\r\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\r\n    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n    // deprecated, backward compatibility\r\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n/*\r\n    Smart Token interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n/**\r\n* @title Admin parameters\r\n* @dev Define administration parameters for this contract\r\n*/\r\ncontract admined { //This token contract is administered\r\n    address public admin; //Admin address is public\r\n\r\n    /**\r\n    * @dev Contract constructor\r\n    * define initial administrator\r\n    */\r\n    constructor() internal {\r\n        admin = msg.sender; //Set initial admin to contract creator\r\n        emit Admined(admin);\r\n    }\r\n\r\n    modifier onlyAdmin() { //A modifier to define admin-only functions\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n   /**\r\n    * @dev Function to set new admin address\r\n    * @param _newAdmin The address to transfer administration to\r\n    */\r\n    function transferAdminship(address _newAdmin) onlyAdmin public { //Admin can be transfered\r\n        require(_newAdmin != 0);\r\n        admin = _newAdmin;\r\n        emit TransferAdminship(admin);\r\n    }\r\n\r\n    event TransferAdminship(address newAdminister);\r\n    event Admined(address administer);\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title ERC20Token\r\n* @notice Token definition contract\r\n*/\r\ncontract MEGA is admined,IERC20Token { //Standar definition of an ERC20Token\r\n    using SafeMath for uint256; //SafeMath is used for uint256 operations\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\t\t\tToken Related\t\t\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    mapping (address => uint256) balances; //A mapping of all balances per address\r\n    mapping (address => mapping (address => uint256)) allowed; //A mapping of all allowances\r\n    uint256 public totalSupply;\r\n    \r\n    /**\r\n    * @notice Get the balance of an _owner address.\r\n    * @param _owner The address to be query.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 bal) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @notice transfer _value tokens to address _to\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    * @return success with boolean value true if done\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(_to != address(0)); //If you dont want that people destroy token\r\n        \r\n        if(_to == address(this)){\r\n        \tburnToken(msg.sender, _value);\r\n        \tsell(msg.sender,_value);\r\n        \treturn true;\r\n        } else {\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t        balances[_to] = balances[_to].add(_value);\r\n    \t    emit Transfer(msg.sender, _to, _value);\r\n        \treturn true;\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from\r\n    * @param _from The address where tokens comes.\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    * @return success with boolean value true if done\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_to != address(0)); //If you dont want that people destroy token\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Assign allowance _value to _spender address to use the msg.sender balance\r\n    * @param _spender The address to be allowed to spend.\r\n    * @param _value The amount to be allowed.\r\n    * @return success with boolean value true\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n    \trequire((_value == 0) || (allowed[msg.sender][_spender] == 0)); //exploit mitigation\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the allowance of an specified address to use another address balance.\r\n    * @param _owner The address of the owner of the tokens.\r\n    * @param _spender The address of the allowed spender.\r\n    * @return remaining with the allowance value\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Mint token to an specified address.\r\n    * @param _target The address of the receiver of the tokens.\r\n    * @param _mintedAmount amount to mint.\r\n    */\r\n    function mintToken(address _target, uint256 _mintedAmount) private {\r\n        balances[_target] = SafeMath.add(balances[_target], _mintedAmount);\r\n        totalSupply = SafeMath.add(totalSupply, _mintedAmount);\r\n        emit Transfer(0, this, _mintedAmount);\r\n        emit Transfer(this, _target, _mintedAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Burn token of an specified address.\r\n    * @param _target The address of the holder of the tokens.\r\n    * @param _burnedAmount amount to burn.\r\n    */\r\n    function burnToken(address _target, uint256 _burnedAmount) private {\r\n        balances[_target] = SafeMath.sub(balances[_target], _burnedAmount);\r\n        totalSupply = SafeMath.sub(totalSupply, _burnedAmount);\r\n        emit Burned(_target, _burnedAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Log Events\r\n    */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Burned(address indexed _target, uint256 _value);\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n///\t\t\t\t\t\t\t\tInvestment related\t\t\t\t\t\t\t\t\t///\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t//Internal Variables\r\n\tIBancorConverter BancorConverter = IBancorConverter(0xc6725aE749677f21E4d8f85F41cFB6DE49b9Db29);\r\n\tIBancorQuickConverter Bancor = IBancorQuickConverter(0xcF1CC6eD5B653DeF7417E3fA93992c3FFe49139B);\r\n\tIBancorGasPriceLimit BancorGas = IBancorGasPriceLimit(0x607a5C47978e2Eb6d59C6C6f51bc0bF411f4b85a);\r\n\r\n\tIERC20Token ETHToken = IERC20Token(0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315);\r\n\r\n\tIERC20Token BNTToken = IERC20Token(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C);\r\n\r\n\tIERC20Token EOSRelay = IERC20Token(0x507b06c23d7Cb313194dBF6A6D80297137fb5E01);\r\n\tIERC20Token EOSToken = IERC20Token(0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0);\r\n\r\n\tIERC20Token ELFRelay = IERC20Token(0x0F2318565f1996CB1eD2F88e172135791BC1FcBf);\r\n\tIERC20Token ELFToken = IERC20Token(0xbf2179859fc6D5BEE9Bf9158632Dc51678a4100e);\r\n\r\n\tIERC20Token OMGToken = IERC20Token(0x99eBD396Ce7AA095412a4Cd1A0C959D6Fd67B340);\r\n\tIERC20Token OMGRelay = IERC20Token(0xd26114cd6EE289AccF82350c8d8487fedB8A0C07);\r\n\r\n\tIERC20Token POAToken = IERC20Token(0x564c07255AFe5050D82c8816F78dA13f2B17ac6D);\r\n\tIERC20Token POARelay = IERC20Token(0x6758B7d441a9739b98552B373703d8d3d14f9e62);\r\n\r\n\tIERC20Token DRGNToken = IERC20Token(0xa7774F9386E1653645E1A08fb7Aae525B4DeDb24);\r\n\tIERC20Token DRGNRelay = IERC20Token(0x419c4dB4B9e25d6Db2AD9691ccb832C8D9fDA05E);\r\n\r\n\tIERC20Token SRNToken = IERC20Token(0xd2Deb679ed81238CaeF8E0c32257092cEcc8888b);\r\n\tIERC20Token SRNRelay = IERC20Token(0x68d57c9a1C35f63E2c83eE8e49A64e9d70528D25);\r\n\r\n\tIERC20Token WAXToken = IERC20Token(0x67563E7A0F13642068F6F999e48c690107A4571F);\r\n\tIERC20Token WAXRelay = IERC20Token(0x39Bb259F66E1C59d5ABEF88375979b4D20D98022);\r\n\r\n\r\n\tIERC20Token POWRToken = IERC20Token(0x168D7Bbf38E17941173a352f1352DF91a7771dF3);\r\n\tIERC20Token POWRRelay = IERC20Token(0x595832F8FC6BF59c85C527fEC3740A1b7a361269);\r\n\r\n\tbool buyFlag = false; //False = set rate - True = auto rate\r\n\tuint256 constant internal magnitude = 2**64;\r\n\t//Path to exchanges\r\n\tmapping(uint8 => IERC20Token[]) paths;\r\n\tmapping(uint8 => IERC20Token[]) reversePaths;\r\n\r\n\r\n\t//public variables\r\n\taddress public feeWallet;\r\n\tuint256 public rate = 6850;\r\n\t//token related\r\n\tstring public name = \"MEGAINVEST v2\";\r\n    uint8 public decimals = 18;\r\n    string public symbol = \"MEG2\";\r\n    string public version = '2';\r\n\r\n\tconstructor(address _feeWallet) public {\r\n\t\tfeeWallet = _feeWallet;\r\n\t\tpaths[0] = [ETHToken,BNTToken,BNTToken,EOSRelay,EOSRelay,EOSRelay,EOSToken];\r\n    \tpaths[1] = [ETHToken,BNTToken,BNTToken,ELFRelay,ELFRelay,ELFRelay,ELFToken];\r\n    \tpaths[2] = [ETHToken,BNTToken,BNTToken,OMGRelay,OMGRelay,OMGRelay,OMGToken];\r\n    \tpaths[3] = [ETHToken,BNTToken,BNTToken,POARelay,POARelay,POARelay,POAToken];\r\n    \tpaths[4] = [ETHToken,BNTToken,BNTToken,DRGNRelay,DRGNRelay,DRGNRelay,DRGNToken];\r\n    \tpaths[5] = [ETHToken,BNTToken,BNTToken,SRNRelay,SRNRelay,SRNRelay,SRNToken];\r\n    \tpaths[6] = [ETHToken,BNTToken,BNTToken,WAXRelay,WAXRelay,WAXRelay,WAXToken];\r\n    \tpaths[7] = [ETHToken,BNTToken,BNTToken,POWRRelay,POWRRelay,POWRRelay,POWRToken];\r\n\r\n    \treversePaths[0] = [EOSToken,EOSRelay,EOSRelay,EOSRelay,BNTToken,BNTToken,ETHToken];\r\n    \treversePaths[1] = [ELFToken,ELFRelay,ELFRelay,ELFRelay,BNTToken,BNTToken,ETHToken];\r\n    \treversePaths[2] = [OMGToken,OMGRelay,OMGRelay,OMGRelay,BNTToken,BNTToken,ETHToken];\r\n    \treversePaths[3] = [POAToken,POARelay,POARelay,POARelay,BNTToken,BNTToken,ETHToken];\r\n    \treversePaths[4] = [DRGNToken,DRGNRelay,DRGNRelay,DRGNRelay,BNTToken,BNTToken,ETHToken];\r\n    \treversePaths[5] = [SRNToken,SRNRelay,SRNRelay,SRNRelay,BNTToken,BNTToken,ETHToken];\r\n    \treversePaths[6] = [WAXToken,WAXRelay,WAXRelay,WAXRelay,BNTToken,BNTToken,ETHToken];\r\n    \treversePaths[7] = [POWRToken,POWRRelay,POWRRelay,POWRRelay,BNTToken,BNTToken,ETHToken];\r\n\t}\r\n\r\n\tfunction changeBuyFlag(bool _flag) public onlyAdmin {\r\n\t\tbuyFlag = _flag;\r\n\t}\r\n\t\r\n\tfunction updateRate(uint256 _rate) public onlyAdmin {\r\n\t    rate = _rate;\r\n\t}\r\n\r\n\tfunction valueOnContract() public view returns (uint256){\r\n\r\n\t\tISmartToken smartToken;\r\n        IERC20Token toToken;\r\n        ITokenConverter converter;\r\n        IERC20Token[] memory _path;\r\n        uint256 pathLength;\r\n        uint256 sumUp;\r\n        uint256 _amount;\r\n        IERC20Token _fromToken;\r\n\r\n        for(uint8 j=0;j<8;j++){\r\n        \t_path = reversePaths[j];\r\n        \t// iterate over the conversion path\r\n\t        pathLength = _path.length;\r\n\t        _fromToken = _path[0];\r\n\t        _amount = _fromToken.balanceOf(address(this));\r\n\r\n\t        for (uint256 i = 1; i < pathLength; i += 2) {\r\n\t            smartToken = ISmartToken(_path[i]);\r\n\t            toToken = _path[i + 1];\r\n\t            converter = ITokenConverter(smartToken.owner());\r\n\r\n\t            // make the conversion - if it's the last one, also provide the minimum return value\r\n\t            _amount = converter.getReturn(_fromToken, toToken, _amount);\r\n\t            _fromToken = toToken;\r\n\t        }\r\n\t        \r\n\t        sumUp += _amount;\r\n        }\r\n\r\n        return sumUp;\r\n\r\n\t}\r\n\r\n\tfunction buy() public payable {\r\n\t    BancorGas.validateGasPrice(tx.gasprice);\r\n\r\n\t\tif(buyFlag == false){\r\n\t\t\ttokenBuy = msg.value.mul(rate);\r\n\t\t} else {\r\n\r\n\t\t\tuint256 valueStored = valueOnContract();\r\n\t\t\tuint256 tokenBuy;\r\n\r\n\t\t\tif(totalSupply > valueStored){\r\n\r\n\t\t\t\tuint256 tempRate = totalSupply.div(valueStored); // Must be > 0 Tok/Eth\r\n\t\t\t\ttokenBuy = msg.value.mul(tempRate); // Eth * Tok / Eth = Tok\r\n\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tuint256 tempPrice = valueStored.div(totalSupply); // Must be > 0 Eth/Tok\r\n\t\t\t\ttokenBuy = msg.value.div(tempPrice); // Eth / Eth / Tok = Tok\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\r\n\t\tuint256 ethFee = msg.value.mul(5)/1000; //5/1000 => 0.5%\r\n\t\tuint256 ethToInvest = msg.value.sub(ethFee);\r\n\r\n\t\tfeeWallet.transfer(ethFee);\r\n\t\tinvest(ethToInvest);\r\n\r\n\t\tmintToken(msg.sender,tokenBuy);\r\n\r\n\t}\r\n\r\n\tfunction invest(uint256 _amount) private {\r\n\t\tuint256 standarValue = _amount.div(8);\r\n\r\n\t\tfor(uint8 i=0; i<8; i++){ \r\n\t\t\tBancor.convertForPrioritized.value(standarValue)(paths[i],standarValue,1,address(this),0,0,0,0x0,0x0);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sell(address _target, uint256 _amount) private {\r\n\t\tuint256 tempBalance;\r\n\t\tuint256 tempFee;\r\n\t\tIERC20Token tempToken;\r\n\t\tuint256 dividedSupply = totalSupply.div(magnitude); //ethereum is not decimals friendly\r\n\r\n\t\tif(dividedSupply == 0 || _amount < dividedSupply) revert();\r\n\t\t\r\n\t\tuint256 factor = _amount.div(dividedSupply);\r\n\r\n\t\tif( factor == 0) revert();\r\n\r\n\t\tfor(uint8 i=0; i<8; i++){ \r\n\t\r\n\t\t\ttempToken = IERC20Token(paths[i][paths[i].length - 1]);\r\n\t\t\ttempBalance = tempToken.balanceOf(this);\r\n\t\t\ttempBalance = tempBalance.mul(factor);\r\n\t\t\ttempBalance = tempBalance.div(magnitude);\r\n\t\t\ttempFee = tempBalance.mul(5);\r\n\t\t\ttempFee = tempFee.div(1000); //0.5%\r\n\t\t\ttempBalance = tempBalance.sub(tempFee);\r\n\t\t\ttempToken.transfer(feeWallet,tempFee);\r\n\t\t\ttempToken.transfer(_target,tempBalance);\r\n\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction emergency() onlyAdmin public{\r\n\t    msg.sender.transfer(address(this).balance);\r\n\t}\r\n\t\r\n    function claimTokens(IERC20Token _address, address _to) onlyAdmin public  {\r\n        require(_to != address(0));\r\n        uint256 remainder = _address.balanceOf(this); //Check remainder tokens\r\n        _address.transfer(_to,remainder); //Transfer tokens to creator\r\n    }\r\n\r\n\tfunction () public payable{\r\n\t\tbuy();\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"valueOnContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminship\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"bal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"changeBuyFlag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_feeWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdminister\",\"type\":\"address\"}],\"name\":\"TransferAdminship\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"administer\",\"type\":\"address\"}],\"name\":\"Admined\",\"type\":\"event\"}]","ContractName":"MEGA","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c346a982d901b44077263477eb43f298928159c4","Library":"","SwarmSource":"bzzr://7b1e1a15f5b581b81fa445f5027234cb13f163f5ce1f34037f4a2f2cbf75de3c"}]}