{"status":"1","message":"OK","result":[{"SourceCode":"contract Partner {\r\n    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\r\n}\r\n\r\ncontract Target {\r\n    function transfer(address _to, uint _value);\r\n}\r\n\r\ncontract COE {\r\n\r\n    string public name = \"Coeval by Monkey Capital\";\r\n    uint8 public decimals = 18;\r\n    string public symbol = \"COE\";\r\n\r\n    address public owner;\r\n    address public devFeesAddr = 0xF772464393Ac87a1b7C628bF79090e014d931A23;\r\n    address public premine;\r\n    address tierController;\r\n\r\n    uint256[] tierTokens = [\r\n        1000000000000000000000,\r\n        900000000000000000000,\r\n        800000000000000000000,\r\n        700000000000000000000,\r\n        2300000000000000000000,\r\n        6500000000000000000000,\r\n        2000000000000000000000,\r\n        1200000000000000000000,\r\n        4500000000000000000000,\r\n        75000000000000000000\r\n    ];\r\n\r\n    // cost per token (cents *10^18) amounts for each tier.\r\n    uint256[] costPerToken = [\r\n        385000000000000000000000,\r\n        610000000000000000000000,\r\n        415000000000000000000000,\r\n        592000000000000000000000,\r\n        947000000000000000000000,\r\n        1100000000000000000000000,\r\n        1123000000000000000000000,\r\n        1115000000000000000000000,\r\n        1135000000000000000000000,\r\n        1013000000000000000000000\r\n    ];\r\n\r\n    uint256 public totalSupply = 100000000000000000000000;\r\n    uint tierLevel = 0;\r\n    uint fiatPerEth = 385000000000000000000000;    // cents per ETH in this case (*10^18)\r\n    uint256 circulatingSupply = 0;\r\n    uint maxTier = 9;\r\n    uint256 devFees = 0;\r\n    uint256 fees = 10000;  // the calculation expects % * 100 (so 10% is 1000)\r\n\r\n    // flags\r\n    bool public receiveEth = true;\r\n    bool payFees = true;\r\n    bool distributionDone = false;\r\n    bool canExchange = true;\r\n\r\n    // Storage\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => bool) public exchangePartners;\r\n\r\n    // events\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n\r\n    function COE() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function premine() public {\r\n        require(msg.sender == owner);\r\n        balances[premine] = add(balances[premine],32664993546427000000000);\r\n        Transfer(this, premine, 32664993546427000000000);\r\n        circulatingSupply = add(circulatingSupply, 32664993546427000000000);\r\n        totalSupply = sub(totalSupply,32664993546427000000000);\r\n    }\r\n\r\n    function () payable public {\r\n        require((msg.value > 0) && (receiveEth));\r\n\r\n        if(payFees) {\r\n            devFees = add(devFees, ((msg.value * fees) / 10000));\r\n        }\r\n        allocateTokens(convertEthToCents(msg.value));\r\n    }\r\n\r\n    function convertEthToCents(uint256 _incoming) internal returns (uint256) {\r\n        return mul(_incoming, fiatPerEth);\r\n    }\r\n\r\n    function allocateTokens(uint256 _submitted) internal {\r\n        uint256 _availableInTier = mul(tierTokens[tierLevel], costPerToken[tierLevel]);\r\n        uint256 _allocation = 0;\r\n        // multiply _submitted by cost per token and see if that is greater than _availableInTier\r\n\r\n        if(_submitted >= _availableInTier) {\r\n            _allocation = tierTokens[tierLevel];\r\n            tierTokens[tierLevel] = 0;\r\n            tierLevel++;\r\n            _submitted = sub(_submitted, _availableInTier);\r\n        }\r\n        else {\r\n            uint256 _tokens = div(div(mul(_submitted, 1 ether), costPerToken[tierLevel]), 1 ether);\r\n            _allocation = add(_allocation, _tokens);\r\n            tierTokens[tierLevel] = sub(tierTokens[tierLevel], _tokens);\r\n            _submitted = sub(_submitted, mul(_tokens, costPerToken[tierLevel]));\r\n        }\r\n\r\n        // transfer tokens allocated so far to wallet address from contract\r\n        balances[msg.sender] = add(balances[msg.sender],_allocation);\r\n        circulatingSupply = add(circulatingSupply, _allocation);\r\n        totalSupply = sub(totalSupply, _allocation);\r\n\r\n        if((_submitted != 0) && (tierLevel <= maxTier)) {\r\n            allocateTokens(_submitted);\r\n        }\r\n        else {\r\n            // emit transfer event\r\n            Transfer(this, msg.sender, balances[msg.sender]);\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public {\r\n        // sender must have enough tokens to transfer\r\n        require(balances[msg.sender] >= _value);\r\n        totalSupply = add(totalSupply, _value);\r\n        circulatingSupply = sub(circulatingSupply, _value);\r\n\r\n        if(_to == address(this)) {\r\n            // WARNING: if you transfer tokens back to the contract you will lose them\r\n            // use the exchange function to exchange for tokens with approved partner contracts\r\n            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n            Transfer(msg.sender, _to, _value);\r\n        }\r\n        else {\r\n            uint codeLength;\r\n\r\n            assembly {\r\n                codeLength := extcodesize(_to)\r\n            }\r\n\r\n            if(codeLength != 0) {\r\n                if(exchangePartners[_to]) {\r\n                    if(canExchange == true) {\r\n                        exchange(_to, _value);\r\n                    }\r\n                    else revert();  // until MNY is ready to accept COE revert attempts to exchange\r\n                }\r\n                else {\r\n                    // WARNING: if you transfer to a contract that cannot handle incoming tokens you may lose them\r\n                    balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n                    balances[_to] = add(balances[_to], _value);\r\n                    Transfer(msg.sender, _to, _value);\r\n                }\r\n            }\r\n            else {\r\n                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n                balances[_to] = add(balances[_to], _value);\r\n                Transfer(msg.sender, _to, _value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function exchange(address _partner, uint _amount) internal {\r\n        require(exchangePartners[_partner]);\r\n        require(requestTokensFromOtherContract(_partner, this, msg.sender, _amount));\r\n        balances[msg.sender] = sub(balanceOf(msg.sender), _amount);\r\n        circulatingSupply = sub(circulatingSupply, _amount);\r\n        totalSupply = add(totalSupply, _amount);\r\n        Transfer(msg.sender, this, _amount);\r\n    }\r\n\r\n    function requestTokensFromOtherContract(address _targetContract, address _sourceContract, address _recipient, uint256 _value) internal returns (bool){\r\n        Partner p = Partner(_targetContract);\r\n        p.exchangeTokensFromOtherContract(_sourceContract, _recipient, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _receiver) public constant returns (uint256) {\r\n        return balances[_receiver];\r\n    }\r\n\r\n    function balanceInTier() public constant returns (uint256) {\r\n        return tierTokens[tierLevel];\r\n    }\r\n\r\n    function currentTier() public constant returns (uint256) {\r\n        return tierLevel;\r\n    }\r\n\r\n    function setFiatPerEthRate(uint256 _newRate) {\r\n        require(msg.sender == owner);\r\n        fiatPerEth = _newRate;\r\n    }\r\n\r\n    function addExchangePartnerTargetAddress(address _partner) public {\r\n        require(msg.sender == owner);\r\n        exchangePartners[_partner] = true;\r\n    }\r\n\r\n    function canContractExchange(address _contract) public constant returns (bool) {\r\n        return exchangePartners[_contract];\r\n    }\r\n\r\n    function removeExchangePartnerTargetAddress(address _partner) public {\r\n        require(msg.sender == owner);\r\n        exchangePartners[_partner] = false;\r\n    }\r\n\r\n    function withdrawDevFees() public {\r\n        require(payFees);\r\n        devFeesAddr.transfer(devFees);\r\n        devFees = 0;\r\n    }\r\n\r\n    function changeDevFees(address _devFees) public {\r\n        require(msg.sender == owner);\r\n        devFeesAddr = _devFees;\r\n    }\r\n\r\n    function changePreMine(address _preMine) {\r\n        require(msg.sender == owner);\r\n        premine = _preMine;\r\n    }\r\n\r\n    function payFeesToggle() {\r\n        require(msg.sender == owner);\r\n        if(payFees) {\r\n            payFees = false;\r\n        }\r\n        else {\r\n            payFees = true;\r\n        }\r\n    }\r\n\r\n    function safeWithdrawal(address _receiver, uint256 _value) public {\r\n        require(msg.sender == owner);\r\n        // check balance before transferring\r\n        require(_value <= this.balance);\r\n        _receiver.transfer(_value);\r\n    }\r\n\r\n    // enables fee update - must be between 0 and 100 (%)\r\n    function updateFeeAmount(uint _newFee) public {\r\n        require(msg.sender == owner);\r\n        require((_newFee >= 0) && (_newFee <= 100));\r\n        fees = _newFee * 100;\r\n    }\r\n\r\n    function handleTokensFromOtherContracts(address _contract, address _recipient, uint256 _tokens) {\r\n        require(msg.sender == owner);\r\n        Target t;\r\n        t = Target(_contract);\r\n        t.transfer(_recipient, _tokens);\r\n    }\r\n\r\n    function changeOwner(address _recipient) {\r\n        require(msg.sender == owner);\r\n        owner = _recipient;\r\n    }\r\n\r\n    function changeTierController(address _controller) {\r\n        require(msg.sender == owner);\r\n        tierController = _controller;\r\n    }\r\n\r\n    function setTokenAndRate(uint256 _tokens, uint256 _rate) {\r\n        require((msg.sender == owner) || (msg.sender == tierController));\r\n        maxTier++;\r\n        tierTokens[maxTier] = _tokens;\r\n        costPerToken[maxTier] = _rate;\r\n    }\r\n\r\n    function setPreMineAddress(address _premine) {\r\n        require(msg.sender == owner);\r\n        premine = _premine;\r\n    }\r\n\r\n    function toggleReceiveEth() {\r\n        require(msg.sender == owner);\r\n        if(receiveEth == true) {\r\n            receiveEth = false;\r\n        }\r\n        else receiveEth = true;\r\n    }\r\n\r\n    function toggleTokenExchange() {\r\n        require(msg.sender == owner);\r\n        if(canExchange == true) {\r\n            canExchange = false;\r\n        }\r\n        else canExchange = true;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_preMine\",\"type\":\"address\"}],\"name\":\"changePreMine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDevFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_devFees\",\"type\":\"address\"}],\"name\":\"changeDevFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setTokenAndRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiveEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"handleTokensFromOtherContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleTokenExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"addExchangePartnerTargetAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"toggleReceiveEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"changeTierController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_premine\",\"type\":\"address\"}],\"name\":\"setPreMineAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFeesAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"premine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"updateFeeAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payFeesToggle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"canContractExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangePartners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"removeExchangePartnerTargetAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setFiatPerEthRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"COE","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8eb6b1eff731dd1b08402a0c0fd9fa03eae90325e6fe1c75cb9cb53d91708eba"}]}