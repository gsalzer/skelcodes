{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary ECRecovery {\r\n\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function recover(bytes32 hash, bytes sig)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            // solium-disable-next-line arg-overflow\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * toEthSignedMessageHash\r\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n     * @dev and hash the result\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(\r\n            \"\\x19Ethereum Signed Message:\\n32\",\r\n            hash\r\n        );\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Htlc is DSMath {\r\n    using ECRecovery for bytes32;\r\n\r\n    // TYPES\r\n\r\n    // ATL Authority timelocked contract\r\n    struct Multisig { // Locked by authority approval (earlyResolve), time (timoutResolve) or conversion into an atomic swap\r\n        address owner; // Owns ether deposited in multisig\r\n        address authority; // Can approve earlyResolve of funds out of multisig\r\n        uint deposit; // Amount deposited by owner in this multisig\r\n        uint unlockTime; // Multisig expiration timestamp in seconds\r\n    }\r\n\r\n    struct AtomicSwap { // Locked by secret (regularTransfer) or time (reclaimExpiredSwaps)\r\n        bytes32 msigId; // Corresponding multisigId\r\n        address initiator; // Initiated this swap\r\n        address beneficiary; // Beneficiary of this swap\r\n        uint amount; // If zero then swap not active anymore\r\n        uint fee; // Fee amount to be paid to multisig authority\r\n        uint expirationTime; // Swap expiration timestamp in seconds\r\n        bytes32 hashedSecret; // sha256(secret), hashed secret of swap initiator\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    address constant FEE_RECIPIENT = 0x478189a0aF876598C8a70Ce8896960500455A949;\r\n    uint constant MAX_BATCH_ITERATIONS = 25; // Assumption block.gaslimit around 7500000\r\n    mapping (bytes32 => Multisig) public multisigs;\r\n    mapping (bytes32 => AtomicSwap) public atomicswaps;\r\n    mapping (bytes32 => bool) public isAntecedentHashedSecret;\r\n\r\n    // EVENTS\r\n\r\n    // TODO add events for all public functions\r\n\r\n    // MODIFIERS\r\n\r\n    // METHODS\r\n\r\n    /**\r\n    @notice Send ether out of this contract to multisig owner and update or delete entry in multisig mapping\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @param amount Spend this amount of ether\r\n    */\r\n    function spendFromMultisig(bytes32 msigId, uint amount, address recipient)\r\n        internal\r\n    {\r\n        multisigs[msigId].deposit = sub(multisigs[msigId].deposit, amount);\r\n        if (multisigs[msigId].deposit == 0)\r\n            delete multisigs[msigId];\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n    @notice Initialise and reparametrize Multisig\r\n    @dev Uses msg.value to fund Multisig\r\n    @param authority Second multisig Authority. Usually this is the Exchange.\r\n    @param unlockTime Lock Ether until unlockTime in seconds.\r\n    @return msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    */\r\n    function initialiseMultisig(address authority, uint unlockTime)\r\n        public\r\n        payable\r\n        returns (bytes32 msigId)\r\n    {\r\n        // Require not own authority and non-zero ether amount are sent\r\n        require(msg.sender != authority);\r\n        require(msg.value > 0);\r\n        // Create unique multisig identifier\r\n        msigId = keccak256(\r\n            msg.sender,\r\n            authority,\r\n            msg.value,\r\n            unlockTime\r\n        );\r\n        // Create multisig\r\n        Multisig storage multisig = multisigs[msigId];\r\n        if (multisig.deposit == 0) { // New or empty multisig\r\n            // Create new multisig\r\n            multisig.owner = msg.sender;\r\n            multisig.authority = authority;\r\n        }\r\n        // Adjust balance and locktime\r\n        reparametrizeMultisig(msigId, unlockTime);\r\n    }\r\n\r\n    /**\r\n    @notice Inititate/extend multisig unlockTime and/or initiate/refund multisig deposit\r\n    @dev Can increase deposit and/or unlockTime but not owner or authority\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @param unlockTime Lock Ether until unlockTime in seconds.\r\n    */\r\n    function reparametrizeMultisig(bytes32 msigId, uint unlockTime)\r\n        public\r\n        payable\r\n    {\r\n        require(multisigs[msigId].owner == msg.sender);\r\n        Multisig storage multisig = multisigs[msigId];\r\n        multisig.deposit = add(multisig.deposit, msg.value);\r\n        assert(multisig.unlockTime <= unlockTime); // Can only increase unlockTime\r\n        multisig.unlockTime = unlockTime;\r\n    }\r\n\r\n    /**\r\n    @notice Withdraw ether from the multisig. Equivalent to EARLY_RESOLVE in Nimiq\r\n    @dev the signature is generated using web3.eth.sign() over the unique msigId\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @param amount Return this amount from this contract to owner\r\n    @param sig bytes signature of the not transaction sending Authority\r\n    */\r\n    function earlyResolve(bytes32 msigId, uint amount, bytes sig)\r\n        public\r\n    {\r\n        // Require: msg.sender == (owner or authority)\r\n        require(\r\n            multisigs[msigId].owner == msg.sender ||\r\n            multisigs[msigId].authority == msg.sender\r\n        );\r\n        // Require: valid signature from not msg.sending authority\r\n        address otherAuthority = multisigs[msigId].owner == msg.sender ?\r\n            multisigs[msigId].authority :\r\n            multisigs[msigId].owner;\r\n        require(otherAuthority == msigId.recover(sig));\r\n        // Return to owner\r\n        spendFromMultisig(msigId, amount, multisigs[msigId].owner);\r\n    }\r\n\r\n    /**\r\n    @notice Withdraw ether and delete the htlc swap. Equivalent to TIMEOUT_RESOLVE in Nimiq\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @dev Only refunds owned multisig deposits\r\n    */\r\n    function timeoutResolve(bytes32 msigId, uint amount)\r\n        public\r\n    {\r\n        // Require time has passed\r\n        require(now >= multisigs[msigId].unlockTime);\r\n        // Return to owner\r\n        spendFromMultisig(msigId, amount, multisigs[msigId].owner);\r\n    }\r\n\r\n    /**\r\n    @notice First or second stage of atomic swap.\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier\r\n    @param beneficiary Beneficiary of this swap\r\n    @param amount Convert this amount from multisig into swap\r\n    @param fee Fee amount to be paid to multisig authority\r\n    @param expirationTime Swap expiration timestamp in seconds; not more than 1 day from now\r\n    @param hashedSecret sha256(secret), hashed secret of swap initiator\r\n    @return swapId Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifier\r\n    */\r\n    function convertIntoHtlc(bytes32 msigId, address beneficiary, uint amount, uint fee, uint expirationTime, bytes32 hashedSecret)\r\n        public\r\n        returns (bytes32 swapId)\r\n    {\r\n        // Require owner with sufficient deposit\r\n        require(multisigs[msigId].owner == msg.sender);\r\n        require(multisigs[msigId].deposit >= amount + fee); // Checks for underflow\r\n        require(\r\n            now <= expirationTime &&\r\n            expirationTime <= min(now + 1 days, multisigs[msigId].unlockTime)\r\n        ); // Not more than 1 day or unlockTime\r\n        require(amount > 0); // Non-empty amount as definition for active swap\r\n        require(!isAntecedentHashedSecret[hashedSecret]);\r\n        isAntecedentHashedSecret[hashedSecret] = true;\r\n        // Account in multisig balance\r\n        multisigs[msigId].deposit = sub(multisigs[msigId].deposit, add(amount, fee));\r\n        // Create swap identifier\r\n        swapId = keccak256(\r\n            msigId,\r\n            msg.sender,\r\n            beneficiary,\r\n            amount,\r\n            fee,\r\n            expirationTime,\r\n            hashedSecret\r\n        );\r\n        // Create swap\r\n        AtomicSwap storage swap = atomicswaps[swapId];\r\n        swap.msigId = msigId;\r\n        swap.initiator = msg.sender;\r\n        swap.beneficiary = beneficiary;\r\n        swap.amount = amount;\r\n        swap.fee = fee;\r\n        swap.expirationTime = expirationTime;\r\n        swap.hashedSecret = hashedSecret;\r\n        // Transfer fee to fee recipient\r\n        FEE_RECIPIENT.transfer(fee);\r\n    }\r\n\r\n    /**\r\n    @notice Batch execution of convertIntoHtlc() function\r\n    */\r\n    function batchConvertIntoHtlc(\r\n        bytes32[] msigIds,\r\n        address[] beneficiaries,\r\n        uint[] amounts,\r\n        uint[] fees,\r\n        uint[] expirationTimes,\r\n        bytes32[] hashedSecrets\r\n    )\r\n        public\r\n        returns (bytes32[] swapId)\r\n    {\r\n        require(msigIds.length <= MAX_BATCH_ITERATIONS);\r\n        for (uint i = 0; i < msigIds.length; ++i)\r\n            convertIntoHtlc(\r\n                msigIds[i],\r\n                beneficiaries[i],\r\n                amounts[i],\r\n                fees[i],\r\n                expirationTimes[i],\r\n                hashedSecrets[i]\r\n            ); // Gas estimate `infinite`\r\n    }\r\n\r\n    /**\r\n    @notice Withdraw ether and delete the htlc swap. Equivalent to REGULAR_TRANSFER in Nimiq\r\n    @dev Transfer swap amount to beneficiary of swap and fee to authority\r\n    @param swapId Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifier\r\n    @param secret Hashed secret of htlc swap\r\n    */\r\n    function regularTransfer(bytes32 swapId, bytes32 secret)\r\n        public\r\n    {\r\n        // Require valid secret provided\r\n        require(sha256(secret) == atomicswaps[swapId].hashedSecret);\r\n        uint amount = atomicswaps[swapId].amount;\r\n        address beneficiary = atomicswaps[swapId].beneficiary;\r\n        // Delete swap\r\n        delete atomicswaps[swapId];\r\n        // Execute swap\r\n        beneficiary.transfer(amount);\r\n    }\r\n\r\n    /**\r\n    @notice Batch exection of regularTransfer() function\r\n    */\r\n    function batchRegularTransfer(bytes32[] swapIds, bytes32[] secrets)\r\n        public\r\n    {\r\n        require(swapIds.length <= MAX_BATCH_ITERATIONS);\r\n        for (uint i = 0; i < swapIds.length; ++i)\r\n            regularTransfer(swapIds[i], secrets[i]); // Gas estimate `infinite`\r\n    }\r\n\r\n    /**\r\n    @notice Reclaim an expired, non-empty swap into a multisig\r\n    @dev Transfer swap amount to beneficiary of swap and fee to authority\r\n    @param msigId Unique (owner, authority, balance != 0) multisig identifier to which deposit expired swaps\r\n    @param swapId Unique (initiator, beneficiary, amount, fee, expirationTime, hashedSecret) swap identifier\r\n    */\r\n    function reclaimExpiredSwap(bytes32 msigId, bytes32 swapId)\r\n        public\r\n    {\r\n        // Require: msg.sender == ower or authority\r\n        require(\r\n            multisigs[msigId].owner == msg.sender ||\r\n            multisigs[msigId].authority == msg.sender\r\n        );\r\n        // Require msigId matches swapId\r\n        require(msigId == atomicswaps[swapId].msigId);\r\n        // Require: is expired\r\n        require(now >= atomicswaps[swapId].expirationTime);\r\n        uint amount = atomicswaps[swapId].amount;\r\n        delete atomicswaps[swapId];\r\n        multisigs[msigId].deposit = add(multisigs[msigId].deposit, amount);\r\n    }\r\n\r\n    /**\r\n    @notice Batch exection of reclaimExpiredSwaps() function\r\n    */\r\n    function batchReclaimExpiredSwaps(bytes32 msigId, bytes32[] swapIds)\r\n        public\r\n    {\r\n        require(swapIds.length <= MAX_BATCH_ITERATIONS); // << block.gaslimit / 88281\r\n        for (uint i = 0; i < swapIds.length; ++i)\r\n            reclaimExpiredSwap(msigId, swapIds[i]); // Gas estimate 88281\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"swapId\",\"type\":\"bytes32\"},{\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"regularTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"reparametrizeMultisig\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"name\":\"hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"convertIntoHtlc\",\"outputs\":[{\"name\":\"swapId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"earlyResolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"swapIds\",\"type\":\"bytes32[]\"},{\"name\":\"secrets\",\"type\":\"bytes32[]\"}],\"name\":\"batchRegularTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"swapId\",\"type\":\"bytes32\"}],\"name\":\"reclaimExpiredSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigIds\",\"type\":\"bytes32[]\"},{\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"fees\",\"type\":\"uint256[]\"},{\"name\":\"expirationTimes\",\"type\":\"uint256[]\"},{\"name\":\"hashedSecrets\",\"type\":\"bytes32[]\"}],\"name\":\"batchConvertIntoHtlc\",\"outputs\":[{\"name\":\"swapId\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"multisigs\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"authority\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"timeoutResolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"swapIds\",\"type\":\"bytes32[]\"}],\"name\":\"batchReclaimExpiredSwaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority\",\"type\":\"address\"},{\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"initialiseMultisig\",\"outputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"atomicswaps\",\"outputs\":[{\"name\":\"msigId\",\"type\":\"bytes32\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"name\":\"hashedSecret\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isAntecedentHashedSecret\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Htlc","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://06f9e43fc70708553bc08cfafd461c429dd28eb5303cc5fb5fe78d18af6461f5"}]}