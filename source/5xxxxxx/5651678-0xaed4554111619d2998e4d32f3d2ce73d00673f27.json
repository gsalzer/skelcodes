{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath32\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath32 {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint32 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ether Habits\r\n * @dev Implements the logic behind Ether Habits\r\n */\r\ncontract Habits {\r\n    \r\n    using SafeMath for uint256;\r\n    using SafeMath32 for uint32;\r\n\r\n    // owner is only set on contract initialization, this cannot be changed\r\n    address internal owner;\r\n    mapping (address => bool) internal adminPermission;\r\n    \r\n    uint256 constant REGISTRATION_FEE = 0.005 ether;  // deposit for a single day\r\n    uint32 constant NUM_REGISTER_DAYS = 10;  // default number of days for registration\r\n    uint32 constant NINETY_DAYS = 90 days;\r\n    uint32 constant WITHDRAW_BUFFER = 129600;  // time before user can withdraw deposit\r\n    uint32 constant MAY_FIRST_2018 = 1525132800;\r\n    uint32 constant DAY = 86400;\r\n\r\n    enum UserEntryStatus {\r\n        NULL,\r\n        REGISTERED,\r\n        COMPLETED,\r\n        WITHDRAWN\r\n    }\r\n\r\n    struct DailyContestStatus {\r\n        uint256 numRegistered;\r\n        uint256 numCompleted;\r\n        bool operationFeeWithdrawn;\r\n    }\r\n\r\n    mapping (address => uint32[]) internal userToDates;\r\n    mapping (uint32 => address[]) internal dateToUsers;\r\n    mapping (address => mapping (uint32 => UserEntryStatus)) internal userDateToStatus;\r\n    mapping (uint32 => DailyContestStatus) internal dateToContestStatus;\r\n\r\n    event LogWithdraw(address user, uint256 amount);\r\n    event LogOperationFeeWithdraw(address user, uint256 amount);\r\n\r\n    /**\r\n     * @dev Sets the contract creator as the owner. Owner can't be changed in the future\r\n     */\r\n    function Habits() public {\r\n        owner = msg.sender;\r\n        adminPermission[owner] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Registers a user for NUM_REGISTER_DAYS days\r\n     * @notice Changes state\r\n     * @param _expectedStartDate (unix time: uint32) Start date the user had in mind when submitting the transaction\r\n     */\r\n    function register(uint32 _expectedStartDate) external payable {\r\n        // throw if sent ether doesn't match the total registration fee\r\n        require(REGISTRATION_FEE.mul(NUM_REGISTER_DAYS) == msg.value);\r\n\r\n        // can't register more than 100 days in advance\r\n        require(_expectedStartDate <= getDate(uint32(now)).add(NINETY_DAYS));\r\n\r\n        uint32 startDate = getStartDate();\r\n        // throw if actual start day doesn't match the user's expectation\r\n        // may happen if a transaction takes a while to get mined\r\n        require(startDate == _expectedStartDate);\r\n\r\n        for (uint32 i = 0; i < NUM_REGISTER_DAYS; i++) {\r\n            uint32 date = startDate.add(i.mul(DAY));\r\n\r\n            // double check that user already hasn't been registered\r\n            require(userDateToStatus[msg.sender][date] == UserEntryStatus.NULL);\r\n\r\n            userDateToStatus[msg.sender][date] = UserEntryStatus.REGISTERED;\r\n            userToDates[msg.sender].push(date);\r\n            dateToUsers[date].push(msg.sender);\r\n            dateToContestStatus[date].numRegistered += 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks-in a user for a given day\r\n     * @notice Changes state\r\n     */\r\n    function checkIn() external {\r\n        uint32 nowDate = getDate(uint32(now));\r\n\r\n        // throw if user entry status isn't registered\r\n        require(userDateToStatus[msg.sender][nowDate] == UserEntryStatus.REGISTERED);\r\n        userDateToStatus[msg.sender][nowDate] = UserEntryStatus.COMPLETED;\r\n        dateToContestStatus[nowDate].numCompleted += 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow users to withdraw deposit and bonus for checked-in dates\r\n     * @notice Changes state\r\n     * @param _dates Array of dates user wishes to withdraw for, this is\r\n     * calculated beforehand and verified in this method to reduce gas costs\r\n     */\r\n    function withdraw(uint32[] _dates) external {\r\n        uint256 withdrawAmount = 0;\r\n        uint256 datesLength = _dates.length;\r\n        uint32 now32 = uint32(now);\r\n        for (uint256 i = 0; i < datesLength; i++) {\r\n            uint32 date = _dates[i];\r\n            // if it hasn't been more than 1.5 days since the entry, skip\r\n            if (now32 <= date.add(WITHDRAW_BUFFER)) {\r\n                continue;\r\n            }\r\n            // if the entry status is anything other than COMPLETED, skip\r\n            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\r\n                continue;\r\n            }\r\n\r\n            // set status to WITHDRAWN to prevent re-entry\r\n            userDateToStatus[msg.sender][date] = UserEntryStatus.WITHDRAWN;\r\n            withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date));\r\n        }\r\n\r\n        if (withdrawAmount > 0) {\r\n           msg.sender.transfer(withdrawAmount);\r\n        }\r\n        LogWithdraw(msg.sender, withdrawAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate current withdrawable amount for a user\r\n     * @notice Doesn't change state\r\n     * @return Amount of withdrawable Wei\r\n     */\r\n    function calculateWithdrawableAmount() external view returns (uint256) {\r\n        uint32[] memory dates = userToDates[msg.sender];\r\n        uint256 datesLength = dates.length;\r\n        uint256 withdrawAmount = 0;\r\n        uint32 now32 = uint32(now);\r\n        for (uint256 i = 0; i < datesLength; i++) {\r\n            uint32 date = dates[i];\r\n            // if it hasn't been more than 1.5 days since the entry, skip\r\n            if (now32 <= date.add(WITHDRAW_BUFFER)) {\r\n                continue;\r\n            }\r\n            // if the entry status is anything other than COMPLETED, skip\r\n            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\r\n                continue;\r\n            }\r\n            withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date));\r\n        }\r\n\r\n        return withdrawAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate dates that a user can withdraw his/her deposit\r\n     * array may contain zeros so those need to be filtered out by the client\r\n     * @notice Doesn't change state\r\n     * @return Array of dates (unix time: uint32)\r\n     */\r\n    function getWithdrawableDates() external view returns(uint32[]) {\r\n        uint32[] memory dates = userToDates[msg.sender];\r\n        uint256 datesLength = dates.length;\r\n        // We can't initialize a mutable array in memory, so creating an array\r\n        // with length set as the number of regsitered days\r\n        uint32[] memory withdrawableDates = new uint32[](datesLength);\r\n        uint256 index = 0;\r\n        uint32 now32 = uint32(now);\r\n\r\n        for (uint256 i = 0; i < datesLength; i++) {\r\n            uint32 date = dates[i];\r\n            // if it hasn't been more than 1.5 days since the entry, skip\r\n            if (now32 <= date.add(WITHDRAW_BUFFER)) {\r\n                continue;\r\n            }\r\n            // if the entry status is anything other than COMPLETED, skip\r\n            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\r\n                continue;\r\n            }\r\n            withdrawableDates[index] = date;\r\n            index += 1;\r\n        }\r\n\r\n        // this array may contain zeroes at the end of the array\r\n        return withdrawableDates;\r\n    }\r\n\r\n    /**\r\n     * @dev Return registered days and statuses for a user\r\n     * @notice Doesn't change state\r\n     * @return Tupple of two arrays (dates registered, statuses)\r\n     */\r\n    function getUserEntryStatuses() external view returns (uint32[], uint32[]) {\r\n        uint32[] memory dates = userToDates[msg.sender];\r\n        uint256 datesLength = dates.length;\r\n        uint32[] memory statuses = new uint32[](datesLength);\r\n\r\n        for (uint256 i = 0; i < datesLength; i++) {\r\n            statuses[i] = uint32(userDateToStatus[msg.sender][dates[i]]);\r\n        }\r\n        return (dates, statuses);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw operation fees for a list of dates\r\n     * @notice Changes state, owner only\r\n     * @param _dates Array of dates to withdraw operation fee\r\n     */\r\n    function withdrawOperationFees(uint32[] _dates) external {\r\n        // throw if sender isn't contract owner\r\n        require(msg.sender == owner);\r\n\r\n        uint256 withdrawAmount = 0;\r\n        uint256 datesLength = _dates.length;\r\n        uint32 now32 = uint32(now);\r\n\r\n        for (uint256 i = 0; i < datesLength; i++) {\r\n            uint32 date = _dates[i];\r\n            // if it hasn't been more than 1.5 days since the entry, skip\r\n            if (now32 <= date.add(WITHDRAW_BUFFER)) {\r\n                continue;\r\n            }\r\n            // if already withdrawn for given date, skip\r\n            if (dateToContestStatus[date].operationFeeWithdrawn) {\r\n                continue;\r\n            }\r\n            // set operationFeeWithdrawn to true to prevent re-entry\r\n            dateToContestStatus[date].operationFeeWithdrawn = true;\r\n            withdrawAmount = withdrawAmount.add(calculateOperationFee(date));\r\n        }\r\n\r\n        if (withdrawAmount > 0) {\r\n            msg.sender.transfer(withdrawAmount);\r\n        }\r\n        LogOperationFeeWithdraw(msg.sender, withdrawAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Get total withdrawable operation fee amount and dates, owner only\r\n     * array may contain zeros so those need to be filtered out by the client\r\n     * @notice Doesn't change state\r\n     * @return Tuple(Array of dates (unix time: uint32), amount)\r\n     */\r\n    function getWithdrawableOperationFeeDatesAndAmount() external view returns (uint32[], uint256) {\r\n        // throw if sender isn't contract owner\r\n        if (msg.sender != owner) {\r\n            return (new uint32[](0), 0);\r\n        }\r\n\r\n        uint32 cutoffTime = uint32(now).sub(WITHDRAW_BUFFER);\r\n        uint32 maxLength = cutoffTime.sub(MAY_FIRST_2018).div(DAY).add(1);\r\n        uint32[] memory withdrawableDates = new uint32[](maxLength);\r\n        uint256 index = 0;\r\n        uint256 withdrawAmount = 0;\r\n        uint32 date = MAY_FIRST_2018;\r\n\r\n        while(date < cutoffTime) {\r\n            if (!dateToContestStatus[date].operationFeeWithdrawn) {\r\n                uint256 amount = calculateOperationFee(date);\r\n                if (amount > 0) {\r\n                    withdrawableDates[index] = date;\r\n                    withdrawAmount = withdrawAmount.add(amount);\r\n                    index += 1;\r\n                }\r\n            }\r\n            date = date.add(DAY);\r\n        } \r\n        return (withdrawableDates, withdrawAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Get contest status, only return complete and bonus numbers if it's been past the withdraw buffer\r\n     * Return -1 for complete and bonus numbers if still before withdraw buffer\r\n     * @notice Doesn't change state\r\n     * @param _date Date to get DailyContestStatus for\r\n     * @return Tuple(numRegistered, numCompleted, bonus)\r\n     */\r\n    function getContestStatusForDate(uint32 _date) external view returns (int256, int256, int256) {\r\n        DailyContestStatus memory dailyContestStatus = dateToContestStatus[_date];\r\n        int256 numRegistered = int256(dailyContestStatus.numRegistered);\r\n        int256 numCompleted = int256(dailyContestStatus.numCompleted);\r\n        int256 bonus = int256(calculateBonus(_date));\r\n\r\n        if (uint32(now) <= _date.add(WITHDRAW_BUFFER)) {\r\n            numCompleted = -1;\r\n            bonus = -1;\r\n        }\r\n        return (numRegistered, numCompleted, bonus);\r\n    }\r\n\r\n    /**\r\n     * @dev Get next valid start date.\r\n     * Tomorrow or the next non-registered date is the next start date\r\n     * @notice Doesn't change state\r\n     * @return Next start date (unix time: uint32)\r\n     */\r\n    function getStartDate() public view returns (uint32) {\r\n        uint32 startDate = getNextDate(uint32(now));\r\n        uint32 lastRegisterDate = getLastRegisterDate();\r\n        if (startDate <= lastRegisterDate) {\r\n            startDate = getNextDate(lastRegisterDate);\r\n        }\r\n        return startDate;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the next UTC midnight date\r\n     * @notice Doesn't change state\r\n     * @param _timestamp (unix time: uint32)\r\n     * @return Next date (unix time: uint32)\r\n     */\r\n    function getNextDate(uint32 _timestamp) internal pure returns (uint32) {\r\n        return getDate(_timestamp.add(DAY));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the date floor (UTC midnight) for a given timestamp\r\n     * @notice Doesn't change state\r\n     * @param _timestamp (unix time: uint32)\r\n     * @return UTC midnight date (unix time: uint32)\r\n     */\r\n    function getDate(uint32 _timestamp) internal pure returns (uint32) {\r\n        return _timestamp.sub(_timestamp % DAY);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the last registered date for a user\r\n     * @notice Doesn't change state\r\n     * @return Last registered date (unix time: uint32), 0 if user has never registered\r\n     */\r\n    function getLastRegisterDate() internal view returns (uint32) {\r\n        uint32[] memory dates = userToDates[msg.sender];\r\n        uint256 pastRegisterCount = dates.length;\r\n\r\n        if(pastRegisterCount == 0) {\r\n            return 0;\r\n        }\r\n        return dates[pastRegisterCount.sub(1)];\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the bonus for a given day\r\n     * @notice Doesn't change state\r\n     * @param _date Date to calculate the bonus for (unix time: uint32)\r\n     * @return Bonus amount (unit256)\r\n     */ \r\n    function calculateBonus(uint32 _date) internal view returns (uint256) {\r\n        DailyContestStatus memory status = dateToContestStatus[_date];\r\n        if (status.numCompleted == 0) {\r\n            return 0;\r\n        }\r\n        uint256 numFailed = status.numRegistered.sub(status.numCompleted);\r\n        // Split 90% of the forfeited deposits between completed users\r\n        return numFailed.mul(REGISTRATION_FEE).mul(9).div(\r\n            status.numCompleted.mul(10)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the operation fee for a given day\r\n     * @notice Doesn't change state\r\n     * @param _date Date to calculate the operation fee for (unix time: uint32)\r\n     * @return Operation fee amount (unit256)\r\n     */ \r\n    function calculateOperationFee(uint32 _date) internal view returns (uint256) {\r\n        DailyContestStatus memory status = dateToContestStatus[_date];\r\n        // if no one has completed, take all as operation fee\r\n        if (status.numCompleted == 0) {\r\n            return status.numRegistered.mul(REGISTRATION_FEE);\r\n        }\r\n        uint256 numFailed = status.numRegistered.sub(status.numCompleted);\r\n        // 10% of forefeited deposits \r\n        return numFailed.mul(REGISTRATION_FEE).div(10);\r\n    }\r\n\r\n    /********************\r\n     * Admin only methods\r\n     ********************/\r\n\r\n    /**\r\n     * @dev Adding an admin, owner only\r\n     * @notice Changes state\r\n     * @param _newAdmin Address of new admin\r\n     */ \r\n    function addAdmin(address _newAdmin) external {\r\n        require(msg.sender == owner);\r\n        adminPermission[_newAdmin] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Return all registered dates for a user, admin only\r\n     * @notice Doesn't change state\r\n     * @param _user User to get dates for\r\n     * @return All dates(uint32[]) the user registered for\r\n     */ \r\n    function getDatesForUser(address _user) external view returns (uint32[]) {\r\n        if (!adminPermission[msg.sender]) {\r\n           return new uint32[](0); \r\n        }\r\n        return userToDates[_user];\r\n    }\r\n\r\n    /**\r\n     * @dev Return all registered users for a date, admin only\r\n     * @notice Doesn't change state\r\n     * @param _date Date to get users for\r\n     * @return All users(address[]) registered on a given date\r\n     */ \r\n    function getUsersForDate(uint32 _date) external view returns (address[]) {\r\n        if (!adminPermission[msg.sender]) {\r\n           return new address[](0); \r\n        }\r\n        return dateToUsers[_date];\r\n    }\r\n\r\n    /**\r\n     * @dev Return entry status for a user and date, admin only\r\n     * @notice Doesn't change state\r\n     * @param _user User to get EntryStatus for\r\n     * @param _date (unix time: uint32) Date to get EntryStatus for\r\n     * @return UserEntryStatus\r\n     */ \r\n    function getEntryStatus(address _user, uint32 _date)\r\n    external view returns (UserEntryStatus) {\r\n        if (!adminPermission[msg.sender]) {\r\n            return UserEntryStatus.NULL;\r\n        }\r\n        return userDateToStatus[_user][_date];\r\n    }\r\n\r\n    /**\r\n     * @dev Get daily contest status, admin only\r\n     * @notice Doesn't change state\r\n     * @param _date Date to get DailyContestStatus for\r\n     * @return Tuple(uint256, uint256, bool)\r\n     */\r\n    function getContestStatusForDateAdmin(uint32 _date)\r\n    external view returns (uint256, uint256, bool) {\r\n        if (!adminPermission[msg.sender]) {\r\n            return (0, 0, false);\r\n        }\r\n        DailyContestStatus memory dailyContestStatus = dateToContestStatus[_date];\r\n        return (\r\n            dailyContestStatus.numRegistered,\r\n            dailyContestStatus.numCompleted,\r\n            dailyContestStatus.operationFeeWithdrawn\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawableDates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_expectedStartDate\",\"type\":\"uint32\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dates\",\"type\":\"uint32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_date\",\"type\":\"uint32\"}],\"name\":\"getContestStatusForDateAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_date\",\"type\":\"uint32\"}],\"name\":\"getEntryStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateWithdrawableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_date\",\"type\":\"uint32\"}],\"name\":\"getContestStatusForDate\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_date\",\"type\":\"uint32\"}],\"name\":\"getUsersForDate\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dates\",\"type\":\"uint32[]\"}],\"name\":\"withdrawOperationFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawableOperationFeeDatesAndAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserEntryStatuses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"},{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDatesForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogOperationFeeWithdraw\",\"type\":\"event\"}]","ContractName":"Habits","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e4b7eb5aab92e167110de2e1a166aa193b17d2c61e50d1e335a94d3e9fd491d1"}]}