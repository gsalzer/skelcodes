{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if(address(OAR)==0) oraclize_setNetwork(networkID_auto);\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n   }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int)\r\n    {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n\r\n}\r\n// </ORACLIZE_API>\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract coinback is owned,usingOraclize {\r\n\r\n    using SafeMath for uint256;\r\n    struct betInfo{\r\n        address srcAddress;\r\n        uint256 betValue;\r\n    }\r\n\r\n    uint256 private POOL_AWARD;\r\n    uint256 constant FREE_PERCENT = 1;\r\n\r\n    uint32 private oraclizeGas = 200000;\r\n    uint32 constant MAX_RANDOM_NUM = 1000000;\r\n    betInfo private overBetPlayer;\r\n    uint256 private betId;\r\n\r\n    uint256 private turnId;\r\n    uint256 private beginTime;\r\n    uint256 private totalAward;\r\n    uint256 private realAward;\r\n\r\n    bool public stopContract;\r\n    bool public stopBet;\r\n    bool private exitOverPlayer;\r\n    bool private generateRandom;\r\n    uint256 private randomBalance;\r\n    mapping(uint256=>betInfo) private betMap;\r\n    uint256 private randomNum;\r\n\r\n    event LOG_NewTurn(uint256 turnNo,uint256 time,uint256 totalnum);\r\n    event LOG_PlayerBet(address srcAddress,uint256 betNum,uint256 turnNo,uint256 totalnum,uint256 time);\r\n    event LOG_LuckyPLayer(address luckyAddress,uint256 luckyNum,uint256 turnNo);\r\n    event LOG_Random(uint256 random);\r\n    modifier onlyOwner {\r\n        if (owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notStopContract {\r\n        if (stopContract) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notStopBet {\r\n        if (stopBet) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notBiger{\r\n        if(msg.value > POOL_AWARD) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyRandom{\r\n        if(!generateRandom) throw;\r\n        _;\r\n    }\r\n\r\n    function coinback(uint256 initPool){\r\n        POOL_AWARD = initPool;\r\n        turnId = 0;\r\n        stopContract = false;\r\n        exitOverPlayer = false;\r\n        betId = 0;\r\n        generateRandom = false;\r\n        startNewTurn();\r\n    }\r\n\r\n    function ()payable {\r\n        bet();\r\n    }\r\n\r\n    function bet() payable\r\n        notStopContract\r\n        notStopBet\r\n        notBiger\r\n        {\r\n\r\n        uint256 betValue = msg.value;\r\n        totalAward = address(this).balance;\r\n        if(totalAward > POOL_AWARD)\r\n            totalAward = POOL_AWARD;\r\n\r\n        realAward = totalAward;\r\n\r\n        if(address(this).balance >= POOL_AWARD)\r\n        {\r\n            uint256 overValue = address(this).balance.sub(POOL_AWARD);\r\n            if(overValue > 0)\r\n            {\r\n                betValue = betValue.sub(overValue);\r\n                overBetPlayer = betInfo({srcAddress:msg.sender,betValue:overValue});\r\n                exitOverPlayer = true;\r\n            }\r\n            stopBet = true;\r\n        }\r\n        betMap[betId] = betInfo({srcAddress:msg.sender,betValue:betValue});\r\n        betId = betId.add(1);\r\n\r\n        LOG_PlayerBet(msg.sender,betValue,turnId,totalAward,beginTime);\r\n\r\n        if(stopBet)\r\n          closeThisTurn();\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result) {\r\n        if (msg.sender != oraclize_cbAddress()) throw;\r\n\r\n        randomNum = parseInt(result);\r\n        generateRandom = true;\r\n        LOG_Random(randomNum);\r\n    }\r\n\r\n    function afterCallBack() onlyOwner\r\n        onlyRandom{\r\n\r\n        generateRandom = false;\r\n        totalAward = address(this).balance;\r\n        if(totalAward > POOL_AWARD)\r\n            totalAward = POOL_AWARD;\r\n\r\n        randomBalance = totalAward.mul(randomNum).div(MAX_RANDOM_NUM);\r\n        uint256 index = getLunckyIndex();\r\n        uint256 winCoin = totalAward.mul(100-FREE_PERCENT).div(100);\r\n        uint256 waiterfree = totalAward.mul(FREE_PERCENT).div(100);\r\n\r\n        LOG_LuckyPLayer(betMap[index].srcAddress,realAward,turnId);\r\n\r\n        if(!betMap[index].srcAddress.send(winCoin)) throw;\r\n        if(!owner.send(waiterfree)) throw;\r\n\r\n        startNewTurn();\r\n\r\n    }\r\n    function getLunckyIndex() private returns(uint256){\r\n\r\n        uint256 range = 0;\r\n        for(uint256 i =0; i< betId; i++)\r\n        {\r\n            range = range.add(betMap[i].betValue);\r\n            if(range >= randomBalance)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function startNewTurn() private{\r\n\r\n        clearBetMap();\r\n        betId = 0;\r\n        turnId = turnId.add(1);\r\n        beginTime = now;\r\n        totalAward = address(this).balance;\r\n        stopBet = false;\r\n        if(exitOverPlayer)\r\n        {\r\n            betMap[betId] = overBetPlayer;\r\n            betId = betId.add(1);\r\n            exitOverPlayer = false;\r\n            LOG_PlayerBet(overBetPlayer.srcAddress,overBetPlayer.betValue,turnId,totalAward,beginTime);\r\n        }\r\n        LOG_NewTurn(turnId,beginTime,totalAward);\r\n    }\r\n\r\n    function clearBetMap() private{\r\n        for(uint256 i=0;i<betId;i++){\r\n            delete betMap[i];\r\n        }\r\n    }\r\n\r\n    function closeThisTurn() private{\r\n\r\n        bytes32 oid = oraclize_query(\"URL\",\"https://www.random.org/integers/?num=1&min=1&max=1000000&col=1&base=10&format=plain&rnd=new\",oraclizeGas);\r\n    }\r\n\r\n    function closeTurnByHand(uint256 no) onlyOwner{\r\n        if(turnId != no) throw;\r\n        if(address(this).balance == 0) throw;\r\n        stopBet = true;\r\n        closeThisTurn();\r\n    }\r\n\r\n    function killContract() onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function destroyContract() onlyOwner{\r\n        stopContract = true;\r\n    }\r\n\r\n    function changeOwner(address newOwner) onlyOwner{\r\n        owner = newOwner;\r\n    }\r\n\r\n    function resetState() onlyOwner{\r\n        stopBet = false;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"afterCallBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"no\",\"type\":\"uint256\"}],\"name\":\"closeTurnByHand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopBet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initPool\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"turnNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalnum\",\"type\":\"uint256\"}],\"name\":\"LOG_NewTurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"srcAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"turnNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalnum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LOG_PlayerBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"luckyAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"luckyNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"turnNo\",\"type\":\"uint256\"}],\"name\":\"LOG_LuckyPLayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"random\",\"type\":\"uint256\"}],\"name\":\"LOG_Random\",\"type\":\"event\"}]","ContractName":"coinback","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000008ac7230489e80000","Library":"","SwarmSource":"bzzr://873274c4b1f95fa9084246800cac09b37569d0da88f1e32a759f57307f8fb283"}]}