{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n// File: attrstore/AttributeStore.sol\r\n\r\npragma solidity^0.4.11;\r\n\r\nlibrary AttributeStore {\r\n    struct Data {\r\n        mapping(bytes32 => uint) store;\r\n    }\r\n\r\n    function getAttribute(Data storage self, bytes32 _UUID, string _attrName)\r\n    public view returns (uint) {\r\n        bytes32 key = keccak256(_UUID, _attrName);\r\n        return self.store[key];\r\n    }\r\n\r\n    function setAttribute(Data storage self, bytes32 _UUID, string _attrName, uint _attrVal)\r\n    public {\r\n        bytes32 key = keccak256(_UUID, _attrName);\r\n        self.store[key] = _attrVal;\r\n    }\r\n}\r\n\r\n// File: dll/DLL.sol\r\n\r\npragma solidity^0.4.11;\r\n\r\nlibrary DLL {\r\n\r\n  uint constant NULL_NODE_ID = 0;\r\n\r\n  struct Node {\r\n    uint next;\r\n    uint prev;\r\n  }\r\n\r\n  struct Data {\r\n    mapping(uint => Node) dll;\r\n  }\r\n\r\n  function isEmpty(Data storage self) public view returns (bool) {\r\n    return getStart(self) == NULL_NODE_ID;\r\n  }\r\n\r\n  function contains(Data storage self, uint _curr) public view returns (bool) {\r\n    if (isEmpty(self) || _curr == NULL_NODE_ID) {\r\n      return false;\r\n    } \r\n\r\n    bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);\r\n    bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);\r\n    return isSingleNode || !isNullNode;\r\n  }\r\n\r\n  function getNext(Data storage self, uint _curr) public view returns (uint) {\r\n    return self.dll[_curr].next;\r\n  }\r\n\r\n  function getPrev(Data storage self, uint _curr) public view returns (uint) {\r\n    return self.dll[_curr].prev;\r\n  }\r\n\r\n  function getStart(Data storage self) public view returns (uint) {\r\n    return getNext(self, NULL_NODE_ID);\r\n  }\r\n\r\n  function getEnd(Data storage self) public view returns (uint) {\r\n    return getPrev(self, NULL_NODE_ID);\r\n  }\r\n\r\n  /**\r\n  @dev Inserts a new node between _prev and _next. When inserting a node already existing in \r\n  the list it will be automatically removed from the old position.\r\n  @param _prev the node which _new will be inserted after\r\n  @param _curr the id of the new node being inserted\r\n  @param _next the node which _new will be inserted before\r\n  */\r\n  function insert(Data storage self, uint _prev, uint _curr, uint _next) public {\r\n    require(_curr != NULL_NODE_ID);\r\n\r\n    remove(self, _curr);\r\n\r\n    require(_prev == NULL_NODE_ID || contains(self, _prev));\r\n    require(_next == NULL_NODE_ID || contains(self, _next));\r\n\r\n    require(getNext(self, _prev) == _next);\r\n    require(getPrev(self, _next) == _prev);\r\n\r\n    self.dll[_curr].prev = _prev;\r\n    self.dll[_curr].next = _next;\r\n\r\n    self.dll[_prev].next = _curr;\r\n    self.dll[_next].prev = _curr;\r\n  }\r\n\r\n  function remove(Data storage self, uint _curr) public {\r\n    if (!contains(self, _curr)) {\r\n      return;\r\n    }\r\n\r\n    uint next = getNext(self, _curr);\r\n    uint prev = getPrev(self, _curr);\r\n\r\n    self.dll[next].prev = prev;\r\n    self.dll[prev].next = next;\r\n\r\n    delete self.dll[_curr];\r\n  }\r\n}\r\n\r\n// File: tokens/eip20/EIP20Interface.sol\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\npragma solidity ^0.4.8;\r\n\r\ncontract EIP20Interface {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// File: zeppelin/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: plcr-revival/PLCRVoting.sol\r\n\r\n/**\r\n@title Partial-Lock-Commit-Reveal Voting scheme with ERC20 tokens\r\n@author Team: Aspyn Palatnick, Cem Ozer, Yorke Rhodes\r\n*/\r\ncontract PLCRVoting {\r\n\r\n    // ============\r\n    // EVENTS:\r\n    // ============\r\n\r\n    event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter);\r\n    event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter);\r\n    event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator);\r\n    event _VotingRightsGranted(uint numTokens, address indexed voter);\r\n    event _VotingRightsWithdrawn(uint numTokens, address indexed voter);\r\n    event _TokensRescued(uint indexed pollID, address indexed voter);\r\n\r\n    // ============\r\n    // DATA STRUCTURES:\r\n    // ============\r\n\r\n    using AttributeStore for AttributeStore.Data;\r\n    using DLL for DLL.Data;\r\n    using SafeMath for uint;\r\n\r\n    struct Poll {\r\n        uint commitEndDate;     /// expiration date of commit period for poll\r\n        uint revealEndDate;     /// expiration date of reveal period for poll\r\n        uint voteQuorum;\t    /// number of votes required for a proposal to pass\r\n        uint votesFor;\t\t    /// tally of votes supporting proposal\r\n        uint votesAgainst;      /// tally of votes countering proposal\r\n        mapping(address => bool) didCommit;  /// indicates whether an address committed a vote for this poll\r\n        mapping(address => bool) didReveal;   /// indicates whether an address revealed a vote for this poll\r\n    }\r\n\r\n    // ============\r\n    // STATE VARIABLES:\r\n    // ============\r\n\r\n    uint constant public INITIAL_POLL_NONCE = 0;\r\n    uint public pollNonce;\r\n\r\n    mapping(uint => Poll) public pollMap; // maps pollID to Poll struct\r\n    mapping(address => uint) public voteTokenBalance; // maps user's address to voteToken balance\r\n\r\n    mapping(address => DLL.Data) dllMap;\r\n    AttributeStore.Data store;\r\n\r\n    EIP20Interface public token;\r\n\r\n    /**\r\n    @dev Initializer. Can only be called once.\r\n    @param _token The address where the ERC20 token contract is deployed\r\n    */\r\n    function init(address _token) public {\r\n        require(_token != 0 && address(token) == 0);\r\n\r\n        token = EIP20Interface(_token);\r\n        pollNonce = INITIAL_POLL_NONCE;\r\n    }\r\n\r\n    // ================\r\n    // TOKEN INTERFACE:\r\n    // ================\r\n\r\n    /**\r\n    @notice Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights\r\n    @dev Assumes that msg.sender has approved voting contract to spend on their behalf\r\n    @param _numTokens The number of votingTokens desired in exchange for ERC20 tokens\r\n    */\r\n    function requestVotingRights(uint _numTokens) public {\r\n        require(token.balanceOf(msg.sender) >= _numTokens);\r\n        voteTokenBalance[msg.sender] += _numTokens;\r\n        require(token.transferFrom(msg.sender, this, _numTokens));\r\n        emit _VotingRightsGranted(_numTokens, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @notice Withdraw _numTokens ERC20 tokens from the voting contract, revoking these voting rights\r\n    @param _numTokens The number of ERC20 tokens desired in exchange for voting rights\r\n    */\r\n    function withdrawVotingRights(uint _numTokens) external {\r\n        uint availableTokens = voteTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));\r\n        require(availableTokens >= _numTokens);\r\n        voteTokenBalance[msg.sender] -= _numTokens;\r\n        require(token.transfer(msg.sender, _numTokens));\r\n        emit _VotingRightsWithdrawn(_numTokens, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev Unlocks tokens locked in unrevealed vote where poll has ended\r\n    @param _pollID Integer identifier associated with the target poll\r\n    */\r\n    function rescueTokens(uint _pollID) public {\r\n        require(isExpired(pollMap[_pollID].revealEndDate));\r\n        require(dllMap[msg.sender].contains(_pollID));\r\n\r\n        dllMap[msg.sender].remove(_pollID);\r\n        emit _TokensRescued(_pollID, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev Unlocks tokens locked in unrevealed votes where polls have ended\r\n    @param _pollIDs Array of integer identifiers associated with the target polls\r\n    */\r\n    function rescueTokensInMultiplePolls(uint[] _pollIDs) public {\r\n        // loop through arrays, rescuing tokens from all\r\n        for (uint i = 0; i < _pollIDs.length; i++) {\r\n            rescueTokens(_pollIDs[i]);\r\n        }\r\n    }\r\n\r\n    // =================\r\n    // VOTING INTERFACE:\r\n    // =================\r\n\r\n    /**\r\n    @notice Commits vote using hash of choice and secret salt to conceal vote until reveal\r\n    @param _pollID Integer identifier associated with target poll\r\n    @param _secretHash Commit keccak256 hash of voter's choice and salt (tightly packed in this order)\r\n    @param _numTokens The number of tokens to be committed towards the target poll\r\n    @param _prevPollID The ID of the poll that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\r\n    */\r\n    function commitVote(uint _pollID, bytes32 _secretHash, uint _numTokens, uint _prevPollID) public {\r\n        require(commitPeriodActive(_pollID));\r\n\r\n        // if msg.sender doesn't have enough voting rights,\r\n        // request for enough voting rights\r\n        if (voteTokenBalance[msg.sender] < _numTokens) {\r\n            uint remainder = _numTokens.sub(voteTokenBalance[msg.sender]);\r\n            requestVotingRights(remainder);\r\n        }\r\n\r\n        // make sure msg.sender has enough voting rights\r\n        require(voteTokenBalance[msg.sender] >= _numTokens);\r\n        // prevent user from committing to zero node placeholder\r\n        require(_pollID != 0);\r\n        // prevent user from committing a secretHash of 0\r\n        require(_secretHash != 0);\r\n\r\n        // Check if _prevPollID exists in the user's DLL or if _prevPollID is 0\r\n        require(_prevPollID == 0 || dllMap[msg.sender].contains(_prevPollID));\r\n\r\n        uint nextPollID = dllMap[msg.sender].getNext(_prevPollID);\r\n\r\n        // edge case: in-place update\r\n        if (nextPollID == _pollID) {\r\n            nextPollID = dllMap[msg.sender].getNext(_pollID);\r\n        }\r\n\r\n        require(validPosition(_prevPollID, nextPollID, msg.sender, _numTokens));\r\n        dllMap[msg.sender].insert(_prevPollID, _pollID, nextPollID);\r\n\r\n        bytes32 UUID = attrUUID(msg.sender, _pollID);\r\n\r\n        store.setAttribute(UUID, \"numTokens\", _numTokens);\r\n        store.setAttribute(UUID, \"commitHash\", uint(_secretHash));\r\n\r\n        pollMap[_pollID].didCommit[msg.sender] = true;\r\n        emit _VoteCommitted(_pollID, _numTokens, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @notice                 Commits votes using hashes of choices and secret salts to conceal votes until reveal\r\n    @param _pollIDs         Array of integer identifiers associated with target polls\r\n    @param _secretHashes    Array of commit keccak256 hashes of voter's choices and salts (tightly packed in this order)\r\n    @param _numsTokens      Array of numbers of tokens to be committed towards the target polls\r\n    @param _prevPollIDs     Array of IDs of the polls that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\r\n    */\r\n    function commitVotes(uint[] _pollIDs, bytes32[] _secretHashes, uint[] _numsTokens, uint[] _prevPollIDs) external {\r\n        // make sure the array lengths are all the same\r\n        require(_pollIDs.length == _secretHashes.length);\r\n        require(_pollIDs.length == _numsTokens.length);\r\n        require(_pollIDs.length == _prevPollIDs.length);\r\n\r\n        // loop through arrays, committing each individual vote values\r\n        for (uint i = 0; i < _pollIDs.length; i++) {\r\n            commitVote(_pollIDs[i], _secretHashes[i], _numsTokens[i], _prevPollIDs[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @dev Compares previous and next poll's committed tokens for sorting purposes\r\n    @param _prevID Integer identifier associated with previous poll in sorted order\r\n    @param _nextID Integer identifier associated with next poll in sorted order\r\n    @param _voter Address of user to check DLL position for\r\n    @param _numTokens The number of tokens to be committed towards the poll (used for sorting)\r\n    @return valid Boolean indication of if the specified position maintains the sort\r\n    */\r\n    function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public constant returns (bool valid) {\r\n        bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));\r\n        // if next is zero node, _numTokens does not need to be greater\r\n        bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);\r\n        return prevValid && nextValid;\r\n    }\r\n\r\n    /**\r\n    @notice Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens\r\n    @param _pollID Integer identifier associated with target poll\r\n    @param _voteOption Vote choice used to generate commitHash for associated poll\r\n    @param _salt Secret number used to generate commitHash for associated poll\r\n    */\r\n    function revealVote(uint _pollID, uint _voteOption, uint _salt) public {\r\n        // Make sure the reveal period is active\r\n        require(revealPeriodActive(_pollID));\r\n        require(pollMap[_pollID].didCommit[msg.sender]);                         // make sure user has committed a vote for this poll\r\n        require(!pollMap[_pollID].didReveal[msg.sender]);                        // prevent user from revealing multiple times\r\n        require(keccak256(_voteOption, _salt) == getCommitHash(msg.sender, _pollID)); // compare resultant hash from inputs to original commitHash\r\n\r\n        uint numTokens = getNumTokens(msg.sender, _pollID);\r\n\r\n        if (_voteOption == 1) {// apply numTokens to appropriate poll choice\r\n            pollMap[_pollID].votesFor += numTokens;\r\n        } else {\r\n            pollMap[_pollID].votesAgainst += numTokens;\r\n        }\r\n\r\n        dllMap[msg.sender].remove(_pollID); // remove the node referring to this vote upon reveal\r\n        pollMap[_pollID].didReveal[msg.sender] = true;\r\n\r\n        emit _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @notice             Reveals multiple votes with choices and secret salts used in generating commitHashes to attribute committed tokens\r\n    @param _pollIDs     Array of integer identifiers associated with target polls\r\n    @param _voteOptions Array of vote choices used to generate commitHashes for associated polls\r\n    @param _salts       Array of secret numbers used to generate commitHashes for associated polls\r\n    */\r\n    function revealVotes(uint[] _pollIDs, uint[] _voteOptions, uint[] _salts) external {\r\n        // make sure the array lengths are all the same\r\n        require(_pollIDs.length == _voteOptions.length);\r\n        require(_pollIDs.length == _salts.length);\r\n\r\n        // loop through arrays, revealing each individual vote values\r\n        for (uint i = 0; i < _pollIDs.length; i++) {\r\n            revealVote(_pollIDs[i], _voteOptions[i], _salts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @param _pollID Integer identifier associated with target poll\r\n    @param _salt Arbitrarily chosen integer used to generate secretHash\r\n    @return correctVotes Number of tokens voted for winning option\r\n    */\r\n    function getNumPassingTokens(address _voter, uint _pollID, uint _salt) public constant returns (uint correctVotes) {\r\n        require(pollEnded(_pollID));\r\n        require(pollMap[_pollID].didReveal[_voter]);\r\n\r\n        uint winningChoice = isPassed(_pollID) ? 1 : 0;\r\n        bytes32 winnerHash = keccak256(winningChoice, _salt);\r\n        bytes32 commitHash = getCommitHash(_voter, _pollID);\r\n\r\n        require(winnerHash == commitHash);\r\n\r\n        return getNumTokens(_voter, _pollID);\r\n    }\r\n\r\n    // ==================\r\n    // POLLING INTERFACE:\r\n    // ==================\r\n\r\n    /**\r\n    @dev Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event\r\n    @param _voteQuorum Type of majority (out of 100) that is necessary for poll to be successful\r\n    @param _commitDuration Length of desired commit period in seconds\r\n    @param _revealDuration Length of desired reveal period in seconds\r\n    */\r\n    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\r\n        pollNonce = pollNonce + 1;\r\n\r\n        uint commitEndDate = block.timestamp.add(_commitDuration);\r\n        uint revealEndDate = commitEndDate.add(_revealDuration);\r\n\r\n        pollMap[pollNonce] = Poll({\r\n            voteQuorum: _voteQuorum,\r\n            commitEndDate: commitEndDate,\r\n            revealEndDate: revealEndDate,\r\n            votesFor: 0,\r\n            votesAgainst: 0\r\n        });\r\n\r\n        emit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\r\n        return pollNonce;\r\n    }\r\n\r\n    /**\r\n    @notice Determines if proposal has passed\r\n    @dev Check if votesFor out of totalVotes exceeds votesQuorum (requires pollEnded)\r\n    @param _pollID Integer identifier associated with target poll\r\n    */\r\n    function isPassed(uint _pollID) constant public returns (bool passed) {\r\n        require(pollEnded(_pollID));\r\n\r\n        Poll memory poll = pollMap[_pollID];\r\n        return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\r\n    }\r\n\r\n    // ----------------\r\n    // POLLING HELPERS:\r\n    // ----------------\r\n\r\n    /**\r\n    @dev Gets the total winning votes for reward distribution purposes\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Total number of votes committed to the winning option for specified poll\r\n    */\r\n    function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint numTokens) {\r\n        require(pollEnded(_pollID));\r\n\r\n        if (isPassed(_pollID))\r\n            return pollMap[_pollID].votesFor;\r\n        else\r\n            return pollMap[_pollID].votesAgainst;\r\n    }\r\n\r\n    /**\r\n    @notice Determines if poll is over\r\n    @dev Checks isExpired for specified poll's revealEndDate\r\n    @return Boolean indication of whether polling period is over\r\n    */\r\n    function pollEnded(uint _pollID) constant public returns (bool ended) {\r\n        require(pollExists(_pollID));\r\n\r\n        return isExpired(pollMap[_pollID].revealEndDate);\r\n    }\r\n\r\n    /**\r\n    @notice Checks if the commit period is still active for the specified poll\r\n    @dev Checks isExpired for the specified poll's commitEndDate\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Boolean indication of isCommitPeriodActive for target poll\r\n    */\r\n    function commitPeriodActive(uint _pollID) constant public returns (bool active) {\r\n        require(pollExists(_pollID));\r\n\r\n        return !isExpired(pollMap[_pollID].commitEndDate);\r\n    }\r\n\r\n    /**\r\n    @notice Checks if the reveal period is still active for the specified poll\r\n    @dev Checks isExpired for the specified poll's revealEndDate\r\n    @param _pollID Integer identifier associated with target poll\r\n    */\r\n    function revealPeriodActive(uint _pollID) constant public returns (bool active) {\r\n        require(pollExists(_pollID));\r\n\r\n        return !isExpired(pollMap[_pollID].revealEndDate) && !commitPeriodActive(_pollID);\r\n    }\r\n\r\n    /**\r\n    @dev Checks if user has committed for specified poll\r\n    @param _voter Address of user to check against\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Boolean indication of whether user has committed\r\n    */\r\n    function didCommit(address _voter, uint _pollID) constant public returns (bool committed) {\r\n        require(pollExists(_pollID));\r\n\r\n        return pollMap[_pollID].didCommit[_voter];\r\n    }\r\n\r\n    /**\r\n    @dev Checks if user has revealed for specified poll\r\n    @param _voter Address of user to check against\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Boolean indication of whether user has revealed\r\n    */\r\n    function didReveal(address _voter, uint _pollID) constant public returns (bool revealed) {\r\n        require(pollExists(_pollID));\r\n\r\n        return pollMap[_pollID].didReveal[_voter];\r\n    }\r\n\r\n    /**\r\n    @dev Checks if a poll exists\r\n    @param _pollID The pollID whose existance is to be evaluated.\r\n    @return Boolean Indicates whether a poll exists for the provided pollID\r\n    */\r\n    function pollExists(uint _pollID) constant public returns (bool exists) {\r\n        return (_pollID != 0 && _pollID <= pollNonce);\r\n    }\r\n\r\n    // ---------------------------\r\n    // DOUBLE-LINKED-LIST HELPERS:\r\n    // ---------------------------\r\n\r\n    /**\r\n    @dev Gets the bytes32 commitHash property of target poll\r\n    @param _voter Address of user to check against\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Bytes32 hash property attached to target poll\r\n    */\r\n    function getCommitHash(address _voter, uint _pollID) constant public returns (bytes32 commitHash) {\r\n        return bytes32(store.getAttribute(attrUUID(_voter, _pollID), \"commitHash\"));\r\n    }\r\n\r\n    /**\r\n    @dev Wrapper for getAttribute with attrName=\"numTokens\"\r\n    @param _voter Address of user to check against\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return Number of tokens committed to poll in sorted poll-linked-list\r\n    */\r\n    function getNumTokens(address _voter, uint _pollID) constant public returns (uint numTokens) {\r\n        return store.getAttribute(attrUUID(_voter, _pollID), \"numTokens\");\r\n    }\r\n\r\n    /**\r\n    @dev Gets top element of sorted poll-linked-list\r\n    @param _voter Address of user to check against\r\n    @return Integer identifier to poll with maximum number of tokens committed to it\r\n    */\r\n    function getLastNode(address _voter) constant public returns (uint pollID) {\r\n        return dllMap[_voter].getPrev(0);\r\n    }\r\n\r\n    /**\r\n    @dev Gets the numTokens property of getLastNode\r\n    @param _voter Address of user to check against\r\n    @return Maximum number of tokens committed in poll specified\r\n    */\r\n    function getLockedTokens(address _voter) constant public returns (uint numTokens) {\r\n        return getNumTokens(_voter, getLastNode(_voter));\r\n    }\r\n\r\n    /*\r\n    @dev Takes the last node in the user's DLL and iterates backwards through the list searching\r\n    for a node with a value less than or equal to the provided _numTokens value. When such a node\r\n    is found, if the provided _pollID matches the found nodeID, this operation is an in-place\r\n    update. In that case, return the previous node of the node being updated. Otherwise return the\r\n    first node that was found with a value less than or equal to the provided _numTokens.\r\n    @param _voter The voter whose DLL will be searched\r\n    @param _numTokens The value for the numTokens attribute in the node to be inserted\r\n    @return the node which the propoded node should be inserted after\r\n    */\r\n    function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _pollID)\r\n    constant public returns (uint prevNode) {\r\n      // Get the last node in the list and the number of tokens in that node\r\n      uint nodeID = getLastNode(_voter);\r\n      uint tokensInNode = getNumTokens(_voter, nodeID);\r\n\r\n      // Iterate backwards through the list until reaching the root node\r\n      while(nodeID != 0) {\r\n        // Get the number of tokens in the current node\r\n        tokensInNode = getNumTokens(_voter, nodeID);\r\n        if(tokensInNode <= _numTokens) { // We found the insert point!\r\n          if(nodeID == _pollID) {\r\n            // This is an in-place update. Return the prev node of the node being updated\r\n            nodeID = dllMap[_voter].getPrev(nodeID);\r\n          }\r\n          // Return the insert point\r\n          return nodeID; \r\n        }\r\n        // We did not find the insert point. Continue iterating backwards through the list\r\n        nodeID = dllMap[_voter].getPrev(nodeID);\r\n      }\r\n\r\n      // The list is empty, or a smaller value than anything else in the list is being inserted\r\n      return nodeID;\r\n    }\r\n\r\n    // ----------------\r\n    // GENERAL HELPERS:\r\n    // ----------------\r\n\r\n    /**\r\n    @dev Checks if an expiration date has been reached\r\n    @param _terminationDate Integer timestamp of date to compare current timestamp with\r\n    @return expired Boolean indication of whether the terminationDate has passed\r\n    */\r\n    function isExpired(uint _terminationDate) constant public returns (bool expired) {\r\n        return (block.timestamp > _terminationDate);\r\n    }\r\n\r\n    /**\r\n    @dev Generates an identifier which associates a user and a poll together\r\n    @param _pollID Integer identifier associated with target poll\r\n    @return UUID Hash which is deterministic from _user and _pollID\r\n    */\r\n    function attrUUID(address _user, uint _pollID) public pure returns (bytes32 UUID) {\r\n        return keccak256(_user, _pollID);\r\n    }\r\n}\r\n\r\n// File: contracts/Parameterizer.sol\r\n\r\npragma solidity^0.4.11;\r\n\r\n\r\n\r\n\r\ncontract Parameterizer {\r\n\r\n    // ------\r\n    // EVENTS\r\n    // ------\r\n\r\n    event _ReparameterizationProposal(string name, uint value, bytes32 propID, uint deposit, uint appEndDate, address indexed proposer);\r\n    event _NewChallenge(bytes32 indexed propID, uint challengeID, uint commitEndDate, uint revealEndDate, address indexed challenger);\r\n    event _ProposalAccepted(bytes32 indexed propID, string name, uint value);\r\n    event _ProposalExpired(bytes32 indexed propID);\r\n    event _ChallengeSucceeded(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\r\n    event _ChallengeFailed(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\r\n    event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\r\n\r\n\r\n    // ------\r\n    // DATA STRUCTURES\r\n    // ------\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct ParamProposal {\r\n        uint appExpiry;\r\n        uint challengeID;\r\n        uint deposit;\r\n        string name;\r\n        address owner;\r\n        uint processBy;\r\n        uint value;\r\n    }\r\n\r\n    struct Challenge {\r\n        uint rewardPool;        // (remaining) pool of tokens distributed amongst winning voters\r\n        address challenger;     // owner of Challenge\r\n        bool resolved;          // indication of if challenge is resolved\r\n        uint stake;             // number of tokens at risk for either party during challenge\r\n        uint winningTokens;     // (remaining) amount of tokens used for voting by the winning side\r\n        mapping(address => bool) tokenClaims;\r\n    }\r\n\r\n    // ------\r\n    // STATE\r\n    // ------\r\n\r\n    mapping(bytes32 => uint) public params;\r\n\r\n    // maps challengeIDs to associated challenge data\r\n    mapping(uint => Challenge) public challenges;\r\n\r\n    // maps pollIDs to intended data change if poll passes\r\n    mapping(bytes32 => ParamProposal) public proposals;\r\n\r\n    // Global Variables\r\n    EIP20Interface public token;\r\n    PLCRVoting public voting;\r\n    uint public PROCESSBY = 604800; // 7 days\r\n\r\n    /**\r\n    @dev Initializer        Can only be called once\r\n    @param _token           The address where the ERC20 token contract is deployed\r\n    @param _plcr            address of a PLCR voting contract for the provided token\r\n    @notice _parameters     array of canonical parameters\r\n    */\r\n    function init(\r\n        address _token,\r\n        address _plcr,\r\n        uint[] _parameters\r\n    ) public {\r\n        require(_token != 0 && address(token) == 0);\r\n        require(_plcr != 0 && address(voting) == 0);\r\n\r\n        token = EIP20Interface(_token);\r\n        voting = PLCRVoting(_plcr);\r\n\r\n        // minimum deposit for listing to be whitelisted\r\n        set(\"minDeposit\", _parameters[0]);\r\n        \r\n        // minimum deposit to propose a reparameterization\r\n        set(\"pMinDeposit\", _parameters[1]);\r\n\r\n        // period over which applicants wait to be whitelisted\r\n        set(\"applyStageLen\", _parameters[2]);\r\n\r\n        // period over which reparmeterization proposals wait to be processed\r\n        set(\"pApplyStageLen\", _parameters[3]);\r\n\r\n        // length of commit period for voting\r\n        set(\"commitStageLen\", _parameters[4]);\r\n        \r\n        // length of commit period for voting in parameterizer\r\n        set(\"pCommitStageLen\", _parameters[5]);\r\n        \r\n        // length of reveal period for voting\r\n        set(\"revealStageLen\", _parameters[6]);\r\n\r\n        // length of reveal period for voting in parameterizer\r\n        set(\"pRevealStageLen\", _parameters[7]);\r\n\r\n        // percentage of losing party's deposit distributed to winning party\r\n        set(\"dispensationPct\", _parameters[8]);\r\n\r\n        // percentage of losing party's deposit distributed to winning party in parameterizer\r\n        set(\"pDispensationPct\", _parameters[9]);\r\n\r\n        // type of majority out of 100 necessary for candidate success\r\n        set(\"voteQuorum\", _parameters[10]);\r\n\r\n        // type of majority out of 100 necessary for proposal success in parameterizer\r\n        set(\"pVoteQuorum\", _parameters[11]);\r\n    }\r\n\r\n    // -----------------------\r\n    // TOKEN HOLDER INTERFACE\r\n    // -----------------------\r\n\r\n    /**\r\n    @notice propose a reparamaterization of the key _name's value to _value.\r\n    @param _name the name of the proposed param to be set\r\n    @param _value the proposed value to set the param to be set\r\n    */\r\n    function proposeReparameterization(string _name, uint _value) public returns (bytes32) {\r\n        uint deposit = get(\"pMinDeposit\");\r\n        bytes32 propID = keccak256(_name, _value);\r\n\r\n        if (keccak256(_name) == keccak256(\"dispensationPct\") ||\r\n            keccak256(_name) == keccak256(\"pDispensationPct\")) {\r\n            require(_value <= 100);\r\n        }\r\n\r\n        require(!propExists(propID)); // Forbid duplicate proposals\r\n        require(get(_name) != _value); // Forbid NOOP reparameterizations\r\n\r\n        // attach name and value to pollID\r\n        proposals[propID] = ParamProposal({\r\n            appExpiry: now.add(get(\"pApplyStageLen\")),\r\n            challengeID: 0,\r\n            deposit: deposit,\r\n            name: _name,\r\n            owner: msg.sender,\r\n            processBy: now.add(get(\"pApplyStageLen\"))\r\n                .add(get(\"pCommitStageLen\"))\r\n                .add(get(\"pRevealStageLen\"))\r\n                .add(PROCESSBY),\r\n            value: _value\r\n        });\r\n\r\n        require(token.transferFrom(msg.sender, this, deposit)); // escrow tokens (deposit amt)\r\n\r\n        emit _ReparameterizationProposal(_name, _value, propID, deposit, proposals[propID].appExpiry, msg.sender);\r\n        return propID;\r\n    }\r\n\r\n    /**\r\n    @notice challenge the provided proposal ID, and put tokens at stake to do so.\r\n    @param _propID the proposal ID to challenge\r\n    */\r\n    function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {\r\n        ParamProposal memory prop = proposals[_propID];\r\n        uint deposit = prop.deposit;\r\n\r\n        require(propExists(_propID) && prop.challengeID == 0);\r\n\r\n        //start poll\r\n        uint pollID = voting.startPoll(\r\n            get(\"pVoteQuorum\"),\r\n            get(\"pCommitStageLen\"),\r\n            get(\"pRevealStageLen\")\r\n        );\r\n\r\n        challenges[pollID] = Challenge({\r\n            challenger: msg.sender,\r\n            rewardPool: SafeMath.sub(100, get(\"pDispensationPct\")).mul(deposit).div(100),\r\n            stake: deposit,\r\n            resolved: false,\r\n            winningTokens: 0\r\n        });\r\n\r\n        proposals[_propID].challengeID = pollID;       // update listing to store most recent challenge\r\n\r\n        //take tokens from challenger\r\n        require(token.transferFrom(msg.sender, this, deposit));\r\n\r\n        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\r\n\r\n        emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);\r\n        return pollID;\r\n    }\r\n\r\n    /**\r\n    @notice             for the provided proposal ID, set it, resolve its challenge, or delete it depending on whether it can be set, has a challenge which can be resolved, or if its \"process by\" date has passed\r\n    @param _propID      the proposal ID to make a determination and state transition for\r\n    */\r\n    function processProposal(bytes32 _propID) public {\r\n        ParamProposal storage prop = proposals[_propID];\r\n        address propOwner = prop.owner;\r\n        uint propDeposit = prop.deposit;\r\n\r\n        \r\n        // Before any token transfers, deleting the proposal will ensure that if reentrancy occurs the\r\n        // prop.owner and prop.deposit will be 0, thereby preventing theft\r\n        if (canBeSet(_propID)) {\r\n            // There is no challenge against the proposal. The processBy date for the proposal has not\r\n            // passed, but the proposal's appExpirty date has passed.\r\n            set(prop.name, prop.value);\r\n            emit _ProposalAccepted(_propID, prop.name, prop.value);\r\n            delete proposals[_propID];\r\n            require(token.transfer(propOwner, propDeposit));\r\n        } else if (challengeCanBeResolved(_propID)) {\r\n            // There is a challenge against the proposal.\r\n            resolveChallenge(_propID);\r\n        } else if (now > prop.processBy) {\r\n            // There is no challenge against the proposal, but the processBy date has passed.\r\n            emit _ProposalExpired(_propID);\r\n            delete proposals[_propID];\r\n            require(token.transfer(propOwner, propDeposit));\r\n        } else {\r\n            // There is no challenge against the proposal, and neither the appExpiry date nor the\r\n            // processBy date has passed.\r\n            revert();\r\n        }\r\n\r\n        assert(get(\"dispensationPct\") <= 100);\r\n        assert(get(\"pDispensationPct\") <= 100);\r\n\r\n        // verify that future proposal appExpiry and processBy times will not overflow\r\n        now.add(get(\"pApplyStageLen\"))\r\n            .add(get(\"pCommitStageLen\"))\r\n            .add(get(\"pRevealStageLen\"))\r\n            .add(PROCESSBY);\r\n\r\n        delete proposals[_propID];\r\n    }\r\n\r\n    /**\r\n    @notice                 Claim the tokens owed for the msg.sender in the provided challenge\r\n    @param _challengeID     the challenge ID to claim tokens for\r\n    @param _salt            the salt used to vote in the challenge being withdrawn for\r\n    */\r\n    function claimReward(uint _challengeID, uint _salt) public {\r\n        // ensure voter has not already claimed tokens and challenge results have been processed\r\n        require(challenges[_challengeID].tokenClaims[msg.sender] == false);\r\n        require(challenges[_challengeID].resolved == true);\r\n\r\n        uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\r\n        uint reward = voterReward(msg.sender, _challengeID, _salt);\r\n\r\n        // subtract voter's information to preserve the participation ratios of other voters\r\n        // compared to the remaining pool of rewards\r\n        challenges[_challengeID].winningTokens -= voterTokens;\r\n        challenges[_challengeID].rewardPool -= reward;\r\n\r\n        // ensures a voter cannot claim tokens again\r\n        challenges[_challengeID].tokenClaims[msg.sender] = true;\r\n\r\n        emit _RewardClaimed(_challengeID, reward, msg.sender);\r\n        require(token.transfer(msg.sender, reward));\r\n    }\r\n\r\n    /**\r\n    @dev                    Called by a voter to claim their rewards for each completed vote.\r\n                            Someone must call updateStatus() before this can be called.\r\n    @param _challengeIDs    The PLCR pollIDs of the challenges rewards are being claimed for\r\n    @param _salts           The salts of a voter's commit hashes in the given polls\r\n    */\r\n    function claimRewards(uint[] _challengeIDs, uint[] _salts) public {\r\n        // make sure the array lengths are the same\r\n        require(_challengeIDs.length == _salts.length);\r\n\r\n        // loop through arrays, claiming each individual vote reward\r\n        for (uint i = 0; i < _challengeIDs.length; i++) {\r\n            claimReward(_challengeIDs[i], _salts[i]);\r\n        }\r\n    }\r\n\r\n    // --------\r\n    // GETTERS\r\n    // --------\r\n\r\n    /**\r\n    @dev                Calculates the provided voter's token reward for the given poll.\r\n    @param _voter       The address of the voter whose reward balance is to be returned\r\n    @param _challengeID The ID of the challenge the voter's reward is being calculated for\r\n    @param _salt        The salt of the voter's commit hash in the given poll\r\n    @return             The uint indicating the voter's reward\r\n    */\r\n    function voterReward(address _voter, uint _challengeID, uint _salt)\r\n    public view returns (uint) {\r\n        uint winningTokens = challenges[_challengeID].winningTokens;\r\n        uint rewardPool = challenges[_challengeID].rewardPool;\r\n        uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\r\n        return (voterTokens * rewardPool) / winningTokens;\r\n    }\r\n\r\n    /**\r\n    @notice Determines whether a proposal passed its application stage without a challenge\r\n    @param _propID The proposal ID for which to determine whether its application stage passed without a challenge\r\n    */\r\n    function canBeSet(bytes32 _propID) view public returns (bool) {\r\n        ParamProposal memory prop = proposals[_propID];\r\n\r\n        return (now > prop.appExpiry && now < prop.processBy && prop.challengeID == 0);\r\n    }\r\n\r\n    /**\r\n    @notice Determines whether a proposal exists for the provided proposal ID\r\n    @param _propID The proposal ID whose existance is to be determined\r\n    */\r\n    function propExists(bytes32 _propID) view public returns (bool) {\r\n        return proposals[_propID].processBy > 0;\r\n    }\r\n\r\n    /**\r\n    @notice Determines whether the provided proposal ID has a challenge which can be resolved\r\n    @param _propID The proposal ID whose challenge to inspect\r\n    */\r\n    function challengeCanBeResolved(bytes32 _propID) view public returns (bool) {\r\n        ParamProposal memory prop = proposals[_propID];\r\n        Challenge memory challenge = challenges[prop.challengeID];\r\n\r\n        return (prop.challengeID > 0 && challenge.resolved == false && voting.pollEnded(prop.challengeID));\r\n    }\r\n\r\n    /**\r\n    @notice Determines the number of tokens to awarded to the winning party in a challenge\r\n    @param _challengeID The challengeID to determine a reward for\r\n    */\r\n    function challengeWinnerReward(uint _challengeID) public view returns (uint) {\r\n        if(voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\r\n            // Edge case, nobody voted, give all tokens to the challenger.\r\n            return 2 * challenges[_challengeID].stake;\r\n        }\r\n\r\n        return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\r\n    }\r\n\r\n    /**\r\n    @notice gets the parameter keyed by the provided name value from the params mapping\r\n    @param _name the key whose value is to be determined\r\n    */\r\n    function get(string _name) public view returns (uint value) {\r\n        return params[keccak256(_name)];\r\n    }\r\n\r\n    /**\r\n    @dev                Getter for Challenge tokenClaims mappings\r\n    @param _challengeID The challengeID to query\r\n    @param _voter       The voter whose claim status to query for the provided challengeID\r\n    */\r\n    function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\r\n        return challenges[_challengeID].tokenClaims[_voter];\r\n    }\r\n\r\n    // ----------------\r\n    // PRIVATE FUNCTIONS\r\n    // ----------------\r\n\r\n    /**\r\n    @dev resolves a challenge for the provided _propID. It must be checked in advance whether the _propID has a challenge on it\r\n    @param _propID the proposal ID whose challenge is to be resolved.\r\n    */\r\n    function resolveChallenge(bytes32 _propID) private {\r\n        ParamProposal memory prop = proposals[_propID];\r\n        Challenge storage challenge = challenges[prop.challengeID];\r\n\r\n        // winner gets back their full staked deposit, and dispensationPct*loser's stake\r\n        uint reward = challengeWinnerReward(prop.challengeID);\r\n\r\n        challenge.winningTokens = voting.getTotalNumberOfTokensForWinningOption(prop.challengeID);\r\n        challenge.resolved = true;\r\n\r\n        if (voting.isPassed(prop.challengeID)) { // The challenge failed\r\n            if(prop.processBy > now) {\r\n                set(prop.name, prop.value);\r\n            }\r\n            emit _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\r\n            require(token.transfer(prop.owner, reward));\r\n        }\r\n        else { // The challenge succeeded or nobody voted\r\n            emit _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\r\n            require(token.transfer(challenges[prop.challengeID].challenger, reward));\r\n        }\r\n    }\r\n\r\n    /**\r\n    @dev sets the param keted by the provided name to the provided value\r\n    @param _name the name of the param to be set\r\n    @param _value the value to set the param to be set\r\n    */\r\n    function set(string _name, uint _value) private {\r\n        params[keccak256(_name)] = _value;\r\n    }\r\n}\r\n\r\n// File: plcr-revival/ProxyFactory.sol\r\n\r\n/***\r\n* Shoutouts:\r\n* \r\n* Bytecode origin https://www.reddit.com/r/ethereum/comments/6ic49q/any_assembly_programmers_willing_to_write_a/dj5ceuw/\r\n* Modified version of Vitalik's https://www.reddit.com/r/ethereum/comments/6c1jui/delegatecall_forwarders_how_to_save_5098_on/\r\n* Credits to Jorge Izquierdo (@izqui) for coming up with this design here: https://gist.github.com/izqui/7f904443e6d19c1ab52ec7f5ad46b3a8\r\n* Credits to Stefan George (@Georgi87) for inspiration for many of the improvements from Gnosis Safe: https://github.com/gnosis/gnosis-safe-contracts\r\n* \r\n* This version has many improvements over the original @izqui's library like using REVERT instead of THROWing on failed calls.\r\n* It also implements the awesome design pattern for initializing code as seen in Gnosis Safe Factory: https://github.com/gnosis/gnosis-safe-contracts/blob/master/contracts/ProxyFactory.sol\r\n* but unlike this last one it doesn't require that you waste storage on both the proxy and the proxied contracts (v. https://github.com/gnosis/gnosis-safe-contracts/blob/master/contracts/Proxy.sol#L8 & https://github.com/gnosis/gnosis-safe-contracts/blob/master/contracts/GnosisSafe.sol#L14)\r\n* \r\n* \r\n* v0.0.2\r\n* The proxy is now only 60 bytes long in total. Constructor included.\r\n* No functionalities were added. The change was just to make the proxy leaner.\r\n* \r\n* v0.0.3\r\n* Thanks @dacarley for noticing the incorrect check for the subsequent call to the proxy. ?\r\n* Note: I'm creating a new version of this that doesn't need that one call.\r\n*       Will add tests and put this in its own repository soonâ„¢. \r\n* \r\n* v0.0.4\r\n* All the merit in this fix + update of the factory is @dacarley 's. ?\r\n* Thank you! ?\r\n*\r\n* Potential updates can be found at https://gist.github.com/GNSPS/ba7b88565c947cfd781d44cf469c2ddb\r\n* \r\n***/\r\n\r\npragma solidity ^0.4.19;\r\n\r\n/* solhint-disable no-inline-assembly, indent, state-visibility, avoid-low-level-calls */\r\n\r\ncontract ProxyFactory {\r\n    event ProxyDeployed(address proxyAddress, address targetAddress);\r\n    event ProxiesDeployed(address[] proxyAddresses, address targetAddress);\r\n\r\n    function createManyProxies(uint256 _count, address _target, bytes _data)\r\n        public\r\n    {\r\n        address[] memory proxyAddresses = new address[](_count);\r\n\r\n        for (uint256 i = 0; i < _count; ++i) {\r\n            proxyAddresses[i] = createProxyImpl(_target, _data);\r\n        }\r\n\r\n        ProxiesDeployed(proxyAddresses, _target);\r\n    }\r\n\r\n    function createProxy(address _target, bytes _data)\r\n        public\r\n        returns (address proxyContract)\r\n    {\r\n        proxyContract = createProxyImpl(_target, _data);\r\n\r\n        ProxyDeployed(proxyContract, _target);\r\n    }\r\n    \r\n    function createProxyImpl(address _target, bytes _data)\r\n        internal\r\n        returns (address proxyContract)\r\n    {\r\n        assembly {\r\n            let contractCode := mload(0x40) // Find empty storage location using \"free memory pointer\"\r\n           \r\n            mstore(add(contractCode, 0x0b), _target) // Add target address, with a 11 bytes [i.e. 23 - (32 - 20)] offset to later accomodate first part of the bytecode\r\n            mstore(sub(contractCode, 0x09), 0x000000000000000000603160008181600b9039f3600080808080368092803773) // First part of the bytecode, shifted left by 9 bytes, overwrites left padding of target address\r\n            mstore(add(contractCode, 0x2b), 0x5af43d828181803e808314602f57f35bfd000000000000000000000000000000) // Final part of bytecode, offset by 43 bytes\r\n\r\n            proxyContract := create(0, contractCode, 60) // total length 60 bytes\r\n            if iszero(extcodesize(proxyContract)) {\r\n                revert(0, 0)\r\n            }\r\n           \r\n            // check if the _data.length > 0 and if it is forward it to the newly created contract\r\n            let dataLength := mload(_data) \r\n            if iszero(iszero(dataLength)) {\r\n                if iszero(call(gas, proxyContract, 0, add(_data, 0x20), dataLength, 0, 0)) {\r\n                    revert(0, 0)\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: tokens/eip20/EIP20.sol\r\n\r\n/*\r\nImplements EIP20 token standard: https://github.com/ethereum/EIPs/issues/20\r\n.*/\r\npragma solidity ^0.4.8;\r\n\r\n\r\ncontract EIP20 is EIP20Interface {\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show.\r\n    string public symbol;                 //An identifier: eg SBX\r\n\r\n     function EIP20(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) public {\r\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        // Update total supply\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) view public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n    view public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\n// File: plcr-revival/PLCRFactory.sol\r\n\r\ncontract PLCRFactory {\r\n\r\n  event newPLCR(address creator, EIP20 token, PLCRVoting plcr);\r\n\r\n  ProxyFactory public proxyFactory;\r\n  PLCRVoting public canonizedPLCR;\r\n\r\n  /// @dev constructor deploys a new canonical PLCRVoting contract and a proxyFactory.\r\n  constructor() {\r\n    canonizedPLCR = new PLCRVoting();\r\n    proxyFactory = new ProxyFactory();\r\n  }\r\n\r\n  /*\r\n  @dev deploys and initializes a new PLCRVoting contract that consumes a token at an address\r\n  supplied by the user.\r\n  @param _token an EIP20 token to be consumed by the new PLCR contract\r\n  */\r\n  function newPLCRBYOToken(EIP20 _token) public returns (PLCRVoting) {\r\n    PLCRVoting plcr = PLCRVoting(proxyFactory.createProxy(canonizedPLCR, \"\"));\r\n    plcr.init(_token);\r\n\r\n    emit newPLCR(msg.sender, _token, plcr);\r\n\r\n    return plcr;\r\n  }\r\n  \r\n  /*\r\n  @dev deploys and initializes a new PLCRVoting contract and an EIP20 to be consumed by the PLCR's\r\n  initializer.\r\n  @param _supply the total number of tokens to mint in the EIP20 contract\r\n  @param _name the name of the new EIP20 token\r\n  @param _decimals the decimal precision to be used in rendering balances in the EIP20 token\r\n  @param _symbol the symbol of the new EIP20 token\r\n  */\r\n  function newPLCRWithToken(\r\n    uint _supply,\r\n    string _name,\r\n    uint8 _decimals,\r\n    string _symbol\r\n  ) public returns (PLCRVoting) {\r\n    // Create a new token and give all the tokens to the PLCR creator\r\n    EIP20 token = new EIP20(_supply, _name, _decimals, _symbol);\r\n    token.transfer(msg.sender, _supply);\r\n\r\n    // Create and initialize a new PLCR contract\r\n    PLCRVoting plcr = PLCRVoting(proxyFactory.createProxy(canonizedPLCR, \"\"));\r\n    plcr.init(token);\r\n\r\n    emit newPLCR(msg.sender, token, plcr);\r\n\r\n    return plcr;\r\n  }\r\n}\r\n\r\n// File: contracts/ParameterizerFactory.sol\r\n\r\ncontract ParameterizerFactory {\r\n\r\n    event NewParameterizer(address creator, address token, address plcr, Parameterizer parameterizer);\r\n\r\n    PLCRFactory public plcrFactory;\r\n    ProxyFactory public proxyFactory;\r\n    Parameterizer public canonizedParameterizer;\r\n\r\n    /// @dev constructor deploys a new canonical Parameterizer contract and a proxyFactory.\r\n    constructor(PLCRFactory _plcrFactory) public {\r\n        plcrFactory = _plcrFactory;\r\n        proxyFactory = plcrFactory.proxyFactory();\r\n        canonizedParameterizer = new Parameterizer();\r\n    }\r\n\r\n    /*\r\n    @dev deploys and initializes a new Parameterizer contract that consumes a token at an address\r\n    supplied by the user.\r\n    @param _token             an EIP20 token to be consumed by the new Parameterizer contract\r\n    @param _plcr              a PLCR voting contract to be consumed by the new Parameterizer contract\r\n    @param _parameters        array of canonical parameters\r\n    */\r\n    function newParameterizerBYOToken(\r\n        EIP20 _token,\r\n        uint[] _parameters\r\n    ) public returns (Parameterizer) {\r\n        PLCRVoting plcr = plcrFactory.newPLCRBYOToken(_token);\r\n        Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, \"\"));\r\n\r\n        parameterizer.init(\r\n            _token,\r\n            plcr,\r\n            _parameters\r\n        );\r\n        emit NewParameterizer(msg.sender, _token, plcr, parameterizer);\r\n        return parameterizer;\r\n    }\r\n\r\n    /*\r\n    @dev deploys and initializes new EIP20, PLCRVoting, and Parameterizer contracts\r\n    @param _supply            the total number of tokens to mint in the EIP20 contract\r\n    @param _name              the name of the new EIP20 token\r\n    @param _decimals          the decimal precision to be used in rendering balances in the EIP20 token\r\n    @param _symbol            the symbol of the new EIP20 token\r\n    @param _parameters        array of canonical parameters\r\n    */\r\n    function newParameterizerWithToken(\r\n        uint _supply,\r\n        string _name,\r\n        uint8 _decimals,\r\n        string _symbol,\r\n        uint[] _parameters\r\n    ) public returns (Parameterizer) {\r\n        // Creates a new EIP20 token & transfers the supply to creator (msg.sender)\r\n        // Deploys & initializes a new PLCRVoting contract\r\n        PLCRVoting plcr = plcrFactory.newPLCRWithToken(_supply, _name, _decimals, _symbol);\r\n        EIP20 token = EIP20(plcr.token());\r\n        token.transfer(msg.sender, _supply);\r\n\r\n        // Create & initialize a new Parameterizer contract\r\n        Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, \"\"));\r\n        parameterizer.init(\r\n            token,\r\n            plcr,\r\n            _parameters\r\n        );\r\n\r\n        emit NewParameterizer(msg.sender, token, plcr, parameterizer);\r\n        return parameterizer;\r\n    }\r\n}\r\n\r\n// File: contracts/Registry.sol\r\n\r\ncontract Registry {\r\n\r\n    // ------\r\n    // EVENTS\r\n    // ------\r\n\r\n    event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data, address indexed applicant);\r\n    event _Challenge(bytes32 indexed listingHash, uint challengeID, string data, uint commitEndDate, uint revealEndDate, address indexed challenger);\r\n    event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal, address indexed owner);\r\n    event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal, address indexed owner);\r\n    event _ApplicationWhitelisted(bytes32 indexed listingHash);\r\n    event _ApplicationRemoved(bytes32 indexed listingHash);\r\n    event _ListingRemoved(bytes32 indexed listingHash);\r\n    event _ListingWithdrawn(bytes32 indexed listingHash);\r\n    event _TouchAndRemoved(bytes32 indexed listingHash);\r\n    event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\r\n    event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\r\n    event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Listing {\r\n        uint applicationExpiry; // Expiration date of apply stage\r\n        bool whitelisted;       // Indicates registry status\r\n        address owner;          // Owner of Listing\r\n        uint unstakedDeposit;   // Number of tokens in the listing not locked in a challenge\r\n        uint challengeID;       // Corresponds to a PollID in PLCRVoting\r\n    }\r\n\r\n    struct Challenge {\r\n        uint rewardPool;        // (remaining) Pool of tokens to be distributed to winning voters\r\n        address challenger;     // Owner of Challenge\r\n        bool resolved;          // Indication of if challenge is resolved\r\n        uint stake;             // Number of tokens at stake for either party during challenge\r\n        uint totalTokens;       // (remaining) Number of tokens used in voting by the winning side\r\n        mapping(address => bool) tokenClaims; // Indicates whether a voter has claimed a reward yet\r\n    }\r\n\r\n    // Maps challengeIDs to associated challenge data\r\n    mapping(uint => Challenge) public challenges;\r\n\r\n    // Maps listingHashes to associated listingHash data\r\n    mapping(bytes32 => Listing) public listings;\r\n\r\n    // Global Variables\r\n    EIP20Interface public token;\r\n    PLCRVoting public voting;\r\n    Parameterizer public parameterizer;\r\n    string public name;\r\n\r\n    /**\r\n    @dev Initializer. Can only be called once.\r\n    @param _token The address where the ERC20 token contract is deployed\r\n    */\r\n    function init(address _token, address _voting, address _parameterizer, string _name) public {\r\n        require(_token != 0 && address(token) == 0);\r\n        require(_voting != 0 && address(voting) == 0);\r\n        require(_parameterizer != 0 && address(parameterizer) == 0);\r\n\r\n        token = EIP20Interface(_token);\r\n        voting = PLCRVoting(_voting);\r\n        parameterizer = Parameterizer(_parameterizer);\r\n        name = _name;\r\n    }\r\n\r\n    // --------------------\r\n    // PUBLISHER INTERFACE:\r\n    // --------------------\r\n\r\n    /**\r\n    @dev                Allows a user to start an application. Takes tokens from user and sets\r\n                        apply stage end time.\r\n    @param _listingHash The hash of a potential listing a user is applying to add to the registry\r\n    @param _amount      The number of ERC20 tokens a user is willing to potentially stake\r\n    @param _data        Extra data relevant to the application. Think IPFS hashes.\r\n    */\r\n    function apply(bytes32 _listingHash, uint _amount, string _data) external {\r\n        require(!isWhitelisted(_listingHash));\r\n        require(!appWasMade(_listingHash));\r\n        require(_amount >= parameterizer.get(\"minDeposit\"));\r\n\r\n        // Sets owner\r\n        Listing storage listing = listings[_listingHash];\r\n        listing.owner = msg.sender;\r\n\r\n        // Sets apply stage end time\r\n        listing.applicationExpiry = block.timestamp.add(parameterizer.get(\"applyStageLen\"));\r\n        listing.unstakedDeposit = _amount;\r\n\r\n        // Transfers tokens from user to Registry contract\r\n        require(token.transferFrom(listing.owner, this, _amount));\r\n\r\n        emit _Application(_listingHash, _amount, listing.applicationExpiry, _data, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev                Allows the owner of a listingHash to increase their unstaked deposit.\r\n    @param _listingHash A listingHash msg.sender is the owner of\r\n    @param _amount      The number of ERC20 tokens to increase a user's unstaked deposit\r\n    */\r\n    function deposit(bytes32 _listingHash, uint _amount) external {\r\n        Listing storage listing = listings[_listingHash];\r\n\r\n        require(listing.owner == msg.sender);\r\n\r\n        listing.unstakedDeposit += _amount;\r\n        require(token.transferFrom(msg.sender, this, _amount));\r\n\r\n        emit _Deposit(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev                Allows the owner of a listingHash to decrease their unstaked deposit.\r\n    @param _listingHash A listingHash msg.sender is the owner of.\r\n    @param _amount      The number of ERC20 tokens to withdraw from the unstaked deposit.\r\n    */\r\n    function withdraw(bytes32 _listingHash, uint _amount) external {\r\n        Listing storage listing = listings[_listingHash];\r\n\r\n        require(listing.owner == msg.sender);\r\n        require(_amount <= listing.unstakedDeposit);\r\n        require(listing.unstakedDeposit - _amount >= parameterizer.get(\"minDeposit\"));\r\n\r\n        listing.unstakedDeposit -= _amount;\r\n        require(token.transfer(msg.sender, _amount));\r\n\r\n        emit _Withdrawal(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev                Allows the owner of a listingHash to remove the listingHash from the whitelist\r\n                        Returns all tokens to the owner of the listingHash\r\n    @param _listingHash A listingHash msg.sender is the owner of.\r\n    */\r\n    function exit(bytes32 _listingHash) external {\r\n        Listing storage listing = listings[_listingHash];\r\n\r\n        require(msg.sender == listing.owner);\r\n        require(isWhitelisted(_listingHash));\r\n\r\n        // Cannot exit during ongoing challenge\r\n        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\r\n\r\n        // Remove listingHash & return tokens\r\n        resetListing(_listingHash);\r\n        emit _ListingWithdrawn(_listingHash);\r\n    }\r\n\r\n    // -----------------------\r\n    // TOKEN HOLDER INTERFACE:\r\n    // -----------------------\r\n\r\n    /**\r\n    @dev                Starts a poll for a listingHash which is either in the apply stage or\r\n                        already in the whitelist. Tokens are taken from the challenger and the\r\n                        applicant's deposits are locked.\r\n    @param _listingHash The listingHash being challenged, whether listed or in application\r\n    @param _data        Extra data relevant to the challenge. Think IPFS hashes.\r\n    */\r\n    function challenge(bytes32 _listingHash, string _data) external returns (uint challengeID) {\r\n        Listing storage listing = listings[_listingHash];\r\n        uint minDeposit = parameterizer.get(\"minDeposit\");\r\n\r\n        // Listing must be in apply stage or already on the whitelist\r\n        require(appWasMade(_listingHash) || listing.whitelisted);\r\n        // Prevent multiple challenges\r\n        require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\r\n\r\n        if (listing.unstakedDeposit < minDeposit) {\r\n            // Not enough tokens, listingHash auto-delisted\r\n            resetListing(_listingHash);\r\n            emit _TouchAndRemoved(_listingHash);\r\n            return 0;\r\n        }\r\n\r\n        // Starts poll\r\n        uint pollID = voting.startPoll(\r\n            parameterizer.get(\"voteQuorum\"),\r\n            parameterizer.get(\"commitStageLen\"),\r\n            parameterizer.get(\"revealStageLen\")\r\n        );\r\n\r\n        uint oneHundred = 100; // Kludge that we need to use SafeMath\r\n        challenges[pollID] = Challenge({\r\n            challenger: msg.sender,\r\n            rewardPool: ((oneHundred.sub(parameterizer.get(\"dispensationPct\"))).mul(minDeposit)).div(100),\r\n            stake: minDeposit,\r\n            resolved: false,\r\n            totalTokens: 0\r\n        });\r\n\r\n        // Updates listingHash to store most recent challenge\r\n        listing.challengeID = pollID;\r\n\r\n        // Locks tokens for listingHash during challenge\r\n        listing.unstakedDeposit -= minDeposit;\r\n\r\n        // Takes tokens from challenger\r\n        require(token.transferFrom(msg.sender, this, minDeposit));\r\n\r\n        var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\r\n\r\n        emit _Challenge(_listingHash, pollID, _data, commitEndDate, revealEndDate, msg.sender);\r\n        return pollID;\r\n    }\r\n\r\n    /**\r\n    @dev                Updates a listingHash's status from 'application' to 'listing' or resolves\r\n                        a challenge if one exists.\r\n    @param _listingHash The listingHash whose status is being updated\r\n    */\r\n    function updateStatus(bytes32 _listingHash) public {\r\n        if (canBeWhitelisted(_listingHash)) {\r\n            whitelistApplication(_listingHash);\r\n        } else if (challengeCanBeResolved(_listingHash)) {\r\n            resolveChallenge(_listingHash);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    @dev                  Updates an array of listingHashes' status from 'application' to 'listing' or resolves\r\n                          a challenge if one exists.\r\n    @param _listingHashes The listingHashes whose status are being updated\r\n    */\r\n    function updateStatuses(bytes32[] _listingHashes) public {\r\n        // loop through arrays, revealing each individual vote values\r\n        for (uint i = 0; i < _listingHashes.length; i++) {\r\n            updateStatus(_listingHashes[i]);\r\n        }\r\n    }\r\n\r\n    // ----------------\r\n    // TOKEN FUNCTIONS:\r\n    // ----------------\r\n\r\n    /**\r\n    @dev                Called by a voter to claim their reward for each completed vote. Someone\r\n                        must call updateStatus() before this can be called.\r\n    @param _challengeID The PLCR pollID of the challenge a reward is being claimed for\r\n    @param _salt        The salt of a voter's commit hash in the given poll\r\n    */\r\n    function claimReward(uint _challengeID, uint _salt) public {\r\n        // Ensures the voter has not already claimed tokens and challenge results have been processed\r\n        require(challenges[_challengeID].tokenClaims[msg.sender] == false);\r\n        require(challenges[_challengeID].resolved == true);\r\n\r\n        uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\r\n        uint reward = voterReward(msg.sender, _challengeID, _salt);\r\n\r\n        // Subtracts the voter's information to preserve the participation ratios\r\n        // of other voters compared to the remaining pool of rewards\r\n        challenges[_challengeID].totalTokens -= voterTokens;\r\n        challenges[_challengeID].rewardPool -= reward;\r\n\r\n        // Ensures a voter cannot claim tokens again\r\n        challenges[_challengeID].tokenClaims[msg.sender] = true;\r\n\r\n        require(token.transfer(msg.sender, reward));\r\n\r\n        emit _RewardClaimed(_challengeID, reward, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev                 Called by a voter to claim their rewards for each completed vote. Someone\r\n                         must call updateStatus() before this can be called.\r\n    @param _challengeIDs The PLCR pollIDs of the challenges rewards are being claimed for\r\n    @param _salts        The salts of a voter's commit hashes in the given polls\r\n    */\r\n    function claimRewards(uint[] _challengeIDs, uint[] _salts) public {\r\n        // make sure the array lengths are the same\r\n        require(_challengeIDs.length == _salts.length);\r\n\r\n        // loop through arrays, claiming each individual vote reward\r\n        for (uint i = 0; i < _challengeIDs.length; i++) {\r\n            claimReward(_challengeIDs[i], _salts[i]);\r\n        }\r\n    }\r\n\r\n    // --------\r\n    // GETTERS:\r\n    // --------\r\n\r\n    /**\r\n    @dev                Calculates the provided voter's token reward for the given poll.\r\n    @param _voter       The address of the voter whose reward balance is to be returned\r\n    @param _challengeID The pollID of the challenge a reward balance is being queried for\r\n    @param _salt        The salt of the voter's commit hash in the given poll\r\n    @return             The uint indicating the voter's reward\r\n    */\r\n    function voterReward(address _voter, uint _challengeID, uint _salt)\r\n    public view returns (uint) {\r\n        uint totalTokens = challenges[_challengeID].totalTokens;\r\n        uint rewardPool = challenges[_challengeID].rewardPool;\r\n        uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\r\n        return (voterTokens * rewardPool) / totalTokens;\r\n    }\r\n\r\n    /**\r\n    @dev                Determines whether the given listingHash be whitelisted.\r\n    @param _listingHash The listingHash whose status is to be examined\r\n    */\r\n    function canBeWhitelisted(bytes32 _listingHash) view public returns (bool) {\r\n        uint challengeID = listings[_listingHash].challengeID;\r\n\r\n        // Ensures that the application was made,\r\n        // the application period has ended,\r\n        // the listingHash can be whitelisted,\r\n        // and either: the challengeID == 0, or the challenge has been resolved.\r\n        if (\r\n            appWasMade(_listingHash) &&\r\n            listings[_listingHash].applicationExpiry < now &&\r\n            !isWhitelisted(_listingHash) &&\r\n            (challengeID == 0 || challenges[challengeID].resolved == true)\r\n        ) { return true; }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    @dev                Returns true if the provided listingHash is whitelisted\r\n    @param _listingHash The listingHash whose status is to be examined\r\n    */\r\n    function isWhitelisted(bytes32 _listingHash) view public returns (bool whitelisted) {\r\n        return listings[_listingHash].whitelisted;\r\n    }\r\n\r\n    /**\r\n    @dev                Returns true if apply was called for this listingHash\r\n    @param _listingHash The listingHash whose status is to be examined\r\n    */\r\n    function appWasMade(bytes32 _listingHash) view public returns (bool exists) {\r\n        return listings[_listingHash].applicationExpiry > 0;\r\n    }\r\n\r\n    /**\r\n    @dev                Returns true if the application/listingHash has an unresolved challenge\r\n    @param _listingHash The listingHash whose status is to be examined\r\n    */\r\n    function challengeExists(bytes32 _listingHash) view public returns (bool) {\r\n        uint challengeID = listings[_listingHash].challengeID;\r\n\r\n        return (listings[_listingHash].challengeID > 0 && !challenges[challengeID].resolved);\r\n    }\r\n\r\n    /**\r\n    @dev                Determines whether voting has concluded in a challenge for a given\r\n                        listingHash. Throws if no challenge exists.\r\n    @param _listingHash A listingHash with an unresolved challenge\r\n    */\r\n    function challengeCanBeResolved(bytes32 _listingHash) view public returns (bool) {\r\n        uint challengeID = listings[_listingHash].challengeID;\r\n\r\n        require(challengeExists(_listingHash));\r\n\r\n        return voting.pollEnded(challengeID);\r\n    }\r\n\r\n    /**\r\n    @dev                Determines the number of tokens awarded to the winning party in a challenge.\r\n    @param _challengeID The challengeID to determine a reward for\r\n    */\r\n    function determineReward(uint _challengeID) public view returns (uint) {\r\n        require(!challenges[_challengeID].resolved && voting.pollEnded(_challengeID));\r\n\r\n        // Edge case, nobody voted, give all tokens to the challenger.\r\n        if (voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\r\n            return 2 * challenges[_challengeID].stake;\r\n        }\r\n\r\n        return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\r\n    }\r\n\r\n    /**\r\n    @dev                Getter for Challenge tokenClaims mappings\r\n    @param _challengeID The challengeID to query\r\n    @param _voter       The voter whose claim status to query for the provided challengeID\r\n    */\r\n    function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\r\n        return challenges[_challengeID].tokenClaims[_voter];\r\n    }\r\n\r\n    // ----------------\r\n    // PRIVATE FUNCTIONS:\r\n    // ----------------\r\n\r\n    /**\r\n    @dev                Determines the winner in a challenge. Rewards the winner tokens and\r\n                        either whitelists or de-whitelists the listingHash.\r\n    @param _listingHash A listingHash with a challenge that is to be resolved\r\n    */\r\n    function resolveChallenge(bytes32 _listingHash) private {\r\n        uint challengeID = listings[_listingHash].challengeID;\r\n\r\n        // Calculates the winner's reward,\r\n        // which is: (winner's full stake) + (dispensationPct * loser's stake)\r\n        uint reward = determineReward(challengeID);\r\n\r\n        // Sets flag on challenge being processed\r\n        challenges[challengeID].resolved = true;\r\n\r\n        // Stores the total tokens used for voting by the winning side for reward purposes\r\n        challenges[challengeID].totalTokens =\r\n            voting.getTotalNumberOfTokensForWinningOption(challengeID);\r\n\r\n        // Case: challenge failed\r\n        if (voting.isPassed(challengeID)) {\r\n            whitelistApplication(_listingHash);\r\n            // Unlock stake so that it can be retrieved by the applicant\r\n            listings[_listingHash].unstakedDeposit += reward;\r\n\r\n            emit _ChallengeFailed(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\r\n        }\r\n        // Case: challenge succeeded or nobody voted\r\n        else {\r\n            resetListing(_listingHash);\r\n            // Transfer the reward to the challenger\r\n            require(token.transfer(challenges[challengeID].challenger, reward));\r\n\r\n            emit _ChallengeSucceeded(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @dev                Called by updateStatus() if the applicationExpiry date passed without a\r\n                        challenge being made. Called by resolveChallenge() if an\r\n                        application/listing beat a challenge.\r\n    @param _listingHash The listingHash of an application/listingHash to be whitelisted\r\n    */\r\n    function whitelistApplication(bytes32 _listingHash) private {\r\n        if (!listings[_listingHash].whitelisted) { emit _ApplicationWhitelisted(_listingHash); }\r\n        listings[_listingHash].whitelisted = true;\r\n    }\r\n\r\n    /**\r\n    @dev                Deletes a listingHash from the whitelist and transfers tokens back to owner\r\n    @param _listingHash The listing hash to delete\r\n    */\r\n    function resetListing(bytes32 _listingHash) private {\r\n        Listing storage listing = listings[_listingHash];\r\n\r\n        // Emit events before deleting listing to check whether is whitelisted\r\n        if (listing.whitelisted) {\r\n            emit _ListingRemoved(_listingHash);\r\n        } else {\r\n            emit _ApplicationRemoved(_listingHash);\r\n        }\r\n\r\n        // Deleting listing to prevent reentry\r\n        address owner = listing.owner;\r\n        uint unstakedDeposit = listing.unstakedDeposit;\r\n        delete listings[_listingHash];\r\n        \r\n        // Transfers any remaining balance back to the owner\r\n        if (unstakedDeposit > 0){\r\n            require(token.transfer(owner, unstakedDeposit));\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/RegistryFactory.sol\r\n\r\ncontract RegistryFactory {\r\n\r\n    event NewRegistry(address creator, EIP20 token, PLCRVoting plcr, Parameterizer parameterizer, Registry registry);\r\n\r\n    ParameterizerFactory public parameterizerFactory;\r\n    ProxyFactory public proxyFactory;\r\n    Registry public canonizedRegistry;\r\n\r\n    /// @dev constructor deploys a new proxyFactory.\r\n    constructor(ParameterizerFactory _parameterizerFactory) public {\r\n        parameterizerFactory = _parameterizerFactory;\r\n        proxyFactory = parameterizerFactory.proxyFactory();\r\n        canonizedRegistry = new Registry();\r\n    }\r\n\r\n    /*\r\n    @dev deploys and initializes a new Registry contract that consumes a token at an address\r\n        supplied by the user.\r\n    @param _token           an EIP20 token to be consumed by the new Registry contract\r\n    */\r\n    function newRegistryBYOToken(\r\n        EIP20 _token,\r\n        uint[] _parameters,\r\n        string _name\r\n    ) public returns (Registry) {\r\n        Parameterizer parameterizer = parameterizerFactory.newParameterizerBYOToken(_token, _parameters);\r\n        PLCRVoting plcr = parameterizer.voting();\r\n\r\n        Registry registry = Registry(proxyFactory.createProxy(canonizedRegistry, \"\"));\r\n        registry.init(_token, plcr, parameterizer, _name);\r\n\r\n        emit NewRegistry(msg.sender, _token, plcr, parameterizer, registry);\r\n        return registry;\r\n    }\r\n\r\n    /*\r\n    @dev deploys and initializes a new Registry contract, an EIP20, a PLCRVoting, and Parameterizer\r\n        to be consumed by the Registry's initializer.\r\n    @param _supply          the total number of tokens to mint in the EIP20 contract\r\n    @param _name            the name of the new EIP20 token\r\n    @param _decimals        the decimal precision to be used in rendering balances in the EIP20 token\r\n    @param _symbol          the symbol of the new EIP20 token\r\n    */\r\n    function newRegistryWithToken(\r\n        uint _supply,\r\n        string _tokenName,\r\n        uint8 _decimals,\r\n        string _symbol,\r\n        uint[] _parameters,\r\n        string _registryName\r\n    ) public returns (Registry) {\r\n        // Creates a new EIP20 token & transfers the supply to creator (msg.sender)\r\n        // Deploys & initializes (1) PLCRVoting contract & (2) Parameterizer contract\r\n        Parameterizer parameterizer = parameterizerFactory.newParameterizerWithToken(_supply, _tokenName, _decimals, _symbol, _parameters);\r\n        EIP20 token = EIP20(parameterizer.token());\r\n        token.transfer(msg.sender, _supply);\r\n        PLCRVoting plcr = parameterizer.voting();\r\n\r\n        // Create & initialize a new Registry contract\r\n        Registry registry = Registry(proxyFactory.createProxy(canonizedRegistry, \"\"));\r\n        registry.init(token, plcr, parameterizer, _registryName);\r\n\r\n        emit NewRegistry(msg.sender, token, plcr, parameterizer, registry);\r\n        return registry;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"parameterizerFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_parameters\",\"type\":\"uint256[]\"},{\"name\":\"_registryName\",\"type\":\"string\"}],\"name\":\"newRegistryWithToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_parameters\",\"type\":\"uint256[]\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"newRegistryBYOToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canonizedRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_parameterizerFactory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"plcr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"parameterizer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"NewRegistry\",\"type\":\"event\"}]","ContractName":"RegistryFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000B6695340ffDAFD5FD46Ea1881B6c5e7FFF27eC17","Library":"","SwarmSource":"bzzr://1755346ffa498a76c7f081576457db326eb9ee3bf3cc0d116cf2b7f87a5f909a"}]}