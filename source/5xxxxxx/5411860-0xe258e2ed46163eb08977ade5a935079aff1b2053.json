{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n/**\r\n * @title Array256 Library\r\n * @author Modular Inc, https://modular.network\r\n *\r\n * version 1.2.0\r\n * Copyright (c) 2017 Modular, Inc\r\n * The MIT License (MIT)\r\n * https://github.com/Modular-Network/ethereum-libraries/blob/master/LICENSE\r\n *\r\n * The Array256 Library provides a few utility functions to work with\r\n * storage uint256[] types in place. Modular provides smart contract services\r\n * and security reviews for contract deployments in addition to working on open\r\n * source projects in the Ethereum community. Our purpose is to test, document,\r\n * and deploy reusable code onto the blockchain and improve both security and\r\n * usability. We also educate non-profits, schools, and other community members\r\n * about the application of blockchain technology.\r\n * For further information: Modular.network\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nlibrary Array256Lib {\r\n\r\n  /// @dev Sum vector\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return sum The sum of all elements, does not check for overflow\r\n  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the max value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return maxValue The highest value in the array\r\n  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      maxValue := sload(sha3(0x60,0x20))\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\r\n        case 1 {\r\n          maxValue := sload(add(sha3(0x60,0x20),i))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the minimum value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return minValue The highest value in the array\r\n  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      minValue := sload(sha3(0x60,0x20))\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\r\n        case 0 {\r\n          minValue := sload(add(sha3(0x60,0x20),i))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Finds the index of a given value in an array\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @param value The value to search for\r\n  /// @param isSorted True if the array is sorted, false otherwise\r\n  /// @return found True if the value was found, false otherwise\r\n  /// @return index The index of the given value, returns 0 if found is false\r\n  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\r\n           public\r\n           view\r\n           returns(bool found, uint256 index) {\r\n    assembly{\r\n      mstore(0x60,self_slot)\r\n      switch isSorted\r\n      case 1 {\r\n        let high := sub(sload(self_slot),1)\r\n        let mid := 0\r\n        let low := 0\r\n        for { } iszero(gt(low, high)) { } {\r\n          mid := div(add(low,high),2)\r\n\r\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\r\n          case 1 {\r\n             low := add(mid,1)\r\n          }\r\n          case 0 {\r\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\r\n            case 1 {\r\n              high := sub(mid,1)\r\n            }\r\n            case 0 {\r\n              found := 1\r\n              index := mid\r\n              low := add(high,1)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      case 0 {\r\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\r\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\r\n          case 1 {\r\n            found := 1\r\n            index := low\r\n            low := sload(self_slot)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of child node\r\n  /// @return pI The parent node index\r\n  function getParentI(uint256 index) private pure returns (uint256 pI) {\r\n    uint256 i = index - 1;\r\n    pI = i/2;\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of parent node\r\n  /// @return lcI The index of left child\r\n  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {\r\n    uint256 i = index * 2;\r\n    lcI = i + 1;\r\n  }\r\n\r\n  /// @dev Sorts given array in place\r\n  /// @param self Storage array containing uint256 type variables\r\n  function heapSort(uint256[] storage self) public {\r\n    if(self.length > 1){\r\n      uint256 end = self.length - 1;\r\n      uint256 start = getParentI(end);\r\n      uint256 root = start;\r\n      uint256 lChild;\r\n      uint256 rChild;\r\n      uint256 swap;\r\n      uint256 temp;\r\n      while(start >= 0){\r\n        root = start;\r\n        lChild = getLeftChildI(start);\r\n        while(lChild <= end){\r\n          rChild = lChild + 1;\r\n          swap = root;\r\n          if(self[swap] < self[lChild])\r\n            swap = lChild;\r\n          if((rChild <= end) && (self[swap]<self[rChild]))\r\n            swap = rChild;\r\n          if(swap == root)\r\n            lChild = end+1;\r\n          else {\r\n            temp = self[swap];\r\n            self[swap] = self[root];\r\n            self[root] = temp;\r\n            root = swap;\r\n            lChild = getLeftChildI(root);\r\n          }\r\n        }\r\n        if(start == 0)\r\n          break;\r\n        else\r\n          start = start - 1;\r\n      }\r\n      while(end > 0){\r\n        temp = self[end];\r\n        self[end] = self[0];\r\n        self[0] = temp;\r\n        end = end - 1;\r\n        root = 0;\r\n        lChild = getLeftChildI(0);\r\n        while(lChild <= end){\r\n          rChild = lChild + 1;\r\n          swap = root;\r\n          if(self[swap] < self[lChild])\r\n            swap = lChild;\r\n          if((rChild <= end) && (self[swap]<self[rChild]))\r\n            swap = rChild;\r\n          if(swap == root)\r\n            lChild = end + 1;\r\n          else {\r\n            temp = self[swap];\r\n            self[swap] = self[root];\r\n            self[root] = temp;\r\n            root = swap;\r\n            lChild = getLeftChildI(root);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Removes duplicates from a given array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  function uniq(uint256[] storage self) public returns (uint256 length) {\r\n    bool contains;\r\n    uint256 index;\r\n\r\n    for (uint256 i = 0; i < self.length; i++) {\r\n      (contains, index) = indexOf(self, self[i], false);\r\n\r\n      if (i > index) {\r\n        for (uint256 j = i; j < self.length - 1; j++){\r\n          self[j] = self[j + 1];\r\n        }\r\n\r\n        delete self[self.length - 1];\r\n        self.length--;\r\n        i--;\r\n      }\r\n    }\r\n\r\n    length = self.length;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"uint256[] storage\"}],\"name\":\"uniq\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"self\",\"type\":\"uint256[] storage\"}],\"name\":\"heapSort\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"uint256[] storage\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isSorted\",\"type\":\"bool\"}],\"name\":\"indexOf\",\"outputs\":[{\"name\":\"found\",\"type\":\"bool\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"uint256[] storage\"}],\"name\":\"sumElements\",\"outputs\":[{\"name\":\"sum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"uint256[] storage\"}],\"name\":\"getMax\",\"outputs\":[{\"name\":\"maxValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"self\",\"type\":\"uint256[] storage\"}],\"name\":\"getMin\",\"outputs\":[{\"name\":\"minValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Array256Lib","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2c59b85e2faf240115f7b7ab5afca38f8caa86174646665c171b36b4c70d7e18"}]}