{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\ncontract Partner {\r\n    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\r\n}\r\n\r\ncontract Target {\r\n    function transfer(address _to, uint _value);\r\n}\r\n\r\ncontract MNY {\r\n\r\n    string public name = \"MNY by Monkey Capital\";\r\n    uint8 public decimals = 18;\r\n    string public symbol = \"MNY\";\r\n\r\n    address public owner;\r\n    address public exchangeAdmin;\r\n\r\n    uint256[] tierTokens = [\r\n        5.33696E18,\r\n        7.69493333E18,\r\n        4.75684324E18,\r\n        6.30846753E18,\r\n        6.21620513E18,\r\n        5.63157219E18,\r\n        5.80023669E18,\r\n        5.04458667E18,\r\n        4.58042767E18,\r\n        5E18\r\n    ];\r\n\r\n    uint256[] costPerToken = [\r\n        9E16,\r\n        9E16,\r\n        8E16,\r\n        7E16,\r\n        8E16,\r\n        5E16,\r\n        6E16,\r\n        5E16,\r\n        5E16,\r\n        6E16\r\n    ];\r\n\r\n    // used to store list of contracts MNY holds tokens in\r\n    address[] contracts = [0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0];\r\n\r\n    uint tierLevel = 0;\r\n    uint maxTier = 9;\r\n    uint256 totalSupply = 21000000000000000000000000;\r\n    uint256 circulatingSupply = 0;\r\n    uint contractCount = 1;\r\n\r\n    // flags\r\n    bool public receiveEth = true;\r\n    bool swap = false;\r\n    bool allSwapped = false;\r\n    bool distributionCalculated = false;\r\n\r\n    // Storage\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => uint256) public tokenBalances;\r\n    mapping (address => uint256) public tokenShare;\r\n    mapping (address => uint256) public exchangeRates; // balance and rate in cents (where $1 = 1*10^18)\r\n\r\n    // events\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n\r\n    function MNY() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transfer(address _to, uint _value, bytes _data) public {\r\n        // sender must have enough tokens to transfer\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if(_to == address(this)) {\r\n            if(swap == false) {\r\n                // WARNING: if you transfer tokens back to the contract outside of the swap you will lose them\r\n                // use the exchange function to exchange for tokens with approved partner contracts\r\n                totalSupply = add(totalSupply, _value);\r\n                circulatingSupply = sub(circulatingSupply, _value);\r\n                if(circulatingSupply == 0) allSwapped = true;\r\n                tierTokens[maxTier] = add(tierTokens[maxTier], _value);\r\n                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n                Transfer(msg.sender, _to, _value);\r\n            }\r\n            else {\r\n                require(div(_value, 1 ether) > 0);   // whole tokens only in for swap\r\n                if(distributionCalculated = false) {\r\n                    calculateHeldTokenDistribution();\r\n                }\r\n                balances[msg.sender] = sub(balances[msg.sender], _value);\r\n                shareStoredTokens(msg.sender, div(_value, 1 ether));\r\n            }\r\n        }\r\n        else {\r\n            // WARNING: if you transfer tokens to a contract address they will be lost unless the contract\r\n            // has been designed to handle incoming/holding tokens in other contracts\r\n            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n            balances[_to] = add(balances[_to], _value);\r\n\r\n            Transfer(msg.sender, _to, _value);\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public {\r\n        // sender must have enough tokens to transfer\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        if(_to == address(this)) {\r\n            if(swap == false) {\r\n                // WARNING: if you transfer tokens back to the contract outside of the swap you will lose them\r\n                // use the exchange function to exchange for tokens with approved partner contracts\r\n                totalSupply = add(totalSupply, _value);\r\n                circulatingSupply = sub(circulatingSupply, _value);\r\n                if(circulatingSupply == 0) allSwapped = true;\r\n                tierTokens[maxTier] = add(tierTokens[maxTier], _value);\r\n                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n                Transfer(msg.sender, _to, _value);\r\n            }\r\n            else {\r\n                if(distributionCalculated = false) {\r\n                    calculateHeldTokenDistribution();\r\n                }\r\n                balances[msg.sender] = sub(balances[msg.sender], _value);\r\n                shareStoredTokens(msg.sender, div(_value, 1 ether));\r\n            }\r\n        }\r\n        else {\r\n            // WARNING: if you transfer tokens to a contract address they will be lost unless the contract\r\n            // has been designed to handle incoming/holding tokens in other contracts\r\n            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\r\n            balances[_to] = add(balances[_to], _value);\r\n\r\n            Transfer(msg.sender, _to, _value);\r\n        }\r\n    }\r\n\r\n    function allocateTokens(uint256 _submitted, address _recipient) internal {\r\n        uint256 _availableInTier = mul(tierTokens[tierLevel], costPerToken[tierLevel]);\r\n        uint256 _allocation = 0;\r\n\r\n        if(_submitted >= _availableInTier) {\r\n            _allocation = tierTokens[tierLevel];\r\n            tierTokens[tierLevel] = 0;\r\n            tierLevel++;\r\n            if(tierLevel > maxTier) {\r\n                swap = true;\r\n            }\r\n            _submitted = sub(_submitted, _availableInTier);\r\n        }\r\n        else {\r\n            uint256 stepOne = mul(_submitted, 1 ether);\r\n            uint256 stepTwo = div(stepOne, costPerToken[tierLevel]);\r\n            uint256 _tokens = stepTwo;\r\n            _allocation = add(_allocation, _tokens);\r\n            tierTokens[tierLevel] = sub(tierTokens[tierLevel], _tokens);\r\n            _submitted = sub(_submitted, _availableInTier);\r\n        }\r\n\r\n        // transfer tokens allocated so far to wallet address from contract\r\n        balances[_recipient] = add(balances[_recipient],_allocation);\r\n        circulatingSupply = add(circulatingSupply, _allocation);\r\n        totalSupply = sub(totalSupply, _allocation);\r\n\r\n        if((_submitted != 0) && (tierLevel <= maxTier)) {\r\n            allocateTokens(_submitted, _recipient);\r\n        }\r\n        else {\r\n            // emit transfer event\r\n            Transfer(this, _recipient, balances[_recipient]);\r\n        }\r\n    }\r\n\r\n    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _sentTokens) public {\r\n\r\n        require(exchangeRates[msg.sender] > 0);\r\n        uint256 _exchanged = mul(_sentTokens, exchangeRates[_source]);\r\n\r\n        require(_exchanged <= mul(totalSupply, 1 ether));\r\n        allocateTokens(_exchanged, _recipient);\r\n    }\r\n\r\n    function addExchangePartnerAddressAndRate(address _partner, uint256 _rate) {\r\n        require(msg.sender == owner);\r\n        // check that _partner is a contract address\r\n        uint codeLength;\r\n        assembly {\r\n            codeLength := extcodesize(_partner)\r\n        }\r\n        require(codeLength > 0);\r\n        exchangeRates[_partner] = _rate;\r\n\r\n        bool isContract = existingContract(_partner);\r\n        if(isContract == false) {\r\n            contractCount++;\r\n            contracts[contractCount] = _partner;\r\n        }\r\n    }\r\n\r\n    // public data retrieval funcs\r\n    function getTotalSupply() public constant returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    function getCirculatingSupply() public constant returns (uint256) {\r\n        return circulatingSupply;\r\n    }\r\n\r\n    function balanceOf(address _receiver) public constant returns (uint256) {\r\n        return balances[_receiver];\r\n    }\r\n\r\n    function balanceInTier() public constant returns (uint256) {\r\n        return tierTokens[tierLevel];\r\n    }\r\n\r\n    function balanceInSpecificTier(uint tier) public constant returns (uint256) {\r\n        return tierTokens[tier];\r\n    }\r\n\r\n    function currentTier() public constant returns (uint256) {\r\n        return tierLevel;\r\n    }\r\n\r\n    // admin functions\r\n    function convertTransferredTokensToMny(uint256 _value, address _recipient, address _source, uint256 _originalAmount) public {\r\n        // allows tokens transferred in for exchange to be converted to MNY and distributed\r\n        // COE is able to interact directly with contract - other exchange partners cannot\r\n        require((msg.sender == owner) || (msg.sender == exchangeAdmin));\r\n        require(exchangeRates[_source] > 0);\r\n        maintainExternalContractTokenBalance(_source, _originalAmount);\r\n        allocateTokens(_value, _recipient);\r\n    }\r\n\r\n    function changeOwner(address _newOwner) public {\r\n        require(msg.sender == owner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function changeExchangeAdmin(address _newAdmin) public {\r\n        require(msg.sender == owner);\r\n        exchangeAdmin = _newAdmin;\r\n    }\r\n\r\n    function maintainExternalContractTokenBalance(address _contract, uint256 _tokens) internal {\r\n        tokenBalances[_contract] = add(tokenBalances[_contract], _tokens);\r\n    }\r\n\r\n    function getTokenBalance(address _contract) public constant returns (uint256) {\r\n        return tokenBalances[_contract];\r\n    }\r\n\r\n    function calculateHeldTokenDistribution() public {\r\n        require(swap = true);\r\n        for(uint i=0; i<contractCount; i++) {\r\n//            tokenShare[contracts[i]] = div(tokenBalances[contracts[i]], div(add(totalSupply, circulatingSupply), 1 ether));\r\n            tokenShare[contracts[i]] = div(tokenBalances[contracts[i]], circulatingSupply);\r\n        }\r\n        distributionCalculated = true;\r\n    }\r\n\r\n    function tokenShare(address _contract) public constant returns (uint256) {\r\n        return tokenShare[_contract];\r\n    }\r\n\r\n    function shareStoredTokens(address _recipient, uint256 mny) internal {\r\n        Target t;\r\n        uint256 share = 0;\r\n        for(uint i=0; i<contractCount; i++) {\r\n            share = mul(mny, tokenShare[contracts[i]]);\r\n\r\n            t = Target(contracts[i]);\r\n            t.transfer(_recipient, share);\r\n        }\r\n    }\r\n\r\n    function distributeMnyAfterSwap(address _recipient, uint256 _tokens) public {\r\n        require(msg.sender == owner);\r\n        require(totalSupply <= _tokens);\r\n        balances[_recipient] = add(balances[_recipient], _tokens);\r\n        Transfer(this, _recipient, _tokens);\r\n        totalSupply = sub(totalSupply, _tokens);\r\n        circulatingSupply = add(circulatingSupply, _tokens);\r\n    }\r\n\r\n    function existingContract(address _contract) internal returns (bool) {\r\n        for(uint i=0; i<contractCount; i++) {\r\n            if(contracts[i] == _contract) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function contractExchangeRate(address _contract) public constant returns (uint256) {\r\n        return exchangeRates[_contract];\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeExchangeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_source\",\"type\":\"address\"},{\"name\":\"_originalAmount\",\"type\":\"uint256\"}],\"name\":\"convertTransferredTokensToMny\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_source\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_sentTokens\",\"type\":\"uint256\"}],\"name\":\"exchangeTokensFromOtherContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiveEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"addExchangePartnerAddressAndRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeRates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"distributeMnyAfterSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calculateHeldTokenDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"contractExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"tokenShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tier\",\"type\":\"uint256\"}],\"name\":\"balanceInSpecificTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MNY","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8cd2dce071df38f840e8dd2de10e25d84c2437580105e0e365575b1d82a61cb3"}]}