{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n// File: contracts\\Auction.sol\r\n\r\n/**\r\n * @title 竞拍接口\r\n */\r\ncontract Auction {\r\n    function bid() public payable returns (bool);\r\n    function end() public returns (bool);\r\n\r\n    event AuctionBid(address indexed from, uint256 value);\r\n}\r\n\r\n// File: contracts\\Base.sol\r\n\r\nlibrary Base {\r\n    struct NTVUConfig {\r\n        uint bidStartValue;\r\n        int bidStartTime;\r\n        int bidEndTime;\r\n\r\n        uint tvUseStartTime;\r\n        uint tvUseEndTime;\r\n\r\n        bool isPrivate;\r\n        bool special;\r\n    }\r\n}\r\n\r\n// File: contracts\\ownership\\Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n// File: contracts\\util\\SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts\\token\\ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts\\token\\BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts\\util\\StringUtils.sol\r\n\r\nlibrary StringUtils {\r\n    function uintToString(uint v) internal pure returns (string str) {\r\n        uint maxlength = 100;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        while (v != 0) {\r\n            uint remainder = v % 10;\r\n            v = v / 10;\r\n            reversed[i++] = byte(48 + remainder);\r\n        }\r\n\r\n        bytes memory s = new bytes(i);\r\n        for (uint j = 0; j < i; j++) {\r\n            s[j] = reversed[i - 1 - j];\r\n        }\r\n\r\n        str = string(s);\r\n    }\r\n\r\n    function concat(string _base, string _value) internal pure returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\r\n        bytes memory _newValue = bytes(_tmpValue);\r\n\r\n        uint i;\r\n        uint j;\r\n\r\n        for(i=0; i<_baseBytes.length; i++) {\r\n            _newValue[j++] = _baseBytes[i];\r\n        }\r\n\r\n        for(i=0; i<_valueBytes.length; i++) {\r\n            _newValue[j++] = _valueBytes[i];\r\n        }\r\n\r\n        return string(_newValue);\r\n    }\r\n\r\n    function bytesToBytes32(bytes memory source) internal pure returns (bytes32 result) {\r\n        require(source.length <= 32);\r\n\r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    function toBytes96(string memory text) internal pure returns (bytes32, bytes32, bytes32, uint8) {\r\n        bytes memory temp = bytes(text);\r\n        len = uint8(temp.length);\r\n        require(len <= 96);\r\n\r\n        uint8 i=0;\r\n        uint8 j=0;\r\n        uint8 k=0;\r\n\r\n        string memory _b1 = new string(32);\r\n        bytes memory b1 = bytes(_b1);\r\n\r\n        string memory _b2 = new string(32);\r\n        bytes memory b2 = bytes(_b2);\r\n\r\n        string memory _b3 = new string(32);\r\n        bytes memory b3 = bytes(_b3);\r\n\r\n        uint8 len;\r\n\r\n        for(i=0; i<len; i++) {\r\n            k = i / 32;\r\n            j = i % 32;\r\n\r\n            if (k == 0) {\r\n                b1[j] = temp[i];\r\n            } else if(k == 1) {\r\n                b2[j] = temp[i];\r\n            } else if(k == 2) {\r\n                b3[j] = temp[i];\r\n            } \r\n        }\r\n\r\n        return (bytesToBytes32(b1), bytesToBytes32(b2), bytesToBytes32(b3), len);\r\n    }\r\n\r\n    function fromBytes96(bytes32 b1, bytes32 b2, bytes32 b3, uint8 len) internal pure returns (string) {\r\n        require(len <= 96);\r\n        string memory _tmpValue = new string(len);\r\n        bytes memory temp = bytes(_tmpValue);\r\n\r\n        uint8 i;\r\n        uint8 j = 0;\r\n\r\n        for(i=0; i<32; i++) {\r\n            if (j >= len) break;\r\n            temp[j++] = b1[i];\r\n        }\r\n\r\n        for(i=0; i<32; i++) {\r\n            if (j >= len) break;\r\n            temp[j++] = b2[i];\r\n        }\r\n\r\n        for(i=0; i<32; i++) {\r\n            if (j >= len) break;\r\n            temp[j++] = b3[i];\r\n        }\r\n\r\n        return string(temp);\r\n    }\r\n}\r\n\r\n// File: contracts\\NTVUToken.sol\r\n\r\n/**\r\n * 链上真心话时段币\r\n */\r\ncontract NTVUToken is BasicToken, Ownable, Auction {\r\n    string public name;\r\n    string public symbol = \"FOT\";\r\n\r\n    uint8 public number = 0;\r\n    uint8 public decimals = 0;\r\n    uint public INITIAL_SUPPLY = 1;\r\n\r\n    uint public bidStartValue;\r\n    uint public bidStartTime;\r\n    uint public bidEndTime;\r\n\r\n    uint public tvUseStartTime;\r\n    uint public tvUseEndTime;\r\n\r\n    bool public isPrivate = false;\r\n\r\n    uint public maxBidValue;\r\n    address public maxBidAccount;\r\n\r\n    bool internal auctionEnded = false;\r\n\r\n    string public text; // 用户配置文本\r\n    string public auditedText; // 审核通过的文本\r\n    string public defaultText; // 默认文本\r\n    uint8 public auditStatus = 0; // 0:未审核；1:审核通过；2:审核不通过\r\n\r\n    uint32 public bidCount;\r\n    uint32 public auctorCount;\r\n\r\n    mapping(address => bool) acutors;\r\n\r\n    address public ethSaver; // 竞拍所得ETH保管者\r\n\r\n    /**\r\n     * 时段币合约构造函数\r\n     *\r\n     * 拍卖期间如有更高出价，前一手出价者的以太坊自动退回其钱包\r\n     *\r\n     * @param _number 时段币的序号，从0开始\r\n     * @param _bidStartValue 起拍价，单位 wei\r\n     * @param _bidStartTime 起拍/私募开始时间，单位s\r\n     * @param _bidEndTime 起拍/私募结束时间，单位s\r\n     * @param _tvUseStartTime 时段币文本开始播放时间\r\n     * @param _tvUseEndTime 时段币文本结束播放时间\r\n     * @param _isPrivate 是否为私募\r\n     * @param _defaultText 默认文本\r\n     * @param _ethSaver 竞拍所得保管着\r\n     */\r\n    function NTVUToken(uint8 _number, uint _bidStartValue, uint _bidStartTime, uint _bidEndTime, uint _tvUseStartTime, uint _tvUseEndTime, bool _isPrivate, string _defaultText, address _ethSaver) public {\r\n        number = _number;\r\n\r\n        if (_number + 1 < 10) {\r\n            symbol = StringUtils.concat(symbol, StringUtils.concat(\"0\", StringUtils.uintToString(_number + 1)));\r\n        } else {\r\n            symbol = StringUtils.concat(symbol, StringUtils.uintToString(_number + 1));\r\n        }\r\n\r\n        name = symbol;\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n\r\n        bidStartValue = _bidStartValue;\r\n        bidStartTime = _bidStartTime;\r\n        bidEndTime = _bidEndTime;\r\n\r\n        tvUseStartTime = _tvUseStartTime;\r\n        tvUseEndTime = _tvUseEndTime;\r\n\r\n        isPrivate = _isPrivate;\r\n\r\n        defaultText = _defaultText;\r\n\r\n        ethSaver = _ethSaver;\r\n    }\r\n\r\n    /**\r\n     * 竞拍出价\r\n     *\r\n     * 拍卖期间如有更高出价，前一手出价者的以太坊自动退回其钱包\r\n     */\r\n    function bid() public payable returns (bool) {\r\n        require(now >= bidStartTime); // 竞拍开始时间到后才能竞拍\r\n        require(now < bidEndTime); // 竞拍截止时间到后不能再竞拍\r\n        require(msg.value >= bidStartValue); // 拍卖金额需要大于起拍价\r\n        require(msg.value >= maxBidValue + 0.05 ether); // 最低0.05ETH加价\r\n        require(!isPrivate || (isPrivate && maxBidAccount == address(0))); // 竞拍或者私募第一次出价\r\n\r\n        // 如果上次有人出价，将上次出价的ETH退还给他\r\n        if (maxBidAccount != address(0)) {\r\n            maxBidAccount.transfer(maxBidValue);\r\n        } \r\n        \r\n        maxBidAccount = msg.sender;\r\n        maxBidValue = msg.value;\r\n        AuctionBid(maxBidAccount, maxBidValue); // 发出有人出价事件\r\n\r\n        // 统计出价次数\r\n        bidCount++;\r\n\r\n        // 统计出价人数\r\n        bool bided = acutors[msg.sender];\r\n        if (!bided) {\r\n            auctorCount++;\r\n            acutors[msg.sender] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 竞拍结束\r\n     *\r\n     * 拍卖结束后，系统确认交易，出价最高者获得该时段Token。\r\n     */\r\n    function end() public returns (bool) {\r\n        require(!auctionEnded); // 已经结束竞拍了不能再结束\r\n        require((now >= bidEndTime) || (isPrivate && maxBidAccount != address(0))); // 普通竞拍拍卖结束后才可以结束竞拍，私募只要出过价就可以结束竞拍\r\n   \r\n        // 如果有人出价，将时段代币转给出价最高的人\r\n        if (maxBidAccount != address(0)) {\r\n            address _from = owner;\r\n            address _to = maxBidAccount;\r\n            uint _value = INITIAL_SUPPLY;\r\n\r\n            // 将时段币转给出价最高的人\r\n            balances[_from] = balances[_from].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            Transfer(_from, _to, _value); // 通知出价最高的人收到时段币了\r\n\r\n            //将时段币中ETH转给ethSaver\r\n            ethSaver.transfer(this.balance);\r\n        }\r\n\r\n        auctionEnded = true;\r\n    }\r\n\r\n    /**\r\n     * 配置上链文本\r\n     *\r\n     * 购得时段后（包含拍卖和私募），可以设置时段文本\r\n     * 每时段文字接受中文30字以内（含标点和空格），多出字符不显示。\r\n     * 审核截止时间是，每个时段播出前30分钟\r\n     */\r\n    function setText(string _text) public {\r\n        require(INITIAL_SUPPLY == balances[msg.sender]); // 拥有时段币的人可以设置文本\r\n        require(bytes(_text).length > 0 && bytes(_text).length <= 90); // 汉字使用UTF8编码，1个汉字最多占用3个字节，所以最多写90个字节的字\r\n        require(now < tvUseStartTime - 30 minutes); // 开播前30分钟不能再设置文本\r\n\r\n        text = _text;\r\n    }\r\n\r\n    function getTextBytes96() public view returns(bytes32, bytes32, bytes32, uint8) {\r\n        return StringUtils.toBytes96(text);\r\n    }\r\n\r\n    /**\r\n     * 审核文本\r\n     */\r\n    function auditText(uint8 _status, string _text) external onlyOwner {\r\n        require((now >= tvUseStartTime - 30 minutes) && (now < tvUseEndTime)); // 时段播出前30分钟为审核时间，截止到时段播出结束时间\r\n        auditStatus = _status;\r\n\r\n        if (_status == 2) { // 审核失败，更新审核文本\r\n            auditedText = _text;\r\n        } else if (_status == 1) { // 审核通过使用用户设置的文本\r\n            auditedText = text; \r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取显示文本\r\n     */\r\n    function getShowText() public view returns(string) {\r\n        if (auditStatus == 1 || auditStatus == 2) { // 审核过了\r\n            return auditedText;\r\n        } else { // 没有审核，显示默认文本\r\n            return defaultText;\r\n        }\r\n    }\r\n\r\n    function getShowTextBytes96() public view returns(bytes32, bytes32, bytes32, uint8) {\r\n        return StringUtils.toBytes96(getShowText());\r\n    }\r\n\r\n    /**\r\n     * 转账代币\r\n     *\r\n     * 获得时段后，时段播出前，不可以转卖。时段播出后，可以作为纪念币转卖\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(now >= tvUseEndTime); // 时段播出后，可以转卖。\r\n\r\n        super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * 获取时段币状态信息\r\n     *\r\n     */\r\n    function getInfo() public view returns(\r\n        string _symbol,\r\n        string _name,\r\n        uint _bidStartValue, \r\n        uint _bidStartTime, \r\n        uint _bidEndTime, \r\n        uint _tvUseStartTime,\r\n        uint _tvUseEndTime,\r\n        bool _isPrivate\r\n        ) {\r\n        _symbol = symbol;\r\n        _name = name;\r\n\r\n        _bidStartValue = bidStartValue;\r\n        _bidStartTime = bidStartTime;\r\n        _bidEndTime = bidEndTime;\r\n\r\n        _tvUseStartTime = tvUseStartTime;\r\n        _tvUseEndTime = tvUseEndTime;\r\n\r\n        _isPrivate = isPrivate;\r\n    }\r\n\r\n    /**\r\n     * 获取时段币可变状态信息\r\n     *\r\n     */\r\n    function getMutalbeInfo() public view returns(\r\n        uint _maxBidValue,\r\n        address _maxBidAccount,\r\n        bool _auctionEnded,\r\n        string _text,\r\n        uint8 _auditStatus,\r\n        uint8 _number,\r\n        string _auditedText,\r\n        uint32 _bidCount,\r\n        uint32 _auctorCount\r\n        ) {\r\n        _maxBidValue = maxBidValue;\r\n        _maxBidAccount = maxBidAccount;\r\n\r\n        _auctionEnded = auctionEnded;\r\n\r\n        _text = text;\r\n        _auditStatus = auditStatus;\r\n\r\n        _number = number;\r\n        _auditedText = auditedText;\r\n\r\n        _bidCount = bidCount;\r\n        _auctorCount = auctorCount;\r\n    }\r\n\r\n    /**\r\n     * 提取以太坊到ethSaver\r\n     */\r\n    function reclaimEther() external onlyOwner {\r\n        require((now > bidEndTime) || (isPrivate && maxBidAccount != address(0))); // 普通竞拍拍卖结束后或者私募完成后，可以提币到ethSaver。\r\n        ethSaver.transfer(this.balance);\r\n    }\r\n\r\n    /**\r\n     * 默认给合约转以太坊就是出价\r\n     */\r\n    function() payable public {\r\n        bid(); // 出价\r\n    }\r\n}\r\n\r\n// File: contracts\\NTVToken.sol\r\n\r\n/**\r\n * 链上真心话合约\r\n */\r\ncontract NTVToken is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint8 public MAX_TIME_RANGE_COUNT = 66; // 最多发行66个时段代币\r\n\r\n    bool public isRunning; // 是否启动运行\r\n\r\n    uint public onlineTime; // 上线时间，第一时段上电视的时间\r\n    uint8 public totalTimeRange; // 当前已经释放的总的时段数\r\n    mapping(uint => address) internal timeRanges; // 每个时段的合约地址，编号从0开始\r\n\r\n    string public defaultText = \"浪花有意千里雪，桃花无言一队春。\"; // 忘记审核使用的默认文本\r\n\r\n    mapping(uint8 => Base.NTVUConfig) internal dayConfigs; // 每天时段配置\r\n    mapping(uint8 => Base.NTVUConfig) internal specialConfigs; // 特殊时段配置\r\n\r\n    address public ethSaver; // 竞拍所得ETH保管者\r\n\r\n    event OnTV(address indexed ntvu, address indexed winer, string text); // 文本上电视\r\n\r\n    /**\r\n     * 佛系电视合约构造函数\r\n     */\r\n    function NTVToken() public {}\r\n\r\n    /**\r\n     * 启动区块链电视\r\n     *\r\n     * @param _onlineTime 区块链电视上线时间，必须为整点，例如 2018-03-26 00:00:00\r\n     * @param _ethSaver 竞拍所得ETH保管者\r\n     */\r\n    function startup(uint256 _onlineTime, address _ethSaver) public onlyOwner {\r\n        require(!isRunning); // 只能上线一次，上线后不能停止\r\n        require((_onlineTime - 57600) % 1 days == 0); // 上线时间只能是整天时间，57600为北京时间的'1970/1/2 0:0:0'\r\n        require(_onlineTime >= now); // 上线时间需要大于当前时间\r\n        require(_ethSaver != address(0));\r\n\r\n        onlineTime = _onlineTime;\r\n        ethSaver = _ethSaver;\r\n\r\n        isRunning = true;\r\n\r\n        // ---------------------------\r\n        // 每天的时段配置，共6个时段\r\n        //\r\n        // 通用规则：\r\n        // 1、首拍后，每天18:30-22:00为竞拍时间\r\n        // ---------------------------\r\n        uint8[6] memory tvUseStartTimes = [0, 10, 12, 18, 20, 22]; // 电视使用开始时段\r\n        uint8[6] memory tvUseEndTimes = [2, 12, 14, 20, 22, 24]; // 电视使用结束时段\r\n\r\n        for (uint8 i=0; i<6; i++) {\r\n            dayConfigs[i].bidStartValue = 0.1 ether; // 正常起拍价0.1ETH\r\n            dayConfigs[i].bidStartTime = 18 hours + 30 minutes - 1 days; // 一天前晚上 18:30起拍\r\n            dayConfigs[i].bidEndTime = 22 hours - 1 days; // 一天前晚上 22:00 结束拍卖\r\n\r\n            dayConfigs[i].tvUseStartTime = uint(tvUseStartTimes[i]) * 1 hours;\r\n            dayConfigs[i].tvUseEndTime = uint(tvUseEndTimes[i]) * 1 hours;\r\n\r\n            dayConfigs[i].isPrivate = false; // 正常都是竞拍，非私募\r\n        }\r\n\r\n        // ---------------------------\r\n        // 特殊时段配置\r\n        // ---------------------------\r\n\r\n        // 首拍，第1天的6个时段都是首拍，拍卖时间从两天前的18:30到一天前的22:00\r\n        for(uint8 p=0; p<6; p++) {\r\n            specialConfigs[p].special = true;\r\n            \r\n            specialConfigs[p].bidStartValue = 0.1 ether; // 起拍价0.1ETH\r\n            specialConfigs[p].bidStartTime = 18 hours + 30 minutes - 2 days; // 两天前的18:30\r\n            specialConfigs[p].bidEndTime = 22 hours - 1 days; // 一天前的22:00\r\n            specialConfigs[p].isPrivate = false; // 非私募\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取区块的时间戳，单位s\r\n     */\r\n    function time() constant internal returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * 获取某个时间是上线第几天，第1天返回1，上线之前返回0\r\n     * \r\n     * @param timestamp 时间戳\r\n     */\r\n    function dayFor(uint timestamp) constant public returns (uint) {\r\n        return timestamp < onlineTime\r\n            ? 0\r\n            : (timestamp.sub(onlineTime) / 1 days) + 1;\r\n    }\r\n\r\n    /**\r\n     * 获取当前时间是今天的第几个时段，第一个时段返回1，没有匹配的返回0\r\n     *\r\n     * @param timestamp 时间戳\r\n     */\r\n    function numberFor(uint timestamp) constant public returns (uint8) {\r\n        if (timestamp >= onlineTime) {\r\n            uint current = timestamp.sub(onlineTime) % 1 days;\r\n\r\n            for(uint8 i=0; i<6; i++) {\r\n                if (dayConfigs[i].tvUseStartTime<=current && current<dayConfigs[i].tvUseEndTime) {\r\n                    return (i + 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * 创建时段币\r\n     */\r\n    function createNTVU() public onlyOwner {\r\n        require(isRunning);\r\n        require(totalTimeRange < MAX_TIME_RANGE_COUNT);\r\n\r\n        uint8 number = totalTimeRange++;\r\n        uint8 day = number / 6;\r\n        uint8 num = number % 6;\r\n\r\n        Base.NTVUConfig memory cfg = dayConfigs[num]; // 读取每天时段的默认配置\r\n\r\n        // 如果有特殊配置则覆盖\r\n        Base.NTVUConfig memory expCfg = specialConfigs[number];\r\n        if (expCfg.special) {\r\n            cfg.bidStartValue = expCfg.bidStartValue;\r\n            cfg.bidStartTime = expCfg.bidStartTime;\r\n            cfg.bidEndTime = expCfg.bidEndTime;\r\n            cfg.isPrivate = expCfg.isPrivate;\r\n        }\r\n\r\n        // 根据上线时间计算具体的时段时间\r\n        uint bidStartTime = uint(int(onlineTime) + day * 24 hours + cfg.bidStartTime);\r\n        uint bidEndTime = uint(int(onlineTime) + day * 24 hours + cfg.bidEndTime);\r\n        uint tvUseStartTime = onlineTime + day * 24 hours + cfg.tvUseStartTime;\r\n        uint tvUseEndTime = onlineTime + day * 24 hours + cfg.tvUseEndTime;\r\n\r\n        timeRanges[number] = new NTVUToken(number, cfg.bidStartValue, bidStartTime, bidEndTime, tvUseStartTime, tvUseEndTime, cfg.isPrivate, defaultText, ethSaver);\r\n    }\r\n\r\n    /**\r\n     * 查询所有时段\r\n     */\r\n    function queryNTVUs(uint startIndex, uint count) public view returns(address[]){\r\n        startIndex = (startIndex < totalTimeRange)? startIndex : totalTimeRange;\r\n        count = (startIndex + count < totalTimeRange) ? count : (totalTimeRange - startIndex);\r\n\r\n        address[] memory result = new address[](count);\r\n        for(uint i=0; i<count; i++) {\r\n            result[i] = timeRanges[startIndex + i];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 查询当前正在播放的时段\r\n     */\r\n    function playingNTVU() public view returns(address){\r\n        uint day = dayFor(time());\r\n        uint8 num = numberFor(time());\r\n\r\n        if (day>0 && (num>0 && num<=6)) {\r\n            day = day - 1;\r\n            num = num - 1;\r\n\r\n            return timeRanges[day * 6 + uint(num)];\r\n        } else {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 审核文本\r\n     */\r\n    function auditNTVUText(uint8 index, uint8 status, string _text) public onlyOwner {\r\n        require(isRunning); // 合约启动后才能审核\r\n        require(index >= 0 && index < totalTimeRange); //只能审核已经上线的时段\r\n        require(status==1 || (status==2 && bytes(_text).length>0 && bytes(_text).length <= 90)); // 审核不通，需要配置文本\r\n\r\n        address ntvu = timeRanges[index];\r\n        assert(ntvu != address(0));\r\n\r\n        NTVUToken ntvuToken = NTVUToken(ntvu);\r\n        ntvuToken.auditText(status, _text);\r\n\r\n        var (b1, b2, b3, len) = ntvuToken.getShowTextBytes96();\r\n        var auditedText = StringUtils.fromBytes96(b1, b2, b3, len);\r\n        OnTV(ntvuToken, ntvuToken.maxBidAccount(), auditedText); // 审核后的文本记录到日志中\r\n    }\r\n\r\n    /**\r\n     * 获取电视播放文本\r\n     */\r\n    function getText() public view returns(string){\r\n        address playing = playingNTVU();\r\n\r\n        if (playing != address(0)) {\r\n            NTVUToken ntvuToken = NTVUToken(playing);\r\n\r\n            var (b1, b2, b3, len) = ntvuToken.getShowTextBytes96();\r\n            return StringUtils.fromBytes96(b1, b2, b3, len);\r\n        } else {\r\n            return \"\"; // 当前不是播放时段，返回空文本\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取竞拍状态\r\n     */\r\n    function status() public view returns(uint8) {\r\n        if (!isRunning) {\r\n            return 0; // 未启动拍卖\r\n        } else if (time() < onlineTime) {\r\n            return 1; // 未到首播时间\r\n        } else {\r\n            if (totalTimeRange == 0) {\r\n                return 2; // 没有创建播放时段\r\n            } else {\r\n                if (time() < NTVUToken(timeRanges[totalTimeRange - 1]).tvUseEndTime()) {\r\n                    return 3; // 整个竞拍活动进行中\r\n                } else {\r\n                    return 4; // 整个竞拍活动已结束\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 获取总的竞拍人数\r\n     */\r\n    function totalAuctorCount() public view returns(uint32) {\r\n        uint32 total = 0;\r\n\r\n        for(uint8 i=0; i<totalTimeRange; i++) {\r\n            total += NTVUToken(timeRanges[i]).auctorCount();\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * 获取总的竞拍次数\r\n     */\r\n    function totalBidCount() public view returns(uint32) {\r\n        uint32 total = 0;\r\n\r\n        for(uint8 i=0; i<totalTimeRange; i++) {\r\n            total += NTVUToken(timeRanges[i]).bidCount();\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * 获取总的出价ETH\r\n     */\r\n    function totalBidEth() public view returns(uint) {\r\n        uint total = 0;\r\n\r\n        for(uint8 i=0; i<totalTimeRange; i++) {\r\n            total += NTVUToken(timeRanges[i]).balance;\r\n        }\r\n\r\n        total += this.balance;\r\n        total += ethSaver.balance;\r\n\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * 获取历史出价最高的ETH\r\n     */\r\n    function maxBidEth() public view returns(uint) {\r\n        uint maxETH = 0;\r\n\r\n        for(uint8 i=0; i<totalTimeRange; i++) {\r\n            uint val = NTVUToken(timeRanges[i]).maxBidValue();\r\n            maxETH =  (val > maxETH) ? val : maxETH;\r\n        }\r\n\r\n        return maxETH;\r\n    }\r\n\r\n    /**\r\n     * 提取当前合约的ETH到ethSaver\r\n     */\r\n    function reclaimEther() public onlyOwner {\r\n        require(isRunning);\r\n\r\n        ethSaver.transfer(this.balance);\r\n    }\r\n\r\n    /**\r\n     * 提取时段币的ETH到ethSaver\r\n     */\r\n    function reclaimNtvuEther(uint8 index) public onlyOwner {\r\n        require(isRunning);\r\n        require(index >= 0 && index < totalTimeRange); //只能审核已经上线的时段\r\n\r\n        NTVUToken(timeRanges[index]).reclaimEther();\r\n    }\r\n\r\n    /**\r\n     * 接收ETH\r\n     */\r\n    function() payable external {}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAuctorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createNTVU\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playingNTVU\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethSaver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBidEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"numberFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"queryNTVUs\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTimeRange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBidCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlineTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint8\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"auditNTVUText\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBidEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_onlineTime\",\"type\":\"uint256\"},{\"name\":\"_ethSaver\",\"type\":\"address\"}],\"name\":\"startup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"dayFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TIME_RANGE_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"reclaimNtvuEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultText\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getText\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ntvu\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"winer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"OnTV\",\"type\":\"event\"}]","ContractName":"NTVToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://490b9b390d23b8965bd26c46f2044ea8a51e506345a1ad77155c0b49674f549c"}]}