{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\ncontract StandardToken is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public totalSupply;\r\n\r\n  mapping(address => uint256) balances;\r\n  mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    /**\r\n   * @dev Gets the balance of the specified address.\r\n   * @param _owner The address to query the the balance of.\r\n   * @return An uint256 representing the amount owned by the passed address.\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /**\r\n   * Internal transfer, only can be called by this contract\r\n   */\r\n  function _transfer(address _from, address _to, uint _value) internal {\r\n    require(_value > 0);\r\n    require(balances[_from] >= _value);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(_from, _to, _value);\r\n  }\r\n  \r\n  /**\r\n   * @dev transfer token for a specified address\r\n   * @param _to The address to transfer to.\r\n   * @param _value The amount to be transferred.\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    _transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require (_value <= allowed[_from][msg.sender]);\r\n\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    _transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SEXNToken is StandardToken, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  string public constant name = \"SexChain\";\r\n  string public constant symbol = \"SEXN\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  struct lockInfo {\r\n    uint256 amount;            // Total number of token locks\r\n    uint256 start;             // The time when the lock was started.\r\n    uint256 transfered;        // The number of tokens that have been unlocked.\r\n    uint256 duration;          // The lock time for each cycle.\r\n    uint256 releaseCount;      // locking cycle.\r\n  }\r\n\r\n  mapping(address => lockInfo) internal _lockInfo;\r\n  // Query locked balance\r\n  mapping(address => uint256) internal _lockupBalances;\r\n\r\n  bool public preSaleFinished = false;\r\n\r\n  // start and end timestamps where investments are allowed (both inclusive) \r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n\r\n  // how many token units a buyer gets per wei\r\n  uint256 public rate;\r\n\r\n  //The number of locks for each round of presale. eg: 5 is 5 days\r\n  uint256 public lockCycle;\r\n\r\n  // The length of one lock cycle, \r\n  uint256 public constant DURATION = 24 * 3600;  // a day\r\n\r\n  /* The maximum amount of single users for pre-sales in the first period is 20,000. */\r\n  uint256 public constant CAT_FIRST = 20000 * (10 ** 18);\r\n\r\n  enum PresaleAction {\r\n    Ready,\r\n    FirstPresaleActivity,\r\n    SecondPresaleActivity,\r\n    ThirdPresaleActivity,\r\n    END\r\n  }\r\n\r\n  PresaleAction public saleAction = PresaleAction.Ready;\r\n\r\n\r\n  address private PRESALE_ADDRESS = 0xFD8C2759Fcf6E0BB57128d5dFCf1747AE9C7e3a1;         // Presale         \r\n  address private FOUNDATION_ADDRESS = 0x096D756888F725ab56eA5bD2002102d10271BEc3;      // Community rewards \r\n  address private COMMERCIAL_PLAN_ADDRESS = 0x51bE0d2Ed867cB68450Bee2Fcbf11a5960843bbd; // commercial plan  \r\n  address private POS_ADDRESS = 0x17c5fD5915DfaDe37EC0C04f1D70Ee495d6957af;             // DPOS                     \r\n  address private TEAM_ADDRESS = 0xE38e1dB1fD7915D2ed877E8cE53697E57EC2417e;            // Technical team   \r\n  address private COMMUNITY_TEAM_ADDRESS = 0xa34C472688D92511beb8fCDA42269a0526CfCCf0;  // community team   \r\n\r\n  address public wallet = 0xDcE9E02972fDfEd54F4b307C75bd0755067cBc90;\r\n\r\n\r\n  /////////////////\r\n  /// Event\r\n  /////////////////\r\n\r\n  event UnLock(address indexed beneficiary, uint256 amount);\r\n  event SellTokens(address indexed recipient, uint256 sellTokens, uint256 rate);\r\n\r\n  /////////////////\r\n  /// Modifier\r\n  /////////////////\r\n\r\n  /* check presale is active */\r\n  modifier beginSaleActive() {\r\n    require(now >= startTime && now <= endTime);\r\n    _;\r\n  }\r\n\r\n  /* check presale is not active */\r\n  modifier notpreSaleActive() {\r\n    require(now <= startTime || now >= endTime);\r\n    _;\r\n  }\r\n\r\n  /* For security reasons, need to change the wallet address */\r\n  function changeWallet(address _newWallet) public {\r\n      require(_newWallet != address(0x0));\r\n      require(msg.sender == wallet);\r\n      \r\n      wallet = _newWallet;\r\n  }\r\n\r\n  /* Query the number of tokens for which an address is locked. */\r\n  function getLockBalance(address _owner) public view returns(uint256){\r\n    return _lockupBalances[_owner];\r\n  }\r\n\r\n  /* Check the remaining quantity of presale in this round. */\r\n  function getRemainingPreSalesAmount() public view returns(uint256){\r\n    return balances[PRESALE_ADDRESS];\r\n  }\r\n\r\n  /*Gets the unlocked time of the specified address. */\r\n  function getLockTime(address _owner) public view returns(uint256){\r\n    // start + ( lockCycle * duration )\r\n    return _lockInfo[_owner].start.add(\r\n        _lockInfo[_owner].releaseCount.mul(_lockInfo[_owner].duration));\r\n  }\r\n\r\n  /**\r\n   * @dev Set the time and amount of presale for each period.\r\n   * @param _round uint8  The number of presale activities\r\n   * @param _startTime uint256  The current round of presales begins.\r\n   * @param _stopTime uint256  The end of the round of presales.\r\n   * @param _rate uint256   How many token units a buyer gets per wei.\r\n   * @param _amount uint256  The number of presale tokens.\r\n   */\r\n  function setSaleInfo(uint8 _round ,uint256 _startTime, uint256 _stopTime, uint256 _rate, uint256 _amount) external notpreSaleActive onlyOwner {\r\n    require(_round == 1 || _round == 2 || _round == 3);\r\n    require(_startTime < _stopTime);\r\n    require(_rate != 0 && _amount >= 0);\r\n    require(_startTime > now); \r\n    require(!preSaleFinished);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].add(_amount);\r\n\r\n    startTime = _startTime;\r\n    endTime = _stopTime;\r\n    rate = _rate;\r\n    _caluLocktime(_round);\r\n  }\r\n\r\n  function _caluLocktime(uint8 _round) internal {\r\n    require(_round == 1 || _round == 2 || _round == 3);\r\n    if (_round == 1 ){\r\n      saleAction = PresaleAction.FirstPresaleActivity;\r\n      lockCycle = 200;        // 200 days\r\n    }\r\n\r\n    if (_round == 2){\r\n      saleAction = PresaleAction.SecondPresaleActivity;\r\n      lockCycle = 150;        // 150 days\r\n    }\r\n\r\n    if (_round == 3){\r\n      saleAction = PresaleAction.ThirdPresaleActivity;\r\n      lockCycle = 120;        // 120 days\r\n    }\r\n  }\r\n\r\n\r\n  /* End the setup of presale activities. */\r\n  function closeSale() public onlyOwner notpreSaleActive {\r\n    preSaleFinished = true;\r\n    saleAction = PresaleAction.END;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Distribute tokens from presale address to an address.\r\n   * @param _to address  The address which you want to distribute to\r\n   * @param _amount uint256  The amount of tokens to be distributed\r\n   * @param _lockCycle uint256  Token locking cycle.\r\n   * @param _duration uint256  The lock time for each cycle.\r\n   */\r\n  function _distribute(address _to, uint256 _amount, uint256 _lockCycle, uint256 _duration) internal returns(bool)  {\r\n    ////Do not allow multiple distributions of the same address. Avoid locking time reset.\r\n    require(_lockInfo[_to].amount == 0 );\r\n    require(_lockupBalances[_to] == 0);\r\n\r\n    _lockInfo[_to].amount = _amount;\r\n    _lockInfo[_to].releaseCount = _lockCycle;\r\n    _lockInfo[_to].start = now;\r\n    _lockInfo[_to].transfered = 0;\r\n    _lockInfo[_to].duration = _duration;\r\n    \r\n    //Easy to query locked balance\r\n    _lockupBalances[_to] = _amount;\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  /* Distribute tokens from presale address to an address. */\r\n  function distribute(address _to, uint256 _amount, uint256 _lockCycle, uint256 _duration) public onlyOwner beginSaleActive {\r\n    require(_to != 0x0);\r\n    require(_amount != 0 && _lockCycle != 0 && _duration != 0);\r\n    \r\n    _distribute(_to, _amount,_lockCycle, _duration * DURATION);\r\n    \r\n    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].sub(_amount);\r\n    emit Transfer(PRESALE_ADDRESS, _to, _amount);\r\n  }\r\n\r\n\r\n\r\n  /* Calculate the unlockable balance */\r\n  function _releasableAmount(address _owner, uint256 time) internal view returns (uint256){\r\n    lockInfo storage userLockInfo = _lockInfo[_owner]; \r\n    if (userLockInfo.transfered == userLockInfo.amount){\r\n      return 0;\r\n    }\r\n\r\n    // Unlockable tokens per cycle.\r\n    uint256 amountPerRelease = userLockInfo.amount.div(userLockInfo.releaseCount); //amount/cnt\r\n    // Total unlockable balance.\r\n    uint256 amount = amountPerRelease.mul((time.sub(userLockInfo.start)).div(userLockInfo.duration));\r\n\r\n    if (amount > userLockInfo.amount){\r\n      amount = userLockInfo.amount;\r\n    }\r\n    // \r\n    amount = amount.sub(userLockInfo.transfered);\r\n\r\n    return amount;\r\n  }\r\n\r\n\r\n  /* Unlock locked tokens */\r\n  function relaseLock() internal returns(uint256){\r\n    uint256 amount = _releasableAmount(msg.sender, now);\r\n    if (amount > 0){\r\n      _lockInfo[msg.sender].transfered = _lockInfo[msg.sender].transfered.add(amount);\r\n      balances[msg.sender] = balances[msg.sender].add(amount);\r\n      _lockupBalances[msg.sender] = _lockupBalances[msg.sender].sub(amount);\r\n      emit UnLock(msg.sender, amount);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n\r\n  function _initialize() internal {\r\n\r\n    uint256 PRESALE_SUPPLY = totalSupply.mul(20).div(100);          // 20% for presale\r\n    uint256 DPOS_SUPPLY = totalSupply.mul(30).div(100);             // 30% for DPOS\r\n    uint256 COMMUNITY_REWARDS_SUPPLY = totalSupply.mul(20).div(100);// 20% for community rewards\r\n    uint256 COMMUNITY_TEAM_SUPPLY = totalSupply.mul(10).div(100);   // 10% for community team\r\n    uint256 COMMERCIAL_PLAN_SUPPLY = totalSupply * 10 / 100;        // 10% for commercial plan\r\n    uint256 TEAM_SUPPLY = totalSupply.mul(10).div(100);             // 10% for technical team \r\n\r\n    balances[msg.sender] = PRESALE_SUPPLY;\r\n    balances[FOUNDATION_ADDRESS] = COMMUNITY_REWARDS_SUPPLY;\r\n    balances[POS_ADDRESS] = DPOS_SUPPLY;\r\n    balances[COMMERCIAL_PLAN_ADDRESS] = COMMERCIAL_PLAN_SUPPLY;\r\n\r\n    //This part of the token locks for one year。\r\n    _distribute(COMMUNITY_TEAM_ADDRESS, COMMUNITY_TEAM_SUPPLY, 1, 365 days);\r\n\r\n    //This part of the token is locked until August 1, divided into 2 phases to unlock.\r\n    _distribute(0x7C88a1EC1D25c232464549ea9eF72B9bDc2a010A, TEAM_SUPPLY.mul(20).div(100), 2, 70 days); //0801\r\n\r\n    // This part of the token locks for one year。\r\n    _distribute(TEAM_ADDRESS, TEAM_SUPPLY.mul(80).div(100), 1, 365 days);\r\n\r\n  }\r\n\r\n\r\n\r\n  function SEXNToken() public {\r\n    totalSupply = 580000000 * (10 ** 18); // 580 million\r\n    _initialize();\r\n  }\r\n\r\n\r\n  /**\r\n   * Fallback function\r\n   * \r\n   * The function without name is the default function that is called whenever anyone sends funds to a contract\r\n   * sell tokens automatic\r\n   */\r\n  function () external payable beginSaleActive {\r\n      sellTokens();\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Sell tokens to msg.sender\r\n   *\r\n   */\r\n  function sellTokens() public payable beginSaleActive {\r\n    require(msg.value > 0);\r\n\r\n    uint256 amount = msg.value;\r\n    uint256 tokens = amount.mul(rate);\r\n\r\n    // check there are tokens for sale;\r\n    require(tokens <= balances[PRESALE_ADDRESS]);\r\n\r\n    if (saleAction == PresaleAction.FirstPresaleActivity){\r\n      // The maximum amount of single users for presales in the first period is 20,000.\r\n      require (tokens <= CAT_FIRST);\r\n    }\r\n\r\n    // send tokens to buyer\r\n    _distribute(msg.sender, tokens, lockCycle, DURATION);\r\n\r\n    \r\n    balances[PRESALE_ADDRESS] = balances[PRESALE_ADDRESS].sub(tokens);\r\n\r\n    emit Transfer(PRESALE_ADDRESS, msg.sender, tokens);\r\n    emit SellTokens(msg.sender, tokens, rate);\r\n\r\n    forwardFunds();\r\n  }\r\n\r\n\r\n  // send ether to the fund collection wallet\r\n  // override to create custom fund forwarding mechanisms\r\n  function forwardFunds() internal {\r\n      wallet.transfer(msg.value);\r\n  }\r\n\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner].add(_lockupBalances[_owner]);\r\n  }\r\n\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    if (_lockupBalances[msg.sender] > 0){\r\n      relaseLock();\r\n    }\r\n\r\n    return  super.transfer( _to, _value);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_round\",\"type\":\"uint8\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_stopTime\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSaleInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainingPreSalesAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CAT_FIRST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getLockBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_lockCycle\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getLockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleAction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sellTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"SellTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SEXNToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9520763f1e147fee684bf4d8b7d625d7f5459bec3228059c208775fcfe35064f"}]}