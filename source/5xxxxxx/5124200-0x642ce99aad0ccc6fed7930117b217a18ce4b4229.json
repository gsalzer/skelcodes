{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n\r\n  Copyright 2017 Cofound.it.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.4.13;\r\n\r\ncontract ReentrnacyHandlingContract{\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\n\r\ncontract IToken {\r\n  function totalSupply() public constant returns (uint256 totalSupply);\r\n  function mintTokens(address _to, uint256 _amount) public {}\r\n}\r\n\r\ncontract IERC20Token {\r\n  function totalSupply() public constant returns (uint256 totalSupply);\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {}\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {}\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\r\n  function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract Crowdsale is ReentrnacyHandlingContract, Owned{\r\n\r\n  struct ContributorData{\r\n    uint priorityPassAllowance;\r\n    bool isActive;\r\n    uint contributionAmount;\r\n    uint tokensIssued;\r\n  }\r\n\r\n  mapping(address => ContributorData) public contributorList;\r\n  uint public nextContributorIndex;\r\n  mapping(uint => address) public contributorIndexes;\r\n\r\n  state public crowdsaleState = state.pendingStart;\r\n  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsale, crowdsaleEnded }\r\n\r\n  uint public presaleStartTime;\r\n  uint public presaleUnlimitedStartTime;\r\n  uint public crowdsaleStartTime;\r\n  uint public crowdsaleEndedTime;\r\n\r\n  event PresaleStarted(uint blockTime);\r\n  event PresaleUnlimitedStarted(uint blockTime);\r\n  event CrowdsaleStarted(uint blockTime);\r\n  event CrowdsaleEnded(uint blockTime);\r\n  event ErrorSendingETH(address to, uint amount);\r\n  event MinCapReached(uint blockTime);\r\n  event MaxCapReached(uint blockTime);\r\n  event ContributionMade(address indexed contributor, uint amount);\r\n\r\n\r\n  IToken token = IToken(0x0);\r\n  uint ethToTokenConversion;\r\n\r\n  uint public minCap;\r\n  uint public maxP1Cap;\r\n  uint public maxCap;\r\n  uint public ethRaised;\r\n\r\n  address public multisigAddress;\r\n\r\n  uint nextContributorToClaim;\r\n  mapping(address => bool) hasClaimedEthWhenFail;\r\n\r\n  uint public maxTokenSupply;\r\n  bool public ownerHasClaimedTokens;\r\n  uint public presaleBonusTokens;\r\n  address public presaleBonusAddress;\r\n  address public presaleBonusAddressColdStorage;\r\n  bool public presaleBonusTokensClaimed;\r\n\r\n  //\r\n  // Unnamed function that runs when eth is sent to the contract\r\n  // @payable\r\n  //\r\n  function() public noReentrancy payable{\r\n    require(msg.value != 0);                        // Throw if value is 0\r\n    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\r\n\r\n    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\r\n\r\n    if (crowdsaleState == state.priorityPass){\r\n      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\r\n        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\r\n      }else{\r\n        refundTransaction(stateChanged);            // Set state and return funds or throw\r\n      }\r\n    }\r\n    else if(crowdsaleState == state.openedPriorityPass){\r\n      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\r\n        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\r\n      }else{\r\n        refundTransaction(stateChanged);            // Set state and return funds or throw\r\n      }\r\n    }\r\n    else if(crowdsaleState == state.crowdsale){\r\n      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\r\n    }\r\n    else{\r\n      refundTransaction(stateChanged);              // Set state and return funds or throw\r\n    }\r\n  }\r\n\r\n  //\r\n  // Check crowdsale state and calibrate it\r\n  //\r\n  function checkCrowdsaleState() internal returns (bool){\r\n    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded){                         // Check if max cap is reached\r\n      crowdsaleState = state.crowdsaleEnded;\r\n      MaxCapReached(block.timestamp);                                                              // Close the crowdsale\r\n      CrowdsaleEnded(block.timestamp);                                                             // Raise event\r\n      return true;\r\n    }\r\n\r\n    if (block.timestamp > presaleStartTime && block.timestamp <= presaleUnlimitedStartTime){  // Check if we are in presale phase\r\n      if (crowdsaleState != state.priorityPass){                                          // Check if state needs to be changed\r\n        crowdsaleState = state.priorityPass;                                              // Set new state\r\n        PresaleStarted(block.timestamp);                                                     // Raise event\r\n        return true;\r\n      }\r\n    }else if(block.timestamp > presaleUnlimitedStartTime && block.timestamp <= crowdsaleStartTime){ // Check if we are in presale unlimited phase\r\n      if (crowdsaleState != state.openedPriorityPass){                                          // Check if state needs to be changed\r\n        crowdsaleState = state.openedPriorityPass;                                              // Set new state\r\n        PresaleUnlimitedStarted(block.timestamp);                                                  // Raise event\r\n        return true;\r\n      }\r\n    }else if(block.timestamp > crowdsaleStartTime && block.timestamp <= crowdsaleEndedTime){        // Check if we are in crowdsale state\r\n      if (crowdsaleState != state.crowdsale){                                                   // Check if state needs to be changed\r\n        crowdsaleState = state.crowdsale;                                                       // Set new state\r\n        CrowdsaleStarted(block.timestamp);                                                         // Raise event\r\n        return true;\r\n      }\r\n    }else{\r\n      if (crowdsaleState != state.crowdsaleEnded && block.timestamp > crowdsaleEndedTime){        // Check if crowdsale is over\r\n        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\r\n        CrowdsaleEnded(block.timestamp);                                                           // Raise event\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  //\r\n  // Decide if throw or only return ether\r\n  //\r\n  function refundTransaction(bool _stateChanged) internal{\r\n    if (_stateChanged){\r\n      msg.sender.transfer(msg.value);\r\n    }else{\r\n      revert();\r\n    }\r\n  }\r\n\r\n  //\r\n  // Calculate how much user can contribute\r\n  //\r\n  function calculateMaxContribution(address _contributor) constant returns (uint maxContribution){\r\n    uint maxContrib;\r\n    if (crowdsaleState == state.priorityPass){    // Check if we are in priority pass\r\n      maxContrib = contributorList[_contributor].priorityPassAllowance - contributorList[_contributor].contributionAmount;\r\n      if (maxContrib > (maxP1Cap - ethRaised)){   // Check if max contribution is more that max cap\r\n        maxContrib = maxP1Cap - ethRaised;        // Alter max cap\r\n      }\r\n    }\r\n    else{\r\n      maxContrib = maxCap - ethRaised;            // Alter max cap\r\n    }\r\n    return maxContrib;\r\n  }\r\n\r\n  //\r\n  // Issue tokens and return if there is overflow\r\n  //\r\n  function processTransaction(address _contributor, uint _amount) internal{\r\n    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\r\n    uint contributionAmount = _amount;\r\n    uint returnAmount = 0;\r\n    if (maxContribution < _amount){                                             // Check if max contribution is lower than _amount sent\r\n      contributionAmount = maxContribution;                                     // Set that user contributes his maximum allowed contribution\r\n      returnAmount = _amount - maxContribution;                                 // Calculate how much he must get back\r\n    }\r\n\r\n    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) MinCapReached(block.timestamp);\r\n\r\n    if (contributorList[_contributor].isActive == false){                       // Check if contributor has already contributed\r\n      contributorList[_contributor].isActive = true;                            // Set his activity to true\r\n      contributorList[_contributor].contributionAmount = contributionAmount;    // Set his contribution\r\n      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\r\n      nextContributorIndex++;\r\n    }\r\n    else{\r\n      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\r\n    }\r\n    ethRaised += contributionAmount;                                            // Add to eth raised\r\n\r\n    ContributionMade(msg.sender, contributionAmount);\r\n\r\n    uint tokenAmount = contributionAmount * ethToTokenConversion;               // Calculate how much tokens must contributor get\r\n    if (tokenAmount > 0){\r\n      token.mintTokens(_contributor, tokenAmount);                                // Issue new tokens\r\n      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\r\n    }\r\n    if (returnAmount != 0) _contributor.transfer(returnAmount);                 // Return overflow of ether\r\n  }\r\n\r\n  //\r\n  // Push contributor data to the contract before the crowdsale so that they are eligible for priority pass\r\n  //\r\n  function editContributors(address[] _contributorAddresses, uint[] _contributorPPAllowances) public onlyOwner{\r\n    require(_contributorAddresses.length == _contributorPPAllowances.length); // Check if input data is correct\r\n\r\n    for(uint cnt = 0; cnt < _contributorAddresses.length; cnt++){\r\n      if (contributorList[_contributorAddresses[cnt]].isActive){\r\n        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\r\n      }\r\n      else{\r\n        contributorList[_contributorAddresses[cnt]].isActive = true;\r\n        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\r\n        contributorIndexes[nextContributorIndex] = _contributorAddresses[cnt];\r\n        nextContributorIndex++;\r\n      }\r\n    }\r\n  }\r\n\r\n  //\r\n  // Method is needed for recovering tokens accidentally sent to token address\r\n  //\r\n  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) public onlyOwner{\r\n    IERC20Token(_tokenAddress).transfer(_to, _amount);\r\n  }\r\n\r\n  //\r\n  // withdrawEth when minimum cap is reached\r\n  // @owner sets contributions to withdraw\r\n  //\r\n  function withdrawEth() onlyOwner public {\r\n    require(this.balance != 0);\r\n    require(ethRaised >= minCap);\r\n\r\n    pendingEthWithdrawal = this.balance;\r\n  }\r\n\r\n\r\n  uint public pendingEthWithdrawal;\r\n  //\r\n  // pulls the funds that were set to send with calling of\r\n  // withdrawEth when minimum cap is reached\r\n  // @multisig pulls the contributions to self\r\n  //\r\n  function pullBalance() public {\r\n    require(msg.sender == multisigAddress);\r\n    require(pendingEthWithdrawal > 0);\r\n\r\n    multisigAddress.transfer(pendingEthWithdrawal);\r\n    pendingEthWithdrawal = 0;\r\n  }\r\n\r\n  //\r\n  // Users can claim their contribution if min cap is not raised\r\n  //\r\n  function claimEthIfFailed() public {\r\n    require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap);    // Check if crowdsale has failed\r\n    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedTime\r\n    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\r\n\r\n    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\r\n    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\r\n    if (!msg.sender.send(ethContributed)){                                // Refund eth\r\n      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\r\n    }\r\n  }\r\n\r\n  //\r\n  // Owner can batch return contributors contributions(eth)\r\n  //\r\n  function batchReturnEthIfFailed(uint _numberOfReturns) public onlyOwner{\r\n    require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap);                // Check if crowdsale has failed\r\n    address currentParticipantAddress;\r\n    uint contribution;\r\n    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\r\n      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\r\n      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\r\n      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\r\n        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\r\n        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\r\n        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\r\n          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\r\n        }\r\n      }\r\n      nextContributorToClaim += 1;                                                    // Repeat\r\n    }\r\n  }\r\n\r\n  //\r\n  // If there were any issue/attach with refund owner can withdraw eth at the end for manual recovery\r\n  //\r\n  function withdrawRemainingBalanceForManualRecovery() public onlyOwner{\r\n    require(this.balance != 0);                                  // Check if there are any eth to claim\r\n    require(block.timestamp > crowdsaleEndedTime);                 // Check if crowdsale is over\r\n    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\r\n    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\r\n  }\r\n\r\n  //\r\n  // Owner can set multisig address for crowdsale\r\n  //\r\n  function setMultisigAddress(address _newAddress) public onlyOwner{\r\n    multisigAddress = _newAddress;\r\n  }\r\n\r\n  //\r\n  // Owner can set token address where mints will happen\r\n  //\r\n  function setToken(address _newAddress) public onlyOwner{\r\n    token = IToken(_newAddress);\r\n  }\r\n\r\n  //\r\n  // Owner can claim teams tokens when crowdsale has successfully ended\r\n  //\r\n  function claimCoreTeamsTokens(address _to) public onlyOwner{\r\n    require(crowdsaleState == state.crowdsaleEnded);              // Check if crowdsale has ended\r\n    require(!ownerHasClaimedTokens);                              // Check if owner has already claimed tokens\r\n\r\n    uint devReward = maxTokenSupply - token.totalSupply();\r\n    if (!presaleBonusTokensClaimed) devReward -= presaleBonusTokens; // If presaleBonusToken has been claimed its ok if not set aside presaleBonusTokens\r\n    token.mintTokens(_to, devReward);                             // Issue Teams tokens\r\n    ownerHasClaimedTokens = true;                                 // Block further mints from this method\r\n  }\r\n\r\n  //\r\n  // Presale bonus tokens\r\n  //\r\n  function claimPresaleTokens() public {\r\n    require(msg.sender == presaleBonusAddress);         // Check if sender is address to claim tokens\r\n    require(crowdsaleState == state.crowdsaleEnded);    // Check if crowdsale has ended\r\n    require(!presaleBonusTokensClaimed);                // Check if tokens were already claimed\r\n\r\n    token.mintTokens(presaleBonusAddressColdStorage, presaleBonusTokens);             // Issue presale  tokens\r\n    presaleBonusTokensClaimed = true;                   // Block further mints from this method\r\n  }\r\n\r\n  function getTokenAddress() public constant returns(address){\r\n    return address(token);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract FutouristCrowdsale is Crowdsale {\r\n  function FutouristCrowdsale() public {\r\n    /* ADAPT */\r\n    presaleStartTime = 1519142400; //20/2/2017/1700\r\n    presaleUnlimitedStartTime = 1519315200; //22/2/2017/1700\r\n    crowdsaleStartTime = 1519747200; //27/2/2017/1700\r\n    crowdsaleEndedTime = 1521561600; //20/3/2017/1700\r\n\r\n    minCap = 1 ether;\r\n    maxCap = 4979 ether;\r\n    maxP1Cap = 4979 ether;\r\n\r\n    ethToTokenConversion = 47000;\r\n\r\n    maxTokenSupply = 1000000000 * 10**18;\r\n    presaleBonusTokens = 115996000  * 10**18;\r\n    presaleBonusAddress = 0xd7C4af0e30EC62a01036e45b6ed37BC6D0a3bd53;\r\n    presaleBonusAddressColdStorage = 0x47D634Ce50170a156ec4300d35BE3b48E17CAaf6;\r\n    /* /ADAPT */\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setMultisigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleUnlimitedStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimPresaleTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributorIndexes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleBonusAddressColdStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributorAddresses\",\"type\":\"address[]\"},{\"name\":\"_contributorPPAllowances\",\"type\":\"uint256[]\"}],\"name\":\"editContributors\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRemainingBalanceForManualRecovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingEthWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxP1Cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokenSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleBonusTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"calculateMaxContribution\",\"outputs\":[{\"name\":\"maxContribution\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleBonusAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numberOfReturns\",\"type\":\"uint256\"}],\"name\":\"batchReturnEthIfFailed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimCoreTeamsTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributorList\",\"outputs\":[{\"name\":\"priorityPassAllowance\",\"type\":\"uint256\"},{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"name\":\"tokensIssued\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextContributorIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pullBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleBonusTokensClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerHasClaimedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"PresaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"PresaleUnlimitedStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ErrorSendingETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"MinCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockTime\",\"type\":\"uint256\"}],\"name\":\"MaxCapReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContributionMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"FutouristCrowdsale","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://074c244cbdf7b193906def32164fa9c58fc4cfb498ba516dbc5b81c9e9a98fe6"}]}