{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancy_lock);\r\n    reentrancy_lock = true;\r\n    _;\r\n    reentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\nlibrary Utils {\r\n  function isEther(address addr) internal pure returns (bool) {\r\n    return addr == address(0x0);\r\n  }\r\n}\r\n\r\n\r\ncontract DUBIex is ReentrancyGuard {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n  \r\n  // order\r\n  struct Order {\r\n    uint256 id;\r\n    address maker;\r\n    uint256 amount;\r\n    address pairA;\r\n    address pairB;\r\n    uint256 priceA;\r\n    uint256 priceB;\r\n  }\r\n\r\n  // order id -> order\r\n  mapping(uint256 => Order) public orders;\r\n\r\n  // weiSend of current tx\r\n  uint256 private weiSend = 0;\r\n\r\n  // makes sure weiSend of current tx is reset\r\n  modifier weiSendGuard() {\r\n    weiSend = msg.value;\r\n    _;\r\n    weiSend = 0;\r\n  }\r\n\r\n  // logs\r\n  event LogMakeOrder(uint256 id, address indexed maker, uint256 amount, address indexed pairA, address indexed pairB, uint256 priceA, uint256 priceB);\r\n  event LogTakeOrder(uint256 indexed id, address indexed taker, uint256 amount);\r\n  event LogCancelOrder(uint256 indexed id);\r\n\r\n  // internal\r\n  function _makeOrder(uint256 id, uint256 amount, address pairA, address pairB, uint256 priceA, uint256 priceB, address maker) internal returns (bool) {\r\n    // validate input\r\n    if (\r\n      id <= 0 ||\r\n      amount <= 0 ||\r\n      pairA == pairB ||\r\n      priceA <= 0 ||\r\n      priceB <= 0 ||\r\n      orders[id].id == id\r\n    ) return false;\r\n\r\n    bool pairAisEther = Utils.isEther(pairA);\r\n    ERC20 tokenA = ERC20(pairA);\r\n\r\n    // validate maker's deposit\r\n    if (pairAisEther && (weiSend <= 0 || weiSend < amount)) return false;\r\n    else if (!pairAisEther && (tokenA.allowance(maker, this) < amount || tokenA.balanceOf(maker) < amount)) return false;\r\n\r\n    // update state\r\n    orders[id] = Order(id, maker, amount, pairA, pairB, priceA, priceB);\r\n\r\n    // retrieve makers amount\r\n    if (pairAisEther) {\r\n      // eth already received, subtract used wei\r\n      weiSend = weiSend.sub(amount);\r\n    } else {\r\n      // pull tokens\r\n      tokenA.safeTransferFrom(maker, this, amount);\r\n    }\r\n\r\n    LogMakeOrder(id, maker, amount, pairA, pairB, priceA, priceB);\r\n\r\n    return true;\r\n  }\r\n\r\n  function _takeOrder(uint256 id, uint256 amount, address taker) internal returns (bool) {\r\n    // validate inputs\r\n    if (\r\n      id <= 0 ||\r\n      amount <= 0\r\n    ) return false;\r\n    \r\n    // get order\r\n    Order storage order = orders[id];\r\n    // validate order\r\n    if (order.id != id) return false;\r\n    \r\n    bool pairAisEther = Utils.isEther(order.pairA);\r\n    bool pairBisEther = Utils.isEther(order.pairB);\r\n    // amount of pairA usable\r\n    uint256 usableAmount = amount > order.amount ? order.amount : amount;\r\n    // amount of pairB maker will receive\r\n    uint256 totalB = usableAmount.mul(order.priceB).div(order.priceA);\r\n\r\n    // token interfaces\r\n    ERC20 tokenA = ERC20(order.pairA);\r\n    ERC20 tokenB = ERC20(order.pairB);\r\n\r\n    // validate taker's deposit\r\n    if (pairBisEther && (weiSend <= 0 || weiSend < totalB)) return false;\r\n    else if (!pairBisEther && (tokenB.allowance(taker, this) < totalB || tokenB.balanceOf(taker) < amount)) return false;\r\n\r\n    // update state\r\n    order.amount = order.amount.sub(usableAmount);\r\n\r\n    // pay maker\r\n    if (pairBisEther) {\r\n      weiSend = weiSend.sub(totalB);\r\n      order.maker.transfer(totalB);\r\n    } else {\r\n      tokenB.safeTransferFrom(taker, order.maker, totalB);\r\n    }\r\n\r\n    // pay taker\r\n    if (pairAisEther) {\r\n      taker.transfer(usableAmount);\r\n    } else {\r\n      tokenA.safeTransfer(taker, usableAmount);\r\n    }\r\n\r\n    LogTakeOrder(id, taker, usableAmount);\r\n\r\n    return true;\r\n  }\r\n\r\n  function _cancelOrder(uint256 id, address maker) internal returns (bool) {\r\n    // validate inputs\r\n    if (id <= 0) return false;\r\n\r\n    // get order\r\n    Order storage order = orders[id];\r\n    if (\r\n      order.id != id ||\r\n      order.maker != maker\r\n    ) return false;\r\n\r\n    uint256 amount = order.amount;\r\n    bool pairAisEther = Utils.isEther(order.pairA);\r\n\r\n    // update state\r\n    order.amount = 0;\r\n\r\n    // actions\r\n    if (pairAisEther) {\r\n      order.maker.transfer(amount);\r\n    } else {\r\n      ERC20(order.pairA).safeTransfer(order.maker, amount);\r\n    }\r\n\r\n    LogCancelOrder(id);\r\n\r\n    return true;\r\n  }\r\n\r\n  // single\r\n  function makeOrder(uint256 id, uint256 amount, address pairA, address pairB, uint256 priceA, uint256 priceB) external payable weiSendGuard nonReentrant returns (bool) {\r\n    bool success = _makeOrder(id, amount, pairA, pairB, priceA, priceB, msg.sender);\r\n\r\n    if (weiSend > 0) msg.sender.transfer(weiSend);\r\n\r\n    return success;\r\n  }\r\n\r\n  function takeOrder(uint256 id, uint256 amount) external payable weiSendGuard nonReentrant returns (bool) {\r\n    bool success = _takeOrder(id, amount, msg.sender);\r\n\r\n    if (weiSend > 0) msg.sender.transfer(weiSend);\r\n\r\n    return success;\r\n  }\r\n\r\n  function cancelOrder(uint256 id) external nonReentrant returns (bool) {\r\n    return _cancelOrder(id, msg.sender);\r\n  }\r\n\r\n  // multi\r\n  function makeOrders(uint256[] ids, uint256[] amounts, address[] pairAs, address[] pairBs, uint256[] priceAs, uint256[] priceBs) external payable weiSendGuard nonReentrant returns (bool) {\r\n    require(\r\n      amounts.length == ids.length &&\r\n      pairAs.length == ids.length &&\r\n      pairBs.length == ids.length &&\r\n      priceAs.length == ids.length &&\r\n      priceBs.length == ids.length\r\n    );\r\n\r\n    bool allSuccess = true;\r\n\r\n    for (uint256 i = 0; i < ids.length; i++) {\r\n      // update if any of the orders failed\r\n      // the function is like this because \"stack too deep\" error\r\n      if (allSuccess && !_makeOrder(ids[i], amounts[i], pairAs[i], pairBs[i], priceAs[i], priceBs[i], msg.sender)) allSuccess = false;\r\n    }\r\n\r\n    if (weiSend > 0) msg.sender.transfer(weiSend);\r\n\r\n    return allSuccess;\r\n  }\r\n\r\n  function takeOrders(uint256[] ids, uint256[] amounts) external payable weiSendGuard nonReentrant returns (bool) {\r\n    require(ids.length == amounts.length);\r\n\r\n    bool allSuccess = true;\r\n\r\n    for (uint256 i = 0; i < ids.length; i++) {\r\n      bool success = _takeOrder(ids[i], amounts[i], msg.sender);\r\n\r\n      // update if any of the orders failed\r\n      if (allSuccess && !success) allSuccess = success;\r\n    }\r\n\r\n    if (weiSend > 0) msg.sender.transfer(weiSend);\r\n\r\n    return allSuccess;\r\n  }\r\n\r\n  function cancelOrders(uint256[] ids) external nonReentrant returns (bool) {\r\n    bool allSuccess = true;\r\n\r\n    for (uint256 i = 0; i < ids.length; i++) {\r\n      bool success = _cancelOrder(ids[i], msg.sender);\r\n\r\n      // update if any of the orders failed\r\n      if (allSuccess && !success) allSuccess = success;\r\n    }\r\n\r\n    return allSuccess;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"takeOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"pairA\",\"type\":\"address\"},{\"name\":\"pairB\",\"type\":\"address\"},{\"name\":\"priceA\",\"type\":\"uint256\"},{\"name\":\"priceB\",\"type\":\"uint256\"}],\"name\":\"makeOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"takeOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"pairA\",\"type\":\"address\"},{\"name\":\"pairB\",\"type\":\"address\"},{\"name\":\"priceA\",\"type\":\"uint256\"},{\"name\":\"priceB\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"cancelOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"pairAs\",\"type\":\"address[]\"},{\"name\":\"pairBs\",\"type\":\"address[]\"},{\"name\":\"priceAs\",\"type\":\"uint256[]\"},{\"name\":\"priceBs\",\"type\":\"uint256[]\"}],\"name\":\"makeOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"pairA\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"pairB\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceA\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"priceB\",\"type\":\"uint256\"}],\"name\":\"LogMakeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogTakeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogCancelOrder\",\"type\":\"event\"}]","ContractName":"DUBIex","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://496ae87aa1f0931306cf087a2e0ee01526ff0d936b9ac1b61d1f9b4eab88cbc5"}]}