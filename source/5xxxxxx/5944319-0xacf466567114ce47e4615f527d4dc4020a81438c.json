{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() onlyPendingOwner public {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\ncontract AccessByGame is Pausable, Claimable {\r\n  mapping(address => bool) internal contractAccess;\r\n\r\n  modifier onlyAccessByGame {\r\n    require(!paused && (msg.sender == owner || contractAccess[msg.sender] == true));\r\n    _;\r\n  }\r\n\r\n  function grantAccess(address _address)\r\n    onlyOwner\r\n    public\r\n  {\r\n    contractAccess[_address] = true;\r\n  }\r\n\r\n  function revokeAccess(address _address)\r\n    onlyOwner\r\n    public\r\n  {\r\n    contractAccess[_address] = false;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title ERC827 interface, an extension of ERC20 token standard\r\n *\r\n * @dev Interface of a ERC827 token, following the ERC20 standard with extra\r\n * @dev methods to transfer value and data and execute calls in transfers and\r\n * @dev approvals.\r\n */\r\ncontract ERC827 is ERC20 {\r\n  function approveAndCall(\r\n    address _spender,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    returns (bool);\r\n\r\n  function transferAndCall(\r\n    address _to,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    returns (bool);\r\n\r\n  function transferFromAndCall(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    returns (bool);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC827Caller {\r\n  function makeCall(address _target, bytes _data) external payable returns (bool) {\r\n    // solium-disable-next-line security/no-call-value\r\n    return _target.call.value(msg.value)(_data);\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC827, an extension of ERC20 token standard\r\n *\r\n * @dev Implementation the ERC827, following the ERC20 standard with extra\r\n * @dev methods to transfer value and data and execute calls in transfers and\r\n * @dev approvals.\r\n *\r\n * @dev Uses OpenZeppelin StandardToken.\r\n */\r\ncontract ERC827Token is ERC827, StandardToken {\r\n  ERC827Caller internal caller_;\r\n\r\n  constructor() public {\r\n    caller_ = new ERC827Caller();\r\n  }\r\n\r\n  /**\r\n   * @dev Addition to ERC20 token methods. It allows to\r\n   * @dev approve the transfer of value and execute a call with the sent data.\r\n   *\r\n   * @dev Beware that changing an allowance with this method brings the risk that\r\n   * @dev someone may use both the old and the new allowance by unfortunate\r\n   * @dev transaction ordering. One possible solution to mitigate this race condition\r\n   * @dev is to first reduce the spender's allowance to 0 and set the desired value\r\n   * @dev afterwards:\r\n   * @dev https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * @param _spender The address that will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   * @param _data ABI-encoded contract call to call `_to` address.\r\n   *\r\n   * @return true if the call function was executed successfully\r\n   */\r\n  function approveAndCall(\r\n    address _spender,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    returns (bool)\r\n  {\r\n    require(_spender != address(this));\r\n\r\n    super.approve(_spender, _value);\r\n\r\n    // solium-disable-next-line security/no-call-value\r\n    require(caller_.makeCall.value(msg.value)(_spender, _data));\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Addition to ERC20 token methods. Transfer tokens to a specified\r\n   * @dev address and execute a call with the sent data on the same transaction\r\n   *\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   * @param _data ABI-encoded contract call to call `_to` address.\r\n   *\r\n   * @return true if the call function was executed successfully\r\n   */\r\n  function transferAndCall(\r\n    address _to,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    returns (bool)\r\n  {\r\n    require(_to != address(this));\r\n\r\n    super.transfer(_to, _value);\r\n\r\n    // solium-disable-next-line security/no-call-value\r\n    require(caller_.makeCall.value(msg.value)(_to, _data));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Addition to ERC20 token methods. Transfer tokens from one address to\r\n   * @dev another and make a contract call on the same transaction\r\n   *\r\n   * @param _from The address which you want to send tokens from\r\n   * @param _to The address which you want to transfer to\r\n   * @param _value The amout of tokens to be transferred\r\n   * @param _data ABI-encoded contract call to call `_to` address.\r\n   *\r\n   * @return true if the call function was executed successfully\r\n   */\r\n  function transferFromAndCall(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public payable returns (bool)\r\n  {\r\n    require(_to != address(this));\r\n\r\n    super.transferFrom(_from, _to, _value);\r\n\r\n    // solium-disable-next-line security/no-call-value\r\n    require(caller_.makeCall.value(msg.value)(_to, _data));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Addition to StandardToken methods. Increase the amount of tokens that\r\n   * @dev an owner allowed to a spender and execute a call with the sent data.\r\n   *\r\n   * @dev approve should be called when allowed[_spender] == 0. To increment\r\n   * @dev allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * @dev the first transaction is mined)\r\n   * @dev From MonolithDAO Token.sol\r\n   *\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   * @param _data ABI-encoded contract call to call `_spender` address.\r\n   */\r\n  function increaseApprovalAndCall(\r\n    address _spender,\r\n    uint _addedValue,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    returns (bool)\r\n  {\r\n    require(_spender != address(this));\r\n\r\n    super.increaseApproval(_spender, _addedValue);\r\n\r\n    // solium-disable-next-line security/no-call-value\r\n    require(caller_.makeCall.value(msg.value)(_spender, _data));\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Addition to StandardToken methods. Decrease the amount of tokens that\r\n   * @dev an owner allowed to a spender and execute a call with the sent data.\r\n   *\r\n   * @dev approve should be called when allowed[_spender] == 0. To decrement\r\n   * @dev allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * @dev the first transaction is mined)\r\n   * @dev From MonolithDAO Token.sol\r\n   *\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   * @param _data ABI-encoded contract call to call `_spender` address.\r\n   */\r\n  function decreaseApprovalAndCall(\r\n    address _spender,\r\n    uint _subtractedValue,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    returns (bool)\r\n  {\r\n    require(_spender != address(this));\r\n\r\n    super.decreaseApproval(_spender, _subtractedValue);\r\n\r\n    // solium-disable-next-line security/no-call-value\r\n    require(caller_.makeCall.value(msg.value)(_spender, _data));\r\n\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    hasMintPermission\r\n    canMint\r\n    public\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n/// @title EverGold\r\n/// @dev ERC827 Token for games.\r\ncontract EverGold is ERC827Token, MintableToken, AccessByGame {\r\n  string public constant name = \"Ever Gold\";\r\n  string public constant symbol = \"EG\";\r\n  uint8 public constant decimals = 0;\r\n\r\n/**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    onlyAccessByGame\r\n    canMint\r\n    public\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n  function transfer(address _to, uint256 _value)\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function approveAndCall(\r\n    address _spender,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.approveAndCall(_spender, _value, _data);\r\n  }\r\n\r\n  function transferAndCall(\r\n    address _to,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transferAndCall(_to, _value, _data);\r\n  }\r\n\r\n  function transferFromAndCall(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transferFromAndCall(_from, _to, _value, _data);\r\n  }\r\n\r\n  function increaseApprovalAndCall(\r\n    address _spender,\r\n    uint _addedValue,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.increaseApprovalAndCall(_spender, _addedValue, _data);\r\n  }\r\n\r\n  function decreaseApprovalAndCall(\r\n    address _spender,\r\n    uint _subtractedValue,\r\n    bytes _data\r\n  )\r\n    public\r\n    payable\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.decreaseApprovalAndCall(_spender, _subtractedValue, _data);\r\n  }\r\n}\r\n\r\nlibrary StringLib {\r\n  function generateName(bytes16 _s, uint256 _len, uint256 _n)\r\n    public\r\n    pure\r\n    returns (bytes16 ret)\r\n  {\r\n    uint256 v = _n;\r\n    bytes16 num = 0;\r\n    while (v > 0) {\r\n      num = bytes16(uint(num) / (2 ** 8));\r\n      num |= bytes16(((v % 10) + 48) * 2 ** (8 * 15));\r\n      v /= 10;\r\n    }\r\n    ret = _s | bytes16(uint(num) / (2 ** (8 * _len)));\r\n    return ret;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() public view returns (string _name);\r\n  function symbol() public view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is ERC721Basic {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  // Mapping from token ID to owner\r\n  mapping (uint256 => address) internal tokenOwner;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping (uint256 => address) internal tokenApprovals;\r\n\r\n  // Mapping from owner to number of owned token\r\n  mapping (address => uint256) internal ownedTokensCount;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n  /**\r\n   * @dev Guarantees msg.sender is owner of the given token\r\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n   */\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n   * @param _tokenId uint256 ID of the token to validate\r\n   */\r\n  modifier canTransfer(uint256 _tokenId) {\r\n    require(isApprovedOrOwner(msg.sender, _tokenId));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address\r\n   * @param _owner address to query the balance of\r\n   * @return uint256 representing the amount owned by the passed address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownedTokensCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the owner of the specified token ID\r\n   * @param _tokenId uint256 ID of the token to query the owner of\r\n   * @return owner address currently marked as the owner of the given token ID\r\n   */\r\n  function ownerOf(uint256 _tokenId) public view returns (address) {\r\n    address owner = tokenOwner[_tokenId];\r\n    require(owner != address(0));\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the specified token exists\r\n   * @param _tokenId uint256 ID of the token to query the existence of\r\n   * @return whether the token exists\r\n   */\r\n  function exists(uint256 _tokenId) public view returns (bool) {\r\n    address owner = tokenOwner[_tokenId];\r\n    return owner != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Approves another address to transfer the given token ID\r\n   * @dev The zero address indicates there is no approved address.\r\n   * @dev There can only be one approved address per token at a given time.\r\n   * @dev Can only be called by the token owner or an approved operator.\r\n   * @param _to address to be approved for the given token ID\r\n   * @param _tokenId uint256 ID of the token to be approved\r\n   */\r\n  function approve(address _to, uint256 _tokenId) public {\r\n    address owner = ownerOf(_tokenId);\r\n    require(_to != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n      tokenApprovals[_tokenId] = _to;\r\n      emit Approval(owner, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the approved address for a token ID, or zero if no address set\r\n   * @param _tokenId uint256 ID of the token to query the approval of\r\n   * @return address currently approved for the given token ID\r\n   */\r\n  function getApproved(uint256 _tokenId) public view returns (address) {\r\n    return tokenApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Sets or unsets the approval of a given operator\r\n   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n   * @param _to operator address to set the approval\r\n   * @param _approved representing the status of the approval to be set\r\n   */\r\n  function setApprovalForAll(address _to, bool _approved) public {\r\n    require(_to != msg.sender);\r\n    operatorApprovals[msg.sender][_to] = _approved;\r\n    emit ApprovalForAll(msg.sender, _to, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Tells whether an operator is approved by a given owner\r\n   * @param _owner owner address which you want to query the approval of\r\n   * @param _operator operator address which you want to query the approval of\r\n   * @return bool whether the given operator is approved by the given owner\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of a given token ID to another address\r\n   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    require(_from != address(0));\r\n    require(_to != address(0));\r\n\r\n    clearApproval(_from, _tokenId);\r\n    removeTokenFrom(_from, _tokenId);\r\n    addTokenTo(_to, _tokenId);\r\n\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n  */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    // solium-disable-next-line arg-overflow\r\n    safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Safely transfers the ownership of a given token ID to another address\r\n   * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n   *  which is called upon a safe transfer, and return the magic value\r\n   *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n   *  the transfer is reverted.\r\n   * @dev Requires the msg sender to be the owner, approved, or operator\r\n   * @param _from current owner of the token\r\n   * @param _to address to receive the ownership of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes data to send along with a safe transfer check\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    canTransfer(_tokenId)\r\n  {\r\n    transferFrom(_from, _to, _tokenId);\r\n    // solium-disable-next-line arg-overflow\r\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether the given spender can transfer a given token ID\r\n   * @param _spender address of the spender to query\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @return bool whether the msg.sender is approved for the given token ID,\r\n   *  is an operator of the owner, or is the owner of the token\r\n   */\r\n  function isApprovedOrOwner(\r\n    address _spender,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    address owner = ownerOf(_tokenId);\r\n    // Disable solium check because of\r\n    // https://github.com/duaraghav8/Solium/issues/175\r\n    // solium-disable-next-line operator-whitespace\r\n    return (\r\n      _spender == owner ||\r\n      getApproved(_tokenId) == _spender ||\r\n      isApprovedForAll(owner, _spender)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to The address that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    require(_to != address(0));\r\n    addTokenTo(_to, _tokenId);\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    clearApproval(_owner, _tokenId);\r\n    removeTokenFrom(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to clear current approval of a given token ID\r\n   * @dev Reverts if the given address is not indeed the owner of the token\r\n   * @param _owner owner of the token\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   */\r\n  function clearApproval(address _owner, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _owner);\r\n    if (tokenApprovals[_tokenId] != address(0)) {\r\n      tokenApprovals[_tokenId] = address(0);\r\n      emit Approval(_owner, address(0), _tokenId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    require(tokenOwner[_tokenId] == address(0));\r\n    tokenOwner[_tokenId] = _to;\r\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    require(ownerOf(_tokenId) == _from);\r\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n    tokenOwner[_tokenId] = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to invoke `onERC721Received` on a target address\r\n   * @dev The call is not executed if the target address is not a contract\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _to target address that will receive the tokens\r\n   * @param _tokenId uint256 ID of the token to be transferred\r\n   * @param _data bytes optional data to send along with the call\r\n   * @return whether the call correctly returned the expected magic value\r\n   */\r\n  function checkAndCallSafeTransfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    returns (bool)\r\n  {\r\n    if (!_to.isContract()) {\r\n      return true;\r\n    }\r\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n      _from, _tokenId, _data);\r\n    return (retval == ERC721_RECEIVED);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Token is ERC721, ERC721BasicToken {\r\n  // Token name\r\n  string internal name_;\r\n\r\n  // Token symbol\r\n  string internal symbol_;\r\n\r\n  // Mapping from owner to list of owned token IDs\r\n  mapping(address => uint256[]) internal ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n  // Array with all token ids, used for enumeration\r\n  uint256[] internal allTokens;\r\n\r\n  // Mapping from token id to position in the allTokens array\r\n  mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n  // Optional mapping for token URIs\r\n  mapping(uint256 => string) internal tokenURIs;\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  constructor(string _name, string _symbol) public {\r\n    name_ = _name;\r\n    symbol_ = _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token name\r\n   * @return string representing the token name\r\n   */\r\n  function name() public view returns (string) {\r\n    return name_;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token symbol\r\n   * @return string representing the token symbol\r\n   */\r\n  function symbol() public view returns (string) {\r\n    return symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an URI for a given token ID\r\n   * @dev Throws if the token ID does not exist. May return an empty string.\r\n   * @param _tokenId uint256 ID of the token to query\r\n   */\r\n  function tokenURI(uint256 _tokenId) public view returns (string) {\r\n    require(exists(_tokenId));\r\n    return tokenURIs[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n   * @param _owner address owning the tokens list to be accessed\r\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < balanceOf(_owner));\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total amount of tokens stored by the contract\r\n   * @return uint256 representing the total amount of tokens\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of all the tokens in this contract\r\n   * @dev Reverts if the index is greater or equal to the total number of tokens\r\n   * @param _index uint256 representing the index to be accessed of the tokens list\r\n   * @return uint256 token ID at the given index of the tokens list\r\n   */\r\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n    require(_index < totalSupply());\r\n    return allTokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to set the token URI for a given token\r\n   * @dev Reverts if the token ID does not exist\r\n   * @param _tokenId uint256 ID of the token to set its URI\r\n   * @param _uri string URI to assign\r\n   */\r\n  function _setTokenURI(uint256 _tokenId, string _uri) internal {\r\n    require(exists(_tokenId));\r\n    tokenURIs[_tokenId] = _uri;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function addTokenTo(address _to, uint256 _tokenId) internal {\r\n    super.addTokenTo(_to, _tokenId);\r\n    uint256 length = ownedTokens[_to].length;\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n    super.removeTokenFrom(_from, _tokenId);\r\n\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * @dev Reverts if the given token ID already exists\r\n   * @param _to address the beneficiary that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal {\r\n    super._mint(_to, _tokenId);\r\n\r\n    allTokensIndex[_tokenId] = allTokens.length;\r\n    allTokens.push(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to burn a specific token\r\n   * @dev Reverts if the token does not exist\r\n   * @param _owner owner of the token to burn\r\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n   */\r\n  function _burn(address _owner, uint256 _tokenId) internal {\r\n    super._burn(_owner, _tokenId);\r\n\r\n    // Clear metadata (if any)\r\n    if (bytes(tokenURIs[_tokenId]).length != 0) {\r\n      delete tokenURIs[_tokenId];\r\n    }\r\n\r\n    // Reorg all tokens array\r\n    uint256 tokenIndex = allTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = allTokens.length.sub(1);\r\n    uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n    allTokens[tokenIndex] = lastToken;\r\n    allTokens[lastTokenIndex] = 0;\r\n\r\n    allTokens.length--;\r\n    allTokensIndex[_tokenId] = 0;\r\n    allTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n}\r\n\r\ncontract NinjaToken is ERC721Token, AccessByGame {\r\n  string public constant NAME = \"Crypto Ninja Game Ninja\";\r\n  string public constant SYMBOL = \"CNN\";\r\n\r\n  event NewNinja(uint256 ninjaid, bytes16 name, bytes32 pattern);\r\n\r\n  struct Ninja {\r\n    bytes32 pattern;\r\n    bytes16 name;\r\n    uint16 level;\r\n    uint32 exp;\r\n    uint8 dna1;\r\n    uint8 dna2;\r\n    uint32 readyTime;\r\n    uint16 winCount;\r\n    uint8 levelPoint;\r\n    uint16 lossCount;\r\n    uint16 reward;\r\n    uint256 lastAttackedCastleid;\r\n  }\r\n\r\n  mapping (uint256 => bytes) private paths;\r\n\r\n  mapping (uint256 => bytes) private steps;\r\n\r\n  EverGold internal goldToken;\r\n\r\n  uint8 internal expOnSuccess = 3;\r\n  uint8 internal expOnFault = 1;\r\n  uint8 internal leveupExp = 10;\r\n\r\n  uint256 internal cooldownTime = 5 minutes;\r\n\r\n  uint256 internal maxCoordinate = 12;\r\n\r\n  Ninja[] internal ninjas;\r\n\r\n  uint256 private randNonce = 0;\r\n\r\n  uint8 public kindCount = 2;\r\n  uint32[] public COLORS = [\r\n    0xD7003A00,\r\n    0xF3980000,\r\n    0x00552E00,\r\n    0x19448E00,\r\n    0x543F3200,\r\n    0xE7609E00,\r\n    0xFFEC4700,\r\n    0x68BE8D00,\r\n    0x0095D900,\r\n    0xE9DFE500,\r\n    0xEE836F00,\r\n    0xF2F2B000,\r\n    0xAACF5300,\r\n    0x0A3AF00,\r\n    0xF8FBF800,\r\n    0xF4B3C200,\r\n    0x928C3600,\r\n    0xA59ACA00,\r\n    0xABCED800,\r\n    0x30283300,\r\n    0xFDEFF200,\r\n    0xDDBB9900,\r\n    0x74539900,\r\n    0xAA4C8F00\r\n  ];\r\n\r\n  uint256 public price = 1000;\r\n\r\n  /// @dev Constructor\r\n  constructor()\r\n      public\r\n      ERC721Token(NAME, SYMBOL)\r\n  {\r\n    ninjas.push(Ninja({\r\n      pattern: 0, name: \"DUMMY\", level: 0, exp: 0,\r\n      dna1: 0, dna2: 0,\r\n      readyTime: 0,\r\n      winCount: 0, lossCount: 0,\r\n      levelPoint:0, reward: 0,\r\n      lastAttackedCastleid: 0 }));\r\n  }\r\n\r\n  function mint(address _beneficiary)\r\n    public\r\n    whenNotPaused\r\n    onlyAccessByGame\r\n    returns (bool)\r\n  {\r\n    require(_beneficiary != address(0));\r\n    return _create(_beneficiary, 0, 0);\r\n  }\r\n\r\n  function burn(uint256 _tokenId) external onlyOwnerOf(_tokenId) {\r\n    super._burn(msg.sender, _tokenId);\r\n  }\r\n\r\n  function setPath(\r\n    uint256 _ninjaid,\r\n    uint256 _castleid,\r\n    bytes _path,\r\n    bytes _steps)\r\n    public\r\n    onlyAccessByGame\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    ninja.lastAttackedCastleid = _castleid;\r\n    paths[_ninjaid] = _path;\r\n    steps[_ninjaid] = _steps;\r\n  }\r\n\r\n  function win(uint256 _ninjaid)\r\n    public\r\n    onlyAccessByGame\r\n    returns (bool)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    ninja.winCount++;\r\n    ninja.exp += expOnSuccess;\r\n    ninja.levelPoint += expOnSuccess;\r\n    _levelUp(ninja);\r\n\r\n    _triggerCooldown(_ninjaid);\r\n\r\n    return true;\r\n  }\r\n\r\n  function lost(uint256 _ninjaid)\r\n    public\r\n    onlyAccessByGame\r\n    returns (bool)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    ninja.lossCount++;\r\n    ninja.exp += expOnFault;\r\n    ninja.levelPoint += expOnFault;\r\n    _levelUp(ninja);\r\n\r\n    _triggerCooldown(_ninjaid);\r\n\r\n    return true;\r\n  }\r\n\r\n  function setName(uint256 _ninjaid, bytes16 _newName)\r\n    external\r\n    onlyOwnerOf(_ninjaid)\r\n  {\r\n    ninjas[_ninjaid].name = _newName;\r\n  }\r\n\r\n  function setGoldContract(address _goldTokenAddress)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(_goldTokenAddress != address(0));\r\n\r\n    goldToken = EverGold(_goldTokenAddress);\r\n  }\r\n\r\n  function setNinjaKindCount(uint8 _kindCount)\r\n    public\r\n    onlyOwner\r\n  {\r\n    kindCount = _kindCount;\r\n  }\r\n\r\n  function setPrice(uint16 _price)\r\n    public\r\n    onlyOwner\r\n  {\r\n    price = _price;\r\n  }\r\n\r\n  function setMaxCoordinate(uint16 _maxCoordinate)\r\n    public\r\n    onlyOwner\r\n  {\r\n    maxCoordinate = _maxCoordinate;\r\n  }\r\n\r\n  function setMaxCoordinate(uint256 _cooldownTime)\r\n    public\r\n    onlyOwner\r\n  {\r\n    cooldownTime = _cooldownTime;\r\n  }\r\n\r\n  function _create(address _beneficiary, uint8 _dna1, uint8 _dna2)\r\n    private\r\n    returns (bool)\r\n  {\r\n    bytes32 pattern = _generateInitialPattern();\r\n    uint256 tokenid = ninjas.length;\r\n    bytes16 name = StringLib.generateName(\"NINJA#\", 6, tokenid);\r\n\r\n    uint256 id = ninjas.push(Ninja({\r\n      pattern: pattern, name: name, level: 1, exp: 0,\r\n      dna1: _dna1, dna2: _dna2,\r\n      readyTime: uint32(now + cooldownTime),\r\n      winCount: 0, lossCount: 0,\r\n      levelPoint:0, reward: 0,\r\n      lastAttackedCastleid: 0})) - 1;\r\n    super._mint(_beneficiary, id);\r\n\r\n    emit NewNinja(id, name, pattern);\r\n\r\n    return true;\r\n  }\r\n\r\n  function _triggerCooldown(uint256 _ninjaid)\r\n    internal\r\n    onlyAccessByGame\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    ninja.readyTime = uint32(now + cooldownTime);\r\n  }\r\n\r\n  function _levelUp(Ninja storage _ninja)\r\n    internal\r\n    onlyAccessByGame\r\n  {\r\n    if (_ninja.levelPoint >= leveupExp) {\r\n      _ninja.levelPoint -= leveupExp;\r\n      _ninja.level++;\r\n      if (_ninja.level == 2) {\r\n        _ninja.dna1 = uint8(_getRandom(6));\r\n      } else if (_ninja.level == 5) {\r\n        _ninja.dna2 = uint8(_getRandom(6));\r\n      }\r\n    }\r\n  }\r\n\r\n  function getByOwner(address _owner)\r\n    external\r\n    view\r\n    returns(uint256[] result)\r\n  {\r\n    return ownedTokens[_owner];\r\n  }\r\n\r\n  function getInfo(uint256 _ninjaid)\r\n    external\r\n    view\r\n    returns (bytes16, uint32, uint16, uint16, bytes32, uint8, uint8)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    return (ninja.name, ninja.level, ninja.winCount, ninja.lossCount, ninja.pattern,\r\n      ninja.dna1, ninja.dna2);\r\n  }\r\n\r\n  function getHp(uint256 _ninjaid)\r\n    public\r\n    view\r\n    returns (uint32)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    return uint32(100 + (ninja.level - 1) * 10);\r\n  }\r\n\r\n  function getDna1(uint256 _ninjaid)\r\n    public\r\n    view\r\n    returns (uint8)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    return ninja.dna1;\r\n  }\r\n\r\n  function getDna2(uint256 _ninjaid)\r\n    public\r\n    view\r\n    returns (uint8)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    return ninja.dna2;\r\n  }\r\n\r\n  function isReady(uint256 _ninjaid)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    return (ninja.readyTime <= now);\r\n  }\r\n\r\n  function getReward(uint256 _ninjaid)\r\n    public\r\n    view\r\n    onlyOwnerOf(_ninjaid)\r\n    returns (uint16)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    return ninja.reward;\r\n  }\r\n\r\n  function getPath(uint256 _ninjaid)\r\n    public\r\n    view\r\n    onlyOwnerOf(_ninjaid)\r\n    returns (bytes path)\r\n  {\r\n    return paths[_ninjaid];\r\n  }\r\n\r\n  function getLastAttack(uint256 _ninjaid)\r\n    public\r\n    view\r\n    onlyOwnerOf(_ninjaid)\r\n    returns (uint256 castleid, bytes path)\r\n  {\r\n    Ninja storage ninja = ninjas[_ninjaid];\r\n    return (ninja.lastAttackedCastleid, paths[_ninjaid]);\r\n  }\r\n\r\n  function getAttr(bytes32 _pattern, uint256 _n)\r\n    internal\r\n    pure\r\n    returns (bytes4)\r\n  {\r\n    require(_n < 8);\r\n    uint32 mask = 0xffffffff;\r\n    return bytes4(uint256(_pattern) / (2 ** ((7 - _n) * 8)) & mask);\r\n  }\r\n\r\n  function _getRandom(uint256 _modulus)\r\n    internal\r\n    onlyAccessByGame\r\n    returns(uint32)\r\n  {\r\n    randNonce = randNonce.add(1);\r\n    return uint32(uint256(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % _modulus);\r\n  }\r\n\r\n  function _generateInitialPattern()\r\n    internal\r\n    onlyAccessByGame\r\n    returns (bytes32)\r\n  {\r\n    uint256 pattern = 0;\r\n\r\n    uint32 color = COLORS[(_getRandom(COLORS.length))];\r\n    for (uint256 i = 0; i < 8; i++) {\r\n      uint32 temp = color;\r\n      if (i == 1) {\r\n        temp |= _getRandom(2);\r\n      } else {\r\n        temp |= _getRandom(maxCoordinate);\r\n      }\r\n      pattern = pattern | (temp * 2 ** (8 * 4 * (7 - i)));\r\n    }\r\n    return bytes32(pattern);\r\n  }\r\n\r\n  function getPrice()\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return price;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kindCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"grantAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes16\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"getReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_goldTokenAddress\",\"type\":\"address\"}],\"name\":\"setGoldContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getByOwner\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"isReady\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"win\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"lost\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"},{\"name\":\"_newName\",\"type\":\"bytes16\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"getHp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"COLORS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"revokeAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"},{\"name\":\"_castleid\",\"type\":\"uint256\"},{\"name\":\"_path\",\"type\":\"bytes\"},{\"name\":\"_steps\",\"type\":\"bytes\"}],\"name\":\"setPath\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint16\"}],\"name\":\"setPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"getLastAttack\",\"outputs\":[{\"name\":\"castleid\",\"type\":\"uint256\"},{\"name\":\"path\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxCoordinate\",\"type\":\"uint16\"}],\"name\":\"setMaxCoordinate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"getDna1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"getDna2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cooldownTime\",\"type\":\"uint256\"}],\"name\":\"setMaxCoordinate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ninjaid\",\"type\":\"uint256\"}],\"name\":\"getPath\",\"outputs\":[{\"name\":\"path\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kindCount\",\"type\":\"uint8\"}],\"name\":\"setNinjaKindCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ninjaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes16\"},{\"indexed\":false,\"name\":\"pattern\",\"type\":\"bytes32\"}],\"name\":\"NewNinja\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"NinjaToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"StringLib:7a3471c362b1b3274d6b3f254e57185ffe94788a","SwarmSource":"bzzr://f3ee078895e7d71372691203b5ca8145bc0bd02a9d54e009c6af268505e3e034"}]}