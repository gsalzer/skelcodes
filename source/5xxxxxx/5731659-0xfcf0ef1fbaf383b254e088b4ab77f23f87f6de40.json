{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\n//standard library for uint\r\nlibrary SafeMath { \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0){\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function pow(uint256 a, uint256 b) internal pure returns (uint256){ //power function\r\n    if (b == 0){\r\n      return 1;\r\n    }\r\n    uint256 c = a**b;\r\n    assert (c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n//standard contract to identify owner\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  address public newOwner;\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  \r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));\r\n    newOwner = _newOwner;\r\n  }\r\n\r\n  function acceptOwnership() public {\r\n    if (msg.sender == newOwner) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n}\r\n//Abstract Token contract\r\ncontract SHAREToken{\r\n  function setCrowdsaleContract (address) public;\r\n  function sendCrowdsaleTokens(address, uint256)  public;\r\n}\r\n\r\n//Crowdsale contract\r\ncontract ShareCrowdsale is Ownable{\r\n\r\n  using SafeMath for uint;\r\n\r\n  uint decimals = 6;\r\n\r\n  // Token contract address\r\n  SHAREToken public token;\r\n\r\n  address public distributionAddress;\r\n\r\n  constructor (address _tokenAddress) public {\r\n    token = SHAREToken(_tokenAddress);\r\n    owner = 0x4fD26ff0Af100C017BEA88Bd6007FcB68C237960;\r\n\r\n    distributionAddress = 0xdF4F78fb8B8201ea3c42A1D91A05c97071B59BF2;\r\n\r\n    setupStages();\r\n\r\n    token.setCrowdsaleContract(this);    \r\n  }\r\n\r\n  uint public constant ICO_START = 1526860800; //21st May 2018\r\n  uint public constant ICO_FINISH = 1576713600; //19th December 2019\r\n\r\n  uint public constant ICO_MIN_CAP = 1 ether;\r\n\r\n  uint public tokensSold;\r\n  uint public ethCollected;\r\n\r\n  uint public constant MIN_DEPOSIT = 0.01 ether;\r\n\r\n  struct Stage {\r\n    uint tokensPrice;\r\n    uint tokensDistribution;\r\n    uint discount;\r\n    bool isActive;\r\n  }\r\n  \r\n  Stage[] public icoStages;\r\n\r\n  function setupStages () internal {\r\n    icoStages.push(Stage(1650,2500000 * ((uint)(10) ** (uint)(decimals)), 10000, true));\r\n    icoStages.push(Stage(1650,5000000 * ((uint)(10) ** (uint)(decimals)), 5000, true));\r\n    icoStages.push(Stage(1650,8000000 * ((uint)(10) ** (uint)(decimals)), 3500, true));\r\n    icoStages.push(Stage(1650,10000000 * ((uint)(10) ** (uint)(decimals)), 2500, true));\r\n    icoStages.push(Stage(1650,15000000 * ((uint)(10) ** (uint)(decimals)), 1800, true));\r\n    icoStages.push(Stage(1650,15000000 * ((uint)(10) ** (uint)(decimals)), 1200, true));\r\n    icoStages.push(Stage(1650,15000000 * ((uint)(10) ** (uint)(decimals)), 600, true));\r\n    icoStages.push(Stage(1650,49500000 * ((uint)(10) ** (uint)(decimals)), 0, true)); \r\n  }\r\n\r\n  function stopIcoPhase (uint _phase) external onlyOwner {\r\n    icoStages[_phase].isActive = false;\r\n  }\r\n\r\n  function startIcoPhase (uint _phase) external onlyOwner {\r\n    icoStages[_phase].isActive = true;\r\n  }\r\n  \r\n  function changeIcoStageTokenPrice (uint _phase, uint _tokenPrice) external onlyOwner {\r\n    icoStages[_phase].tokensPrice = _tokenPrice;\r\n  }\r\n  \r\n  function () public payable {\r\n    require (isIco());\r\n    require (msg.value >= MIN_DEPOSIT);\r\n    require (buy(msg.sender, msg.value));\r\n  }\r\n\r\n  function buy (address _address, uint _value) internal returns(bool) {\r\n    uint currentStage = getCurrentStage();\r\n    if (currentStage == 100){\r\n      return false;\r\n    }\r\n\r\n    uint _phasePrice = icoStages[currentStage].tokensPrice;\r\n    uint _tokenPrice = _phasePrice.add(_phasePrice.mul(icoStages[currentStage].discount)/10000);\r\n    uint tokensToSend = _value.mul(_tokenPrice)/(uint(10).pow(uint(12))); //decimals difference\r\n\r\n    if(ethCollected >= ICO_MIN_CAP){\r\n      distributionAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    token.sendCrowdsaleTokens(_address,tokensToSend);\r\n    \r\n    tokensSold = tokensSold.add(tokensToSend);\r\n    ethCollected += _value;\r\n    \r\n    return true;\r\n  }\r\n\r\n  function getCurrentStage () public view returns(uint) {\r\n    uint buffer;\r\n\r\n    if(isIco()){\r\n      for (uint i = 0; i < icoStages.length; i++){\r\n        buffer += icoStages[i].tokensDistribution;\r\n        if(tokensSold <= buffer && icoStages[i].isActive){\r\n          return i;\r\n        }\r\n      }\r\n    }\r\n    return 100; //something went wrong\r\n  }\r\n\r\n  function isIco() public view returns(bool) {\r\n    if(ICO_START <= now && now <= ICO_FINISH){\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function sendCrowdsaleTokensManually (address _address, uint _value) external onlyOwner {\r\n    token.sendCrowdsaleTokens(_address,_value);\r\n    tokensSold = tokensSold.add(_value);\r\n  }\r\n\r\n  //if something went wrong\r\n  function sendEtherManually () public onlyOwner {\r\n    distributionAddress.transfer(address(this).balance);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_phase\",\"type\":\"uint256\"}],\"name\":\"startIcoPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"icoStages\",\"outputs\":[{\"name\":\"tokensPrice\",\"type\":\"uint256\"},{\"name\":\"tokensDistribution\",\"type\":\"uint256\"},{\"name\":\"discount\",\"type\":\"uint256\"},{\"name\":\"isActive\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_FINISH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_MIN_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sendCrowdsaleTokensManually\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phase\",\"type\":\"uint256\"}],\"name\":\"stopIcoPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phase\",\"type\":\"uint256\"},{\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"name\":\"changeIcoStageTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendEtherManually\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_START\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_DEPOSIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIco\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ShareCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000001ae6ec66a9b4c6bb2062183abaac0a4be04d74f4","Library":"","SwarmSource":"bzzr://a78e79b497174c063f3aeb31c3b83e030cb07caacbdd6e712ecba0b5550a6165"}]}