{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n// source : https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\n\r\ncontract GRETToken is ERC20Interface {\r\n  using SafeMath for uint;\r\n\r\n  // State variables\r\n  string public symbol = 'GRET';\r\n  string public name = 'GRET';\r\n  uint public decimals = 8;\r\n  address public owner;\r\n  uint public totalSupply = 75000000 * (10 ** 8);\r\n  bool public emergencyFreeze;\r\n  \r\n  // mappings\r\n  mapping (address => uint) balances;\r\n  mapping (address => mapping (address => uint) ) allowed;\r\n  mapping (address => bool) frozen;\r\n  \r\n\r\n  // constructor\r\n  function GRETToken () public {\r\n    owner = msg.sender;\r\n    balances[owner] = totalSupply;\r\n  }\r\n\r\n  // events\r\n  event OwnershipTransferred(address indexed _from, address indexed _to);\r\n  event Burn(address indexed from, uint256 amount);\r\n  event Mint(address indexed tagetAddress, uint256 amount);\r\n  event Freezed(address targetAddress, bool frozen);\r\n  event EmerygencyFreezed(bool emergencyFreezeStatus);\r\n  \r\n\r\n\r\n  // Modifiers\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n     _;\r\n  }\r\n\r\n  modifier unfreezed(address _account) { \r\n    require(!frozen[_account]);\r\n    _;  \r\n  }\r\n  \r\n  modifier noEmergencyFreeze() { \r\n    require(!emergencyFreeze);\r\n    _; \r\n  }\r\n  \r\n\r\n\r\n  // functions\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Transfer Token\r\n  // ------------------------------------------------------------------------\r\n  function transfer(address _to, uint _value) unfreezed(_to) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\r\n    require(_to != 0x0);\r\n    require(balances[msg.sender] >= _value);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Approve others to spend on your behalf\r\n  // ------------------------------------------------------------------------\r\n  /* \r\n    While changing approval, the allowed must be changed to 0 than then to updated value\r\n    The smart contract doesn't enforces this due to backward competibility but requires frontend to do the validations\r\n   */\r\n  function approve(address _spender, uint _value) unfreezed(_spender) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Approve and call : If approve returns true, it calls receiveApproval method of contract\r\n  // ------------------------------------------------------------------------\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData) unfreezed(_spender) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success)\r\n    {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Transferred approved amount from other's account\r\n  // ------------------------------------------------------------------------\r\n  function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require (balances[_from]>= _value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Burn (Destroy tokens)\r\n  // ------------------------------------------------------------------------\r\n  function burn(uint256 _value) public returns (bool success) {\r\n    require(balances[msg.sender] >= _value);\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    totalSupply = totalSupply.sub(_value);\r\n    emit Burn(msg.sender, _value);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  //               ONLYOWNER METHODS                             \r\n  // ------------------------------------------------------------------------\r\n\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Transfer Ownership\r\n  // ------------------------------------------------------------------------\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0));\r\n    owner = _newOwner;\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Mint Token (Uncapped Minting)\r\n  // ------------------------------------------------------------------------\r\n  function mintToken (address _targetAddress, uint256 _mintedAmount) unfreezed(_targetAddress) noEmergencyFreeze() public onlyOwner returns(bool res) {\r\n    require(_targetAddress != 0x0); // use burn instead\r\n    require(_mintedAmount != 0);\r\n    balances[_targetAddress] = balances[_targetAddress].add(_mintedAmount);\r\n    totalSupply = totalSupply.add(_mintedAmount);\r\n    emit Mint(_targetAddress, _mintedAmount);\r\n    emit Transfer(address(0), _targetAddress, _mintedAmount);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Freeze account - onlyOwner\r\n  // ------------------------------------------------------------------------\r\n  function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool res) {\r\n    require(_target != 0x0);\r\n    frozen[_target] = _freeze;\r\n    emit Freezed(_target, _freeze);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Emerygency freeze - onlyOwner\r\n  // ------------------------------------------------------------------------\r\n  function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool res) {\r\n    emergencyFreeze = _freeze;\r\n    emit EmerygencyFreezed(_freeze);\r\n    return true;\r\n  }\r\n  \r\n\r\n  // ------------------------------------------------------------------------\r\n  //               CONSTANT METHODS\r\n  // ------------------------------------------------------------------------\r\n\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Check Allowance : Constant\r\n  // ------------------------------------------------------------------------\r\n  function allowance(address _tokenOwner, address _spender) public constant returns (uint remaining) {\r\n    return allowed[_tokenOwner][_spender];\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Check Balance : Constant\r\n  // ------------------------------------------------------------------------\r\n  function balanceOf(address _tokenOwner) public constant returns (uint balance) {\r\n    return balances[_tokenOwner];\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Total supply : Constant\r\n  // ------------------------------------------------------------------------\r\n  function totalSupply() public constant returns (uint) {\r\n    return totalSupply;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Get Freeze Status : Constant\r\n  // ------------------------------------------------------------------------\r\n  function isFreezed(address _targetAddress) public constant returns (bool) {\r\n    return frozen[_targetAddress]; \r\n  }\r\n\r\n\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Prevents contract from accepting ETH\r\n  // ------------------------------------------------------------------------\r\n  function () public payable {\r\n    revert();\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Owner can transfer out any accidentally sent ERC20 tokens\r\n  // ------------------------------------------------------------------------\r\n  function transferAnyERC20Token(address _tokenAddress, uint _value) public onlyOwner returns (bool success) {\r\n      return ERC20Interface(_tokenAddress).transfer(owner, _value);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"emergencyFreezeAllAccounts\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targetAddress\",\"type\":\"address\"},{\"name\":\"_mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_targetAddress\",\"type\":\"address\"}],\"name\":\"isFreezed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyFreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tagetAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"Freezed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"emergencyFreezeStatus\",\"type\":\"bool\"}],\"name\":\"EmerygencyFreezed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"GRETToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cbcde7a8feb51abb95c3b7f0f19ce9853e0ea760cc2974e61b01d162fd17a722"}]}