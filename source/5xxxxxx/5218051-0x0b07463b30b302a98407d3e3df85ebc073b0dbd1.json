{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n// File: contracts/ENS.sol\r\n\r\n/**\r\n * The ENS registry contract.\r\n */\r\ncontract ENS {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    struct Record {\r\n        address owner;\r\n        address resolver;\r\n        uint64 ttl;\r\n    }\r\n\r\n    mapping (bytes32 => Record) records;\r\n\r\n    // Permits modifications only by the owner of the specified node.\r\n    modifier only_owner(bytes32 node) {\r\n        if (records[node].owner != msg.sender) throw;\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructs a new ENS registrar.\r\n     */\r\n    function ENS() public {\r\n        records[0].owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Returns the address that owns the specified node.\r\n     */\r\n    function owner(bytes32 node) public constant returns (address) {\r\n        return records[node].owner;\r\n    }\r\n\r\n    /**\r\n     * Returns the address of the resolver for the specified node.\r\n     */\r\n    function resolver(bytes32 node) public constant returns (address) {\r\n        return records[node].resolver;\r\n    }\r\n\r\n    /**\r\n     * Returns the TTL of a node, and any records associated with it.\r\n     */\r\n    function ttl(bytes32 node) public constant returns (uint64) {\r\n        return records[node].ttl;\r\n    }\r\n\r\n    /**\r\n     * Transfers ownership of a node to a new address. May only be called by the current\r\n     * owner of the node.\r\n     * @param node The node to transfer ownership of.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setOwner(bytes32 node, address owner) public only_owner(node) {\r\n        Transfer(node, owner);\r\n        records[node].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\r\n     * called by the owner of the parent node.\r\n     * @param node The parent node.\r\n     * @param label The hash of the label specifying the subnode.\r\n     * @param owner The address of the new owner.\r\n     */\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public only_owner(node) {\r\n        var subnode = sha3(node, label);\r\n        NewOwner(node, label, owner);\r\n        records[subnode].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolver address for the specified node.\r\n     * @param node The node to update.\r\n     * @param resolver The address of the resolver.\r\n     */\r\n    function setResolver(bytes32 node, address resolver) public only_owner(node) {\r\n        NewResolver(node, resolver);\r\n        records[node].resolver = resolver;\r\n    }\r\n\r\n    /**\r\n     * Sets the TTL for the specified node.\r\n     * @param node The node to update.\r\n     * @param ttl The TTL in seconds.\r\n     */\r\n    function setTTL(bytes32 node, uint64 ttl) public only_owner(node) {\r\n        NewTTL(node, ttl);\r\n        records[node].ttl = ttl;\r\n    }\r\n}\r\n\r\n// File: contracts/HashRegistrarSimplified.sol\r\n\r\ncontract Deed {\r\n    address public owner;\r\n    address public previousOwner;\r\n}\r\n\r\ncontract HashRegistrarSimplified {\r\n    enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }\r\n\r\n    bytes32 public rootNode;\r\n\r\n    function entries(bytes32 _hash) public view returns (Mode, address, uint, uint, uint);\r\n    function transfer(bytes32 _hash, address newOwner) public;\r\n}\r\n\r\n// File: contracts/RegistrarInterface.sol\r\n\r\ncontract RegistrarInterface {\r\n    event OwnerChanged(bytes32 indexed label, address indexed oldOwner, address indexed newOwner);\r\n    event DomainConfigured(bytes32 indexed label);\r\n    event DomainUnlisted(bytes32 indexed label);\r\n    event NewRegistration(bytes32 indexed label, string subdomain, address indexed owner, address indexed referrer, uint price);\r\n    event RentPaid(bytes32 indexed label, string subdomain, uint amount, uint expirationDate);\r\n\r\n    // InterfaceID of these four methods is 0xc1b15f5a\r\n    function query(bytes32 label, string subdomain) public view returns (string domain, uint signupFee, uint rent, uint referralFeePPM);\r\n    function register(bytes32 label, string subdomain, address owner, address referrer, address resolver) public payable;\r\n\r\n    function rentDue(bytes32 label, string subdomain) public view returns (uint timestamp);\r\n    function payRent(bytes32 label, string subdomain) public payable;\r\n}\r\n\r\n// File: contracts/Resolver.sol\r\n\r\n/**\r\n * @dev A basic interface for ENS resolvers.\r\n */\r\ncontract Resolver {\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\r\n    function addr(bytes32 node) public view returns (address);\r\n    function setAddr(bytes32 node, address addr) public;\r\n}\r\n\r\n// File: contracts/SubdomainRegistrar.sol\r\n\r\n/**\r\n * @dev Implements an ENS registrar that sells subdomains on behalf of their owners.\r\n *\r\n * Users may register a subdomain by calling `register` with the name of the domain\r\n * they wish to register under, and the label hash of the subdomain they want to\r\n * register. They must also specify the new owner of the domain, and the referrer,\r\n * who is paid an optional finder's fee. The registrar then configures a simple\r\n * default resolver, which resolves `addr` lookups to the new owner, and sets\r\n * the `owner` account as the owner of the subdomain in ENS.\r\n *\r\n * New domains may be added by calling `configureDomain`, then transferring\r\n * ownership in the ENS registry to this contract. Ownership in the contract\r\n * may be transferred using `transfer`, and a domain may be unlisted for sale\r\n * using `unlistDomain`. There is (deliberately) no way to recover ownership\r\n * in ENS once the name is transferred to this registrar.\r\n *\r\n * Critically, this contract does not check one key property of a listed domain:\r\n *\r\n * - Is the name UTS46 normalised?\r\n *\r\n * User applications MUST check these two elements for each domain before\r\n * offering them to users for registration.\r\n *\r\n * Applications should additionally check that the domains they are offering to\r\n * register are controlled by this registrar, since calls to `register` will\r\n * fail if this is not the case.\r\n */\r\ncontract SubdomainRegistrar is RegistrarInterface {\r\n\r\n    // namehash('eth')\r\n    bytes32 constant public TLD_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\r\n\r\n    bool public stopped = false;\r\n    address public registrarOwner;\r\n    address public migration;\r\n\r\n    ENS public ens;\r\n    HashRegistrarSimplified public hashRegistrar;\r\n\r\n    struct Domain {\r\n        string name;\r\n        address owner;\r\n        address transferAddress;\r\n        uint price;\r\n        uint referralFeePPM;\r\n    }\r\n\r\n    mapping (bytes32 => Domain) domains;\r\n\r\n    modifier new_registrar() {\r\n        require(ens.owner(TLD_NODE) != address(hashRegistrar));\r\n        _;\r\n    }\r\n\r\n    modifier owner_only(bytes32 label) {\r\n        require(owner(label) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier not_stopped() {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n\r\n    modifier registrar_owner_only() {\r\n        require(msg.sender == registrarOwner);\r\n        _;\r\n    }\r\n\r\n    event TransferAddressSet(bytes32 indexed label, address addr);\r\n    event DomainTransferred(bytes32 indexed label, string name);\r\n\r\n    function SubdomainRegistrar(ENS _ens) public {\r\n        ens = _ens;\r\n        hashRegistrar = HashRegistrarSimplified(ens.owner(TLD_NODE));\r\n        registrarOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev owner returns the address of the account that controls a domain.\r\n     *      Initially this is a null address. If the name has been\r\n     *      transferred to this contract, then the internal mapping is consulted\r\n     *      to determine who controls it. If the owner is not set,\r\n     *      the previous owner of the deed is returned.\r\n     * @param label The label hash of the deed to check.\r\n     * @return The address owning the deed.\r\n     */\r\n    function owner(bytes32 label) public view returns (address) {\r\n\r\n        if (domains[label].owner != 0x0) {\r\n            return domains[label].owner;\r\n        }\r\n\r\n        Deed domainDeed = deed(label);\r\n        if (domainDeed.owner() != address(this)) {\r\n            return 0x0;\r\n        }\r\n\r\n        return domainDeed.previousOwner();\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers internal control of a name to a new account. Does not update\r\n     *      ENS.\r\n     * @param name The name to transfer.\r\n     * @param newOwner The address of the new owner.\r\n     */\r\n    function transfer(string name, address newOwner) public owner_only(keccak256(name)) {\r\n        bytes32 label = keccak256(name);\r\n        OwnerChanged(keccak256(name), domains[label].owner, newOwner);\r\n        domains[label].owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the resolver record for a name in ENS.\r\n     * @param name The name to set the resolver for.\r\n     * @param resolver The address of the resolver\r\n     */\r\n    function setResolver(string name, address resolver) public owner_only(keccak256(name)) {\r\n        bytes32 label = keccak256(name);\r\n        bytes32 node = keccak256(TLD_NODE, label);\r\n        ens.setResolver(node, resolver);\r\n    }\r\n\r\n    /**\r\n     * @dev Configures a domain for sale.\r\n     * @param name The name to configure.\r\n     * @param price The price in wei to charge for subdomain registrations\r\n     * @param referralFeePPM The referral fee to offer, in parts per million\r\n     */\r\n    function configureDomain(string name, uint price, uint referralFeePPM) public {\r\n        configureDomainFor(name, price, referralFeePPM, msg.sender, 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Configures a domain, optionally transferring it to a new owner.\r\n     * @param name The name to configure.\r\n     * @param price The price in wei to charge for subdomain registrations.\r\n     * @param referralFeePPM The referral fee to offer, in parts per million.\r\n     * @param _owner The address to assign ownership of this domain to.\r\n     * @param _transfer The address to set as the transfer address for the name\r\n     *        when the permanent registrar is replaced. Can only be set to a non-zero\r\n     *        value once.\r\n     */\r\n    function configureDomainFor(string name, uint price, uint referralFeePPM, address _owner, address _transfer) public owner_only(keccak256(name)) {\r\n        bytes32 label = keccak256(name);\r\n        Domain storage domain = domains[label];\r\n\r\n        // Don't allow changing the transfer address once set. Treat 0 as \"don't change\" for convenience.\r\n        require(domain.transferAddress == 0 || _transfer == 0 || domain.transferAddress == _transfer);\r\n\r\n        if (domain.owner != _owner) {\r\n            domain.owner = _owner;\r\n        }\r\n\r\n        if (keccak256(domain.name) != label) {\r\n            // New listing\r\n            domain.name = name;\r\n        }\r\n\r\n        domain.price = price;\r\n        domain.referralFeePPM = referralFeePPM;\r\n\r\n        if (domain.transferAddress != _transfer && _transfer != 0) {\r\n            domain.transferAddress = _transfer;\r\n            TransferAddressSet(label, _transfer);\r\n        }\r\n\r\n        DomainConfigured(label);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the transfer address of a domain for after an ENS update.\r\n     * @param name The name for which to set the transfer address.\r\n     * @param transfer The address to transfer to.\r\n     */\r\n    function setTransferAddress(string name, address transfer) public owner_only(keccak256(name)) {\r\n        bytes32 label = keccak256(name);\r\n        Domain storage domain = domains[label];\r\n\r\n        require(domain.transferAddress == 0x0);\r\n\r\n        domain.transferAddress = transfer;\r\n        TransferAddressSet(label, transfer);\r\n    }\r\n\r\n    /**\r\n     * @dev Unlists a domain\r\n     * May only be called by the owner.\r\n     * @param name The name of the domain to unlist.\r\n     */\r\n    function unlistDomain(string name) public owner_only(keccak256(name)) {\r\n        bytes32 label = keccak256(name);\r\n        Domain storage domain = domains[label];\r\n        DomainUnlisted(label);\r\n\r\n        domain.name = '';\r\n        domain.owner = owner(label);\r\n        domain.price = 0;\r\n        domain.referralFeePPM = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns information about a subdomain.\r\n     * @param label The label hash for the domain.\r\n     * @param subdomain The label for the subdomain.\r\n     * @return domain The name of the domain, or an empty string if the subdomain\r\n     *                is unavailable.\r\n     * @return price The price to register a subdomain, in wei.\r\n     * @return rent The rent to retain a subdomain, in wei per second.\r\n     * @return referralFeePPM The referral fee for the dapp, in ppm.\r\n     */\r\n    function query(bytes32 label, string subdomain) public view returns (string domain, uint price, uint rent, uint referralFeePPM) {\r\n        bytes32 node = keccak256(TLD_NODE, label);\r\n        bytes32 subnode = keccak256(node, keccak256(subdomain));\r\n\r\n        if (ens.owner(subnode) != 0) {\r\n            return ('', 0, 0, 0);\r\n        }\r\n\r\n        Domain data = domains[label];\r\n        return (data.name, data.price, 0, data.referralFeePPM);\r\n    }\r\n\r\n    /**\r\n     * @dev Registers a subdomain.\r\n     * @param label The label hash of the domain to register a subdomain of.\r\n     * @param subdomain The desired subdomain label.\r\n     * @param subdomainOwner The account that should own the newly configured subdomain.\r\n     * @param referrer The address of the account to receive the referral fee.\r\n     */\r\n    function register(bytes32 label, string subdomain, address subdomainOwner, address referrer, address resolver) public not_stopped payable {\r\n        bytes32 domainNode = keccak256(TLD_NODE, label);\r\n        bytes32 subdomainLabel = keccak256(subdomain);\r\n\r\n        // Subdomain must not be registered already.\r\n        require(ens.owner(keccak256(domainNode, subdomainLabel)) == address(0));\r\n\r\n        Domain storage domain = domains[label];\r\n\r\n        // Domain must be available for registration\r\n        require(keccak256(domain.name) == label);\r\n\r\n        // User must have paid enough\r\n        require(msg.value >= domain.price);\r\n\r\n        // Send any extra back\r\n        if (msg.value > domain.price) {\r\n            msg.sender.transfer(msg.value - domain.price);\r\n        }\r\n\r\n        // Send any referral fee\r\n        uint256 total = domain.price;\r\n        if (domain.referralFeePPM * domain.price > 0 && referrer != 0 && referrer != domain.owner) {\r\n            uint256 referralFee = (domain.price * domain.referralFeePPM) / 1000000;\r\n            referrer.transfer(referralFee);\r\n            total -= referralFee;\r\n        }\r\n\r\n        // Send the registration fee\r\n        if (total > 0) {\r\n            domain.owner.transfer(total);\r\n        }\r\n\r\n        // Register the domain\r\n        if (subdomainOwner == 0) {\r\n            subdomainOwner = msg.sender;\r\n        }\r\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\r\n\r\n        NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\r\n    }\r\n\r\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\r\n        // Get the subdomain so we can configure it\r\n        ens.setSubnodeOwner(node, label, this);\r\n\r\n        bytes32 subnode = keccak256(node, label);\r\n        // Set the subdomain's resolver\r\n        ens.setResolver(subnode, resolver);\r\n\r\n        // Set the address record on the resolver\r\n        resolver.setAddr(subnode, subdomainOwner);\r\n\r\n        // Pass ownership of the new subdomain to the registrant\r\n        ens.setOwner(subnode, subdomainOwner);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return (\r\n            (interfaceID == 0x01ffc9a7) // supportsInterface(bytes4)\r\n            || (interfaceID == 0xc1b15f5a) // RegistrarInterface\r\n        );\r\n    }\r\n\r\n    function rentDue(bytes32 label, string subdomain) public view returns (uint timestamp) {\r\n        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades the domain to a new registrar.\r\n     * @param name The name of the domain to transfer.\r\n     */\r\n    function upgrade(string name) public owner_only(keccak256(name)) new_registrar {\r\n        bytes32 label = keccak256(name);\r\n        address transfer = domains[label].transferAddress;\r\n\r\n        require(transfer != 0x0);\r\n\r\n        delete domains[label];\r\n\r\n        hashRegistrar.transfer(label, transfer);\r\n        DomainTransferred(label, name);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Stops the registrar, disabling configuring of new domains.\r\n     */\r\n    function stop() public not_stopped registrar_owner_only {\r\n        stopped = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address where domains are migrated to.\r\n     * @param _migration Address of the new registrar.\r\n     */\r\n    function setMigrationAddress(address _migration) public registrar_owner_only {\r\n        require(stopped);\r\n        migration = _migration;\r\n    }\r\n\r\n    /**\r\n     * @dev Migrates the domain to a new registrar.\r\n     * @param name The name of the domain to migrate.\r\n     */\r\n    function migrate(string name) public owner_only(keccak256(name)) {\r\n        require(stopped);\r\n        require(migration != 0x0);\r\n\r\n        bytes32 label = keccak256(name);\r\n        Domain storage domain = domains[label];\r\n\r\n        hashRegistrar.transfer(label, migration);\r\n\r\n        SubdomainRegistrar(migration).configureDomainFor(\r\n            domain.name,\r\n            domain.price,\r\n            domain.referralFeePPM,\r\n            domain.owner,\r\n            domain.transferAddress\r\n        );\r\n\r\n        delete domains[label];\r\n\r\n        DomainTransferred(label, name);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public registrar_owner_only {\r\n        registrarOwner = newOwner;\r\n    }\r\n\r\n    function payRent(bytes32 label, string subdomain) public payable {\r\n        revert();\r\n    }\r\n\r\n    function deed(bytes32 label) internal view returns (Deed) {\r\n        var (,deedAddress,,,) = hashRegistrar.entries(label);\r\n        return Deed(deedAddress);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migration\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrarOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"query\",\"outputs\":[{\"name\":\"domain\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"rent\",\"type\":\"uint256\"},{\"name\":\"referralFeePPM\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hashRegistrar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"subdomain\",\"type\":\"string\"},{\"name\":\"subdomainOwner\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_migration\",\"type\":\"address\"}],\"name\":\"setMigrationAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"rentDue\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TLD_NODE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"label\",\"type\":\"bytes32\"},{\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"payRent\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"referralFeePPM\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_transfer\",\"type\":\"address\"}],\"name\":\"configureDomainFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"referralFeePPM\",\"type\":\"uint256\"}],\"name\":\"configureDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"transfer\",\"type\":\"address\"}],\"name\":\"setTransferAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"unlistDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"TransferAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"DomainTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainUnlisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewRegistration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expirationDate\",\"type\":\"uint256\"}],\"name\":\"RentPaid\",\"type\":\"event\"}]","ContractName":"SubdomainRegistrar","CompilerVersion":"v0.4.21-nightly.2018.3.6+commit.a9e02acc","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b","Library":"","SwarmSource":"bzzr://4a2ec41a7a4ef565521711812f8252c0cb8a69f51a8ad8910d3f48acfdc3732d"}]}