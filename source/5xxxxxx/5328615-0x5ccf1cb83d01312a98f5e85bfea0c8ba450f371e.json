{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract BallerToken is Ownable, Destructible {\r\n    using SafeMath for uint;\r\n    /*** EVENTS ***/\r\n\r\n    // @dev Fired whenever a new Baller token is created for the first time.\r\n    event BallerCreated(uint256 tokenId, string name, address owner);\r\n\r\n    // @dev Fired whenever a new Baller Player token is created for first time\r\n    event BallerPlayerCreated(uint256 tokenId, string name, uint teamID, address owner);\r\n\r\n    // @dev Fired whenever a Baller token is sold.\r\n    event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwner, string name);\r\n\r\n    // @dev Fired whenever a team is transfered from one owner to another\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    /*** CONSTANTS ***/\r\n\r\n    uint constant private DEFAULT_START_PRICE = 0.01 ether;\r\n    uint constant private FIRST_PRICE_LIMIT =  0.5 ether;\r\n    uint constant private SECOND_PRICE_LIMIT =  2 ether;\r\n    uint constant private THIRD_PRICE_LIMIT =  5 ether;\r\n    uint constant private FIRST_COMMISSION_LEVEL = 5;\r\n    uint constant private SECOND_COMMISSION_LEVEL = 4;\r\n    uint constant private THIRD_COMMISSION_LEVEL = 3;\r\n    uint constant private FOURTH_COMMISSION_LEVEL = 2;\r\n    uint constant private FIRST_LEVEL_INCREASE = 200;\r\n    uint constant private SECOND_LEVEL_INCREASE = 135;\r\n    uint constant private THIRD_LEVEL_INCREASE = 125;\r\n    uint constant private FOURTH_LEVEL_INCREASE = 115;\r\n\r\n    /*** STORAGE ***/\r\n\r\n    // @dev maps team id to address of who owns it\r\n    mapping (uint => address) private teamIndexToOwner;\r\n\r\n    // @dev maps team id to a price\r\n    mapping (uint => uint) private teamIndexToPrice;\r\n\r\n    // @dev maps address to how many tokens they own\r\n    mapping (address => uint) private ownershipTokenCount;\r\n\r\n\r\n    // @dev maps player id to address of who owns it\r\n    mapping (uint => address) public playerIndexToOwner;\r\n\r\n    // @dev maps player id to a price\r\n    mapping (uint => uint) private playerIndexToPrice;\r\n\r\n    // @dev maps address to how many players they own\r\n    mapping (address => uint) private playerOwnershipTokenCount;\r\n\r\n\r\n    /*** DATATYPES ***/\r\n    //@dev struct for a baller team\r\n    struct Team {\r\n        string name;\r\n    }\r\n\r\n    //@dev struct for a baller player\r\n    struct Player {\r\n        string name;\r\n        uint teamID;\r\n    }\r\n\r\n    //@dev array which holds each team\r\n    Team[] private ballerTeams;\r\n\r\n    //@dev array which holds each baller\r\n    Player[] private ballerPlayers;\r\n\r\n    /*** PUBLIC FUNCTIONS ***/\r\n\r\n    /**\r\n    * @dev public function to create team, can only be called by owner of smart contract\r\n    * @param _name the name of the team\r\n    * @param _price the price of the team when created\r\n    */\r\n\r\n    function createTeam(string _name, uint _price) public onlyOwner {\r\n        _createTeam(_name, this, _price);\r\n    }\r\n\r\n    /**\r\n    * @dev public function to create a promotion team and assign it to some address\r\n    * @param _name the name of the team\r\n    * @param _owner the owner of the team when created\r\n    * @param _price the price of the team when created\r\n    */\r\n    function createPromoTeam(string _name, address _owner, uint _price) public onlyOwner {\r\n        _createTeam(_name, _owner, _price);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev public function to create a player, can only be called by owner of smart contract\r\n    * @param _name the name of the player\r\n    * @param _teamID the id of the team the player belongs to\r\n    * @param _price the price of the player when created\r\n    */\r\n    function createPlayer(string _name, uint _teamID, uint _price) public onlyOwner {\r\n        _createPlayer(_name, _teamID, this, _price);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns all the relevant information about a specific team.\r\n    * @param _tokenId The ID of the team.\r\n    * @return teamName the name of the team.\r\n    * @return currPrice what the team is currently worth.\r\n    * @return owner address of whoever owns the team\r\n    */\r\n    function getTeam(uint _tokenId) public view returns(string teamName, uint currPrice, address owner) {\r\n        Team storage currTeam = ballerTeams[_tokenId];\r\n        teamName = currTeam.name;\r\n        currPrice = teamIndexToPrice[_tokenId];\r\n        owner = ownerOf(_tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns all relevant info about a specific player.\r\n    * @return playerName the name of the player\r\n    * @return currPrice what the player is currently worth.\r\n    * @return owner address of whoever owns the player.\r\n    * @return owningTeamID ID of team that the player plays on.\r\n    */\r\n    function getPlayer(uint _tokenId) public view returns(string playerName, uint currPrice, address owner, uint owningTeamID) {\r\n        Player storage currPlayer = ballerPlayers[_tokenId];\r\n        playerName = currPlayer.name;\r\n        currPrice = playerIndexToPrice[_tokenId];\r\n        owner = ownerOfPlayer(_tokenId);\r\n        owningTeamID = currPlayer.teamID;\r\n    }\r\n\r\n    /**\r\n    * @dev changes the name of a specific team.\r\n    * @param _tokenId The id of the team which you want to change.\r\n    * @param _newName The name you want to set the team to be.\r\n    */\r\n    function changeTeamName(uint _tokenId, string _newName) public onlyOwner {\r\n        require(_tokenId < ballerTeams.length && _tokenId >= 0);\r\n        ballerTeams[_tokenId].name = _newName;\r\n    }\r\n\r\n    /**\r\n    * @dev changes name of a player.\r\n    * @param _tokenId the id of the player which you want to change.\r\n    * @param _newName the name you want to set the player to be.\r\n    */\r\n    function changePlayerName(uint _tokenId, string _newName) public onlyOwner {\r\n        require(_tokenId < ballerPlayers.length && _tokenId >= 0);\r\n        ballerPlayers[_tokenId].name = _newName;\r\n    }\r\n\r\n    /**\r\n    * @dev changes the team the player is own\r\n    * @param _tokenId the id of the player which you want to change.\r\n    * @param _newTeamId the team the player will now be on.\r\n    */\r\n\r\n    function changePlayerTeam(uint _tokenId, uint _newTeamId) public onlyOwner {\r\n        require(_newTeamId < ballerPlayers.length && _newTeamId >= 0);\r\n        ballerPlayers[_tokenId].teamID = _newTeamId;\r\n    }\r\n\r\n    /**\r\n    * @dev sends all ethereum in this contract to the address specified\r\n    * @param _to address you want the eth to be sent to\r\n    */\r\n\r\n    function payout(address _to) public onlyOwner {\r\n      _withdrawAmount(_to, this.balance);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to send some amount of ethereum out of the contract to an address\r\n    * @param _to address the eth will be sent to\r\n    * @param _amount amount you want to withdraw\r\n    */\r\n    function withdrawAmount(address _to, uint _amount) public onlyOwner {\r\n      _withdrawAmount(_to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to get price of a team\r\n    * @param _teamId of team\r\n    * @return price price of team\r\n    */\r\n    function priceOfTeam(uint _teamId) public view returns (uint price) {\r\n      price = teamIndexToPrice[_teamId];\r\n    }\r\n\r\n    /**\r\n    * @dev Function to get price of a player\r\n    * @param _playerID id of player\r\n    * @return price price of player\r\n    */\r\n\r\n    function priceOfPlayer(uint _playerID) public view returns (uint price) {\r\n        price = playerIndexToPrice[_playerID];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets list of teams owned by a person.\r\n    * @dev note: don't want to call this in the smart contract, expensive op.\r\n    * @param _owner address of the owner\r\n    * @return ownedTeams list of the teams owned by the owner\r\n    */\r\n    function getTeamsOfOwner(address _owner) public view returns (uint[] ownedTeams) {\r\n      uint tokenCount = balanceOf(_owner);\r\n      ownedTeams = new uint[](tokenCount);\r\n      uint totalTeams = totalSupply();\r\n      uint resultIndex = 0;\r\n      if (tokenCount != 0) {\r\n        for (uint pos = 0; pos < totalTeams; pos++) {\r\n          address currOwner = ownerOf(pos);\r\n          if (currOwner == _owner) {\r\n            ownedTeams[resultIndex] = pos;\r\n            resultIndex++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets list of players owned by a person.\r\n    * @dev note: don't want to call this in smart contract, expensive op.\r\n    * @param _owner address of owner\r\n    * @return ownedPlayers list of all players owned by the address passed in\r\n    */\r\n\r\n    function getPlayersOfOwner(address _owner) public view returns (uint[] ownedPlayers) {\r\n        uint numPlayersOwned = balanceOfPlayers(_owner);\r\n        ownedPlayers = new uint[](numPlayersOwned);\r\n        uint totalPlayers = totalPlayerSupply();\r\n        uint resultIndex = 0;\r\n        if (numPlayersOwned != 0) {\r\n            for (uint pos = 0; pos < totalPlayers; pos++) {\r\n                address currOwner = ownerOfPlayer(pos);\r\n                if (currOwner == _owner) {\r\n                    ownedPlayers[resultIndex] = pos;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev gets the address of owner of the team\r\n     * @param _tokenId is id of the team\r\n     * @return owner the owner of the team's address\r\n    */\r\n    function ownerOf(uint _tokenId) public view returns (address owner) {\r\n      owner = teamIndexToOwner[_tokenId];\r\n      require(owner != address(0));\r\n    }\r\n\r\n    /*\r\n     * @dev gets address of owner of player\r\n     * @param _playerId is id of the player\r\n     * @return owner the address of the owner of the player\r\n    */\r\n\r\n    function ownerOfPlayer(uint _playerId) public view returns (address owner) {\r\n        owner = playerIndexToOwner[_playerId];\r\n        require(owner != address(0));\r\n    }\r\n\r\n    function teamOwnerOfPlayer(uint _playerId) public view returns (address teamOwner) {\r\n        uint teamOwnerId = ballerPlayers[_playerId].teamID;\r\n        teamOwner = ownerOf(teamOwnerId);\r\n    }\r\n    /*\r\n     * @dev gets how many tokens an address owners\r\n     * @param _owner is address of owner\r\n     * @return numTeamsOwned how much teams he has\r\n    */\r\n\r\n    function balanceOf(address _owner) public view returns (uint numTeamsOwned) {\r\n      numTeamsOwned = ownershipTokenCount[_owner];\r\n    }\r\n\r\n    /*\r\n     * @dev gets how many players an owner owners\r\n     * @param _owner is address of owner\r\n     * @return numPlayersOwned how many players the owner has\r\n    */\r\n\r\n    function balanceOfPlayers(address _owner) public view returns (uint numPlayersOwned) {\r\n        numPlayersOwned = playerOwnershipTokenCount[_owner];\r\n    }\r\n\r\n    /*\r\n     * @dev gets total number of teams\r\n     * @return totalNumTeams which is the number of teams\r\n    */\r\n    function totalSupply() public view returns (uint totalNumTeams) {\r\n      totalNumTeams = ballerTeams.length;\r\n    }\r\n\r\n    /*\r\n     * @dev gets total number of players\r\n     * @return totalNumPlayers is the number of players\r\n    */\r\n\r\n    function totalPlayerSupply() public view returns (uint totalNumPlayers) {\r\n        totalNumPlayers = ballerPlayers.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows user to buy a team from the old owner.\r\n    * @dev Pays old owner minus commission, updates price.\r\n    * @param _teamId id of the team they're trying to buy\r\n    */\r\n    function purchase(uint _teamId) public payable {\r\n      address oldOwner = ownerOf(_teamId);\r\n      address newOwner = msg.sender;\r\n\r\n      uint sellingPrice = teamIndexToPrice[_teamId];\r\n\r\n      // Making sure token owner is not sending to self\r\n      require(oldOwner != newOwner);\r\n\r\n      // Safety check to prevent against an unexpected 0x0 default.\r\n      require(_addressNotNull(newOwner));\r\n\r\n      // Making sure sent amount is greater than or equal to the sellingPrice\r\n      require(msg.value >= sellingPrice);\r\n\r\n      uint payment =  _calculatePaymentToOwner(sellingPrice, true);\r\n      uint excessPayment = msg.value.sub(sellingPrice);\r\n      uint newPrice = _calculateNewPrice(sellingPrice);\r\n      teamIndexToPrice[_teamId] = newPrice;\r\n\r\n      _transfer(oldOwner, newOwner, _teamId);\r\n      // Pay old tokenOwner, unless it's the smart contract\r\n      if (oldOwner != address(this)) {\r\n        oldOwner.transfer(payment);\r\n      }\r\n\r\n      newOwner.transfer(excessPayment);\r\n      string memory teamName = ballerTeams[_teamId].name;\r\n      TokenSold(_teamId, sellingPrice, newPrice, oldOwner, newOwner, teamName);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev allows user to buy a player from the old owner.\r\n    * @dev pays old owner minus commission, updates price.\r\n    * @dev commission includes house plus amount that goes to owner of team that player plays on\r\n    * @param _playerId the id of the player they're trying to buy.\r\n    */\r\n\r\n    function purchasePlayer(uint _playerId) public payable {\r\n        address oldOwner = ownerOfPlayer(_playerId);\r\n        address newOwner = msg.sender;\r\n        address teamOwner = teamOwnerOfPlayer(_playerId);\r\n\r\n        uint sellingPrice = playerIndexToPrice[_playerId];\r\n\r\n        // Making sure token owner is not sending to self\r\n        require(oldOwner != newOwner);\r\n\r\n        // Safety check to prevent against na unexpected 0x0 default\r\n        require(_addressNotNull(newOwner));\r\n\r\n        //Making sure sent amount is greater than or equal to selling price\r\n        require(msg.value >= sellingPrice);\r\n\r\n        bool sellingTeam = false;\r\n        uint payment = _calculatePaymentToOwner(sellingPrice, sellingTeam);\r\n        uint commission = msg.value.sub(payment);\r\n        uint teamOwnerCommission = commission.div(2);\r\n        uint excessPayment = msg.value.sub(sellingPrice);\r\n        uint newPrice = _calculateNewPrice(sellingPrice);\r\n        playerIndexToPrice[_playerId] = newPrice;\r\n\r\n        _transferPlayer(oldOwner, newOwner, _playerId);\r\n\r\n        // pay old token owner\r\n        if (oldOwner != address(this)) {\r\n            oldOwner.transfer(payment);\r\n        }\r\n\r\n        // pay team owner\r\n        if (teamOwner != address(this)) {\r\n            teamOwner.transfer(teamOwnerCommission);\r\n        }\r\n\r\n        newOwner.transfer(excessPayment);\r\n        string memory playerName = ballerPlayers[_playerId].name;\r\n        TokenSold(_playerId, sellingPrice, newPrice, oldOwner, newOwner, playerName);\r\n    }\r\n\r\n\r\n    /// Safety check on _to address to prevent against an unexpected 0x0 default.\r\n    function _addressNotNull(address _to) private pure returns (bool) {\r\n      return _to != address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to send some amount of ethereum out of the contract to an address\r\n    * @param _to address the eth will be sent to\r\n    * @param _amount amount you want to withdraw\r\n    */\r\n    function _withdrawAmount(address _to, uint _amount) private {\r\n      require(this.balance >= _amount);\r\n      if (_to == address(0)) {\r\n        owner.transfer(_amount);\r\n      } else {\r\n        _to.transfer(_amount);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to create team\r\n    * @param _name the name of the team\r\n    * @param _owner the owner of the team\r\n    * @param _startingPrice the price of the team at the beginning\r\n    */\r\n    function _createTeam(string _name, address _owner, uint _startingPrice) private {\r\n      Team memory currTeam = Team(_name);\r\n      uint newTeamId = ballerTeams.push(currTeam) - 1;\r\n\r\n      // make sure we never overflow amount of tokens possible to be created\r\n      // 4 billion tokens...shouldn't happen.\r\n      require(newTeamId == uint256(uint32(newTeamId)));\r\n\r\n      BallerCreated(newTeamId, _name, _owner);\r\n      teamIndexToPrice[newTeamId] = _startingPrice;\r\n      _transfer(address(0), _owner, newTeamId);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to create player\r\n    * @param _name the name of the player\r\n    * @param _teamID the id of the team the player plays on\r\n    * @param _owner the owner of the player\r\n    * @param _startingPrice the price of the player at creation\r\n    */\r\n\r\n    function _createPlayer(string _name, uint _teamID, address _owner, uint _startingPrice) private {\r\n        Player memory currPlayer = Player(_name, _teamID);\r\n        uint newPlayerId = ballerPlayers.push(currPlayer) - 1;\r\n\r\n        // make sure we never overflow amount of tokens possible to be created\r\n        // 4 billion players, shouldn't happen\r\n        require(newPlayerId == uint256(uint32(newPlayerId)));\r\n        BallerPlayerCreated(newPlayerId, _name, _teamID, _owner);\r\n        playerIndexToPrice[newPlayerId] = _startingPrice;\r\n        _transferPlayer(address(0), _owner, newPlayerId);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to transfer ownership of team\r\n    * @param _from original owner of token\r\n    * @param _to the new owner\r\n    * @param _teamId id of the team\r\n    */\r\n    function _transfer(address _from, address _to, uint _teamId) private {\r\n      ownershipTokenCount[_to]++;\r\n      teamIndexToOwner[_teamId] = _to;\r\n\r\n      // Creation of new team causes _from to be 0\r\n      if (_from != address(0)) {\r\n        ownershipTokenCount[_from]--;\r\n      }\r\n\r\n      Transfer(_from, _to, _teamId);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev internal function to transfer ownership of player\r\n    * @param _from original owner of token\r\n    * @param _to the new owner\r\n    * @param _playerId the id of the player\r\n    */\r\n\r\n    function _transferPlayer(address _from, address _to, uint _playerId) private {\r\n        playerOwnershipTokenCount[_to]++;\r\n        playerIndexToOwner[_playerId] = _to;\r\n\r\n        // creation of new player causes _from to be 0\r\n        if (_from != address(0)) {\r\n            playerOwnershipTokenCount[_from]--;\r\n        }\r\n\r\n        Transfer(_from, _to, _playerId);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate how much to give to owner of contract\r\n    * @param _sellingPrice the current price of the team\r\n    * @param _sellingTeam if you're selling a team or a player\r\n    * @return payment amount the owner gets after commission.\r\n    */\r\n    function _calculatePaymentToOwner(uint _sellingPrice, bool _sellingTeam) private pure returns (uint payment) {\r\n      uint multiplier = 1;\r\n      if (! _sellingTeam) {\r\n          multiplier = 2;\r\n      }\r\n      uint commissionAmount = 100;\r\n      if (_sellingPrice < FIRST_PRICE_LIMIT) {\r\n        commissionAmount = commissionAmount.sub(FIRST_COMMISSION_LEVEL.mul(multiplier));\r\n        payment = uint256(_sellingPrice.mul(commissionAmount).div(100));\r\n      }\r\n      else if (_sellingPrice < SECOND_PRICE_LIMIT) {\r\n        commissionAmount = commissionAmount.sub(SECOND_COMMISSION_LEVEL.mul(multiplier));\r\n\r\n        payment = uint256(_sellingPrice.mul(commissionAmount).div(100));\r\n      }\r\n      else if (_sellingPrice < THIRD_PRICE_LIMIT) {\r\n        commissionAmount = commissionAmount.sub(THIRD_COMMISSION_LEVEL.mul(multiplier));\r\n\r\n        payment = uint256(_sellingPrice.mul(commissionAmount).div(100));\r\n      }\r\n      else {\r\n        commissionAmount = commissionAmount.sub(FOURTH_COMMISSION_LEVEL.mul(multiplier));\r\n        payment = uint256(_sellingPrice.mul(commissionAmount).div(100));\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate how much the new price is\r\n    * @param _sellingPrice the current price of the team.\r\n    * @return newPrice price the team will be worth after being bought.\r\n    */\r\n    function _calculateNewPrice(uint _sellingPrice) private pure returns (uint newPrice) {\r\n      if (_sellingPrice < FIRST_PRICE_LIMIT) {\r\n        newPrice = uint256(_sellingPrice.mul(FIRST_LEVEL_INCREASE).div(100));\r\n      }\r\n      else if (_sellingPrice < SECOND_PRICE_LIMIT) {\r\n        newPrice = uint256(_sellingPrice.mul(SECOND_LEVEL_INCREASE).div(100));\r\n      }\r\n      else if (_sellingPrice < THIRD_PRICE_LIMIT) {\r\n        newPrice = uint256(_sellingPrice.mul(THIRD_LEVEL_INCREASE).div(100));\r\n      }\r\n      else {\r\n        newPrice = uint256(_sellingPrice.mul(FOURTH_LEVEL_INCREASE).div(100));\r\n      }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTeam\",\"outputs\":[{\"name\":\"teamName\",\"type\":\"string\"},{\"name\":\"currPrice\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerId\",\"type\":\"uint256\"}],\"name\":\"teamOwnerOfPlayer\",\"outputs\":[{\"name\":\"teamOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_playerId\",\"type\":\"uint256\"}],\"name\":\"purchasePlayer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalNumTeams\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPlayerSupply\",\"outputs\":[{\"name\":\"totalNumPlayers\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newName\",\"type\":\"string\"}],\"name\":\"changePlayerName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newTeamId\",\"type\":\"uint256\"}],\"name\":\"changePlayerTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"numTeamsOwned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerID\",\"type\":\"uint256\"}],\"name\":\"priceOfPlayer\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"createPromoTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTeamsOfOwner\",\"outputs\":[{\"name\":\"ownedTeams\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOfPlayers\",\"outputs\":[{\"name\":\"numPlayersOwned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newName\",\"type\":\"string\"}],\"name\":\"changeTeamName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"createTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getPlayersOfOwner\",\"outputs\":[{\"name\":\"ownedPlayers\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_teamID\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"createPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerId\",\"type\":\"uint256\"}],\"name\":\"ownerOfPlayer\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint256\"}],\"name\":\"priceOfTeam\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPlayer\",\"outputs\":[{\"name\":\"playerName\",\"type\":\"string\"},{\"name\":\"currPrice\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"owningTeamID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerIndexToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"BallerCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"teamID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"BallerPlayerCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BallerToken","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b21963695a2be441ccbffef608f3060f8d9f81af063ca0d63a9dd9b4371407c7"}]}