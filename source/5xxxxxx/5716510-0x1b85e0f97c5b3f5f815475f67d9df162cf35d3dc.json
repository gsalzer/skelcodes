{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract HasManager {\r\n  address public manager;\r\n\r\n  modifier onlyManager {\r\n    require(msg.sender == manager);\r\n    _;\r\n  }\r\n\r\n  function transferManager(address _newManager) public onlyManager() {\r\n    require(_newManager != address(0));\r\n    manager = _newManager;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract IWingsController {\r\n  uint256 public ethRewardPart;\r\n  uint256 public tokenRewardPart;\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ICrowdsaleProcessor is Ownable, HasManager {\r\n  modifier whenCrowdsaleAlive() {\r\n    require(isActive());\r\n    _;\r\n  }\r\n\r\n  modifier whenCrowdsaleFailed() {\r\n    require(isFailed());\r\n    _;\r\n  }\r\n\r\n  modifier whenCrowdsaleSuccessful() {\r\n    require(isSuccessful());\r\n    _;\r\n  }\r\n\r\n  modifier hasntStopped() {\r\n    require(!stopped);\r\n    _;\r\n  }\r\n\r\n  modifier hasBeenStopped() {\r\n    require(stopped);\r\n    _;\r\n  }\r\n\r\n  modifier hasntStarted() {\r\n    require(!started);\r\n    _;\r\n  }\r\n\r\n  modifier hasBeenStarted() {\r\n    require(started);\r\n    _;\r\n  }\r\n\r\n  // Minimal acceptable hard cap\r\n  uint256 constant public MIN_HARD_CAP = 1 ether;\r\n\r\n  // Minimal acceptable duration of crowdsale\r\n  uint256 constant public MIN_CROWDSALE_TIME = 3 days;\r\n\r\n  // Maximal acceptable duration of crowdsale\r\n  uint256 constant public MAX_CROWDSALE_TIME = 50 days;\r\n\r\n  // Becomes true when timeframe is assigned\r\n  bool public started;\r\n\r\n  // Becomes true if cancelled by owner\r\n  bool public stopped;\r\n\r\n  // Total collected Ethereum: must be updated every time tokens has been sold\r\n  uint256 public totalCollected;\r\n\r\n  // Total amount of project's token sold: must be updated every time tokens has been sold\r\n  uint256 public totalSold;\r\n\r\n  // Crowdsale minimal goal, must be greater or equal to Forecasting min amount\r\n  uint256 public minimalGoal;\r\n\r\n  // Crowdsale hard cap, must be less or equal to Forecasting max amount\r\n  uint256 public hardCap;\r\n\r\n  // Crowdsale duration in seconds.\r\n  // Accepted range is MIN_CROWDSALE_TIME..MAX_CROWDSALE_TIME.\r\n  uint256 public duration;\r\n\r\n  // Start timestamp of crowdsale, absolute UTC time\r\n  uint256 public startTimestamp;\r\n\r\n  // End timestamp of crowdsale, absolute UTC time\r\n  uint256 public endTimestamp;\r\n\r\n  // Allows to transfer some ETH into the contract without selling tokens\r\n  function deposit() public payable {}\r\n\r\n  // Returns address of crowdsale token, must be ERC20 compilant\r\n  function getToken() public returns(address);\r\n\r\n  // Transfers ETH rewards amount (if ETH rewards is configured) to Forecasting contract\r\n  function mintETHRewards(address _contract, uint256 _amount) public onlyManager();\r\n\r\n  // Mints token Rewards to Forecasting contract\r\n  function mintTokenRewards(address _contract, uint256 _amount) public onlyManager();\r\n\r\n  // Releases tokens (transfers crowdsale token from mintable to transferrable state)\r\n  function releaseTokens() public onlyManager() hasntStopped() whenCrowdsaleSuccessful();\r\n\r\n  // Stops crowdsale. Called by CrowdsaleController, the latter is called by owner.\r\n  // Crowdsale may be stopped any time before it finishes.\r\n  function stop() public onlyManager() hasntStopped();\r\n\r\n  // Validates parameters and starts crowdsale\r\n  function start(uint256 _startTimestamp, uint256 _endTimestamp, address _fundingAddress)\r\n    public onlyManager() hasntStarted() hasntStopped();\r\n\r\n  // Is crowdsale failed (completed, but minimal goal wasn't reached)\r\n  function isFailed() public constant returns (bool);\r\n\r\n  // Is crowdsale active (i.e. the token can be sold)\r\n  function isActive() public constant returns (bool);\r\n\r\n  // Is crowdsale completed successfully\r\n  function isSuccessful() public constant returns (bool);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract DefaultToken is BasicToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\ncontract BasicCrowdsale is ICrowdsaleProcessor {\r\n  event CROWDSALE_START(uint256 startTimestamp, uint256 endTimestamp, address fundingAddress);\r\n\r\n  // Where to transfer collected ETH\r\n  address public fundingAddress;\r\n\r\n  // Ctor.\r\n  function BasicCrowdsale(\r\n    address _owner,\r\n    address _manager\r\n  )\r\n    public\r\n  {\r\n    owner = _owner;\r\n    manager = _manager;\r\n  }\r\n\r\n  // called by CrowdsaleController to transfer reward part of ETH\r\n  // collected by successful crowdsale to Forecasting contract.\r\n  // This call is made upon closing successful crowdfunding process\r\n  // iff agreed ETH reward part is not zero\r\n  function mintETHRewards(\r\n    address _contract,  // Forecasting contract\r\n    uint256 _amount     // agreed part of totalCollected which is intended for rewards\r\n  )\r\n    public\r\n    onlyManager() // manager is CrowdsaleController instance\r\n  {\r\n    require(_contract.call.value(_amount)());\r\n  }\r\n\r\n  // cancels crowdsale\r\n  function stop() public onlyManager() hasntStopped()  {\r\n    // we can stop only not started and not completed crowdsale\r\n    if (started) {\r\n      require(!isFailed());\r\n      require(!isSuccessful());\r\n    }\r\n    stopped = true;\r\n  }\r\n\r\n  // called by CrowdsaleController to setup start and end time of crowdfunding process\r\n  // as well as funding address (where to transfer ETH upon successful crowdsale)\r\n  function start(\r\n    uint256 _startTimestamp,\r\n    uint256 _endTimestamp,\r\n    address _fundingAddress\r\n  )\r\n    public\r\n    onlyManager()   // manager is CrowdsaleController instance\r\n    hasntStarted()  // not yet started\r\n    hasntStopped()  // crowdsale wasn't cancelled\r\n  {\r\n    require(_fundingAddress != address(0));\r\n\r\n    // start time must not be earlier than current time\r\n    require(_startTimestamp >= block.timestamp);\r\n\r\n    // range must be sane\r\n    require(_endTimestamp > _startTimestamp);\r\n    duration = _endTimestamp - _startTimestamp;\r\n\r\n    // duration must fit constraints\r\n    require(duration >= MIN_CROWDSALE_TIME && duration <= MAX_CROWDSALE_TIME);\r\n\r\n    startTimestamp = _startTimestamp;\r\n    endTimestamp = _endTimestamp;\r\n    fundingAddress = _fundingAddress;\r\n\r\n    // now crowdsale is considered started, even if the current time is before startTimestamp\r\n    started = true;\r\n\r\n    CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress);\r\n  }\r\n\r\n  // must return true if crowdsale is over, but it failed\r\n  function isFailed()\r\n    public\r\n    constant\r\n    returns(bool)\r\n  {\r\n    return (\r\n      // it was started\r\n      started &&\r\n\r\n      // crowdsale period has finished\r\n      block.timestamp >= endTimestamp &&\r\n\r\n      // but collected ETH is below the required minimum\r\n      totalCollected < minimalGoal\r\n    );\r\n  }\r\n\r\n  // must return true if crowdsale is active (i.e. the token can be bought)\r\n  function isActive()\r\n    public\r\n    constant\r\n    returns(bool)\r\n  {\r\n    return (\r\n      // it was started\r\n      started &&\r\n\r\n      // hard cap wasn't reached yet\r\n      totalCollected < hardCap &&\r\n\r\n      // and current time is within the crowdfunding period\r\n      block.timestamp >= startTimestamp &&\r\n      block.timestamp < endTimestamp\r\n    );\r\n  }\r\n\r\n  // must return true if crowdsale completed successfully\r\n  function isSuccessful()\r\n    public\r\n    constant\r\n    returns(bool)\r\n  {\r\n    return (\r\n      // either the hard cap is collected\r\n      totalCollected >= hardCap ||\r\n\r\n      // ...or the crowdfunding period is over, but the minimum has been reached\r\n      (block.timestamp >= endTimestamp && totalCollected >= minimalGoal)\r\n    );\r\n  }\r\n}\r\n\r\ncontract Bridge is BasicCrowdsale {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  event CUSTOM_CROWDSALE_TOKEN_ADDED(address token, uint8 decimals);\r\n  event CUSTOM_CROWDSALE_FINISH();\r\n\r\n  // Crowdsale token must be ERC20-compliant\r\n  DefaultToken token;\r\n\r\n  // Crowdsale state\r\n  bool completed;\r\n\r\n  // Constructor\r\n  constructor(\r\n    uint256 _minimalGoal,\r\n    uint256 _hardCap,\r\n    address _token\r\n  )\r\n    BasicCrowdsale(msg.sender, msg.sender) // owner, manager\r\n  {\r\n    minimalGoal = _minimalGoal;\r\n    hardCap = _hardCap;\r\n    token = DefaultToken(_token);\r\n  }\r\n\r\n  /*\r\n     Here goes ICrowdsaleProcessor methods implementation\r\n  */\r\n\r\n  // Returns address of crowdsale token\r\n  function getToken()\r\n    public\r\n    returns (address)\r\n  {\r\n    return address(token);\r\n  }\r\n\r\n  // Mints token Rewards to Forecasting contract\r\n  // called by CrowdsaleController\r\n  function mintTokenRewards(\r\n    address _contract,\r\n    uint256 _amount    // agreed part of totalSold which is intended for rewards\r\n  )\r\n    public\r\n    onlyManager()\r\n  {\r\n    // in our example we are transferring tokens instead of minting them\r\n    token.transfer(_contract, _amount);\r\n  }\r\n\r\n  function releaseTokens() public onlyManager() hasntStopped() whenCrowdsaleSuccessful() {\r\n  }\r\n\r\n  /*\r\n     Crowdsale methods implementation\r\n  */\r\n\r\n  // Fallback payable function\r\n  function() public payable {\r\n  }\r\n\r\n  // Update information about collected ETH and sold tokens amount\r\n  function notifySale(uint256 _ethAmount, uint256 _tokensAmount)\r\n    public\r\n    hasBeenStarted()\r\n    hasntStopped()\r\n    whenCrowdsaleAlive()\r\n    onlyOwner()\r\n  {\r\n    totalCollected = totalCollected.add(_ethAmount);\r\n    totalSold = totalSold.add(_tokensAmount);\r\n  }\r\n\r\n  // Validates parameters and starts crowdsale\r\n  // called by CrowdsaleController\r\n  function start(\r\n    uint256 _startTimestamp,\r\n    uint256 _endTimestamp,\r\n    address _fundingAddress\r\n  )\r\n    public\r\n    hasntStarted()\r\n    hasntStopped()\r\n    onlyManager()\r\n  {\r\n    started = true;\r\n\r\n    emit CROWDSALE_START(_startTimestamp, _endTimestamp, _fundingAddress);\r\n  }\r\n\r\n  // Finish crowdsale\r\n  function finish()\r\n    public\r\n    hasntStopped()\r\n    hasBeenStarted()\r\n    whenCrowdsaleAlive()\r\n    onlyOwner()\r\n  {\r\n    completed = true;\r\n\r\n    emit CUSTOM_CROWDSALE_FINISH();\r\n  }\r\n\r\n  function isFailed()\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return (false);\r\n  }\r\n\r\n  function isActive()\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return (started && !completed);\r\n  }\r\n\r\n  function isSuccessful()\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return (completed);\r\n  }\r\n\r\n  // Find out the amount of rewards in ETH and tokens\r\n  function calculateRewards() public view returns (uint256, uint256) {\r\n    uint256 tokenRewardPart = IWingsController(manager).tokenRewardPart();\r\n    uint256 ethRewardPart = IWingsController(manager).ethRewardPart();\r\n\r\n    uint256 tokenReward = totalSold.mul(tokenRewardPart) / 1000000;\r\n    uint256 ethReward = (ethRewardPart == 0) ? 0 : (totalCollected.mul(ethRewardPart) / 1000000);\r\n\r\n    return (ethReward, tokenReward);\r\n  }\r\n\r\n  // Change token address (in case you've used the dafault token address during bridge deployment)\r\n  function changeToken(address _newToken) public onlyOwner() {\r\n    token = DefaultToken(_newToken);\r\n\r\n    emit CUSTOM_CROWDSALE_TOKEN_ADDED(address(token), uint8(token.decimals()));\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_CROWDSALE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintETHRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newToken\",\"type\":\"address\"}],\"name\":\"changeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_CROWDSALE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_HARD_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"name\":\"_tokensAmount\",\"type\":\"uint256\"}],\"name\":\"notifySale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTimestamp\",\"type\":\"uint256\"},{\"name\":\"_endTimestamp\",\"type\":\"uint256\"},{\"name\":\"_fundingAddress\",\"type\":\"address\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTokenRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"transferManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSuccessful\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFailed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_minimalGoal\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"CUSTOM_CROWDSALE_TOKEN_ADDED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CUSTOM_CROWDSALE_FINISH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fundingAddress\",\"type\":\"address\"}],\"name\":\"CROWDSALE_START\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Bridge","CompilerVersion":"v0.4.25-nightly.2018.5.30+commit.3f3d6df2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000002a22e5cca00a3d63308fa39f29202eb1b39eef52","Library":"","SwarmSource":"bzzr://583acfb5964e63cf7c951e4fa44d797f5dda478ec406e039199c265b0b5015c7"}]}