{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n*\r\n* Universal Mobile Token smart contract\r\n* Developed by Phenom.team <info@phenom.team>   \r\n*\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract UniversalMobileToken is Ownable {\r\n    \r\n    using SafeMath for uint;\r\n\r\n    /*\r\n        Standard ERC20 token\r\n    */\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    // Name of token\r\n    string public name;\r\n    // Short symbol for token\r\n    string public symbol;\r\n\r\n    // Nubmer of decimal places\r\n    uint public decimals;\r\n\r\n    // Token's total supply\r\n    uint public totalSupply;\r\n\r\n    // Is minting active\r\n    bool public mintingIsFinished;\r\n\r\n    // Is transfer possible\r\n    bool public transferIsPossible;\r\n\r\n    modifier onlyEmitter() {\r\n        require(emitters[msg.sender] == true);\r\n        _;\r\n    }\r\n    \r\n    mapping (address => uint) public balances;\r\n    mapping (address => bool) public emitters;\r\n    mapping (address => mapping (address => uint)) internal allowed;\r\n    \r\n    constructor() Ownable() public {\r\n        name = \"Universal Mobile Token\";\r\n        symbol = \"UMT\";\r\n        decimals = 18;   \r\n        // Make the Owner also an emitter\r\n        emitters[msg.sender] = true;\r\n    }\r\n\r\n    /**\r\n    *   @dev Finish minting process\r\n    */\r\n    function finishMinting() public onlyOwner {\r\n        mintingIsFinished = true;\r\n        transferIsPossible = true;\r\n    }\r\n\r\n    /**\r\n    *   @dev Send coins\r\n    *   throws on any error rather then return a false flag to minimize\r\n    *   user errors\r\n    *   @param _to           target address\r\n    *   @param _value       transfer amount\r\n    *\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        // Make transfer only if transfer is possible\r\n        require(transferIsPossible);\r\n        require(_to != address(0) && _to != address(this));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *   @dev Allows another account/contract to spend some tokens on its behalf\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   also, to minimize the risk of the approve/transferFrom attack vector\r\n    *   approve has to be called twice in 2 separate transactions - once to\r\n    *   change the allowance to 0 and secondly to change it to the new allowance\r\n    *   value\r\n    *\r\n    *   @param _spender      approved address\r\n    *   @param _value       allowance amount\r\n    *\r\n    *   @return true if the approval was successful\r\n    */\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *   @dev An account/contract attempts to get the coins\r\n    *   throws on any error rather then return a false flag to minimize user errors\r\n    *\r\n    *   @param _from         source address\r\n    *   @param _to           target address\r\n    *   @param _value        amount\r\n    *\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        // Make transfer only if transfer is possible\r\n        require(transferIsPossible);\r\n\r\n        require(_to != address(0) && _to != address(this));\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    *   @dev Add an emitter account\r\n    *   \r\n    *   @param _emitter     emitter's address\r\n    */\r\n    function addEmitter(address _emitter) public onlyOwner {\r\n        emitters[_emitter] = true;\r\n    }\r\n    \r\n    /**\r\n    *   @dev Remove an emitter account\r\n    *   \r\n    *   @param _emitter     emitter's address\r\n    */\r\n    function removeEmitter(address _emitter) public onlyOwner {\r\n        emitters[_emitter] = false;\r\n    }\r\n    \r\n    /**\r\n    *   @dev Mint token in batches\r\n    *   \r\n    *   @param _adresses     token holders' adresses\r\n    *   @param _values       token holders' values\r\n    */\r\n    function batchMint(address[] _adresses, uint[] _values) public onlyEmitter {\r\n        require(_adresses.length == _values.length);\r\n        for (uint i = 0; i < _adresses.length; i++) {\r\n            require(minted(_adresses[i], _values[i]));\r\n        }\r\n    }\r\n\r\n    /**\r\n    *   @dev Transfer token in batches\r\n    *   \r\n    *   @param _adresses     token holders' adresses\r\n    *   @param _values       token holders' values\r\n    */\r\n    function batchTransfer(address[] _adresses, uint[] _values) public {\r\n        require(_adresses.length == _values.length);\r\n        for (uint i = 0; i < _adresses.length; i++) {\r\n            require(transfer(_adresses[i], _values[i]));\r\n        }\r\n    }\r\n\r\n    /**\r\n    *   @dev Burn Tokens\r\n    *   @param _from       token holder address which the tokens will be burnt\r\n    *   @param _value      number of tokens to burn\r\n    */\r\n    function burn(address _from, uint _value) public onlyEmitter {\r\n        // Burn tokens only if minting stage is not finished\r\n        require(!mintingIsFinished);\r\n\r\n        require(_value <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n    }\r\n\r\n    /**\r\n    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    *   @param _tokenOwner        the address which owns the funds\r\n    *   @param _spender      the address which will spend the funds\r\n    *\r\n    *   @return              the amount of tokens still avaible for the spender\r\n    */\r\n    function allowance(address _tokenOwner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_tokenOwner][_spender];\r\n    }\r\n\r\n    /**\r\n    *   @dev Function to check the amount of tokens that _tokenOwner has.\r\n    *\r\n    *   @param _tokenOwner        the address which owns the funds\r\n    *\r\n    *   @return              the amount of tokens _tokenOwner has\r\n    */\r\n    function balanceOf(address _tokenOwner) public constant returns (uint balance) {\r\n        return balances[_tokenOwner];\r\n    }\r\n\r\n    function minted(address _to, uint _value) internal returns (bool) {\r\n        // Mint tokens only if minting stage is not finished\r\n        require(!mintingIsFinished);\r\n        balances[_to] = balances[_to].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        emit Transfer(address(0), _to, _value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_emitter\",\"type\":\"address\"}],\"name\":\"removeEmitter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_emitter\",\"type\":\"address\"}],\"name\":\"addEmitter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingIsFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adresses\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferIsPossible\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adresses\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"emitters\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"UniversalMobileToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://be9acf5de4697cda7efa4407ba733b8e3a56898f5ceb70f74f02b66bb34d7c19"}]}