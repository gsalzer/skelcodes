{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/**\r\n* @title TuurntToken \r\n* @dev The TuurntToken contract contains the information about \r\n* Tuurnt token.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\ncontract TuurntToken is StandardToken, DetailedERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // distribution variables\r\n    uint256 public tokenAllocToTeam;\r\n    uint256 public tokenAllocToCrowdsale;\r\n    uint256 public tokenAllocToCompany;\r\n\r\n    // addresses\r\n    address public crowdsaleAddress;\r\n    address public teamAddress;\r\n    address public companyAddress;\r\n    \r\n\r\n    /**\r\n    * @dev The TuurntToken constructor set the orginal crowdsaleAddress,teamAddress and companyAddress and allocate the\r\n    * tokens to them.\r\n    * @param _crowdsaleAddress The address of crowsale contract\r\n    * @param _teamAddress The address of team\r\n    * @param _companyAddress The address of company \r\n    */\r\n\r\n    constructor(address _crowdsaleAddress, address _teamAddress, address _companyAddress, string _name, string _symbol, uint8 _decimals) public \r\n        DetailedERC20(_name, _symbol, _decimals)\r\n    {\r\n        require(_crowdsaleAddress != address(0));\r\n        require(_teamAddress != address(0));\r\n        require(_companyAddress != address(0));\r\n        totalSupply_ = 500000000 * 10 ** 18;\r\n        tokenAllocToTeam = (totalSupply_.mul(33)).div(100);     // 33 % Allocation\r\n        tokenAllocToCompany = (totalSupply_.mul(33)).div(100);  // 33 % Allocation \r\n        tokenAllocToCrowdsale = (totalSupply_.mul(34)).div(100);// 34 % Allocation\r\n\r\n        // Address      \r\n        crowdsaleAddress = _crowdsaleAddress;\r\n        teamAddress = _teamAddress;\r\n        companyAddress = _companyAddress;\r\n        \r\n\r\n        // Allocations\r\n        balances[crowdsaleAddress] = tokenAllocToCrowdsale;\r\n        balances[companyAddress] = tokenAllocToCompany;\r\n        balances[teamAddress] = tokenAllocToTeam; \r\n       \r\n        //transfer event\r\n        emit Transfer(address(0), crowdsaleAddress, tokenAllocToCrowdsale);\r\n        emit Transfer(address(0), companyAddress, tokenAllocToCompany);\r\n        emit Transfer(address(0), teamAddress, tokenAllocToTeam);\r\n       \r\n        \r\n    }  \r\n}\r\n\r\ncontract WhitelistInterface {\r\n    function checkWhitelist(address _whiteListAddress) public view returns(bool);\r\n}\r\n\r\n/**\r\n* @title TuurntCrowdsale\r\n* @dev The Crowdsale contract holds the token for the public sale of token and \r\n* contains the function to buy token.  \r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TuurntCrowdsale is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    TuurntToken public token;\r\n    WhitelistInterface public whitelist;\r\n\r\n    //variable declaration\r\n    uint256 public MIN_INVESTMENT = 0.2 ether;\r\n    uint256 public ethRaised;\r\n    uint256 public ethRate = 524;\r\n    uint256 public startCrowdsalePhase1Date;\r\n    uint256 public endCrowdsalePhase1Date;\r\n    uint256 public startCrowdsalePhase2Date;\r\n    uint256 public endCrowdsalePhase2Date;\r\n    uint256 public startCrowdsalePhase3Date;\r\n    uint256 public endCrowdsalePhase3Date;\r\n    uint256 public startPresaleDate;\r\n    uint256 public endPresaleDate;\r\n    uint256 public startPrivatesaleDate;\r\n    uint256 public soldToken = 0;                                                           \r\n\r\n    //addresses\r\n    address public beneficiaryAddress;\r\n    address public tokenAddress;\r\n\r\n    bool private isPrivatesaleActive = false;\r\n    bool private isPresaleActive = false;\r\n    bool private isPhase1CrowdsaleActive = false;\r\n    bool private isPhase2CrowdsaleActive = false;\r\n    bool private isPhase3CrowdsaleActive = false;\r\n    bool private isGapActive = false;\r\n\r\n    event TokenBought(address indexed _investor, uint256 _token, uint256 _timestamp);\r\n    event LogTokenSet(address _token, uint256 _timestamp);\r\n\r\n    enum State { PrivateSale, PreSale, Gap, CrowdSalePhase1, CrowdSalePhase2, CrowdSalePhase3 }\r\n\r\n    /**\r\n    * @dev Transfer the ether to the beneficiaryAddress.\r\n    * @param _fund The ether that is transferred to contract to buy tokens.  \r\n    */\r\n    function fundTransfer(uint256 _fund) internal returns(bool) {\r\n        beneficiaryAddress.transfer(_fund);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev fallback function which accepts the ether and call the buy token function.\r\n    */\r\n    function () payable public {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev TuurntCrowdsale constructor sets the original beneficiaryAddress and \r\n    * set the timeslot for the Pre-ICO and ICO.\r\n    * @param _beneficiaryAddress The address to transfer the ether that is raised during crowdsale. \r\n    */\r\n    constructor(address _beneficiaryAddress, address _whitelist, uint256 _startDate) public {\r\n        require(_beneficiaryAddress != address(0));\r\n        beneficiaryAddress = _beneficiaryAddress;\r\n        whitelist = WhitelistInterface(_whitelist);\r\n        startPrivatesaleDate = _startDate;\r\n        isPrivatesaleActive = !isPrivatesaleActive;\r\n    }\r\n\r\n    /**\r\n    * @dev Allow founder to end the Private sale.\r\n    */\r\n    function endPrivatesale() onlyOwner public {\r\n        require(isPrivatesaleActive == true);\r\n        isPrivatesaleActive = !isPrivatesaleActive;\r\n    }\r\n\r\n    /**\r\n    * @dev Allow founder to set the token contract address.\r\n    * @param _tokenAddress The address of token contract.\r\n    */\r\n    function setTokenAddress(address _tokenAddress) onlyOwner public {\r\n        require(tokenAddress == address(0));\r\n        token = TuurntToken(_tokenAddress);\r\n        tokenAddress = _tokenAddress;\r\n        emit LogTokenSet(token, now);\r\n    }\r\n\r\n     /**\r\n    * @dev Allow founder to start the Presale.\r\n    */\r\n    function activePresale(uint256 _presaleDate) onlyOwner public {\r\n        require(isPresaleActive == false);\r\n        require(isPrivatesaleActive == false);\r\n        startPresaleDate = _presaleDate;\r\n        endPresaleDate = startPresaleDate + 2 days;\r\n        isPresaleActive = !isPresaleActive;\r\n    }\r\n   \r\n    /**\r\n    * @dev Allow founder to start the Crowdsale phase1.\r\n    */\r\n    function activeCrowdsalePhase1(uint256 _phase1Date) onlyOwner public {\r\n        require(isPresaleActive == true);\r\n        require(_phase1Date > endPresaleDate);\r\n        require(isPhase1CrowdsaleActive == false);\r\n        startCrowdsalePhase1Date = _phase1Date;\r\n        endCrowdsalePhase1Date = _phase1Date + 1 weeks;\r\n        isPresaleActive = !isPresaleActive;\r\n        isPhase1CrowdsaleActive = !isPhase1CrowdsaleActive;\r\n    }\r\n\r\n    /**\r\n    * @dev Allow founder to start the Crowdsale phase2. \r\n    */\r\n\r\n    function activeCrowdsalePhase2(uint256 _phase2Date) onlyOwner public {\r\n        require(isPhase2CrowdsaleActive == false);\r\n        require(_phase2Date > endCrowdsalePhase1Date);\r\n        require(isPhase1CrowdsaleActive == true);\r\n        startCrowdsalePhase2Date = _phase2Date;\r\n        endCrowdsalePhase2Date = _phase2Date + 2 weeks;\r\n        isPhase2CrowdsaleActive = !isPhase2CrowdsaleActive;\r\n        isPhase1CrowdsaleActive = !isPhase1CrowdsaleActive;\r\n    }\r\n\r\n    /**\r\n    * @dev Allow founder to start the Crowdsale phase3. \r\n    */\r\n    function activeCrowdsalePhase3(uint256 _phase3Date) onlyOwner public {\r\n        require(isPhase3CrowdsaleActive == false);\r\n        require(_phase3Date > endCrowdsalePhase2Date);\r\n        require(isPhase2CrowdsaleActive == true);\r\n        startCrowdsalePhase3Date = _phase3Date;\r\n        endCrowdsalePhase3Date = _phase3Date + 3 weeks;\r\n        isPhase3CrowdsaleActive = !isPhase3CrowdsaleActive;\r\n        isPhase2CrowdsaleActive = !isPhase2CrowdsaleActive;\r\n    }\r\n    /**\r\n    * @dev Allow founder to change the minimum investment of ether.\r\n    * @param _newMinInvestment The value of new minimum ether investment. \r\n    */\r\n    function changeMinInvestment(uint256 _newMinInvestment) onlyOwner public {\r\n        MIN_INVESTMENT = _newMinInvestment;\r\n    }\r\n\r\n     /**\r\n    * @dev Allow founder to change the ether rate.\r\n    * @param _newEthRate current rate of ether. \r\n    */\r\n    function setEtherRate(uint256 _newEthRate) onlyOwner public {\r\n        require(_newEthRate != 0);\r\n        ethRate = _newEthRate;\r\n    }\r\n\r\n    /**\r\n    * @dev Return the state based on the timestamp. \r\n    */\r\n\r\n    function getState() view public returns(State) {\r\n        \r\n        if(now >= startPrivatesaleDate && isPrivatesaleActive == true) {\r\n            return State.PrivateSale;\r\n        }\r\n        if (now >= startPresaleDate && now <= endPresaleDate) {\r\n            require(isPresaleActive == true);\r\n            return State.PreSale;\r\n        }\r\n        if (now >= startCrowdsalePhase1Date && now <= endCrowdsalePhase1Date) {\r\n            require(isPhase1CrowdsaleActive == true);\r\n            return State.CrowdSalePhase1;\r\n        }\r\n        if (now >= startCrowdsalePhase2Date && now <= endCrowdsalePhase2Date) {\r\n            require(isPhase2CrowdsaleActive == true);\r\n            return State.CrowdSalePhase2;\r\n        }\r\n        if (now >= startCrowdsalePhase3Date && now <= endCrowdsalePhase3Date) {\r\n            require(isPhase3CrowdsaleActive == true);\r\n            return State.CrowdSalePhase3;\r\n        }\r\n        return State.Gap;\r\n\r\n    }\r\n \r\n    /**\r\n    * @dev Return the rate based on the state and timestamp.\r\n    */\r\n\r\n    function getRate() view public returns(uint256) {\r\n        if (getState() == State.PrivateSale) {\r\n            return 5;\r\n        }\r\n        if (getState() == State.PreSale) {\r\n            return 6;\r\n        }\r\n        if (getState() == State.CrowdSalePhase1) {\r\n            return 7;\r\n        }\r\n        if (getState() == State.CrowdSalePhase2) {\r\n            return 8;\r\n        }\r\n        if (getState() == State.CrowdSalePhase3) {\r\n            return 10;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Calculate the number of tokens to be transferred to the investor address \r\n    * based on the invested ethers.\r\n    * @param _investedAmount The value of ether that is invested.  \r\n    */\r\n    function getTokenAmount(uint256 _investedAmount) view public returns(uint256) {\r\n        uint256 tokenRate = getRate();\r\n        uint256 tokenAmount = _investedAmount.mul((ethRate.mul(100)).div(tokenRate));\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer the tokens to the investor address.\r\n    * @param _investorAddress The address of investor. \r\n    */\r\n    function buyTokens(address _investorAddress) \r\n    public \r\n    payable\r\n    returns(bool)\r\n    {   \r\n        require(whitelist.checkWhitelist(_investorAddress));\r\n        if ((getState() == State.PreSale) ||\r\n            (getState() == State.CrowdSalePhase1) || \r\n            (getState() == State.CrowdSalePhase2) || \r\n            (getState() == State.CrowdSalePhase3) || \r\n            (getState() == State.PrivateSale)) {\r\n            uint256 amount;\r\n            require(_investorAddress != address(0));\r\n            require(tokenAddress != address(0));\r\n            require(msg.value >= MIN_INVESTMENT);\r\n            amount = getTokenAmount(msg.value);\r\n            require(fundTransfer(msg.value));\r\n            require(token.transfer(_investorAddress, amount));\r\n            ethRaised = ethRaised.add(msg.value);\r\n            soldToken = soldToken.add(amount);\r\n            emit TokenBought(_investorAddress,amount,now);\r\n            return true;\r\n        }else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allow founder to end the crowsale and transfer the remaining\r\n    * tokens of crowdfund to the company address. \r\n    */\r\n    function endCrowdfund(address companyAddress) onlyOwner public returns(bool) {\r\n        require(isPhase3CrowdsaleActive == true);\r\n        require(now >= endCrowdsalePhase3Date); \r\n        uint256 remaining = token.balanceOf(this);\r\n        require(token.transfer(companyAddress, remaining));\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_presaleDate\",\"type\":\"uint256\"}],\"name\":\"activePresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phase2Date\",\"type\":\"uint256\"}],\"name\":\"activeCrowdsalePhase2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endPrivatesale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMinInvestment\",\"type\":\"uint256\"}],\"name\":\"changeMinInvestment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPrivatesaleDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startCrowdsalePhase2Date\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phase3Date\",\"type\":\"uint256\"}],\"name\":\"activeCrowdsalePhase3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPresaleDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endCrowdsalePhase3Date\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startCrowdsalePhase3Date\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEthRate\",\"type\":\"uint256\"}],\"name\":\"setEtherRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startCrowdsalePhase1Date\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investedAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_phase1Date\",\"type\":\"uint256\"}],\"name\":\"activeCrowdsalePhase1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endCrowdsalePhase1Date\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiaryAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startPresaleDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"companyAddress\",\"type\":\"address\"}],\"name\":\"endCrowdfund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investorAddress\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endCrowdsalePhase2Date\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiaryAddress\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"address\"},{\"name\":\"_startDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"LogTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TuurntCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a9cd4e094a3c7cca0431e8da8dd280181ad8c99c0000000000000000000000004c518f5dfdc03117b2ea388d1b4c4497954fd409000000000000000000000000000000000000000000000000000000005b2c11d0","Library":"","SwarmSource":"bzzr://723f100531b27d3877e123c0af0df95fa13dcc83dac4c50f231da2044e05380f"}]}