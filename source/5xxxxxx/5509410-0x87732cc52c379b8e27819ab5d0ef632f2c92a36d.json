{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n    \r\n    // File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n    \r\n    /**\r\n     * @title Ownable\r\n     * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n     * functions, this simplifies the implementation of \"user permissions\".\r\n     */\r\n    contract Ownable {\r\n      address public owner;\r\n    \r\n    \r\n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    \r\n      /**\r\n       * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n       * account.\r\n       */\r\n      function Ownable() public {\r\n        owner = msg.sender;\r\n      }\r\n    \r\n      /**\r\n       * @dev Throws if called by any account other than the owner.\r\n       */\r\n      modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n      }\r\n    \r\n      /**\r\n       * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n       * @param newOwner The address to transfer ownership to.\r\n       */\r\n      function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n      }\r\n    \r\n    }\r\n    \r\n    // File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n    \r\n    /**\r\n     * @title Pausable\r\n     * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n     */\r\n    contract Pausable is Ownable {\r\n      event Pause();\r\n      event Unpause();\r\n    \r\n      bool public paused = false;\r\n    \r\n    \r\n      /**\r\n       * @dev Modifier to make a function callable only when the contract is not paused.\r\n       */\r\n      modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n      }\r\n    \r\n      /**\r\n       * @dev Modifier to make a function callable only when the contract is paused.\r\n       */\r\n      modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n      }\r\n    \r\n      /**\r\n       * @dev called by the owner to pause, triggers stopped state\r\n       */\r\n      function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n      }\r\n    \r\n      /**\r\n       * @dev called by the owner to unpause, returns to normal state\r\n       */\r\n      function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n      }\r\n    }\r\n    \r\n    // File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n    \r\n    /**\r\n     * @title SafeMath\r\n     * @dev Math operations with safety checks that throw on error\r\n     */\r\n    library SafeMath {\r\n    \r\n      /**\r\n      * @dev Multiplies two numbers, throws on overflow.\r\n      */\r\n      function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n      }\r\n    \r\n      /**\r\n      * @dev Integer division of two numbers, truncating the quotient.\r\n      */\r\n      function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n      }\r\n    \r\n      /**\r\n      * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n      */\r\n      function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n      }\r\n    \r\n      /**\r\n      * @dev Adds two numbers, throws on overflow.\r\n      */\r\n      function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n      }\r\n    }\r\n    \r\n    // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n    \r\n    /**\r\n     * @title ERC20Basic\r\n     * @dev Simpler version of ERC20 interface\r\n     * @dev see https://github.com/ethereum/EIPs/issues/179\r\n     */\r\n    contract ERC20Basic {\r\n      function totalSupply() public view returns (uint256);\r\n      function balanceOf(address who) public view returns (uint256);\r\n      function transfer(address to, uint256 value) public returns (bool);\r\n      event Transfer(address indexed from, address indexed to, uint256 value);\r\n    }\r\n    \r\n    // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n    \r\n    /**\r\n     * @title Basic token\r\n     * @dev Basic version of StandardToken, with no allowances.\r\n     */\r\n    contract BasicToken is ERC20Basic {\r\n      using SafeMath for uint256;\r\n    \r\n      mapping(address => uint256) balances;\r\n    \r\n      uint256 totalSupply_;\r\n    \r\n      /**\r\n      * @dev total number of tokens in existence\r\n      */\r\n      function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n      }\r\n    \r\n      /**\r\n      * @dev transfer token for a specified address\r\n      * @param _to The address to transfer to.\r\n      * @param _value The amount to be transferred.\r\n      */\r\n      function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n    \r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      }\r\n    \r\n      /**\r\n      * @dev Gets the balance of the specified address.\r\n      * @param _owner The address to query the the balance of.\r\n      * @return An uint256 representing the amount owned by the passed address.\r\n      */\r\n      function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n      }\r\n    \r\n    }\r\n    \r\n    // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n    \r\n    /**\r\n     * @title ERC20 interface\r\n     * @dev see https://github.com/ethereum/EIPs/issues/20\r\n     */\r\n    contract ERC20 is ERC20Basic {\r\n      function allowance(address owner, address spender) public view returns (uint256);\r\n      function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n      function approve(address spender, uint256 value) public returns (bool);\r\n      event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    }\r\n    \r\n    // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n    \r\n    /**\r\n     * @title Standard ERC20 token\r\n     *\r\n     * @dev Implementation of the basic standard token.\r\n     * @dev https://github.com/ethereum/EIPs/issues/20\r\n     * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n     */\r\n    contract StandardToken is ERC20, BasicToken {\r\n    \r\n      mapping (address => mapping (address => uint256)) internal allowed;\r\n    \r\n    \r\n      /**\r\n       * @dev Transfer tokens from one address to another\r\n       * @param _from address The address which you want to send tokens from\r\n       * @param _to address The address which you want to transfer to\r\n       * @param _value uint256 the amount of tokens to be transferred\r\n       */\r\n      function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n    \r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      }\r\n    \r\n      /**\r\n       * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n       *\r\n       * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n       * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n       * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n       * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n       * @param _spender The address which will spend the funds.\r\n       * @param _value The amount of tokens to be spent.\r\n       */\r\n      function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n      }\r\n    \r\n      /**\r\n       * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n       * @param _owner address The address which owns the funds.\r\n       * @param _spender address The address which will spend the funds.\r\n       * @return A uint256 specifying the amount of tokens still available for the spender.\r\n       */\r\n      function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n      }\r\n    \r\n      /**\r\n       * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n       *\r\n       * approve should be called when allowed[_spender] == 0. To increment\r\n       * allowed value is better to use this function to avoid 2 calls (and wait until\r\n       * the first transaction is mined)\r\n       * From MonolithDAO Token.sol\r\n       * @param _spender The address which will spend the funds.\r\n       * @param _addedValue The amount of tokens to increase the allowance by.\r\n       */\r\n      function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n      }\r\n    \r\n      /**\r\n       * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n       *\r\n       * approve should be called when allowed[_spender] == 0. To decrement\r\n       * allowed value is better to use this function to avoid 2 calls (and wait until\r\n       * the first transaction is mined)\r\n       * From MonolithDAO Token.sol\r\n       * @param _spender The address which will spend the funds.\r\n       * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n       */\r\n      function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n          allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n          allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n      }\r\n    \r\n    }\r\n    \r\n    // File: contracts/CurrentToken.sol\r\n    \r\n    contract CurrentToken is StandardToken, Pausable {\r\n        string constant public name = \"CurrentCoin\";\r\n        string constant public symbol = \"CUR\";\r\n        uint8 constant public decimals = 18;\r\n    \r\n        uint256 constant public INITIAL_TOTAL_SUPPLY = 1e11 * (uint256(10) ** decimals);\r\n    \r\n        address private addressIco;\r\n    \r\n        modifier onlyIco() {\r\n            require(msg.sender == addressIco);\r\n            _;\r\n        }\r\n    \r\n        /**\r\n        * @dev Create CurrentToken contract and set pause\r\n        * @param _ico The address of ICO contract.\r\n        */\r\n        function CurrentToken (address _ico) public {\r\n            require(_ico != address(0));\r\n    \r\n            addressIco = _ico;\r\n    \r\n            totalSupply_ = totalSupply_.add(INITIAL_TOTAL_SUPPLY);\r\n            balances[_ico] = balances[_ico].add(INITIAL_TOTAL_SUPPLY);\r\n            Transfer(address(0), _ico, INITIAL_TOTAL_SUPPLY);\r\n    \r\n            pause();\r\n        }\r\n    \r\n        /**\r\n        * @dev Transfer token for a specified address with pause feature for owner.\r\n        * @dev Only applies when the transfer is allowed by the owner.\r\n        * @param _to The address to transfer to.\r\n        * @param _value The amount to be transferred.\r\n        */\r\n        function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) {\r\n            super.transfer(_to, _value);\r\n        }\r\n    \r\n        /**\r\n        * @dev Transfer tokens from one address to another with pause feature for owner.\r\n        * @dev Only applies when the transfer is allowed by the owner.\r\n        * @param _from address The address which you want to send tokens from\r\n        * @param _to address The address which you want to transfer to\r\n        * @param _value uint256 the amount of tokens to be transferred\r\n        */\r\n        function transferFrom(address _from, address _to, uint256 _value) whenNotPaused public returns (bool) {\r\n            super.transferFrom(_from, _to, _value);\r\n        }\r\n    \r\n        /**\r\n        * @dev Transfer tokens from ICO address to another address.\r\n        * @param _to The address to transfer to.\r\n        * @param _value The amount to be transferred.\r\n        */\r\n        function transferFromIco(address _to, uint256 _value) onlyIco public returns (bool) {\r\n            super.transfer(_to, _value);\r\n        }\r\n    \r\n        /**\r\n        * @dev Burn remaining tokens from the ICO balance.\r\n        */\r\n        function burnFromIco() onlyIco public {\r\n            uint256 remainingTokens = balanceOf(addressIco);\r\n    \r\n            balances[addressIco] = balances[addressIco].sub(remainingTokens);\r\n            totalSupply_ = totalSupply_.sub(remainingTokens);\r\n            Transfer(addressIco, address(0), remainingTokens);\r\n        }\r\n    \r\n        /**\r\n        * @dev Burn all tokens form balance of token holder during refund process.\r\n        * @param _from The address of token holder whose tokens to be burned.\r\n        */\r\n        function burnFromAddress(address _from) onlyIco public {\r\n            uint256 amount = balances[_from];\r\n    \r\n            balances[_from] = 0;\r\n            totalSupply_ = totalSupply_.sub(amount);\r\n            Transfer(_from, address(0), amount);\r\n        }\r\n    }\r\n    \r\n    // File: contracts/Whitelist.sol\r\n    \r\n    /**\r\n     * @title Whitelist contract\r\n     * @dev Whitelist for wallets.\r\n    */\r\n    contract Whitelist is Ownable {\r\n        mapping(address => bool) whitelist;\r\n    \r\n        uint256 public whitelistLength = 0;\r\n    \r\n        /**\r\n        * @dev Add wallet to whitelist.\r\n        * @dev Accept request from the owner only.\r\n        * @param _wallet The address of wallet to add.\r\n        */  \r\n        function addWallet(address _wallet) onlyOwner public {\r\n            require(_wallet != address(0));\r\n            require(!isWhitelisted(_wallet));\r\n            whitelist[_wallet] = true;\r\n            whitelistLength++;\r\n        }\r\n    \r\n        /**\r\n        * @dev Remove wallet from whitelist.\r\n        * @dev Accept request from the owner only.\r\n        * @param _wallet The address of whitelisted wallet to remove.\r\n        */  \r\n        function removeWallet(address _wallet) onlyOwner public {\r\n            require(_wallet != address(0));\r\n            require(isWhitelisted(_wallet));\r\n            whitelist[_wallet] = false;\r\n            whitelistLength--;\r\n        }\r\n    \r\n        /**\r\n        * @dev Check the specified wallet whether it is in the whitelist.\r\n        * @param _wallet The address of wallet to check.\r\n        */ \r\n        function isWhitelisted(address _wallet) constant public returns (bool) {\r\n            return whitelist[_wallet];\r\n        }\r\n    \r\n    }\r\n    \r\n    // File: contracts/Whitelistable.sol\r\n    \r\n    contract Whitelistable {\r\n        Whitelist public whitelist;\r\n    \r\n        modifier whenWhitelisted(address _wallet) {\r\n            require(whitelist.isWhitelisted(_wallet));\r\n            _;\r\n        }\r\n    \r\n        /**\r\n        * @dev Constructor for Whitelistable contract.\r\n        */\r\n        function Whitelistable() public {\r\n            whitelist = new Whitelist();\r\n        }\r\n    }\r\n    \r\n    // File: contracts/CurrentCrowdsale.sol\r\n    \r\n    contract CurrentCrowdsale is Pausable, Whitelistable {\r\n        using SafeMath for uint256;\r\n    \r\n        uint256 constant private DECIMALS = 18;\r\n        uint256 constant public RESERVED_TOKENS_FOUNDERS = 40e9 * (10 ** DECIMALS);\r\n        uint256 constant public RESERVED_TOKENS_OPERATIONAL_EXPENSES = 10e9 * (10 ** DECIMALS);\r\n        uint256 constant public HARDCAP_TOKENS_PRE_ICO = 100e6 * (10 ** DECIMALS);\r\n        uint256 constant public HARDCAP_TOKENS_ICO = 499e8 * (10 ** DECIMALS);\r\n    \r\n        uint256 public startTimePreIco = 0;\r\n        uint256 public endTimePreIco = 0;\r\n    \r\n        uint256 public startTimeIco = 0;\r\n        uint256 public endTimeIco = 0;\r\n    \r\n        uint256 public exchangeRatePreIco = 0;\r\n    \r\n        bool public isTokenRateCalculated = false;\r\n    \r\n        uint256 public exchangeRateIco = 0;\r\n    \r\n        uint256 public mincap = 0;\r\n        uint256 public maxcap = 0;\r\n    \r\n        mapping(address => uint256) private investments;    \r\n    \r\n        uint256 public tokensSoldIco = 0;\r\n        uint256 public tokensRemainingIco = HARDCAP_TOKENS_ICO;\r\n        uint256 public tokensSoldTotal = 0;\r\n    \r\n        uint256 public weiRaisedPreIco = 0;\r\n        uint256 public weiRaisedIco = 0;\r\n        uint256 public weiRaisedTotal = 0;\r\n    \r\n        mapping(address => uint256) private investmentsPreIco;\r\n        address[] private investorsPreIco;\r\n    \r\n        address private withdrawalWallet;\r\n    \r\n        bool public isTokensPreIcoDistributed = false;\r\n        uint256 public distributionPreIcoCount = 0;\r\n    \r\n        CurrentToken public token = new CurrentToken(this);\r\n    \r\n        modifier beforeReachingHardCap() {\r\n            require(tokensRemainingIco > 0 && weiRaisedTotal < maxcap);\r\n            _;\r\n        }\r\n    \r\n        modifier whenPreIcoSaleHasEnded() {\r\n            require(now > endTimePreIco);\r\n            _;\r\n        }\r\n    \r\n        modifier whenIcoSaleHasEnded() {\r\n            require(endTimeIco > 0 && now > endTimeIco);\r\n            _;\r\n        }\r\n    \r\n        /**\r\n        * @dev Constructor for CurrentCrowdsale contract.\r\n        * @dev Set the owner who can manage whitelist and token.\r\n        * @param _mincap The mincap value.\r\n        * @param _startTimePreIco The pre-ICO start time.\r\n        * @param _endTimePreIco The pre-ICO end time.\r\n        * @param _foundersWallet The address to which reserved tokens for founders will be transferred.\r\n        * @param _operationalExpensesWallet The address to which reserved tokens for operational expenses will be transferred.\r\n        * @param _withdrawalWallet The address to which raised funds will be withdrawn.\r\n        */\r\n        function CurrentCrowdsale(\r\n            uint256 _mincap,\r\n            uint256 _maxcap,\r\n            uint256 _startTimePreIco,\r\n            uint256 _endTimePreIco,\r\n            address _foundersWallet,\r\n            address _operationalExpensesWallet,\r\n            address _withdrawalWallet\r\n        ) Whitelistable() public\r\n        {\r\n            require(_foundersWallet != address(0) && _operationalExpensesWallet != address(0) && _withdrawalWallet != address(0));\r\n            require(_startTimePreIco >= now && _endTimePreIco > _startTimePreIco);\r\n            require(_mincap > 0 && _maxcap > _mincap);\r\n    \r\n            startTimePreIco = _startTimePreIco;\r\n            endTimePreIco = _endTimePreIco;\r\n    \r\n            withdrawalWallet = _withdrawalWallet;\r\n    \r\n            mincap = _mincap;\r\n            maxcap = _maxcap;\r\n    \r\n            whitelist.transferOwnership(msg.sender);\r\n    \r\n            token.transferFromIco(_foundersWallet, RESERVED_TOKENS_FOUNDERS);\r\n            token.transferFromIco(_operationalExpensesWallet, RESERVED_TOKENS_OPERATIONAL_EXPENSES);\r\n            token.transferOwnership(msg.sender);\r\n        }\r\n    \r\n        /**\r\n        * @dev Fallback function can be used to buy tokens.\r\n        */\r\n        function() public payable {\r\n            if (isPreIco()) {\r\n                sellTokensPreIco();\r\n            } else if (isIco()) {\r\n                sellTokensIco();\r\n            } else {\r\n                revert();\r\n            }\r\n        }\r\n    \r\n        /**\r\n        * @dev Check whether the pre-ICO is active at the moment.\r\n        */\r\n        function isPreIco() public constant returns (bool) {\r\n            bool withinPreIco = now >= startTimePreIco && now <= endTimePreIco;\r\n            return withinPreIco;\r\n        }\r\n    \r\n        /**\r\n        * @dev Check whether the ICO is active at the moment.\r\n        */\r\n        function isIco() public constant returns (bool) {\r\n            bool withinIco = now >= startTimeIco && now <= endTimeIco;\r\n            return withinIco;\r\n        }\r\n    \r\n        /**\r\n        * @dev Manual refund if mincap has not been reached.\r\n        * @dev Only applies when the ICO was ended. \r\n        */\r\n        function manualRefund() whenIcoSaleHasEnded public {\r\n            require(weiRaisedTotal < mincap);\r\n    \r\n            uint256 weiAmountTotal = investments[msg.sender];\r\n            require(weiAmountTotal > 0);\r\n    \r\n            investments[msg.sender] = 0;\r\n    \r\n            uint256 weiAmountPreIco = investmentsPreIco[msg.sender];\r\n            uint256 weiAmountIco = weiAmountTotal;\r\n    \r\n            if (weiAmountPreIco > 0) {\r\n                investmentsPreIco[msg.sender] = 0;\r\n                weiRaisedPreIco = weiRaisedPreIco.sub(weiAmountPreIco);\r\n                weiAmountIco = weiAmountIco.sub(weiAmountPreIco);\r\n            }\r\n    \r\n            if (weiAmountIco > 0) {\r\n                weiRaisedIco = weiRaisedIco.sub(weiAmountIco);\r\n                uint256 tokensIco = weiAmountIco.mul(exchangeRateIco);\r\n                tokensSoldIco = tokensSoldIco.sub(tokensIco);\r\n            }\r\n    \r\n            weiRaisedTotal = weiRaisedTotal.sub(weiAmountTotal);\r\n    \r\n            uint256 tokensAmount = token.balanceOf(msg.sender);\r\n    \r\n            tokensSoldTotal = tokensSoldTotal.sub(tokensAmount);\r\n    \r\n            token.burnFromAddress(msg.sender);\r\n    \r\n            msg.sender.transfer(weiAmountTotal);\r\n        }\r\n    \r\n        /**\r\n        * @dev Sell tokens during pre-ICO.\r\n        * @dev Sell tokens only for whitelisted wallets.\r\n        */\r\n        function sellTokensPreIco() beforeReachingHardCap whenWhitelisted(msg.sender) whenNotPaused public payable {\r\n            require(isPreIco());\r\n            require(msg.value > 0);\r\n    \r\n            uint256 weiAmount = msg.value;\r\n            uint256 excessiveFunds = 0;\r\n    \r\n            uint256 plannedWeiTotal = weiRaisedTotal.add(weiAmount);\r\n    \r\n            if (plannedWeiTotal > maxcap) {\r\n                excessiveFunds = plannedWeiTotal.sub(maxcap);\r\n                weiAmount = maxcap.sub(weiRaisedTotal);\r\n            }\r\n    \r\n            investments[msg.sender] = investments[msg.sender].add(weiAmount);\r\n    \r\n            weiRaisedPreIco = weiRaisedPreIco.add(weiAmount);\r\n            weiRaisedTotal = weiRaisedTotal.add(weiAmount);\r\n    \r\n            addInvestmentPreIco(msg.sender, weiAmount);\r\n    \r\n            if (excessiveFunds > 0) {\r\n                msg.sender.transfer(excessiveFunds);\r\n            }\r\n        }\r\n    \r\n        /**\r\n        * @dev Sell tokens during ICO.\r\n        * @dev Sell tokens only for whitelisted wallets.\r\n        */\r\n        function sellTokensIco() beforeReachingHardCap whenWhitelisted(msg.sender) whenNotPaused public payable {\r\n            require(isIco());\r\n            require(msg.value > 0);\r\n    \r\n            uint256 weiAmount = msg.value;\r\n            uint256 excessiveFunds = 0;\r\n    \r\n            uint256 plannedWeiTotal = weiRaisedTotal.add(weiAmount);\r\n    \r\n            if (plannedWeiTotal > maxcap) {\r\n                excessiveFunds = plannedWeiTotal.sub(maxcap);\r\n                weiAmount = maxcap.sub(weiRaisedTotal);\r\n            }\r\n    \r\n            uint256 tokensAmount = weiAmount.mul(exchangeRateIco);\r\n    \r\n            if (tokensAmount > tokensRemainingIco) {\r\n                uint256 weiToAccept = tokensRemainingIco.div(exchangeRateIco);\r\n                excessiveFunds = excessiveFunds.add(weiAmount.sub(weiToAccept));\r\n                \r\n                tokensAmount = tokensRemainingIco;\r\n                weiAmount = weiToAccept;\r\n            }\r\n    \r\n            investments[msg.sender] = investments[msg.sender].add(weiAmount);\r\n    \r\n            tokensSoldIco = tokensSoldIco.add(tokensAmount);\r\n            tokensSoldTotal = tokensSoldTotal.add(tokensAmount);\r\n            tokensRemainingIco = tokensRemainingIco.sub(tokensAmount);\r\n    \r\n            weiRaisedIco = weiRaisedIco.add(weiAmount);\r\n            weiRaisedTotal = weiRaisedTotal.add(weiAmount);\r\n    \r\n            token.transferFromIco(msg.sender, tokensAmount);\r\n    \r\n            if (excessiveFunds > 0) {\r\n                msg.sender.transfer(excessiveFunds);\r\n            }\r\n        }\r\n    \r\n        /**\r\n        * @dev Send raised funds to the withdrawal wallet.\r\n        */\r\n        function forwardFunds() onlyOwner public {\r\n            require(weiRaisedTotal >= mincap);\r\n            withdrawalWallet.transfer(this.balance);\r\n        }\r\n    \r\n        /**\r\n        * @dev Calculate token exchange rate for pre-ICO and ICO.\r\n        * @dev Only applies when the pre-ICO was ended.\r\n        * @dev May be called only once.\r\n        */\r\n        function calcTokenRate() whenPreIcoSaleHasEnded onlyOwner public {\r\n            require(!isTokenRateCalculated);\r\n            require(weiRaisedPreIco > 0);\r\n    \r\n            exchangeRatePreIco = HARDCAP_TOKENS_PRE_ICO.div(weiRaisedPreIco);\r\n    \r\n            exchangeRateIco = exchangeRatePreIco.div(2);\r\n    \r\n            isTokenRateCalculated = true;\r\n        }\r\n    \r\n        /**\r\n        * @dev Distribute tokens to pre-ICO investors using pagination.\r\n        * @dev Pagination proceeds the set value (paginationCount) of tokens distributions per one function call.\r\n        * @param _paginationCount The value that used for pagination.\r\n        */\r\n        function distributeTokensPreIco(uint256 _paginationCount) onlyOwner public {\r\n            require(isTokenRateCalculated && !isTokensPreIcoDistributed);\r\n            require(_paginationCount > 0);\r\n    \r\n            uint256 count = 0;\r\n            for (uint256 i = distributionPreIcoCount; i < getPreIcoInvestorsCount(); i++) {\r\n                if (count == _paginationCount) {\r\n                    break;\r\n                }\r\n                uint256 investment = getPreIcoInvestment(getPreIcoInvestor(i));\r\n                uint256 tokensAmount = investment.mul(exchangeRatePreIco);\r\n                \r\n                tokensSoldTotal = tokensSoldTotal.add(tokensAmount);\r\n    \r\n                token.transferFromIco(getPreIcoInvestor(i), tokensAmount);\r\n    \r\n                count++;\r\n            }\r\n    \r\n            distributionPreIcoCount = distributionPreIcoCount.add(count);\r\n    \r\n            if (distributionPreIcoCount == getPreIcoInvestorsCount()) {\r\n                isTokensPreIcoDistributed = true;\r\n            }\r\n        }\r\n    \r\n        /**\r\n        * @dev Burn unsold tokens from the ICO balance.\r\n        * @dev Only applies when the ICO was ended.\r\n        */\r\n        function burnUnsoldTokens() whenIcoSaleHasEnded onlyOwner public {\r\n            require(tokensRemainingIco > 0);\r\n            token.burnFromIco();\r\n            tokensRemainingIco = 0;\r\n        }\r\n    \r\n        /**\r\n        * @dev Count the pre-ICO investors total.\r\n        */\r\n        function getPreIcoInvestorsCount() constant public returns (uint256) {\r\n            return investorsPreIco.length;\r\n        }\r\n    \r\n        /**\r\n        * @dev Get the pre-ICO investor address.\r\n        * @param _index the index of investor in the array. \r\n        */\r\n        function getPreIcoInvestor(uint256 _index) constant public returns (address) {\r\n            return investorsPreIco[_index];\r\n        }\r\n    \r\n        /**\r\n        * @dev Gets the amount of tokens for pre-ICO investor.\r\n        * @param _investorPreIco the pre-ICO investor address.\r\n        */\r\n        function getPreIcoInvestment(address _investorPreIco) constant public returns (uint256) {\r\n            return investmentsPreIco[_investorPreIco];\r\n        }\r\n    \r\n        /**\r\n        * @dev Set start time and end time for ICO.\r\n        * @dev Only applies when tokens distributions to pre-ICO investors were processed.\r\n        * @param _startTimeIco The ICO start time.\r\n        * @param _endTimeIco The ICO end time.\r\n        */\r\n        function setStartTimeIco(uint256 _startTimeIco, uint256 _endTimeIco) whenPreIcoSaleHasEnded beforeReachingHardCap onlyOwner public {\r\n            require(_startTimeIco >= now && _endTimeIco > _startTimeIco);\r\n            require(isTokenRateCalculated);\r\n    \r\n            startTimeIco = _startTimeIco;\r\n            endTimeIco = _endTimeIco;\r\n        }\r\n    \r\n        /**\r\n        * @dev Add new investment to the pre-ICO investments storage.\r\n        * @param _from The address of a pre-ICO investor.\r\n        * @param _value The investment received from a pre-ICO investor.\r\n        */\r\n        function addInvestmentPreIco(address _from, uint256 _value) internal {\r\n            if (investmentsPreIco[_from] == 0) {\r\n                investorsPreIco.push(_from);\r\n            }\r\n            investmentsPreIco[_from] = investmentsPreIco[_from].add(_value);\r\n        }  \r\n    }","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"removeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Whitelist","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://225756a0f9c84934246a57a221dcb71f416077e0009ea6f8faf8de9402780713"}]}