{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/*\r\nCheck code on Github: https://github.com/maraoz/cryptokitties-arena/tree/700d2e67d52396485236623402dba4e60e3765c0\r\n*/\r\n\r\ncontract Destiny {\r\n    function fight(bytes32 cat1, bytes32 cat2, bytes32 entropy) public returns (bytes32 winner);\r\n}\r\n\r\ncontract KittyInterface {\r\n    function approve(address _to, uint256 _tokenId) public;\r\n\tfunction transfer(address to, uint256 kittyId);\r\n\tfunction transferFrom(address from, address to, uint256 kittyId);\r\n\tfunction getKitty(uint256 _id) external view returns (bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes);\r\n}\r\n\r\ncontract Random {\r\n  // The upper bound of the number returns is 2^bits - 1\r\n  function bitSlice(uint256 n, uint256 bits, uint256 slot) public pure returns(uint256) {\r\n      uint256 offset = slot * bits;\r\n      // mask is made by shifting left an offset number of times\r\n      uint256 mask = uint256((2**bits) - 1) << offset;\r\n      // AND n with mask, and trim to max of 5 bits\r\n      return uint256((n & mask) >> offset);\r\n  }\r\n\r\n  /**\r\n  * @dev This function assumes that the consumer contract has logic for handling when\r\n  the returned blockhash is bytes32(0), \r\n  */\r\n  function maxRandom(uint256 sourceBlock) public view returns (uint256 randomNumber) {\r\n    require(block.number > sourceBlock);\r\n    return uint256(block.blockhash(sourceBlock));\r\n  }\r\n\r\n  function random(uint256 upper) public view returns (uint256 randomNumber) {\r\n    return random(upper, block.number - 1);\r\n  }\r\n\r\n  // return a pseudo random number between lower and upper bounds\r\n  // given the number of previous blocks it should hash.\r\n  function random(uint256 upper, uint256 sourceBlock) public returns (uint256 randomNumber) {\r\n    return maxRandom(sourceBlock) % upper;\r\n  }\r\n}\r\n\r\n\r\ncontract KittyArena is Random {\r\n\tstruct Player {\r\n\t\tuint256 kitty;\r\n\t\taddress addr;\r\n\t}\r\n\r\n\tstruct Game {\r\n\t\tPlayer player1;\r\n\t\tPlayer player2;\r\n\t\tuint256 fightBlock;\r\n\t\taddress winner;\r\n\t}\r\n\r\n\tKittyInterface public ck;\r\n\tDestiny destiny;\r\n\tGame[] public games;\r\n\r\n\taddress constant public TIE = address(-2);\r\n\r\n\tevent KittyEntered(uint256 indexed gameId, uint256 indexed kittyId, address indexed owner);\r\n\tevent FightStarted(uint256 indexed gameId, uint256 fightBlock);\r\n\tevent FightResolved(uint256 indexed gameId, address indexed winner);\r\n\r\n\tconstructor (KittyInterface _ck, Destiny _destiny) public {\r\n\t\tck = _ck;\r\n\t\tdestiny = _destiny;\r\n\t}\r\n\r\n\tfunction enter(uint256 kitty) external {\r\n\t\tck.transferFrom(msg.sender, this, kitty);\r\n\t\tPlayer storage player;\r\n\t\tGame storage game;\r\n\r\n\t\tif (games.length > 0 && games[games.length - 1].fightBlock == 0) {\r\n\t\t\t// player is player2 for game\r\n\t\t\tgame = games[games.length - 1];\r\n\t\t\tgame.player2 = Player(kitty, msg.sender);\r\n\t\t\tgame.fightBlock = block.number;\r\n\r\n\t\t\tplayer = game.player2;\r\n\r\n\t\t\temit FightStarted(games.length - 1, game.fightBlock);\r\n\t\t} else {\r\n\t\t\tgames.length += 1;\r\n\t\t\tgame = games[games.length - 1];\r\n\t\t\tgame.player1 = Player(kitty, msg.sender);\r\n\r\n\t\t\tplayer = game.player1;\r\n\t\t}\r\n\r\n\t\temit KittyEntered(games.length - 1, player.kitty, player.addr);\r\n\t}\r\n\r\n\tfunction resolve(uint256 gameId) external {\r\n\t\tGame storage game = games[gameId];\r\n\t\trequire(game.winner == address(0));\r\n        require(game.player1.addr != address(0));\r\n        require(game.player2.addr != address(0));\r\n\r\n\t\tgame.winner = getWinner(gameId);\r\n\t\t\r\n\t\tck.transfer(game.winner == TIE ? game.player1.addr : game.winner, game.player1.kitty);\r\n\t\tck.transfer(game.winner == TIE ? game.player2.addr : game.winner, game.player2.kitty);\r\n\r\n\t\temit FightResolved(gameId, game.winner);\r\n\t}\r\n\r\n\tfunction getWinner(uint256 gameId) public view returns (address) {\r\n\t\tGame storage game = games[gameId];\r\n\t\tif (game.winner != address(0)) {\r\n\t\t\treturn game.winner;\r\n\t\t}\r\n\r\n\t\tbytes32 genes1 = catGenes(game.player1.kitty);\r\n\t\tbytes32 genes2 = catGenes(game.player2.kitty);\r\n\r\n\t\trequire(block.number > game.fightBlock);\r\n\t\tbytes32 seed = bytes32(maxRandom(game.fightBlock));\r\n\t\t\r\n\t\t// If game isn't resolved in 256 blocks and we cannot get the entropy,\r\n\t\t// we considered it tie\r\n\t\tif (seed == bytes32(0)) {\r\n\t\t\treturn TIE;\r\n\t\t}\r\n\r\n\t\tbytes32 winnerGenes = destiny.fight(genes1, genes2, seed);\r\n\r\n\t\tif (winnerGenes == genes1) {\r\n\t\t\treturn game.player1.addr;\r\n\t\t} \r\n\r\n\t\tif (winnerGenes == genes2) { \r\n\t\t\treturn game.player2.addr;\r\n\t\t}\r\n\r\n\t\t// Destiny may return something other than one of the two cats gens,\r\n\t\t// if so we consider it a tie\r\n\t\treturn TIE;\r\n\t}\r\n\r\n\tfunction catGenes(uint256 kitty) private view returns (bytes32 genes) {\r\n\t\tvar (,,,,,,,,,_genes) = ck.getKitty(kitty);\r\n\t\tgenes = bytes32(_genes);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"TIE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"components\":[{\"name\":\"kitty\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"player1\",\"type\":\"tuple\"},{\"components\":[{\"name\":\"kitty\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"player2\",\"type\":\"tuple\"},{\"name\":\"fightBlock\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"getWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"resolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"bits\",\"type\":\"uint256\"},{\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"bitSlice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"kitty\",\"type\":\"uint256\"}],\"name\":\"enter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"upper\",\"type\":\"uint256\"},{\"name\":\"sourceBlock\",\"type\":\"uint256\"}],\"name\":\"random\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"upper\",\"type\":\"uint256\"}],\"name\":\"random\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ck\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sourceBlock\",\"type\":\"uint256\"}],\"name\":\"maxRandom\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ck\",\"type\":\"address\"},{\"name\":\"_destiny\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"kittyId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"KittyEntered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fightBlock\",\"type\":\"uint256\"}],\"name\":\"FightStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"FightResolved\",\"type\":\"event\"}]","ContractName":"KittyArena","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000006012c8cf97bead5deae237070f9587f8e7a266d000000000000000000000000b90b203a64e219dabb4e7bc152d16b04419cff43","Library":"","SwarmSource":"bzzr://6d78d1e20ed3a4f24fc58a7c733658de9d4f10052db6da2ae7c6b9d0b0d2658d"}]}