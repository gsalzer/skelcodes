{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/* ==================================================================== */\r\n/* Copyright (c) 2018 The Priate Conquest Project.  All rights reserved.\r\n/* \r\n/* https://www.pirateconquest.com One of the world's slg games of blockchain \r\n/*  \r\n/* authors rainy@livestar.com/Jonny.Fu@livestar.com\r\n/*                 \r\n/* ==================================================================== */\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\ncontract ERC721 /* is ERC165 */ {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n  function ownerOf(uint256 _tokenId) external view returns (address);\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n  function approve(address _approved, uint256 _tokenId) external payable;\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n  function getApproved(uint256 _tokenId) external view returns (address);\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n     function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\ninterface ERC721TokenReceiver {\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    function name() external view returns (string _name);\r\n    function symbol() external view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /*\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() external onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() external onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint32 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function div32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function add32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    uint32 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract AccessAdmin is Pausable {\r\n\r\n  /// @dev Admin Address\r\n  mapping (address => bool) adminContracts;\r\n\r\n  /// @dev Trust contract\r\n  mapping (address => bool) actionContracts;\r\n\r\n  function setAdminContract(address _addr, bool _useful) public onlyOwner {\r\n    require(_addr != address(0));\r\n    adminContracts[_addr] = _useful;\r\n  }\r\n\r\n  modifier onlyAdmin {\r\n    require(adminContracts[msg.sender]); \r\n    _;\r\n  }\r\n\r\n  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\r\n    actionContracts[_actionAddr] = _useful;\r\n  }\r\n\r\n  modifier onlyAccess() {\r\n    require(actionContracts[msg.sender]);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\ncontract KittyToken is AccessAdmin, ERC721 {\r\n  using SafeMath for SafeMath;\r\n  //event \r\n  event CreateGift(uint tokenId,uint32 cardId, address _owner, uint256 _price);\r\n  //ERC721\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  struct Kitty {\r\n    uint32 kittyId;\r\n  }\r\n\r\n  Kitty[] public kitties; //dynamic Array\r\n  function KittyToken() public {\r\n    kitties.length += 1;\r\n    setAdminContract(msg.sender,true);\r\n    setActionContract(msg.sender,true);\r\n  }\r\n\r\n  /**MAPPING**/\r\n  /// @dev tokenId to owner  tokenId -> address\r\n  mapping (uint256 => address) public TokenIdToOwner;\r\n  /// @dev Equipment token ID search in owner array kittyId -> tokenId\r\n  mapping (uint256 => uint256) kittyIdToOwnerIndex;  \r\n  /// @dev kittys owner by the owner (array)\r\n  mapping (address => uint256[]) ownerTokittyArray;\r\n  /// @dev price of each token\r\n  mapping (uint256 => uint256) TokenIdToPrice;\r\n  /// @dev token count of kitty\r\n  mapping (uint32 => uint256) tokenCountOfkitty;\r\n  /// @dev tokens by the kitty\r\n  mapping (uint256 => uint32) IndexTokitty;\r\n  /// @dev The authorized address for each kitty\r\n  mapping (uint256 => address) kittyTokenIdToApprovals;\r\n  /// @dev The authorized operators for each address\r\n  mapping (address => mapping (address => bool)) operatorToApprovals;\r\n  mapping(uint256 => bool) tokenToSell;\r\n  \r\n\r\n  /*** CONSTRUCTOR ***/\r\n  /// @dev Amount of tokens destroyed\r\n  uint256 destroyKittyCount;\r\n  uint256 onAuction;\r\n  // modifier\r\n  /// @dev Check if token ID is valid\r\n  modifier isValidToken(uint256 _tokenId) {\r\n    require(_tokenId >= 1 && _tokenId <= kitties.length);\r\n    require(TokenIdToOwner[_tokenId] != address(0)); \r\n    _;\r\n  }\r\n  modifier canTransfer(uint256 _tokenId) {\r\n    require(msg.sender == TokenIdToOwner[_tokenId]);\r\n    _;\r\n  }\r\n  /// @dev Creates a new kitty with the given name.\r\n  function CreateKittyToken(address _owner,uint256 _price, uint32 _cardId) public onlyAccess {\r\n    _createKittyToken(_owner,_price,_cardId);\r\n  }\r\n\r\n    /// For creating GiftToken\r\n  function _createKittyToken(address _owner, uint256 _price, uint32 _kittyId) \r\n  internal {\r\n    uint256 newTokenId = kitties.length;\r\n    Kitty memory _kitty = Kitty({\r\n      kittyId: _kittyId\r\n    });\r\n    kitties.push(_kitty);\r\n    //event\r\n    CreateGift(newTokenId, _kittyId, _owner, _price);\r\n    TokenIdToPrice[newTokenId] = _price;\r\n    IndexTokitty[newTokenId] = _kittyId;\r\n    tokenCountOfkitty[_kittyId] = SafeMath.add(tokenCountOfkitty[_kittyId],1);\r\n    // This will assign ownership, and also emit the Transfer event as\r\n    // per ERC721 draft\r\n    _transfer(address(0), _owner, newTokenId);\r\n  } \r\n  /// @dev let owner set the token price\r\n  function setTokenPriceByOwner(uint256 _tokenId, uint256 _price) external {\r\n    require(TokenIdToOwner[_tokenId] == msg.sender);\r\n    TokenIdToPrice[_tokenId] = _price;\r\n  }\r\n\r\n    /// @dev set the token price\r\n  function setTokenPrice(uint256 _tokenId, uint256 _price) external onlyAccess {\r\n    TokenIdToPrice[_tokenId] = _price;\r\n  }\r\n\r\n  /// @notice Returns all the relevant information about a specific tokenId.\r\n  /// @param _tokenId The tokenId of the captain\r\n  function getKittyInfo(uint256 _tokenId) external view returns (\r\n    uint32 kittyId,  \r\n    uint256 price,\r\n    address owner,\r\n    bool selled\r\n  ) {\r\n    Kitty storage kitty = kitties[_tokenId];\r\n    kittyId = kitty.kittyId;\r\n    price = TokenIdToPrice[_tokenId];\r\n    owner = TokenIdToOwner[_tokenId];\r\n    selled = tokenToSell[_tokenId];\r\n  }\r\n  /// @dev Do the real transfer with out any condition checking\r\n  /// @param _from The old owner of this kitty(If created: 0x0)\r\n  /// @param _to The new owner of this kitty \r\n  /// @param _tokenId The tokenId of the kitty\r\n  function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n    if (_from != address(0)) {\r\n      uint256 indexFrom = kittyIdToOwnerIndex[_tokenId];  // tokenId -> kittyId\r\n      uint256[] storage cpArray = ownerTokittyArray[_from];\r\n      require(cpArray[indexFrom] == _tokenId);\r\n\r\n      // If the kitty is not the element of array, change it to with the last\r\n      if (indexFrom != cpArray.length - 1) {\r\n        uint256 lastTokenId = cpArray[cpArray.length - 1];\r\n        cpArray[indexFrom] = lastTokenId; \r\n        kittyIdToOwnerIndex[lastTokenId] = indexFrom;\r\n      }\r\n      cpArray.length -= 1; \r\n    \r\n      if (kittyTokenIdToApprovals[_tokenId] != address(0)) {\r\n        delete kittyTokenIdToApprovals[_tokenId];\r\n      }      \r\n    }\r\n\r\n    // Give the kitty to '_to'\r\n    TokenIdToOwner[_tokenId] = _to;\r\n    ownerTokittyArray[_to].push(_tokenId);\r\n    kittyIdToOwnerIndex[_tokenId] = ownerTokittyArray[_to].length - 1;\r\n        \r\n    Transfer(_from != address(0) ? _from : this, _to, _tokenId);\r\n  }\r\n\r\n  /// @dev Return all the auction tokens\r\n  function getAuctions() external view returns (uint256[]) {\r\n    uint256 totalgifts = kitties.length - destroyKittyCount - 1;\r\n\r\n    uint256[] memory result = new uint256[](onAuction);\r\n    uint256 tokenId = 1;\r\n    for (uint i=0;i< totalgifts;i++) {\r\n      if (tokenToSell[tokenId] == true) {\r\n        result[i] = tokenId;\r\n        tokenId ++;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /// ERC721 \r\n\r\n  function balanceOf(address _owner) external view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownerTokittyArray[_owner].length;\r\n  }\r\n\r\n  function ownerOf(uint256 _tokenId) external view returns (address) {\r\n    return TokenIdToOwner[_tokenId];\r\n  }\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {\r\n    _safeTransferFrom(_from, _to, _tokenId, data);\r\n  }\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /// @dev Actually perform the safeTransferFrom\r\n  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) \r\n    internal\r\n    isValidToken(_tokenId) \r\n    canTransfer(_tokenId)\r\n    {\r\n    address owner = TokenIdToOwner[_tokenId];\r\n    require(owner != address(0) && owner == _from);\r\n    require(_to != address(0));\r\n        \r\n    _transfer(_from, _to, _tokenId);\r\n\r\n    // Do the callback after everything is done to avoid reentrancy attack\r\n    /*uint256 codeSize;\r\n    assembly { codeSize := extcodesize(_to) }\r\n    if (codeSize == 0) {\r\n      return;\r\n    }*/\r\n    bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\r\n    // bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")) = 0xf0b9e5ba;\r\n    require(retval == 0xf0b9e5ba);\r\n  }\r\n    \r\n  /// @dev Transfer ownership of an kitty, '_to' must be a vaild address, or the WAR will lost\r\n  /// @param _from The current owner of the kitty\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The kitty to transfer\r\n  function transferFrom(address _from, address _to, uint256 _tokenId)\r\n        external\r\n        whenNotPaused\r\n        isValidToken(_tokenId)\r\n        canTransfer(_tokenId)\r\n        payable\r\n    {\r\n    address owner = TokenIdToOwner[_tokenId];\r\n    require(owner != address(0));\r\n    require(owner == _from);\r\n    require(_to != address(0));\r\n        \r\n    _transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /// @dev Safe transfer by trust contracts\r\n  function safeTransferByContract(address _from,address _to, uint256 _tokenId) \r\n  external\r\n  whenNotPaused\r\n  {\r\n    require(actionContracts[msg.sender]);\r\n\r\n    require(_tokenId >= 1 && _tokenId <= kitties.length);\r\n    address owner = TokenIdToOwner[_tokenId];\r\n    require(owner != address(0));\r\n    require(_to != address(0));\r\n    require(owner != _to);\r\n    require(_from == owner);\r\n\r\n    _transfer(owner, _to, _tokenId);\r\n  }\r\n\r\n  /// @dev Set or reaffirm the approved address for an kitty\r\n  /// @param _approved The new approved kitty controller\r\n  /// @param _tokenId The kitty to approve\r\n  function approve(address _approved, uint256 _tokenId)\r\n    external\r\n    whenNotPaused \r\n    payable\r\n  {\r\n    address owner = TokenIdToOwner[_tokenId];\r\n    require(owner != address(0));\r\n    require(msg.sender == owner || operatorToApprovals[owner][msg.sender]);\r\n\r\n    kittyTokenIdToApprovals[_tokenId] = _approved;\r\n    Approval(owner, _approved, _tokenId);\r\n  }\r\n\r\n  /// @dev Enable or disable approval for a third party (\"operator\") to manage all your asset.\r\n  /// @param _operator Address to add to the set of authorized operators.\r\n  /// @param _approved True if the operators is approved, false to revoke approval\r\n  function setApprovalForAll(address _operator, bool _approved) \r\n    external \r\n    whenNotPaused\r\n  {\r\n    operatorToApprovals[msg.sender][_operator] = _approved;\r\n    ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /// @dev Get the approved address for a single kitty\r\n  /// @param _tokenId The WAR to find the approved address for\r\n  /// @return The approved address for this WAR, or the zero address if there is none\r\n  function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) {\r\n    return kittyTokenIdToApprovals[_tokenId];\r\n  }\r\n  \r\n  /// @dev Query if an address is an authorized operator for another address\r\n  /// @param _owner The address that owns the WARs\r\n  /// @param _operator The address that acts on behalf of the owner\r\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n    return operatorToApprovals[_owner][_operator];\r\n  }\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() public pure returns(string) {\r\n    return \"Pirate Kitty Token\";\r\n  }\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() public pure returns(string) {\r\n    return \"KCT\";\r\n  }\r\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n  ///  Metadata JSON Schema\".\r\n  //function tokenURI(uint256 _tokenId) external view returns (string);\r\n\r\n  /// @notice Count NFTs tracked by this contract\r\n  /// @return A count of valid NFTs tracked by this contract, where each one of\r\n  ///  them has an assigned and queryable owner not equal to the zero address\r\n  function totalSupply() external view returns (uint256) {\r\n    return kitties.length - destroyKittyCount -1;\r\n  }\r\n  /// @notice Enumerate valid NFTs\r\n  /// @dev Throws if `_index` >= `totalSupply()`.\r\n  /// @param _index A counter less than `totalSupply()`\r\n  /// @return The token identifier for the `_index`th NFT,\r\n  ///  (sort order not specified)\r\n  function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n    require(_index<(kitties.length - destroyKittyCount));\r\n    //return kittyIdToOwnerIndex[_index];\r\n    return _index;\r\n  }\r\n  /// @notice Enumerate NFTs assigned to an owner\r\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  ///  `_owner` is the zero address, representing invalid NFTs.\r\n  /// @param _owner An address where we are interested in NFTs owned by them\r\n  /// @param _index A counter less than `balanceOf(_owner)`\r\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  ///   (sort order not specified)\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n    require(_index < ownerTokittyArray[_owner].length);\r\n    if (_owner != address(0)) {\r\n      uint256 tokenId = ownerTokittyArray[_owner][_index];\r\n      return tokenId;\r\n    }\r\n  }\r\n\r\n  /// @param _owner The owner whose celebrity tokens we are interested in.\r\n  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\r\n  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n  ///  not contract-to-contract calls.\r\n  function tokensOfOwner(address _owner) external view returns (uint256[],uint32[]) {\r\n    uint256 len = ownerTokittyArray[_owner].length;\r\n    uint256[] memory tokens = new uint256[](len);\r\n    uint32[] memory kittyss = new uint32[](len);\r\n    uint256 icount;\r\n    if (_owner != address(0)) {\r\n      for (uint256 i=0;i<len;i++) {\r\n        tokens[i] = ownerTokittyArray[_owner][icount];\r\n        kittyss[i] = IndexTokitty[ownerTokittyArray[_owner][icount]];\r\n        icount++;\r\n      }\r\n    }\r\n    return (tokens,kittyss);\r\n  }\r\n\r\n  /// @param _kittyId The kitty whose celebrity tokens we are interested in.\r\n  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\r\n  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n  ///  not contract-to-contract calls.\r\n  function tokensOfkitty(uint32 _kittyId) public view returns(uint256[] kittyTokens) {\r\n    uint256 tokenCount = tokenCountOfkitty[_kittyId];\r\n    if (tokenCount == 0) {\r\n        // Return an empty array\r\n      return new uint256[](0);\r\n    } else {\r\n      uint256[] memory result = new uint256[](tokenCount);\r\n      uint256 totalkitties = kitties.length - destroyKittyCount - 1;\r\n      uint256 resultIndex = 0;\r\n\r\n      uint256 tokenId;\r\n      for (tokenId = 0; tokenId <= totalkitties; tokenId++) {\r\n        if (IndexTokitty[tokenId] == _kittyId) {\r\n          result[resultIndex] = tokenId;\r\n          resultIndex++;\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  } \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setAdminContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setTokenPriceByOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TokenIdToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_kittyId\",\"type\":\"uint32\"}],\"name\":\"tokensOfkitty\",\"outputs\":[{\"name\":\"kittyTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_actionAddr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setActionContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getKittyInfo\",\"outputs\":[{\"name\":\"kittyId\",\"type\":\"uint32\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"selled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"kitties\",\"outputs\":[{\"name\":\"kittyId\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_cardId\",\"type\":\"uint32\"}],\"name\":\"CreateKittyToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuctions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferByContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cardId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"CreateGift\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"KittyToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://73074787483e25567e175895fbfdcc05a80e2bfc8d694fae5341e14f2bb34ecd"}]}