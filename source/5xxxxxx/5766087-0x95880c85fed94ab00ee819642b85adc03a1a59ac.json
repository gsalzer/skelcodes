{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Bet {\r\n    address public ceoAddress;\r\n    address public cooAddress;\r\n\r\n    enum RoundStatus { UNKNOWN, RUNNING, FINISHED, CANCELLED }\r\n\r\n    event RoundCreated(uint16 roundId);\r\n    event BetPlaced(uint betId, uint16 roundId, uint amount);\r\n    event RoundStatusUpdated(uint16 roundId, RoundStatus oldStatus, RoundStatus newStatus);\r\n    event FinalScoreUpdated(uint16 roundId, bytes32 winner);\r\n    event Debug(uint16 roundId, uint expire, uint time, bool condition);\r\n\r\n    struct Round {\r\n        string name;\r\n        bytes32[] statusPossibility;\r\n        uint16 nbBets;\r\n        uint prizePool;\r\n        RoundStatus status;\r\n        bytes32 resultStatus;\r\n        uint runningAt;\r\n        uint finishedAt;\r\n        uint expireAt;\r\n    }\r\n\r\n    struct Bet {\r\n        uint16 roundId;\r\n        address owner;\r\n        uint amount;\r\n        bytes32 status;\r\n        bool claimed;\r\n    }\r\n\r\n    //mapping(uint => address) public betToOwner;\r\n    mapping(uint16 => uint[]) public roundBets; // roundId => betId[]\r\n    //mapping(address => uint) public ownerBetCount;\r\n    Bet[] public bets;\r\n    Round[] public rounds;\r\n    uint16 public roundsCount;\r\n    uint public fees;\r\n    uint public MINIMUM_BET_VALUE = 0.01 ether;\r\n\r\n    constructor() public {\r\n        ceoAddress = msg.sender;\r\n        cooAddress = msg.sender;\r\n    }\r\n\r\n    function setMinimumBetValue(uint _minimumBetValue) onlyCLevel {\r\n        MINIMUM_BET_VALUE = _minimumBetValue;\r\n    }\r\n\r\n    function setCEOAddress(address _address) public onlyOwner {\r\n        ceoAddress = _address;\r\n    }\r\n\r\n    function setCOOAddress(address _address) public onlyOwner {\r\n        cooAddress = _address;\r\n    }\r\n\r\n    function createRound(string _name, bytes32[] _statusPossibility, uint _expireAt) public onlyCLevel {\r\n        uint16 id = uint16(rounds.push(Round(_name, _statusPossibility, 0, 0, RoundStatus.RUNNING, 0, now, 0, _expireAt)) - 1);\r\n        roundsCount = uint16(SafeMath.add(roundsCount, 1));\r\n\r\n        emit RoundCreated(id);\r\n    }\r\n\r\n    function getRoundStatuses(uint16 _roundId) public view returns(bytes32[] statuses) {\r\n        return rounds[_roundId].statusPossibility;\r\n    }\r\n\r\n    function extendRound(uint16 _roundId, uint _time) public onlyCLevel {\r\n        rounds[_roundId].expireAt = _time;\r\n    }\r\n\r\n    function getRoundBets(uint16 _roundId) public view returns(uint[] values) {\r\n        return roundBets[_roundId];\r\n    }\r\n\r\n    function updateRoundStatus(uint16 _id, RoundStatus _status) public onlyCLevel {\r\n        require(rounds[_id].status != RoundStatus.FINISHED);\r\n        emit RoundStatusUpdated(_id, rounds[_id].status, _status);\r\n        rounds[_id].status = _status;\r\n\r\n        if (_status == RoundStatus.CANCELLED) {\r\n            rounds[_id].finishedAt = now;\r\n        }\r\n    }\r\n\r\n    function setRoundFinalScore(uint16 _roundId, bytes32 _resultStatus) public\r\n    roundIsRunning(_roundId)\r\n    onlyCLevel\r\n    payable {\r\n        rounds[_roundId].status = RoundStatus.FINISHED;\r\n        rounds[_roundId].finishedAt = now;\r\n        rounds[_roundId].resultStatus = _resultStatus;\r\n\r\n        emit FinalScoreUpdated(_roundId, _resultStatus);\r\n    }\r\n\r\n    function bet(uint16 _roundId, bytes32 _status) public\r\n    roundIsRunning(_roundId)\r\n    greaterThan(msg.value, MINIMUM_BET_VALUE)\r\n    isNotExpired(_roundId)\r\n    payable {\r\n        Debug(_roundId, rounds[_roundId].expireAt, now, now >= rounds[_roundId].expireAt);\r\n        uint id = bets.push(Bet(_roundId, msg.sender, msg.value, _status, false)) - 1;\r\n        roundBets[_roundId].push(id);\r\n        rounds[_roundId].nbBets++;\r\n        rounds[_roundId].prizePool += msg.value;\r\n\r\n        emit BetPlaced(id, _roundId, msg.value);\r\n    }\r\n\r\n    function claimRoundReward(uint16 _roundId, address _owner) public roundIsFinish(_roundId) returns (uint rewardAfterFees, uint rewardFees) {\r\n        Round memory myRound = rounds[_roundId];\r\n        uint[] memory betIds = getRoundBets(_roundId);\r\n\r\n        uint totalRewardsOnBet = 0;\r\n        uint totalBetOnWinResult = 0;\r\n        uint amountBetOnResultForOwner = 0;\r\n        for (uint i = 0; i < betIds.length; i++) {\r\n            Bet storage bet = bets[betIds[i]];\r\n\r\n            if (bet.status == myRound.resultStatus) {\r\n                totalBetOnWinResult = SafeMath.add(totalBetOnWinResult, bet.amount);\r\n                if (bet.claimed == false && bet.owner == _owner) {\r\n                    amountBetOnResultForOwner = SafeMath.add(amountBetOnResultForOwner, bet.amount);\r\n                    bet.claimed = true;\r\n                }\r\n            } else {\r\n                totalRewardsOnBet = SafeMath.add(totalRewardsOnBet, bet.amount);\r\n            }\r\n        }\r\n\r\n        uint coef = 10000000; // Handle 4 numbers precision\r\n        uint percentOwnerReward = SafeMath.div(SafeMath.mul(amountBetOnResultForOwner, coef), totalBetOnWinResult);\r\n\r\n        uint rewardToOwner = SafeMath.div(SafeMath.mul(percentOwnerReward, totalRewardsOnBet), coef);\r\n        rewardAfterFees = SafeMath.div(SafeMath.mul(rewardToOwner, 90), 100);\r\n        rewardFees = SafeMath.sub(rewardToOwner, rewardAfterFees);\r\n        rewardAfterFees = SafeMath.add(rewardAfterFees, amountBetOnResultForOwner);\r\n\r\n        fees = SafeMath.add(fees, rewardFees);\r\n\r\n        _owner.transfer(rewardAfterFees);\r\n    }\r\n\r\n    function claimCancelled(uint16 _roundId, address _owner) public roundIsCancelled(_roundId) returns(uint amountToClaimBack) {\r\n        uint[] memory betIds = getRoundBets(_roundId);\r\n\r\n        amountToClaimBack = 0;\r\n        for (uint i = 0; i < betIds.length; i++) {\r\n            Bet storage bet = bets[betIds[i]];\r\n\r\n            if (bet.owner == _owner && bet.claimed != true) {\r\n                amountToClaimBack = SafeMath.add(amountToClaimBack, bet.amount);\r\n                bet.claimed = true;\r\n            }\r\n        }\r\n\r\n        _owner.transfer(amountToClaimBack);\r\n    }\r\n\r\n    function claimRewards(uint16[] _roundsToClaim, address _owner) public {\r\n        for (uint i = 0; i < _roundsToClaim.length; i++) {\r\n            claimRoundReward(_roundsToClaim[i], _owner);\r\n        }\r\n    }\r\n\r\n    function payout(address _to, uint _amount) public onlyOwner {\r\n        require(fees >= _amount);\r\n        fees = SafeMath.sub(fees, _amount);\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(msg.sender == ceoAddress || msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier greaterThan(uint _value, uint _expect) {\r\n        require(_value >= _expect);\r\n        _;\r\n    }\r\n\r\n    modifier isNotExpired(uint16 _roundId) {\r\n        require(rounds[_roundId].expireAt == 0 || now < rounds[_roundId].expireAt);\r\n        _;\r\n    }\r\n\r\n    modifier betStatusPossible(uint16 _roundId, bytes32 _status) {\r\n        //require(_status < rounds[_roundId].statusPossibility);\r\n        _;\r\n    }\r\n\r\n    modifier roundIsCancelled(uint16 _roundId) {\r\n        require(rounds[_roundId].status == RoundStatus.CANCELLED);\r\n        _;\r\n    }\r\n\r\n    modifier roundIsRunning(uint16 _roundId) {\r\n        require(rounds[_roundId].status == RoundStatus.RUNNING);\r\n        _;\r\n    }\r\n\r\n    modifier roundIsFinish(uint16 _roundId) {\r\n        require(rounds[_roundId].status == RoundStatus.FINISHED);\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint16\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"extendRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimumBetValue\",\"type\":\"uint256\"}],\"name\":\"setMinimumBetValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_statusPossibility\",\"type\":\"bytes32[]\"},{\"name\":\"_expireAt\",\"type\":\"uint256\"}],\"name\":\"createRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"roundId\",\"type\":\"uint16\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"bytes32\"},{\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCOOAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint16\"}],\"name\":\"getRoundStatuses\",\"outputs\":[{\"name\":\"statuses\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint16\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"claimRoundReward\",\"outputs\":[{\"name\":\"rewardAfterFees\",\"type\":\"uint256\"},{\"name\":\"rewardFees\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint16\"}],\"name\":\"getRoundBets\",\"outputs\":[{\"name\":\"values\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"nbBets\",\"type\":\"uint16\"},{\"name\":\"prizePool\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"resultStatus\",\"type\":\"bytes32\"},{\"name\":\"runningAt\",\"type\":\"uint256\"},{\"name\":\"finishedAt\",\"type\":\"uint256\"},{\"name\":\"expireAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint16\"},{\"name\":\"_status\",\"type\":\"bytes32\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundsToClaim\",\"type\":\"uint16[]\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCEOAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint16\"},{\"name\":\"_resultStatus\",\"type\":\"bytes32\"}],\"name\":\"setRoundFinalScore\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint16\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"claimCancelled\",\"outputs\":[{\"name\":\"amountToClaimBack\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint16\"},{\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"updateRoundStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_BET_VALUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint16\"}],\"name\":\"RoundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"oldStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"RoundStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"bytes32\"}],\"name\":\"FinalScoreUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"expire\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"condition\",\"type\":\"bool\"}],\"name\":\"Debug\",\"type\":\"event\"}]","ContractName":"Bet","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://75a23f5573fbd82ba1919ba647a92116ec7fe4a24c067b9951e650564fca2e3b"}]}