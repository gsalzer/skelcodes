{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n// We have to specify what version of compiler this code will compile with\r\n\r\n\r\ncontract MarbleEarth {\r\n\r\n\r\n  struct NewMoon {\r\n\r\n    uint timeAdded;\r\n    MoonType moonType;\r\n    uint64 votes;\r\n    mapping (address => bool) supportMap;\r\n\r\n  }\r\n\r\n\r\n  enum MoonType { Verification, Purge}\r\n\r\n  MRBLToken tokenContract;\r\n  VerificationMoon verificationContract;\r\n  PurgeMoon purgeContract;\r\n\r\n  address[] addresses;\r\n  bytes32[] identities;\r\n  mapping (address => bytes32) voterMap;\r\n\r\n  mapping (address => NewMoon) public proposedMoons;\r\n  address[] public proposedMoonsIndex;\r\n\r\n  address public verificationAddress;\r\n  address public purgeAddress;\r\n  address public tokenAddress;\r\n\r\n  address public lastVerified;\r\n\r\n//constructor\r\n\r\n  function MarbleEarth(address verificationMoon, address purgeMoon) public {\r\n\r\n    verificationMoon = verificationMoon;\r\n    purgeMoon = purgeMoon;\r\n\r\n  }\r\n\r\n  function proposeNewMoon(address mAddress, MoonType moonType) public  {\r\n    \r\n    if ((block.timestamp - proposedMoons[proposedMoonsIndex[0]].timeAdded) > 172800) {\r\n\r\n      delete proposedMoons[proposedMoonsIndex[0]];\r\n      delete proposedMoonsIndex[0];\r\n\r\n      }\r\n\r\n    if (proposedMoonsIndex.length >= 1000) {\r\n      return;\r\n      }\r\n\r\n      proposedMoons[mAddress] = NewMoon(block.timestamp, moonType, 1);\r\n      proposedMoonsIndex.push(mAddress);\r\n\r\n  }\r\n\r\n\r\n  function supportNewMoon(address newMoonAddress) public {\r\n\r\n    NewMoon storage newMoon = proposedMoons[newMoonAddress];\r\n\r\n    if (!newMoon.supportMap[msg.sender]) {\r\n      newMoon.supportMap[msg.sender] = true;\r\n      newMoon.votes++;\r\n      proposedMoons[newMoonAddress] = newMoon;\r\n    }\r\n\r\n    uint quotient = (newMoon.votes*100)/addresses.length;\r\n\r\n    if (quotient >= 67) {\r\n    \r\n      replaceNewMoon(newMoon, newMoonAddress);\r\n    }\r\n\r\n  }\r\n\r\n  function replaceNewMoon(NewMoon newMoon, address newMoonAddress) internal {\r\n\r\n      if (newMoon.moonType == MoonType.Verification) {\r\n       verificationAddress = newMoonAddress;\r\n      }\r\n\r\n      else if (newMoon.moonType == MoonType.Purge) {\r\n        purgeAddress = newMoonAddress;\r\n      }\r\n\r\n      delete proposedMoons[newMoonAddress]; \r\n\r\n  }\r\n\r\n  function proposePurge(address proposedAddress, bytes32 proof) public {\r\n\r\n    purgeContract = PurgeMoon(purgeAddress);\r\n    purgeContract.propose(proposedAddress, proof, addresses, identities);\r\n\r\n  }\r\n\r\n  function proposeVoter(bytes32 proof) public {\r\n\r\n    verificationContract = VerificationMoon(verificationAddress);\r\n    verificationContract.propose(msg.sender, proof, addresses, identities);\r\n\r\n  }\r\n\r\n  function addVoter(address voterAddress, address verifierAddress, bytes32 identity) public {\r\n    \r\n    if (msg.sender != verificationAddress)\r\n      return;\r\n\r\n    addresses.push(voterAddress);\r\n    identities.push(identity);\r\n    voterMap[voterAddress] = identity;\r\n\r\n    tokenContract = MRBLToken(tokenAddress);\r\n    tokenContract.transfer(voterAddress, newVoterAllocation());\r\n    tokenContract.transfer(verifierAddress, verifierAllocation());\r\n    lastVerified = voterAddress;\r\n\r\n  }\r\n\r\n  function getBalance() public returns (uint256) {\r\n        tokenContract = MRBLToken(tokenAddress);            \r\n        return tokenContract.getBalance(this);\r\n    }\r\n\r\n    function verifierAllocation() internal returns (uint) {\r\n     \r\n      uint contractBalance = getBalance();\r\n      return (-contractBalance*addresses.length/100000000000 + 2*contractBalance/10000000000)*1/5;\r\n\r\n    }\r\n\r\n  function newVoterAllocation() internal returns (uint) {\r\n            uint contractBalance = getBalance();\r\n           if (addresses.length < 1000000) {runLottery(contractBalance); }\r\n\r\n      return (-contractBalance*addresses.length/100000000000 + 2*contractBalance/10000000000)*4/5;\r\n\r\n  }\r\n\r\n  function runLottery(uint contractBalance) internal {\r\n\r\n            bytes32 blockHash = block.blockhash(block.number);\r\n            bytes32 randomHash = keccak256(lastVerified, blockHash);\r\n            uint hashNumber = uint(randomHash);\r\n     \r\n        if (addresses.length < 1000 && hashNumber < 2**246) {\r\n             tokenContract = MRBLToken(tokenAddress);\r\n             tokenContract.transfer(lastVerified, contractBalance/5);\r\n        }\r\n        else if (hashNumber < 2**236)  {\r\n             tokenContract = MRBLToken(tokenAddress);\r\n             tokenContract.transfer(lastVerified, contractBalance/5);\r\n       }\r\n\r\n  }\r\n\r\n  function purgeVoter(address purgedAddress, uint arrayIndex) public {\r\n    \r\n    if (msg.sender != purgeAddress)\r\n      return;\r\n\r\n    if (addresses[arrayIndex] != purgedAddress)\r\n      return;\r\n\r\n      delete addresses[arrayIndex];\r\n      delete identities[arrayIndex];\r\n      delete voterMap[purgedAddress];\r\n\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract VerificationMoon {\r\n  \r\n    struct NewVoter {\r\n\r\n\r\n      uint timeAdded;\r\n      uint64 votes;\r\n      bytes32 argument;\r\n      mapping (address => bool) supportMap;\r\n\r\n\r\n  }\r\n\r\n  address public marbleEarthAddress;\r\n  mapping (address => NewVoter) public proposedVoters;\r\n  uint16 public numberOfProposed;\r\n  address[] public voterAddresses;\r\n  bytes32[] public voterIdentities;\r\n\r\n  function propose(address selfProposed, bytes32 argument, address[] addresses, bytes32[] identities) public {\r\n\r\n    if (msg.sender != marbleEarthAddress)\r\n      return;\r\n\r\n    voterAddresses = addresses;\r\n    voterIdentities = identities;\r\n\r\n    if (addresses.length == 0) {\r\n        addVoter(selfProposed, selfProposed, argument);\r\n    }\r\n    else {\r\n\r\n    NewVoter memory newVoter;\r\n    newVoter.argument = argument;\r\n    newVoter.timeAdded = block.timestamp;\r\n    proposedVoters[selfProposed] = newVoter;\r\n\r\n    }\r\n\r\n  }\r\n\r\n  function addVoter(address verifiedAddress,address verifierAddress, bytes32 argument) internal {\r\n\r\n         MarbleEarth marbleEarth = MarbleEarth(marbleEarthAddress);\r\n         marbleEarth.addVoter(verifiedAddress, verifierAddress, argument);\r\n\r\n  }\r\n\r\n  function supportNewVoter(address _address) public {\r\n\r\n    if ((block.timestamp - proposedVoters[0].timeAdded) > 604800) {\r\n\r\n      delete proposedVoters[0];\r\n      numberOfProposed--;\r\n\r\n      }\r\n\r\n    if (numberOfProposed >= 1000) {\r\n\r\n      return;\r\n\r\n      }\r\n\r\n    if (!proposedVoters[_address].supportMap[msg.sender]) {\r\n      proposedVoters[_address].supportMap[msg.sender] = true;\r\n      proposedVoters[_address].votes++;\r\n      numberOfProposed++;\r\n\r\n    }\r\n\r\n    if (proposedVoters[_address].votes*100 / voterAddresses.length > 50) {\r\n\r\n        addVoter(_address, msg.sender, proposedVoters[_address].argument);\r\n        delete proposedVoters[_address];\r\n        numberOfProposed--;\r\n\r\n    }\r\n  }\r\n}\r\n\r\ncontract PurgeMoon {\r\n  \r\n    struct NewPurge {\r\n\r\n      uint timeAdded;\r\n      uint64 votes;\r\n      bytes32 argument;\r\n      mapping (address => bool) supportMap;\r\n\r\n  }\r\n\r\n  address public marbleEarthAddress;\r\n  mapping (address => NewPurge) public proposedPurges;\r\n  uint16 public numberOfProposed;\r\n  address[] public voterAddresses;\r\n  bytes32[] public voterIdentities;\r\n\r\n  function propose(address proposed, bytes32 argument, address[] addresses, bytes32[] identities) public {\r\n\r\n    if (msg.sender != marbleEarthAddress)\r\n      return;\r\n\r\n    voterAddresses = addresses;\r\n    voterIdentities = identities;\r\n\r\n    NewPurge memory newPurge;\r\n    newPurge.argument = argument;\r\n    newPurge.timeAdded = block.timestamp;\r\n    proposedPurges[proposed] = newPurge;\r\n\r\n  }\r\n\r\n  function purgeVoter(address purgedAddress, uint arrayIndex) internal {\r\n\r\n         MarbleEarth marbleEarth = MarbleEarth(marbleEarthAddress);\r\n         marbleEarth.purgeVoter(purgedAddress, arrayIndex);\r\n\r\n  }\r\n\r\n  function supportNewPurge(address _address, uint arrayIndex) public {\r\n\r\n    if ((block.timestamp - proposedPurges[0].timeAdded) > 604800) {\r\n\r\n      delete proposedPurges[0];\r\n      numberOfProposed--;\r\n\r\n      }\r\n\r\n    if (numberOfProposed >= 1000) {\r\n\r\n      return;\r\n\r\n      }\r\n\r\n    if (!proposedPurges[_address].supportMap[msg.sender]) {\r\n      proposedPurges[_address].supportMap[msg.sender] = true;\r\n      proposedPurges[_address].votes++;\r\n      numberOfProposed++;\r\n\r\n    }\r\n\r\n    if (proposedPurges[_address].votes*100 / voterAddresses.length > 50) {\r\n\r\n        purgeVoter(_address, arrayIndex);\r\n        delete proposedPurges[_address];\r\n        numberOfProposed--;\r\n\r\n    }\r\n  }\r\n}\r\n\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\ncontract MRBLToken {\r\n    string public name = \"Marble\";\r\n    string public symbol = \"MRBL\";\r\n    uint256 public decimals = 18;\r\n    uint256 public totalSupply = 100*1000*1000*1000*10**decimals;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    function MRBLToken() public {\r\n        balanceOf[msg.sender] = totalSupply;                \r\n    }\r\n\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0);\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    function getBalance(address _address) view public returns (uint256) {\r\n        return balanceOf[_address];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   \r\n        balanceOf[msg.sender] -= _value;            \r\n        totalSupply -= _value;                      \r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                \r\n        require(_value <= allowance[_from][msg.sender]);    \r\n        balanceOf[_from] -= _value;                         \r\n        allowance[_from][msg.sender] -= _value;             \r\n        totalSupply -= _value;                              \r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"MRBLToken","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1c569cc86cfdcf38cfad142f1e059c9121a04632f01550a18e2961d47785fe0e"}]}