{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\ncontract Trigonometry {\r\n\r\n    // Table index into the trigonometric table\r\n    uint constant INDEX_WIDTH = 4;\r\n    // Interpolation between successive entries in the tables\r\n    uint constant INTERP_WIDTH = 8;\r\n    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;\r\n    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;\r\n    uint16 constant ANGLES_IN_CYCLE = 16384;\r\n    uint16 constant QUADRANT_HIGH_MASK = 8192;\r\n    uint16 constant QUADRANT_LOW_MASK = 4096;\r\n    uint constant SINE_TABLE_SIZE = 16;\r\n\r\n    // constant sine lookup table generated by gen_tables.py\r\n    // We have no other choice but this since constant arrays don't yet exist\r\n    uint8 constant entry_bytes = 2;\r\n    bytes constant sin_table = \"\\x00\\x00\\x0c\\x8c\\x18\\xf9\\x25\\x28\\x30\\xfb\\x3c\\x56\\x47\\x1c\\x51\\x33\\x5a\\x82\\x62\\xf1\\x6a\\x6d\\x70\\xe2\\x76\\x41\\x7a\\x7c\\x7d\\x89\\x7f\\x61\\x7f\\xff\";\r\n\r\n    /**\r\n     * Convenience function to apply a mask on an integer to extract a certain\r\n     * number of bits. Using exponents since solidity still does not support\r\n     * shifting.\r\n     *\r\n     * @param _value The integer whose bits we want to get\r\n     * @param _width The width of the bits (in bits) we want to extract\r\n     * @param _offset The offset of the bits (in bits) we want to extract\r\n     * @return An integer containing _width bits of _value starting at the\r\n     *         _offset bit\r\n     */\r\n    function bits(uint _value, uint _width, uint _offset) pure internal returns (uint) {\r\n        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);\r\n    }\r\n\r\n    function sin_table_lookup(uint index) pure internal returns (uint16) {\r\n        bytes memory table = sin_table;\r\n        uint offset = (index + 1) * entry_bytes;\r\n        uint16 trigint_value;\r\n        assembly {\r\n            trigint_value := mload(add(table, offset))\r\n        }\r\n\r\n        return trigint_value;\r\n    }\r\n\r\n    /**\r\n     * Return the sine of an integer approximated angle as a signed 16-bit\r\n     * integer.\r\n     *\r\n     * @param _angle A 14-bit angle. This divides the circle into 16384\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The sine result as a number in the range -32767 to 32767.\r\n     */\r\n    function sin(uint16 _angle) public pure returns (int) {\r\n        uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);\r\n        uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);\r\n\r\n        bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;\r\n        bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;\r\n\r\n        if (!is_odd_quadrant) {\r\n            index = SINE_TABLE_SIZE - 1 - index;\r\n        }\r\n\r\n        uint x1 = sin_table_lookup(index);\r\n        uint x2 = sin_table_lookup(index + 1);\r\n        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);\r\n\r\n        int sine;\r\n        if (is_odd_quadrant) {\r\n            sine = int(x1) + int(approximation);\r\n        } else {\r\n            sine = int(x2) - int(approximation);\r\n        }\r\n\r\n        if (is_negative_quadrant) {\r\n            sine *= -1;\r\n        }\r\n\r\n        return sine;\r\n    }\r\n\r\n    /**\r\n     * Return the cos of an integer approximated angle.\r\n     * It functions just like the sin() method but uses the trigonometric\r\n     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.\r\n     */\r\n    function cos(uint16 _angle) public pure returns (int) {\r\n        if (_angle > ANGLES_IN_CYCLE - QUADRANT_LOW_MASK) {\r\n            _angle = QUADRANT_LOW_MASK - ANGLES_IN_CYCLE - _angle;\r\n        } else {\r\n            _angle += QUADRANT_LOW_MASK;\r\n        }\r\n        return sin(_angle);\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract VirusGame is Ownable, Trigonometry {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n    * Structs\r\n    */\r\n\r\n    struct Virus {\r\n        bytes32 name;\r\n        bytes32 parent;\r\n        uint256 potential;\r\n        uint256 infected;\r\n        uint256 infectedPayed;\r\n        uint256 infectedTriggle;\r\n        uint256 lastWithdraw;\r\n        uint256 lastInfected;\r\n        uint256 generation;\r\n        address owner;\r\n    }\r\n\r\n    /**\r\n    * State\r\n    */\r\n\r\n    uint256 nonce;\r\n\r\n    mapping (address => bytes32[]) public virusOwner;\r\n\r\n    mapping (bytes32 => Virus) public virus;\r\n\r\n    bytes32[] public virusHashes;\r\n\r\n    uint256 public totalPopulation;\r\n\r\n    uint256 public totalInfected;\r\n\r\n    bytes32 public genesisVirus;\r\n\r\n    uint256 public totalBalance;\r\n\r\n    uint256 public totalPayed;\r\n\r\n    /**\r\n    * Modifier\r\n    */\r\n\r\n    modifier useNonce() {\r\n        _;\r\n        nonce = nonce.add(1);\r\n    }\r\n\r\n    modifier healthyPeople() {\r\n        require(totalPopulation > totalInfected);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * Functions\r\n    */\r\n\r\n    event LogMutation(\r\n        bytes32 parentHash,\r\n        bytes32 virusHash\r\n    );\r\n\r\n    function mutate(bytes32 _virus, bytes32 _name) payable healthyPeople useNonce public {\r\n        // ensure parent virus exists\r\n        require(virus[_virus].owner != address(0));\r\n\r\n        uint costs = virus[_virus].generation.mul(0.001 ether).add(0.01 ether);\r\n        require(msg.value >= costs);\r\n\r\n        bytes32 newHash = keccak256(_virus, _name, nonce, msg.sender, now);\r\n\r\n        // new potential from virus hash to uint -> sinus or cosinus\r\n        int mutationFactor = sin(uint16(newHash));\r\n        uint uintFactor;\r\n        uint newPotential;\r\n\r\n        if (mutationFactor >= 0) {\r\n            uintFactor = uint(mutationFactor);\r\n            newPotential = virus[_virus].potential.mul(\r\n                uintFactor.mul(20).div(32767).add(100)\r\n            ).div(100);\r\n        } else {\r\n            uintFactor = uint(-mutationFactor);\r\n            newPotential = virus[_virus].potential.mul(\r\n                uintFactor.mul(20).div(32767).add(80)\r\n            ).div(100);\r\n        }\r\n\r\n        virus[newHash].name = _name;\r\n        virus[newHash].parent = _virus;\r\n        virus[newHash].generation = virus[_virus].generation.add(1);\r\n        virus[newHash].potential = newPotential;\r\n        virus[newHash].lastInfected = now;\r\n        virus[newHash].lastWithdraw = now;\r\n        virus[newHash].owner = msg.sender;\r\n\r\n        virusHashes.push(newHash);\r\n        virusOwner[msg.sender].push(newHash);\r\n\r\n        totalBalance = totalBalance.add(\r\n            costs.mul(9).div(10)\r\n        );\r\n\r\n        LogMutation(\r\n            _virus,\r\n            newHash\r\n        );\r\n    }\r\n\r\n    event LogInfection(\r\n        uint infected,\r\n        bytes32 virusHash\r\n    );\r\n\r\n    event LogEndOfWorld();\r\n\r\n    function infect(bytes32 _virus) healthyPeople public {\r\n        require(virus[_virus].owner == msg.sender);\r\n\r\n        // infectedTriggle + potential * delay = infected\r\n        uint delay = now.sub(virus[_virus].lastInfected);\r\n\r\n        uint infected = virus[_virus].infectedTriggle.add(\r\n            virus[_virus].potential.mul(delay).div(1 days)\r\n        );\r\n        \r\n        // infectedTriggle from parent must be set to x% of infected\r\n        virus[virus[_virus].parent].infectedTriggle = virus[virus[_virus].parent].infectedTriggle.add(\r\n            infected.div(10)\r\n        );\r\n\r\n        totalInfected = totalInfected.add(infected);\r\n        virus[_virus].infected = virus[_virus].infected.add(infected);\r\n\r\n        virus[_virus].lastInfected = now;\r\n        virus[_virus].infectedTriggle = 0;\r\n\r\n        LogInfection(\r\n            infected,\r\n            _virus\r\n        );\r\n\r\n        if (totalPopulation < totalInfected) {\r\n            totalInfected = totalPopulation;\r\n            LogEndOfWorld();\r\n        }\r\n    }\r\n\r\n    function withdraw(bytes32 _virus) public {\r\n        require(virus[_virus].owner == msg.sender);\r\n\r\n        // only withdraw once a day\r\n        require(now > (virus[_virus].lastWithdraw + 1 days));\r\n\r\n        // calculate ether\r\n        uint toBePayed = virus[_virus].infected.sub(virus[_virus].infectedPayed);\r\n        uint amount = totalBalance.div(totalInfected.sub(totalPayed)).mul(toBePayed);\r\n\r\n        require(amount <= totalBalance);\r\n\r\n        // subtract from total balance\r\n        totalBalance = totalBalance.sub(amount);\r\n        totalPayed = totalPayed.add(toBePayed);\r\n\r\n        // send ether\r\n        msg.sender.transfer(amount);\r\n\r\n        virus[_virus].infectedPayed = virus[_virus].infected;\r\n        virus[_virus].lastWithdraw = now;\r\n    }\r\n\r\n    function withdrawExcess(address _withdraw) onlyOwner public {\r\n        _withdraw.transfer(this.balance.sub(totalBalance));\r\n    }\r\n\r\n    /**\r\n    * Getters\r\n    */\r\n\r\n    function getVirusLength() public view returns(uint) {\r\n        return virusHashes.length;\r\n    }\r\n\r\n    function getOwnerVirusLength(address _owner) public view returns(uint) {\r\n        return virusOwner[_owner].length;\r\n    }\r\n\r\n    /**\r\n    * Constructor\r\n    */\r\n\r\n    function VirusGame() public {\r\n        totalPopulation = 7000000000;\r\n\r\n        genesisVirus = keccak256(\"Genesis\");\r\n\r\n        virus[genesisVirus].name = \"Genesis\";\r\n        virus[genesisVirus].potential = 100;\r\n        virus[genesisVirus].owner = msg.sender;\r\n        virus[genesisVirus].lastInfected = now;\r\n\r\n        virusOwner[msg.sender].push(genesisVirus);\r\n        virusHashes.push(genesisVirus);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalInfected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVirusLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPopulation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_angle\",\"type\":\"uint16\"}],\"name\":\"cos\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_virus\",\"type\":\"bytes32\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"mutate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_virus\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"virusHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdraw\",\"type\":\"address\"}],\"name\":\"withdrawExcess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_virus\",\"type\":\"bytes32\"}],\"name\":\"infect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPayed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genesisVirus\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"virus\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"parent\",\"type\":\"bytes32\"},{\"name\":\"potential\",\"type\":\"uint256\"},{\"name\":\"infected\",\"type\":\"uint256\"},{\"name\":\"infectedPayed\",\"type\":\"uint256\"},{\"name\":\"infectedTriggle\",\"type\":\"uint256\"},{\"name\":\"lastWithdraw\",\"type\":\"uint256\"},{\"name\":\"lastInfected\",\"type\":\"uint256\"},{\"name\":\"generation\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"virusOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_angle\",\"type\":\"uint16\"}],\"name\":\"sin\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwnerVirusLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"parentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"virusHash\",\"type\":\"bytes32\"}],\"name\":\"LogMutation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"infected\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virusHash\",\"type\":\"bytes32\"}],\"name\":\"LogInfection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogEndOfWorld\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"VirusGame","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a7967a9a75d26cc2134bf9586fc8719a023da87c2a549c0b68c69f2a343e2efc"}]}