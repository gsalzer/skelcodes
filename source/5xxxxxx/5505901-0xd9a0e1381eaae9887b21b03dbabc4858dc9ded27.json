{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/*\r\n*DivvyUp for Goo\r\n*\r\n* ====================================================================*\r\n*'||''|.    ||                                    '||'  '|'         \r\n* ||   ||  ...  .... ... .... ... .... ...      ,  ||    |  ... ... \r\n* ||    ||  ||   '|.  |   '|.  |   '|.  |  <>  /   ||    |   ||'  ||\r\n* ||    ||  ||    '|.|     '|.|     '|.|      /    ||    |   ||    |\r\n*.||...|'  .||.    '|       '|       '|      /      '|..'    ||...' \r\n*                                 .. |      /                ||     \r\n*                                  ''      /  <>            ''''    \r\n* =====================================================================*\r\n*\r\n* A wealth redistribution smart contract cleverly disguised as a ERC20 token.\r\n* Complete with a factory for making new verticals, and a fair launch contract\r\n* to ensure a fair launch.\r\n*\r\n*/\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint256);\r\n    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public returns (bool success);\r\n    function approve(address spender, uint256 tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public ownerCandidate;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        ownerCandidate = _newOwner;\r\n    }\r\n    \r\n    function acceptOwnership() public {\r\n        require(msg.sender == ownerCandidate);  \r\n        owner = ownerCandidate;\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract DivvyUpFactoryInterface {\r\n    function create(\r\n        bytes32 name, // Name of the DivvyUp\r\n        bytes32 symbol,  // ERC20 Symbol fo the DivvyUp\r\n        uint8 dividendDivisor, // Amount to divide incoming counter by as fees for dividens. Example: 3 for 33%, 10 for 10%, 100 for 1%\r\n        uint8 decimals, // Number of decimals the token has. Example: 18\r\n        uint256 initialPrice, // Starting price per token. Example: 0.0000001 ether\r\n        uint256 incrementPrice, // How much to increment the price by. Example: 0.00000001 ether\r\n        uint256 magnitude, //magnitude to multiply the fees by before distribution. Example: 2**64\r\n        address counter // The counter currency to accept. Example: 0x0 for ETH, otherwise the ERC20 token address.\r\n     )\r\n        public \r\n        returns(address);\r\n}\r\n\r\n\r\ncontract DivvyUpFactory is Owned {\r\n\r\n    event Create(\r\n        bytes32 name,\r\n        bytes32 symbol,\r\n        uint8 dividendDivisor,\r\n        uint8 decimals,\r\n        uint256 initialPrice,\r\n        uint256 incrementPrice,\r\n        uint256 magnitude,\r\n        address creator\r\n    );\r\n\r\n  \r\n    DivvyUp[] public registry;\r\n\r\n    function create(\r\n        bytes32 name, // Name of the DivvyUp\r\n        bytes32 symbol,  // ERC20 Symbol fo the DivvyUp\r\n        uint8 dividendDivisor, // Amount to divide incoming counter by as fees for dividens. Example: 3 for 33%, 10 for 10%, 100 for 1%\r\n        uint8 decimals, // Number of decimals the token has. Example: 18\r\n        uint256 initialPrice, // Starting price per token. Example: 0.0000001 ether\r\n        uint256 incrementPrice, // How much to increment the price by. Example: 0.00000001 ether\r\n        uint256 magnitude, //magnitude to multiply the fees by before distribution. Example: 2**64\r\n        address counter // The counter currency to accept. Example: 0x0 for ETH, otherwise the ERC20 token address.\r\n     )\r\n        public \r\n        returns(address)\r\n    {\r\n        DivvyUp divvyUp = new DivvyUp(name, symbol, dividendDivisor, decimals, initialPrice, incrementPrice, magnitude, counter);\r\n        divvyUp.changeOwner(msg.sender);\r\n        registry.push(divvyUp);\r\n        emit Create(name, symbol, dividendDivisor, decimals, initialPrice, incrementPrice, magnitude, msg.sender);\r\n        return divvyUp;\r\n    }\r\n\r\n    function die() onlyOwner public {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * Owner can transfer out any accidentally sent ERC20 tokens\r\n    * \r\n    * Implementation taken from ERC20 reference\r\n    * \r\n    */\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}\r\n\r\ncontract DivvyUpInterface{\r\n    function purchaseTokens()\r\n        public\r\n        payable\r\n        returns(uint256);\r\n\r\n    function purchaseTokensERC20(uint256 amount)\r\n        public\r\n        returns(uint256);\r\n}\r\n\r\ncontract DivvyUp is ERC20Interface, Owned, DivvyUpInterface {\r\n    using SafeMath for uint256;\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    // only people with tokens\r\n    modifier onlyTokenHolders() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n    \r\n    // only people with profits\r\n    modifier onlyDividendHolders() {\r\n        require(dividendDivisor > 0 && myDividends() > 0);\r\n        _;\r\n    }\r\n\r\n    modifier erc20Destination(){\r\n        require(counter != 0x0);\r\n        _;\r\n    }\r\n    \r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event Purchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingCounter,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event Sell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 counterEarned\r\n    );\r\n    \r\n    event Reinvestment(\r\n        address indexed customerAddress,\r\n        uint256 counterReinvested,\r\n        uint256 tokensMinted\r\n    );\r\n    \r\n    event Withdraw(\r\n        address indexed customerAddress,\r\n        uint256 counterWithdrawn\r\n    ); \r\n    \r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint8  public dividendDivisor;\r\n    uint8 public decimals;// = 18;\r\n    uint256 public tokenPriceInitial;// = 0.0000001 ether;\r\n    uint256 public tokenPriceIncremental;// = 0.00000001 ether;\r\n    uint256 public magnitude;// = 2**64;\r\n    address counter;\r\n\r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    // amount of tokens for each address\r\n    mapping(address => uint256) internal tokenBalanceLedger;\r\n    // amount of eth withdrawn\r\n    mapping(address => int256) internal payoutsTo;\r\n    // amount of tokens allowed to someone else \r\n    mapping(address => mapping(address => uint)) allowed;\r\n    // the actual amount of tokens\r\n    uint256 internal tokenSupply = 0;\r\n    // the amount of dividends per token\r\n    uint256 internal profitPerShare;\r\n    \r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /**\r\n    * -- APPLICATION ENTRY POINTS --  \r\n    */\r\n    function DivvyUp(bytes32 aName, bytes32 aSymbol, uint8 aDividendDivisor, uint8 aDecimals, uint256 aTokenPriceInitial, uint256 aTokenPriceIncremental, uint256 aMagnitude, address aCounter) \r\n    public {\r\n        require(aDividendDivisor < 100);\r\n        name = aName;\r\n        symbol = aSymbol;\r\n        dividendDivisor = aDividendDivisor;\r\n        decimals = aDecimals;\r\n        tokenPriceInitial = aTokenPriceInitial;\r\n        tokenPriceIncremental = aTokenPriceIncremental;\r\n        magnitude = aMagnitude;\r\n        counter = aCounter;    \r\n    }\r\n    \r\n    /**\r\n     * Allows the owner to change the name of the contract\r\n     */\r\n    function changeName(bytes32 newName) onlyOwner() public {\r\n        name = newName;\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Allows the owner to change the symbol of the contract\r\n     */\r\n    function changeSymbol(bytes32 newSymbol) onlyOwner() public {\r\n        symbol = newSymbol;\r\n    }\r\n    \r\n    /**\r\n     * Converts all incoming counter to tokens for the caller\r\n     */\r\n    function purchaseTokens()\r\n        public\r\n        payable\r\n        returns(uint256)\r\n    {\r\n        if(msg.value > 0){\r\n            require(counter == 0x0);\r\n        }\r\n        return purchaseTokens(msg.value);\r\n    }\r\n    \r\n\r\n    /**\r\n     * Converts all incoming counter to tokens for the caller\r\n     */\r\n    function purchaseTokensERC20(uint256 amount)\r\n        public\r\n        erc20Destination\r\n        returns(uint256)\r\n    {\r\n        require(ERC20Interface(counter).transferFrom(msg.sender, this, amount));\r\n        return purchaseTokens(amount);\r\n    }\r\n\r\n\r\n        /**\r\n     * Fallback function to handle counter that was send straight to the contract.\r\n     * Causes tokens to be purchased.\r\n     */\r\n    function()\r\n        payable\r\n        public\r\n    {\r\n        if(msg.value > 0){\r\n            require(counter == 0x0);\r\n        }\r\n        purchaseTokens(msg.value);\r\n    }\r\n    \r\n     \r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     */\r\n    function reinvestDividends()\r\n        onlyDividendHolders()\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // fetch dividends\r\n        uint256 dividends = myDividends(); \r\n       \r\n        // pay out the dividends virtually\r\n        address customerAddress = msg.sender;\r\n        payoutsTo[customerAddress] += (int256) (dividends * magnitude);\r\n        \r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\" if we have dividends\r\n        uint256 tokens = purchaseTokens(dividends);\r\n        \r\n        // fire event\r\n        emit Reinvestment(customerAddress, dividends, tokens);\r\n        \r\n        return tokens;\r\n    }\r\n    \r\n    /**\r\n     * Alias of sell() and withdraw().\r\n     */\r\n    function exit()\r\n        public\r\n    {\r\n        // get token count for caller & sell them all\r\n        address customerAddress = msg.sender;\r\n        uint256 tokens = tokenBalanceLedger[customerAddress];\r\n        if(tokens > 0) {\r\n            sell(tokens);\r\n        }\r\n        // lambo delivery service\r\n        withdraw();\r\n    }\r\n\r\n    /**\r\n     * Withdraws all of the callers earnings.\r\n     */\r\n    function withdraw()\r\n        onlyDividendHolders()\r\n        public\r\n    {\r\n        // setup data\r\n        address customerAddress = msg.sender;\r\n        uint256 dividends = myDividends(); \r\n\r\n        // update dividend tracker\r\n        payoutsTo[customerAddress] += (int256) (dividends * magnitude);\r\n                \r\n        // fire event\r\n        emit Withdraw(customerAddress, dividends);\r\n    }\r\n    \r\n    /**\r\n     * Liquifies tokens to counter.\r\n     */\r\n    function sell(uint256 amountOfTokens)\r\n        onlyTokenHolders()\r\n        public\r\n    {\r\n        require(amountOfTokens > 0);\r\n        // setup data\r\n        address customerAddress = msg.sender;\r\n        // russian hackers BTFO\r\n        require(amountOfTokens <= tokenBalanceLedger[customerAddress]);\r\n        uint256 tokens = amountOfTokens;\r\n        uint256 counterAmount = tokensToCounter(tokens);\r\n        uint256 dividends = dividendDivisor > 0 ? SafeMath.div(counterAmount, dividendDivisor) : 0;\r\n        uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\r\n        \r\n        // burn the sold tokens\r\n        tokenSupply = SafeMath.sub(tokenSupply, tokens);\r\n        tokenBalanceLedger[customerAddress] = SafeMath.sub(tokenBalanceLedger[customerAddress], tokens);\r\n        \r\n        // update dividends tracker\r\n        int256 updatedPayouts = (int256) (profitPerShare * tokens + (taxedCounter * magnitude));\r\n        payoutsTo[customerAddress] -= updatedPayouts;       \r\n        \r\n        // dividing by zero is a bad idea\r\n        if (tokenSupply > 0 && dividendDivisor > 0) {\r\n            // update the amount of dividends per token\r\n            profitPerShare = SafeMath.add(profitPerShare, (dividends * magnitude) / tokenSupply);\r\n        }\r\n        \r\n        // fire event\r\n        emit Sell(customerAddress, tokens, taxedCounter);\r\n    }\r\n    \r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     * Transfering ownership of tokens requires settling outstanding dividends\r\n     * and transfering them back. You can therefore send 0 tokens to this contract to\r\n     * trigger your withdraw.\r\n     */\r\n    function transfer(address toAddress, uint256 amountOfTokens)\r\n        onlyTokenHolders\r\n        public\r\n        returns(bool)\r\n    {\r\n\r\n       // Sell on transfer in instad of transfering to\r\n        if(toAddress == address(this)){\r\n            // If we sent in tokens, destroy them and credit their account with ETH\r\n            if(amountOfTokens > 0){\r\n                sell(amountOfTokens);\r\n            }\r\n            // Send them their ETH\r\n            withdraw();\r\n            // fire event\r\n            emit Transfer(0x0, msg.sender, amountOfTokens);\r\n\r\n            return true;\r\n        }\r\n       \r\n        // Deal with outstanding dividends first\r\n        if(myDividends() > 0) {\r\n            withdraw();\r\n        }\r\n        \r\n        return _transfer(toAddress, amountOfTokens);\r\n    }\r\n\r\n    function transferWithDividends(address toAddress, uint256 amountOfTokens) public onlyTokenHolders returns (bool) {\r\n        return _transfer(toAddress, amountOfTokens);\r\n    }\r\n\r\n    function _transfer(address toAddress, uint256 amountOfTokens)\r\n        internal\r\n        onlyTokenHolders\r\n        returns(bool)\r\n    {\r\n        // setup\r\n        address customerAddress = msg.sender;\r\n        \r\n        // make sure we have the requested tokens\r\n        require(amountOfTokens <= tokenBalanceLedger[customerAddress]);\r\n       \r\n        // exchange tokens\r\n        tokenBalanceLedger[customerAddress] = SafeMath.sub(tokenBalanceLedger[customerAddress], amountOfTokens);\r\n        tokenBalanceLedger[toAddress] = SafeMath.add(tokenBalanceLedger[toAddress], amountOfTokens);\r\n        \r\n        // fire event\r\n        emit Transfer(customerAddress, toAddress, amountOfTokens);\r\n\r\n\r\n        return true;\r\n       \r\n    }\r\n\r\n    // ERC20 \r\n\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * Transfer `tokens` from the `from` account to the `to` account\r\n    * \r\n    * The calling account must already have sufficient tokens approve(...)-d\r\n    * for spending from the `from` account and\r\n    * - From account must have sufficient balance to transfer\r\n    * - Spender must have sufficient allowance to transfer\r\n    * - 0 value transfers are allowed\r\n    * \r\n    * Implementation taken from ERC20 reference\r\n    * \r\n    */\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        tokenBalanceLedger[from] = tokenBalanceLedger[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        tokenBalanceLedger[to] = tokenBalanceLedger[to].add(tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Returns the amount of tokens approved by the owner that can be\r\n    * transferred to the spender's account\r\n    * \r\n    * Implementation taken from ERC20 reference\r\n    * \r\n    */\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    /**\r\n    * Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    * from the token owner's account. The `spender` contract function\r\n    * `receiveApproval(...)` is then executed\r\n    * \r\n    */\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current Counter stored in the contract\r\n     * Example: totalDestinationBalance()\r\n     */\r\n    function totalDestinationBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if(counter == 0x0){\r\n            return address(this).balance;\r\n        } else {\r\n            return ERC20Interface(counter).balanceOf(this);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the name of the token.\r\n     */\r\n    function name() \r\n        public \r\n        view \r\n        returns(bytes32)\r\n    {\r\n        return name;\r\n    }\r\n     \r\n\r\n    /**\r\n     * Retrieve the symbol of the token.\r\n     */\r\n    function symbol() \r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return symbol;\r\n    }\r\n     \r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenSupply;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address customerAddress = msg.sender;\r\n        return balanceOf(customerAddress);\r\n    }\r\n    \r\n    /**\r\n    * Retrieve the dividends owned by the caller.\r\n    */\r\n\r\n    function myDividends() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        address customerAddress = msg.sender;\r\n\r\n        return (uint256) ((int256)(profitPerShare * tokenBalanceLedger[customerAddress]) - payoutsTo[customerAddress]) / magnitude;\r\n    }\r\n    \r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger[customerAddress];\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Return the buy price of 1 individual token.\r\n     */\r\n    function sellPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if(tokenSupply == 0){\r\n            return tokenPriceInitial - tokenPriceIncremental;\r\n        } else {\r\n            uint256 counterAmount = tokensToCounter(1e18);\r\n            uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\r\n            uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\r\n            return taxedCounter;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Return the sell price of 1 individual token.\r\n     */\r\n    function buyPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if(tokenSupply == 0){\r\n            return tokenPriceInitial + tokenPriceIncremental;\r\n        } else {\r\n            uint256 counterAmount = tokensToCounter(1e18);\r\n            uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\r\n            uint256 taxedCounter = SafeMath.add(counterAmount, dividends);\r\n            return taxedCounter;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n     */\r\n    function calculateTokensReceived(uint256 counterToSpend) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        uint256 dividends = SafeMath.div(counterToSpend, dividendDivisor);\r\n        uint256 taxedCounter = SafeMath.sub(counterToSpend, dividends);\r\n        uint256 amountOfTokens = counterToTokens(taxedCounter);\r\n        \r\n        return amountOfTokens;\r\n    }\r\n    \r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n     */\r\n    function calculateCounterReceived(uint256 tokensToSell) \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        require(tokensToSell <= tokenSupply);\r\n        uint256 counterAmount = tokensToCounter(tokensToSell);\r\n        uint256 dividends = SafeMath.div(counterAmount, dividendDivisor);\r\n        uint256 taxedCounter = SafeMath.sub(counterAmount, dividends);\r\n        return taxedCounter;\r\n    }\r\n    \r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    function purchaseTokens(uint256 incomingCounter)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        if(incomingCounter == 0){\r\n            return reinvestDividends();\r\n        }\r\n\r\n\r\n        \r\n        // book keeping\r\n        address customerAddress = msg.sender;\r\n//     uint256 undividedDividends = dividendDivisor > 0 ? SafeMath.div(incomingCounter, dividendDivisor) : 0;\r\n//this was ref bonus \r\n        uint256 dividends = dividendDivisor > 0 ? SafeMath.div(incomingCounter, dividendDivisor) : 0;\r\n        uint256 taxedCounter = SafeMath.sub(incomingCounter, dividends);\r\n        uint256 amountOfTokens = counterToTokens(taxedCounter);\r\n        uint256 fee = dividends * magnitude;\r\n \r\n        // prevents overflow\r\n        assert(amountOfTokens > 0 && (SafeMath.add(amountOfTokens,tokenSupply) > tokenSupply));\r\n               \r\n        // Start making sure we can do the math. No token holders means no dividends, yet.\r\n        if(tokenSupply > 0){\r\n            \r\n            // add tokens to the pool\r\n            tokenSupply = SafeMath.add(tokenSupply, amountOfTokens);\r\n \r\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n            profitPerShare += (dividends * magnitude / (tokenSupply));\r\n            \r\n            // calculate the amount of tokens the customer receives \r\n            fee = dividendDivisor > 0 ? fee - (fee-(amountOfTokens * (dividends * magnitude / (tokenSupply)))) : 0x0;\r\n        \r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply = amountOfTokens;\r\n        }\r\n        \r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger[customerAddress] = SafeMath.add(tokenBalanceLedger[customerAddress], amountOfTokens);\r\n        \r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them\r\n        int256 updatedPayouts = (int256) ((profitPerShare * amountOfTokens) - fee);\r\n        payoutsTo[customerAddress] += updatedPayouts;\r\n        \r\n        // fire events\r\n        emit Purchase(customerAddress, incomingCounter, amountOfTokens);\r\n        emit Transfer(0x0, customerAddress, amountOfTokens);\r\n        return amountOfTokens;\r\n    }\r\n\r\n    /**\r\n     * Calculate Token price based on an amount of incoming counter\r\n     */\r\n    function counterToTokens(uint256 counterAmount)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 tokenPrice = tokenPriceInitial * 1e18;\r\n        uint256 tokensReceived = ((SafeMath.sub((sqrt((tokenPrice**2)+(2*(tokenPriceIncremental * 1e18)*(counterAmount * 1e18))+(((tokenPriceIncremental)**2)*(tokenSupply**2))+(2*(tokenPriceIncremental)*tokenPrice*tokenSupply))), tokenPrice))/(tokenPriceIncremental))-(tokenSupply);  \r\n        return tokensReceived;\r\n    }\r\n    \r\n    /**\r\n     * Calculate token sell value.\r\n     */\r\n    function tokensToCounter(uint256 tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 theTokens = (tokens + 1e18);\r\n        uint256 theTokenSupply = (tokenSupply + 1e18);\r\n        // underflow attempts BTFO\r\n        uint256 etherReceived = (SafeMath.sub((((tokenPriceInitial + (tokenPriceIncremental * (theTokenSupply/1e18)))-tokenPriceIncremental)*(theTokens - 1e18)),(tokenPriceIncremental*((theTokens**2-theTokens)/1e18))/2)/1e18);\r\n        return etherReceived;\r\n    }\r\n    \r\n    //This is where all your gas goes, sorry\r\n    //Not sorry, you probably only paid 1 gwei\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Owner can transfer out any accidentally sent ERC20 tokens\r\n    * \r\n    * Implementation taken from ERC20 reference\r\n    * \r\n    */\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        require(tokenAddress != counter);\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"counterToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceInitial\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"magnitude\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSymbol\",\"type\":\"bytes32\"}],\"name\":\"changeSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"purchaseTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transferWithDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newName\",\"type\":\"bytes32\"}],\"name\":\"changeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateCounterReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvestDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchaseTokensERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceIncremental\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDestinationBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"aName\",\"type\":\"bytes32\"},{\"name\":\"aSymbol\",\"type\":\"bytes32\"},{\"name\":\"aDividendDivisor\",\"type\":\"uint8\"},{\"name\":\"aDecimals\",\"type\":\"uint8\"},{\"name\":\"aTokenPriceInitial\",\"type\":\"uint256\"},{\"name\":\"aTokenPriceIncremental\",\"type\":\"uint256\"},{\"name\":\"aMagnitude\",\"type\":\"uint256\"},{\"name\":\"aCounter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingCounter\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"counterEarned\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"counterReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"Reinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"counterWithdrawn\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"DivvyUp","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"476f6f4469766964656e647300000000000000000000000000000000000000004744495600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000008ac7230489e80000000000000000000000000000000000000000000000000000001ff973cafa800000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://826f821a8b2d966aaba3cc8dc878a09c5face8658dd30792c6bf9b820193a875"}]}