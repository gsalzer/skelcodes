{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract AtomicTokenSwap {\r\n    struct Swap {\r\n        uint expiration;\r\n        address initiator;\r\n        address participant;\r\n        address token;\r\n        uint256 value;\r\n        bool exists;\r\n    }\r\n\r\n    // maps the bytes20 hash to a swap    \r\n    mapping(address => mapping(bytes20 => Swap)) public swaps;\r\n    \r\n    // creates a new swap\r\n    function initiate(uint _expiration, bytes20 _hash, address _participant, address _token, uint256 _value) public {\r\n        Swap storage s = swaps[_participant][_hash];\r\n        \r\n        // make sure you aren't overwriting a pre-existing swap\r\n        // (so the original initiator can't rewrite the terms)\r\n        require(s.exists == false);\r\n\r\n        // require that the sender has allowed the tokens to be withdrawn from their account\r\n        ERC20 token = ERC20(_token);\r\n        require(token.allowance(msg.sender, this) == _value);\r\n        token.transferFrom(msg.sender, this, _value);\r\n\r\n        // create the new swap\r\n        swaps[_participant][_hash] = Swap(_expiration, msg.sender, _participant, _token, _value, true);\r\n    }\r\n    \r\n    function redeem(bytes32 _secret) public {\r\n        // get a swap from the mapping. we can do it directly because there is no way to \r\n        // fake the secret.\r\n        bytes20 hash = ripemd160(_secret);\r\n        Swap storage s = swaps[msg.sender][hash];\r\n        \r\n        // make sure it's the right sender\r\n        require(msg.sender == s.participant);\r\n        // make sure the swap did not expire already\r\n        require(now < s.expiration);\r\n        // make sure the swap was not redeemed or refunded\r\n        require(s.exists);\r\n        // clean up and send\r\n        s.exists = false;\r\n        ERC20 token = ERC20(s.token);\r\n        token.transfer(msg.sender, s.value);\r\n    }\r\n    \r\n    function refund(bytes20 _hash, address _participant) public {\r\n        Swap storage s = swaps[_participant][_hash];\r\n        require(now > s.expiration);\r\n        require(msg.sender == s.initiator);\r\n        // make sure the swap was not redeemed or refunded\r\n        require(s.exists);\r\n\r\n        s.exists = false;\r\n        ERC20 token = ERC20(s.token);\r\n        token.transfer(msg.sender, s.value);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_expiration\",\"type\":\"uint256\"},{\"name\":\"_hash\",\"type\":\"bytes20\"},{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"initiate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes20\"}],\"name\":\"swaps\",\"outputs\":[{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"initiator\",\"type\":\"address\"},{\"name\":\"participant\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes20\"},{\"name\":\"_participant\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AtomicTokenSwap","CompilerVersion":"v0.4.20-nightly.2018.1.6+commit.2548228b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f59c26686c9a5a49e7c3fae72694f97786c13d655fff07feff1bcbff09981f8f"}]}