{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.15;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n}\r\n\r\n/// @title Token contract - Implements Standard Token Interface with DNN features.\r\n/// @author Dondrey Taylor - <dondrey@dnn.media>\r\ncontract DNNToken is StandardToken {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    ////////////////////////////////////////////////////////////\r\n    // Used to indicate which allocation we issue tokens from //\r\n    ////////////////////////////////////////////////////////////\r\n    enum DNNSupplyAllocations {\r\n        EarlyBackerSupplyAllocation,\r\n        PRETDESupplyAllocation,\r\n        TDESupplyAllocation,\r\n        BountySupplyAllocation,\r\n        WriterAccountSupplyAllocation,\r\n        AdvisorySupplyAllocation,\r\n        PlatformSupplyAllocation\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////\r\n    // Smart-Contract with permission to allocate tokens from supplies //\r\n    /////////////////////////////////////////////////////////////////////\r\n    address public allocatorAddress;\r\n    address public crowdfundContract;\r\n\r\n    /////////////////////\r\n    // Token Meta Data //\r\n    /////////////////////\r\n    string constant public name = \"DNN\";\r\n    string constant public symbol = \"DNN\";\r\n    uint8 constant public decimals = 18; // 1 DNN = 1 * 10^18 atto-DNN\r\n\r\n    /////////////////////////////////////////\r\n    // Addresses of the co-founders of DNN //\r\n    /////////////////////////////////////////\r\n    address public cofounderA;\r\n    address public cofounderB;\r\n\r\n    /////////////////////////\r\n    // Address of Platform //\r\n    /////////////////////////\r\n    address public platform;\r\n\r\n    /////////////////////////////////////////////\r\n    // Token Distributions (% of total supply) //\r\n    /////////////////////////////////////////////\r\n    uint256 public earlyBackerSupply; // 10%\r\n    uint256 public PRETDESupply; // 10%\r\n    uint256 public TDESupply; // 40%\r\n    uint256 public bountySupply; // 1%\r\n    uint256 public writerAccountSupply; // 4%\r\n    uint256 public advisorySupply; // 14%\r\n    uint256 public cofoundersSupply; // 10%\r\n    uint256 public platformSupply; // 11%\r\n\r\n    uint256 public earlyBackerSupplyRemaining; // 10%\r\n    uint256 public PRETDESupplyRemaining; // 10%\r\n    uint256 public TDESupplyRemaining; // 40%\r\n    uint256 public bountySupplyRemaining; // 1%\r\n    uint256 public writerAccountSupplyRemaining; // 4%\r\n    uint256 public advisorySupplyRemaining; // 14%\r\n    uint256 public cofoundersSupplyRemaining; // 10%\r\n    uint256 public platformSupplyRemaining; // 11%\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n    // Amount of CoFounder Supply that has been distributed based on vesting schedule //\r\n    ////////////////////////////////////////////////////////////////////////////////////\r\n    uint256 public cofoundersSupplyVestingTranches = 10;\r\n    uint256 public cofoundersSupplyVestingTranchesIssued = 0;\r\n    uint256 public cofoundersSupplyVestingStartDate; // Epoch\r\n    uint256 public cofoundersSupplyDistributed = 0;  // # of atto-DNN distributed to founders\r\n\r\n    //////////////////////////////////////////////\r\n    // Prevents tokens from being transferrable //\r\n    //////////////////////////////////////////////\r\n    bool public tokensLocked = true;\r\n\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    // Event triggered when tokens are transferred from one address to another //\r\n    /////////////////////////////////////////////////////////////////////////////\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    ////////////////////////////////////////////////////////////\r\n    // Checks if tokens can be issued to founder at this time //\r\n    ////////////////////////////////////////////////////////////\r\n    modifier CofoundersTokensVested()\r\n    {\r\n        // Make sure that a starting vesting date has been set and 4 weeks have passed since vesting date\r\n        require (cofoundersSupplyVestingStartDate != 0 && (now-cofoundersSupplyVestingStartDate) >= 4 weeks);\r\n\r\n        // Get current tranche based on the amount of time that has passed since vesting start date\r\n        uint256 currentTranche = now.sub(cofoundersSupplyVestingStartDate) / 4 weeks;\r\n\r\n        // Amount of tranches that have been issued so far\r\n        uint256 issuedTranches = cofoundersSupplyVestingTranchesIssued;\r\n\r\n        // Amount of tranches that cofounders are entitled to\r\n        uint256 maxTranches = cofoundersSupplyVestingTranches;\r\n\r\n        // Make sure that we still have unvested tokens and that\r\n        // the tokens for the current tranche have not been issued.\r\n        require (issuedTranches != maxTranches && currentTranche > issuedTranches);\r\n\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    // Checks if tokens are unlocked //\r\n    ///////////////////////////////////\r\n    modifier TokensUnlocked()\r\n    {\r\n        require (tokensLocked == false);\r\n        _;\r\n    }\r\n\r\n    /////////////////////////////////\r\n    // Checks if tokens are locked //\r\n    /////////////////////////////////\r\n    modifier TokensLocked()\r\n    {\r\n       require (tokensLocked == true);\r\n       _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounders are performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounders()\r\n    {\r\n        require (msg.sender == cofounderA || msg.sender == cofounderB);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounder A is performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounderA()\r\n    {\r\n        require (msg.sender == cofounderA);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    // Checks if CoFounder B is performing the action //\r\n    ////////////////////////////////////////////////////\r\n    modifier onlyCofounderB()\r\n    {\r\n        require (msg.sender == cofounderB);\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////\r\n    // Checks if Allocator is performing the action //\r\n    //////////////////////////////////////////////////\r\n    modifier onlyAllocator()\r\n    {\r\n        require (msg.sender == allocatorAddress);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////\r\n    // Checks if Crowdfund Contract is performing the action //\r\n    ///////////////////////////////////////////////////////////\r\n    modifier onlyCrowdfundContract()\r\n    {\r\n        require (msg.sender == crowdfundContract);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    // Checks if Crowdfund Contract, Platform, or Allocator is performing the action //\r\n    ///////////////////////////////////////////////////////////////////////////////////\r\n    modifier onlyAllocatorOrCrowdfundContractOrPlatform()\r\n    {\r\n        require (msg.sender == allocatorAddress || msg.sender == crowdfundContract || msg.sender == platform);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    //  @des Function to change address that is manage platform holding  //\r\n    //  @param newAddress Address of new issuance contract.              //\r\n    ///////////////////////////////////////////////////////////////////////\r\n    function changePlatform(address newAddress)\r\n        onlyCofounders\r\n    {\r\n        platform = newAddress;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //  @des Function to change address that is allowed to do token issuance. Crowdfund contract can only be set once.   //\r\n    //  @param newAddress Address of new issuance contract.                                                              //\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function changeCrowdfundContract(address newAddress)\r\n        onlyCofounders\r\n    {\r\n        crowdfundContract = newAddress;\r\n    }\r\n\r\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //  @des Function to change address that is allowed to do token issuance. Allocator can only be set once.  //\r\n    //  @param newAddress Address of new issuance contract.                                                    //\r\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function changeAllocator(address newAddress)\r\n        onlyCofounders\r\n    {\r\n        allocatorAddress = newAddress;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////\r\n    //  @des Function to change founder A address.       //\r\n    //  @param newAddress Address of new founder A.      //\r\n    ///////////////////////////////////////////////////////\r\n    function changeCofounderA(address newAddress)\r\n        onlyCofounderA\r\n    {\r\n        cofounderA = newAddress;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    //  @des Function to change founder B address.      //\r\n    //  @param newAddress Address of new founder B.     //\r\n    //////////////////////////////////////////////////////\r\n    function changeCofounderB(address newAddress)\r\n        onlyCofounderB\r\n    {\r\n        cofounderB = newAddress;\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////\r\n    // Transfers tokens from senders address to another address //\r\n    //////////////////////////////////////////////////////////////\r\n    function transfer(address _to, uint256 _value)\r\n      TokensUnlocked\r\n      returns (bool)\r\n    {\r\n          Transfer(msg.sender, _to, _value);\r\n          return BasicToken.transfer(_to, _value);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////\r\n    // Transfers tokens from one address to another address //\r\n    //////////////////////////////////////////////////////////\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n      TokensUnlocked\r\n      returns (bool)\r\n    {\r\n          Transfer(_from, _to, _value);\r\n          return StandardToken.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////\r\n    //  @des Cofounders issue tokens to themsleves if within vesting period. Returns success.    //\r\n    //  @param beneficiary Address of receiver.                                                  //\r\n    //  @param tokenCount Number of tokens to issue.                                             //\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////\r\n    function issueCofoundersTokensIfPossible()\r\n        onlyCofounders\r\n        CofoundersTokensVested\r\n        returns (bool)\r\n    {\r\n        // Compute total amount of vested tokens to issue\r\n        uint256 tokenCount = cofoundersSupply.div(cofoundersSupplyVestingTranches);\r\n\r\n        // Make sure that there are cofounder tokens left\r\n        if (tokenCount > cofoundersSupplyRemaining) {\r\n           return false;\r\n        }\r\n\r\n        // Decrease cofounders supply\r\n        cofoundersSupplyRemaining = cofoundersSupplyRemaining.sub(tokenCount);\r\n\r\n        // Update how many tokens have been distributed to cofounders\r\n        cofoundersSupplyDistributed = cofoundersSupplyDistributed.add(tokenCount);\r\n\r\n        // Split tokens between both founders\r\n        balances[cofounderA] = balances[cofounderA].add(tokenCount.div(2));\r\n        balances[cofounderB] = balances[cofounderB].add(tokenCount.div(2));\r\n\r\n        // Update that a tranche has been issued\r\n        cofoundersSupplyVestingTranchesIssued += 1;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    //////////////////\r\n    // Issue tokens //\r\n    //////////////////\r\n    function issueTokens(address beneficiary, uint256 tokenCount, DNNSupplyAllocations allocationType)\r\n      onlyAllocatorOrCrowdfundContractOrPlatform\r\n      returns (bool)\r\n    {\r\n        // We'll use the following to determine whether the allocator, platform,\r\n        // or the crowdfunding contract can allocate specified supply\r\n        bool canAllocatorPerform = msg.sender == allocatorAddress;\r\n        bool canCrowdfundContractPerform = msg.sender == crowdfundContract;\r\n        bool canPlatformPerform = msg.sender == platform;\r\n\r\n        // Early Backers\r\n        if (canAllocatorPerform && allocationType == DNNSupplyAllocations.EarlyBackerSupplyAllocation && tokenCount <= earlyBackerSupplyRemaining) {\r\n            earlyBackerSupplyRemaining = earlyBackerSupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // PRE-TDE\r\n        else if (canCrowdfundContractPerform && msg.sender == crowdfundContract && allocationType == DNNSupplyAllocations.PRETDESupplyAllocation) {\r\n\r\n              // Check to see if we have enough tokens to satisfy this purchase\r\n              // using just the pre-tde.\r\n              if (PRETDESupplyRemaining >= tokenCount) {\r\n\r\n                    // Decrease pre-tde supply\r\n                    PRETDESupplyRemaining = PRETDESupplyRemaining.sub(tokenCount);\r\n              }\r\n\r\n              // Check to see if we can satisfy this using pre-tde and tde supply combined\r\n              else if (PRETDESupplyRemaining+TDESupplyRemaining >= tokenCount) {\r\n\r\n                    // Decrease tde supply\r\n                    TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount-PRETDESupplyRemaining);\r\n\r\n                    // Decrease pre-tde supply by its' remaining tokens\r\n                    PRETDESupplyRemaining = 0;\r\n              }\r\n\r\n              // Otherwise, we can't satisfy this sale because we don't have enough tokens.\r\n              else {\r\n                  return false;\r\n              }\r\n        }\r\n\r\n        // TDE\r\n        else if (canCrowdfundContractPerform && allocationType == DNNSupplyAllocations.TDESupplyAllocation && tokenCount <= TDESupplyRemaining) {\r\n            TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // Bounty\r\n        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.BountySupplyAllocation && tokenCount <= bountySupplyRemaining) {\r\n            bountySupplyRemaining = bountySupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // Writer Accounts\r\n        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.WriterAccountSupplyAllocation && tokenCount <= writerAccountSupplyRemaining) {\r\n            writerAccountSupplyRemaining = writerAccountSupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // Advisory\r\n        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.AdvisorySupplyAllocation && tokenCount <= advisorySupplyRemaining) {\r\n            advisorySupplyRemaining = advisorySupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        // Platform (Also makes sure that the beneficiary is the platform address specified in this contract)\r\n        else if (canPlatformPerform && allocationType == DNNSupplyAllocations.PlatformSupplyAllocation && tokenCount <= platformSupplyRemaining) {\r\n            platformSupplyRemaining = platformSupplyRemaining.sub(tokenCount);\r\n        }\r\n\r\n        else {\r\n            return false;\r\n        }\r\n\r\n        // Transfer tokens\r\n        Transfer(address(this), beneficiary, tokenCount);\r\n\r\n        // Credit tokens to the address specified\r\n        balances[beneficiary] = balances[beneficiary].add(tokenCount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /////////////////////////////////////////////////\r\n    // Transfer Unsold tokens from TDE to Platform //\r\n    /////////////////////////////////////////////////\r\n    function sendUnsoldTDETokensToPlatform()\r\n      external\r\n      onlyCrowdfundContract\r\n    {\r\n        // Make sure we have tokens to send from TDE\r\n        if (TDESupplyRemaining > 0) {\r\n\r\n            // Add remaining tde tokens to platform remaining tokens\r\n            platformSupplyRemaining = platformSupplyRemaining.add(TDESupplyRemaining);\r\n\r\n            // Clear remaining tde token count\r\n            TDESupplyRemaining = 0;\r\n        }\r\n    }\r\n\r\n    /////////////////////////////////////////////////////\r\n    // Transfer Unsold tokens from pre-TDE to Platform //\r\n    /////////////////////////////////////////////////////\r\n    function sendUnsoldPRETDETokensToTDE()\r\n      external\r\n      onlyCrowdfundContract\r\n    {\r\n          // Make sure we have tokens to send from pre-TDE\r\n          if (PRETDESupplyRemaining > 0) {\r\n\r\n              // Add remaining pre-tde tokens to tde remaining tokens\r\n              TDESupplyRemaining = TDESupplyRemaining.add(PRETDESupplyRemaining);\r\n\r\n              // Clear remaining pre-tde token count\r\n              PRETDESupplyRemaining = 0;\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    // @des Allows tokens to be transferrable. Returns lock state //\r\n    ////////////////////////////////////////////////////////////////\r\n    function unlockTokens()\r\n        external\r\n        onlyCrowdfundContract\r\n    {\r\n        // Make sure tokens are currently locked before proceeding to unlock them\r\n        require(tokensLocked == true);\r\n\r\n        tokensLocked = false;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    //  @des Contract constructor function sets initial token balances.  //\r\n    ///////////////////////////////////////////////////////////////////////\r\n    function DNNToken()\r\n    {\r\n          // Start date\r\n          uint256 vestingStartDate = 1526072145;\r\n\r\n          // Set cofounder addresses\r\n          cofounderA = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;\r\n          cofounderB = 0x9FFE2aD5D76954C7C25be0cEE30795279c4Cab9f;\r\n\r\n          // Sets platform address\r\n          platform = address(this);\r\n\r\n          // Set total supply - 1 Billion DNN Tokens = (1,000,000,000 * 10^18) atto-DNN\r\n          // 1 DNN = 10^18 atto-DNN\r\n          totalSupply = uint256(1000000000).mul(uint256(10)**decimals);\r\n\r\n          // Set Token Distributions (% of total supply)\r\n          earlyBackerSupply = totalSupply.mul(10).div(100); // 10%\r\n          PRETDESupply = totalSupply.mul(10).div(100); // 10%\r\n          TDESupply = totalSupply.mul(40).div(100); // 40%\r\n          bountySupply = totalSupply.mul(1).div(100); // 1%\r\n          writerAccountSupply = totalSupply.mul(4).div(100); // 4%\r\n          advisorySupply = totalSupply.mul(14).div(100); // 14%\r\n          cofoundersSupply = totalSupply.mul(10).div(100); // 10%\r\n          platformSupply = totalSupply.mul(11).div(100); // 11%\r\n\r\n          // Set each remaining token count equal to its' respective supply\r\n          earlyBackerSupplyRemaining = earlyBackerSupply;\r\n          PRETDESupplyRemaining = PRETDESupply;\r\n          TDESupplyRemaining = TDESupply;\r\n          bountySupplyRemaining = bountySupply;\r\n          writerAccountSupplyRemaining = writerAccountSupply;\r\n          advisorySupplyRemaining = advisorySupply;\r\n          cofoundersSupplyRemaining = cofoundersSupply;\r\n          platformSupplyRemaining = platformSupply;\r\n\r\n          // Sets cofounder vesting start date (Ensures that it is a date in the future, otherwise it will default to now)\r\n          cofoundersSupplyVestingStartDate = vestingStartDate >= now ? vestingStartDate : now;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cofoundersSupplyRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"writerAccountSupplyRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofoundersSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRETDESupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofoundersSupplyVestingTranches\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"name\":\"allocationType\",\"type\":\"uint8\"}],\"name\":\"issueTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofoundersSupplyVestingStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyBackerSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformSupplyRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofoundersSupplyVestingTranchesIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platform\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofounderB\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeCrowdfundContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TDESupplyRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendUnsoldTDETokensToPlatform\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofoundersSupplyDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeCofounderA\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changePlatform\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeCofounderB\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"issueCofoundersTokensIfPossible\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocatorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorySupplyRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeAllocator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"writerAccountSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdfundContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRETDESupplyRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendUnsoldPRETDETokensToTDE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountySupplyRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cofounderA\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TDESupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyBackerSupplyRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"DNNToken","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://291fe9bc7632c9fbc23aaba2993c1ac185ca9f127b731d8dd0df8c793f9a8b52"}]}