{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract Asset is DSMath, ERC20Interface {\r\n\r\n    // DATA STRUCTURES\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public _totalSupply;\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n     * @notice Send `_value` tokens to `_to` from `msg.sender`\r\n     * @dev Transfers sender's tokens to a given address\r\n     * @dev Similar to transfer(address, uint, bytes), but without _data parameter\r\n     * @param _to Address of token receiver\r\n     * @param _value Number of tokens to transfer\r\n     * @return Returns success of function call\r\n     */\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(balances[msg.sender] >= _value); // sanity checks\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] = sub(balances[msg.sender], _value);\r\n        balances[_to] = add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    /// @notice Restriction: An account can only use this function to send to itself\r\n    /// @dev Allows for an approved third party to transfer tokens from one\r\n    /// address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n        // require(_to == msg.sender); // can only use transferFrom to send to self\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint _value) public returns (bool) {\r\n        require(_spender != address(0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @dev Returns number of allowed tokens that a spender can transfer on\r\n    /// behalf of a token owner.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    /// @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by the given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns balance of owner.\r\n    function balanceOf(address _owner) constant public returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function totalSupply() view public returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ninterface RiskMgmtInterface {\r\n\r\n    // METHODS\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks if the makeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If makeOrder is permitted\r\n    function isMakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n\r\n    /// @notice Checks if the takeOrder price is reasonable and not manipulative\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If takeOrder is permitted\r\n    function isTakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    ) view returns (bool);\r\n}\r\n\r\ncontract RMMakeOrders is DSMath, RiskMgmtInterface {\r\n\r\n    // FIELDS\r\n\r\n    uint public constant RISK_LEVEL = 10 ** uint256(17); // Allows 10 percent deviation from referencePrice; 10 percent is expressed as 0.1 * 10 ** 18\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    /// @notice Checks if the makeOrder price is within maximum allowed deviation from reference price\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If makeOrder is permitted\r\n    function isMakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        view\r\n        returns (bool)\r\n    {\r\n        // Makes sure difference between orderPrice and referencePrice is less than or equal to maximum allowed deviation\r\n        if (orderPrice < sub(referencePrice, wmul(RISK_LEVEL, referencePrice))) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @notice Checks if the takeOrder price is within maximum allowed deviation from reference price\r\n    /// @param orderPrice Price of Order\r\n    /// @param referencePrice Reference price obtained through PriceFeed contract\r\n    /// @param sellAsset Asset (as registered in Asset registrar) to be sold\r\n    /// @param buyAsset Asset (as registered in Asset registrar) to be bought\r\n    /// @param sellQuantity Quantity of sellAsset to be sold\r\n    /// @param buyQuantity Quantity of buyAsset to be bought\r\n    /// @return If takeOrder is permitted\r\n    function isTakePermitted(\r\n        uint orderPrice,\r\n        uint referencePrice,\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        view\r\n        returns (bool)\r\n    {\r\n        // Makes sure difference between orderPrice and referencePrice is less than or equal to maximum allowed deviation\r\n        if (orderPrice < sub(referencePrice, wmul(RISK_LEVEL, referencePrice))) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"RISK_LEVEL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderPrice\",\"type\":\"uint256\"},{\"name\":\"referencePrice\",\"type\":\"uint256\"},{\"name\":\"sellAsset\",\"type\":\"address\"},{\"name\":\"buyAsset\",\"type\":\"address\"},{\"name\":\"sellQuantity\",\"type\":\"uint256\"},{\"name\":\"buyQuantity\",\"type\":\"uint256\"}],\"name\":\"isMakePermitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"orderPrice\",\"type\":\"uint256\"},{\"name\":\"referencePrice\",\"type\":\"uint256\"},{\"name\":\"sellAsset\",\"type\":\"address\"},{\"name\":\"buyAsset\",\"type\":\"address\"},{\"name\":\"sellQuantity\",\"type\":\"uint256\"},{\"name\":\"buyQuantity\",\"type\":\"uint256\"}],\"name\":\"isTakePermitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RMMakeOrders","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://46e2a5fb90029f8b27bbb7fed99eec0dc51da7eaa4a98679849732fdc80cccc3"}]}