{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n/*\r\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\r\n * participate, they get the jackpot: 7 times the price of their bet.\r\n * Of course one address can only win once. The owner regularly reseeds the secret\r\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\r\n * just wait for a reseed and try again!\r\n *\r\n * Jackpot chance:   1 in 8\r\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\r\n * Jackpot size: 7 times the ticket price\r\n *\r\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\r\n * Keep in mind that your address can only win once\r\n *\r\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\r\n*/\r\n\r\ncontract OpenAddressLottery{\r\n    struct SeedComponents{\r\n        uint component1;\r\n        uint component2;\r\n        uint component3;\r\n        uint component4;\r\n    }\r\n    \r\n    address owner; //address of the owner\r\n    uint private secretSeed; //seed used to calculate number of an address\r\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\r\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\r\n        \r\n    mapping (address => bool) winner; //keeping track of addresses that have already won\r\n    \r\n    function OpenAddressLottery() {\r\n        owner = msg.sender;\r\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\r\n    }\r\n    \r\n    function participate() payable {\r\n        // make sure he hasn't won already\r\n        require(winner[msg.sender] == false);\r\n        \r\n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\r\n            winner[msg.sender] = true; // every address can only win once\r\n            \r\n            uint win=msg.value*7; //win = 7 times the ticket price\r\n            \r\n            if(win>this.balance) //if the balance isnt sufficient...\r\n                win=this.balance; //...send everything we've got\r\n            msg.sender.transfer(win);\r\n        }\r\n        \r\n        if(block.number-lastReseed>1000) //reseed if needed\r\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\r\n    }\r\n    \r\n    function luckyNumberOfAddress(address addr) constant returns(uint n){\r\n        // calculate the number of current address - 1 in 8 chance\r\n        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\r\n    }\r\n    \r\n    function reseed(SeedComponents components) internal {\r\n        secretSeed = uint256(keccak256(\r\n            components.component1,\r\n            components.component2,\r\n            components.component3,\r\n            components.component4\r\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\r\n        lastReseed = block.number;\r\n    }\r\n    \r\n    function kill() {\r\n        require(msg.sender==owner);\r\n        \r\n        selfdestruct(msg.sender);\r\n    }\r\n    \r\n    function forceReseed() { //reseed initiated by the owner - for testing purposes\r\n        require(msg.sender==owner);\r\n        \r\n        SeedComponents s;\r\n        s.component1 = uint(msg.sender);\r\n        s.component2 = uint256(block.blockhash(block.number - 1));\r\n        s.component3 = block.difficulty*(uint)(block.coinbase);\r\n        s.component4 = tx.gasprice * 7;\r\n        \r\n        reseed(s); //reseed\r\n    }\r\n    \r\n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\r\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\r\n            participate();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"luckyNumberOfAddress\",\"outputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forceReseed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"participate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"OpenAddressLottery","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://110655367eda695d12c951524345a8f9c0f0d5d475842aa95bc80e6801bc2349"}]}