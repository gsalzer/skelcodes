{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ninterface ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * Owned Contract\r\n *\r\n * This is a contract trait to inherit from. Contracts that inherit from Owned\r\n * are able to modify functions to be only callable by the owner of the\r\n * contract.\r\n *\r\n * By default it is impossible to change the owner of the contract.\r\n */\r\ncontract Owned {\r\n  /**\r\n   * Contract owner.\r\n   *\r\n   * This value is set at contract creation time.\r\n   */\r\n  address owner;\r\n\r\n  /**\r\n   * Contract constructor.\r\n   *\r\n   * This sets the owner of the Owned contract at the time of contract\r\n   * creation.\r\n   */\r\n  function Owned() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * Modify method to only allow the owner to call it.\r\n   */\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * Chi Token Sale Contract with revenue sharing\r\n *\r\n * The intention of this contract is to run until the total value of 2000 ETH\r\n * is sold out. There is no time limit placed on the contract.\r\n *\r\n * The total number of CHI tokens allocated to the contract is equal to the\r\n * maximum number of tokens that can be acquired. This maximum number is\r\n * calculating the purchase of 2000 ETH of tokens, and adding the bonus tokens\r\n * for that purchase.\r\n *\r\n * The bonus tiers thresholds are calculated using the absolute number of sold\r\n * tokens (by this contract), and are as follows:\r\n *  - the 1st 150.000 tokens (0 - 149.999) get a bonus of 75%;\r\n *  - the 2nd 150.000 tokens (150.000 - 299.999) get a bonus of 60%;\r\n *  - the 3rd 150.000 tokens (300.000 - 449.999) get a bonus of 50%;\r\n *  - the 4th 150.000 tokens (450.000 - 599.999) get a bonus of 40%;\r\n *  - the 5th 150.000 tokens (600.000 - 749.999) get a bonus of 30%;\r\n *  - the 6th 150.000 tokens (750.000 - 899.999) get a bonus of 20%;\r\n *  - the next 300.000 tokens (900.000 - 1.199.999) get a bonus of 10%;\r\n *  - the next 300.000 tokens (1.200.000 - 1.499.999) get a bonus of 5%; and\r\n *  - the next 500.000 tokens (1.500.000 - 1.999.999) get a bonus of 2%.\r\n *\r\n * The maximum number of tokens this contract is able to hand out, can be\r\n * calculated using the following Python code:\r\n *  https://pyfiddle.io/fiddle/9bbc870a-534e-47b1-87c3-5f000bdd7d74/\r\n */\r\ncontract ChiSale is Owned {\r\n    // For simplicity reasons, all values are calculated using uint256. Both\r\n    // values could technically be reduced to a lower bit value: percentage\r\n    // fits in `uint8`, and threshold fits within `uint64`. This contract is\r\n    // not optimized for storage and does not use bit packing to store multiple\r\n    // smaller `uint` values in a single larger `uint`.\r\n    struct BonusTier {\r\n        uint256 percentage;\r\n        uint256 threshold;\r\n    }\r\n\r\n    // The list of bonus tiers is set at contract construction and does not\r\n    // mutate.\r\n    BonusTier[] private bonusTiers;\r\n\r\n    // The number of sold tokens is to keep track of the active bonus tier. The\r\n    // number is updated every time a purchase is made.\r\n    uint256 private tokensSold;\r\n\r\n    // The bonus index is always up-to-date with the latest bonus tier. It is\r\n    // automatically updated when a new threshold is hit.\r\n    uint8 private bonusIndex;\r\n\r\n    // The maximum bonus threshold indicated the threshold of the final bonus\r\n    // tier. This is also the maximum number of tokens a buyer is able to\r\n    // purchase.\r\n    uint256 private maxBonusThreshold;\r\n\r\n    // The price per CHI token is constant, and equal to the value determined\r\n    // by the Aethian Crystal Bank: 0.001 ether per CHI, which is equal to 1\r\n    // ether for 1000 CHI.\r\n    uint256 private constant TOKEN_PRICE = 0.001 ether;\r\n\r\n    // The revenue share percentage is the percentage that the referrer of the\r\n    // buyer receives, after the buyer makes a purchase using their address as\r\n    // referral address. The referral address is the address that receives the\r\n    // revenue share percentage.\r\n    uint256 private constant REVENUE_SHARE_PERCENTAGE = 22;\r\n\r\n    // The CHI token contract implements ERC-20.\r\n    ERC20 private chiContract;\r\n\r\n    // Log the CHI purchase event. The purchase events are filterable by buyer\r\n    // and referrer to allow for quick look-ups for specific users.\r\n    event LogChiPurchase(\r\n        address indexed buyer,\r\n        address indexed referrer,\r\n        uint256 number,\r\n        uint256 timestamp\r\n    );\r\n\r\n    /**\r\n     * CHI Sale contract constructor\r\n     *\r\n     * The CHI contract address and bonus numbers are passed in dynamically\r\n     * to allow for testing using different Ethereum networks and different\r\n     * bonus numbers.\r\n     */\r\n    function ChiSale(\r\n        address chiAddress,\r\n        uint256[] bonusThresholds,\r\n        uint256[] bonusPercentages\r\n    )\r\n        public\r\n        Owned()\r\n    {\r\n        // Explicitly check the lengths of the bonus percentage and threshold\r\n        // arrays to prevent human error. This does not prevent the creator\r\n        // from inputting the wrong numbers, however.\r\n        require(bonusThresholds.length == bonusPercentages.length);\r\n\r\n        // Explicitly check that the number of bonus tiers is less than 256, as\r\n        // it should fit within the 8 bit unsigned integer value that is used\r\n        // as the index counter.\r\n        require(bonusThresholds.length < 256);\r\n\r\n        // Loop through one array, whilst simultaneously reading data from the\r\n        // other array. This is possible because both arrays are of the same\r\n        // length, as checked in the line above.\r\n        for (uint8 i = 0; i < bonusThresholds.length; i++) {\r\n\r\n            // Guard against human error, by checking that the new bonus\r\n            // threshold is always a higher value than the previous threshold.\r\n            if (i > 0) {\r\n                require(bonusThresholds[i] > bonusThresholds[i - 1]);\r\n            }\r\n\r\n            // It is already guaranteed that bonus thresholds are in ascending\r\n            // order. For this reason, the maximum bonus threshold can be set\r\n            // by selecting the final value in the bonus thresholds array.\r\n            if (i > bonusThresholds.length - 1) {\r\n                maxBonusThreshold = bonusThresholds[i];\r\n            }\r\n\r\n            bonusTiers.push(BonusTier({\r\n                percentage: bonusPercentages[i],\r\n                threshold: bonusThresholds[i]\r\n            }));\r\n        }\r\n\r\n        // The CHI token contract address is passed as argument to allow for\r\n        // easier testing on the development and testing networks.\r\n        chiContract = ERC20(chiAddress);\r\n\r\n        // The default value of an unsigned integer is already zero, however,\r\n        // for verbosity and readability purposes, both counters are explicitly\r\n        // set to zero.\r\n        tokensSold = 0;\r\n        bonusIndex = 0;\r\n    }\r\n\r\n    function buy(address referralAddress) external payable {\r\n        // Calculate the number of tokens to buy. This can be 0, if the buyer\r\n        // sends an ether value that is less than the price indicated by\r\n        // `TOKEN_PRICE`.\r\n        uint256 tokensToBuy = msg.value / TOKEN_PRICE;\r\n\r\n        // Get the current CHI token balance of this contract. If this number\r\n        // is zero, no more tokens can will be sold.\r\n        uint256 tokenBalance = chiContract.balanceOf(address(this));\r\n\r\n        // A buyer can send more than the required amount for buying a number\r\n        // of tokens. In this case the remainder is calculated, that will be\r\n        // sent back at the end of the transaction.\r\n        uint256 remainder = msg.value % TOKEN_PRICE;\r\n\r\n        // Explicitly guard against the scenario wherein human error occurs,\r\n        // and fewer tokens have been transferred to the contract than dictated\r\n        // by the bonus tiers. This situation can still be resolved at a later\r\n        // date by calling `resetMaxBonusThreshold`.\r\n        if (maxBonusThreshold < tokenBalance) {\r\n            maxBonusThreshold = tokenBalance;\r\n        }\r\n\r\n        // A scenario is possible wherein a buyer attempts to buy more tokens\r\n        // than the contract is offering. In this case the purchase is limited\r\n        // to the available number of tokens.\r\n        if (tokensToBuy > maxBonusThreshold) {\r\n            tokensToBuy = maxBonusThreshold;\r\n\r\n            // The actual number of tokens that can be bought is multiplied by\r\n            // the token price to calculate the actual purchase price of the\r\n            // transaction. This is then subtracted from the total value of\r\n            // ether sent in the transaction to end up with the remainder that\r\n            // will be sent back to the buyer.\r\n            remainder = msg.value - tokensToBuy * TOKEN_PRICE;\r\n        }\r\n\r\n        // The sale contract has a bonus structure. The number of bonus tokens\r\n        // is calculated in a different method. This method will always return\r\n        // a number (of bonus tokens) without error; this number can be zero.\r\n        uint256 bonusTokens = calculateBonusTokens(tokensToBuy);\r\n\r\n        // Update the number of tokens sold. This number does not include the\r\n        // number of bonus tokens that were given out, only the number of\r\n        // tokens that were 'bought'.\r\n        tokensSold += tokensToBuy;\r\n\r\n        // Guard against transfers where the contract attempts to transfer more\r\n        // CHI tokens than it has available. In reality, this can never occur\r\n        // as the proper amount of tokens should have been deposited within the\r\n        // contract in accordance to the number calculated by the Python script\r\n        // linked above. This is simply a guard against human error.\r\n        if (tokenBalance < tokensToBuy + bonusTokens) {\r\n            chiContract.transfer(msg.sender, tokenBalance);\r\n        } else {\r\n            chiContract.transfer(msg.sender, tokensToBuy + bonusTokens);\r\n        }\r\n\r\n        // The referral address has a default value set to the contract address\r\n        // of this CHI sale contract in the web application. The application\r\n        // changes this value to a different referral address if a special link\r\n        // is followed. If the referral address does not equal this contract's\r\n        // address, the revenue share percentage is paid out to that address.\r\n        if (referralAddress != address(this) && referralAddress != address(0)) {\r\n\r\n            // The value `msg.value * REVENUE_SHARE_PERCENTAGE / 100` is always\r\n            // guaranteed to be a valid number (i.e. accepted by the `transfer`\r\n            // method). The value cannot overflow as the maximum number of Wei\r\n            // in `msg.value` fits in 128 bits. Multiplying this number by\r\n            // `REVENUE_SHARE_PERCENTAGE` still safely fits within the current\r\n            // 256 bit range. The value is sent using `send` to make sure the\r\n            // purchase does not fail if someone uses an invalid address.\r\n            referralAddress.send(\r\n                msg.value * REVENUE_SHARE_PERCENTAGE / 100\r\n            );\r\n        }\r\n\r\n        // In the case where a buyer sent in too much ether, or there weren't\r\n        // enough tokens available, the remaining ether is sent back to the\r\n        // buyer.\r\n        if (remainder > 0) {\r\n            msg.sender.transfer(remainder);\r\n        }\r\n\r\n        LogChiPurchase(msg.sender, referralAddress, tokensToBuy, now);\r\n    }\r\n\r\n    /**\r\n     * Reset the maximum bonus threshold to the correct value.\r\n     *\r\n     * This number is lowered if the contract has fewer tokens available than\r\n     * indicated by the maximum bonus threshold. In this case, the correct\r\n     * number of tokens should be deposited before calling this method to\r\n     * restore the numbers.\r\n     */\r\n    function resetMaxBonusThreshold() external onlyOwner {\r\n        maxBonusThreshold = bonusTiers[bonusTiers.length - 1].threshold;\r\n    }\r\n\r\n    /**\r\n     * Withdraw all ether from the contract.\r\n     *\r\n     * This withdrawal is separate from the CHI withdrawal method to allow for\r\n     * intermittent withdrawals as the contract has no set time period to run\r\n     * for.\r\n     */\r\n    function withdrawEther() external onlyOwner {\r\n        // The transfer method cannot fail with the current given input, as a\r\n        // transfer of 0 Wei is also a valid transfer call.\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * Withdraw remaining CHI from the contract.\r\n     *\r\n     * The intent of this method is to retrieve the remaining bonus tokens\r\n     * after the sale has concluded successfully, but not all bonus tokens have\r\n     * been handed out (due to rounding).\r\n     */\r\n    function withdrawChi() external onlyOwner {\r\n        // This CHI transfer cannot fail as the available balance is first\r\n        // retrieved from the CHI token contract. The deterministic nature of\r\n        // the Ethereum blockchain guarantees that no other operations occur\r\n        // in between the balance retrieval call and the transfer call.\r\n        chiContract.transfer(msg.sender, chiContract.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * Get the number of bonus tiers.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The number of bonus tiers in the sale contract.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method returns a 256 bit unsigned integer because that is the\r\n     * return type of the `length` method on arrays. Type casting it would be\r\n     * a needless gas cost.\r\n     */\r\n    function getBonusTierCount() external view returns (uint256) {\r\n        return bonusTiers.length;\r\n    }\r\n\r\n    /**\r\n     * Get bonus percentage and threshold of a given bonus tier.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * bonusTierIndex : uint8\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The first 256 bit unsigned integer is the bonus percentage of the\r\n     *     given bonus tier.\r\n     * uint256\r\n     *     The second 256 bit unsigned integer is the bonus threshold of the\r\n     *     given bonus tier.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Both percentage and threshold are 256 bit unsigned integers, even though\r\n     * they technically respectively fit within an 8 bit unsigned integer and\r\n     * a 64 bit unsigned integer. For simplicity purposes, they are kept as 256\r\n     * bit values.\r\n     */\r\n    function getBonusTier(\r\n        uint8 bonusTierIndex\r\n    )\r\n        external\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return (\r\n            bonusTiers[bonusTierIndex].percentage,\r\n            bonusTiers[bonusTierIndex].threshold\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get bonus percentage and threshold of the current bonus tier.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The first 256 bit unsigned integer is the bonus percentage of the\r\n     *     current bonus tier.\r\n     * uint256\r\n     *     The second 256 bit unsigned integer is the bonus threshold of the\r\n     *     current bonus tier.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * Both percentage and threshold are 256 bit unsigned integers, even though\r\n     * they technically respectively fit within an 8 bit unsigned integer and\r\n     * a 64 bit unsigned integer. For simplicity purposes, they are kept as 256\r\n     * bit values.\r\n     */\r\n    function getCurrentBonusTier()\r\n        external\r\n        view\r\n        returns (uint256 percentage, uint256 threshold)\r\n    {\r\n        return (\r\n            bonusTiers[bonusIndex].percentage,\r\n            bonusTiers[bonusIndex].threshold\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the next bonus tier index.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint8\r\n     *     The index of the next bonus tier.\r\n     */\r\n    function getNextBonusIndex()\r\n        external\r\n        view\r\n        returns (uint8)\r\n    {\r\n        return bonusIndex + 1;\r\n    }\r\n\r\n    /**\r\n     * Get the number of sold tokens.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The number of sold tokens.\r\n     */\r\n    function getSoldTokens() external view returns (uint256) {\r\n        return tokensSold;\r\n    }\r\n\r\n    /**\r\n     * Calculate the number of bonus tokens to send the buyer.\r\n     *\r\n     * Parameters\r\n     * ----------\r\n     * boughtTokens : uint256\r\n     *     The number of tokens the buyer has bought, and to calculate the\r\n     *     number of bonus tokens of.\r\n     *\r\n     * Returns\r\n     * -------\r\n     * uint256\r\n     *     The number of bonus tokens to send the buyer.\r\n     *\r\n     * Notice\r\n     * ------\r\n     * This method modifies contract state by incrementing the bonus tier index\r\n     * whenever a bonus tier is completely exhausted. This is done for\r\n     * simplicity purposes. A different approach would have been to move the\r\n     * loop to a different segment of the contract.\r\n     */\r\n    function calculateBonusTokens(\r\n        uint256 boughtTokens\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // Immediate return if all bonus tokens have already been handed out.\r\n        if (bonusIndex == bonusTiers.length) {\r\n            return 0;\r\n        }\r\n\r\n        // The number of bonus tokens always starts at zero. If the buyer does\r\n        // not hit any of the bonus thresholds, or if the buyer buys a low\r\n        // number of tokens that causes the bonus to round down to zero, this\r\n        // zero value is returned.\r\n        uint256 bonusTokens = 0;\r\n\r\n        // Copy the number of bought tokens to an `lvalue` to allow mutation.\r\n        uint256 _boughtTokens = boughtTokens;\r\n\r\n        // Copy the number of sold tokens to an `lvalue` to allow mutation.\r\n        uint256 _tokensSold = tokensSold;\r\n\r\n        while (_boughtTokens > 0) {\r\n            uint256 threshold = bonusTiers[bonusIndex].threshold;\r\n            uint256 bonus = bonusTiers[bonusIndex].percentage;\r\n\r\n            // There are two possible scenarios for the active bonus tier:\r\n            //  1: the buyer purchases equal or more CHI tokens than available\r\n            //     in the current bonus tier; and\r\n            //  2: the buyer purchases less CHI tokens than available in the\r\n            //     current bonus tier.\r\n            if (_tokensSold + _boughtTokens >= threshold) {\r\n                // The number of remaining tokens within the threshold is equal\r\n                // to the threshold minus the number of tokens that have been\r\n                // sold already.\r\n                _boughtTokens -= threshold - _tokensSold;\r\n\r\n                // The number of bonus tokens is equal to the remaining number\r\n                // of tokens in the bonus tier multiplied by the bonus tier's\r\n                // percentage. A different bonus will be calculated for the\r\n                // remaining bought tokens. The number is first multiplied by\r\n                // the bonus percentage to work to the advantage of the buyer,\r\n                // as the minimum number of tokens that need to be bought for a\r\n                // bonus to be counted would be equal to `100 / bonus` (rounded\r\n                // down), in comparison to requiring a minimum of 100 tokens in\r\n                // the other case.\r\n                bonusTokens += (threshold - _tokensSold) * bonus / 100;\r\n\r\n                // The number of sold tokens is 'normally' incremented by the\r\n                // number of tokens that have been bought (in that bonus tier).\r\n                // However, when all remaining tokens in a bonus tier are\r\n                // purchased, the resulting operation looks as follows:\r\n                //  _tokensSold = _tokensSold + (threshold - _tokensSold)\r\n                // which can be simplified to the current operation.\r\n                _tokensSold = threshold;\r\n\r\n                // If the bonus tier limit has not been reached, the bonus\r\n                // index is incremented, because all tokens in the current\r\n                // bonus tier have been sold.\r\n                if (bonusIndex < bonusTiers.length) {\r\n                    bonusIndex += 1;\r\n                }\r\n            } else {\r\n\r\n                // In the case where the number of bought tokens does not hit\r\n                // the bonus threshold. No bonus changes have to be made, and\r\n                // the number of sold tokens can be incremented by the bought\r\n                // number of tokens.\r\n                _tokensSold += _boughtTokens;\r\n\r\n                // The number of bonus tokens is equal to the number of bought\r\n                // tokens multiplied by the bonus factor of the active bonus\r\n                // tier.\r\n                bonusTokens += _boughtTokens * bonus / 100;\r\n\r\n                // Reset the bought tokens to zero.\r\n                _boughtTokens = 0;\r\n            }\r\n        }\r\n\r\n        return bonusTokens;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentBonusTier\",\"outputs\":[{\"name\":\"percentage\",\"type\":\"uint256\"},{\"name\":\"threshold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextBonusIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBonusTierCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawChi\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetMaxBonusThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSoldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bonusTierIndex\",\"type\":\"uint8\"}],\"name\":\"getBonusTier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"chiAddress\",\"type\":\"address\"},{\"name\":\"bonusThresholds\",\"type\":\"uint256[]\"},{\"name\":\"bonusPercentages\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LogChiPurchase\",\"type\":\"event\"}]","ContractName":"ChiSale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000071e1f8e809dc8911fcac95043bc94929a36505a5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000249f000000000000000000000000000000000000000000000000000000000000493e0000000000000000000000000000000000000000000000000000000000006ddd000000000000000000000000000000000000000000000000000000000000927c000000000000000000000000000000000000000000000000000000000000b71b000000000000000000000000000000000000000000000000000000000000dbba00000000000000000000000000000000000000000000000000000000000124f80000000000000000000000000000000000000000000000000000000000016e36000000000000000000000000000000000000000000000000000000000001e84800000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000004b000000000000000000000000000000000000000000000000000000000000003c00000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000002","Library":"","SwarmSource":"bzzr://be017df6f6b43e6602d9fa60958d81e99ee686e0863f648d8ab8d6c5b17d28da"}]}