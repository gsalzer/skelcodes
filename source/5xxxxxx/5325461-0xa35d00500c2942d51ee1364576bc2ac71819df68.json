{"status":"1","message":"OK","result":[{"SourceCode":"/* This source code is part of CACIB DocChain registered trademark\r\n*  It is provided becaused published in the public blockchain of Ethereum.\r\n*  Reusing this code is forbidden without approbation of CACIB first (idea@ca-cib.com)\r\n*  Providing this code in public repository is meant to provide clarity to the mechanism by which the DocChain product works\r\n*/\r\npragma solidity ^0.4.11;\r\n\r\n/**\r\n * The IEthIdentity interface defines fundamental functionnalities\r\n * that every Ethereum identity in this framework must implement to be \r\n * usable with DocChain principles.\r\n * \r\n * The purpose of implementing IEthIdentity interface is to prove its own identity\r\n * and let others checking whether any proof has been made by its identity.\r\n */\r\ninterface IEthIdentity {\r\n    \r\n    /**\r\n     * Add proof if it does not exist yet\r\n     *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)\r\n     *  - bytes32: the attribute id or proof id for which the identity owner has made a proof\r\n     */\r\n    function addProof(address, bytes32) public returns(bool);\r\n    \r\n    /**\r\n     * Remove proof of a source if existed\r\n     *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)\r\n     *  - bytes32: the attribute id or proof id to be removed\r\n     */\r\n    function removeProof(address, bytes32) public returns(bool);\r\n\r\n    /**\r\n     * Check whether the provided address is the controlling wallet (owner) of the identity\r\n     */\r\n    function checkOwner(address) public constant returns(bool);\r\n    \r\n    /**\r\n     * Get the identity owner name\r\n     */\r\n    function getIdentityName() public constant returns(bytes32);\r\n    \r\n}\r\n\r\n/**\r\n * The implementation of IEthIdentity interface.\r\n * \r\n * This is just an implementation of IEthIdentity interface, other implementation\r\n * may be different. However, the fundamental functionnalities defined in IEthIdentity\r\n * interface must be fully implemented to be compatible with the framework.\r\n */\r\ncontract EthIdentity is IEthIdentity {\r\n    \r\n    /**\r\n     * The EthIdentity contract is a prudent identity proof of its owner\r\n     * When contract is created, it assigns the sender of creating contract\r\n     * transaction as its owner. \r\n     * The contract owner can only be changed by the override owner.\r\n     * The override owner can only be changed by the override owner.\r\n     * Although set as private but they can always be read via the getStorageAt. It saves bytecode in the final structure\r\n     */\r\n    address public owner;\r\n    address private override;\r\n    \r\n    /**\r\n     * The identity name is a string for human readability and visibility\r\n     * but is stored as 32 bytes in order to be used between contract calls.\r\n     */\r\n    bytes32 private identityName;\r\n    \r\n    /**\r\n     * Constructor of EthIdentity contract\r\n     * Only execute once.\r\n     * receives the Name of the identity\r\n     */\r\n    function EthIdentity(bytes32 _name) public {\r\n        owner = msg.sender;\r\n        override = msg.sender;\r\n        identityName = _name;\r\n    }\r\n    \r\n    /**\r\n     * Constants for event type & notifications\r\n     */\r\n    uint constant ERROR_EVENT = 119;\r\n    uint constant INFO_EVENT = 115;\r\n    \r\n    /**\r\n     * This event is used for change notification and outputs the following:\r\n     * - event sender (indexed for filter)\r\n     * - event status (indexed for filter)\r\n     * - event message\r\n     */\r\n    event EventNotification(address indexed sender, uint indexed status, bytes32 message);\r\n    \r\n    /**\r\n     * The list of proofs stored by this identity owner\r\n     * The identity owner can store several proofs for a particular source, hence\r\n     * is defined as a mapping list that use the proof value (attribute) as key\r\n     * Hence the attribute value must be unique accross all sources.\r\n     * \r\n     * For the eSignature contract, the proof is defined as the document id\r\n     * generated by this contract when the document hash is added/signed by an identity owner.\r\n     * For a wider use, it can be any attribute that is stored by this identity owner, but must be a bytes32 for optimisation.\r\n     */\r\n    mapping(bytes32 => address) proofList;\r\n    \r\n    /**\r\n     * Add a proof ONLY if not already present and ONLY by the identity owner\r\n     * \r\n     * _source: address of the source (e.g. eSignature contract) where the proof has been stored\r\n     * _attribute: a bytes32 representing the attribute at the source identifying the proof\r\n     * \r\n     * For eSignature case, _attribute is the document id generated when the identity adds/signs the document\r\n     */\r\n    function addProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {\r\n        // Check input\r\n        require(_source != address(0x0));\r\n        \r\n        // Check proof existence\r\n        bool existed = checkProof(_attribute);\r\n        \r\n        // Returns and do nothing except emitting event if the proof already exists\r\n        if (existed == true) {\r\n            EventNotification(msg.sender, ERROR_EVENT, \"Proof already exist\");\r\n            return false;\r\n        }\r\n        \r\n        // Add new proof\r\n        proofList[_attribute] = _source;\r\n        \r\n        EventNotification(msg.sender, INFO_EVENT, \"New proof added\");\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Remove proof of a source ONLY if present and ONLY by the identity owner\r\n     * \r\n     * _source: address of the source (e.g. eSignature contract) where the proof has been stored\r\n     * _attribute: a bytes32 representing the attribute at the source identifying the proof\r\n     * \r\n     * For eSignature case, _attribute is the document id generated when the identity adds/signs the document\r\n     */\r\n    function removeProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {\r\n        // Check proof existence\r\n        bool existed = checkProof(_attribute);\r\n        \r\n        // Return and do nothing except emitting event if the proof does not exist\r\n        if (existed == false) {\r\n            EventNotification(msg.sender, ERROR_EVENT, \"Proof not found\");\r\n            return false;\r\n        }\r\n        \r\n        // Return and do nothing except emitting event if the source is not correct\r\n        if (proofList[_attribute] != _source) {\r\n            EventNotification(msg.sender, ERROR_EVENT, \"Incorrect source\");\r\n            return false;\r\n        }\r\n        \r\n        // Delete existing proof\r\n        delete proofList[_attribute];\r\n        \r\n        EventNotification(msg.sender, INFO_EVENT, \"Proof removed\");\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Check whether the identity owner has stored a proof with a  source\r\n     * Return true if proof is found\r\n     * \r\n     * _attribute: a string representing the attribute of the source for which the proof has been made\r\n     * \r\n     * For eSignature case, _attribute is the document id generated when the identity create/sign the document\r\n     */\r\n    function checkProof(bytes32 _attribute) public constant returns(bool) {\r\n        var source = proofList[_attribute];\r\n        // Check if proof source is assigned & matched\r\n        if (source != address(0x0))\r\n            return true;\r\n        // Proof not exists since its source is not matched    \r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Check whether the provided address is the controlling wallet of the identity\r\n     * Return true if yes\r\n     */\r\n    function checkOwner(address _check) public constant returns(bool) {\r\n        return _check == owner;\r\n    }\r\n    \r\n    /**\r\n     * Get the identity owner name, usable inside contract call\r\n     */\r\n    function getIdentityName() public constant returns(bytes32) {\r\n        return identityName;\r\n    }\r\n    \r\n    /**\r\n     * Show the name of the identity in string \r\n     * (for Etherscan read-only function)\r\n     */\r\n    function nameOfIdentity() public constant returns(string) {\r\n        return bytes32ToString(identityName);\r\n    }\r\n    \r\n    /**\r\n     * Get the identity detail information\r\n     */\r\n    function getIdentityInfo() public constant returns(address, address, string) {\r\n        return (override, owner, bytes32ToString(identityName));\r\n    }\r\n    \r\n     /**\r\n     * Only the identity owner can set its name\r\n     */\r\n    function setIdentityName(bytes32 _newName) public onlyBy(owner) returns(bool) {\r\n        identityName = _newName;\r\n        EventNotification(msg.sender, INFO_EVENT, \"Set owner name\");\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Only the override address is allowed to change the owner address.\r\n     */\r\n    function setOwner(address _newOwner) public onlyBy(override) returns(bool) {\r\n        owner = _newOwner;\r\n        EventNotification(msg.sender, INFO_EVENT, \"Set new owner\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Only the override address is allowed to change the override address.\r\n     */\r\n    function setOverride(address _newOverride) public onlyBy(override) returns(bool) {\r\n        override = _newOverride;\r\n        EventNotification(msg.sender, INFO_EVENT, \"Set new override\");\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Convert bytes32 to string. Set modifier pure which means cannot\r\n     * access the contract storage.\r\n     */\r\n    function bytes32ToString(bytes32 data) internal pure returns (string) {\r\n        bytes memory bytesString = new bytes(32);\r\n        for (uint j=0; j<32; j++){\r\n            if (data[j] != 0) {\r\n                bytesString[j] = data[j];\r\n            }\r\n        }\r\n        return string(bytesString);\r\n    }\r\n    \r\n    /**\r\n     * Modifier to make a constraint on who is permitted\r\n     * to execute a function\r\n     */\r\n    modifier onlyBy(address _authorized) {\r\n        assert(msg.sender == _authorized);\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_source\",\"type\":\"address\"},{\"name\":\"_attribute\",\"type\":\"bytes32\"}],\"name\":\"addProof\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIdentityName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_attribute\",\"type\":\"bytes32\"}],\"name\":\"checkProof\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_source\",\"type\":\"address\"},{\"name\":\"_attribute\",\"type\":\"bytes32\"}],\"name\":\"removeProof\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newName\",\"type\":\"bytes32\"}],\"name\":\"setIdentityName\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOverride\",\"type\":\"address\"}],\"name\":\"setOverride\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIdentityInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nameOfIdentity\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_check\",\"type\":\"address\"}],\"name\":\"checkOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"status\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"bytes32\"}],\"name\":\"EventNotification\",\"type\":\"event\"}]","ContractName":"EthIdentity","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"434143494220284672616e6365292047756172616e7465657320424f00000000","Library":"","SwarmSource":"bzzr://a32b74e90fc6bff8b513c51638b21ab47f767edad0f11cf5b472ff9a457cb23c"}]}