{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n// File: contracts/ClaimRegistry.sol\r\n\r\ncontract ClaimRegistry {\r\n    function getSingleSubjectByAddress(address linkedAddress, uint subjectIndex) public view returns(address subject);\r\n    function getSubjectClaimSetSize(address subject, uint typeNameIx, uint attrNameIx) public constant returns (uint) ;\r\n    function getSubjectClaimSetEntryAt(address subject, uint typeNameIx, uint attrNameIx, uint ix) public constant returns (address issuer, uint url);\r\n    function getSubjectCountByAddress(address linkedAddress) public view returns(uint subjectCount);\r\n }\r\n\r\n// File: contracts/NotakeyVerifierForICOP.sol\r\n\r\ncontract NotakeyVerifierForICOP {\r\n\r\n    uint public constant ICO_CONTRIBUTOR_TYPE = 6;\r\n    uint public constant REPORT_BUNDLE = 6;\r\n    uint public constant NATIONALITY_INDEX = 7;\r\n\r\n    address public claimRegistryAddr;\r\n    address public trustedIssuerAddr;\r\n    // address private callerIdentitySubject;\r\n\r\n    uint public constant USA = 883423532389192164791648750371459257913741948437809479060803100646309888;\r\n        // USA is 240nd; blacklist: 1 << (240-1)\r\n    uint public constant CHINA = 8796093022208;\r\n        // China is 44th; blacklist: 1 << (44-1)\r\n    uint public constant SOUTH_KOREA = 83076749736557242056487941267521536;\r\n        // SK is 117th; blacklist: 1 << (117-1)\r\n\r\n     event GotUnregisteredPaymentAddress(address indexed paymentAddress);\r\n\r\n\r\n    function NotakeyVerifierForICOP(address _trustedIssuerAddr, address _claimRegistryAddr) public {\r\n        claimRegistryAddr = _claimRegistryAddr;\r\n        trustedIssuerAddr  = _trustedIssuerAddr;\r\n    }\r\n\r\n    modifier onlyVerifiedSenders(address paymentAddress, uint256 nationalityBlacklist) {\r\n        // DISABLED for ICOP sale\r\n        // require(_hasIcoContributorType(paymentAddress));\r\n        require(!_preventedByNationalityBlacklist(paymentAddress, nationalityBlacklist));\r\n\r\n        _;\r\n    }\r\n\r\n    function sanityCheck() public pure returns (string) {\r\n        return \"Hello Dashboard\";\r\n    }\r\n\r\n    function isVerified(address subject, uint256 nationalityBlacklist) public constant onlyVerifiedSenders(subject, nationalityBlacklist) returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function _preventedByNationalityBlacklist(\r\n        address paymentAddress,\r\n        uint256 nationalityBlacklist) internal constant returns (bool)\r\n    {\r\n        var claimRegistry = ClaimRegistry(claimRegistryAddr);\r\n\r\n        uint subjectCount = _lookupOwnerIdentityCount(paymentAddress);\r\n\r\n        uint256 ignoredClaims;\r\n        uint claimCount;\r\n        address subject;\r\n\r\n        // Loop over all isued identities associated to this wallet adress and\r\n        // throw if any match to blacklist\r\n        for (uint subjectIndex = 0 ; subjectIndex < subjectCount ; subjectIndex++ ){\r\n            subject = claimRegistry.getSingleSubjectByAddress(paymentAddress, subjectIndex);\r\n            claimCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX);\r\n            ignoredClaims = 0;\r\n\r\n            for (uint i = 0; i < claimCount; ++i) {\r\n                var (issuer, url) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX, i);\r\n                var countryMask = 2**(url-1);\r\n\r\n                if (issuer != trustedIssuerAddr) {\r\n                    ignoredClaims += 1;\r\n                } else {\r\n                    if (((countryMask ^ nationalityBlacklist) & countryMask) != countryMask) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the blacklist is empty (0), then that's fine for the V1 contract (where we validate the bundle);\r\n        // For our own sale, however, this attribute is a proxy indicator for whether the address is verified.\r\n        //\r\n        // Account for ignored claims (issued by unrecognized issuers)\r\n        require((claimCount - ignoredClaims) > 0);\r\n\r\n        return false;\r\n    }\r\n\r\n    function _lookupOwnerIdentityCount(address paymentAddress) internal constant returns (uint){\r\n        var claimRegistry = ClaimRegistry(claimRegistryAddr);\r\n        var subjectCount = claimRegistry.getSubjectCountByAddress(paymentAddress);\r\n\r\n        // The address is unregistered so we throw and log event\r\n        // This method and callers have to overriden as non-constant to emit events\r\n        // if ( subjectCount == 0 ) {\r\n            // GotUnregisteredPaymentAddress( paymentAddress );\r\n            // revert();\r\n        // }\r\n\r\n        require(subjectCount > 0);\r\n\r\n        return subjectCount;\r\n    }\r\n\r\n    function _hasIcoContributorType(address paymentAddress) internal constant returns (bool)\r\n    {\r\n        uint subjectCount = _lookupOwnerIdentityCount(paymentAddress);\r\n\r\n        var atLeastOneValidReport = false;\r\n        var atLeastOneValidNationality = false;\r\n        address subject;\r\n\r\n        var claimRegistry = ClaimRegistry(claimRegistryAddr);\r\n\r\n        // Loop over all isued identities associated to this wallet address and\r\n        // exit loop any satisfy the business logic requirement\r\n        for (uint subjectIndex = 0 ; subjectIndex < subjectCount ; subjectIndex++ ){\r\n            subject = claimRegistry.getSingleSubjectByAddress(paymentAddress, subjectIndex);\r\n\r\n            var nationalityCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX);\r\n            for (uint nationalityIndex = 0; nationalityIndex < nationalityCount; ++nationalityIndex) {\r\n                var (nationalityIssuer,) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, NATIONALITY_INDEX, nationalityIndex);\r\n                if (nationalityIssuer == trustedIssuerAddr) {\r\n                    atLeastOneValidNationality = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            var reportCount = claimRegistry.getSubjectClaimSetSize(subject, ICO_CONTRIBUTOR_TYPE, REPORT_BUNDLE);\r\n            for (uint reportIndex = 0; reportIndex < reportCount; ++reportIndex) {\r\n                var (reportIssuer,) = claimRegistry.getSubjectClaimSetEntryAt(subject, ICO_CONTRIBUTOR_TYPE, REPORT_BUNDLE, reportIndex);\r\n                if (reportIssuer == trustedIssuerAddr) {\r\n                    atLeastOneValidReport = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return atLeastOneValidNationality && atLeastOneValidReport;\r\n    }\r\n}\r\n\r\n// File: contracts/SecondPriceAuction.sol\r\n\r\n//! Copyright Parity Technologies, 2017.\r\n//! (original version: https://github.com/paritytech/second-price-auction)\r\n//!\r\n//! Copyright Notakey Latvia SIA, 2017.\r\n//! Original version modified to verify contributors against Notakey\r\n//! KYC smart contract.\r\n//!\r\n//! Released under the Apache Licence 2.\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n/// Stripped down ERC20 standard token interface.\r\ncontract Token {\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n}\r\n\r\n/// Simple modified second price auction contract. Price starts high and monotonically decreases\r\n/// until all tokens are sold at the current price with currently received funds.\r\n/// The price curve has been chosen to resemble a logarithmic curve\r\n/// and produce a reasonable auction timeline.\r\ncontract SecondPriceAuction {\r\n\t// Events:\r\n\r\n\t/// Someone bought in at a particular max-price.\r\n\tevent Buyin(address indexed who, uint accounted, uint received, uint price);\r\n\r\n\t/// Admin injected a purchase.\r\n\tevent Injected(address indexed who, uint accounted, uint received);\r\n\r\n\t/// At least 5 minutes has passed since last Ticked event.\r\n\tevent Ticked(uint era, uint received, uint accounted);\r\n\r\n\t/// The sale just ended with the current price.\r\n\tevent Ended(uint price);\r\n\r\n\t/// Finalised the purchase for `who`, who has been given `tokens` tokens.\r\n\tevent Finalised(address indexed who, uint tokens);\r\n\r\n\t/// Auction is over. All accounts finalised.\r\n\tevent Retired();\r\n\r\n\t// Constructor:\r\n\r\n\t/// Simple constructor.\r\n\t/// Token cap should take be in smallest divisible units.\r\n\t/// \tNOTE: original SecondPriceAuction contract stipulates token cap must be given in whole tokens.\r\n\t///\t\tThis does not seem correct, as only whole token values are transferred via transferFrom (which - in our wallet's case -\r\n\t///     expects transfers in the smallest divisible amount)\r\n\tfunction SecondPriceAuction(\r\n\t\taddress _trustedClaimIssuer,\r\n\t\taddress _notakeyClaimRegistry,\r\n\t\taddress _tokenContract,\r\n\t\taddress _treasury,\r\n\t\taddress _admin,\r\n\t\tuint _beginTime,\r\n\t\tuint _tokenCap\r\n\t)\r\n\t\tpublic\r\n\t{\r\n\t\t// this contract must be created by the notakey claim issuer (sender)\r\n\t\tverifier = new NotakeyVerifierForICOP(_trustedClaimIssuer, _notakeyClaimRegistry);\r\n\r\n\t\ttokenContract = Token(_tokenContract);\r\n\t\ttreasury = _treasury;\r\n\t\tadmin = _admin;\r\n\t\tbeginTime = _beginTime;\r\n\t\ttokenCap = _tokenCap;\r\n\t\tendTime = beginTime + DEFAULT_AUCTION_LENGTH;\r\n\t}\r\n\r\n\tfunction() public payable { buyin(); }\r\n\r\n\t// Public interaction:\r\n\tfunction moveStartDate(uint newStart)\r\n\t\tpublic\r\n\t\tbefore_beginning\r\n\t\tonly_admin\r\n\t{\r\n\t\tbeginTime = newStart;\r\n\t\tendTime = calculateEndTime();\r\n\t}\r\n\r\n\t/// Buyin function. Throws if the sale is not active and when refund would be needed.\r\n\tfunction buyin()\r\n\t\tpublic\r\n\t\tpayable\r\n\t\twhen_not_halted\r\n\t\twhen_active\r\n\t\tonly_eligible(msg.sender)\r\n\t{\r\n\t\tflushEra();\r\n\r\n\t\t// Flush bonus period:\r\n\t\tif (currentBonus > 0) {\r\n\t\t\t// Bonus is currently active...\r\n\t\t\tif (now >= beginTime + BONUS_MIN_DURATION\t\t\t\t// ...but outside the automatic bonus period\r\n\t\t\t\t&& lastNewInterest + BONUS_LATCH <= block.number\t// ...and had no new interest for some blocks\r\n\t\t\t) {\r\n\t\t\t\tcurrentBonus--;\r\n\t\t\t}\r\n\t\t\tif (now >= beginTime + BONUS_MAX_DURATION) {\r\n\t\t\t\tcurrentBonus = 0;\r\n\t\t\t}\r\n\t\t\tif (buyins[msg.sender].received == 0) {\t// We have new interest\r\n\t\t\t\tlastNewInterest = uint32(block.number);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint accounted;\r\n\t\tbool refund;\r\n\t\tuint price;\r\n\t\t(accounted, refund, price) = theDeal(msg.value);\r\n\r\n\t\t/// No refunds allowed.\r\n\t\trequire (!refund);\r\n\r\n\t\t// record the acceptance.\r\n\t\tbuyins[msg.sender].accounted += uint128(accounted);\r\n\t\tbuyins[msg.sender].received += uint128(msg.value);\r\n\t\ttotalAccounted += accounted;\r\n\t\ttotalReceived += msg.value;\r\n\t\tendTime = calculateEndTime();\r\n\t\tBuyin(msg.sender, accounted, msg.value, price);\r\n\r\n\t\t// send to treasury\r\n\t\ttreasury.transfer(msg.value);\r\n\t}\r\n\r\n\t/// Like buyin except no payment required and bonus automatically given.\r\n\tfunction inject(address _who, uint128 _received)\r\n\t\tpublic\r\n\t\tonly_admin\r\n\t\tonly_basic(_who)\r\n\t\tbefore_beginning\r\n\t{\r\n\t\tuint128 bonus = _received * uint128(currentBonus) / 100;\r\n\t\tuint128 accounted = _received + bonus;\r\n\r\n\t\tbuyins[_who].accounted += accounted;\r\n\t\tbuyins[_who].received += _received;\r\n\t\ttotalAccounted += accounted;\r\n\t\ttotalReceived += _received;\r\n\t\tendTime = calculateEndTime();\r\n\t\tInjected(_who, accounted, _received);\r\n\t}\r\n\r\n\t/// Mint tokens for a particular participant.\r\n\tfunction finalise(address _who)\r\n\t\tpublic\r\n\t\twhen_not_halted\r\n\t\twhen_ended\r\n\t\tonly_buyins(_who)\r\n\t{\r\n\t\t// end the auction if we're the first one to finalise.\r\n\t\tif (endPrice == 0) {\r\n\t\t\tendPrice = totalAccounted / tokenCap;\r\n\t\t\tEnded(endPrice);\r\n\t\t}\r\n\r\n\t\t// enact the purchase.\r\n\t\tuint total = buyins[_who].accounted;\r\n\t\tuint tokens = total / endPrice;\r\n\t\ttotalFinalised += total;\r\n\t\tdelete buyins[_who];\r\n\t\trequire (tokenContract.transferFrom(treasury, _who, tokens));\r\n\r\n\t\tFinalised(_who, tokens);\r\n\r\n\t\tif (totalFinalised == totalAccounted) {\r\n\t\t\tRetired();\r\n\t\t}\r\n\t}\r\n\r\n\t// Prviate utilities:\r\n\r\n\t/// Ensure the era tracker is prepared in case the current changed.\r\n\tfunction flushEra() private {\r\n\t\tuint currentEra = (now - beginTime) / ERA_PERIOD;\r\n\t\tif (currentEra > eraIndex) {\r\n\t\t\tTicked(eraIndex, totalReceived, totalAccounted);\r\n\t\t}\r\n\t\teraIndex = currentEra;\r\n\t}\r\n\r\n\t// Admin interaction:\r\n\r\n\t/// Emergency function to pause buy-in and finalisation.\r\n\tfunction setHalted(bool _halted) public only_admin { halted = _halted; }\r\n\r\n\t/// Emergency function to drain the contract of any funds.\r\n\tfunction drain() public only_admin { treasury.transfer(this.balance); }\r\n\r\n\t// Inspection:\r\n\r\n\t/// The current end time of the sale assuming that nobody else buys in.\r\n\tfunction calculateEndTime() public constant returns (uint) {\r\n\t\tvar factor = tokenCap / DIVISOR * EURWEI;\r\n\t\tuint16 scaleDownRatio = 1; // 1 for prod\r\n\t\treturn beginTime + (182035 * factor / (totalAccounted + factor / 10 ) - 0) / scaleDownRatio;\r\n\t}\r\n\r\n\t/// The current price for a single indivisible part of a token. If a buyin happens now, this is\r\n\t/// the highest price per indivisible token part that the buyer will pay. This doesn't\r\n\t/// include the discount which may be available.\r\n\tfunction currentPrice() public constant when_active returns (uint weiPerIndivisibleTokenPart) {\r\n\t\treturn ((EURWEI * 184325000 / (now - beginTime + 5760) - EURWEI*5) / DIVISOR);\r\n\t}\r\n\r\n\t/// Returns the total indivisible token parts available for purchase right now.\r\n\tfunction tokensAvailable() public constant when_active returns (uint tokens) {\r\n\t\tuint _currentCap = totalAccounted / currentPrice();\r\n\t\tif (_currentCap >= tokenCap) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn tokenCap - _currentCap;\r\n\t}\r\n\r\n\t/// The largest purchase than can be made at present, not including any\r\n\t/// discount.\r\n\tfunction maxPurchase() public constant when_active returns (uint spend) {\r\n\t\treturn tokenCap * currentPrice() - totalAccounted;\r\n\t}\r\n\r\n\t/// Get the number of `tokens` that would be given if the sender were to\r\n\t/// spend `_value` now. Also tell you what `refund` would be given, if any.\r\n\tfunction theDeal(uint _value)\r\n\t\tpublic\r\n\t\tconstant\r\n\t\twhen_active\r\n\t\treturns (uint accounted, bool refund, uint price)\r\n\t{\r\n\t\tuint _bonus = bonus(_value);\r\n\r\n\t\tprice = currentPrice();\r\n\t\taccounted = _value + _bonus;\r\n\r\n\t\tuint available = tokensAvailable();\r\n\t\tuint tokens = accounted / price;\r\n\t\trefund = (tokens > available);\r\n\t}\r\n\r\n\t/// Any applicable bonus to `_value`.\r\n\tfunction bonus(uint _value)\r\n\t\tpublic\r\n\t\tconstant\r\n\t\twhen_active\r\n\t\treturns (uint extra)\r\n\t{\r\n\t\treturn _value * uint(currentBonus) / 100;\r\n\t}\r\n\r\n\t/// True if the sale is ongoing.\r\n\tfunction isActive() public constant returns (bool) { return now >= beginTime && now < endTime; }\r\n\r\n\t/// True if all buyins have finalised.\r\n\tfunction allFinalised() public constant returns (bool) { return now >= endTime && totalAccounted == totalFinalised; }\r\n\r\n\t/// Returns true if the sender of this transaction is a basic account.\r\n\tfunction isBasicAccount(address _who) internal constant returns (bool) {\r\n\t\tuint senderCodeSize;\r\n\t\tassembly {\r\n\t\t\tsenderCodeSize := extcodesize(_who)\r\n\t\t}\r\n\t    return senderCodeSize == 0;\r\n\t}\r\n\r\n\t// Modifiers:\r\n\r\n\t/// Ensure the sale is ongoing.\r\n\tmodifier when_active { require (isActive()); _; }\r\n\r\n\t/// Ensure the sale has not begun.\r\n\tmodifier before_beginning { require (now < beginTime); _; }\r\n\r\n\t/// Ensure the sale is ended.\r\n\tmodifier when_ended { require (now >= endTime); _; }\r\n\r\n\t/// Ensure we're not halted.\r\n\tmodifier when_not_halted { require (!halted); _; }\r\n\r\n\t/// Ensure `_who` is a participant.\r\n\tmodifier only_buyins(address _who) { require (buyins[_who].accounted != 0); _; }\r\n\r\n\t/// Ensure sender is admin.\r\n\tmodifier only_admin { require (msg.sender == admin); _; }\r\n\r\n\t/// Ensure that the signature is valid, `who` is a certified, basic account,\r\n\t/// the gas price is sufficiently low and the value is sufficiently high.\r\n\tmodifier only_eligible(address who) {\r\n\t\trequire (\r\n\t\t\tverifier.isVerified(who, verifier.USA() | verifier.CHINA() | verifier.SOUTH_KOREA()) &&\r\n\t\t\tisBasicAccount(who) &&\r\n\t\t\tmsg.value >= DUST_LIMIT\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\t/// Ensure sender is not a contract.\r\n\tmodifier only_basic(address who) { require (isBasicAccount(who)); _; }\r\n\r\n\t// State:\r\n\r\n\tstruct Account {\r\n\t\tuint128 accounted;\t// including bonus & hit\r\n\t\tuint128 received;\t// just the amount received, without bonus & hit\r\n\t}\r\n\r\n\t/// Those who have bought in to the auction.\r\n\tmapping (address => Account) public buyins;\r\n\r\n\t/// Total amount of ether received, excluding phantom \"bonus\" ether.\r\n\tuint public totalReceived = 0;\r\n\r\n\t/// Total amount of ether accounted for, including phantom \"bonus\" ether.\r\n\tuint public totalAccounted = 0;\r\n\r\n\t/// Total amount of ether which has been finalised.\r\n\tuint public totalFinalised = 0;\r\n\r\n\t/// The current end time. Gets updated when new funds are received.\r\n\tuint public endTime;\r\n\r\n\t/// The price per token; only valid once the sale has ended and at least one\r\n\t/// participant has finalised.\r\n\tuint public endPrice;\r\n\r\n\t/// Must be false for any public function to be called.\r\n\tbool public halted;\r\n\r\n\t/// The current percentage of bonus that purchasers get.\r\n\tuint8 public currentBonus = 15;\r\n\r\n\t/// The last block that had a new participant.\r\n\tuint32 public lastNewInterest;\r\n\r\n\t// Constants after constructor:\r\n\r\n\t/// The tokens contract.\r\n\tToken public tokenContract;\r\n\r\n\t/// The Notakey verifier contract.\r\n\tNotakeyVerifierForICOP public verifier;\r\n\r\n\t/// The treasury address; where all the Ether goes.\r\n\taddress public treasury;\r\n\r\n\t/// The admin address; auction can be paused or halted at any time by this.\r\n\taddress public admin;\r\n\r\n\t/// The time at which the sale begins.\r\n\tuint public beginTime;\r\n\r\n\t/// Maximum amount of tokens to mint. Once totalAccounted / currentPrice is\r\n\t/// greater than this, the sale ends.\r\n\tuint public tokenCap;\r\n\r\n\t// Era stuff (isolated)\r\n\t/// The era for which the current consolidated data represents.\r\n\tuint public eraIndex;\r\n\r\n\t/// The size of the era in seconds.\r\n\tuint constant public ERA_PERIOD = 5 minutes;\r\n\r\n\t// Static constants:\r\n\r\n\t/// Anything less than this is considered dust and cannot be used to buy in.\r\n\tuint constant public DUST_LIMIT = 5 finney;\r\n\r\n\t//# Statement to actually sign.\r\n\t//# ```js\r\n\t//# statement = function() { this.STATEMENT().map(s => s.substr(28)) }\r\n\t//# ```\r\n\r\n\t/// Minimum duration after sale begins that bonus is active.\r\n\tuint constant public BONUS_MIN_DURATION = 1 hours;\r\n\r\n\t/// Minimum duration after sale begins that bonus is active.\r\n\tuint constant public BONUS_MAX_DURATION = 12 hours;\r\n\r\n\t/// Number of consecutive blocks where there must be no new interest before bonus ends.\r\n\tuint constant public BONUS_LATCH = 2;\r\n\r\n\t/// Number of Wei in one EUR, constant.\r\n\tuint constant public EURWEI = 2000 szabo; // 500 eur ~ 1 eth\r\n\r\n\t/// Initial auction length\r\n\tuint constant public DEFAULT_AUCTION_LENGTH = 2 days;\r\n\r\n\t/// Divisor of the token.\r\n\tuint constant public DIVISOR = 1000;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"ERA_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"bonus\",\"outputs\":[{\"name\":\"extra\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eraIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAccounted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"finalise\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyins\",\"outputs\":[{\"name\":\"accounted\",\"type\":\"uint128\"},{\"name\":\"received\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_MIN_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DUST_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFinalised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_LATCH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAvailable\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyin\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EURWEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEFAULT_AUCTION_LENGTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beginTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastNewInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPurchase\",\"outputs\":[{\"name\":\"spend\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_MAX_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"name\":\"weiPerIndivisibleTokenPart\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"theDeal\",\"outputs\":[{\"name\":\"accounted\",\"type\":\"uint256\"},{\"name\":\"refund\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_received\",\"type\":\"uint128\"}],\"name\":\"inject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStart\",\"type\":\"uint256\"}],\"name\":\"moveStartDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_halted\",\"type\":\"bool\"}],\"name\":\"setHalted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allFinalised\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_trustedClaimIssuer\",\"type\":\"address\"},{\"name\":\"_notakeyClaimRegistry\",\"type\":\"address\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_treasury\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_beginTime\",\"type\":\"uint256\"},{\"name\":\"_tokenCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"accounted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"received\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Buyin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"accounted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"Injected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"era\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"received\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"accounted\",\"type\":\"uint256\"}],\"name\":\"Ticked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Ended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Finalised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Retired\",\"type\":\"event\"}]","ContractName":"SecondPriceAuction","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"000000000000000000000000abb5fe17faaf5f7c9a99d0aaf887994d4a8474e40000000000000000000000005355ecdd65ac4a7fb8593cacc9776c171087f1390000000000000000000000006a130078a1904276b95f037f1ea9823919d19bc000000000000000000000000090f8a8169bdeebab347af5d31c5f874be259c206000000000000000000000000af14b994b95c06fe73839b96919b1c7b2b6276db000000000000000000000000000000000000000000000000000000005c2b3a200000000000000000000000000000000000000000000000000000000438683e68","Library":"","SwarmSource":"bzzr://a121e8ef348f59d27f0916161a6c30bcd1a54052c73adc6fc2b173cd1c929c9e"}]}