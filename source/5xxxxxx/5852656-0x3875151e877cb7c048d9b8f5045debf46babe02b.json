{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSExec {\r\n    function tryExec( address target, bytes calldata, uint value)\r\n             internal\r\n             returns (bool call_ret)\r\n    {\r\n        return target.call.value(value)(calldata);\r\n    }\r\n    function exec( address target, bytes calldata, uint value)\r\n             internal\r\n    {\r\n        if(!tryExec(target, calldata, value)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    // Convenience aliases\r\n    function exec( address t, bytes c )\r\n        internal\r\n    {\r\n        exec(t, c, 0);\r\n    }\r\n    function exec( address t, uint256 v )\r\n        internal\r\n    {\r\n        bytes memory c; exec(t, c, v);\r\n    }\r\n    function tryExec( address t, bytes c )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return tryExec(t, c, 0);\r\n    }\r\n    function tryExec( address t, uint256 v )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        bytes memory c; return tryExec(t, c, v);\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSGroup is DSExec, DSNote {\r\n    address[]  public  members;\r\n    uint       public  quorum;\r\n    uint       public  window;\r\n    uint       public  actionCount;\r\n\r\n    mapping (uint => Action)                     public  actions;\r\n    mapping (uint => mapping (address => bool))  public  confirmedBy;\r\n    mapping (address => bool)                    public  isMember;\r\n\r\n    // Legacy events\r\n    event Proposed   (uint id, bytes calldata);\r\n    event Confirmed  (uint id, address member);\r\n    event Triggered  (uint id);\r\n\r\n    struct Action {\r\n        address  target;\r\n        bytes    calldata;\r\n        uint     value;\r\n\r\n        uint     confirmations;\r\n        uint     deadline;\r\n        bool     triggered;\r\n    }\r\n\r\n    function DSGroup(\r\n        address[]  members_,\r\n        uint       quorum_,\r\n        uint       window_\r\n    ) {\r\n        members  = members_;\r\n        quorum   = quorum_;\r\n        window   = window_;\r\n\r\n        for (uint i = 0; i < members.length; i++) {\r\n            isMember[members[i]] = true;\r\n        }\r\n    }\r\n\r\n    function memberCount() constant returns (uint) {\r\n        return members.length;\r\n    }\r\n\r\n    function target(uint id) constant returns (address) {\r\n        return actions[id].target;\r\n    }\r\n    function calldata(uint id) constant returns (bytes) {\r\n        return actions[id].calldata;\r\n    }\r\n    function value(uint id) constant returns (uint) {\r\n        return actions[id].value;\r\n    }\r\n\r\n    function confirmations(uint id) constant returns (uint) {\r\n        return actions[id].confirmations;\r\n    }\r\n    function deadline(uint id) constant returns (uint) {\r\n        return actions[id].deadline;\r\n    }\r\n    function triggered(uint id) constant returns (bool) {\r\n        return actions[id].triggered;\r\n    }\r\n\r\n    function confirmed(uint id) constant returns (bool) {\r\n        return confirmations(id) >= quorum;\r\n    }\r\n    function expired(uint id) constant returns (bool) {\r\n        return now > deadline(id);\r\n    }\r\n\r\n    function deposit() note payable {\r\n    }\r\n\r\n    function propose(\r\n        address  target,\r\n        bytes    calldata,\r\n        uint     value\r\n    ) onlyMembers note returns (uint id) {\r\n        id = ++actionCount;\r\n\r\n        actions[id].target    = target;\r\n        actions[id].calldata  = calldata;\r\n        actions[id].value     = value;\r\n        actions[id].deadline  = now + window;\r\n\r\n        Proposed(id, calldata);\r\n    }\r\n\r\n    function confirm(uint id) onlyMembers onlyActive(id) note {\r\n        assert(!confirmedBy[id][msg.sender]);\r\n\r\n        confirmedBy[id][msg.sender] = true;\r\n        actions[id].confirmations++;\r\n\r\n        Confirmed(id, msg.sender);\r\n    }\r\n\r\n    function trigger(uint id) onlyMembers onlyActive(id) note {\r\n        assert(confirmed(id));\r\n\r\n        actions[id].triggered = true;\r\n        exec(actions[id].target, actions[id].calldata, actions[id].value);\r\n\r\n        Triggered(id);\r\n    }\r\n\r\n    modifier onlyMembers {\r\n        assert(isMember[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyActive(uint id) {\r\n        assert(!expired(id));\r\n        assert(!triggered(id));\r\n        _;\r\n    }\r\n\r\n    //------------------------------------------------------------------\r\n    // Legacy functions\r\n    //------------------------------------------------------------------\r\n\r\n    function getInfo() constant returns (\r\n        uint  quorum_,\r\n        uint  memberCount,\r\n        uint  window_,\r\n        uint  actionCount_\r\n    ) {\r\n        return (quorum, members.length, window, actionCount);\r\n    }\r\n\r\n    function getActionStatus(uint id) constant returns (\r\n        uint     confirmations,\r\n        uint     deadline,\r\n        bool     triggered,\r\n        address  target,\r\n        uint     value\r\n    ) {\r\n        return (\r\n            actions[id].confirmations,\r\n            actions[id].deadline,\r\n            actions[id].triggered,\r\n            actions[id].target,\r\n            actions[id].value\r\n        );\r\n    }\r\n}\r\n\r\ncontract DSGroupFactory is DSNote {\r\n    mapping (address => bool)  public  isGroup;\r\n\r\n    function newGroup(\r\n        address[]  members,\r\n        uint       quorum,\r\n        uint       window\r\n    ) note returns (DSGroup group) {\r\n        group = new DSGroup(members, quorum, window);\r\n        isGroup[group] = true;\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n\r\n    function S(string s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(s));\r\n    }\r\n\r\n}\r\n\r\ninterface AssetInterface {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    // Events\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n\r\n    //ERC 223\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value, bytes _data) public returns (bool success);\r\n\r\n    // ERC 20\r\n    // PUBLIC METHODS\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    // PUBLIC VIEW METHODS\r\n    function balanceOf(address _owner) view public returns (uint balance);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n}\r\n\r\ncontract DBC {\r\n\r\n    // MODIFIERS\r\n\r\n    modifier pre_cond(bool condition) {\r\n        require(condition);\r\n        _;\r\n    }\r\n\r\n    modifier post_cond(bool condition) {\r\n        _;\r\n        assert(condition);\r\n    }\r\n\r\n    modifier invariant(bool condition) {\r\n        require(condition);\r\n        _;\r\n        assert(condition);\r\n    }\r\n}\r\n\r\ncontract Owned is DBC {\r\n\r\n    // FIELDS\r\n\r\n    address public owner;\r\n\r\n    // NON-CONSTANT METHODS\r\n\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\r\n\r\n    // PRE, POST, INVARIANT CONDITIONS\r\n\r\n    function isOwner() internal returns (bool) { return msg.sender == owner; }\r\n\r\n}\r\n\r\ncontract CanonicalRegistrar is DSThing, DBC {\r\n\r\n    // TYPES\r\n\r\n    struct Asset {\r\n        bool exists; // True if asset is registered here\r\n        bytes32 name; // Human-readable name of the Asset as in ERC223 token standard\r\n        bytes8 symbol; // Human-readable symbol of the Asset as in ERC223 token standard\r\n        uint decimals; // Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\r\n        string url; // URL for additional information of Asset\r\n        string ipfsHash; // Same as url but for ipfs\r\n        address breakIn; // Break in contract on destination chain\r\n        address breakOut; // Break out contract on this chain; A way to leave\r\n        uint[] standards; // compliance with standards like ERC20, ERC223, ERC777, etc. (the uint is the standard number)\r\n        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->Asset` as much as possible. I.e. name same concepts with the same functionSignature.\r\n        uint price; // Price of asset quoted against `QUOTE_ASSET` * 10 ** decimals\r\n        uint timestamp; // Timestamp of last price update of this asset\r\n    }\r\n\r\n    struct Exchange {\r\n        bool exists;\r\n        address adapter; // adapter contract for this exchange\r\n        // One-time note: takesCustody is inverse case of isApproveOnly\r\n        bool takesCustody; // True in case of exchange implementation which requires  are approved when an order is made instead of transfer\r\n        bytes4[] functionSignatures; // Whitelisted function signatures that can be called using `useExternalFunction` in Fund contract. Note: Adhere to a naming convention for `Fund<->ExchangeAdapter` as much as possible. I.e. name same concepts with the same functionSignature.\r\n    }\r\n    // TODO: populate each field here\r\n    // TODO: add whitelistFunction function\r\n\r\n    // FIELDS\r\n\r\n    // Methods fields\r\n    mapping (address => Asset) public assetInformation;\r\n    address[] public registeredAssets;\r\n\r\n    mapping (address => Exchange) public exchangeInformation;\r\n    address[] public registeredExchanges;\r\n\r\n    // METHODS\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /// @notice Registers an Asset information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofAsset is registered\r\n    /// @param ofAsset Address of asset to be registered\r\n    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputDecimals Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputUrl Url for extended information of the asset\r\n    /// @param inputIpfsHash Same as url but for ipfs\r\n    /// @param breakInBreakOut Address of break in and break out contracts on destination chain\r\n    /// @param inputStandards Integers of EIP standards this asset adheres to\r\n    /// @param inputFunctionSignatures Function signatures for whitelisted asset functions\r\n    function registerAsset(\r\n        address ofAsset,\r\n        bytes32 inputName,\r\n        bytes8 inputSymbol,\r\n        uint inputDecimals,\r\n        string inputUrl,\r\n        string inputIpfsHash,\r\n        address[2] breakInBreakOut,\r\n        uint[] inputStandards,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(!assetInformation[ofAsset].exists)\r\n    {\r\n        assetInformation[ofAsset].exists = true;\r\n        registeredAssets.push(ofAsset);\r\n        updateAsset(\r\n            ofAsset,\r\n            inputName,\r\n            inputSymbol,\r\n            inputDecimals,\r\n            inputUrl,\r\n            inputIpfsHash,\r\n            breakInBreakOut,\r\n            inputStandards,\r\n            inputFunctionSignatures\r\n        );\r\n        assert(assetInformation[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Register an exchange information entry\r\n    /// @dev Pre: Only registrar owner should be able to register\r\n    /// @dev Post: Address ofExchange is registered\r\n    /// @param ofExchange Address of the exchange\r\n    /// @param ofExchangeAdapter Address of exchange adapter for this exchange\r\n    /// @param inputTakesCustody Whether this exchange takes custody of tokens before trading\r\n    /// @param inputFunctionSignatures Function signatures for whitelisted exchange functions\r\n    function registerExchange(\r\n        address ofExchange,\r\n        address ofExchangeAdapter,\r\n        bool inputTakesCustody,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(!exchangeInformation[ofExchange].exists)\r\n    {\r\n        exchangeInformation[ofExchange].exists = true;\r\n        registeredExchanges.push(ofExchange);\r\n        updateExchange(\r\n            ofExchange,\r\n            ofExchangeAdapter,\r\n            inputTakesCustody,\r\n            inputFunctionSignatures\r\n        );\r\n        assert(exchangeInformation[ofExchange].exists);\r\n    }\r\n\r\n    /// @notice Updates description information of a registered Asset\r\n    /// @dev Pre: Owner can change an existing entry\r\n    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\r\n    /// @param ofAsset Address of the asset to be updated\r\n    /// @param inputName Human-readable name of the Asset as in ERC223 token standard\r\n    /// @param inputSymbol Human-readable symbol of the Asset as in ERC223 token standard\r\n    /// @param inputUrl Url for extended information of the asset\r\n    /// @param inputIpfsHash Same as url but for ipfs\r\n    function updateAsset(\r\n        address ofAsset,\r\n        bytes32 inputName,\r\n        bytes8 inputSymbol,\r\n        uint inputDecimals,\r\n        string inputUrl,\r\n        string inputIpfsHash,\r\n        address[2] ofBreakInBreakOut,\r\n        uint[] inputStandards,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(assetInformation[ofAsset].exists)\r\n    {\r\n        Asset asset = assetInformation[ofAsset];\r\n        asset.name = inputName;\r\n        asset.symbol = inputSymbol;\r\n        asset.decimals = inputDecimals;\r\n        asset.url = inputUrl;\r\n        asset.ipfsHash = inputIpfsHash;\r\n        asset.breakIn = ofBreakInBreakOut[0];\r\n        asset.breakOut = ofBreakInBreakOut[1];\r\n        asset.standards = inputStandards;\r\n        asset.functionSignatures = inputFunctionSignatures;\r\n    }\r\n\r\n    function updateExchange(\r\n        address ofExchange,\r\n        address ofExchangeAdapter,\r\n        bool inputTakesCustody,\r\n        bytes4[] inputFunctionSignatures\r\n    )\r\n        auth\r\n        pre_cond(exchangeInformation[ofExchange].exists)\r\n    {\r\n        Exchange exchange = exchangeInformation[ofExchange];\r\n        exchange.adapter = ofExchangeAdapter;\r\n        exchange.takesCustody = inputTakesCustody;\r\n        exchange.functionSignatures = inputFunctionSignatures;\r\n    }\r\n\r\n    // TODO: check max size of array before remaking this becomes untenable\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofAsset address for which specific information is requested\r\n    function removeAsset(\r\n        address ofAsset,\r\n        uint assetIndex\r\n    )\r\n        auth\r\n        pre_cond(assetInformation[ofAsset].exists)\r\n    {\r\n        require(registeredAssets[assetIndex] == ofAsset);\r\n        delete assetInformation[ofAsset]; // Sets exists boolean to false\r\n        delete registeredAssets[assetIndex];\r\n        for (uint i = assetIndex; i < registeredAssets.length-1; i++) {\r\n            registeredAssets[i] = registeredAssets[i+1];\r\n        }\r\n        registeredAssets.length--;\r\n        assert(!assetInformation[ofAsset].exists);\r\n    }\r\n\r\n    /// @notice Deletes an existing entry\r\n    /// @dev Owner can delete an existing entry\r\n    /// @param ofExchange address for which specific information is requested\r\n    /// @param exchangeIndex index of the exchange in array\r\n    function removeExchange(\r\n        address ofExchange,\r\n        uint exchangeIndex\r\n    )\r\n        auth\r\n        pre_cond(exchangeInformation[ofExchange].exists)\r\n    {\r\n        require(registeredExchanges[exchangeIndex] == ofExchange);\r\n        delete exchangeInformation[ofExchange];\r\n        delete registeredExchanges[exchangeIndex];\r\n        for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {\r\n            registeredExchanges[i] = registeredExchanges[i+1];\r\n        }\r\n        registeredExchanges.length--;\r\n        assert(!exchangeInformation[ofExchange].exists);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // get asset specific information\r\n    function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }\r\n    function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }\r\n    function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }\r\n    function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }\r\n    function getRegisteredAssets() view returns (address[]) { return registeredAssets; }\r\n    function assetMethodIsAllowed(\r\n        address ofAsset, bytes4 querySignature\r\n    )\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == querySignature) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // get exchange-specific information\r\n    function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }\r\n    function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }\r\n    function getExchangeInformation(address ofExchange)\r\n        view\r\n        returns (address, bool)\r\n    {\r\n        Exchange exchange = exchangeInformation[ofExchange];\r\n        return (\r\n            exchange.adapter,\r\n            exchange.takesCustody\r\n        );\r\n    }\r\n    function getExchangeFunctionSignatures(address ofExchange)\r\n        view\r\n        returns (bytes4[])\r\n    {\r\n        return exchangeInformation[ofExchange].functionSignatures;\r\n    }\r\n    function exchangeMethodIsAllowed(\r\n        address ofExchange, bytes4 querySignature\r\n    )\r\n        returns (bool)\r\n    {\r\n        bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;\r\n        for (uint i = 0; i < signatures.length; i++) {\r\n            if (signatures[i] == querySignature) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\ninterface SimplePriceFeedInterface {\r\n\r\n    // EVENTS\r\n\r\n    event PriceUpdated(bytes32 hash);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function update(address[] ofAssets, uint[] newPrices) external;\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get price feed operation specific information\r\n    function getQuoteAsset() view returns (address);\r\n    function getLastUpdateId() view returns (uint);\r\n    // Get asset specific information as updated in price feed\r\n    function getPrice(address ofAsset) view returns (uint price, uint timestamp);\r\n    function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);\r\n}\r\n\r\ncontract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {\r\n\r\n    // TYPES\r\n    struct Data {\r\n        uint price;\r\n        uint timestamp;\r\n    }\r\n\r\n    // FIELDS\r\n    mapping(address => Data) public assetsToPrices;\r\n\r\n    // Constructor fields\r\n    address public QUOTE_ASSET; // Asset of a portfolio against which all other assets are priced\r\n\r\n    // Contract-level variables\r\n    uint public updateId;        // Update counter for this pricefeed; used as a check during investment\r\n    CanonicalRegistrar public registrar;\r\n    CanonicalPriceFeed public superFeed;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param ofRegistrar Address of canonical registrar\r\n    /// @param ofSuperFeed Address of superfeed\r\n    function SimplePriceFeed(\r\n        address ofRegistrar,\r\n        address ofQuoteAsset,\r\n        address ofSuperFeed\r\n    ) {\r\n        registrar = CanonicalRegistrar(ofRegistrar);\r\n        QUOTE_ASSET = ofQuoteAsset;\r\n        superFeed = CanonicalPriceFeed(ofSuperFeed);\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    /// @param newPrices list of prices for each of the assets\r\n    function update(address[] ofAssets, uint[] newPrices)\r\n        external\r\n        auth\r\n    {\r\n        _updatePrices(ofAssets, newPrices);\r\n    }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // Get pricefeed specific information\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    /**\r\n    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\r\n    @dev Asset has been registered\r\n    @param ofAsset Asset for which price should be returned\r\n    @return {\r\n      \"price\": \"Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers\",\r\n      \"timestamp\": \"When the asset's price was updated\"\r\n    }\r\n    */\r\n    function getPrice(address ofAsset)\r\n        view\r\n        returns (uint price, uint timestamp)\r\n    {\r\n        Data data = assetsToPrices[ofAsset];\r\n        return (data.price, data.timestamp);\r\n    }\r\n\r\n    /**\r\n    @notice Price of a registered asset in format (bool areRecent, uint[] prices, uint[] decimals)\r\n    @dev Convention for price formatting: mul(price, 10 ** decimal), to avoid floating numbers\r\n    @param ofAssets Assets for which prices should be returned\r\n    @return {\r\n        \"prices\":       \"Array of prices\",\r\n        \"timestamps\":   \"Array of timestamps\",\r\n    }\r\n    */\r\n    function getPrices(address[] ofAssets)\r\n        view\r\n        returns (uint[], uint[])\r\n    {\r\n        uint[] memory prices = new uint[](ofAssets.length);\r\n        uint[] memory timestamps = new uint[](ofAssets.length);\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            var (price, timestamp) = getPrice(ofAssets[i]);\r\n            prices[i] = price;\r\n            timestamps[i] = timestamp;\r\n        }\r\n        return (prices, timestamps);\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /// @dev Internal so that feeds inheriting this one are not obligated to have an exposed update(...) method, but can still perform updates\r\n    function _updatePrices(address[] ofAssets, uint[] newPrices)\r\n        internal\r\n        pre_cond(ofAssets.length == newPrices.length)\r\n    {\r\n        updateId++;\r\n        for (uint i = 0; i < ofAssets.length; ++i) {\r\n            require(registrar.assetIsRegistered(ofAssets[i]));\r\n            require(assetsToPrices[ofAssets[i]].timestamp != now); // prevent two updates in one block\r\n            assetsToPrices[ofAssets[i]].timestamp = now;\r\n            assetsToPrices[ofAssets[i]].price = newPrices[i];\r\n        }\r\n        emit PriceUpdated(keccak256(ofAssets, newPrices));\r\n    }\r\n}\r\n\r\ncontract StakingPriceFeed is SimplePriceFeed {\r\n\r\n    OperatorStaking public stakingContract;\r\n    AssetInterface public stakingToken;\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param ofRegistrar Address of canonical registrar\r\n    /// @param ofSuperFeed Address of superfeed\r\n    function StakingPriceFeed(\r\n        address ofRegistrar,\r\n        address ofQuoteAsset,\r\n        address ofSuperFeed\r\n    )\r\n        SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)\r\n    {\r\n        stakingContract = OperatorStaking(ofSuperFeed); // canonical feed *is* staking contract\r\n        stakingToken = AssetInterface(stakingContract.stakingToken());\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @param amount Number of tokens to stake for this feed\r\n    /// @param data Data may be needed for some future applications (can be empty for now)\r\n    function depositStake(uint amount, bytes data)\r\n        external\r\n        auth\r\n    {\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n        require(stakingToken.approve(stakingContract, amount));\r\n        stakingContract.stake(amount, data);\r\n    }\r\n\r\n    /// @param amount Number of tokens to unstake for this feed\r\n    /// @param data Data may be needed for some future applications (can be empty for now)\r\n    function unstake(uint amount, bytes data) {\r\n        stakingContract.unstake(amount, data);\r\n    }\r\n\r\n    function withdrawStake()\r\n        external\r\n        auth\r\n    {\r\n        uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));\r\n        stakingContract.withdrawStake();\r\n        require(stakingToken.transfer(msg.sender, amountToWithdraw));\r\n    }\r\n}\r\n\r\ncontract OperatorStaking is DBC {\r\n\r\n    // EVENTS\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\r\n    event StakeBurned(address indexed user, uint256 amount, bytes data);\r\n\r\n    // TYPES\r\n\r\n    struct StakeData {\r\n        uint amount;\r\n        address staker;\r\n    }\r\n\r\n    // Circular linked list\r\n    struct Node {\r\n        StakeData data;\r\n        uint prev;\r\n        uint next;\r\n    }\r\n\r\n    // FIELDS\r\n\r\n    // INTERNAL FIELDS\r\n    Node[] internal stakeNodes; // Sorted circular linked list nodes containing stake data (Built on top https://programtheblockchain.com/posts/2018/03/30/storage-patterns-doubly-linked-list/)\r\n\r\n    // PUBLIC FIELDS\r\n    uint public minimumStake;\r\n    uint public numOperators;\r\n    uint public withdrawalDelay;\r\n    mapping (address => bool) public isRanked;\r\n    mapping (address => uint) public latestUnstakeTime;\r\n    mapping (address => uint) public stakeToWithdraw;\r\n    mapping (address => uint) public stakedAmounts;\r\n    uint public numStakers; // Current number of stakers (Needed because of array holes)\r\n    AssetInterface public stakingToken;\r\n\r\n    // TODO: consider renaming \"operator\" depending on how this is implemented\r\n    //  (i.e. is pricefeed staking itself?)\r\n    function OperatorStaking(\r\n        AssetInterface _stakingToken,\r\n        uint _minimumStake,\r\n        uint _numOperators,\r\n        uint _withdrawalDelay\r\n    )\r\n        public\r\n    {\r\n        require(address(_stakingToken) != address(0));\r\n        stakingToken = _stakingToken;\r\n        minimumStake = _minimumStake;\r\n        numOperators = _numOperators;\r\n        withdrawalDelay = _withdrawalDelay;\r\n        StakeData memory temp = StakeData({ amount: 0, staker: address(0) });\r\n        stakeNodes.push(Node(temp, 0, 0));\r\n    }\r\n\r\n    // METHODS : STAKING\r\n\r\n    function stake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n        pre_cond(amount >= minimumStake)\r\n    {\r\n        uint tailNodeId = stakeNodes[0].prev;\r\n        stakedAmounts[msg.sender] += amount;\r\n        updateStakerRanking(msg.sender);\r\n        require(stakingToken.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n\r\n    function unstake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n    {\r\n        uint preStake = stakedAmounts[msg.sender];\r\n        uint postStake = preStake - amount;\r\n        require(postStake >= minimumStake || postStake == 0);\r\n        require(stakedAmounts[msg.sender] >= amount);\r\n        latestUnstakeTime[msg.sender] = block.timestamp;\r\n        stakedAmounts[msg.sender] -= amount;\r\n        stakeToWithdraw[msg.sender] += amount;\r\n        updateStakerRanking(msg.sender);\r\n        emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);\r\n    }\r\n\r\n    function withdrawStake()\r\n        public\r\n        pre_cond(stakeToWithdraw[msg.sender] > 0)\r\n        pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)\r\n    {\r\n        uint amount = stakeToWithdraw[msg.sender];\r\n        stakeToWithdraw[msg.sender] = 0;\r\n        require(stakingToken.transfer(msg.sender, amount));\r\n    }\r\n\r\n    // VIEW FUNCTIONS\r\n\r\n    function isValidNode(uint id) view returns (bool) {\r\n        // 0 is a sentinel and therefore invalid.\r\n        // A valid node is the head or has a previous node.\r\n        return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);\r\n    }\r\n\r\n    function searchNode(address staker) view returns (uint) {\r\n        uint current = stakeNodes[0].next;\r\n        while (isValidNode(current)) {\r\n            if (staker == stakeNodes[current].data.staker) {\r\n                return current;\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function isOperator(address user) view returns (bool) {\r\n        address[] memory operators = getOperators();\r\n        for (uint i; i < operators.length; i++) {\r\n            if (operators[i] == user) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getOperators()\r\n        view\r\n        returns (address[])\r\n    {\r\n        uint arrLength = (numOperators > numStakers) ?\r\n            numStakers :\r\n            numOperators;\r\n        address[] memory operators = new address[](arrLength);\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < arrLength; i++) {\r\n            operators[i] = stakeNodes[current].data.staker;\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return operators;\r\n    }\r\n\r\n    function getStakersAndAmounts()\r\n        view\r\n        returns (address[], uint[])\r\n    {\r\n        address[] memory stakers = new address[](numStakers);\r\n        uint[] memory amounts = new uint[](numStakers);\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < numStakers; i++) {\r\n            stakers[i] = stakeNodes[current].data.staker;\r\n            amounts[i] = stakeNodes[current].data.amount;\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return (stakers, amounts);\r\n    }\r\n\r\n    function totalStakedFor(address user)\r\n        view\r\n        returns (uint)\r\n    {\r\n        return stakedAmounts[user];\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    // DOUBLY-LINKED LIST\r\n\r\n    function insertNodeSorted(uint amount, address staker) internal returns (uint) {\r\n        uint current = stakeNodes[0].next;\r\n        if (current == 0) return insertNodeAfter(0, amount, staker);\r\n        while (isValidNode(current)) {\r\n            if (amount > stakeNodes[current].data.amount) {\r\n                break;\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return insertNodeBefore(current, amount, staker);\r\n    }\r\n\r\n    function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {\r\n\r\n        // 0 is allowed here to insert at the beginning.\r\n        require(id == 0 || isValidNode(id));\r\n\r\n        Node storage node = stakeNodes[id];\r\n\r\n        stakeNodes.push(Node({\r\n            data: StakeData(amount, staker),\r\n            prev: id,\r\n            next: node.next\r\n        }));\r\n\r\n        newID = stakeNodes.length - 1;\r\n\r\n        stakeNodes[node.next].prev = newID;\r\n        node.next = newID;\r\n        numStakers++;\r\n    }\r\n\r\n    function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {\r\n        return insertNodeAfter(stakeNodes[id].prev, amount, staker);\r\n    }\r\n\r\n    function removeNode(uint id) internal {\r\n        require(isValidNode(id));\r\n\r\n        Node storage node = stakeNodes[id];\r\n\r\n        stakeNodes[node.next].prev = node.prev;\r\n        stakeNodes[node.prev].next = node.next;\r\n\r\n        delete stakeNodes[id];\r\n        numStakers--;\r\n    }\r\n\r\n    // UPDATING OPERATORS\r\n\r\n    function updateStakerRanking(address _staker) internal {\r\n        uint newStakedAmount = stakedAmounts[_staker];\r\n        if (newStakedAmount == 0) {\r\n            isRanked[_staker] = false;\r\n            removeStakerFromArray(_staker);\r\n        } else if (isRanked[_staker]) {\r\n            removeStakerFromArray(_staker);\r\n            insertNodeSorted(newStakedAmount, _staker);\r\n        } else {\r\n            isRanked[_staker] = true;\r\n            insertNodeSorted(newStakedAmount, _staker);\r\n        }\r\n    }\r\n\r\n    function removeStakerFromArray(address _staker) internal {\r\n        uint id = searchNode(_staker);\r\n        require(id > 0);\r\n        removeNode(id);\r\n    }\r\n\r\n}\r\n\r\ncontract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {\r\n\r\n    // EVENTS\r\n    event SetupPriceFeed(address ofPriceFeed);\r\n\r\n    struct HistoricalPrices {\r\n        address[] assets;\r\n        uint[] prices;\r\n        uint timestamp;\r\n    }\r\n\r\n    // FIELDS\r\n    bool public updatesAreAllowed = true;\r\n    uint public minimumPriceCount = 1;\r\n    uint public VALIDITY;\r\n    uint public INTERVAL;\r\n    mapping (address => bool) public isStakingFeed; // If the Staking Feed has been created through this contract\r\n    HistoricalPrices[] public priceHistory;\r\n\r\n    // METHODS\r\n\r\n    // CONSTRUCTOR\r\n\r\n    /// @dev Define and register a quote asset against which all prices are measured/based against\r\n    /// @param ofStakingAsset Address of staking asset (may or may not be quoteAsset)\r\n    /// @param ofQuoteAsset Address of quote asset\r\n    /// @param quoteAssetName Name of quote asset\r\n    /// @param quoteAssetSymbol Symbol for quote asset\r\n    /// @param quoteAssetDecimals Decimal places for quote asset\r\n    /// @param quoteAssetUrl URL related to quote asset\r\n    /// @param quoteAssetIpfsHash IPFS hash associated with quote asset\r\n    /// @param quoteAssetBreakInBreakOut Break-in/break-out for quote asset on destination chain\r\n    /// @param quoteAssetStandards EIP standards quote asset adheres to\r\n    /// @param quoteAssetFunctionSignatures Whitelisted functions of quote asset contract\r\n    // /// @param interval Number of seconds between pricefeed updates (this interval is not enforced on-chain, but should be followed by the datafeed maintainer)\r\n    // /// @param validity Number of seconds that datafeed update information is valid for\r\n    /// @param ofGovernance Address of contract governing the Canonical PriceFeed\r\n    function CanonicalPriceFeed(\r\n        address ofStakingAsset,\r\n        address ofQuoteAsset, // Inital entry in asset registrar contract is Melon (QUOTE_ASSET)\r\n        bytes32 quoteAssetName,\r\n        bytes8 quoteAssetSymbol,\r\n        uint quoteAssetDecimals,\r\n        string quoteAssetUrl,\r\n        string quoteAssetIpfsHash,\r\n        address[2] quoteAssetBreakInBreakOut,\r\n        uint[] quoteAssetStandards,\r\n        bytes4[] quoteAssetFunctionSignatures,\r\n        uint[2] updateInfo, // interval, validity\r\n        uint[3] stakingInfo, // minStake, numOperators, unstakeDelay\r\n        address ofGovernance\r\n    )\r\n        OperatorStaking(\r\n            AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]\r\n        )\r\n        SimplePriceFeed(address(this), ofQuoteAsset, address(0))\r\n    {\r\n        registerAsset(\r\n            ofQuoteAsset,\r\n            quoteAssetName,\r\n            quoteAssetSymbol,\r\n            quoteAssetDecimals,\r\n            quoteAssetUrl,\r\n            quoteAssetIpfsHash,\r\n            quoteAssetBreakInBreakOut,\r\n            quoteAssetStandards,\r\n            quoteAssetFunctionSignatures\r\n        );\r\n        INTERVAL = updateInfo[0];\r\n        VALIDITY = updateInfo[1];\r\n        setOwner(ofGovernance);\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n\r\n    /// @notice Create a new StakingPriceFeed\r\n    function setupStakingPriceFeed() external {\r\n        address ofStakingPriceFeed = new StakingPriceFeed(\r\n            address(this),\r\n            stakingToken,\r\n            address(this)\r\n        );\r\n        isStakingFeed[ofStakingPriceFeed] = true;\r\n        StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);\r\n        emit SetupPriceFeed(ofStakingPriceFeed);\r\n    }\r\n\r\n    /// @dev override inherited update function to prevent manual update from authority\r\n    function update() external { revert(); }\r\n\r\n    /// @dev Burn state for a pricefeed operator\r\n    /// @param user Address of pricefeed operator to burn the stake from\r\n    function burnStake(address user)\r\n        external\r\n        auth\r\n    {\r\n        uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);\r\n        stakedAmounts[user] = 0;\r\n        stakeToWithdraw[user] = 0;\r\n        updateStakerRanking(user);\r\n        emit StakeBurned(user, totalToBurn, \"\");\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    // STAKING\r\n\r\n    function stake(\r\n        uint amount,\r\n        bytes data\r\n    )\r\n        public\r\n        pre_cond(isStakingFeed[msg.sender])\r\n    {\r\n        OperatorStaking.stake(amount, data);\r\n    }\r\n\r\n    // function stakeFor(\r\n    //     address user,\r\n    //     uint amount,\r\n    //     bytes data\r\n    // )\r\n    //     public\r\n    //     pre_cond(isStakingFeed[user])\r\n    // {\r\n\r\n    //     OperatorStaking.stakeFor(user, amount, data);\r\n    // }\r\n\r\n    // AGGREGATION\r\n\r\n    /// @dev Only Owner; Same sized input arrays\r\n    /// @dev Updates price of asset relative to QUOTE_ASSET\r\n    /** Ex:\r\n     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\r\n     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\r\n     *  and let EUR-T decimals == 8.\r\n     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\r\n     */\r\n    /// @param ofAssets list of asset addresses\r\n    function collectAndUpdate(address[] ofAssets)\r\n        public\r\n        auth\r\n        pre_cond(updatesAreAllowed)\r\n    {\r\n        uint[] memory newPrices = pricesToCommit(ofAssets);\r\n        priceHistory.push(\r\n            HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})\r\n        );\r\n        _updatePrices(ofAssets, newPrices);\r\n    }\r\n\r\n    function pricesToCommit(address[] ofAssets)\r\n        view\r\n        returns (uint[])\r\n    {\r\n        address[] memory operators = getOperators();\r\n        uint[] memory newPrices = new uint[](ofAssets.length);\r\n        for (uint i = 0; i < ofAssets.length; i++) {\r\n            uint[] memory assetPrices = new uint[](operators.length);\r\n            for (uint j = 0; j < operators.length; j++) {\r\n                SimplePriceFeed feed = SimplePriceFeed(operators[j]);\r\n                var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);\r\n                if (now > add(timestamp, VALIDITY)) {\r\n                    continue; // leaves a zero in the array (dealt with later)\r\n                }\r\n                assetPrices[j] = price;\r\n            }\r\n            newPrices[i] = medianize(assetPrices);\r\n        }\r\n        return newPrices;\r\n    }\r\n\r\n    /// @dev from MakerDao medianizer contract\r\n    function medianize(uint[] unsorted)\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint numValidEntries;\r\n        for (uint i = 0; i < unsorted.length; i++) {\r\n            if (unsorted[i] != 0) {\r\n                numValidEntries++;\r\n            }\r\n        }\r\n        if (numValidEntries < minimumPriceCount) {\r\n            revert();\r\n        }\r\n        uint counter;\r\n        uint[] memory out = new uint[](numValidEntries);\r\n        for (uint j = 0; j < unsorted.length; j++) {\r\n            uint item = unsorted[j];\r\n            if (item != 0) {    // skip zero (invalid) entries\r\n                if (counter == 0 || item >= out[counter - 1]) {\r\n                    out[counter] = item;  // item is larger than last in array (we are home)\r\n                } else {\r\n                    uint k = 0;\r\n                    while (item >= out[k]) {\r\n                        k++;  // get to where element belongs (between smaller and larger items)\r\n                    }\r\n                    for (uint l = counter; l > k; l--) {\r\n                        out[l] = out[l - 1];    // bump larger elements rightward to leave slot\r\n                    }\r\n                    out[k] = item;\r\n                }\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        uint value;\r\n        if (counter % 2 == 0) {\r\n            uint value1 = uint(out[(counter / 2) - 1]);\r\n            uint value2 = uint(out[(counter / 2)]);\r\n            value = add(value1, value2) / 2;\r\n        } else {\r\n            value = out[(counter - 1) / 2];\r\n        }\r\n        return value;\r\n    }\r\n\r\n    function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }\r\n    function enableUpdates() auth { updatesAreAllowed = true; }\r\n    function disableUpdates() auth { updatesAreAllowed = false; }\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    // FEED INFORMATION\r\n\r\n    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\r\n    function getInterval() view returns (uint) { return INTERVAL; }\r\n    function getValidity() view returns (uint) { return VALIDITY; }\r\n    function getLastUpdateId() view returns (uint) { return updateId; }\r\n\r\n    // PRICES\r\n\r\n    /// @notice Whether price of asset has been updated less than VALIDITY seconds ago\r\n    /// @param ofAsset Asset in registrar\r\n    /// @return isRecent Price information ofAsset is recent\r\n    function hasRecentPrice(address ofAsset)\r\n        view\r\n        pre_cond(assetIsRegistered(ofAsset))\r\n        returns (bool isRecent)\r\n    {\r\n        var ( , timestamp) = getPrice(ofAsset);\r\n        return (sub(now, timestamp) <= VALIDITY);\r\n    }\r\n\r\n    /// @notice Whether prices of assets have been updated less than VALIDITY seconds ago\r\n    /// @param ofAssets All assets in registrar\r\n    /// @return isRecent Price information ofAssets array is recent\r\n    function hasRecentPrices(address[] ofAssets)\r\n        view\r\n        returns (bool areRecent)\r\n    {\r\n        for (uint i; i < ofAssets.length; i++) {\r\n            if (!hasRecentPrice(ofAssets[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getPriceInfo(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint price, uint assetDecimals)\r\n    {\r\n        isRecent = hasRecentPrice(ofAsset);\r\n        (price, ) = getPrice(ofAsset);\r\n        assetDecimals = getDecimals(ofAsset);\r\n    }\r\n\r\n    /**\r\n    @notice Gets inverted price of an asset\r\n    @dev Asset has been initialised and its price is non-zero\r\n    @dev Existing price ofAssets quoted in QUOTE_ASSET (convention)\r\n    @param ofAsset Asset for which inverted price should be return\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"invertedPrice\": \"Price based (instead of quoted) against QUOTE_ASSET\",\r\n        \"assetDecimals\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getInvertedPriceInfo(address ofAsset)\r\n        view\r\n        returns (bool isRecent, uint invertedPrice, uint assetDecimals)\r\n    {\r\n        uint inputPrice;\r\n        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\r\n        (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);\r\n\r\n        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\r\n        uint quoteDecimals = getDecimals(QUOTE_ASSET);\r\n\r\n        return (\r\n            isRecent,\r\n            mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,\r\n            quoteDecimals   // TODO: check on this; shouldn't it be assetDecimals?\r\n        );\r\n    }\r\n\r\n    /**\r\n    @notice Gets reference price of an asset pair\r\n    @dev One of the address is equal to quote asset\r\n    @dev either ofBase == QUOTE_ASSET or ofQuote == QUOTE_ASSET\r\n    @param ofBase Address of base asset\r\n    @param ofQuote Address of quote asset\r\n    @return {\r\n        \"isRecent\": \"Whether the price is fresh, given VALIDITY interval\",\r\n        \"referencePrice\": \"Reference price\",\r\n        \"decimal\": \"Decimal places for this asset\"\r\n    }\r\n    */\r\n    function getReferencePriceInfo(address ofBase, address ofQuote)\r\n        view\r\n        returns (bool isRecent, uint referencePrice, uint decimal)\r\n    {\r\n        if (getQuoteAsset() == ofQuote) {\r\n            (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);\r\n        } else if (getQuoteAsset() == ofBase) {\r\n            (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);\r\n        } else {\r\n            revert(); // no suitable reference price available\r\n        }\r\n    }\r\n\r\n    /// @notice Gets price of Order\r\n    /// @param sellAsset Address of the asset to be sold\r\n    /// @param buyAsset Address of the asset to be bought\r\n    /// @param sellQuantity Quantity in base units being sold of sellAsset\r\n    /// @param buyQuantity Quantity in base units being bought of buyAsset\r\n    /// @return orderPrice Price as determined by an order\r\n    function getOrderPriceInfo(\r\n        address sellAsset,\r\n        address buyAsset,\r\n        uint sellQuantity,\r\n        uint buyQuantity\r\n    )\r\n        view\r\n        returns (uint orderPrice)\r\n    {\r\n        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\r\n    }\r\n\r\n    /// @notice Checks whether data exists for a given asset pair\r\n    /// @dev Prices are only upated against QUOTE_ASSET\r\n    /// @param sellAsset Asset for which check to be done if data exists\r\n    /// @param buyAsset Asset for which check to be done if data exists\r\n    /// @return Whether assets exist for given asset pair\r\n    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\r\n        view\r\n        returns (bool isExistent)\r\n    {\r\n        return\r\n            hasRecentPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            hasRecentPrice(buyAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\r\n            (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) && // One asset must be QUOTE_ASSET\r\n            (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET); // Pair must consists of diffrent assets\r\n    }\r\n\r\n    /// @return Sparse array of addresses of owned pricefeeds\r\n    function getPriceFeedsByOwner(address _owner)\r\n        view\r\n        returns(address[])\r\n    {\r\n        address[] memory ofPriceFeeds = new address[](numStakers);\r\n        if (numStakers == 0) return ofPriceFeeds;\r\n        uint current = stakeNodes[0].next;\r\n        for (uint i; i < numStakers; i++) {\r\n            StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);\r\n            if (stakingFeed.owner() == _owner) {\r\n                ofPriceFeeds[i] = address(stakingFeed);\r\n            }\r\n            current = stakeNodes[current].next;\r\n        }\r\n        return ofPriceFeeds;\r\n    }\r\n\r\n    function getHistoryLength() returns (uint) { return priceHistory.length; }\r\n\r\n    function getHistoryAt(uint id) returns (address[], uint[], uint) {\r\n        address[] memory assets = priceHistory[id].assets;\r\n        uint[] memory prices = priceHistory[id].prices;\r\n        uint timestamp = priceHistory[id].timestamp;\r\n        return (assets, prices, timestamp);\r\n    }\r\n}\r\n\r\ninterface VersionInterface {\r\n\r\n    // EVENTS\r\n\r\n    event FundUpdated(uint id);\r\n\r\n    // PUBLIC METHODS\r\n\r\n    function shutDown() external;\r\n\r\n    function setupFund(\r\n        bytes32 ofFundName,\r\n        address ofQuoteAsset,\r\n        uint ofManagementFee,\r\n        uint ofPerformanceFee,\r\n        address ofCompliance,\r\n        address ofRiskMgmt,\r\n        address[] ofExchanges,\r\n        address[] ofDefaultAssets,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    );\r\n    function shutDownFund(address ofFund);\r\n\r\n    // PUBLIC VIEW METHODS\r\n\r\n    function getNativeAsset() view returns (address);\r\n    function getFundById(uint withId) view returns (address);\r\n    function getLastFundId() view returns (uint);\r\n    function getFundByManager(address ofManager) view returns (address);\r\n    function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"ofExchange\",\"type\":\"address\"},{\"name\":\"querySignature\",\"type\":\"bytes4\"}],\"name\":\"exchangeMethodIsAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAssets\",\"type\":\"address[]\"}],\"name\":\"hasRecentPrices\",\"outputs\":[{\"name\":\"areRecent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"},{\"name\":\"inputName\",\"type\":\"bytes32\"},{\"name\":\"inputSymbol\",\"type\":\"bytes8\"},{\"name\":\"inputDecimals\",\"type\":\"uint256\"},{\"name\":\"inputUrl\",\"type\":\"string\"},{\"name\":\"inputIpfsHash\",\"type\":\"string\"},{\"name\":\"ofBreakInBreakOut\",\"type\":\"address[2]\"},{\"name\":\"inputStandards\",\"type\":\"uint256[]\"},{\"name\":\"inputFunctionSignatures\",\"type\":\"bytes4[]\"}],\"name\":\"updateAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastUpdateId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"assetIsRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"},{\"name\":\"assetIndex\",\"type\":\"uint256\"}],\"name\":\"removeAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStakingFeed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isValidNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAssets\",\"type\":\"address[]\"},{\"name\":\"newPrices\",\"type\":\"uint256[]\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableUpdates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VALIDITY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCount\",\"type\":\"uint256\"}],\"name\":\"setMinimumPriceCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"totalStakedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getHistoryLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"superFeed\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"},{\"name\":\"inputName\",\"type\":\"bytes32\"},{\"name\":\"inputSymbol\",\"type\":\"bytes8\"},{\"name\":\"inputDecimals\",\"type\":\"uint256\"},{\"name\":\"inputUrl\",\"type\":\"string\"},{\"name\":\"inputIpfsHash\",\"type\":\"string\"},{\"name\":\"breakInBreakOut\",\"type\":\"address[2]\"},{\"name\":\"inputStandards\",\"type\":\"uint256[]\"},{\"name\":\"inputFunctionSignatures\",\"type\":\"bytes4[]\"}],\"name\":\"registerAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"},{\"name\":\"querySignature\",\"type\":\"bytes4\"}],\"name\":\"assetMethodIsAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numStakers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofExchange\",\"type\":\"address\"}],\"name\":\"getExchangeFunctionSignatures\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableUpdates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakersAndAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"updatesAreAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofExchange\",\"type\":\"address\"},{\"name\":\"ofExchangeAdapter\",\"type\":\"address\"},{\"name\":\"inputTakesCustody\",\"type\":\"bool\"},{\"name\":\"inputFunctionSignatures\",\"type\":\"bytes4[]\"}],\"name\":\"registerExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INTERVAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setupStakingPriceFeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getPriceInfo\",\"outputs\":[{\"name\":\"isRecent\",\"type\":\"bool\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"assetDecimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAssets\",\"type\":\"address[]\"}],\"name\":\"getPrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getPriceFeedsByOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getInvertedPriceInfo\",\"outputs\":[{\"name\":\"isRecent\",\"type\":\"bool\"},{\"name\":\"invertedPrice\",\"type\":\"uint256\"},{\"name\":\"assetDecimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellAsset\",\"type\":\"address\"},{\"name\":\"buyAsset\",\"type\":\"address\"},{\"name\":\"sellQuantity\",\"type\":\"uint256\"},{\"name\":\"buyQuantity\",\"type\":\"uint256\"}],\"name\":\"getOrderPriceInfo\",\"outputs\":[{\"name\":\"orderPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofExchange\",\"type\":\"address\"},{\"name\":\"ofExchangeAdapter\",\"type\":\"address\"},{\"name\":\"inputTakesCustody\",\"type\":\"bool\"},{\"name\":\"inputFunctionSignatures\",\"type\":\"bytes4[]\"}],\"name\":\"updateExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"searchNode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredAssets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofBase\",\"type\":\"address\"},{\"name\":\"ofQuote\",\"type\":\"address\"}],\"name\":\"getReferencePriceInfo\",\"outputs\":[{\"name\":\"isRecent\",\"type\":\"bool\"},{\"name\":\"referencePrice\",\"type\":\"uint256\"},{\"name\":\"decimal\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchangeInformation\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"adapter\",\"type\":\"address\"},{\"name\":\"takesCustody\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegisteredExchanges\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeToWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceHistory\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofExchange\",\"type\":\"address\"},{\"name\":\"exchangeIndex\",\"type\":\"uint256\"}],\"name\":\"removeExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetsToPrices\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"hasRecentPrice\",\"outputs\":[{\"name\":\"isRecent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"unsorted\",\"type\":\"uint256[]\"}],\"name\":\"medianize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"updateId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ofAssets\",\"type\":\"address[]\"}],\"name\":\"collectAndUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredExchanges\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getSymbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAsset\",\"type\":\"address\"}],\"name\":\"getDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegisteredAssets\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQuoteAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getHistoryAt\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRanked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"latestUnstakeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"sellAsset\",\"type\":\"address\"},{\"name\":\"buyAsset\",\"type\":\"address\"}],\"name\":\"existsPriceOnAssetPair\",\"outputs\":[{\"name\":\"isExistent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumPriceCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetInformation\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"symbol\",\"type\":\"bytes8\"},{\"name\":\"decimals\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"ipfsHash\",\"type\":\"string\"},{\"name\":\"breakIn\",\"type\":\"address\"},{\"name\":\"breakOut\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUOTE_ASSET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofAssets\",\"type\":\"address[]\"}],\"name\":\"pricesToCommit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"burnStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofExchange\",\"type\":\"address\"}],\"name\":\"exchangeIsRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ofExchange\",\"type\":\"address\"}],\"name\":\"getExchangeInformation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ofStakingAsset\",\"type\":\"address\"},{\"name\":\"ofQuoteAsset\",\"type\":\"address\"},{\"name\":\"quoteAssetName\",\"type\":\"bytes32\"},{\"name\":\"quoteAssetSymbol\",\"type\":\"bytes8\"},{\"name\":\"quoteAssetDecimals\",\"type\":\"uint256\"},{\"name\":\"quoteAssetUrl\",\"type\":\"string\"},{\"name\":\"quoteAssetIpfsHash\",\"type\":\"string\"},{\"name\":\"quoteAssetBreakInBreakOut\",\"type\":\"address[2]\"},{\"name\":\"quoteAssetStandards\",\"type\":\"uint256[]\"},{\"name\":\"quoteAssetFunctionSignatures\",\"type\":\"bytes4[]\"},{\"name\":\"updateInfo\",\"type\":\"uint256[2]\"},{\"name\":\"stakingInfo\",\"type\":\"uint256[3]\"},{\"name\":\"ofGovernance\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ofPriceFeed\",\"type\":\"address\"}],\"name\":\"SetupPriceFeed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"StakeBurned\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"}]","ContractName":"CanonicalPriceFeed","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000beb9ef514a379b997e0798fdcc901ee474b6d9a1000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc25772617070656420457468657220746f6b656e0000000000000000000000000057455448000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000083c41ea13af6c2d5aaddf6e73142eb9a7b00183000000000000000000000000083c41ea13af6c2d5aaddf6e73142eb9a7b001830000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000015180000000000000000000000000000000000000000000000002b5e3af16b188000000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000d041e27ac805ed204ba227ff9a3e159940ddf0e40000000000000000000000000000000000000000000000000000000000000042307838366235656564383164623566363931633336636338336562353863623532303562643230393062663337363361313966306335626632663037346464383462000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004230783836623565656438316462356636393163333663633833656235386362353230356264323039306266333736336131396630633562663266303734646438346200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://50402bc3f7731b9090a0f2eb31433bfba1936e9868f1900ca13b364648905be5"}]}