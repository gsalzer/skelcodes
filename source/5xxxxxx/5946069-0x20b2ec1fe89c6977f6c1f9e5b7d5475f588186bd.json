{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n/* ==================================================================== */\r\n/* Copyright (c) 2018 The MagicAcademy Project.  All rights reserved.\r\n/* \r\n/* https://www.magicacademy.io One of the world's first idle strategy games of blockchain \r\n/*  \r\n/* authors rainy@livestar.com/fanny.zheng@livestar.com\r\n/*                 \r\n/* ==================================================================== */\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /*\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\ncontract AccessAdmin is Ownable {\r\n\r\n  /// @dev Admin Address\r\n  mapping (address => bool) adminContracts;\r\n\r\n  /// @dev Trust contract\r\n  mapping (address => bool) actionContracts;\r\n\r\n  function setAdminContract(address _addr, bool _useful) public onlyOwner {\r\n    require(_addr != address(0));\r\n    adminContracts[_addr] = _useful;\r\n  }\r\n\r\n  modifier onlyAdmin {\r\n    require(adminContracts[msg.sender]); \r\n    _;\r\n  }\r\n\r\n  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\r\n    actionContracts[_actionAddr] = _useful;\r\n  }\r\n\r\n  modifier onlyAccess() {\r\n    require(actionContracts[msg.sender]);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\ninterface BitGuildTokenInterface { // implements ERC20Interface\r\n  function totalSupply() public constant returns (uint);\r\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n  function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n  function transfer(address to, uint tokens) public returns (bool success);\r\n  function approve(address spender, uint tokens) public returns (bool success);\r\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint tokens);\r\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ninterface CardsInterface {\r\n  function getGameStarted() external constant returns (bool);\r\n  function getOwnedCount(address player, uint256 cardId) external view returns (uint256);\r\n  function getMaxCap(address _addr,uint256 _cardId) external view returns (uint256);\r\n  function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\r\n  function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\r\n  function balanceOf(address player) public constant returns(uint256);\r\n  function coinBalanceOf(address player,uint8 itype) external constant returns(uint256);\r\n  function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) external;\r\n  function getUnitsProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256);\r\n  function increasePlayersJadeProduction(address player, uint256 increase) public;\r\n  function setUintCoinProduction(address _address, uint256 cardId, uint256 iValue, bool iflag) external;\r\n  function getUintsOwnerCount(address _address) external view returns (uint256);\r\n  function AddPlayers(address _address) external;\r\n  function setUintsOwnerCount(address _address, uint256 amount, bool iflag) external;\r\n  function setOwnedCount(address player, uint256 cardId, uint256 amount, bool iflag) external;\r\n  function setCoinBalance(address player, uint256 eth, uint8 itype, bool iflag) external;\r\n  function setTotalEtherPool(uint256 inEth, uint8 itype, bool iflag) external;\r\n  function getUpgradesOwned(address player, uint256 upgradeId) external view returns (uint256);\r\n  function setUpgradesOwned(address player, uint256 upgradeId) external;\r\n  function updatePlayersCoinByOut(address player) external;\r\n  function balanceOfUnclaimed(address player) public constant returns (uint256);\r\n  function setLastJadeSaveTime(address player) external;\r\n  function setRoughSupply(uint256 iroughSupply) external;\r\n  function setJadeCoin(address player, uint256 coin, bool iflag) external;\r\n  function getUnitsInProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256);\r\n  function reducePlayersJadeProduction(address player, uint256 decrease) public;\r\n}\r\ninterface GameConfigInterface {\r\n  function unitCoinProduction(uint256 cardId) external constant returns (uint256);\r\n  function unitPLATCost(uint256 cardId) external constant returns (uint256);\r\n  function getCostForCards(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256);\r\n  function getCostForBattleCards(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256);\r\n  function unitBattlePLATCost(uint256 cardId) external constant returns (uint256);\r\n  function getUpgradeCardsInfo(uint256 upgradecardId,uint256 existing) external constant returns (\r\n    uint256 coinCost, \r\n    uint256 ethCost, \r\n    uint256 upgradeClass, \r\n    uint256 cardId, \r\n    uint256 upgradeValue,\r\n    uint256 platCost\r\n  );\r\n function getCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256, bool);\r\n function getBattleCardInfo(uint256 cardId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, bool);\r\n\r\n}\r\ninterface RareInterface {\r\n  function getRareItemsOwner(uint256 rareId) external view returns (address);\r\n  function getRareItemsPrice(uint256 rareId) external view returns (uint256);\r\n  function getRareItemsPLATPrice(uint256 rareId) external view returns (uint256);\r\n   function getRarePLATInfo(uint256 _tokenId) external view returns (\r\n    uint256 sellingPrice,\r\n    address owner,\r\n    uint256 nextPrice,\r\n    uint256 rareClass,\r\n    uint256 cardId,\r\n    uint256 rareValue\r\n  );\r\n  function transferToken(address _from, address _to, uint256 _tokenId) external;\r\n  function setRarePrice(uint256 _rareId, uint256 _price) external;\r\n}\r\n/// @notice Purchase on BitGuild\r\n/// @author rainysiu rainy@livestar.com\r\ncontract BitGuildTrade is AccessAdmin {\r\n  BitGuildTokenInterface public tokenContract;\r\n   //data contract\r\n  CardsInterface public cards ;\r\n  GameConfigInterface public schema;\r\n  RareInterface public rare;\r\n\r\n  \r\n  function BitGuildTrade() public {\r\n    setAdminContract(msg.sender,true);\r\n    setActionContract(msg.sender,true);\r\n  }\r\n\r\n  event UnitBought(address player, uint256 unitId, uint256 amount);\r\n  event UpgradeCardBought(address player, uint256 upgradeId);\r\n  event BuyRareCard(address player, address previous, uint256 rareId,uint256 iPrice);\r\n  event UnitSold(address player, uint256 unitId, uint256 amount);\r\n\r\n \r\n  function() external payable {\r\n    revert();\r\n  }\r\n  function setBitGuildToken(address _tokenContract) external onlyOwner {\r\n    tokenContract = BitGuildTokenInterface(_tokenContract);\r\n  } \r\n\r\n  function setCardsAddress(address _address) external onlyOwner {\r\n    cards = CardsInterface(_address);\r\n  }\r\n\r\n   //normal cards\r\n  function setConfigAddress(address _address) external onlyOwner {\r\n    schema = GameConfigInterface(_address);\r\n  }\r\n\r\n  //rare cards\r\n  function setRareAddress(address _address) external onlyOwner {\r\n    rare = RareInterface(_address);\r\n  }\r\n  function kill() public onlyOwner {\r\n    tokenContract.transferFrom(this, msg.sender, tokenContract.balanceOf(this));\r\n    selfdestruct(msg.sender); //end execution, destroy current contract and send funds to a\r\n  }  \r\n  /// @notice Returns all the relevant information about a specific tokenId.\r\n  /// val1:flag,val2:id,val3:amount\r\n  function _getExtraParam(bytes _extraData) private pure returns(uint256 val1,uint256 val2,uint256 val3) {\r\n    if (_extraData.length == 2) {\r\n      val1 = uint256(_extraData[0]);\r\n      val2 = uint256(_extraData[1]);\r\n      val3 = 1; \r\n    } else if (_extraData.length == 3) {\r\n      val1 = uint256(_extraData[0]);\r\n      val2 = uint256(_extraData[1]);\r\n      val3 = uint256(_extraData[2]);\r\n    }  \r\n  }\r\n  \r\n  function receiveApproval(address _player, uint256 _value, address _tokenContractAddr, bytes _extraData) external {\r\n    require(msg.sender == _tokenContractAddr);\r\n    require(_extraData.length >=1);\r\n    require(tokenContract.transferFrom(_player, address(this), _value));\r\n    uint256 flag;\r\n    uint256 unitId;\r\n    uint256 amount;\r\n    (flag,unitId,amount) = _getExtraParam(_extraData);\r\n\r\n    if (flag==1) {\r\n      buyPLATCards(_player, _value, unitId, amount);  // 1-39\r\n    } else if (flag==3) {\r\n      buyUpgradeCard(_player, _value, unitId);  // >=1\r\n    } else if (flag==4) {\r\n      buyRareItem(_player, _value, unitId); //rarecard\r\n    } \r\n  } \r\n\r\n  /// buy normal cards via jade\r\n  function buyBasicCards(uint256 unitId, uint256 amount) external {\r\n    require(cards.getGameStarted());\r\n    require(amount>=1);\r\n    uint256 existing = cards.getOwnedCount(msg.sender,unitId);\r\n    uint256 total = SafeMath.add(existing, amount);\r\n    if (total > 99) { // Default unit limit\r\n      require(total <= cards.getMaxCap(msg.sender,unitId)); // Housing upgrades (allow more units)\r\n    }\r\n\r\n    uint256 coinProduction;\r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    if (unitId>=1 && unitId<=39) {    \r\n      (, coinProduction, coinCost, ethCost,) = schema.getCardInfo(unitId, existing, amount);\r\n    } else if (unitId>=40) {\r\n      (, coinCost, ethCost,) = schema.getBattleCardInfo(unitId, existing, amount);\r\n    }\r\n    require(cards.balanceOf(msg.sender) >= coinCost);\r\n    require(ethCost == 0); // Free ether unit\r\n        \r\n    // Update players jade \r\n    cards.updatePlayersCoinByPurchase(msg.sender, coinCost);\r\n    ///****increase production***/\r\n    if (coinProduction > 0) {\r\n      cards.increasePlayersJadeProduction(msg.sender,cards.getUnitsProduction(msg.sender, unitId, amount)); \r\n      cards.setUintCoinProduction(msg.sender,unitId,cards.getUnitsProduction(msg.sender, unitId, amount),true); \r\n    }\r\n    //players\r\n    if (cards.getUintsOwnerCount(msg.sender)<=0) {\r\n      cards.AddPlayers(msg.sender);\r\n    }\r\n    cards.setUintsOwnerCount(msg.sender,amount,true);\r\n    cards.setOwnedCount(msg.sender,unitId,amount,true);\r\n    \r\n    UnitBought(msg.sender, unitId, amount);\r\n  }\r\n\r\n  function buyBasicCards_Migrate(address _addr, uint256 _unitId, uint256 _amount) external onlyAdmin {\r\n    require(cards.getGameStarted());\r\n    require(_amount>=1);\r\n    uint256 existing = cards.getOwnedCount(_addr,_unitId);\r\n    uint256 total = SafeMath.add(existing, _amount);\r\n    if (total > 99) { // Default unit limit\r\n      require(total <= cards.getMaxCap(_addr,_unitId)); // Housing upgrades (allow more units)\r\n    }\r\n    require (_unitId == 41);\r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    (, coinCost, ethCost,) = schema.getBattleCardInfo(_unitId, existing, _amount);\r\n    //players\r\n    if (cards.getUintsOwnerCount(_addr)<=0) {\r\n      cards.AddPlayers(_addr);\r\n    }\r\n    cards.setUintsOwnerCount(_addr,_amount,true);\r\n    cards.setOwnedCount(_addr,_unitId,_amount,true);\r\n    \r\n    UnitBought(_addr, _unitId, _amount);\r\n  }\r\n\r\n  function buyPLATCards(address _player, uint256 _platValue, uint256 _cardId, uint256 _amount) internal {\r\n    require(cards.getGameStarted());\r\n    require(_amount>=1);\r\n    uint256 existing = cards.getOwnedCount(_player,_cardId);\r\n    uint256 total = SafeMath.add(existing, _amount);\r\n    if (total > 99) { // Default unit limit\r\n      require(total <= cards.getMaxCap(_player,_cardId)); // Housing upgrades (allow more units)\r\n    }\r\n\r\n    uint256 coinProduction;\r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n\r\n    if (_cardId>=1 && _cardId<=39) {\r\n      coinProduction = schema.unitCoinProduction(_cardId);\r\n      coinCost = schema.getCostForCards(_cardId, existing, _amount);\r\n      ethCost = SafeMath.mul(schema.unitPLATCost(_cardId),_amount);  // get platprice\r\n    } else if (_cardId>=40) {\r\n      coinCost = schema.getCostForBattleCards(_cardId, existing, _amount);\r\n      ethCost = SafeMath.mul(schema.unitBattlePLATCost(_cardId),_amount);  // get platprice\r\n    }\r\n\r\n    require(ethCost>0);\r\n    require(SafeMath.add(cards.coinBalanceOf(_player,1),_platValue) >= ethCost);\r\n    require(cards.balanceOf(_player) >= coinCost);   \r\n\r\n    // Update players jade  \r\n    cards.updatePlayersCoinByPurchase(_player, coinCost);\r\n\r\n    if (ethCost > _platValue) {\r\n      cards.setCoinBalance(_player,SafeMath.sub(ethCost,_platValue),1,false);\r\n    } else if (_platValue > ethCost) {\r\n      // Store overbid in their balance\r\n      cards.setCoinBalance(_player,SafeMath.sub(_platValue,ethCost),1,true);\r\n    } \r\n\r\n    uint256 devFund = uint256(SafeMath.div(ethCost,20)); // 5% fee\r\n    cards.setTotalEtherPool(uint256(SafeMath.div(ethCost,4)),1,true);  // 20% to pool\r\n    cards.setCoinBalance(owner,devFund,1,true);  \r\n    \r\n    if (coinProduction > 0) {\r\n      cards.increasePlayersJadeProduction(_player, cards.getUnitsProduction(_player, _cardId, _amount)); \r\n      cards.setUintCoinProduction(_player,_cardId,cards.getUnitsProduction(_player, _cardId, _amount),true); \r\n    }\r\n    \r\n    if (cards.getUintsOwnerCount(_player)<=0) {\r\n      cards.AddPlayers(_player);\r\n    }\r\n    cards.setUintsOwnerCount(_player,_amount, true);\r\n    cards.setOwnedCount(_player,_cardId,_amount,true);\r\n    //event\r\n    UnitBought(_player, _cardId, _amount);\r\n  }\r\n\r\n  /// buy upgrade cards with ether/Jade\r\n  function buyUpgradeCard(uint256 upgradeId) external payable {\r\n    require(cards.getGameStarted());\r\n    require(upgradeId>=1);\r\n    uint256 existing = cards.getUpgradesOwned(msg.sender,upgradeId);\r\n    \r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    uint256 upgradeClass;\r\n    uint256 unitId;\r\n    uint256 upgradeValue;\r\n    (coinCost, ethCost, upgradeClass, unitId, upgradeValue,) = schema.getUpgradeCardsInfo(upgradeId,existing);\r\n    if (upgradeClass<8) {\r\n      require(existing<=5); \r\n    } else {\r\n      require(existing<=2); \r\n    }\r\n    require (coinCost>0 && ethCost==0);\r\n    require(cards.balanceOf(msg.sender) >= coinCost);  \r\n    cards.updatePlayersCoinByPurchase(msg.sender, coinCost);\r\n\r\n    cards.upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue);  \r\n    cards.setUpgradesOwned(msg.sender,upgradeId); //upgrade cards level\r\n\r\n    UpgradeCardBought(msg.sender, upgradeId);\r\n  }\r\n\r\n  /// upgrade cards-- jade + plat\r\n  function buyUpgradeCard(address _player, uint256 _platValue,uint256 _upgradeId) internal {\r\n    require(cards.getGameStarted());\r\n    require(_upgradeId>=1);\r\n    uint256 existing = cards.getUpgradesOwned(_player,_upgradeId);\r\n    require(existing<=5);  // v1 - v6\r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    uint256 upgradeClass;\r\n    uint256 unitId;\r\n    uint256 upgradeValue;\r\n    uint256 platCost;\r\n    (coinCost, ethCost, upgradeClass, unitId, upgradeValue,platCost) = schema.getUpgradeCardsInfo(_upgradeId,existing);\r\n\r\n    require(platCost>0);\r\n    if (platCost > 0) {\r\n      require(SafeMath.add(cards.coinBalanceOf(_player,1),_platValue) >= platCost); \r\n\r\n      if (platCost > _platValue) { // They can use their balance instead\r\n        cards.setCoinBalance(_player, SafeMath.sub(platCost,_platValue),1,false);\r\n      } else if (platCost < _platValue) {  \r\n        cards.setCoinBalance(_player,SafeMath.sub(_platValue,platCost),1,true);\r\n    } \r\n      // defund 5%，upgrade card can not be sold，\r\n      uint256 devFund = uint256(SafeMath.div(platCost, 20)); // 5% fee on purchases (marketing, gameplay & maintenance)\r\n      cards.setTotalEtherPool(SafeMath.sub(platCost,devFund),1,true); // Rest goes to div pool (Can't sell upgrades)\r\n      cards.setCoinBalance(owner,devFund,1,true);  \r\n    }\r\n        \r\n     // Update \r\n    require(cards.balanceOf(_player) >= coinCost);  \r\n    cards.updatePlayersCoinByPurchase(_player, coinCost);\r\n    \r\n    //add weight\r\n    cards.upgradeUnitMultipliers(_player, upgradeClass, unitId, upgradeValue);  \r\n    cards.setUpgradesOwned(_player,_upgradeId); // upgrade level up\r\n\r\n     //add user to userlist\r\n    if (cards.getUintsOwnerCount(_player)<=0) {\r\n      cards.AddPlayers(_player);\r\n    }\r\n \r\n    UpgradeCardBought(_player, _upgradeId);\r\n  }\r\n\r\n\r\n  // Allows someone to send ether and obtain the token\r\n  function buyRareItem(address _player, uint256 _platValue,uint256 _rareId) internal {\r\n    require(cards.getGameStarted());        \r\n    address previousOwner = rare.getRareItemsOwner(_rareId);  // rare card\r\n    require(previousOwner != 0);\r\n    require(_player!=previousOwner);  // can not buy from itself\r\n    \r\n    uint256 ethCost = rare.getRareItemsPLATPrice(_rareId); // get plat cost\r\n    uint256 totalCost = SafeMath.add(cards.coinBalanceOf(_player,1),_platValue);\r\n    require(totalCost >= ethCost); \r\n    // We have to claim buyer/sellder's goo before updating their production values \r\n    cards.updatePlayersCoinByOut(_player);\r\n    cards.updatePlayersCoinByOut(previousOwner);\r\n\r\n    uint256 upgradeClass;\r\n    uint256 unitId;\r\n    uint256 upgradeValue;\r\n    (,,,,upgradeClass, unitId, upgradeValue) = rare.getRarePLATInfo(_rareId);\r\n    \r\n    // modify weight\r\n    cards.upgradeUnitMultipliers(_player, upgradeClass, unitId, upgradeValue); \r\n    cards.removeUnitMultipliers(previousOwner, upgradeClass, unitId, upgradeValue); \r\n\r\n    // Splitbid/Overbid\r\n    if (ethCost > _platValue) {\r\n      cards.setCoinBalance(_player,SafeMath.sub(ethCost,_platValue),1,false);\r\n    } else if (_platValue > ethCost) {\r\n      // Store overbid in their balance\r\n      cards.setCoinBalance(_player,SafeMath.sub(_platValue,ethCost),1,true);\r\n    }  \r\n    // Distribute ethCost  uint256 devFund = ethCost / 50; \r\n    uint256 devFund = uint256(SafeMath.div(ethCost, 20)); // 5% fee on purchases (marketing, gameplay & maintenance)  抽成2%\r\n    uint256 dividends = uint256(SafeMath.div(ethCost,20)); // 5% goes to pool \r\n\r\n    cards.setTotalEtherPool(dividends,1,true);  // 5% to pool\r\n    cards.setCoinBalance(owner,devFund,1,true);  // 5% fee\r\n        \r\n    // Transfer / update rare item\r\n    rare.transferToken(previousOwner,_player,_rareId); \r\n    rare.setRarePrice(_rareId,SafeMath.div(SafeMath.mul(rare.getRareItemsPrice(_rareId),5),4));\r\n    \r\n    cards.setCoinBalance(previousOwner,SafeMath.sub(ethCost,SafeMath.add(dividends,devFund)),1,true);\r\n    \r\n    if (cards.getUintsOwnerCount(_player)<=0) {\r\n      cards.AddPlayers(_player);\r\n    }\r\n   \r\n    cards.setUintsOwnerCount(_player,1,true);\r\n    cards.setUintsOwnerCount(previousOwner,1,true);\r\n\r\n    //tell the world\r\n    BuyRareCard(_player, previousOwner, _rareId, ethCost);\r\n  }\r\n\r\n  /// refunds 75% since no transfer between bitguild and player,no need to call approveAndCall\r\n  function sellCards( uint256 _unitId, uint256 _amount) external {\r\n    require(cards.getGameStarted());\r\n    uint256 existing = cards.getOwnedCount(msg.sender,_unitId);\r\n    require(existing >= _amount && _amount>0); \r\n    existing = SafeMath.sub(existing,_amount);\r\n    uint256 coinChange;\r\n    uint256 decreaseCoin;\r\n    uint256 schemaUnitId;\r\n    uint256 coinProduction;\r\n    uint256 coinCost;\r\n    uint256 ethCost;\r\n    bool sellable;\r\n    if (_unitId>=40) { // upgrade card\r\n      (schemaUnitId,coinCost,, sellable) = schema.getBattleCardInfo(_unitId, existing, _amount);\r\n      ethCost = SafeMath.mul(schema.unitBattlePLATCost(_unitId),_amount);\r\n    } else {\r\n      (schemaUnitId, coinProduction, coinCost, , sellable) = schema.getCardInfo(_unitId, existing, _amount);\r\n      ethCost = SafeMath.mul(schema.unitPLATCost(_unitId),_amount); // plat \r\n    }\r\n    require(sellable);  // can be refunded\r\n    if (coinCost>0) {\r\n      coinChange = SafeMath.add(cards.balanceOfUnclaimed(msg.sender), SafeMath.div(SafeMath.mul(coinCost,70),100)); // Claim unsaved goo whilst here\r\n    } else {\r\n      coinChange = cards.balanceOfUnclaimed(msg.sender); \r\n    }\r\n\r\n    cards.setLastJadeSaveTime(msg.sender); \r\n    cards.setRoughSupply(coinChange);  \r\n    cards.setJadeCoin(msg.sender, coinChange, true); // refund 75% Jadecoin to player \r\n\r\n    decreaseCoin = cards.getUnitsInProduction(msg.sender, _unitId, _amount);\r\n  \r\n    if (coinProduction > 0) { \r\n      cards.reducePlayersJadeProduction(msg.sender, decreaseCoin);\r\n      //update the speed of jade minning\r\n      cards.setUintCoinProduction(msg.sender,_unitId,decreaseCoin,false); \r\n    }\r\n\r\n    if (ethCost > 0) { // Premium units sell for 75% of buy cost\r\n      cards.setCoinBalance(msg.sender,SafeMath.div(SafeMath.mul(ethCost,70),100),1,true);\r\n    }\r\n\r\n    cards.setOwnedCount(msg.sender,_unitId,_amount,false); \r\n    cards.setUintsOwnerCount(msg.sender,_amount,false);\r\n\r\n    //tell the world\r\n    UnitSold(msg.sender, _unitId, _amount);\r\n  }\r\n\r\n  //@notice for player withdraw\r\n  function withdrawEtherFromTrade(uint256 amount) external {\r\n    require(amount <= cards.coinBalanceOf(msg.sender,1));\r\n    cards.setCoinBalance(msg.sender,amount,1,false);\r\n    tokenContract.transfer(msg.sender,amount);\r\n  } \r\n\r\n  //@notice withraw all PLAT by dev\r\n  function withdrawToken(uint256 amount) external onlyOwner {\r\n    uint256 balance = tokenContract.balanceOf(this);\r\n    require(balance > 0 && balance >= amount);\r\n    tokenContract.transfer(msg.sender, amount);\r\n  }\r\n\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setAdminContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyBasicCards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cards\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEtherFromTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rare\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCardsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_actionAddr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setActionContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"setBitGuildToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setRareAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setConfigAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_unitId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyBasicCards_Migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_tokenContractAddr\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_unitId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellCards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"upgradeId\",\"type\":\"uint256\"}],\"name\":\"buyUpgradeCard\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"schema\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnitBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"upgradeId\",\"type\":\"uint256\"}],\"name\":\"UpgradeCardBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rareId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iPrice\",\"type\":\"uint256\"}],\"name\":\"BuyRareCard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"unitId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnitSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BitGuildTrade","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://37c00b155f0144ea9b3c4f2e04a5f7d5d9adf79618f9026c91eeda8e28ff1fe2"}]}