{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\ninterface Hash {\r\n   \r\n    function get() public returns (bytes32); \r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract StandardToken {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    uint256 public totalSupply;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     */\r\n    /*function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }*/\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Lotery is Ownable {\r\n\r\n  //event when gamer is buying a new ticket\r\n  event TicketSelling(uint periodNumber, address indexed from, bytes32 hash, uint when);\r\n\r\n  //event when period finished\r\n  event PeriodFinished(uint periodNumber, address indexed winnerAddr, uint reward, bytes32 winnerHash, uint when);\r\n\r\n  //event when any funds transferred\r\n  event TransferBenefit(address indexed to, uint value);\r\n\r\n  event JackPot(uint periodNumber, address winnerAddr, bytes32 winnerHash, uint value, uint when);\r\n\r\n\r\n//current period of the game\r\n  uint public currentPeriod;\r\n\r\n  //if maxTicketAmount is not rised and maxPeriodDuration from period start is gone everyone can finish current round\r\n  uint public maxPeriodDuration;\r\n\r\n  uint public maxTicketAmount;\r\n\r\n  //ticket price in this contract\r\n  uint public ticketPrice;\r\n\r\n  //part for owner\r\n  uint public benefitPercents;\r\n\r\n  //funds for owner\r\n  uint public benefitFunds;\r\n\r\n  //jackPot percents\r\n  uint public jackPotPercents;\r\n\r\n  uint public jackPotFunds;\r\n\r\n  bytes32 public jackPotBestHash;\r\n\r\n\r\n  //base game hash from other contract Hash\r\n  bytes32 private baseHash;\r\n\r\n  Hash private hashGenerator;\r\n\r\n  //period struct\r\n  struct period {\r\n  uint number;\r\n  uint startDate;\r\n  bytes32 winnerHash;\r\n  address winnerAddress;\r\n  uint raised;\r\n  uint ticketAmount;\r\n  bool finished;\r\n  uint reward;\r\n  }\r\n\r\n  //ticket struct\r\n  struct ticket {\r\n  uint number;\r\n  address addr;\r\n  bytes32 hash;\r\n  }\r\n\r\n\r\n  //ticket store\r\n  mapping (uint => mapping (uint => ticket)) public tickets;\r\n\r\n  //periods store\r\n  mapping (uint => period) public periods;\r\n\r\n\r\n  function Lotery(uint _maxPeriodDuration, uint _ticketPrice, uint _benefitPercents, uint _maxTicketAmount, address _hashAddr, uint _jackPotPercents) public {\r\n\r\n    require(_maxPeriodDuration > 0 && _ticketPrice > 0 && _benefitPercents > 0 && _benefitPercents < 50 && _maxTicketAmount > 0 && _jackPotPercents > 0 && _jackPotPercents < 50);\r\n    //set data in constructor\r\n    maxPeriodDuration = _maxPeriodDuration;\r\n    ticketPrice = _ticketPrice;\r\n    benefitPercents = _benefitPercents;\r\n    maxTicketAmount = _maxTicketAmount;\r\n    jackPotPercents = _jackPotPercents;\r\n\r\n    //get initial hash\r\n    hashGenerator = Hash(_hashAddr);\r\n    baseHash = hashGenerator.get();\r\n\r\n    //start initial period\r\n    periods[currentPeriod].number = currentPeriod;\r\n    periods[currentPeriod].startDate = now;\r\n\r\n\r\n  }\r\n\r\n\r\n\r\n  //start new period\r\n  function startNewPeriod() private {\r\n    //if prev period finished\r\n    require(periods[currentPeriod].finished);\r\n    //init new period\r\n    currentPeriod++;\r\n    periods[currentPeriod].number = currentPeriod;\r\n    periods[currentPeriod].startDate = now;\r\n\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  //buy ticket with specified round and passing string data\r\n  function buyTicket(uint periodNumber, string data) payable public {\r\n\r\n    //only with ticket price!\r\n    require(msg.value == ticketPrice);\r\n    //only if current ticketAmount < maxTicketAmount\r\n    require(periods[periodNumber].ticketAmount < maxTicketAmount);\r\n    //roundNumber is currentRound\r\n    require(periodNumber == currentPeriod);\r\n\r\n    processTicketBuying(data, msg.value, msg.sender);\r\n\r\n  }\r\n\r\n\r\n  //buy ticket with msg.data and currentRound when transaction happened\r\n  function() payable public {\r\n\r\n    //only with ticket price!\r\n    require(msg.value == ticketPrice);\r\n    //only if current ticketAmount < maxTicketAmount\r\n    require(periods[currentPeriod].ticketAmount < maxTicketAmount);\r\n\r\n\r\n    processTicketBuying(string(msg.data), msg.value, msg.sender);\r\n\r\n\r\n  }\r\n\r\n  function processTicketBuying(string data, uint value, address sender) private {\r\n\r\n\r\n    //MAIN SECRET!\r\n    //calc ticket hash from baseHash and user data\r\n    //nobody knows baseHash\r\n    bytes32 hash = sha256(data, baseHash);\r\n\r\n    //update base hash for next tickets\r\n    baseHash = sha256(hash, baseHash);\r\n\r\n    //set winner if this is a best hash in round\r\n    if (periods[currentPeriod].ticketAmount == 0 || (hash < periods[currentPeriod].winnerHash)) {\r\n      periods[currentPeriod].winnerHash = hash;\r\n      periods[currentPeriod].winnerAddress = sender;\r\n    }\r\n\r\n    //update tickets store\r\n    tickets[currentPeriod][periods[currentPeriod].ticketAmount].number = periods[currentPeriod].ticketAmount;\r\n    tickets[currentPeriod][periods[currentPeriod].ticketAmount].addr = sender;\r\n    tickets[currentPeriod][periods[currentPeriod].ticketAmount].hash = hash;\r\n\r\n\r\n    //update periods store\r\n    periods[currentPeriod].ticketAmount++;\r\n    periods[currentPeriod].raised += value;\r\n\r\n    //call events\r\n    TicketSelling(currentPeriod, sender, hash, now);\r\n\r\n    //automatically finish and start new round if max ticket amount is raised\r\n    if (periods[currentPeriod].ticketAmount >= maxTicketAmount) {\r\n      finishRound();\r\n    }\r\n\r\n  }\r\n\r\n\r\n  //finish round\r\n  function finishRound() private {\r\n\r\n    //only if not finished yet\r\n    require(!periods[currentPeriod].finished);\r\n    //only if ticketAmount >= maxTicketAmount\r\n    require(periods[currentPeriod].ticketAmount >= maxTicketAmount);\r\n\r\n\r\n    //calc reward for current winner with minus %\r\n\r\n    uint fee = ((periods[currentPeriod].raised * benefitPercents) / 100);\r\n    uint jack = ((periods[currentPeriod].raised * jackPotPercents) / 100);\r\n\r\n\r\n    uint winnerReward = periods[currentPeriod].raised - fee - jack;\r\n\r\n    //calc owner benefit\r\n    benefitFunds += periods[currentPeriod].raised - winnerReward;\r\n\r\n\r\n    //if first time\r\n    if (jackPotBestHash == 0x0) {\r\n      jackPotBestHash = periods[currentPeriod].winnerHash;\r\n    }\r\n    //all other times\r\n    if (periods[currentPeriod].winnerHash < jackPotBestHash) {\r\n\r\n      jackPotBestHash = periods[currentPeriod].winnerHash;\r\n\r\n\r\n      if (jackPotFunds > 0) {\r\n        winnerReward += jackPotFunds;\r\n        JackPot(currentPeriod, periods[currentPeriod].winnerAddress, periods[currentPeriod].winnerHash, jackPotFunds, now);\r\n\r\n      }\r\n\r\n      jackPotFunds = 0;\r\n\r\n    }\r\n\r\n    //move jack to next round\r\n    jackPotFunds += jack;\r\n\r\n    //calc expected balance\r\n    uint plannedBalance = this.balance - winnerReward;\r\n\r\n    //send ether to winner\r\n    periods[currentPeriod].winnerAddress.transfer(winnerReward);\r\n\r\n    //update period data\r\n    periods[currentPeriod].reward = winnerReward;\r\n    periods[currentPeriod].finished = true;\r\n\r\n    //call events\r\n    PeriodFinished(currentPeriod, periods[currentPeriod].winnerAddress, winnerReward, periods[currentPeriod].winnerHash, now);\r\n\r\n    //automatically start new period\r\n    startNewPeriod();\r\n\r\n    //check balance\r\n    assert(this.balance == plannedBalance);\r\n  }\r\n\r\n  //benefit for owner\r\n  function benefit() public onlyOwner {\r\n    require(benefitFunds > 0);\r\n\r\n    uint plannedBalance = this.balance - benefitFunds;\r\n    owner.transfer(benefitFunds);\r\n    benefitFunds = 0;\r\n\r\n    TransferBenefit(owner, benefitFunds);\r\n    assert(this.balance == plannedBalance);\r\n  }\r\n\r\n  //manually finish and restart round\r\n  function finishRoundAndStartNew() public {\r\n    //only if round has tickets\r\n    require(periods[currentPeriod].ticketAmount > 0);\r\n    //only if date is expired\r\n    require(periods[currentPeriod].startDate + maxPeriodDuration < now);\r\n    //restart round\r\n    finishRound();\r\n  }\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackPotFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackPotPercents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"benefitPercents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"benefit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishRoundAndStartNew\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"benefitFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackPotBestHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"periodNumber\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"string\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTicketAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tickets\",\"outputs\":[{\"name\":\"number\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPeriodDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periods\",\"outputs\":[{\"name\":\"number\",\"type\":\"uint256\"},{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"winnerHash\",\"type\":\"bytes32\"},{\"name\":\"winnerAddress\",\"type\":\"address\"},{\"name\":\"raised\",\"type\":\"uint256\"},{\"name\":\"ticketAmount\",\"type\":\"uint256\"},{\"name\":\"finished\",\"type\":\"bool\"},{\"name\":\"reward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_maxPeriodDuration\",\"type\":\"uint256\"},{\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"name\":\"_benefitPercents\",\"type\":\"uint256\"},{\"name\":\"_maxTicketAmount\",\"type\":\"uint256\"},{\"name\":\"_hashAddr\",\"type\":\"address\"},{\"name\":\"_jackPotPercents\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"periodNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"TicketSelling\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"periodNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"PeriodFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferBenefit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"periodNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"JackPot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Lotery","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000aa87bee538000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000005d6beb7e4c3f471c3f12e5d613c43d7c35a76a1f0000000000000000000000000000000000000000000000000000000000000019","Library":"","SwarmSource":"bzzr://86dcc640a1064e63dd3f8146a4d99d5319cab4f3b6a0777606a6d41de99d0dc6"}]}