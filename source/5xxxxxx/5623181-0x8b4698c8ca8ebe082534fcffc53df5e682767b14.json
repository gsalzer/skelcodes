{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.23;\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract Proxied is Ownable {\r\n    address public target;\r\n    mapping (address => bool) public initialized;\r\n\r\n    event EventUpgrade(address indexed newTarget, address indexed oldTarget, address indexed admin);\r\n    event EventInitialized(address indexed target);\r\n\r\n    function upgradeTo(address _target) public;\r\n}\r\n\r\ncontract Upgradeable is Proxied {\r\n    /*\r\n     * @notice Modifier to make body of function only execute if the contract has not already been initialized.\r\n     */\r\n    modifier initializeOnceOnly() {\r\n         if(!initialized[target]) {\r\n             initialized[target] = true;\r\n             emit EventInitialized(target);\r\n             _;\r\n         } else revert();\r\n     }\r\n\r\n    /**\r\n     * @notice Will always fail if called. This is used as a placeholder for the contract ABI.\r\n     * @dev This is code is never executed by the Proxy using delegate call\r\n     */\r\n    function upgradeTo(address) public {\r\n        assert(false);\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize any state variables that would normally be set in the contructor.\r\n     * @dev Initialization functionality MUST be implemented in inherited upgradeable contract if the child contract requires\r\n     * variable initialization on creation. This is because the contructor of the child contract will not execute\r\n     * and set any state when the Proxy contract targets it.\r\n     * This function MUST be called stright after the Upgradeable contract is set as the target of the Proxy. This method\r\n     * can be overwridden so that it may have arguments. Make sure that the initializeOnceOnly() modifier is used to protect\r\n     * from being initialized more than once.\r\n     * If a contract is upgraded twice, pay special attention that the state variables are not initialized again\r\n     */\r\n    function initialize() initializeOnceOnly public {\r\n        // initialize contract state variables here\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require (!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require (paused) ;\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\ninterface IClaims  {\r\n\r\n    event ClaimCreated(uint indexed claimId);\r\n\r\n    function createClaim(address[] _voters, uint _votingDeadline,\r\n    address _claimantAddress) external;\r\n\r\n    function castVote(uint _claimId, uint _pType, bytes32 _hash, string _url,\r\n    bytes32 _tokenHash) external;\r\n    \r\n    function register(uint _claimId, uint _pType, bytes32 _hash, string _url,\r\n    bytes32 _tokenHash) external;\r\n}\r\n\r\ncontract NaiveClaims is Upgradeable, Pausable, IClaims  {\r\n\r\n    struct Claim {\r\n        address[] voters;\r\n        mapping(address => Vote) votes;\r\n        address claimantAddress;\r\n        uint votingDeadline;\r\n    }\r\n\r\n    struct Vote {\r\n        uint pType;\r\n        bytes32 hash;\r\n        string url;\r\n        bool exists;\r\n        bytes32 tokenHash;\r\n    }\r\n\r\n    mapping (uint => Claim) public claims;\r\n    event ClaimCreated(uint indexed claimId);\r\n    uint256 public claimsCreated;\r\n\r\n    /**\r\n     * @param _voters - addresses eligible to vote\r\n     * @param _votingDeadline - after which votes cannot be submitted\r\n     * @param _claimantAddress  - claimants address\r\n     */\r\n    function createClaim(address[] _voters, uint _votingDeadline, address _claimantAddress) external whenNotPaused {\r\n\r\n        claims[claimsCreated].voters = _voters;\r\n        claims[claimsCreated].claimantAddress = _claimantAddress;\r\n        claims[claimsCreated].votingDeadline = _votingDeadline;\r\n\r\n        emit ClaimCreated(claimsCreated);\r\n        claimsCreated++;\r\n    }\r\n\r\n    /**\r\n     * @param _claimId - claim id for which user is casting the vote\r\n     * @param _pType - type of hashPointer (1 - PlainVote)\r\n     * @param _hash - of the vote - in this version plain YES or NO\r\n     * @param _url - to the location of the vote (mongo://{vote-doc-id})\r\n     * @param _tokenHash - received from indorse on centralized vote submission\r\n     */\r\n    function castVote(uint _claimId, uint _pType, bytes32 _hash, string _url,\r\n    bytes32 _tokenHash) external {\r\n        Claim storage claim = claims[_claimId];\r\n        Vote storage vote = claim.votes[msg.sender];\r\n\r\n        require(vote.exists != true, \"Voters can only vote once\");\r\n        require(now < claim.votingDeadline, \"Cannot vote after the dealine has passed\");\r\n\r\n        claims[_claimId].votes[msg.sender] = Vote(_pType, _hash, _url, true, _tokenHash);\r\n    }\r\n\r\n    function getVote(uint _claimId, address _voter)  constant external returns (uint ,bytes32,\r\n    string ,bool ,bytes32){\r\n        return (claims[_claimId].votes[_voter].pType,\r\n        claims[_claimId].votes[_voter].hash,\r\n        claims[_claimId].votes[_voter].url,\r\n        claims[_claimId].votes[_voter].exists,\r\n        claims[_claimId].votes[_voter].tokenHash);\r\n    }\r\n\r\n    function getVoter(uint _claimId, uint _index) external constant returns (address) {\r\n        return claims[_claimId].voters[_index];\r\n    }\r\n\r\n    function getVoterCount(uint _claimId) external constant returns (uint) {\r\n        return claims[_claimId].voters.length;\r\n    }\r\n\r\n    function initialize() initializeOnceOnly public {\r\n        claimsCreated = 0; // This is not strictly needed but is good practice to show initialization here\r\n    }\r\n\r\n    function register(uint _claimId, uint _pType, bytes32 _hash, string _url,\r\n    bytes32 _tokenHash) external {\r\n        revert(\"Unsupported operation\");\r\n    }\r\n}\r\n\r\ncontract NaiveTallyCalculator {\r\n    \r\n    bytes32 public yesHash = keccak256(\"YES\");\r\n    bytes32 public noHash = keccak256(\"NO\");\r\n\r\n    function calculateTally(address _claimsAddress, uint _claimId) constant returns (bool) {\r\n        NaiveClaims claimsContract = NaiveClaims(_claimsAddress);\r\n    \r\n        uint votingDeadline;\r\n        (,votingDeadline) = claimsContract.claims(_claimId);\r\n\r\n        uint voterCount = claimsContract.getVoterCount(_claimId);\r\n        require(votingDeadline < now);\r\n\r\n        uint indorsements;\r\n\r\n        for (uint voterIndex = 0; voterIndex < voterCount; voterIndex++) {\r\n            address voter = claimsContract.getVoter(_claimId, voterIndex);\r\n            \r\n            var (, hash,,voteExists,) = claimsContract.getVote(_claimId, voter);\r\n\r\n            if (voteExists == true) {\r\n                if (hash == yesHash) {\r\n                    indorsements++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return indorsements > 5;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"yesHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_claimsAddress\",\"type\":\"address\"},{\"name\":\"_claimId\",\"type\":\"uint256\"}],\"name\":\"calculateTally\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NaiveTallyCalculator","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3a2ff2292c7fdfaca319c4f921aad68d340c268dae75f97693777596a60e5ca6"}]}