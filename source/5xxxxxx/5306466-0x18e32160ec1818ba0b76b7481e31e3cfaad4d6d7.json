{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/*\r\n    Bancor Formula interface\r\n*/\r\ncontract IBancorFormula {\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256);\r\n    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256);\r\n}\r\n\r\n\r\n\r\n/*\r\n    Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    /**\r\n        constructor\r\n    */\r\n    function Utils() public {\r\n    }\r\n\r\n    // verifies that an amount is greater than zero\r\n    modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    // Overflow protected math functions\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract BancorFormula is IBancorFormula, Utils {\r\n    string public version = '0.3';\r\n\r\n    uint256 private constant ONE = 1;\r\n    uint32 private constant MAX_WEIGHT = 1000000;\r\n    uint8 private constant MIN_PRECISION = 32;\r\n    uint8 private constant MAX_PRECISION = 127;\r\n\r\n    /**\r\n        The values below depend on MAX_PRECISION. If you choose to change it:\r\n        Apply the same change in file 'PrintIntScalingFactors.py', run it and paste the results below.\r\n    */\r\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\r\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\r\n    uint256 private constant MAX_NUM = 0x1ffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n        The values below depend on MAX_PRECISION. If you choose to change it:\r\n        Apply the same change in file 'PrintLn2ScalingFactors.py', run it and paste the results below.\r\n    */\r\n    uint256 private constant LN2_NUMERATOR   = 0x3f80fe03f80fe03f80fe03f80fe03f8;\r\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\r\n\r\n    /**\r\n        The values below depend on MIN_PRECISION and MAX_PRECISION. If you choose to change either one of them:\r\n        Apply the same change in file 'PrintFunctionBancorFormula.py', run it and paste the results below.\r\n    */\r\n    uint256[128] private maxExpArray;\r\n\r\n    function BancorFormula() public {\r\n    //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\r\n    //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\r\n    //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\r\n    //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\r\n    //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\r\n    //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\r\n    //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\r\n    //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\r\n        maxExpArray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;\r\n        maxExpArray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;\r\n        maxExpArray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;\r\n        maxExpArray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;\r\n        maxExpArray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;\r\n        maxExpArray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;\r\n        maxExpArray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;\r\n        maxExpArray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;\r\n        maxExpArray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;\r\n        maxExpArray[ 41] = 0x13545598e5c23fffffffffffffffffffff;\r\n        maxExpArray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;\r\n        maxExpArray[ 43] = 0x11c592761c666fffffffffffffffffffff;\r\n        maxExpArray[ 44] = 0x110a688680a757ffffffffffffffffffff;\r\n        maxExpArray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;\r\n        maxExpArray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;\r\n        maxExpArray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;\r\n        maxExpArray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;\r\n        maxExpArray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;\r\n        maxExpArray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;\r\n        maxExpArray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\r\n        maxExpArray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;\r\n        maxExpArray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;\r\n        maxExpArray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;\r\n        maxExpArray[ 55] = 0x0abc25204e02828dffffffffffffffffff;\r\n        maxExpArray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\r\n        maxExpArray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;\r\n        maxExpArray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;\r\n        maxExpArray[ 59] = 0x09131271922eaa606fffffffffffffffff;\r\n        maxExpArray[ 60] = 0x08b380f3558668c46fffffffffffffffff;\r\n        maxExpArray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;\r\n        maxExpArray[ 62] = 0x07ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;\r\n        maxExpArray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;\r\n        maxExpArray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;\r\n        maxExpArray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;\r\n        maxExpArray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\r\n        maxExpArray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\r\n        maxExpArray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;\r\n        maxExpArray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;\r\n        maxExpArray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;\r\n        maxExpArray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;\r\n        maxExpArray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;\r\n        maxExpArray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;\r\n        maxExpArray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;\r\n        maxExpArray[ 76] = 0x0471649d87199aa990756fffffffffffff;\r\n        maxExpArray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;\r\n        maxExpArray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\r\n        maxExpArray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\r\n        maxExpArray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\r\n        maxExpArray[ 81] = 0x0399e96897690418f785257fffffffffff;\r\n        maxExpArray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\r\n        maxExpArray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\r\n        maxExpArray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;\r\n        maxExpArray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;\r\n        maxExpArray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\r\n        maxExpArray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\r\n        maxExpArray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;\r\n        maxExpArray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\r\n        maxExpArray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\r\n        maxExpArray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;\r\n        maxExpArray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;\r\n        maxExpArray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;\r\n        maxExpArray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;\r\n        maxExpArray[ 95] = 0x01ffffffffffffffffffffffffffffffff;\r\n        maxExpArray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\r\n        maxExpArray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\r\n        maxExpArray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;\r\n        maxExpArray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\r\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\r\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\r\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\r\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\r\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\r\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\r\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\r\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\r\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\r\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\r\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\r\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\r\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\r\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\r\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\r\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\r\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\r\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\r\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\r\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\r\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\r\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\r\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\r\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\r\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\r\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\r\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\r\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\r\n    }\r\n\r\n    /**\r\n        @dev given a token supply, connector balance, weight and a deposit amount (in the connector token),\r\n        calculates the return for a given conversion (in the main token)\r\n\r\n        Formula:\r\n        Return = _supply * ((1 + _depositAmount / _connectorBalance) ^ (_connectorWeight / 1000000) - 1)\r\n\r\n        @param _supply              token total supply\r\n        @param _connectorBalance    total connector balance\r\n        @param _connectorWeight     connector weight, represented in ppm, 1-1000000\r\n        @param _depositAmount       deposit amount, in connector token\r\n\r\n        @return purchase return amount\r\n    */\r\n    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) public view returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT);\r\n\r\n        // special case for 0 deposit amount\r\n        if (_depositAmount == 0)\r\n            return 0;\r\n\r\n        // special case if the weight = 100%\r\n        if (_connectorWeight == MAX_WEIGHT)\r\n            return safeMul(_supply, _depositAmount) / _connectorBalance;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseN = safeAdd(_depositAmount, _connectorBalance);\r\n        (result, precision) = power(baseN, _connectorBalance, _connectorWeight, MAX_WEIGHT);\r\n        uint256 temp = safeMul(_supply, result) >> precision;\r\n        return temp - _supply;\r\n    }\r\n\r\n    /**\r\n        @dev given a token supply, connector balance, weight and a sell amount (in the main token),\r\n        calculates the return for a given conversion (in the connector token)\r\n\r\n        Formula:\r\n        Return = _connectorBalance * (1 - (1 - _sellAmount / _supply) ^ (1 / (_connectorWeight / 1000000)))\r\n\r\n        @param _supply              token total supply\r\n        @param _connectorBalance    total connector\r\n        @param _connectorWeight     constant connector Weight, represented in ppm, 1-1000000\r\n        @param _sellAmount          sell amount, in the token itself\r\n\r\n        @return sale return amount\r\n    */\r\n    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) public view returns (uint256) {\r\n        // validate input\r\n        require(_supply > 0 && _connectorBalance > 0 && _connectorWeight > 0 && _connectorWeight <= MAX_WEIGHT && _sellAmount <= _supply);\r\n\r\n        // special case for 0 sell amount\r\n        if (_sellAmount == 0)\r\n            return 0;\r\n\r\n        // special case for selling the entire supply\r\n        if (_sellAmount == _supply)\r\n            return _connectorBalance;\r\n\r\n        // special case if the weight = 100%\r\n        if (_connectorWeight == MAX_WEIGHT)\r\n            return safeMul(_connectorBalance, _sellAmount) / _supply;\r\n\r\n        uint256 result;\r\n        uint8 precision;\r\n        uint256 baseD = _supply - _sellAmount;\r\n        (result, precision) = power(_supply, baseD, MAX_WEIGHT, _connectorWeight);\r\n        uint256 temp1 = safeMul(_connectorBalance, result);\r\n        uint256 temp2 = _connectorBalance << precision;\r\n        return (temp1 - temp2) / result;\r\n    }\r\n\r\n    /**\r\n        General Description:\r\n            Determine a value of precision.\r\n            Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\r\n            Return the result along with the precision used.\r\n\r\n        Detailed Description:\r\n            Instead of calculating \"base ^ exp\", we calculate \"e ^ (ln(base) * exp)\".\r\n            The value of \"ln(base)\" is represented with an integer slightly smaller than \"ln(base) * 2 ^ precision\".\r\n            The larger \"precision\" is, the more accurately this value represents the real value.\r\n            However, the larger \"precision\" is, the more bits are required in order to store this value.\r\n            And the exponentiation function, which takes \"x\" and calculates \"e ^ x\", is limited to a maximum exponent (maximum value of \"x\").\r\n            This maximum exponent depends on the \"precision\" used, and it is given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n            Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\r\n            This allows us to compute \"base ^ exp\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\r\n            This functions assumes that \"_expN < (1 << 256) / ln(MAX_NUM, 1)\", otherwise the multiplication should be replaced with a \"safeMul\".\r\n    */\r\n    function power(uint256 _baseN, uint256 _baseD, uint32 _expN, uint32 _expD) internal view returns (uint256, uint8) {\r\n        uint256 lnBaseTimesExp = ln(_baseN, _baseD) * _expN / _expD;\r\n        uint8 precision = findPositionInMaxExpArray(lnBaseTimesExp);\r\n        return (fixedExp(lnBaseTimesExp >> (MAX_PRECISION - precision), precision), precision);\r\n    }\r\n\r\n    /**\r\n        Return floor(ln(numerator / denominator) * 2 ^ MAX_PRECISION), where:\r\n        - The numerator   is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\r\n        - The denominator is a value between 1 and 2 ^ (256 - MAX_PRECISION) - 1\r\n        - The output      is a value between 0 and floor(ln(2 ^ (256 - MAX_PRECISION) - 1) * 2 ^ MAX_PRECISION)\r\n        This functions assumes that the numerator is larger than or equal to the denominator, because the output would be negative otherwise.\r\n    */\r\n    function ln(uint256 _numerator, uint256 _denominator) internal pure returns (uint256) {\r\n        assert(_numerator <= MAX_NUM);\r\n\r\n        uint256 res = 0;\r\n        uint256 x = _numerator * FIXED_1 / _denominator;\r\n\r\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\r\n        if (x >= FIXED_2) {\r\n            uint8 count = floorLog2(x / FIXED_1);\r\n            x >>= count; // now x < 2\r\n            res = count * FIXED_1;\r\n        }\r\n\r\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\r\n        if (x > FIXED_1) {\r\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\r\n                x = (x * x) / FIXED_1; // now 1 < x < 4\r\n                if (x >= FIXED_2) {\r\n                    x >>= 1; // now 1 < x < 2\r\n                    res += ONE << (i - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return res * LN2_NUMERATOR / LN2_DENOMINATOR;\r\n    }\r\n\r\n    /**\r\n        Compute the largest integer smaller than or equal to the binary logarithm of the input.\r\n    */\r\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\r\n        uint8 res = 0;\r\n\r\n        if (_n < 256) {\r\n            // At most 8 iterations\r\n            while (_n > 1) {\r\n                _n >>= 1;\r\n                res += 1;\r\n            }\r\n        }\r\n        else {\r\n            // Exactly 8 iterations\r\n            for (uint8 s = 128; s > 0; s >>= 1) {\r\n                if (_n >= (ONE << s)) {\r\n                    _n >>= s;\r\n                    res |= s;\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n        The global \"maxExpArray\" is sorted in descending order, and therefore the following statements are equivalent:\r\n        - This function finds the position of [the smallest value in \"maxExpArray\" larger than or equal to \"x\"]\r\n        - This function finds the highest position of [a value in \"maxExpArray\" larger than or equal to \"x\"]\r\n    */\r\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\r\n        uint8 lo = MIN_PRECISION;\r\n        uint8 hi = MAX_PRECISION;\r\n\r\n        while (lo + 1 < hi) {\r\n            uint8 mid = (lo + hi) / 2;\r\n            if (maxExpArray[mid] >= _x)\r\n                lo = mid;\r\n            else\r\n                hi = mid;\r\n        }\r\n\r\n        if (maxExpArray[hi] >= _x)\r\n            return hi;\r\n        if (maxExpArray[lo] >= _x)\r\n            return lo;\r\n\r\n        assert(false);\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n        This function can be auto-generated by the script 'PrintFunctionFixedExp.py'.\r\n        It approximates \"e ^ x\" via maclaurin summation: \"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\".\r\n        It returns \"e ^ (x / 2 ^ precision) * 2 ^ precision\", that is, the result is upshifted for accuracy.\r\n        The global \"maxExpArray\" maps each \"precision\" to \"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\".\r\n        The maximum permitted value for \"x\" is therefore given by \"maxExpArray[precision] >> (MAX_PRECISION - precision)\".\r\n    */\r\n    function fixedExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\r\n        uint256 xi = _x;\r\n        uint256 res = 0;\r\n\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x03442c4e6074a82f1797f72ac0000000; // add x^2 * (33! / 2!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0116b96f757c380fb287fd0e40000000; // add x^3 * (33! / 3!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0045ae5bdd5f0e03eca1ff4390000000; // add x^4 * (33! / 4!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000defabf91302cd95b9ffda50000000; // add x^5 * (33! / 5!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0002529ca9832b22439efff9b8000000; // add x^6 * (33! / 6!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000054f1cf12bd04e516b6da88000000; // add x^7 * (33! / 7!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000a9e39e257a09ca2d6db51000000; // add x^8 * (33! / 8!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000012e066e7b839fa050c309000000; // add x^9 * (33! / 9!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000052b6b54569976310000; // add x^17 * (33! / 17!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000004985f67696bf748000; // add x^18 * (33! / 18!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000001317c70077000; // add x^23 * (33! / 23!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000082573a0a00; // add x^25 * (33! / 25!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000005035ad900; // add x^26 * (33! / 26!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x0000000000000000000000002f881b00; // add x^27 * (33! / 27!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000001b29340; // add x^28 * (33! / 28!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x000000000000000000000000000efc40; // add x^29 * (33! / 29!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000007fe0; // add x^30 * (33! / 30!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000000420; // add x^31 * (33! / 31!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000000021; // add x^32 * (33! / 32!)\r\n        xi = (xi * _x) >> _precision;\r\n        res += xi * 0x00000000000000000000000000000001; // add x^33 * (33! / 33!)\r\n\r\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_connectorBalance\",\"type\":\"uint256\"},{\"name\":\"_connectorWeight\",\"type\":\"uint32\"},{\"name\":\"_depositAmount\",\"type\":\"uint256\"}],\"name\":\"calculatePurchaseReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_connectorBalance\",\"type\":\"uint256\"},{\"name\":\"_connectorWeight\",\"type\":\"uint32\"},{\"name\":\"_sellAmount\",\"type\":\"uint256\"}],\"name\":\"calculateSaleReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"BancorFormula","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cfa0750b888bab94df1dfecb2ba3d4d5b94a655ee7f150dbea9b37da1e49ddc9"}]}