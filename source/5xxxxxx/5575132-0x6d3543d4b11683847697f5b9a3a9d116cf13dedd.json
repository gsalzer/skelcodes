{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/******* USING Registry **************************\r\n\r\nGives the inherting contract access to:\r\n    .addressOf(bytes32): returns current address mapped to the name.\r\n    [modifier] .fromOwner(): requires the sender is owner.\r\n\r\n*************************************************/\r\n// Returned by .getRegistry()\r\ninterface IRegistry {\r\n    function owner() external view returns (address _addr);\r\n    function addressOf(bytes32 _name) external view returns (address _addr);\r\n}\r\n\r\ncontract UsingRegistry {\r\n    IRegistry private registry;\r\n\r\n    modifier fromOwner(){\r\n        require(msg.sender == getOwner());\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry)\r\n        public\r\n    {\r\n        require(_registry != 0);\r\n        registry = IRegistry(_registry);\r\n    }\r\n\r\n    function addressOf(bytes32 _name)\r\n        internal\r\n        view\r\n        returns(address _addr)\r\n    {\r\n        return registry.addressOf(_name);\r\n    }\r\n\r\n    function getOwner()\r\n        public\r\n        view\r\n        returns (address _addr)\r\n    {\r\n        return registry.owner();\r\n    }\r\n\r\n    function getRegistry()\r\n        public\r\n        view\r\n        returns (IRegistry _addr)\r\n    {\r\n        return registry;\r\n    }\r\n}\r\n\r\n/******* USING ADMIN ***********************\r\n\r\nGives the inherting contract access to:\r\n    .getAdmin(): returns the current address of the admin\r\n    [modifier] .fromAdmin: requires the sender is the admin\r\n\r\n*************************************************/\r\ncontract UsingAdmin is\r\n    UsingRegistry\r\n{\r\n    constructor(address _registry)\r\n        UsingRegistry(_registry)\r\n        public\r\n    {}\r\n\r\n    modifier fromAdmin(){\r\n        require(msg.sender == getAdmin());\r\n        _;\r\n    }\r\n    \r\n    function getAdmin()\r\n        public\r\n        constant\r\n        returns (address _addr)\r\n    {\r\n        return addressOf(\"ADMIN\");\r\n    }\r\n}\r\n\r\n/******* USING TREASURY **************************\r\n\r\nGives the inherting contract access to:\r\n    .getTreasury(): returns current ITreasury instance\r\n    [modifier] .fromTreasury(): requires the sender is current Treasury\r\n\r\n*************************************************/\r\n// Returned by .getTreasury()\r\ninterface ITreasury {\r\n    function issueDividend() external returns (uint _profits);\r\n    function profitsSendable() external view returns (uint _profits);\r\n}\r\n\r\ncontract UsingTreasury is\r\n    UsingRegistry\r\n{\r\n    constructor(address _registry)\r\n        UsingRegistry(_registry)\r\n        public\r\n    {}\r\n\r\n    modifier fromTreasury(){\r\n        require(msg.sender == address(getTreasury()));\r\n        _;\r\n    }\r\n    \r\n    function getTreasury()\r\n        public\r\n        view\r\n        returns (ITreasury)\r\n    {\r\n        return ITreasury(addressOf(\"TREASURY\"));\r\n    }\r\n}\r\n\r\n/**\r\n    This is a simple class that maintains a doubly linked list of\r\n    address => uint amounts. Address balances can be added to \r\n    or removed from via add() and subtract(). All balances can\r\n    be obtain by calling balances(). If an address has a 0 amount,\r\n    it is removed from the Ledger.\r\n\r\n    Note: THIS DOES NOT TEST FOR OVERFLOWS, but it's safe to\r\n          use to track Ether balances.\r\n\r\n    Public methods:\r\n      - [fromOwner] add()\r\n      - [fromOwner] subtract()\r\n    Public views:\r\n      - total()\r\n      - size()\r\n      - balanceOf()\r\n      - balances()\r\n      - entries() [to manually iterate]\r\n*/\r\ncontract Ledger {\r\n    uint public total;      // Total amount in Ledger\r\n\r\n    struct Entry {          // Doubly linked list tracks amount per address\r\n        uint balance;\r\n        address next;\r\n        address prev;\r\n    }\r\n    mapping (address => Entry) public entries;\r\n\r\n    address public owner;\r\n    modifier fromOwner() { require(msg.sender==owner); _; }\r\n\r\n    // Constructor sets the owner\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** OWNER METHODS ************************/\r\n    /******************************************************/\r\n\r\n    function add(address _address, uint _amt)\r\n        fromOwner\r\n        public\r\n    {\r\n        if (_address == address(0) || _amt == 0) return;\r\n        Entry storage entry = entries[_address];\r\n\r\n        // If new entry, replace first entry with this one.\r\n        if (entry.balance == 0) {\r\n            entry.next = entries[0x0].next;\r\n            entries[entries[0x0].next].prev = _address;\r\n            entries[0x0].next = _address;\r\n        }\r\n        // Update stats.\r\n        total += _amt;\r\n        entry.balance += _amt;\r\n    }\r\n\r\n    function subtract(address _address, uint _amt)\r\n        fromOwner\r\n        public\r\n        returns (uint _amtRemoved)\r\n    {\r\n        if (_address == address(0) || _amt == 0) return;\r\n        Entry storage entry = entries[_address];\r\n\r\n        uint _maxAmt = entry.balance;\r\n        if (_maxAmt == 0) return;\r\n        \r\n        if (_amt >= _maxAmt) {\r\n            // Subtract the max amount, and delete entry.\r\n            total -= _maxAmt;\r\n            entries[entry.prev].next = entry.next;\r\n            entries[entry.next].prev = entry.prev;\r\n            delete entries[_address];\r\n            return _maxAmt;\r\n        } else {\r\n            // Subtract the amount from entry.\r\n            total -= _amt;\r\n            entry.balance -= _amt;\r\n            return _amt;\r\n        }\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** PUBLIC VIEWS *************************/\r\n    /******************************************************/\r\n\r\n    function size()\r\n        public\r\n        view\r\n        returns (uint _size)\r\n    {\r\n        // Loop once to get the total count.\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _curEntry = entries[_curEntry.next];\r\n            _size++;\r\n        }\r\n        return _size;\r\n    }\r\n\r\n    function balanceOf(address _address)\r\n        public\r\n        view\r\n        returns (uint _balance)\r\n    {\r\n        return entries[_address].balance;\r\n    }\r\n\r\n    function balances()\r\n        public\r\n        view\r\n        returns (address[] _addresses, uint[] _balances)\r\n    {\r\n        // Populate names and addresses\r\n        uint _size = size();\r\n        _addresses = new address[](_size);\r\n        _balances = new uint[](_size);\r\n        uint _i = 0;\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _addresses[_i] = _curEntry.next;\r\n            _balances[_i] = entries[_curEntry.next].balance;\r\n            _curEntry = entries[_curEntry.next];\r\n            _i++;\r\n        }\r\n        return (_addresses, _balances);\r\n    }\r\n}\r\n\r\n/**\r\n    This is a simple class that maintains a doubly linked list of\r\n    addresses it has seen. Addresses can be added and removed\r\n    from the set, and a full list of addresses can be obtained.\r\n\r\n    Methods:\r\n     - [fromOwner] .add()\r\n     - [fromOwner] .remove()\r\n    Views:\r\n     - .size()\r\n     - .has()\r\n     - .addresses()\r\n*/\r\ncontract AddressSet {\r\n    \r\n    struct Entry {  // Doubly linked list\r\n        bool exists;\r\n        address next;\r\n        address prev;\r\n    }\r\n    mapping (address => Entry) public entries;\r\n\r\n    address public owner;\r\n    modifier fromOwner() { require(msg.sender==owner); _; }\r\n\r\n    // Constructor sets the owner.\r\n    constructor(address _owner)\r\n        public\r\n    {\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** OWNER METHODS ************************/\r\n    /******************************************************/\r\n\r\n    function add(address _address)\r\n        fromOwner\r\n        public\r\n        returns (bool _didCreate)\r\n    {\r\n        // Do not allow the adding of HEAD.\r\n        if (_address == address(0)) return;\r\n        Entry storage entry = entries[_address];\r\n        // If already exists, do nothing. Otherwise set it.\r\n        if (entry.exists) return;\r\n        else entry.exists = true;\r\n\r\n        // Replace first entry with this one.\r\n        // Before: HEAD <-> X <-> Y\r\n        // After: HEAD <-> THIS <-> X <-> Y\r\n        // do: THIS.NEXT = [0].next; [0].next.prev = THIS; [0].next = THIS; THIS.prev = 0;\r\n        Entry storage HEAD = entries[0x0];\r\n        entry.next = HEAD.next;\r\n        entries[HEAD.next].prev = _address;\r\n        HEAD.next = _address;\r\n        return true;\r\n    }\r\n\r\n    function remove(address _address)\r\n        fromOwner\r\n        public\r\n        returns (bool _didExist)\r\n    {\r\n        // Do not allow the removal of HEAD.\r\n        if (_address == address(0)) return;\r\n        Entry storage entry = entries[_address];\r\n        // If it doesn't exist already, there is nothing to do.\r\n        if (!entry.exists) return;\r\n\r\n        // Stitch together next and prev, delete entry.\r\n        // Before: X <-> THIS <-> Y\r\n        // After: X <-> Y\r\n        // do: THIS.next.prev = this.prev; THIS.prev.next = THIS.next;\r\n        entries[entry.prev].next = entry.next;\r\n        entries[entry.next].prev = entry.prev;\r\n        delete entries[_address];\r\n        return true;\r\n    }\r\n\r\n\r\n    /******************************************************/\r\n    /*************** PUBLIC VIEWS *************************/\r\n    /******************************************************/\r\n\r\n    function size()\r\n        public\r\n        view\r\n        returns (uint _size)\r\n    {\r\n        // Loop once to get the total count.\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _curEntry = entries[_curEntry.next];\r\n            _size++;\r\n        }\r\n        return _size;\r\n    }\r\n\r\n    function has(address _address)\r\n        public\r\n        view\r\n        returns (bool _exists)\r\n    {\r\n        return entries[_address].exists;\r\n    }\r\n\r\n    function addresses()\r\n        public\r\n        view\r\n        returns (address[] _addresses)\r\n    {\r\n        // Populate names and addresses\r\n        uint _size = size();\r\n        _addresses = new address[](_size);\r\n        // Iterate forward through all entries until the end.\r\n        uint _i = 0;\r\n        Entry memory _curEntry = entries[0x0];\r\n        while (_curEntry.next > 0) {\r\n            _addresses[_i] = _curEntry.next;\r\n            _curEntry = entries[_curEntry.next];\r\n            _i++;\r\n        }\r\n        return _addresses;\r\n    }\r\n}\r\n\r\n/**\r\n  A simple class that manages bankroll, and maintains collateral.\r\n  This class only ever sends profits the Treasury. No exceptions.\r\n\r\n  - Anybody can add funding (according to whitelist)\r\n  - Anybody can tell profits (balance - (funding + collateral)) to go to Treasury.\r\n  - Anyone can remove their funding, so long as balance >= collateral.\r\n  - Whitelist is managed by getWhitelistOwner() -- typically Admin.\r\n\r\n  Exposes the following:\r\n    Public Methods\r\n     - addBankroll\r\n     - removeBankroll\r\n     - sendProfits\r\n    Public Views\r\n     - getCollateral\r\n     - profits\r\n     - profitsSent\r\n     - profitsTotal\r\n     - bankroll\r\n     - bankrollAvailable\r\n     - bankrolledBy\r\n     - bankrollerTable\r\n*/\r\ncontract Bankrollable is\r\n    UsingTreasury\r\n{   \r\n    // How much profits have been sent. \r\n    uint public profitsSent;\r\n    // Ledger keeps track of who has bankrolled us, and for how much\r\n    Ledger public ledger;\r\n    // This is a copy of ledger.total(), to save gas in .bankrollAvailable()\r\n    uint public bankroll;\r\n    // This is the whitelist of who can call .addBankroll()\r\n    AddressSet public whitelist;\r\n\r\n    modifier fromWhitelistOwner(){\r\n        require(msg.sender == getWhitelistOwner());\r\n        _;\r\n    }\r\n\r\n    event BankrollAdded(uint time, address indexed bankroller, uint amount, uint bankroll);\r\n    event BankrollRemoved(uint time, address indexed bankroller, uint amount, uint bankroll);\r\n    event ProfitsSent(uint time, address indexed treasury, uint amount);\r\n    event AddedToWhitelist(uint time, address indexed addr, address indexed wlOwner);\r\n    event RemovedFromWhitelist(uint time, address indexed addr, address indexed wlOwner);\r\n\r\n    // Constructor creates the ledger and whitelist, with self as owner.\r\n    constructor(address _registry)\r\n        UsingTreasury(_registry)\r\n        public\r\n    {\r\n        ledger = new Ledger(this);\r\n        whitelist = new AddressSet(this);\r\n    }\r\n\r\n\r\n    /*****************************************************/\r\n    /************** WHITELIST MGMT ***********************/\r\n    /*****************************************************/    \r\n\r\n    function addToWhitelist(address _addr)\r\n        fromWhitelistOwner\r\n        public\r\n    {\r\n        bool _didAdd = whitelist.add(_addr);\r\n        if (_didAdd) emit AddedToWhitelist(now, _addr, msg.sender);\r\n    }\r\n\r\n    function removeFromWhitelist(address _addr)\r\n        fromWhitelistOwner\r\n        public\r\n    {\r\n        bool _didRemove = whitelist.remove(_addr);\r\n        if (_didRemove) emit RemovedFromWhitelist(now, _addr, msg.sender);\r\n    }\r\n\r\n    /*****************************************************/\r\n    /************** PUBLIC FUNCTIONS *********************/\r\n    /*****************************************************/\r\n\r\n    // Bankrollable contracts should be payable (to receive revenue)\r\n    function () public payable {}\r\n\r\n    // Increase funding by whatever value is sent\r\n    function addBankroll()\r\n        public\r\n        payable \r\n    {\r\n        require(whitelist.size()==0 || whitelist.has(msg.sender));\r\n        ledger.add(msg.sender, msg.value);\r\n        bankroll = ledger.total();\r\n        emit BankrollAdded(now, msg.sender, msg.value, bankroll);\r\n    }\r\n\r\n    // Removes up to _amount from Ledger, and sends it to msg.sender._callbackFn\r\n    function removeBankroll(uint _amount, string _callbackFn)\r\n        public\r\n        returns (uint _recalled)\r\n    {\r\n        // cap amount at the balance minus collateral, or nothing at all.\r\n        address _bankroller = msg.sender;\r\n        uint _collateral = getCollateral();\r\n        uint _balance = address(this).balance;\r\n        uint _available = _balance > _collateral ? _balance - _collateral : 0;\r\n        if (_amount > _available) _amount = _available;\r\n\r\n        // Try to remove _amount from ledger, get actual _amount removed.\r\n        _amount = ledger.subtract(_bankroller, _amount);\r\n        bankroll = ledger.total();\r\n        if (_amount == 0) return;\r\n\r\n        bytes4 _sig = bytes4(keccak256(_callbackFn));\r\n        require(_bankroller.call.value(_amount)(_sig));\r\n        emit BankrollRemoved(now, _bankroller, _amount, bankroll);\r\n        return _amount;\r\n    }\r\n\r\n    // Send any excess profits to treasury.\r\n    function sendProfits()\r\n        public\r\n        returns (uint _profits)\r\n    {\r\n        int _p = profits();\r\n        if (_p <= 0) return;\r\n        _profits = uint(_p);\r\n        profitsSent += _profits;\r\n        // Send profits to Treasury\r\n        address _tr = getTreasury();\r\n        require(_tr.call.value(_profits)());\r\n        emit ProfitsSent(now, _tr, _profits);\r\n    }\r\n\r\n\r\n    /*****************************************************/\r\n    /************** PUBLIC VIEWS *************************/\r\n    /*****************************************************/\r\n\r\n    // Function must be overridden by inheritors to ensure collateral is kept.\r\n    function getCollateral()\r\n        public\r\n        view\r\n        returns (uint _amount);\r\n\r\n    // Function must be overridden by inheritors to enable whitelist control.\r\n    function getWhitelistOwner()\r\n        public\r\n        view\r\n        returns (address _addr);\r\n\r\n    // Profits are the difference between balance and threshold\r\n    function profits()\r\n        public\r\n        view\r\n        returns (int _profits)\r\n    {\r\n        int _balance = int(address(this).balance);\r\n        int _threshold = int(bankroll + getCollateral());\r\n        return _balance - _threshold;\r\n    }\r\n\r\n    // How profitable this contract is, overall\r\n    function profitsTotal()\r\n        public\r\n        view\r\n        returns (int _profits)\r\n    {\r\n        return int(profitsSent) + profits();\r\n    }\r\n\r\n    // Returns the amount that can currently be bankrolled.\r\n    //   - 0 if balance < collateral\r\n    //   - If profits: full bankroll\r\n    //   - If no profits: remaning bankroll: balance - collateral\r\n    function bankrollAvailable()\r\n        public\r\n        view\r\n        returns (uint _amount)\r\n    {\r\n        uint _balance = address(this).balance;\r\n        uint _bankroll = bankroll;\r\n        uint _collat = getCollateral();\r\n        // Balance is below collateral!\r\n        if (_balance <= _collat) return 0;\r\n        // No profits, but we have a balance over collateral.\r\n        else if (_balance < _collat + _bankroll) return _balance - _collat;\r\n        // Profits. Return only _bankroll\r\n        else return _bankroll;\r\n    }\r\n\r\n    function bankrolledBy(address _addr)\r\n        public\r\n        view\r\n        returns (uint _amount)\r\n    {\r\n        return ledger.balanceOf(_addr);\r\n    }\r\n\r\n    function bankrollerTable()\r\n        public\r\n        view\r\n        returns (address[], uint[])\r\n    {\r\n        return ledger.balances();\r\n    }\r\n}\r\n\r\ncontract VideoPokerUtils {\r\n    uint constant HAND_UNDEFINED = 0;\r\n    uint constant HAND_RF = 1;\r\n    uint constant HAND_SF = 2;\r\n    uint constant HAND_FK = 3;\r\n    uint constant HAND_FH = 4;\r\n    uint constant HAND_FL = 5;\r\n    uint constant HAND_ST = 6;\r\n    uint constant HAND_TK = 7;\r\n    uint constant HAND_TP = 8;\r\n    uint constant HAND_JB = 9;\r\n    uint constant HAND_HC = 10;\r\n    uint constant HAND_NOT_COMPUTABLE = 11;\r\n\r\n    /*****************************************************/\r\n    /********** PUBLIC PURE FUNCTIONS ********************/\r\n    /*****************************************************/\r\n\r\n    // Gets a new 5-card hand, stored in uint32\r\n    // Gas Cost: 3k\r\n    function getHand(uint256 _hash)\r\n        public\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        // Return the cards as a hand.\r\n        return uint32(getCardsFromHash(_hash, 5, 0));\r\n    }\r\n\r\n    // Both _hand and _draws store the first card in the\r\n    //   rightmost position. _hand uses chunks of 6 bits.\r\n    //\r\n    // In the below example, hand is [9,18,35,12,32], and\r\n    // the cards 18 and 35 will be replaced.\r\n    //\r\n    // _hand:                                [9,18,35,12,32]  \r\n    //    encoding:    XX 100000 001100 100011 010010 001001\r\n    //      chunks:           32     12     35     18      9\r\n    //       order:        card5, card4, card3, card2, card1\r\n    //     decimal:                                540161161\r\n    //\r\n    // _draws:                               card2 and card4\r\n    //    encoding:   XXX      0      0      1      1      0\r\n    //       order:        card5, card4, card3, card2, card1 \r\n    //     decimal:                                        6\r\n    // \r\n    // Gas Cost: Fixed 6k gas. \r\n    function drawToHand(uint256 _hash, uint32 _hand, uint _draws)\r\n        public\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        // Draws must be valid. If no hand, must draw all 5 cards.\r\n        assert(_draws <= 31);\r\n        assert(_hand != 0 || _draws == 31);\r\n        // Shortcuts. Return _hand on no draws, or 5 cards on full draw.\r\n        if (_draws == 0) return _hand;\r\n        if (_draws == 31) return uint32(getCardsFromHash(_hash, 5, handToBitmap(_hand)));\r\n\r\n        // Create a mask of 1's where new cards should go.\r\n        uint _newMask;\r\n        for (uint _i=0; _i<5; _i++) {\r\n            if (_draws & 2**_i == 0) continue;\r\n            _newMask |= 63 * (2**(6*_i));\r\n        }\r\n        // Create a mask of 0's where new cards should go.\r\n        // Be sure to use only first 30 bits (5 cards x 6 bits)\r\n        uint _discardMask = ~_newMask & (2**31-1);\r\n\r\n        // Select from _newHand, discard from _hand, and combine.\r\n        uint _newHand = getCardsFromHash(_hash, 5, handToBitmap(_hand));\r\n        _newHand &= _newMask;\r\n        _newHand |= _hand & _discardMask;\r\n        return uint32(_newHand);\r\n    }\r\n\r\n    // Looks at a hand of 5-cards, determines strictly the HandRank.\r\n    // Gas Cost: up to 7k depending on hand.\r\n    function getHandRank(uint32 _hand)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (_hand == 0) return HAND_NOT_COMPUTABLE;\r\n\r\n        uint _card;\r\n        uint[] memory _valCounts = new uint[](13);\r\n        uint[] memory _suitCounts = new uint[](5);\r\n        uint _pairVal;\r\n        uint _minNonAce = 100;\r\n        uint _maxNonAce = 0;\r\n        uint _numPairs;\r\n        uint _maxSet;\r\n        bool _hasFlush;\r\n        bool _hasAce;\r\n\r\n        // Set all the values above.\r\n        // Note:\r\n        //   _hasTwoPair will be true even if one pair is Trips.\r\n        //   Likewise, _hasTrips will be true even if there are Quads.\r\n        uint _i;\r\n        uint _val;\r\n        for (_i=0; _i<5; _i++) {\r\n            _card = readFromCards(_hand, _i);\r\n            if (_card > 51) return HAND_NOT_COMPUTABLE;\r\n            \r\n            // update val and suit counts, and if it's a flush\r\n            _val = _card % 13;\r\n            _valCounts[_val]++;\r\n            _suitCounts[_card/13]++;\r\n            if (_suitCounts[_card/13] == 5) _hasFlush = true;\r\n            \r\n            // update _hasAce, and min/max value\r\n            if (_val == 0) {\r\n                _hasAce = true;\r\n            } else {\r\n                if (_val < _minNonAce) _minNonAce = _val;\r\n                if (_val > _maxNonAce) _maxNonAce = _val;\r\n            }\r\n\r\n            // update _pairVal, _numPairs, _maxSet\r\n            if (_valCounts[_val] == 2) {\r\n                if (_numPairs==0) _pairVal = _val;\r\n                _numPairs++;\r\n            } else if (_valCounts[_val] == 3) {\r\n                _maxSet = 3;\r\n            } else if (_valCounts[_val] == 4) {\r\n                _maxSet = 4;\r\n            }\r\n        }\r\n\r\n        if (_numPairs > 0){\r\n            // If they have quads, they can't have royal flush, so we can return.\r\n            if (_maxSet==4) return HAND_FK;\r\n            // One of the two pairs was the trips, so it's a full house.\r\n            if (_maxSet==3 && _numPairs==2) return HAND_FH;\r\n            // Trips is their best hand (no straight or flush possible)\r\n            if (_maxSet==3) return HAND_TK;\r\n            // Two pair is their best hand (no straight or flush possible)\r\n            if (_numPairs==2) return HAND_TP;\r\n            // One pair is their best hand (no straight or flush possible)\r\n            if (_numPairs == 1 && (_pairVal >= 10 || _pairVal==0)) return HAND_JB;\r\n            // They have a low pair (no straight or flush possible)\r\n            return HAND_HC;\r\n        }\r\n\r\n        // They have no pair. Do they have a straight?\r\n        bool _hasStraight = _hasAce\r\n            // Check for: A,1,2,3,4 or 9,10,11,12,A\r\n            ? _maxNonAce == 4 || _minNonAce == 9\r\n            // Check for X,X+1,X+2,X+3,X+4\r\n            : _maxNonAce - _minNonAce == 4;\r\n        \r\n        // Check for hands in order of rank.\r\n        if (_hasStraight && _hasFlush && _minNonAce==9) return HAND_RF;\r\n        if (_hasStraight && _hasFlush) return HAND_SF;\r\n        if (_hasFlush) return HAND_FL;\r\n        if (_hasStraight) return HAND_ST;\r\n        return HAND_HC;\r\n    }\r\n\r\n    // Not used anywhere, but added for convenience\r\n    function handToCards(uint32 _hand)\r\n        public\r\n        pure\r\n        returns (uint8[5] _cards)\r\n    {\r\n        uint32 _mask;\r\n        for (uint _i=0; _i<5; _i++){\r\n            _mask = uint32(63 * 2**(6*_i));\r\n            _cards[_i] = uint8((_hand & _mask) / (2**(6*_i)));\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /*****************************************************/\r\n    /********** PRIVATE INTERNAL FUNCTIONS ***************/\r\n    /*****************************************************/\r\n\r\n    function readFromCards(uint _cards, uint _index)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint _offset = 2**(6*_index);\r\n        uint _oneBits = 2**6 - 1;\r\n        return (_cards & (_oneBits * _offset)) / _offset;\r\n    }\r\n\r\n    // Returns a bitmap to represent the set of cards in _hand.\r\n    function handToBitmap(uint32 _hand)\r\n        internal\r\n        pure\r\n        returns (uint _bitmap)\r\n    {\r\n        if (_hand == 0) return 0;\r\n        uint _mask;\r\n        uint _card;\r\n        for (uint _i=0; _i<5; _i++){\r\n            _mask = 63 * 2**(6*_i);\r\n            _card = (_hand & _mask) / (2**(6*_i));\r\n            _bitmap |= 2**_card;\r\n        }\r\n    }\r\n\r\n    // Returns numCards from a uint256 (eg, keccak256) seed hash.\r\n    // Returns cards as one uint, with each card being 6 bits.\r\n    function getCardsFromHash(uint256 _hash, uint _numCards, uint _usedBitmap)\r\n        internal\r\n        pure\r\n        returns (uint _cards)\r\n    {\r\n        // Return early if we don't need to pick any cards.\r\n        if (_numCards == 0) return;\r\n\r\n        uint _cardIdx = 0;                // index of currentCard\r\n        uint _card;                       // current chosen card\r\n        uint _usedMask;                   // mask of current card\r\n\r\n        while (true) {\r\n            _card = _hash % 52;           // Generate card from hash\r\n            _usedMask = 2**_card;         // Create mask for the card\r\n\r\n            // If card is not used, add it to _cards and _usedBitmap\r\n            // Return if we have enough cards.\r\n            if (_usedBitmap & _usedMask == 0) {\r\n                _cards |= (_card * 2**(_cardIdx*6));\r\n                _usedBitmap |= _usedMask;\r\n                _cardIdx++;\r\n                if (_cardIdx == _numCards) return _cards;\r\n            }\r\n\r\n            // Generate hash used to pick next card.\r\n            _hash = uint256(keccak256(_hash));\r\n        }\r\n    }\r\n}\r\n\r\ncontract VideoPoker is\r\n    VideoPokerUtils,\r\n    Bankrollable,\r\n    UsingAdmin\r\n{\r\n    // All the data needed for each game.\r\n    struct Game {\r\n        // [1st 256-bit block]\r\n        uint32 userId;\r\n        uint64 bet;         // max of 18 Ether (set on bet)\r\n        uint16 payTableId;  // the PayTable used (set on bet)\r\n        uint32 iBlock;      // initial hand block (set on bet)\r\n        uint32 iHand;       // initial hand (set on draw/finalize)\r\n        uint8 draws;        // bitmap of which cards to draw (set on draw/finalize)\r\n        uint32 dBlock;      // block of the dHand (set on draw/finalize)\r\n        uint32 dHand;       // hand after draws (set on finalize)\r\n        uint8 handRank;     // result of the hand (set on finalize)\r\n    }\r\n\r\n    // These variables change on each bet and finalization.\r\n    // We put them in a struct with the hopes that optimizer\r\n    //   will do one write if any/all of them change.\r\n    struct Vars {\r\n        // [1st 256-bit block]\r\n        uint32 curId;               // (changes on bet)\r\n        uint64 totalWageredGwei;    // (changes on bet)\r\n        uint32 curUserId;           // (changes on bet, maybe)\r\n        uint128 empty1;             // intentionally left empty, so the below\r\n                                    //   updates occur in the same update\r\n        // [2nd 256-bit block]\r\n        uint64 totalWonGwei;        // (changes on finalization win)\r\n        uint88 totalCredits;        // (changes on finalization win)\r\n        uint8 empty2;               // set to true to normalize gas cost\r\n    }\r\n\r\n    struct Settings {\r\n        uint64 minBet;\r\n        uint64 maxBet;\r\n        uint16 curPayTableId;\r\n        uint16 numPayTables;\r\n        uint32 lastDayAdded;\r\n    }\r\n\r\n    Settings settings;\r\n    Vars vars;\r\n\r\n    // A Mapping of all games\r\n    mapping(uint32 => Game) public games;\r\n    \r\n    // Credits we owe the user\r\n    mapping(address => uint) public credits;\r\n\r\n    // Store a two-way mapping of address <=> userId\r\n    // If we've seen a user before, betting will be just 1 write\r\n    //  per Game struct vs 2 writes.\r\n    // The trade-off is 3 writes for new users. Seems fair.\r\n    mapping (address => uint32) public userIds;\r\n    mapping (uint32 => address) public userAddresses;\r\n\r\n    // Note: Pay tables cannot be changed once added.\r\n    // However, admin can change the current PayTable\r\n    mapping(uint16=>uint16[12]) payTables;\r\n\r\n    // version of the game\r\n    uint8 public constant version = 1;\r\n    uint8 constant WARN_IHAND_TIMEOUT = 1; // \"Initial hand not available. Drawing 5 new cards.\"\r\n    uint8 constant WARN_DHAND_TIMEOUT = 2; // \"Draw cards not available. Using initial hand.\"\r\n    uint8 constant WARN_BOTH_TIMEOUT = 3;  // \"Draw cards not available, and no initial hand.\"\r\n    \r\n    // Admin Events\r\n    event Created(uint time);\r\n    event PayTableAdded(uint time, address admin, uint payTableId);\r\n    event SettingsChanged(uint time, address admin);\r\n    // Game Events\r\n    event BetSuccess(uint time, address indexed user, uint32 indexed id, uint bet, uint payTableId);\r\n    event BetFailure(uint time, address indexed user, uint bet, string msg);\r\n    event DrawSuccess(uint time, address indexed user, uint32 indexed id, uint32 iHand, uint8 draws, uint8 warnCode);\r\n    event DrawFailure(uint time, address indexed user, uint32 indexed id, uint8 draws, string msg);\r\n    event FinalizeSuccess(uint time, address indexed user, uint32 indexed id, uint32 dHand, uint8 handRank, uint payout, uint8 warnCode);\r\n    event FinalizeFailure(uint time, address indexed user, uint32 indexed id, string msg);\r\n    // Credits\r\n    event CreditsAdded(uint time, address indexed user, uint32 indexed id, uint amount);\r\n    event CreditsUsed(uint time, address indexed user, uint32 indexed id, uint amount);\r\n    event CreditsCashedout(uint time, address indexed user, uint amount);\r\n        \r\n    constructor(address _registry)\r\n        Bankrollable(_registry)\r\n        UsingAdmin(_registry)\r\n        public\r\n    {\r\n        // Add the default PayTable.\r\n        _addPayTable(800, 50, 25, 9, 6, 4, 3, 2, 1);\r\n        // write to vars, to lower gas-cost for the first game.\r\n        vars.empty1 = 1;\r\n        vars.empty2 = 1;\r\n        // initialize settings\r\n        settings.minBet = .001 ether;\r\n        settings.maxBet = .5 ether;\r\n        emit Created(now);\r\n    }\r\n    \r\n    \r\n    /************************************************************/\r\n    /******************** ADMIN FUNCTIONS ***********************/\r\n    /************************************************************/\r\n    \r\n    // Allows admin to change minBet, maxBet, and curPayTableId\r\n    function changeSettings(uint64 _minBet, uint64 _maxBet, uint8 _payTableId)\r\n        public\r\n        fromAdmin\r\n    {\r\n        require(_minBet <= _maxBet);\r\n        require(_maxBet <= .625 ether);\r\n        require(_payTableId < settings.numPayTables);\r\n        settings.minBet = _minBet;\r\n        settings.maxBet = _maxBet;\r\n        settings.curPayTableId = _payTableId;\r\n        emit SettingsChanged(now, msg.sender);\r\n    }\r\n    \r\n    // Allows admin to permanently add a PayTable (once per day)\r\n    function addPayTable(\r\n        uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh,\r\n        uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb\r\n    )\r\n        public\r\n        fromAdmin\r\n    {\r\n        uint32 _today = uint32(block.timestamp / 1 days);\r\n        require(settings.lastDayAdded < _today);\r\n        settings.lastDayAdded = _today;\r\n        _addPayTable(_rf, _sf, _fk, _fh, _fl, _st, _tk, _tp, _jb);\r\n        emit PayTableAdded(now, msg.sender, settings.numPayTables-1);\r\n    }\r\n    \r\n\r\n    /************************************************************/\r\n    /****************** PUBLIC FUNCTIONS ************************/\r\n    /************************************************************/\r\n\r\n    // Allows a user to add credits to their account.\r\n    function addCredits()\r\n        public\r\n        payable\r\n    {\r\n        _creditUser(msg.sender, msg.value, 0);\r\n    }\r\n\r\n    // Allows the user to cashout an amt (or their whole balance)\r\n    function cashOut(uint _amt)\r\n        public\r\n    {\r\n        _uncreditUser(msg.sender, _amt);\r\n    }\r\n\r\n    // Allows a user to create a game from Ether sent.\r\n    //\r\n    // Gas Cost: 55k (prev player), 95k (new player)\r\n    //   - 22k: tx overhead\r\n    //   - 26k, 66k: see _createNewGame()\r\n    //   -  3k: event\r\n    //   -  2k: curMaxBet()\r\n    //   -  2k: SLOAD, execution\r\n    function bet()\r\n        public\r\n        payable\r\n    {\r\n        uint _bet = msg.value;\r\n        if (_bet > settings.maxBet)\r\n            return _betFailure(\"Bet too large.\", _bet, true);\r\n        if (_bet < settings.minBet)\r\n            return _betFailure(\"Bet too small.\", _bet, true);\r\n        if (_bet > curMaxBet())\r\n            return _betFailure(\"The bankroll is too low.\", _bet, true);\r\n\r\n        // no uint64 overflow: _bet < maxBet < .625 ETH < 2e64\r\n        uint32 _id = _createNewGame(uint64(_bet));\r\n        emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId);\r\n    }\r\n\r\n    // Allows a user to create a game from Credits.\r\n    //\r\n    // Gas Cost: 61k\r\n    //   - 22k: tx overhead\r\n    //   - 26k: see _createNewGame()\r\n    //   -  3k: event\r\n    //   -  2k: curMaxBet()\r\n    //   -  2k: 1 event: CreditsUsed\r\n    //   -  5k: update credits[user]\r\n    //   -  1k: SLOAD, execution\r\n    function betWithCredits(uint64 _bet)\r\n        public\r\n    {\r\n        if (_bet > settings.maxBet)\r\n            return _betFailure(\"Bet too large.\", _bet, false);\r\n        if (_bet < settings.minBet)\r\n            return _betFailure(\"Bet too small.\", _bet, false);\r\n        if (_bet > curMaxBet())\r\n            return _betFailure(\"The bankroll is too low.\", _bet, false);\r\n        if (_bet > credits[msg.sender])\r\n            return _betFailure(\"Insufficient credits\", _bet, false);\r\n\r\n        uint32 _id = _createNewGame(uint64(_bet));\r\n        credits[msg.sender] -= _bet;\r\n        emit CreditsUsed(now, msg.sender, _id, _bet);\r\n        emit BetSuccess(now, msg.sender, _id, _bet, settings.curPayTableId);\r\n    }\r\n\r\n    function betFromGame(uint32 _id, bytes32 _hashCheck)\r\n        public\r\n    {\r\n        bool _didFinalize = finalize(_id, _hashCheck);\r\n        uint64 _bet = games[_id].bet;\r\n        if (!_didFinalize)\r\n            return _betFailure(\"Failed to finalize prior game.\", _bet, false);\r\n        betWithCredits(_bet);\r\n    }\r\n\r\n        // Logs an error, and optionally refunds user the _bet\r\n        function _betFailure(string _msg, uint _bet, bool _doRefund)\r\n            private\r\n        {\r\n            if (_doRefund) require(msg.sender.call.value(_bet)());\r\n            emit BetFailure(now, msg.sender, _bet, _msg);\r\n        }\r\n        \r\n\r\n    // Resolves the initial hand (if possible) and sets the users draws.\r\n    // Users cannot draw 0 cards. They should instead use finalize().\r\n    //\r\n    // Notes:\r\n    //  - If user unable to resolve initial hand, sets draws to 5\r\n    //  - This always sets game.dBlock\r\n    //\r\n    // Gas Cost: ~38k\r\n    //   - 23k: tx\r\n    //   - 13k: see _draw()\r\n    //   -  2k: SLOADs, execution\r\n    function draw(uint32 _id, uint8 _draws, bytes32 _hashCheck)\r\n        public\r\n    {\r\n        Game storage _game = games[_id];\r\n        address _user = userAddresses[_game.userId];\r\n        if (_game.iBlock == 0)\r\n            return _drawFailure(_id, _draws, \"Invalid game Id.\");\r\n        if (_user != msg.sender)\r\n            return _drawFailure(_id, _draws, \"This is not your game.\");\r\n        if (_game.iBlock == block.number)\r\n            return _drawFailure(_id, _draws, \"Initial cards not available.\");\r\n        if (_game.dBlock != 0)\r\n            return _drawFailure(_id, _draws, \"Cards already drawn.\");\r\n        if (_draws > 31)\r\n            return _drawFailure(_id, _draws, \"Invalid draws.\");\r\n        if (_draws == 0)\r\n            return _drawFailure(_id, _draws, \"Cannot draw 0 cards. Use finalize instead.\");\r\n        if (_game.handRank != HAND_UNDEFINED)\r\n            return _drawFailure(_id, _draws, \"Game already finalized.\");\r\n        \r\n        _draw(_game, _id, _draws, _hashCheck);\r\n    }\r\n        function _drawFailure(uint32 _id, uint8 _draws, string _msg)\r\n            private\r\n        {\r\n            emit DrawFailure(now, msg.sender, _id, _draws, _msg);\r\n        }\r\n      \r\n\r\n    // Callable any time after the initial hand. Will assume\r\n    // no draws if called directly after new hand.\r\n    //\r\n    // Gas Cost: 44k (loss), 59k (win, has credits), 72k (win, no credits)\r\n    //   - 22k: tx overhead\r\n    //   - 21k, 36k, 49k: see _finalize()\r\n    //   -  1k: SLOADs, execution\r\n    function finalize(uint32 _id, bytes32 _hashCheck)\r\n        public\r\n        returns (bool _didFinalize)\r\n    {\r\n        Game storage _game = games[_id];\r\n        address _user = userAddresses[_game.userId];\r\n        if (_game.iBlock == 0)\r\n            return _finalizeFailure(_id, \"Invalid game Id.\");\r\n        if (_user != msg.sender)\r\n            return _finalizeFailure(_id, \"This is not your game.\");\r\n        if (_game.iBlock == block.number)\r\n            return _finalizeFailure(_id, \"Initial hand not avaiable.\");\r\n        if (_game.dBlock == block.number)\r\n            return _finalizeFailure(_id, \"Drawn cards not available.\");\r\n        if (_game.handRank != HAND_UNDEFINED)\r\n            return _finalizeFailure(_id, \"Game already finalized.\");\r\n\r\n        _finalize(_game, _id, _hashCheck);\r\n        return true;\r\n    }\r\n        function _finalizeFailure(uint32 _id, string _msg)\r\n            private\r\n            returns (bool)\r\n        {\r\n            emit FinalizeFailure(now, msg.sender, _id, _msg);\r\n            return false;\r\n        }\r\n\r\n\r\n    /************************************************************/\r\n    /****************** PRIVATE FUNCTIONS ***********************/\r\n    /************************************************************/\r\n\r\n    // Appends a PayTable to the mapping.\r\n    // It ensures sane values. (Double the defaults)\r\n    function _addPayTable(\r\n        uint16 _rf, uint16 _sf, uint16 _fk, uint16 _fh,\r\n        uint16 _fl, uint16 _st, uint16 _tk, uint16 _tp, uint16 _jb\r\n    )\r\n        private\r\n    {\r\n        require(_rf<=1600 && _sf<=100 && _fk<=50 && _fh<=18 && _fl<=12 \r\n                 && _st<=8 && _tk<=6 && _tp<=4 && _jb<=2);\r\n\r\n        uint16[12] memory _pt;\r\n        _pt[HAND_UNDEFINED] = 0;\r\n        _pt[HAND_RF] = _rf;\r\n        _pt[HAND_SF] = _sf;\r\n        _pt[HAND_FK] = _fk;\r\n        _pt[HAND_FH] = _fh;\r\n        _pt[HAND_FL] = _fl;\r\n        _pt[HAND_ST] = _st;\r\n        _pt[HAND_TK] = _tk;\r\n        _pt[HAND_TP] = _tp;\r\n        _pt[HAND_JB] = _jb;\r\n        _pt[HAND_HC] = 0;\r\n        _pt[HAND_NOT_COMPUTABLE] = 0;\r\n        payTables[settings.numPayTables] = _pt;\r\n        settings.numPayTables++;\r\n    }\r\n\r\n    // Increases totalCredits and credits[user]\r\n    // Optionally increases totalWonGwei stat.\r\n    function _creditUser(address _user, uint _amt, uint32 _gameId)\r\n        private\r\n    {\r\n        if (_amt == 0) return;\r\n        uint64 _incr = _gameId == 0 ? 0 : uint64(_amt / 1e9);\r\n        uint88 _totalCredits = vars.totalCredits + uint88(_amt);\r\n        uint64 _totalWonGwei = vars.totalWonGwei + _incr;\r\n        vars.totalCredits = _totalCredits;\r\n        vars.totalWonGwei = _totalWonGwei;\r\n        credits[_user] += _amt;\r\n        emit CreditsAdded(now, _user, _gameId, _amt);\r\n    }\r\n\r\n    // Lowers totalCredits and credits[user].\r\n    // Sends to user, using unlimited gas.\r\n    function _uncreditUser(address _user, uint _amt)\r\n        private\r\n    {\r\n        if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];\r\n        if (_amt == 0) return;\r\n        vars.totalCredits -= uint88(_amt);\r\n        credits[_user] -= _amt;\r\n        require(_user.call.value(_amt)());\r\n        emit CreditsCashedout(now, _user, _amt);\r\n    }\r\n\r\n    // Creates a new game with the specified bet and current PayTable.\r\n    // Does no validation of the _bet size.\r\n    //\r\n    // Gas Cost: 26k, 66k\r\n    //   Overhead:\r\n    //     - 20k: 1 writes: Game\r\n    //     -  5k: 1 update: vars\r\n    //     -  1k: SLOAD, execution\r\n    //   New User:\r\n    //     - 40k: 2 writes: userIds, userAddresses\r\n    //   Repeat User:\r\n    //     -  0k: nothing extra\r\n    function _createNewGame(uint64 _bet)\r\n        private\r\n        returns (uint32 _curId)\r\n    {\r\n        // get or create user id\r\n        uint32 _curUserId = vars.curUserId;\r\n        uint32 _userId = userIds[msg.sender];\r\n        if (_userId == 0) {\r\n            _curUserId++;\r\n            userIds[msg.sender] = _curUserId;\r\n            userAddresses[_curUserId] = msg.sender;\r\n            _userId = _curUserId;\r\n        }\r\n\r\n        // increment vars\r\n        _curId =  vars.curId + 1;\r\n        uint64 _totalWagered = vars.totalWageredGwei + _bet / 1e9;\r\n        vars.curId = _curId;\r\n        vars.totalWageredGwei = _totalWagered;\r\n        vars.curUserId = _curUserId;\r\n\r\n        // save game\r\n        uint16 _payTableId = settings.curPayTableId;\r\n        Game storage _game = games[_curId];\r\n        _game.userId = _userId;\r\n        _game.bet = _bet;\r\n        _game.payTableId = _payTableId;\r\n        _game.iBlock = uint32(block.number);\r\n        return _curId;\r\n    }\r\n\r\n    // Gets initialHand, and stores .draws and .dBlock.\r\n    // Gas Cost: 13k\r\n    //   - 3k: getHand()\r\n    //   - 5k: 1 update: iHand, draws, dBlock\r\n    //   - 3k: event: DrawSuccess\r\n    //   - 2k: SLOADs, other\r\n    function _draw(Game storage _game, uint32 _id, uint8 _draws, bytes32 _hashCheck)\r\n        private\r\n    {\r\n        // assert hand is not already drawn\r\n        assert(_game.dBlock == 0);\r\n\r\n        // Deal the initial hand, or set draws to 5.\r\n        uint32 _iHand;\r\n        bytes32 _iBlockHash = blockhash(_game.iBlock);\r\n        uint8 _warnCode;\r\n        if (_iBlockHash != 0) {\r\n            // Ensure they are drawing against expected hand\r\n            if (_iBlockHash != _hashCheck) {\r\n                return _drawFailure(_id, _draws, \"HashCheck Failed. Try refreshing game.\");\r\n            }\r\n            _iHand = getHand(uint(keccak256(_iBlockHash, _id)));\r\n        } else {\r\n            _warnCode = WARN_IHAND_TIMEOUT;\r\n            _draws = 31;\r\n        }\r\n\r\n        // update game\r\n        _game.iHand = _iHand;\r\n        _game.draws = _draws;\r\n        _game.dBlock = uint32(block.number);\r\n\r\n        emit DrawSuccess(now, msg.sender, _id, _game.iHand, _draws, _warnCode);\r\n    }\r\n\r\n    // Resolves game based on .iHand and .draws, crediting user on a win.\r\n    // This always sets game.dHand and game.handRank.\r\n    //\r\n    // There are four possible scenarios:\r\n    //   User draws N cads, and dBlock is fresh:\r\n    //     - draw N cards into iHand, this is dHand\r\n    //   User draws N cards, and dBlock is too old:\r\n    //     - set dHand to iHand (note: iHand may be empty)\r\n    //   User draws 0 cards, and iBlock is fresh:\r\n    //     - draw 5 cards into iHand, set dHand to iHand\r\n    //   User draws 0 cards, and iBlock is too old:\r\n    //     - fail: set draws to 5, return. (user should call finalize again)\r\n    //\r\n    // Gas Cost: 21k loss, 36k win, 49k new win\r\n    //   - 6k: if draws > 0: drawToHand()\r\n    //   - 7k: getHandRank()\r\n    //   - 5k: 1 update: Game\r\n    //   - 2k: FinalizeSuccess\r\n    //   - 1k: SLOADs, execution\r\n    //   On Win: +13k, or +28k\r\n    //   - 5k: 1 updates: totalCredits, totalWon\r\n    //   - 5k or 20k: 1 update/write to credits[user]\r\n    //   - 2k: event: AccountCredited\r\n    //   - 1k: SLOADs, execution\r\n    function _finalize(Game storage _game, uint32 _id, bytes32 _hashCheck)\r\n        private\r\n    {\r\n        // Require game is not already finalized\r\n        assert(_game.handRank == HAND_UNDEFINED);\r\n\r\n        // Compute _dHand\r\n        address _user = userAddresses[_game.userId];\r\n        bytes32 _blockhash;\r\n        uint32 _dHand;\r\n        uint32 _iHand;  // set if draws are 0, and iBlock is fresh\r\n        uint8 _warnCode;\r\n        if (_game.draws != 0) {\r\n            _blockhash = blockhash(_game.dBlock);\r\n            if (_blockhash != 0) {\r\n                // draw cards to iHand, use as dHand\r\n                _dHand = drawToHand(uint(keccak256(_blockhash, _id)), _game.iHand, _game.draws);\r\n            } else {\r\n                // cannot draw any cards. use iHand.\r\n                if (_game.iHand != 0){\r\n                    _dHand = _game.iHand;\r\n                    _warnCode = WARN_DHAND_TIMEOUT;\r\n                } else {\r\n                    _dHand = 0;\r\n                    _warnCode = WARN_BOTH_TIMEOUT;\r\n                }\r\n            }\r\n        } else {\r\n            _blockhash = blockhash(_game.iBlock);\r\n            if (_blockhash != 0) {\r\n                // ensure they are drawing against expected hand\r\n                if (_blockhash != _hashCheck) {\r\n                    _finalizeFailure(_id, \"HashCheck Failed. Try refreshing game.\");\r\n                    return;\r\n                }\r\n                // draw 5 cards into iHand, use as dHand\r\n                _iHand = getHand(uint(keccak256(_blockhash, _id)));\r\n                _dHand = _iHand;\r\n            } else {\r\n                // can't finalize with iHand. Draw 5 cards.\r\n                _finalizeFailure(_id, \"Initial hand not available. Drawing 5 new cards.\");\r\n                _game.draws = 31;\r\n                _game.dBlock = uint32(block.number);\r\n                emit DrawSuccess(now, _user, _id, 0, 31, WARN_IHAND_TIMEOUT);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Compute _handRank. be sure dHand is not empty\r\n        uint8 _handRank = _dHand == 0\r\n            ? uint8(HAND_NOT_COMPUTABLE)\r\n            : uint8(getHandRank(_dHand));\r\n\r\n        // This only happens if draws==0, and iHand was drawable.\r\n        if (_iHand > 0) _game.iHand = _iHand;\r\n        // Always set dHand and handRank\r\n        _game.dHand = _dHand;\r\n        _game.handRank = _handRank;\r\n\r\n        // Compute _payout, credit user, emit event.\r\n        uint _payout = payTables[_game.payTableId][_handRank] * uint(_game.bet);\r\n        if (_payout > 0) _creditUser(_user, _payout, _id);\r\n        emit FinalizeSuccess(now, _user, _id, _game.dHand, _game.handRank, _payout, _warnCode);\r\n    }\r\n\r\n\r\n\r\n    /************************************************************/\r\n    /******************** PUBLIC VIEWS **************************/\r\n    /************************************************************/\r\n\r\n    // IMPLEMENTS: Bankrollable.getProfits()\r\n    // Ensures contract always has at least bankroll + totalCredits.\r\n    function getCollateral() public view returns (uint _amount) {\r\n        return vars.totalCredits;\r\n    }\r\n\r\n    // IMPLEMENTS: Bankrollable.getWhitelistOwner()\r\n    // Ensures contract always has at least bankroll + totalCredits.\r\n    function getWhitelistOwner() public view returns (address _wlOwner) {\r\n        return getAdmin();\r\n    }\r\n\r\n    // Returns the largest bet such that we could pay out two RoyalFlushes.\r\n    // The likelihood that two RoyalFlushes (with max bet size) are \r\n    //  won within a 255 block period is extremely low.\r\n    function curMaxBet() public view returns (uint) {\r\n        // Return largest bet such that RF*2*bet = bankrollable\r\n        uint _maxPayout = payTables[settings.curPayTableId][HAND_RF] * 2;\r\n        return bankrollAvailable() / _maxPayout;\r\n    }\r\n\r\n    // Return the less of settings.maxBet and curMaxBet()\r\n    function effectiveMaxBet() public view returns (uint _amount) {\r\n        uint _curMax = curMaxBet();\r\n        return _curMax > settings.maxBet ? settings.maxBet : _curMax;\r\n    }\r\n\r\n    function getPayTable(uint16 _payTableId)\r\n        public\r\n        view\r\n        returns (uint16[12])\r\n    {\r\n        require(_payTableId < settings.numPayTables);\r\n        return payTables[_payTableId];\r\n    }\r\n\r\n    function getCurPayTable()\r\n        public\r\n        view\r\n        returns (uint16[12])\r\n    {\r\n        return getPayTable(settings.curPayTableId);\r\n    }\r\n\r\n    // Gets the initial hand of a game.\r\n    function getIHand(uint32 _id)\r\n        public\r\n        view\r\n        returns (uint32)\r\n    {\r\n        Game memory _game = games[_id];\r\n        if (_game.iHand != 0) return _game.iHand;\r\n        if (_game.iBlock == 0) return;\r\n        \r\n        bytes32 _iBlockHash = blockhash(_game.iBlock);\r\n        if (_iBlockHash == 0) return;\r\n        return getHand(uint(keccak256(_iBlockHash, _id)));\r\n    }\r\n\r\n    // Get the final hand of a game.\r\n    // This will return iHand if there are no draws yet.\r\n    function getDHand(uint32 _id)\r\n        public\r\n        view\r\n        returns (uint32)\r\n    {\r\n        Game memory _game = games[_id];\r\n        if (_game.dHand != 0) return _game.dHand;\r\n        if (_game.draws == 0) return _game.iHand;\r\n        if (_game.dBlock == 0) return;\r\n\r\n        bytes32 _dBlockHash = blockhash(_game.dBlock);\r\n        if (_dBlockHash == 0) return _game.iHand;\r\n        return drawToHand(uint(keccak256(_dBlockHash, _id)), _game.iHand, _game.draws);\r\n    }\r\n\r\n    // Returns the hand rank and payout of a Game.\r\n    function getDHandRank(uint32 _id)\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        uint32 _dHand = getDHand(_id);\r\n        return _dHand == 0\r\n            ? uint8(HAND_NOT_COMPUTABLE)\r\n            : uint8(getHandRank(_dHand));\r\n    }\r\n\r\n    // Expose Vars //////////////////////////////////////\r\n    function curId() public view returns (uint32) {\r\n        return vars.curId;\r\n    }\r\n    function totalWagered() public view returns (uint) {\r\n        return uint(vars.totalWageredGwei) * 1e9;\r\n    }\r\n    function curUserId() public view returns (uint) {\r\n        return uint(vars.curUserId);\r\n    }\r\n    function totalWon() public view returns (uint) {\r\n        return uint(vars.totalWonGwei) * 1e9;\r\n    }\r\n    function totalCredits() public view returns (uint) {\r\n        return vars.totalCredits;\r\n    }\r\n    /////////////////////////////////////////////////////\r\n\r\n    // Expose Settings //////////////////////////////////\r\n    function minBet() public view returns (uint) {\r\n        return settings.minBet;\r\n    }\r\n    function maxBet() public view returns (uint) {\r\n        return settings.maxBet;\r\n    }\r\n    function curPayTableId() public view returns (uint) {\r\n        return settings.curPayTableId;\r\n    }\r\n    function numPayTables() public view returns (uint) {\r\n        return settings.numPayTables;\r\n    }\r\n    /////////////////////////////////////////////////////\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bankrollAvailable\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint32\"}],\"name\":\"getDHandRank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addBankroll\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"userAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint32\"}],\"name\":\"getDHand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profits\",\"outputs\":[{\"name\":\"_profits\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addCredits\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint32\"}],\"name\":\"getIHand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankrollerTable\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"effectiveMaxBet\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"bankrolledBy\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ledger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sendProfits\",\"outputs\":[{\"name\":\"_profits\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollateral\",\"outputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"cashOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint32\"},{\"name\":\"_hashCheck\",\"type\":\"bytes32\"}],\"name\":\"betFromGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_callbackFn\",\"type\":\"string\"}],\"name\":\"removeBankroll\",\"outputs\":[{\"name\":\"_recalled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hand\",\"type\":\"uint32\"}],\"name\":\"getHandRank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurPayTable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16[12]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curPayTableId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curMaxBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bet\",\"type\":\"uint64\"}],\"name\":\"betWithCredits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitsTotal\",\"outputs\":[{\"name\":\"_profits\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hand\",\"type\":\"uint32\"}],\"name\":\"handToCards\",\"outputs\":[{\"name\":\"_cards\",\"type\":\"uint8[5]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint32\"},{\"name\":\"_hashCheck\",\"type\":\"bytes32\"}],\"name\":\"finalize\",\"outputs\":[{\"name\":\"_didFinalize\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minBet\",\"type\":\"uint64\"},{\"name\":\"_maxBet\",\"type\":\"uint64\"},{\"name\":\"_payTableId\",\"type\":\"uint8\"}],\"name\":\"changeSettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCredits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWhitelistOwner\",\"outputs\":[{\"name\":\"_wlOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rf\",\"type\":\"uint16\"},{\"name\":\"_sf\",\"type\":\"uint16\"},{\"name\":\"_fk\",\"type\":\"uint16\"},{\"name\":\"_fh\",\"type\":\"uint16\"},{\"name\":\"_fl\",\"type\":\"uint16\"},{\"name\":\"_st\",\"type\":\"uint16\"},{\"name\":\"_tk\",\"type\":\"uint16\"},{\"name\":\"_tp\",\"type\":\"uint16\"},{\"name\":\"_jb\",\"type\":\"uint16\"}],\"name\":\"addPayTable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint32\"},{\"name\":\"_draws\",\"type\":\"uint8\"},{\"name\":\"_hashCheck\",\"type\":\"bytes32\"}],\"name\":\"draw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"uint256\"}],\"name\":\"getHand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"uint256\"},{\"name\":\"_hand\",\"type\":\"uint32\"},{\"name\":\"_draws\",\"type\":\"uint256\"}],\"name\":\"drawToHand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"userId\",\"type\":\"uint32\"},{\"name\":\"bet\",\"type\":\"uint64\"},{\"name\":\"payTableId\",\"type\":\"uint16\"},{\"name\":\"iBlock\",\"type\":\"uint32\"},{\"name\":\"iHand\",\"type\":\"uint32\"},{\"name\":\"draws\",\"type\":\"uint8\"},{\"name\":\"dBlock\",\"type\":\"uint32\"},{\"name\":\"dHand\",\"type\":\"uint32\"},{\"name\":\"handRank\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitsSent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numPayTables\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_payTableId\",\"type\":\"uint16\"}],\"name\":\"getPayTable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16[12]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"credits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payTableId\",\"type\":\"uint256\"}],\"name\":\"PayTableAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"SettingsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payTableId\",\"type\":\"uint256\"}],\"name\":\"BetSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"BetFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"iHand\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"draws\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"warnCode\",\"type\":\"uint8\"}],\"name\":\"DrawSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"draws\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"DrawFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"dHand\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"handRank\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"warnCode\",\"type\":\"uint8\"}],\"name\":\"FinalizeSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"FinalizeFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreditsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreditsUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CreditsCashedout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bankroller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bankroll\",\"type\":\"uint256\"}],\"name\":\"BankrollAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bankroller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bankroll\",\"type\":\"uint256\"}],\"name\":\"BankrollRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"treasury\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitsSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"wlOwner\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"wlOwner\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"}]","ContractName":"VideoPoker","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009c6386aba3907ad0e2177e74684f3ac986070981","Library":"","SwarmSource":"bzzr://d361b00680d188dcc0850e1c5d1a66cd44807fdcd0f9bc82fd23ee8cca4dfca0"}]}