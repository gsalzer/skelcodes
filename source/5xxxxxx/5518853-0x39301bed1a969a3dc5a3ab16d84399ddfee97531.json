{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/*\r\n\r\nOptions Exchange\r\n========================\r\n\r\nAn Exchange for American Options.\r\nAn American Option is a contract between its Buyer and its Seller, giving the Buyer the ability\r\nto buy (or sell) an Asset at a specified Strike Price any time before a specified time (Maturation).\r\n\r\nAuthors: /u/Cintix and /u/Hdizzle83\r\n\r\n*/\r\n\r\n// Using the SafeMath Library helps prevent integer overflow bugs.\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert((a == 0) || (c / a == b));\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n// Options can only be created for tokens adhering to the ERC20 Interface.\r\n// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\r\ncontract Token {\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool success) {}\r\n  function transfer(address to, uint256 value) public returns (bool success) {}\r\n}\r\n\r\n// An Option is a bet between two users on the relative price of two assets on a given date.\r\n// The Seller locks amountLocked of assetLocked in the Option in exchange for immediate payment of amountPremium of assetPremium from the Buyer.\r\n// The Buyer is then free to exercise the Option by trading amountTraded of assetTraded for the locked funds.\r\n// The ratio of amountTraded and amountLocked is called the Strike Price.\r\n// At the closing date (Maturation) or when the Buyer exercises the Option, the Option's funds are sent back to the Seller.\r\ncontract OptionsExchange {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  // Admin takes a 1% cut of each purchased Option's Premium, stored as a ratio with 1 ether as the denominator.\r\n  uint256 public fee_ratio = 10 ** 16;\r\n  \r\n  // Admin is initialized to the contract creator.\r\n  address public admin = msg.sender;\r\n  \r\n  // User balances are stored as userBalance[user][asset], where ETH is stored as address 0.\r\n  mapping (address => mapping(address => uint256)) public userBalance;\r\n  \r\n  // Onchain Option data indicates the current Buyer and Seller along with corresponding nonces used to invalidate old offchain orders.\r\n  // The Seller and Buyer addresses and their nonces take up two 32 byte storage slots, making up the only onchain data for each Option.\r\n  // When both storage slots are zero (i.e. uninitialized), the Option is Available or Invalid.\r\n  // When both storage slots are non-zero, the Option is Live or Matured.\r\n  // When only the Buyer storage slot is non-zero, the Option is Closed.\r\n  // When only the Seller storage slot is non-zero, the Option is Exercised or Cancelled.\r\n  // When only nonceSeller is non-zero, the Option is Cancelled.\r\n  // When an Option is Live, nonceSeller and nonceBuyer store how many users have been the Option's Seller and Buyer, respectively.\r\n  // The storage slots are zeroed out when the Option is Closed or Exercised to refund 10,000 gas.\r\n  struct optionDatum {\r\n    address seller;\r\n    uint96 nonceSeller;\r\n    address buyer;\r\n    uint96 nonceBuyer;\r\n  }\r\n  \r\n  // To reduce onchain storage, Options are indexed by a hash of their offchain parameters, optionHash.\r\n  mapping (bytes32 => optionDatum) public optionData;\r\n  \r\n  // Possible states an Option (or its offchain order) can be in.\r\n  // Options implicitly store locked funds when they're Live or Matured.\r\n  enum optionStates {\r\n    Invalid,   // Option parameters are invalid.\r\n    Available, // Option hasn't been created or filled yet.\r\n    Cancelled, // Option's initial offchain order has been cancelled by the Maker.\r\n    Live,      // Option contains implicitly stored funds, can be resold or exercised any time before its Maturation time.\r\n    Exercised, // Option has been exercised by its buyer, withdrawing its implicitly stored funds.\r\n    Matured,   // Option still contains implicitly stored funds but has passed its Maturation time and is ready to be closed.\r\n    Closed     // Option has been closed by its Seller, who has withdrawn its implicitly stored funds.\r\n  }\r\n  \r\n  // Events emitted by the contract for use in tracking exchange activity.\r\n  // For Deposits and Withdrawals, ETH balances are stored as an asset with address 0.\r\n  event Deposit(address indexed user, address indexed asset, uint256 amount);\r\n  event Withdrawal(address indexed user, address indexed asset, uint256 amount);\r\n  event OrderFilled(bytes32 indexed optionHash,\r\n                    address indexed maker,\r\n                    address indexed taker,\r\n                    address[3] assetLocked_assetTraded_firstMaker,\r\n                    uint256[3] amountLocked_amountTraded_maturation,\r\n                    uint256[2] amountPremium_expiration,\r\n                    address assetPremium,\r\n                    bool makerIsSeller,\r\n                    uint96 nonce);\r\n  event OrderCancelled(bytes32 indexed optionHash, bool bySeller, uint96 nonce);\r\n  event OptionExercised(bytes32 indexed optionHash, address indexed buyer, address indexed seller);\r\n  event OptionClosed(bytes32 indexed optionHash, address indexed seller);\r\n  event UserBalanceUpdated(address indexed user, address indexed asset, uint256 newBalance);\r\n  \r\n  // Allow the admin to transfer ownership.\r\n  function changeAdmin(address _admin) external {\r\n    require(msg.sender == admin);\r\n    admin = _admin;\r\n  }\r\n  \r\n  // Users must first deposit assets into the Exchange in order to create, purchase, or exercise Options.\r\n  // ETH balances are stored as an asset with address 0.\r\n  function depositETH() external payable {\r\n    userBalance[msg.sender][0] = userBalance[msg.sender][0].add(msg.value);\r\n    emit Deposit(msg.sender, 0, msg.value);\r\n    emit UserBalanceUpdated(msg.sender, 0, userBalance[msg.sender][0]);\r\n  }\r\n  \r\n  // Users can withdraw any amount of ETH up to their current balance.\r\n  function withdrawETH(uint256 amount) external {\r\n    require(userBalance[msg.sender][0] >= amount);\r\n    userBalance[msg.sender][0] = userBalance[msg.sender][0].sub(amount);\r\n    msg.sender.transfer(amount);\r\n    emit Withdrawal(msg.sender, 0, amount);\r\n    emit UserBalanceUpdated(msg.sender, 0, userBalance[msg.sender][0]);\r\n  }\r\n  \r\n  // To deposit tokens, users must first \"approve\" the transfer in the token contract.\r\n  // Users must first deposit assets into the Exchange in order to create, purchase, or exercise Options.\r\n  function depositToken(address token, uint256 amount) external {\r\n    require(Token(token).transferFrom(msg.sender, this, amount));  \r\n    userBalance[msg.sender][token] = userBalance[msg.sender][token].add(amount);\r\n    emit Deposit(msg.sender, token, amount);\r\n    emit UserBalanceUpdated(msg.sender, token, userBalance[msg.sender][token]);\r\n  }\r\n  \r\n  // Users can withdraw any amount of a given token up to their current balance.\r\n  function withdrawToken(address token, uint256 amount) external {\r\n    require(userBalance[msg.sender][token] >= amount);\r\n    userBalance[msg.sender][token] = userBalance[msg.sender][token].sub(amount);\r\n    require(Token(token).transfer(msg.sender, amount));\r\n    emit Withdrawal(msg.sender, token, amount);\r\n    emit UserBalanceUpdated(msg.sender, token, userBalance[msg.sender][token]);\r\n  }\r\n  \r\n  // Transfer funds from one user's balance to another's.  Not externally callable.\r\n  function transferUserToUser(address from, address to, address asset, uint256 amount) private {\r\n    require(userBalance[from][asset] >= amount);\r\n    userBalance[from][asset] = userBalance[from][asset].sub(amount);\r\n    userBalance[to][asset] = userBalance[to][asset].add(amount);\r\n    emit UserBalanceUpdated(from, asset, userBalance[from][asset]);\r\n    emit UserBalanceUpdated(to, asset, userBalance[to][asset]);\r\n  }\r\n  \r\n  // Hashes an Option's parameters for use in looking up information about the Option.  Callable internally and externally.\r\n  // Variables are grouped into arrays as a workaround for the \"too many local variables\" problem.\r\n  // Instead of directly encoding the asset exchange rate (Strike Price), it is instead implicitly\r\n  // stored as the ratio of amountLocked, the amount of assetLocked stored in the Option, and amountTraded,\r\n  // the amount of assetTraded needed to exercise the Option.\r\n  function getOptionHash(address[3] assetLocked_assetTraded_firstMaker,\r\n                         uint256[3] amountLocked_amountTraded_maturation) pure public returns(bytes32) {\r\n    bytes32 optionHash = keccak256(assetLocked_assetTraded_firstMaker[0],\r\n                                   assetLocked_assetTraded_firstMaker[1],\r\n                                   assetLocked_assetTraded_firstMaker[2],\r\n                                   amountLocked_amountTraded_maturation[0],\r\n                                   amountLocked_amountTraded_maturation[1],\r\n                                   amountLocked_amountTraded_maturation[2]);\r\n    return optionHash;\r\n  }\r\n  \r\n  // Hashes an Order's parameters for use in ecrecover.  Callable internally and externally.\r\n  function getOrderHash(bytes32 optionHash,\r\n                        uint256[2] amountPremium_expiration,\r\n                        address assetPremium,\r\n                        bool makerIsSeller,\r\n                        uint96 nonce) view public returns(bytes32) {\r\n    // A hash of the Order's information which was signed by the Maker to create the offchain order.\r\n    bytes32 orderHash = keccak256(\"\\x19Ethereum Signed Message:\\n32\",\r\n                                  keccak256(address(this),\r\n                                            optionHash,\r\n                                            amountPremium_expiration[0],\r\n                                            amountPremium_expiration[1],\r\n                                            assetPremium,\r\n                                            makerIsSeller,\r\n                                            nonce));\r\n    return orderHash;\r\n  }\r\n  \r\n  // Computes the current state of an Option given its parameters.  Callable internally and externally.\r\n  function getOptionState(address[3] assetLocked_assetTraded_firstMaker,\r\n                          uint256[3] amountLocked_amountTraded_maturation) view public returns(optionStates) {\r\n    // Tokens must be different for Option to be Valid.\r\n    if(assetLocked_assetTraded_firstMaker[0] == assetLocked_assetTraded_firstMaker[1]) return optionStates.Invalid;\r\n    // Options must have a non-zero amount of locked assets to be Valid.\r\n    if(amountLocked_amountTraded_maturation[0] == 0) return optionStates.Invalid;\r\n    // Exercising an Option must require trading a non-zero amount of assets.\r\n    if(amountLocked_amountTraded_maturation[1] == 0) return optionStates.Invalid;\r\n    // Options must reach Maturation between 2018 and 2030 to be Valid.\r\n    if(amountLocked_amountTraded_maturation[2] < 1514764800) return optionStates.Invalid;\r\n    if(amountLocked_amountTraded_maturation[2] > 1893456000) return optionStates.Invalid;\r\n    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\r\n    address seller = optionData[optionHash].seller;\r\n    uint96 nonceSeller = optionData[optionHash].nonceSeller;\r\n    address buyer = optionData[optionHash].buyer;\r\n    if(seller == 0x0) {\r\n      // Check if the Option's offchain order was cancelled.\r\n      if(nonceSeller != 0) return optionStates.Cancelled;\r\n      // If both Buyer and Seller are still 0, Option is Available, even if it's past Maturation.\r\n      if(buyer == 0x0) return optionStates.Available;\r\n      // If Seller is 0 and Buyer is non-zero, Option must have been Closed.\r\n      return optionStates.Closed;\r\n    }\r\n    // If Seller is non-zero and Buyer is 0, Option must have been Exercised.\r\n    if(buyer == 0x0) return optionStates.Exercised;\r\n    // If Seller and Buyer are both non-zero and the Option hasn't passed Maturation, it's Live.\r\n    if(now < amountLocked_amountTraded_maturation[2]) return optionStates.Live;\r\n    // Otherwise, the Option must have Matured.\r\n    return optionStates.Matured;\r\n  }\r\n  \r\n  // Transfer payment from an Option's Buyer to the Seller less the 1% fee sent to the admin.  Not externally callable.\r\n  function payForOption(address buyer, address seller, address assetPremium, uint256 amountPremium) private {\r\n    uint256 fee = (amountPremium.mul(fee_ratio)).div(1 ether);\r\n    transferUserToUser(buyer, seller, assetPremium, amountPremium.sub(fee));\r\n    transferUserToUser(buyer, admin, assetPremium, fee);\r\n  }\r\n  \r\n  // Allows a Taker to fill an offchain Option order created by a Maker.\r\n  // Transitions new Options from Available to Live, depositing its implicitly stored locked funds.\r\n  // Maintains state of existing Options as Live, without affecting their implicitly stored locked funds.\r\n  function fillOptionOrder(address[3] assetLocked_assetTraded_firstMaker,\r\n                           uint256[3] amountLocked_amountTraded_maturation,\r\n                           uint256[2] amountPremium_expiration,\r\n                           address assetPremium,\r\n                           bool makerIsSeller,\r\n                           uint96 nonce,\r\n                           uint8 v,\r\n                           bytes32[2] r_s) external {\r\n    // Verify offchain order hasn't expired.\r\n    require(now < amountPremium_expiration[1]);\r\n    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\r\n    // A hash of the Order's information which was signed by the Maker to create the offchain order.\r\n    bytes32 orderHash = getOrderHash(optionHash, amountPremium_expiration, assetPremium, makerIsSeller, nonce);\r\n    // A nonce of zero corresponds to creating a new Option, while nonzero means reselling an old one.\r\n    if(nonce == 0) {\r\n      // Option must be Available, which means it is valid, unfilled, and uncancelled.\r\n      require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Available);\r\n      // Option must not already be past its Maturation time.\r\n      require(now < amountLocked_amountTraded_maturation[2]);\r\n      // Verify the Maker's offchain order is valid by checking whether it was signed by the first Maker.\r\n      require(ecrecover(orderHash, v, r_s[0], r_s[1]) == assetLocked_assetTraded_firstMaker[2]);\r\n      // Set the Option's Buyer and Seller and initialize the nonces to 1, marking the Option as Live.\r\n      // Ternary operator to assign the Seller and Buyer from the Maker and Taker: (<conditional> ? <if-true> : <if-false>)\r\n      optionData[optionHash].seller = makerIsSeller ? assetLocked_assetTraded_firstMaker[2] : msg.sender;\r\n      optionData[optionHash].nonceSeller = 1;\r\n      optionData[optionHash].buyer = makerIsSeller ? msg.sender : assetLocked_assetTraded_firstMaker[2];\r\n      optionData[optionHash].nonceBuyer = 1;\r\n      // The Buyer pays the Seller the premium for the Option.\r\n      payForOption(optionData[optionHash].buyer, optionData[optionHash].seller, assetPremium, amountPremium_expiration[0]);\r\n      // Lock amountLocked of the Seller's assetLocked in implicit storage as specified by the Option parameters.\r\n      require(userBalance[optionData[optionHash].seller][assetLocked_assetTraded_firstMaker[0]] >= amountLocked_amountTraded_maturation[0]);\r\n      userBalance[optionData[optionHash].seller][assetLocked_assetTraded_firstMaker[0]] = userBalance[optionData[optionHash].seller][assetLocked_assetTraded_firstMaker[0]].sub(amountLocked_amountTraded_maturation[0]);\r\n      emit UserBalanceUpdated(optionData[optionHash].seller, assetLocked_assetTraded_firstMaker[0], userBalance[optionData[optionHash].seller][assetLocked_assetTraded_firstMaker[0]]);\r\n      emit OrderFilled(optionHash, \r\n                       assetLocked_assetTraded_firstMaker[2],\r\n                       msg.sender,\r\n                       assetLocked_assetTraded_firstMaker,\r\n                       amountLocked_amountTraded_maturation,\r\n                       amountPremium_expiration,\r\n                       assetPremium,\r\n                       makerIsSeller,\r\n                       nonce);\r\n    } else {\r\n      // Option must be Live, which means this order is a resale by the current buyer or seller.\r\n      require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Live);\r\n      // If the Maker is the Seller, they're buying back out their locked asset.\r\n      // Otherwise, the Maker is the Buyer and they're reselling their ability to exercise the Option.\r\n      if(makerIsSeller) {\r\n        // Verify the nonce of the Maker's offchain order matches to ensure the order isn't old or cancelled.\r\n        require(optionData[optionHash].nonceSeller == nonce);\r\n        // Verify the Maker's offchain order is valid by checking whether it was signed by the Maker.\r\n        require(ecrecover(orderHash, v, r_s[0], r_s[1]) == optionData[optionHash].seller);\r\n        // The Maker pays the Taker the premium for buying out their locked asset.\r\n        payForOption(optionData[optionHash].seller, msg.sender, assetPremium, amountPremium_expiration[0]);\r\n        // The Taker directly sends the Maker an amount equal to the Maker's locked assets, replacing them as the Seller.\r\n        transferUserToUser(msg.sender, optionData[optionHash].seller, assetLocked_assetTraded_firstMaker[0], amountLocked_amountTraded_maturation[0]);\r\n        // Update the Option's Seller to be the Taker and increment the nonce to prevent double-filling.\r\n        optionData[optionHash].seller = msg.sender;\r\n        optionData[optionHash].nonceSeller += 1;\r\n        emit OrderFilled(optionHash, \r\n                         optionData[optionHash].seller,\r\n                         msg.sender,\r\n                         assetLocked_assetTraded_firstMaker,\r\n                         amountLocked_amountTraded_maturation,\r\n                         amountPremium_expiration,\r\n                         assetPremium,\r\n                         makerIsSeller,\r\n                         nonce);\r\n      } else {\r\n        // Verify the nonce of the Maker's offchain order matches to ensure the order isn't old or cancelled.\r\n        require(optionData[optionHash].nonceBuyer == nonce);\r\n        // Verify the Maker's offchain order is valid by checking whether it was signed by the Maker.\r\n        require(ecrecover(orderHash, v, r_s[0], r_s[1]) == optionData[optionHash].buyer);\r\n        // The Taker pays the Maker the premium for the ability to exercise the Option.\r\n        payForOption(msg.sender, optionData[optionHash].buyer, assetPremium, amountPremium_expiration[0]);\r\n        // Update the Option's Buyer to be the Taker and increment the nonce to prevent double-filling.\r\n        optionData[optionHash].buyer = msg.sender;\r\n        optionData[optionHash].nonceBuyer += 1;\r\n        emit OrderFilled(optionHash, \r\n                         optionData[optionHash].buyer,\r\n                         msg.sender,\r\n                         assetLocked_assetTraded_firstMaker,\r\n                         amountLocked_amountTraded_maturation,\r\n                         amountPremium_expiration,\r\n                         assetPremium,\r\n                         makerIsSeller,\r\n                         nonce);\r\n      }      \r\n    }\r\n  }\r\n  \r\n  // Allows a Maker to cancel their offchain Option order early (i.e. before its expiration).\r\n  function cancelOptionOrder(address[3] assetLocked_assetTraded_firstMaker,\r\n                             uint256[3] amountLocked_amountTraded_maturation,\r\n                             bool makerIsSeller) external {\r\n    optionStates state = getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\r\n    // Option must be Available or Live.  Orders can't be filled in any other state.\r\n    require(state == optionStates.Available || state == optionStates.Live);\r\n    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\r\n    // If the Option is Available, the first order hasn't been filled yet.\r\n    if(state == optionStates.Available) {\r\n      // Only allow the Maker to cancel their own offchain Option order.\r\n      require(msg.sender == assetLocked_assetTraded_firstMaker[2]);\r\n      emit OrderCancelled(optionHash, makerIsSeller, 0);\r\n      // Mark the Option as Cancelled by setting the Seller nonce nonzero while the Seller is still 0x0.\r\n      optionData[optionHash].nonceSeller = 1;\r\n    } else {\r\n      // Live Options can be resold by either the Buyer or the Seller.\r\n      if(makerIsSeller) {\r\n        // Only allow the Maker to cancel their own offchain Option order.\r\n        require(msg.sender == optionData[optionHash].seller);\r\n        emit OrderCancelled(optionHash, makerIsSeller, optionData[optionHash].nonceSeller);\r\n        // Invalidate the old offchain order by incrementing the Maker's nonce.\r\n        optionData[optionHash].nonceSeller += 1;\r\n      } else {\r\n        // Only allow the Maker to cancel their own offchain Option order.\r\n        require(msg.sender == optionData[optionHash].buyer);\r\n        emit OrderCancelled(optionHash, makerIsSeller, optionData[optionHash].nonceBuyer);\r\n        // Invalidate the old offchain order by incrementing the Maker's nonce.\r\n        optionData[optionHash].nonceBuyer += 1;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Allow an Option's Buyer to exercise the Option, trading amountTraded of assetTraded to the Option for amountLocked of assetLocked.\r\n  // The traded funds are sent directly to the Seller so they don't need to close it afterwards.\r\n  // Transitions an Option from Live to Exercised, withdrawing its implicitly stored locked funds.\r\n  function exerciseOption(address[3] assetLocked_assetTraded_firstMaker,\r\n                          uint256[3] amountLocked_amountTraded_maturation) external {\r\n    // Option must be Live, which means it's been filled and hasn't passed its trading deadline (Maturation).\r\n    require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Live);\r\n    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\r\n    address buyer = optionData[optionHash].buyer;\r\n    address seller = optionData[optionHash].seller;\r\n    // Only allow the current Buyer to exercise the Option.\r\n    require(msg.sender == buyer);\r\n    // The Buyer sends the Seller the traded assets as specified by the Option parameters.\r\n    transferUserToUser(buyer, seller, assetLocked_assetTraded_firstMaker[1], amountLocked_amountTraded_maturation[1]);\r\n    // Mark the Option as Exercised by zeroing out the Buyer and the corresponding nonce.\r\n    delete optionData[optionHash].buyer;\r\n    delete optionData[optionHash].nonceBuyer;\r\n    // The Buyer receives the implicitly stored locked assets as specified by the Option parameters.\r\n    userBalance[buyer][assetLocked_assetTraded_firstMaker[0]] = userBalance[buyer][assetLocked_assetTraded_firstMaker[0]].add(amountLocked_amountTraded_maturation[0]);\r\n    emit UserBalanceUpdated(buyer, assetLocked_assetTraded_firstMaker[0], userBalance[buyer][assetLocked_assetTraded_firstMaker[0]]);\r\n    emit OptionExercised(optionHash, buyer, seller);\r\n  }\r\n  \r\n  // Allows an Option's Seller to withdraw their funds after the Option's Maturation.\r\n  // Transitions an Option from Matured to Closed, withdrawing its implicitly stored locked funds.\r\n  function closeOption(address[3] assetLocked_assetTraded_firstMaker,\r\n                       uint256[3] amountLocked_amountTraded_maturation) external {\r\n    // Option must have Matured, which means it's filled, unexercised, and has passed its Maturation time.\r\n    require(getOptionState(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation) == optionStates.Matured);\r\n    bytes32 optionHash = getOptionHash(assetLocked_assetTraded_firstMaker, amountLocked_amountTraded_maturation);\r\n    address seller = optionData[optionHash].seller;\r\n    // Only allow the Seller to close their own Option.\r\n    require(msg.sender == seller);\r\n    // Mark the Option as Closed by zeroing out the Seller and the corresponding nonce.\r\n    delete optionData[optionHash].seller;\r\n    delete optionData[optionHash].nonceSeller;\r\n    // Transfer the Option's implicitly stored locked funds back to the Seller.\r\n    userBalance[seller][assetLocked_assetTraded_firstMaker[0]] = userBalance[seller][assetLocked_assetTraded_firstMaker[0]].add(amountLocked_amountTraded_maturation[0]);\r\n    emit UserBalanceUpdated(seller, assetLocked_assetTraded_firstMaker[0], userBalance[seller][assetLocked_assetTraded_firstMaker[0]]);\r\n    emit OptionClosed(optionHash, seller);\r\n  }\r\n  \r\n  function() payable external {\r\n    revert();\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"assetLocked_assetTraded_firstMaker\",\"type\":\"address[3]\"},{\"name\":\"amountLocked_amountTraded_maturation\",\"type\":\"uint256[3]\"},{\"name\":\"makerIsSeller\",\"type\":\"bool\"}],\"name\":\"cancelOptionOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"optionHash\",\"type\":\"bytes32\"},{\"name\":\"amountPremium_expiration\",\"type\":\"uint256[2]\"},{\"name\":\"assetPremium\",\"type\":\"address\"},{\"name\":\"makerIsSeller\",\"type\":\"bool\"},{\"name\":\"nonce\",\"type\":\"uint96\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetLocked_assetTraded_firstMaker\",\"type\":\"address[3]\"},{\"name\":\"amountLocked_amountTraded_maturation\",\"type\":\"uint256[3]\"}],\"name\":\"getOptionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetLocked_assetTraded_firstMaker\",\"type\":\"address[3]\"},{\"name\":\"amountLocked_amountTraded_maturation\",\"type\":\"uint256[3]\"}],\"name\":\"closeOption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetLocked_assetTraded_firstMaker\",\"type\":\"address[3]\"},{\"name\":\"amountLocked_amountTraded_maturation\",\"type\":\"uint256[3]\"}],\"name\":\"getOptionState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee_ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetLocked_assetTraded_firstMaker\",\"type\":\"address[3]\"},{\"name\":\"amountLocked_amountTraded_maturation\",\"type\":\"uint256[3]\"},{\"name\":\"amountPremium_expiration\",\"type\":\"uint256[2]\"},{\"name\":\"assetPremium\",\"type\":\"address\"},{\"name\":\"makerIsSeller\",\"type\":\"bool\"},{\"name\":\"nonce\",\"type\":\"uint96\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r_s\",\"type\":\"bytes32[2]\"}],\"name\":\"fillOptionOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetLocked_assetTraded_firstMaker\",\"type\":\"address[3]\"},{\"name\":\"amountLocked_amountTraded_maturation\",\"type\":\"uint256[3]\"}],\"name\":\"exerciseOption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"optionData\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"nonceSeller\",\"type\":\"uint96\"},{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"nonceBuyer\",\"type\":\"uint96\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"optionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"assetLocked_assetTraded_firstMaker\",\"type\":\"address[3]\"},{\"indexed\":false,\"name\":\"amountLocked_amountTraded_maturation\",\"type\":\"uint256[3]\"},{\"indexed\":false,\"name\":\"amountPremium_expiration\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"assetPremium\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"makerIsSeller\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint96\"}],\"name\":\"OrderFilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"optionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"bySeller\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"nonce\",\"type\":\"uint96\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"optionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"OptionExercised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"optionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"OptionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"UserBalanceUpdated\",\"type\":\"event\"}]","ContractName":"OptionsExchange","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://79a7ffa985492acc317418d30839556ec1429f320469f9ef29b2fddbb666ff8d"}]}