{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.16;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\n\r\ncontract Ownable {\r\n    \r\n    address[] public owners;\r\n    \r\n    mapping(address => bool) bOwner;\r\n    \r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owners = [ 0x315C082246FFF04c9E790620867E6e0AD32f2FE3 ];\r\n                    \r\n        for (uint i=0; i< owners.length; i++){\r\n            bOwner[owners[i]]=true;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        \r\n        require(bOwner[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n\r\n}\r\n\r\n\r\ncontract ClothingToken is Ownable {\r\n    \r\n\r\n    uint256 public totalSupply;\r\n    uint256 public totalSupplyMarket;\r\n    uint256 public totalSupplyYear;\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    \r\n    string public constant name = \"ClothingCoin\";\r\n    string public constant symbol = \"CC\";\r\n    uint32 public constant decimals = 0;\r\n\r\n    uint256 public constant hardcap = 300000000;\r\n    uint256 public constant marketCap= 150000000;\r\n    uint256 public yearCap=75000000 ;\r\n    \r\n    uint currentyear=2018;\r\n    \r\n    mapping (address => bool) public frozenAccount;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds(address target, bool frozen);\r\n    \r\n    struct DateTime {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        uint8 weekday;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint constant HOUR_IN_SECONDS = 3600;\r\n    uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) constant returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        dt.year = ORIGIN_YEAR;\r\n\r\n        // Year\r\n        while (true) {\r\n            if (isLeapYear(dt.year)) {\r\n                    buf = LEAP_YEAR_IN_SECONDS;\r\n            }\r\n            else {\r\n                    buf = YEAR_IN_SECONDS;\r\n            }\r\n\r\n            if (secondsAccountedFor + buf > timestamp) {\r\n                    break;\r\n            }\r\n            dt.year += 1;\r\n            secondsAccountedFor += buf;\r\n        }\r\n\r\n        // Month\r\n        uint8[12] monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(dt.year)) {\r\n            monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        uint secondsInMonth;\r\n        for (i = 0; i < monthDayCounts.length; i++) {\r\n            secondsInMonth = DAY_IN_SECONDS * monthDayCounts[i];\r\n            if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                    dt.month = i + 1;\r\n                    break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        // Day\r\n        for (i = 0; i < monthDayCounts[dt.month - 1]; i++) {\r\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                    dt.day = i + 1;\r\n                    break;\r\n            }\r\n            secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n\r\n        // Hour\r\n        for (i = 0; i < 24; i++) {\r\n            if (HOUR_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                    dt.hour = i;\r\n                    break;\r\n            }\r\n            secondsAccountedFor += HOUR_IN_SECONDS;\r\n        }\r\n\r\n        // Minute\r\n        for (i = 0; i < 60; i++) {\r\n            if (MINUTE_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                    dt.minute = i;\r\n                    break;\r\n            }\r\n            secondsAccountedFor += MINUTE_IN_SECONDS;\r\n        }\r\n\r\n        if (timestamp - secondsAccountedFor > 60) {\r\n            __throw();\r\n        }\r\n        \r\n        // Second\r\n        dt.second = uint8(timestamp - secondsAccountedFor);\r\n\r\n        // Day of week.\r\n        buf = timestamp / DAY_IN_SECONDS;\r\n        dt.weekday = uint8((buf + 3) % 7);\r\n    }\r\n        \r\n    function __throw() {\r\n        uint[] arst;\r\n        arst[1];\r\n    }\r\n    \r\n    function getYear(uint timestamp) constant returns (uint16) {\r\n        return parseTimestamp(timestamp).year;\r\n    }\r\n    \r\n    modifier canYearMint() {\r\n        if(getYear(now) != currentyear){\r\n            currentyear=getYear(now);\r\n            yearCap=yearCap/2;\r\n            totalSupplyYear=0;\r\n        }\r\n        require(totalSupply <= marketCap);\r\n        require(totalSupplyYear <= yearCap);\r\n        _;\r\n        \r\n    }\r\n    \r\n    modifier canMarketMint(){\r\n        require(totalSupplyMarket <= marketCap);\r\n        _;\r\n    }\r\n\r\n    function mintForMarket (address _to, uint256 _value) public onlyOwner canMarketMint returns (bool){\r\n        \r\n        if (_value + totalSupplyMarket <= marketCap) {\r\n        \r\n            totalSupplyMarket = totalSupplyMarket + _value;\r\n            \r\n            assert(totalSupplyMarket >= _value);\r\n             \r\n            balances[msg.sender] = balances[msg.sender] + _value;\r\n            assert(balances[msg.sender] >= _value);\r\n            Mint(msg.sender, _value);\r\n        \r\n            _transfer(_to, _value);\r\n            \r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _transfer( address _to, uint256 _value) internal {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        require(!frozenAccount[_to]);\r\n\r\n        balances[msg.sender] = balances[msg.sender] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) public  returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n        require(!frozenAccount[msg.sender]);\r\n        require(!frozenAccount[_to]);\r\n\r\n        balances[msg.sender] = balances[msg.sender] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        require(!frozenAccount[_from]);\r\n        require(!frozenAccount[_to]);\r\n        balances[_from] = balances[_from] - _value;\r\n        balances[_to] = balances[_to] + _value;\r\n        //assert(balances[_to] >= _value); no need to check, since mint has limited hardcap\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n    \r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    \r\n    function mintForYear(address _to, uint256 _value) public onlyOwner canYearMint returns (bool) {\r\n        require(_to != address(0));\r\n        \r\n        if (_value + totalSupplyYear <= yearCap) {\r\n            \r\n            totalSupply = totalSupply + _value;\r\n        \r\n            totalSupplyYear = totalSupplyYear + _value;\r\n            \r\n            assert(totalSupplyYear >= _value);\r\n             \r\n            balances[msg.sender] = balances[msg.sender] + _value;\r\n            assert(balances[msg.sender] >= _value);\r\n            Mint(msg.sender, _value);\r\n        \r\n            _transfer(_to, _value);\r\n            \r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n\r\n    function burn(uint256 _value) public returns (bool) {\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n        balances[msg.sender] = balances[msg.sender] - _value;\r\n        totalSupply = totalSupply - _value;\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);   \r\n        balances[_from] = balances[_from] - _value;\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;\r\n        totalSupply = totalSupply - _value;\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n    \r\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n    /// @param target Address to be frozen\r\n    /// @param freeze either to freeze it or not\r\n    function freezeAccount(address target, bool freeze) public onlyOwner {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    event Mint(address indexed to, uint256 amount);\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"yearCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"isLeapYear\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintForMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintForYear\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupplyMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"__throw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"ClothingToken","CompilerVersion":"v0.4.20+commit.3155dd80","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8a39e75a50f3d3acf74bc41aec924cd80b115c27f133ac4ade62b34e1b3ef5ba"}]}