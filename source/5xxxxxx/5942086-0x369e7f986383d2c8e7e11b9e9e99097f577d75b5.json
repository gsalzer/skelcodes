{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Beths base contract\r\n * @author clemlak (https://www.beths.co)\r\n * @notice Place bets using Ether, based on the \"pari mutuel\" principle\r\n * Only the owner of the contract can create bets, he can also take a cut on every payouts\r\n * @dev This is the base contract for our dapp, we manage here all the things related to the \"house\"\r\n */\r\ncontract BethsHouse is Ownable {\r\n  /**\r\n   * @notice Emitted when the house cut percentage is changed\r\n   * @param newHouseCutPercentage The new percentage\r\n   */\r\n  event HouseCutPercentageChanged(uint newHouseCutPercentage);\r\n\r\n  /**\r\n   * @notice The percentage taken by the house on every game\r\n   * @dev Can be changed later with the changeHouseCutPercentage() function\r\n   */\r\n  uint public houseCutPercentage = 10;\r\n\r\n  /**\r\n   * @notice Changes the house cut percentage\r\n   * @dev To prevent abuses, the new percentage is checked\r\n   * @param newHouseCutPercentage The new house cut percentage\r\n   */\r\n  function changeHouseCutPercentage(uint newHouseCutPercentage) external onlyOwner {\r\n    // This prevents us from being too greedy ;)\r\n    if (newHouseCutPercentage >= 0 && newHouseCutPercentage < 20) {\r\n      houseCutPercentage = newHouseCutPercentage;\r\n      emit HouseCutPercentageChanged(newHouseCutPercentage);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title We manage all the things related to our games here\r\n * @author Clemlak (https://www.beths.co)\r\n */\r\ncontract BethsGame is BethsHouse {\r\n  /**\r\n   * @notice We use the SafeMath library in order to prevent overflow errors\r\n   * @dev Don't forget to use add(), sub(), ... instead of +, -, ...\r\n   */\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n   * @notice Emitted when a new game is opened\r\n   * @param gameId The id of the corresponding game\r\n   * @param teamA The name of the team A\r\n   * @param teamB The name of the team B\r\n   * @param description A small description of the game\r\n   * @param frozenTimestamp The exact moment when the game will be frozen\r\n   */\r\n  event GameHasOpened(uint gameId, string teamA, string teamB, string description, uint frozenTimestamp);\r\n\r\n  /**\r\n   * @notice Emitted when a game is frozen\r\n   * @param gameId The id of the corresponding game\r\n   */\r\n  event GameHasFrozen(uint gameId);\r\n\r\n  /**\r\n   * @notice Emitted when a game is closed\r\n   * @param gameId The id of the corresponding game\r\n   * @param result The result of the game (see: enum GameResults)\r\n   */\r\n  event GameHasClosed(uint gameId, GameResults result);\r\n\r\n  /**\r\n   * @notice All the different states a game can have (only 1 at a time)\r\n   */\r\n  enum GameStates { Open, Frozen, Closed }\r\n\r\n  /**\r\n   * @notice All the possible results (only 1 at a time)\r\n   * @dev All new games are initialized with a NotYet result\r\n   */\r\n  enum GameResults { NotYet, TeamA, Draw, TeamB }\r\n\r\n  /**\r\n   * @notice This struct defines what a game is\r\n   */\r\n  struct Game {\r\n    string teamA;\r\n    uint amountToTeamA;\r\n    string teamB;\r\n    uint amountToTeamB;\r\n    uint amountToDraw;\r\n    string description;\r\n    uint frozenTimestamp;\r\n    uint bettorsCount;\r\n    GameResults result;\r\n    GameStates state;\r\n    bool isHouseCutWithdrawn;\r\n  }\r\n\r\n  /**\r\n  * @notice We store all our games in an array\r\n  */\r\n  Game[] public games;\r\n\r\n  /**\r\n   * @notice This function creates a new game\r\n   * @dev Can only be called externally by the owner\r\n   * @param teamA The name of the team A\r\n   * @param teamB The name of the team B\r\n   * @param description A small description of the game\r\n   * @param frozenTimestamp A timestamp representing when the game will be frozen\r\n   */\r\n  function createNewGame(\r\n    string teamA,\r\n    string teamB,\r\n    string description,\r\n    uint frozenTimestamp\r\n  ) external onlyOwner {\r\n    // We push the new game directly into our array\r\n    uint gameId = games.push(Game(\r\n      teamA, 0, teamB, 0, 0, description, frozenTimestamp, 0, GameResults.NotYet, GameStates.Open, false\r\n    )) - 1;\r\n\r\n    emit GameHasOpened(gameId, teamA, teamB, description, frozenTimestamp);\r\n  }\r\n\r\n  /**\r\n   * @notice We use this function to froze a game\r\n   * @dev Can only be called externally by the owner\r\n   * @param gameId The id of the corresponding game\r\n   */\r\n  function freezeGame(uint gameId) external onlyOwner whenGameIsOpen(gameId) {\r\n    games[gameId].state = GameStates.Frozen;\r\n\r\n    emit GameHasFrozen(gameId);\r\n  }\r\n\r\n  /**\r\n   * @notice We use this function to close a game\r\n   * @dev Can only be called by the owner when a game is frozen\r\n   * @param gameId The id of a specific game\r\n   * @param result The result of the game (see: enum GameResults)\r\n   */\r\n  function closeGame(uint gameId, GameResults result) external onlyOwner whenGameIsFrozen(gameId) {\r\n    games[gameId].state = GameStates.Closed;\r\n    games[gameId].result = result;\r\n\r\n    emit GameHasClosed(gameId, result);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns some basic information about a specific game\r\n   * @dev This function DOES NOT return the bets-related info, the current state or the result of the game\r\n   * @param gameId The id of the corresponding game\r\n   */\r\n  function getGameInfo(uint gameId) public view returns (\r\n    string,\r\n    string,\r\n    string\r\n  ) {\r\n    return (\r\n      games[gameId].teamA,\r\n      games[gameId].teamB,\r\n      games[gameId].description\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Returns all the info related to the bets\r\n   * @dev Use other functions for more info\r\n   * @param gameId The id of the corresponding game\r\n   */\r\n  function getGameAmounts(uint gameId) public view returns (\r\n    uint,\r\n    uint,\r\n    uint,\r\n    uint,\r\n    uint\r\n  ) {\r\n    return (\r\n      games[gameId].amountToTeamA,\r\n      games[gameId].amountToDraw,\r\n      games[gameId].amountToTeamB,\r\n      games[gameId].bettorsCount,\r\n      games[gameId].frozenTimestamp\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the state of a specific game\r\n   * @dev Use other functions for more info\r\n   * @param gameId The id of the corresponding game\r\n   */\r\n  function getGameState(uint gameId) public view returns (GameStates) {\r\n    return games[gameId].state;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the result of a specific game\r\n   * @dev Use other functions for more info\r\n   * @param gameId The id of the corresponding game\r\n   */\r\n  function getGameResult(uint gameId) public view returns (GameResults) {\r\n    return games[gameId].result;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the total number of games\r\n   */\r\n  function getTotalGames() public view returns (uint) {\r\n    return games.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Compare 2 strings and returns true if they are identical\r\n   * This function even work if a string is in memory and the other in storage\r\n   * @param a The first string\r\n   * @param b The second string\r\n   */\r\n  function compareStrings(string a, string b) internal pure returns (bool) {\r\n    return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n  }\r\n\r\n  /**\r\n   * @dev Prevent to interact if the game is not open\r\n   * @param gameId The id of a specific game\r\n   */\r\n  modifier whenGameIsOpen(uint gameId) {\r\n    require(games[gameId].state == GameStates.Open);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevent to interact if the game is not frozen\r\n   * @param gameId The id of a specific game\r\n   */\r\n  modifier whenGameIsFrozen(uint gameId) {\r\n    require(games[gameId].state == GameStates.Frozen);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevent to interact if the game is not closed\r\n   * @param gameId The id of a specific game\r\n   */\r\n  modifier whenGameIsClosed(uint gameId) {\r\n    require(games[gameId].state == GameStates.Closed);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title We manage all the things related to our bets here\r\n * @author Clemlak (https://www.beths.co)\r\n */\r\ncontract BethsBet is BethsGame {\r\n  /**\r\n   * @notice Emitted when a new bet is placed\r\n   * @param gameId The name of the corresponding game\r\n   * @param result The result expected by the bettor (see: enum GameResults)\r\n   * @param amount How much the bettor placed\r\n   */\r\n  event NewBetPlaced(uint gameId, GameResults result, uint amount);\r\n\r\n  /**\r\n   * @notice The minimum amount needed to place bet (in Wei)\r\n   * @dev Can be changed later by the changeMinimumBetAmount() function\r\n   */\r\n  uint public minimumBetAmount = 1000000000;\r\n\r\n  /**\r\n   * @notice This struct defines what a bet is\r\n   */\r\n  struct Bet {\r\n    uint gameId;\r\n    GameResults result;\r\n    uint amount;\r\n    bool isPayoutWithdrawn;\r\n  }\r\n\r\n  /**\r\n   * @notice We store all our bets in an array\r\n   */\r\n  Bet[] public bets;\r\n\r\n  /**\r\n   * @notice This links bets with bettors\r\n   */\r\n  mapping (uint => address) public betToAddress;\r\n\r\n  /**\r\n   * @notice This links the bettor to their bets\r\n   */\r\n  mapping (address => uint[]) public addressToBets;\r\n\r\n  /**\r\n   * @notice Changes the minimum amount needed to place a bet\r\n   * @dev The amount is in Wei and must be greater than 0 (can only be changed by the owner)\r\n   * @param newMinimumBetAmount The new amount\r\n   */\r\n  function changeMinimumBetAmount(uint newMinimumBetAmount) external onlyOwner {\r\n    if (newMinimumBetAmount > 0) {\r\n      minimumBetAmount = newMinimumBetAmount;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Place a new bet\r\n   * @dev This function is payable and we'll use the amount we receive as the bet amount\r\n   * Bets can only be placed while the game is open\r\n   * @param gameId The id of the corresponding game\r\n   * @param result The result expected by the bettor (see enum GameResults)\r\n   */\r\n  function placeNewBet(uint gameId, GameResults result) public whenGameIsOpen(gameId) payable {\r\n    // We check if the bet amount is greater or equal to our minimum\r\n    if (msg.value >= minimumBetAmount) {\r\n      // We push our bet in our main array\r\n      uint betId = bets.push(Bet(gameId, result, msg.value, false)) - 1;\r\n\r\n      // We link the bet with the bettor\r\n      betToAddress[betId] = msg.sender;\r\n\r\n      // We link the address with their bets\r\n      addressToBets[msg.sender].push(betId);\r\n\r\n      // Then we update our game\r\n      games[gameId].bettorsCount = games[gameId].bettorsCount.add(1);\r\n\r\n      // And we update the amount bet on the expected result\r\n      if (result == GameResults.TeamA) {\r\n        games[gameId].amountToTeamA = games[gameId].amountToTeamA.add(msg.value);\r\n      } else if (result == GameResults.Draw) {\r\n        games[gameId].amountToDraw = games[gameId].amountToDraw.add(msg.value);\r\n      } else if (result == GameResults.TeamB) {\r\n        games[gameId].amountToTeamB = games[gameId].amountToTeamB.add(msg.value);\r\n      }\r\n\r\n      // And finally we emit the corresponding event\r\n      emit NewBetPlaced(gameId, result, msg.value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Returns an array containing the ids of the bets placed by a specific address\r\n   * @dev This function is meant to be used with the getBetInfo() function\r\n   * @param bettorAddress The address of the bettor\r\n   */\r\n  function getBetsFromAddress(address bettorAddress) public view returns (uint[]) {\r\n    return addressToBets[bettorAddress];\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the info of a specific bet\r\n   * @dev This function is meant to be used with the getBetsFromAddress() function\r\n   * @param betId The id of the specific bet\r\n   */\r\n  function getBetInfo(uint betId) public view returns (uint, GameResults, uint, bool) {\r\n    return (bets[betId].gameId, bets[betId].result, bets[betId].amount, bets[betId].isPayoutWithdrawn);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title This contract handles all the functions related to the payouts\r\n * @author Clemlak (https://www.beths.co)\r\n * @dev This contract is still in progress\r\n */\r\ncontract BethsPayout is BethsBet {\r\n  /**\r\n   * @notice We use this function to withdraw the house cut from a game\r\n   * @dev Can only be called externally by the owner when a game is closed\r\n   * @param gameId The id of a specific game\r\n   */\r\n  function withdrawHouseCutFromGame(uint gameId) external onlyOwner whenGameIsClosed(gameId) {\r\n    // We check if we haven't already withdrawn the cut\r\n    if (!games[gameId].isHouseCutWithdrawn) {\r\n      games[gameId].isHouseCutWithdrawn = true;\r\n      uint houseCutAmount = calculateHouseCutAmount(gameId);\r\n      owner.transfer(houseCutAmount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice This function is called by a bettor to withdraw his payout\r\n   * @dev This function can only be called externally\r\n   * @param betId The id of a specific bet\r\n   */\r\n  function withdrawPayoutFromBet(uint betId) external whenGameIsClosed(bets[betId].gameId) {\r\n    // We check if the bettor has won\r\n    require(games[bets[betId].gameId].result == bets[betId].result);\r\n\r\n    // If he won, but we want to be sure that he didn't already withdraw his payout\r\n    if (!bets[betId].isPayoutWithdrawn) {\r\n      // Everything seems okay, so now we give the bettor his payout\r\n      uint payout = calculatePotentialPayout(betId);\r\n\r\n      // We prevent the bettor to withdraw his payout more than once\r\n      bets[betId].isPayoutWithdrawn = true;\r\n\r\n      address bettorAddress = betToAddress[betId];\r\n\r\n      // We send the payout\r\n      bettorAddress.transfer(payout);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the \"raw\" pool amount (including the amount of the house cut)\r\n   * @dev Can be called at any state of a game\r\n   * @param gameId The id of a specific game\r\n   */\r\n  function calculateRawPoolAmount(uint gameId) internal view returns (uint) {\r\n    return games[gameId].amountToDraw.add(games[gameId].amountToTeamA.add(games[gameId].amountToTeamB));\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the amount the house will take\r\n   * @dev Can be called at any state of a game\r\n   * @param gameId The id of a specific game\r\n   */\r\n  function calculateHouseCutAmount(uint gameId) internal view returns (uint) {\r\n    uint rawPoolAmount = calculateRawPoolAmount(gameId);\r\n    return houseCutPercentage.mul(rawPoolAmount.div(100));\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the total of the pool (minus the house part)\r\n   * @dev This value will be used to calculate the bettors' payouts\r\n   * @param gameId the id of a specific game\r\n   */\r\n  function calculatePoolAmount(uint gameId) internal view returns (uint) {\r\n    uint rawPoolAmount = calculateRawPoolAmount(gameId);\r\n    uint houseCutAmount = calculateHouseCutAmount(gameId);\r\n\r\n    return rawPoolAmount.sub(houseCutAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the potential payout from a bet\r\n   * @dev Warning! This function DOES NOT check if the game is open/frozen/closed or if the bettor has won\r\n   * @param betId The id of a specific bet\r\n   */\r\n  function calculatePotentialPayout(uint betId) internal view returns (uint) {\r\n    uint betAmount = bets[betId].amount;\r\n\r\n    uint poolAmount = calculatePoolAmount(bets[betId].gameId);\r\n\r\n    uint temp = betAmount.mul(poolAmount);\r\n\r\n    uint betAmountToWinningTeam = 0;\r\n\r\n    if (games[bets[betId].gameId].result == GameResults.TeamA) {\r\n      betAmountToWinningTeam = games[bets[betId].gameId].amountToTeamA;\r\n    } else if (games[bets[betId].gameId].result == GameResults.TeamB) {\r\n      betAmountToWinningTeam = games[bets[betId].gameId].amountToTeamB;\r\n    } else if (games[bets[betId].gameId].result == GameResults.Draw) {\r\n      betAmountToWinningTeam = games[bets[betId].gameId].amountToDraw;\r\n    }\r\n\r\n    return temp.div(betAmountToWinningTeam);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"teamA\",\"type\":\"string\"},{\"name\":\"amountToTeamA\",\"type\":\"uint256\"},{\"name\":\"teamB\",\"type\":\"string\"},{\"name\":\"amountToTeamB\",\"type\":\"uint256\"},{\"name\":\"amountToDraw\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"frozenTimestamp\",\"type\":\"uint256\"},{\"name\":\"bettorsCount\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"isHouseCutWithdrawn\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"isPayoutWithdrawn\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"closeGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHouseCutPercentage\",\"type\":\"uint256\"}],\"name\":\"changeHouseCutPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"withdrawHouseCutFromGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumBetAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getBetInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bettorAddress\",\"type\":\"address\"}],\"name\":\"getBetsFromAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressToBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"teamA\",\"type\":\"string\"},{\"name\":\"teamB\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"frozenTimestamp\",\"type\":\"uint256\"}],\"name\":\"createNewGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"freezeGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseCutPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"withdrawPayoutFromBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"placeNewBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"getGameResult\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumBetAmount\",\"type\":\"uint256\"}],\"name\":\"changeMinimumBetAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"getGameAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"getGameState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewBetPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"teamA\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"teamB\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"frozenTimestamp\",\"type\":\"uint256\"}],\"name\":\"GameHasOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"}],\"name\":\"GameHasFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"GameHasClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newHouseCutPercentage\",\"type\":\"uint256\"}],\"name\":\"HouseCutPercentageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BethsPayout","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://263f124845f7f84b29bab4b7b63cdd9603c85898e45b98c7582f67912af4f6ae"}]}