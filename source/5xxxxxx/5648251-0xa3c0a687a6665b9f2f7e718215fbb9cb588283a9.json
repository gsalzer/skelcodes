{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\ncontract Factory {\r\n  address developer = 0x007C67F0CDBea74592240d492Aef2a712DAFa094c3;\r\n  \r\n  event ContractCreated(address creator, address newcontract, uint timestamp, string contract_type);\r\n    \r\n  function setDeveloper (address _dev) public {\r\n    if(developer==address(0) || developer==msg.sender){\r\n       developer = _dev;\r\n    }\r\n  }\r\n  \r\n  function createContract (bool isbroker, string contract_type, bool _brokerrequired) \r\n  public {\r\n    address newContract = new Broker(isbroker, developer, msg.sender, _brokerrequired);\r\n    emit ContractCreated(msg.sender, newContract, block.timestamp, contract_type);\r\n  } \r\n}\r\n\r\ncontract Broker {\r\n  enum State { Created, Validated, Locked, Finished }\r\n  State public state;\r\n\r\n  enum FileState { \r\n    Created, \r\n    Invalidated\r\n    // , Confirmed \r\n  }\r\n\r\n  struct File{\r\n    // The purpose of this file. Like, picture, license info., etc.\r\n    // to save the space, we better use short name.\r\n    // Dapps should match proper long name for this.\r\n    bytes32 purpose;\r\n    // name of the file\r\n    string name;\r\n    // ipfs id for this file\r\n    string ipfshash;\r\n    FileState state;\r\n  }\r\n\r\n  struct Item{\r\n    string name;\r\n    // At least 0.1 Finney, because it's the fee to the developer\r\n    uint   price;\r\n    // this could be a link to an Web page explaining about this item\r\n    string detail;\r\n    File[] documents;\r\n  }\r\n\r\n  Item public item;\r\n  address public seller = address(0);\r\n  address public broker = address(0);\r\n  uint    public brokerFee;\r\n  // Minimum 0.1 Finney (0.0001 eth ~ 25Cent) to 0.01% of the price.\r\n  uint    public developerfee = 0.1 finney;\r\n  uint    minimumdeveloperfee = 0.1 finney;\r\n  address developer = 0x007C67F0CDBea74592240d492Aef2a712DAFa094c3;\r\n  // bool public validated;\r\n  address creator = 0x0;\r\n  address factory = 0x0;\r\n  \r\n  bool bBrokerRequired = true;\r\n  address[] public buyers;\r\n\r\n\r\n  modifier onlySeller() {\r\n    require(msg.sender == seller);\r\n    _;\r\n  }\r\n\r\n  modifier onlyCreator() {\r\n    require(msg.sender == creator);\r\n    _;\r\n  }\r\n\r\n  modifier onlyBroker() {\r\n    require(msg.sender == broker);\r\n    _;\r\n  }\r\n\r\n  modifier inState(State _state) {\r\n      require(state == _state);\r\n      _;\r\n  }\r\n\r\n  modifier condition(bool _condition) {\r\n      require(_condition);\r\n      _;\r\n  }\r\n\r\n  event AbortedBySeller();\r\n  event AbortedByBroker();\r\n  event PurchaseConfirmed(address buyer);\r\n  event ItemReceived();\r\n  event Validated();\r\n  event ItemInfoChanged(string name, uint price, string detail, uint developerfee);\r\n  event SellerChanged(address seller);\r\n  event BrokerChanged(address broker);\r\n  event BrokerFeeChanged(uint fee);\r\n\r\n  // The constructor\r\n  constructor(bool isbroker, address _dev, address _creator, bool _brokerrequired) \r\n    public \r\n  {\r\n    bBrokerRequired = _brokerrequired;\r\n    if(creator==address(0)){\r\n      //storedData = initialValue;\r\n      if(isbroker)\r\n        broker = _creator;\r\n      else\r\n        seller = _creator;\r\n      creator = _creator;\r\n      // value = msg.value / 2;\r\n      // require((2 * value) == msg.value);\r\n      state = State.Created;\r\n\r\n      // validated = false;\r\n      brokerFee = 50;\r\n    }\r\n    if(developer==address(0) || developer==msg.sender){\r\n       developer = _dev;\r\n    }\r\n    if(factory==address(0)){\r\n       factory = msg.sender;\r\n    }\r\n  }\r\n\r\n  function joinAsBroker() public {\r\n    if(broker==address(0)){\r\n      broker = msg.sender;\r\n    }\r\n  }\r\n\r\n  function createOrSet(string name, uint price, string detail)\r\n    public \r\n    inState(State.Created)\r\n    onlyCreator\r\n  {\r\n    require(price > minimumdeveloperfee);\r\n    item.name = name;\r\n    item.price = price;\r\n    item.detail = detail;\r\n    developerfee = (price/1000)<minimumdeveloperfee ? minimumdeveloperfee : (price/1000);\r\n    emit ItemInfoChanged(name, price, detail, developerfee);\r\n  }\r\n\r\n  function getBroker()\r\n    public \r\n    constant returns(address, uint)\r\n  {\r\n    return (broker, brokerFee);\r\n  }\r\n\r\n  function getSeller()\r\n    public \r\n    constant returns(address)\r\n  {\r\n    return (seller);\r\n  }\r\n  \r\n  function getBuyers()\r\n    public \r\n    constant returns(address[])\r\n  {\r\n    return (buyers);\r\n  }\r\n\r\n  function setBroker(address _address)\r\n    public \r\n    onlySeller\r\n    inState(State.Created)\r\n  {\r\n    broker = _address;\r\n    emit BrokerChanged(broker);\r\n  }\r\n\r\n  function setBrokerFee(uint fee)\r\n    public \r\n    onlyCreator\r\n    inState(State.Created)\r\n  {\r\n    brokerFee = fee;\r\n    emit BrokerFeeChanged(fee);\r\n  }\r\n\r\n  function setSeller(address _address)\r\n    public \r\n    onlyBroker\r\n    inState(State.Created)\r\n  {\r\n    seller = _address;\r\n    emit SellerChanged(seller);\r\n  }\r\n\r\n  // We will have some 'peculiar' list of documents\r\n  // for each deals. \r\n  // For ex, for House we will require\r\n  // proof of documents about the basic information of the House,\r\n  // and some insurance information.\r\n  // So we can make a template for each differene kind of deals.\r\n  // Deals for a house, deals for a Car, etc.\r\n  function addDocument(bytes32 _purpose, string _name, string _ipfshash)\r\n    public \r\n  {\r\n    require(state != State.Finished);\r\n    require(state != State.Locked);\r\n    item.documents.push( File({\r\n      purpose:_purpose, name:_name, ipfshash:_ipfshash, state:FileState.Created}\r\n      ) \r\n    );\r\n  }\r\n\r\n  // deleting actual file on the IPFS network is very hard.\r\n  function deleteDocument(uint index)\r\n    public \r\n  {\r\n    require(state != State.Finished);\r\n    require(state != State.Locked);\r\n    if(index<item.documents.length){\r\n      item.documents[index].state = FileState.Invalidated;\r\n    }\r\n  }\r\n\r\n  function validate()\r\n    public \r\n    onlyBroker\r\n    inState(State.Created)\r\n  {\r\n    // if(index<item.documents.length){\r\n    //   item.documents[index].state = FileState.Confirmed;\r\n    // }\r\n    emit Validated();\r\n    // validated = true;\r\n    state = State.Validated;\r\n  }\r\n\r\n  /// Abort the purchase and reclaim the ether.\r\n  /// Can only be called by the seller before\r\n  /// the contract is locked.\r\n  function abort()\r\n    public \r\n    onlySeller\r\n    inState(State.Created)\r\n  {\r\n      emit AbortedBySeller();\r\n      state = State.Finished;\r\n      // validated = false;\r\n      seller.transfer(address(this).balance);\r\n  }\r\n\r\n  function abortByBroker()\r\n    public \r\n    onlyBroker\r\n  {\r\n      if(!bBrokerRequired)\r\n        return;\r\n        \r\n      require(state != State.Finished);\r\n      state = State.Finished;\r\n      emit AbortedByBroker();\r\n      \r\n      if(buyers.length>0){\r\n          uint val = address(this).balance / buyers.length;\r\n          for (uint256 x = 0; x < buyers.length; x++) {\r\n              buyers[x].transfer(val);\r\n          }\r\n      }\r\n  }\r\n\r\n  /// Confirm the purchase as buyer.\r\n  /// The ether will be locked until confirmReceived\r\n  /// is called.\r\n  function confirmPurchase()\r\n    public \r\n    condition(msg.value == item.price)\r\n    payable\r\n  {\r\n      if(bBrokerRequired){\r\n        if(state != State.Validated){\r\n          return;\r\n        }\r\n      }\r\n      \r\n      state = State.Locked;\r\n      buyers.push(msg.sender);\r\n      emit PurchaseConfirmed(msg.sender);\r\n      \r\n      if(!bBrokerRequired){\r\n\t\t// send money right away\r\n        seller.transfer(item.price-developerfee);\r\n        developer.transfer(developerfee);\r\n      }\r\n  }\r\n\r\n  /// Confirm that you (the buyer) received the item.\r\n  /// This will release the locked ether.\r\n  function confirmReceived()\r\n    public \r\n    onlyBroker\r\n    inState(State.Locked)\r\n  {\r\n      // It is important to change the state first because\r\n      // otherwise, the contracts called using `send` below\r\n      // can call in again here.\r\n      state = State.Finished;\r\n\r\n      // NOTE: This actually allows both the buyer and the seller to\r\n      // block the refund - the withdraw pattern should be used.\r\n      seller.transfer(address(this).balance-brokerFee-developerfee);\r\n      broker.transfer(brokerFee);\r\n      developer.transfer(developerfee);\r\n\r\n      emit ItemReceived();\r\n  }\r\n\r\n  function getInfo() constant \r\n    public \r\n    returns (State, string, uint, string, uint, uint, address, address, bool)\r\n  {\r\n    return (state, item.name, item.price, item.detail, item.documents.length, \r\n        developerfee, seller, broker, bBrokerRequired);\r\n  }\r\n\r\n  function getFileAt(uint index) \r\n    public \r\n    constant returns(uint, bytes32, string, string, FileState)\r\n  {\r\n    return (index,\r\n      item.documents[index].purpose,\r\n      item.documents[index].name,\r\n      item.documents[index].ipfshash,\r\n      item.documents[index].state);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"isbroker\",\"type\":\"bool\"},{\"name\":\"contract_type\",\"type\":\"string\"},{\"name\":\"_brokerrequired\",\"type\":\"bool\"}],\"name\":\"createContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dev\",\"type\":\"address\"}],\"name\":\"setDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newcontract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contract_type\",\"type\":\"string\"}],\"name\":\"ContractCreated\",\"type\":\"event\"}]","ContractName":"Factory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bb160a0231527f7d7db826c0ac28a76e29d44797d6f40c5a0abeec892004cb01"}]}