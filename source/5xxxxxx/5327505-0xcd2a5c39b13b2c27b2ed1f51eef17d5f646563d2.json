{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n// Wolf Crypto presale pooling contract\r\n// written by @iamdefinitelyahuman\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) return 0;\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface ERC20 {\r\n  function balanceOf(address _owner) external returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface WhiteList {\r\n   function checkMemberLevel (address addr) external view returns (uint);\r\n}\r\n\r\nlibrary PresaleLib {\r\n\t\r\n  using SafeMath for uint;\r\n  \r\n  WhiteList constant whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63);\r\n  uint constant contributionMin = 100000000000000000;\r\n  uint constant maxGasPrice = 50000000000;\r\n  \r\n  struct Contributor {\r\n    uint16 claimedTokensIndex;\r\n    uint balance;\r\n  }\r\n  \r\n  struct Data {\r\n    address owner;\r\n    address receiver;\r\n    address[] withdrawToken;\r\n    bool poolSubmitted;\r\n    bool locked;\r\n    uint addressSetTime;\r\n    uint fee;\r\n    uint contractCap;\r\n    uint finalBalance;\r\n    uint[] withdrawAmount;\r\n    uint[] capAmounts;\r\n    uint32[] capTimes;\r\n    mapping (address => uint) tokenBalances;\r\n    mapping (address => uint) individualCaps;\r\n    mapping (address => Contributor) contributorMap;\r\n  }\r\n  \r\n  event ContributorBalanceChanged (address contributor, uint totalBalance);\r\n  event ReceiverAddressSet ( address addr);\r\n  event PoolSubmitted (address receiver, uint amount);\r\n  event WithdrawalAvailable (address token);\r\n  event WithdrawalClaimed (address receiver, address token, uint amount);\r\n  \r\n  modifier onlyOwner (Data storage self) {\r\n    require (msg.sender == self.owner);\r\n    _;\r\n  }\r\n  \r\n  modifier noReentrancy(Data storage self) {\r\n    require(!self.locked);\r\n    self.locked = true;\r\n    _;\r\n    self.locked = false;\r\n  }\r\n  \r\n  function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\r\n    return numerator.mul(10 ** 20).div(denominator);\r\n  }\r\n  \r\n  function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\r\n    return numerator.mul(pct).div(10 ** 20);\r\n  }\r\n  \r\n  function newPool (Data storage self, uint _fee, address _receiver, uint _contractCap, uint _individualCap) public {\r\n    require (_fee < 1000);\r\n    self.owner = msg.sender;\r\n    self.receiver = _receiver;\r\n    self.contractCap = _contractCap;\r\n    self.capTimes.push(0);\r\n    self.capAmounts.push(_individualCap);\r\n    self.fee = _toPct(_fee,1000);\r\n  }\r\n\t\r\n  function deposit (Data storage self) public {\r\n\t  assert (!self.poolSubmitted);\r\n    require (tx.gasprice <= maxGasPrice);\r\n    Contributor storage c = self.contributorMap[msg.sender];\r\n    uint cap = _getCap(self, msg.sender);\r\n    require (cap >= c.balance.add(msg.value));\r\n    if (self.contractCap < address(this).balance) {\r\n      require (address(this).balance.sub(msg.value) < self.contractCap);\r\n      uint excess = address(this).balance.sub(self.contractCap);\r\n      c.balance = c.balance.add(msg.value.sub(excess));\r\n      msg.sender.transfer(excess);\r\n    } else {\r\n      c.balance = c.balance.add(msg.value);\r\n    }\r\n    require (c.balance >= contributionMin);\r\n    emit ContributorBalanceChanged(msg.sender, c.balance);\r\n  }\r\n  \r\n  function receiveRefund (Data storage self) public {\r\n    assert (self.poolSubmitted);\r\n    require (msg.sender == self.receiver || msg.sender == self.owner);\r\n    require (msg.value >= 1 ether);\r\n    self.withdrawToken.push(0x00);\r\n    self.withdrawAmount.push(msg.value);\r\n    emit WithdrawalAvailable(0x00);\r\n  }\r\n  \r\n  function withdraw (Data storage self) public {\r\n    assert (msg.value == 0);\r\n    Contributor storage c = self.contributorMap[msg.sender];\r\n    require (c.balance > 0);\r\n    if (!self.poolSubmitted) {\r\n      uint balance = c.balance;\r\n      c.balance = 0;\r\n      msg.sender.transfer(balance);\r\n      emit ContributorBalanceChanged(msg.sender, 0);\r\n      return;\r\n    }\r\n    require (c.claimedTokensIndex < self.withdrawToken.length);\r\n    uint pct = _toPct(c.balance,self.finalBalance);\r\n    uint amount;\r\n    address token;\r\n    for (uint16 i = c.claimedTokensIndex; i < self.withdrawToken.length; i++) {\r\n      amount = _applyPct(self.withdrawAmount[i],pct);\r\n      token = self.withdrawToken[i];\r\n      c.claimedTokensIndex++;\r\n      if (amount > 0) {  \r\n        if (token == 0x00) {\r\n          msg.sender.transfer(amount);\r\n        } else {\r\n          require (ERC20(token).transfer(msg.sender, amount));\r\n          self.tokenBalances[token] = self.tokenBalances[token].sub(amount);  \r\n        }\r\n        emit WithdrawalClaimed(msg.sender, token, amount);\r\n      }\r\n    }\r\n  }\r\n  \r\n  function setIndividualCaps (Data storage self, address[] addr, uint[] cap) public onlyOwner(self) {\r\n    require (addr.length == cap.length);\r\n    for (uint8 i = 0; i < addr.length; i++) {\r\n      self.individualCaps[addr[i]] = cap[i];\r\n    }  \r\n  }\r\n  \r\n  function setCaps (Data storage self, uint32[] times, uint[] caps) public onlyOwner(self) {\r\n    require (caps.length > 0);\r\n    require (caps.length == times.length);\r\n    self.capTimes = [0];\r\n    self.capAmounts = [self.capAmounts[0]];\r\n    for (uint8 i = 0; i < caps.length; i++) {\r\n      require (times[i] > self.capTimes[self.capTimes.length.sub(1)]);\r\n      self.capTimes.push(times[i]);\r\n      self.capAmounts.push(caps[i]);\r\n    }\r\n  }\r\n  \r\n  function setContractCap (Data storage self, uint amount) public onlyOwner(self) {\r\n    require (amount >= address(this).balance);\r\n    self.contractCap = amount;\r\n  }\r\n  \r\n  function _getCap (Data storage self, address addr) internal view returns (uint) {\r\n    if (self.individualCaps[addr] > 0) return self.individualCaps[addr];\r\n    if (whitelistContract.checkMemberLevel(msg.sender) == 0) return 0;\r\n    return getCapAtTime(self,now);\r\n  }\r\n  \r\n  function getCapAtTime (Data storage self, uint time) public view returns (uint) {\r\n    if (time == 0) time = now;\r\n    for (uint i = 1; i < self.capTimes.length; i++) {\r\n      if (self.capTimes[i] > time) return self.capAmounts[i-1];\r\n    }\r\n    return self.capAmounts[self.capAmounts.length-1];\r\n  }\r\n  \r\n  function getPoolInfo (Data storage self) view public returns (uint balance, uint remaining, uint cap) {\r\n    if (!self.poolSubmitted) return (address(this).balance, self.contractCap.sub(address(this).balance), self.contractCap);\r\n    return (address(this).balance, 0, self.contractCap);\r\n  }\r\n  \r\n  function getContributorInfo (Data storage self, address addr) view public returns (uint balance, uint remaining, uint cap) {\r\n    cap = _getCap(self, addr);\r\n    Contributor storage c = self.contributorMap[addr];\r\n    if (self.poolSubmitted || cap <= c.balance) return (c.balance, 0, cap);\r\n    if (cap.sub(c.balance) > self.contractCap.sub(address(this).balance)) return (c.balance, self.contractCap.sub(address(this).balance), cap);\r\n    return (c.balance, cap.sub(c.balance), cap);\r\n  }\r\n  \r\n  function checkWithdrawalAvailable (Data storage self, address addr) view public returns (bool) {\r\n    return self.contributorMap[addr].claimedTokensIndex < self.withdrawToken.length;\r\n  }\r\n  \r\n  function setReceiverAddress (Data storage self, address _receiver) public onlyOwner(self) {\r\n    require (!self.poolSubmitted);\r\n    self.receiver = _receiver;\r\n    self.addressSetTime = now;\r\n    emit ReceiverAddressSet(_receiver);\r\n  }\r\n  \r\n  function submitPool (Data storage self, uint amountInWei) public onlyOwner(self) noReentrancy(self) {\r\n    require (!self.poolSubmitted);\r\n    require (now > self.addressSetTime.add(86400));\r\n    if (amountInWei == 0) amountInWei = address(this).balance;\r\n    self.finalBalance = address(this).balance;\r\n    self.poolSubmitted = true;\r\n    require (self.receiver.call.value(amountInWei).gas(gasleft().sub(5000))());\r\n    if (address(this).balance > 0) {\r\n      self.withdrawToken.push(0x00);\r\n      self.withdrawAmount.push(address(this).balance);\r\n      emit WithdrawalAvailable(0x00);\r\n    }\r\n    emit PoolSubmitted(self.receiver, amountInWei);\r\n  }\r\n  \r\n  function enableWithdrawals (Data storage self, address tokenAddress, address feeAddress) public onlyOwner(self) noReentrancy(self) {\r\n    require (self.poolSubmitted);\r\n    if (feeAddress == 0x00) feeAddress = self.owner;\r\n    ERC20 token = ERC20(tokenAddress);\r\n    uint amount = token.balanceOf(this).sub(self.tokenBalances[tokenAddress]);\r\n    require (amount > 0);\r\n    if (self.fee > 0) {\r\n      require (token.transfer(feeAddress, _applyPct(amount,self.fee)));\r\n      amount = token.balanceOf(this).sub(self.tokenBalances[tokenAddress]);\r\n    }\r\n    self.tokenBalances[tokenAddress] = token.balanceOf(this);\r\n    self.withdrawToken.push(tokenAddress);\r\n    self.withdrawAmount.push(amount);\r\n    emit WithdrawalAvailable(tokenAddress);\r\n  }\r\n\r\n}\r\ncontract PresalePool {\r\n\t\r\n\tusing PresaleLib for PresaleLib.Data;\r\n\tPresaleLib.Data data;\r\n  \r\n  event ERC223Received (address token, uint value, bytes data);\r\n\t\r\n\tfunction PresalePool (uint fee, address receiver, uint contractCap, uint individualCap) public {\r\n    data.newPool(fee, receiver, contractCap, individualCap);\r\n\t}\r\n\t\r\n\tfunction () public payable {\r\n    if (msg.value > 0) {\r\n      if (!data.poolSubmitted) {\r\n        data.deposit();\r\n      } else {\r\n        data.receiveRefund();\r\n      }\r\n    } else {\r\n      data.withdraw();\r\n    }\r\n\t}\r\n  \r\n  function setIndividualCaps (address[] addr, uint[] cap) public {\r\n    data.setIndividualCaps(addr, cap); \r\n  }\r\n  \r\n  function setCaps (uint32[] times, uint[] caps) public {\r\n    data.setCaps(times,caps);\r\n  }\r\n  \r\n  function setContractCap (uint amount) public {\r\n    data.setContractCap(amount);\r\n  }\r\n  \r\n  function getPoolInfo () view public returns (uint balance, uint remaining, uint cap) {\r\n    return data.getPoolInfo();\r\n  }\r\n  \r\n  function getContributorInfo (address addr) view public returns (uint balance, uint remaining, uint cap) {\r\n    return data.getContributorInfo(addr);\r\n  }\r\n  \r\n  function getCapAtTime (uint32 time) view public returns (uint) {\r\n    return data.getCapAtTime(time);\r\n  }\r\n  \r\n  function checkWithdrawalAvailable (address addr) view public returns (bool) {\r\n    return data.checkWithdrawalAvailable(addr);\r\n  }\r\n  \r\n  function setReceiverAddress (address receiver) public {\r\n    data.setReceiverAddress(receiver);\r\n  }\r\n  \r\n  function submitPool (uint amountInWei) public {\r\n    data.submitPool(amountInWei);\r\n  }\r\n  \r\n  function enableWithdrawals (address tokenAddress, address feeAddress) public {\r\n    data.enableWithdrawals(tokenAddress, feeAddress);\r\n  }\r\n  \r\n  function tokenFallback (address from, uint value, bytes calldata) public {\r\n    emit ERC223Received(from, value, calldata);\r\n  }\r\n\t\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getContributorInfo\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"times\",\"type\":\"uint32[]\"},{\"name\":\"caps\",\"type\":\"uint256[]\"}],\"name\":\"setCaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"submitPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address[]\"},{\"name\":\"cap\",\"type\":\"uint256[]\"}],\"name\":\"setIndividualCaps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"time\",\"type\":\"uint32\"}],\"name\":\"getCapAtTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPoolInfo\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"remaining\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setReceiverAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setContractCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"feeAddress\",\"type\":\"address\"}],\"name\":\"enableWithdrawals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkWithdrawalAvailable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"calldata\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"contractCap\",\"type\":\"uint256\"},{\"name\":\"individualCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC223Received\",\"type\":\"event\"}]","ContractName":"PresalePool","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"PresaleLib:C49501f07c9A587AdAc93E09ECAe5F701098ec2a","SwarmSource":"bzzr://9ad5dc6050e6d3ad8a99b36781149bf3f1ed8ed0711978d6c83ed4b37d9bf0ac"}]}