{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.18;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract iERC223Token {\r\n    function transfer(address to, uint value, bytes data) public returns (bool ok);\r\n    function transferFrom(address from, address to, uint value, bytes data) public returns (bool ok);\r\n}\r\n\r\ncontract ERC223Receiver {\r\n    function tokenFallback( address _origin, uint _value, bytes _data) public returns (bool ok);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract iERC20Token {\r\n    uint256 public totalSupply = 0;\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  function safeTransfer(StandardToken token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(StandardToken token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(StandardToken token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\ncontract StandardToken is iERC20Token {\r\n\r\n    using SafeMath for uint256;\r\n    mapping(address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n   /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract FreezableToken is iERC223Token, StandardToken, Ownable {\r\n\r\n    event ContractTransfer(address indexed _from, address indexed _to, uint _value, bytes _data);\r\n\r\n    bool public freezed;\r\n\r\n    modifier canTransfer(address _transferer) {\r\n        require(owner == _transferer || !freezed);\r\n        _;\r\n    }\r\n\r\n    function FreezableToken() public {\r\n        freezed = true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value, bytes _data) canTransfer(msg.sender)\r\n        public\r\n        canTransfer(msg.sender)\r\n        returns (bool success) {\r\n        //filtering if the target is a contract with bytecode inside it\r\n        require(super.transfer(_to, _value)); // do a normal token transfer\r\n        if (isContract(_to)) {\r\n            require(contractFallback(msg.sender, _to, _value, _data));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value, bytes _data) public canTransfer(msg.sender) returns (bool success) {\r\n        require(super.transferFrom(_from, _to, _value)); // do a normal token transfer\r\n        if (isContract(_to)) {\r\n            require(contractFallback(_from, _to, _value, _data));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) canTransfer(msg.sender) public canTransfer(msg.sender) returns (bool success) {\r\n        return transfer(_to, _value, new bytes(0));\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public canTransfer(msg.sender) returns (bool success) {\r\n        return transferFrom(_from, _to, _value, new bytes(0));\r\n    }\r\n\r\n    //function that is called when transaction target is a contract\r\n    function contractFallback(address _origin, address _to, uint _value, bytes _data) private returns (bool) {\r\n        ContractTransfer(_origin, _to, _value, _data);\r\n        ERC223Receiver reciever = ERC223Receiver(_to);\r\n        require(reciever.tokenFallback(_origin, _value, _data));\r\n        return true;\r\n    }\r\n\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) private view returns (bool is_contract) {\r\n        uint length;\r\n        assembly { length := extcodesize(_addr) }\r\n        return length > 0;\r\n    }\r\n\r\n    function unfreeze() public onlyOwner returns (bool){\r\n        freezed = false;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract SimpleMultisigWallet is ERC223Receiver {\r\n\r\n\r\n    // Max size of owners that can be added to wallet\r\n    uint constant private MAX_OWNER_COUNT = 5;\r\n\r\n    /**\r\n      * event for transaction confirmation logging\r\n      * @param sender who confirmed transaction\r\n      * @param transactionId transaction identifier\r\n      * @param createdOn time of log\r\n      */\r\n    event Confirmation(address sender, uint transactionId, uint256 createdOn);\r\n\r\n    /**\r\n      * event for transaction revocation logging\r\n      * @param sender who confirmed transaction\r\n      * @param transactionId transaction identifier\r\n      * @param createdOn time of log\r\n      */\r\n    event Revocation(address sender, uint transactionId, uint256 createdOn);\r\n\r\n    /**\r\n      * event for transaction submission logging\r\n      * @param transactionId transaction identifier\r\n      * @param token token contract address if transaction submits tokens\r\n      * @param transactionType type of transaction showing if tokens or ether is submited\r\n      * @param createdOn time of log\r\n      */\r\n    event Submission(uint indexed transactionId, address indexed token, address indexed newOwner, TransactionType transactionType, uint256 createdOn);\r\n\r\n    /**\r\n      * event for transaction execution logging\r\n      * @param transactionId transaction identifier\r\n      * @param createdOn time of log\r\n      */\r\n    event Execution(uint indexed transactionId, uint256 createdOn);\r\n\r\n    /**\r\n      * event for deposit logging\r\n      * @param sender account who send ether\r\n      * @param value amount of wei which was sent\r\n      * @param createdOn time of log\r\n      */\r\n    event Deposit(address indexed sender, uint value, uint256 createdOn);\r\n\r\n    /**\r\n      * event for owner addition logging\r\n      * @param owner new added wallet owner\r\n      * @param createdOn time of log\r\n      */\r\n    event OwnerAddition(address indexed owner, uint256 createdOn);\r\n\r\n    /**\r\n      * event for owner removal logging\r\n      * @param owner wallet owner who was removed from wallet\r\n      * @param createdOn time of log\r\n      */\r\n    event OwnerRemoval(address indexed owner, uint256 createdOn);\r\n\r\n    /**\r\n      * event for needed confirmation requirement change logging\r\n      * @param required number of confirmation needed for action to be proceeded\r\n      * @param createdOn time of log\r\n      *//*\r\n    event RequirementChange(uint required, uint256 createdOn);*/\r\n\r\n    // dictionary which shows transaction info by transaction identifer\r\n    mapping (uint => Transaction) public transactions;\r\n\r\n    // dictionary which shows which owners confirmed transactions\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n\r\n    // dictionary which shows if ether account is owner\r\n    mapping (address => bool) internal isOwner;\r\n\r\n    // owners of wallet\r\n    address[] internal owners;\r\n\r\n    // number of confirmation which is needed to action be proceeded\r\n    uint internal required;\r\n\r\n    //total transaction count\r\n    uint public transactionCount;\r\n\r\n    // dictionary which shows owners who confirmed new owner addition\r\n    mapping(address => address[]) private ownersConfirmedOwnerAdd;\r\n\r\n    // dictionary which shows owners who confirmed existing owner remove\r\n    mapping(address => address[]) private ownersConfirmedOwnerRemove;\r\n\r\n    // Type which identifies if transaction will operate with ethers or tokens\r\n    enum TransactionType{Standard, Token, Unfreeze, PassOwnership}\r\n\r\n    // Structure of detailed transaction information\r\n    struct Transaction {\r\n        address token;\r\n        address destination;\r\n        uint value;\r\n        TransactionType transactionType;\r\n        bool executed;\r\n    }\r\n\r\n    modifier notConfirmedOwnerAdd(address _owner) {\r\n        for(uint i = 0; i < ownersConfirmedOwnerAdd[_owner].length; i++){\r\n            require(ownersConfirmedOwnerAdd[_owner][i] != msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmedOwnerRemove(address _owner) {\r\n        for(uint i = 0; i < ownersConfirmedOwnerRemove[_owner].length; i++){\r\n            require(ownersConfirmedOwnerRemove[_owner][i] != msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require (transactions[transactionId].destination != 0 || transactions[transactionId].token != 0);\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(transactionId >= 0 && transactionId < transactionCount);\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(transactionId >= 0 && transactionId < transactionCount);\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require (_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint _ownersCount, uint _required) {\r\n        require(_ownersCount <= MAX_OWNER_COUNT);\r\n        require(_required <= _ownersCount);\r\n        require(_required > 1);\r\n        require(_ownersCount > 1);\r\n        _;\r\n    }\r\n\r\n    modifier validTransaction(address destination, uint value) {\r\n        require(destination != 0x0);\r\n        require(value > 0);\r\n        _;\r\n    }\r\n\r\n    modifier validTokenTransaction(address token, address destination, uint value) {\r\n        require(token != 0x0);\r\n        require(destination != 0x0);\r\n        require(value > 0);\r\n        _;\r\n    }\r\n\r\n    modifier validFreezableToken(address token) {\r\n        require(token != 0x0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function() public payable {\r\n        if (msg.value > 0){\r\n            Deposit(msg.sender, msg.value, now);\r\n        }\r\n    }\r\n\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required number of needed confirmation to proceed any action\r\n    function SimpleMultisigWallet(address[] _owners, uint _required)\r\n    public\r\n    validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            require(!(isOwner[_owners[i]] || _owners[i] == 0));\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n\r\n        owners = _owners;\r\n        //        owners.push(msg.sender);\r\n        //        isOwner[msg.sender] = true;\r\n        require(_required <= owners.length);\r\n        required = _required;\r\n    }\r\n\r\n    function getOwners()\r\n    public\r\n    view\r\n    returns(address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n\r\n    function removeOwnersConfirmations(address _owner) private {\r\n        uint[] memory transactionIds = ownersConfirmedTransactions(_owner);\r\n        for (uint i = 0; i < transactionIds.length; i++) {\r\n            confirmations[transactionIds[i]][_owner] = false;\r\n        }\r\n    }\r\n\r\n    /*/// @dev Allows to change the number of required confirmations.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        ownerExists(msg.sender)\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required, now);\r\n    }*/\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value)\r\n    public\r\n    ownerExists(msg.sender)\r\n    validTransaction(destination, value)\r\n    returns (uint)\r\n    {\r\n        require(address(this).balance >= value);\r\n        uint transactionId = addTransaction(0x0, destination, value, TransactionType.Standard);\r\n        confirmTransaction(transactionId);\r\n        return transactionId;\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a token transaction.\r\n    /// @param token address of token SC which supply will b transferred.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @return Returns transaction ID.\r\n    function submitTokenTransaction(address token, address destination, uint value)\r\n    public\r\n    ownerExists(msg.sender)\r\n    validTokenTransaction(token, destination, value)\r\n    returns (uint)\r\n    {\r\n        require(StandardToken(token).balanceOf(address(this)) >= value);\r\n        uint transactionId = addTransaction(token, destination, value, TransactionType.Token);\r\n        confirmTransaction(transactionId);\r\n        return transactionId;\r\n    }\r\n\r\n\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    transactionExists(transactionId)\r\n    notConfirmed(transactionId, msg.sender)\r\n    returns (bool)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId, now);\r\n        executeTransaction(transactionId);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId, now);\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i < owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]){\r\n                count += 1;\r\n            }\r\n            if (count == required){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n    public\r\n    notExecuted(transactionId)\r\n    returns(bool)\r\n    {\r\n        if (transactions[transactionId].transactionType == TransactionType.Standard\r\n        && isConfirmed(transactionId)\r\n        && this.balance >= transactions[transactionId].value) {\r\n            transactions[transactionId].executed = true;\r\n            transactions[transactionId].destination.transfer(transactions[transactionId].value);\r\n            Execution(transactionId, now);\r\n            return true;\r\n        } else if(transactions[transactionId].transactionType == TransactionType.Token\r\n        && isConfirmed(transactionId)\r\n        && StandardToken(transactions[transactionId].token).balanceOf(address(this)) >= transactions[transactionId].value) {\r\n            transactions[transactionId].executed = true;\r\n            StandardToken(transactions[transactionId].token).transfer(transactions[transactionId].destination, transactions[transactionId].value);\r\n            Execution(transactionId, now);\r\n            return true;\r\n        } else if(transactions[transactionId].transactionType == TransactionType.Unfreeze\r\n        && isConfirmed(transactionId)) {\r\n            transactions[transactionId].executed = true;\r\n            FreezableToken(transactions[transactionId].token).unfreeze();\r\n            Execution(transactionId, now);\r\n            return true;\r\n        } else if(transactions[transactionId].transactionType == TransactionType.PassOwnership\r\n        && isConfirmed(transactionId)) {\r\n            transactions[transactionId].executed = true;\r\n            Ownable(transactions[transactionId].token).transferOwnership(transactions[transactionId].destination);\r\n            Execution(transactionId, now);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether/token value.\r\n    /// @param transactionType Transaction type (Standard/token).\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address token, address destination, uint value, TransactionType transactionType)\r\n    internal\r\n    notNull(destination)\r\n    returns (uint)\r\n    {\r\n        uint transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            token: token,\r\n            value: value,\r\n            transactionType: transactionType,\r\n            executed: false\r\n            });\r\n\r\n        transactionCount += 1;\r\n        Submission(transactionId, token, 0x0, transactionType, now);\r\n        return transactionId;\r\n    }\r\n\r\n\r\n\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n    public\r\n    view\r\n    returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n    public\r\n    view\r\n    returns (uint founded)\r\n    {\r\n        for (uint i=0; i < transactionCount; i++) {\r\n            if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\r\n                founded += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Check balance of holding specific tokens\r\n    /// @param token address of token\r\n    /// @return balance of tokens\r\n    function tokenBalance(StandardToken token)\r\n    public\r\n    view\r\n    returns(uint)\r\n    {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n    public\r\n    view\r\n    returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n    public\r\n    view\r\n    returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count;\r\n        uint i;\r\n        for (i=0; i < transactionCount; i++){\r\n            if ((pending && !transactions[i].executed) ||\r\n                (executed && transactions[i].executed))\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count +=1;\r\n            }\r\n        }\r\n\r\n        if(to > count) {\r\n            to = count;\r\n        }\r\n\r\n        _transactionIds = new uint[](to - from);\r\n\r\n        for (i=from; i<to; i++) {\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n        }\r\n    }\r\n\r\n    function ownersConfirmedTransactions(address _owner)\r\n    public\r\n    view\r\n    ownerExists(msg.sender)\r\n    returns(uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n\r\n        for (i=0; i < transactionCount; i++){\r\n            if (confirmations[i][_owner]) {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        }\r\n\r\n        _transactionIds = new uint[](count);\r\n        for(i = 0; i< count; i++){\r\n            _transactionIds[i] = transactionIdsTemp[i];\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /// @dev Implementation of ERC223 receiver fallback function in order to protect\r\n    /// @dev sending tokens (standard ERC223) to smart tokens who doesn't except them\r\n    function tokenFallback(address /*_origin*/, uint /*_value*/, bytes /*_data*/) public returns (bool ok) {\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract SimpleTokenVesting is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for StandardToken;\r\n\r\n    event Released(uint256 amount, uint releaseDate);\r\n\r\n    // beneficiary of tokens after they are released\r\n    address public beneficiary;\r\n\r\n    uint256 public vestedDate;\r\n\r\n    mapping(address => uint256) public released;\r\n\r\n    modifier vested() {\r\n        require(now >= vestedDate);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n     * _beneficiary\r\n     * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n     * @param _vestedDate the period in which the tokens will vest\r\n     */\r\n    function SimpleTokenVesting(address _beneficiary, uint256 _vestedDate) public {\r\n        require(_beneficiary != address(0));\r\n        require(_vestedDate >= now);\r\n\r\n        beneficiary = _beneficiary;\r\n        vestedDate = _vestedDate;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers vested tokens to beneficiary.\r\n     * @param token ERC20 token which is being vested\r\n     */\r\n    function release(StandardToken token)\r\n    vested\r\n    public\r\n    {\r\n        uint256 unreleased = token.balanceOf(this);\r\n\r\n        require(unreleased > 0);\r\n\r\n        released[token] = released[token].add(unreleased);\r\n\r\n        token.safeTransfer(beneficiary, unreleased);\r\n\r\n        Released(unreleased, now);\r\n    }\r\n\r\n    /// @dev Implementation of ERC223 receiver fallback function in order to protect\r\n    /// @dev sending tokens (standard ERC223) to smart tokens who doesn't except them\r\n    function tokenFallback(address /*_origin*/, uint /*_value*/, bytes /*_data*/) pure public returns (bool ok) {\r\n        return true;\r\n    }\r\n\r\n}\r\ncontract VestedMultisigWallet is SimpleMultisigWallet {\r\n\r\n    //date till when multi-signature wallet will be vested\r\n    uint public vestedDate;\r\n\r\n\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required number of needed confirmation to proceed any action\r\n    /// @param _vestedDate date till when multisignature will be vested\r\n    function VestedMultisigWallet(address[] _owners, uint _required, uint _vestedDate)\r\n    SimpleMultisigWallet(_owners, _required)\r\n    public\r\n    {\r\n        vestedDate = _vestedDate;\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n    public\r\n    notExecuted(transactionId)\r\n    returns(bool)\r\n    {\r\n        if (transactions[transactionId].transactionType == TransactionType.Standard\r\n        && isConfirmed(transactionId)\r\n        && this.balance >= transactions[transactionId].value) {\r\n            transactions[transactionId].executed = true;\r\n            transactions[transactionId].destination.transfer(transactions[transactionId].value);\r\n            Execution(transactionId, now);\r\n            return true;\r\n        } else if(transactions[transactionId].transactionType == TransactionType.Token\r\n        && isConfirmed(transactionId)\r\n        && StandardToken(transactions[transactionId].token).balanceOf(address(this)) >= transactions[transactionId].value) {\r\n            require(now >= vestedDate);\r\n            transactions[transactionId].executed = true;\r\n            StandardToken(transactions[transactionId].token).transfer(transactions[transactionId].destination, transactions[transactionId].value);\r\n            Execution(transactionId, now);\r\n            return true;\r\n        } else if(transactions[transactionId].transactionType == TransactionType.Unfreeze\r\n        && isConfirmed(transactionId)) {\r\n            transactions[transactionId].executed = true;\r\n            FreezableToken(transactions[transactionId].token).unfreeze();\r\n            Execution(transactionId, now);\r\n            return true;\r\n        } else if(transactions[transactionId].transactionType == TransactionType.PassOwnership\r\n        && isConfirmed(transactionId)) {\r\n            transactions[transactionId].executed = true;\r\n            Ownable(transactions[transactionId].token).transferOwnership(transactions[transactionId].destination);\r\n            Execution(transactionId, now);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ownersConfirmedTransactions\",\"outputs\":[{\"name\":\"_transactionIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"submitTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionCount\",\"outputs\":[{\"name\":\"founded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestedDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmationCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"transactionType\",\"type\":\"uint8\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"},{\"name\":\"pending\",\"type\":\"bool\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"getTransactionIds\",\"outputs\":[{\"name\":\"_transactionIds\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"submitTokenTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getConfirmations\",\"outputs\":[{\"name\":\"_confirmations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transactionCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"},{\"name\":\"_vestedDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"createdOn\",\"type\":\"uint256\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"createdOn\",\"type\":\"uint256\"}],\"name\":\"Revocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"createdOn\",\"type\":\"uint256\"}],\"name\":\"Submission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"createdOn\",\"type\":\"uint256\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"createdOn\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"createdOn\",\"type\":\"uint256\"}],\"name\":\"OwnerAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"createdOn\",\"type\":\"uint256\"}],\"name\":\"OwnerRemoval\",\"type\":\"event\"}]","ContractName":"VestedMultisigWallet","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000005c538c0000000000000000000000000000000000000000000000000000000000000000050000000000000000000000001bfa1f19f60489606c03339f2ad747b23ffe01690000000000000000000000005291fd45420ae6a9fdf453cb8b58fb2da66da594000000000000000000000000bc901dae297c386767862bd932dac3bb8cf1648d0000000000000000000000005f6c3dbe0386b5c6631526532fada66ccd385f65000000000000000000000000bf1a99d6ab75d4a2f78e6cb6ebd346d8539267b6","Library":"","SwarmSource":"bzzr://03c53590b6c70015f64f3b41d0b2436b3495b2add8cd6614455431e536987caf"}]}