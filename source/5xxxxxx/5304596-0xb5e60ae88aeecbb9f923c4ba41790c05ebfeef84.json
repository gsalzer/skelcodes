{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n///address -> uint256 mapping.\r\nlibrary IterableMapping\r\n{\r\n    struct IndexValue { uint keyIndex; uint value; }\r\n    struct KeyFlag { address key; bool deleted; }\r\n    struct itmap\r\n    {\r\n        mapping(address => IndexValue) data;\r\n        KeyFlag[] keys;\r\n        uint size;\r\n    }\r\n\r\n    function insert(itmap storage self, address key, uint value) internal returns (bool replaced)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        self.data[key].value = value;\r\n        if (keyIndex > 0)\r\n            return true;\r\n        else\r\n        {\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex + 1;\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n    function remove(itmap storage self, address key) internal returns (bool success)\r\n    {\r\n        uint keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0)\r\n            return false;\r\n        delete self.data[key];\r\n        self.keys[keyIndex - 1].deleted = true;\r\n        self.size --;\r\n    }\r\n    function contains(itmap storage self, address key) internal returns (bool)\r\n    {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n    function iterate_start(itmap storage self) internal returns (uint keyIndex)\r\n    {\r\n        return iterate_next(self, uint(-1));\r\n    }\r\n    function iterate_valid(itmap storage self, uint keyIndex) internal returns (bool)\r\n    {\r\n        return keyIndex < self.keys.length;\r\n    }\r\n    function iterate_next(itmap storage self, uint keyIndex) internal returns (uint r_keyIndex)\r\n    {\r\n        keyIndex++;\r\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)\r\n            keyIndex++;\r\n        return keyIndex;\r\n    }\r\n    function iterate_get(itmap storage self, uint keyIndex) internal returns (address key, uint value)\r\n    {\r\n        key = self.keys[keyIndex].key;\r\n        value = self.data[key].value;\r\n    }\r\n}\r\n\r\n/**\r\n *Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint a, uint b) internal returns (uint){\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a ==b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal returns (uint) {\r\n        //assert(b > 0); //Solidity automatically throws when dividing by 0\r\n        uint c = a/b;\r\n        // assert(a == b * c + a% b); //There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal returns (uint) {\r\n        assert(b<=a);\r\n        return a-b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function assert(bool assertion) internal {\r\n        if(!assertion){\r\n            throw;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * title ERC20 Basic\r\n * dev Simpler version of ERC20 interface\r\n * dev see https://github.com/ethereum/EIPs/issues/20\r\n *\r\n */\r\ncontract ERC20Basic{\r\n    function balanceOf(address who) constant returns (uint);\r\n    function transfer(address to, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n\r\n/**\r\n * title Basic token\r\n * dev Basic version of StandardToken, eith no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint;\r\n    /**\r\n    * dev Fix for eht ERC20 short address attack.\r\n    */\r\n    modifier onlyPayloadSize(uint size) {\r\n        if(msg.data.length < size + 4){\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* title ERC20 interface\r\n* dev see https://github.com/ethereum/EIPs/issues/20\r\n*/\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n    function transferFrom(address from, address to, uint value);\r\n    function approve(address spender, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n/**\r\n* title Standard ERC20 token\r\n*\r\n* dev Implemantation of the basic standart token.\r\n* dev https://github.com/ethereum/EIPs/issues/20\r\n* dev Based on code by FirstBlood:http://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n**/\r\ncontract StandardToken is BasicToken, ERC20{\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    event Burn(address from, address to, uint value);\r\n    event TransferFrom(address from, uint value);\r\n    event Dividends(address from, address to, uint value);\r\n\r\n    /**\r\n    * dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\n    * param _spender The address which will spend the funds.\r\n    * param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint _value) {\r\n        //To change the approve amount you first have to reduce the addresses\r\n        // allowance to zero by calling approve(_spender, 0) if if it not\r\n        // already 0 to mitigate the race condition described here:\r\n        // https://github.com/ethereum/EIPs/issues/20#issuscomment-263524729\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n    }\r\n\r\n    /**\r\n    * dev Function to check the amount of token rhan an owner allowed to a spender.\r\n    * param _owner address Thr address whivh owns the funds.\r\n    * param _spender address The address which will spend the funds.\r\n    * return A uint specifing the amount of tokrns still avaible for the spender.\r\n    **/\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable(){\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        if(msg.sender != owner){\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n//    function transferOwnership(address newOwner) onlyOwner{\r\n//        if (newOwner != address(0)){\r\n//            owner = newOwner;\r\n//        }\r\n//    }\r\n}\r\n\r\ncontract GlobalCoin is Ownable, StandardToken{\r\n    uint256 public decimals = 8;\r\n    uint public totalSupply = 1000000000000000;//1后面15个0 ,发行1000，0000 ，后面是00000000,对应小数点后8个0\r\n    address public dividendAddress = 0x1D33776a090a2F321FF596C0C011F2f414f3A527;//分红地址\r\n    address public burnAddress = 0x0000000000000000000000000000000000000000; //销毁GBC地址\r\n    uint256 private globalShares = 0;\r\n    mapping (address => uint256) private balances;\r\n    mapping (address => uint256) private vips;\r\n    using IterableMapping for IterableMapping.itmap;\r\n    IterableMapping.itmap public data;\r\n    using SafeMath for uint256;\r\n\r\n    modifier noEth() {\r\n        if (msg.value < 0) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n    function() {\r\n        // 当有人发送eth或者Token，会触发这个事件\r\n        if (msg.value > 0)\r\n            TransferFrom(msg.sender, msg.value);\r\n    }\r\n\r\n    function insert(address k, uint v) internal returns (uint size)\r\n    {\r\n        IterableMapping.insert(data, k, v);\r\n        return data.size;\r\n    }\r\n        //预计分多少红\r\n    function expectedDividends(address user) constant returns (uint Dividends){\r\n        return balances[dividendAddress] / globalShares * vips[user];\r\n    }\r\n\r\n//    //显示有多少GBC\r\n    function balanceOf(address addr) constant returns (uint balance) {\r\n        return balances[addr];\r\n    }\r\n    //显示有多少股\r\n    function yourShares(address addr) constant returns (uint shares) {\r\n        return vips[addr];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) onlyPayloadSize(2 * 32)\r\n    {\r\n        if (to == burnAddress) {\r\n            return burn(amount);\r\n        }\r\n        balances[msg.sender] = balances[msg.sender].sub(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        Transfer(msg.sender, to, amount);\r\n    }\r\n    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n    //Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    // if (_value > _allowance) throw;\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n    }\r\n    function burn (uint256 amount) //获得分红\r\n    {\r\n        if (amount >= 100000000000) {\r\n            vips[msg.sender] += amount / 100000000000;\r\n            globalShares += amount / 100000000000;\r\n            insert(msg.sender, vips[msg.sender]);\r\n            balances[msg.sender] = balances[msg.sender].sub(amount);\r\n            balances[burnAddress] = balances[burnAddress].add(amount);\r\n            Burn(msg.sender, burnAddress, amount);\r\n        }\r\n    }\r\n\r\n\r\n    //查看全球一共多少股\r\n    function totalShares() constant returns (uint shares){\r\n        return globalShares;\r\n    }\r\n\r\n\r\n    //为每个股民发送分红\r\n    function distributeDividends() onlyOwner public noEth(){\r\n        for (var i = IterableMapping.iterate_start(data); IterableMapping.iterate_valid(data, i); i = IterableMapping.iterate_next(data, i))\r\n        {\r\n            var (key, value) = IterableMapping.iterate_get(data, i);\r\n            uint tmp = balances[dividendAddress] / globalShares * value;\r\n            balances[key] = balances[key].add(tmp);\r\n            Dividends(dividendAddress, key, tmp);\r\n        }\r\n        balances[dividendAddress] = balances[dividendAddress].sub(balances[dividendAddress] / globalShares * globalShares);\r\n    }\r\n\r\n    function GlobalCoin() onlyOwner {\r\n        balances[owner] = totalSupply;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"distributeDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"yourShares\",\"outputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"expectedDividends\",\"outputs\":[{\"name\":\"Dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Dividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"GlobalCoin","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9244872fbb4b0cf79d4f5afeffa440d4da40f21d9b6538de70b5bf989101a4d2"}]}