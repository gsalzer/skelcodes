{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n/**\r\n *  @title Smart City Token https://www.smartcitycoin.io\r\n *  @dev ERC20 standard compliant / https://github.com/ethereum/EIPs/issues/20 /\r\n *  @dev Amount not sold during Crowdsale is burned\r\n */\r\n\r\ncontract SmartCityToken {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;  // address of Token Owner\r\n    address public crowdsale; // address of Crowdsale contract\r\n\r\n    string constant public standard = \"ERC20\"; // token standard\r\n    string constant public name = \"Smart City\"; // token name\r\n    string constant public symbol = \"CITY\"; // token symbol\r\n\r\n    uint256 constant public decimals = 5; // 1 CITY = 100000 tokens\r\n    uint256 public totalSupply = 252862966307692; // total token provision\r\n\r\n    uint256 constant public amountForSale = 164360928100000; // amount that might be sold during ICO - 65% of total token supply\r\n    uint256 constant public amountReserved = 88502038207692; // amount reserved for founders / loyalty / bounties / etc. - 35% of total token supply\r\n    uint256 constant public amountLocked = 61951426745384; // the amount of tokens Owner cannot spend within first 2 years after Crowdsale - 70% of the reserved amount\r\n\r\n    uint256 public startTime; // from this time on transfer and transferFrom functions are available to anyone except of token Owner\r\n    uint256 public unlockOwnerDate; // from this time on transfer and transferFrom functions are available to token Owner\r\n\r\n    mapping(address => uint256) public balances; // balances array\r\n    mapping(address => mapping(address => uint256)) public allowances; // allowances array\r\n\r\n    bool public burned; // indicates whether excess tokens have already been burned\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value); // Transfer event\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value); // Approval event\r\n    event Burned(uint256 amount); // Burned event\r\n\r\n    modifier onlyPayloadSize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  @dev Contract initialization\r\n     *  @param _ownerAddress address Token owner address\r\n     *  @param _startTime uint256 Crowdsale end time\r\n     *\r\n     */\r\n    function SmartCityToken(address _ownerAddress, uint256 _startTime) public {\r\n        owner = _ownerAddress; // token Owner\r\n        startTime = _startTime; // token Start Time\r\n        unlockOwnerDate = startTime + 2 years;\r\n        balances[owner] = totalSupply; // all tokens are initially allocated to token owner\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers token for a specified address\r\n     * @param _to address The address to transfer to\r\n     * @param _value uint256 The amount to be transferred\r\n     */\r\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns(bool success) {\r\n        require(now >= startTime);\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        if (msg.sender == owner && now < unlockOwnerDate)\r\n            require(balances[msg.sender].sub(_value) >= amountLocked);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value); // subtract requested amount from the sender address\r\n        balances[_to] = balances[_to].add(_value); // send requested amount to the target address\r\n\r\n        //Transfer(msg.sender, _to, _value); // trigger Transfer event\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns(bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowances[_from][msg.sender]);\r\n\r\n        if (now < startTime)\r\n            require(_from == owner);\r\n\r\n        if (_from == owner && now < unlockOwnerDate)\r\n            require(balances[_from].sub(_value) >= amountLocked);\r\n\r\n        uint256 _allowance = allowances[_from][msg.sender];\r\n        balances[_from] = balances[_from].sub(_value); // subtract requested amount from the sender address\r\n        balances[_to] = balances[_to].add(_value); // send requested amount to the target address\r\n        allowances[_from][msg.sender] = _allowance.sub(_value); // reduce sender allowance by transferred amount\r\n\r\n        //Transfer(_from, _to, _value); // trigger Transfer event\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _addr address The address to query the balance of.\r\n     * @return uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _addr) public view returns (uint256 balance) {\r\n        return balances[_addr];\r\n    }\r\n\r\n    /**\r\n     *  @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *  @param _spender address The address which will spend the funds\r\n     *  @param _value uint256 The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) public returns(bool success) {\r\n        return _approve(_spender, _value);\r\n    }\r\n\r\n    /**\r\n     *  @dev Workaround for vulnerability described here: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM\r\n     */\r\n    function _approve(address _spender, uint256 _value) internal returns(bool success) {\r\n        require((_value == 0) || (allowances[msg.sender][_spender] == 0));\r\n\r\n        allowances[msg.sender][_spender] = _value; // Set spender allowance\r\n\r\n        Approval(msg.sender, _spender, _value); // Trigger Approval event\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     *  @dev Burns all the tokens which has not been sold during ICO\r\n     */\r\n    function burn() public {\r\n        if (!burned && now > startTime) {\r\n            uint256 diff = balances[owner].sub(amountReserved); // Get the amount of unsold tokens\r\n\r\n            balances[owner] = amountReserved;\r\n            totalSupply = totalSupply.sub(diff); // Reduce total provision number\r\n\r\n            burned = true;\r\n            Burned(diff); // Trigger Burned event\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Corwdsale contract address & allowance\r\n     *  @param _crowdsaleAddress address The address of the Crowdsale contract\r\n     */\r\n    function setCrowdsale(address _crowdsaleAddress) public {\r\n        require(msg.sender == owner);\r\n        require(crowdsale == address(0));\r\n\r\n        crowdsale = _crowdsaleAddress;\r\n        assert(_approve(crowdsale, amountForSale));\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n    /**\r\n    *            CITY 2.0 token by www.SmartCityCoin.io\r\n    * \r\n    *          .ossssss:                      `+sssss`      \r\n    *         ` +ssssss+` `.://++++++//:.`  .osssss+       \r\n    *            /sssssssssssssssssssssssss+ssssso`        \r\n    *             -sssssssssssssssssssssssssssss+`         \r\n    *            .+sssssssss+:--....--:/ossssssss+.        \r\n    *          `/ssssssssssso`         .sssssssssss/`      \r\n    *         .ossssss+sssssss-       :sssss+:ossssso.     \r\n    *        `ossssso. .ossssss:    `/sssss/  `/ssssss.    \r\n    *        ossssso`   `+ssssss+` .osssss:     /ssssss`   \r\n    *       :ssssss`      /sssssso:ssssso.       +o+/:-`   \r\n    *       osssss+        -sssssssssss+`                  \r\n    *       ssssss:         .ossssssss/                    \r\n    *       osssss/          `+ssssss-                     \r\n    *       /ssssso           :ssssss                      \r\n    *       .ssssss-          :ssssss                      \r\n    *        :ssssss-         :ssssss          `           \r\n    *         /ssssss/`       :ssssss        `/s+:`        \r\n    *          :sssssso:.     :ssssss      ./ssssss+`      \r\n    *           .+ssssssso/-.`:ssssss``.-/osssssss+.       \r\n    *             .+ssssssssssssssssssssssssssss+-         \r\n    *               `:+ssssssssssssssssssssss+:`           \r\n    *                  `.:+osssssssssssso+:.`              \r\n    *                        `/ssssss.`                    \r\n    *                         :ssssss                      \r\n    */","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"unlockOwnerDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"name\":\"setCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerAddress\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"}]","ContractName":"SmartCityToken","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001676ce8401236f40058dc93fabea4cb093f1686a000000000000000000000000000000000000000000000000000000005b43f700","Library":"","SwarmSource":"bzzr://4076ea134024ef37b2d79911dca46ecd0d396bf44062e99fdef3d1d27d65102f"}]}