{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n *\r\n * @dev Functionality in this library is largely implemented using an\r\n *      abstraction called a 'slice'. A slice represents a part of a string -\r\n *      anything from the entire string to a single character, or even no\r\n *      characters at all (a 0-length slice). Since a slice only has to specify\r\n *      an offset and a length, copying and manipulating slices is a lot less\r\n *      expensive than copying and manipulating the strings they reference.\r\n *\r\n *      To further reduce gas costs, most functions on slice that need to return\r\n *      a slice modify the original one instead of allocating a new one; for\r\n *      instance, `s.split(\".\")` will return the text up to the first '.',\r\n *      modifying s to only contain the remainder of the string after the '.'.\r\n *      In situations where you do not want to modify the original slice, you\r\n *      can make a copy first with `.copy()`, for example:\r\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\r\n *      Solidity has no memory management, it will result in allocating many\r\n *      short-lived slices that are later discarded.\r\n *\r\n *      Functions that return two slices come in two versions: a non-allocating\r\n *      version that takes the second slice as an argument, modifying it in\r\n *      place, and an allocating version that allocates and returns the second\r\n *      slice; see `nextRune` for example.\r\n *\r\n *      Functions that have to copy string data will return strings rather than\r\n *      slices; these can be cast back to slices for further processing if\r\n *      required.\r\n *\r\n *      For convenience, some functions are provided with non-modifying\r\n *      variants that create a new slice and return both; for instance,\r\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\r\n *      corresponding to the left and right parts of the string.\r\n */\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string self) internal returns (slice) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (self & 0xffffffffffffffff == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (self & 0xffffffff == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (self & 0xffff == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (self & 0xff == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-termintaed utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal returns (slice ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice self) internal returns (slice) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice self) internal returns (string) {\r\n        var ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice self) internal returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        var ptr = self._ptr - 31;\r\n        var end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice self) internal returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice self, slice other) internal returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        var selfptr = self._ptr;\r\n        var otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                var diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                    return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice self, slice other) internal returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice self, slice rune) internal returns (slice) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint len;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            len = 1;\r\n        } else if(b < 0xE0) {\r\n            len = 2;\r\n        } else if(b < 0xF0) {\r\n            len = 3;\r\n        } else {\r\n            len = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (len > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += len;\r\n        self._len -= len;\r\n        rune._len = len;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice self) internal returns (slice ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice self) internal returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        var b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice self) internal returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice self, slice needle) internal returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice self, slice needle) internal returns (slice) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice self, slice needle) internal returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        var selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice self, slice needle) internal returns (slice) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        var selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\r\n        uint ptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                // Optimized assembly for 68 gas per byte on short strings\r\n                assembly {\r\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\r\n                    let needledata := and(mload(needleptr), mask)\r\n                    let end := add(selfptr, sub(selflen, needlelen))\r\n                    ptr := selfptr\r\n                    loop:\r\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\r\n                    ptr := add(ptr, 1)\r\n                    jumpi(loop, lt(sub(ptr, 1), end))\r\n                    ptr := add(selfptr, selflen)\r\n                    exit:\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := sha3(needleptr, needlelen) }\r\n                ptr = selfptr;\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := sha3(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                // Optimized assembly for 69 gas per byte on short strings\r\n                assembly {\r\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\r\n                    let needledata := and(mload(needleptr), mask)\r\n                    ptr := add(selfptr, sub(selflen, needlelen))\r\n                    loop:\r\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\r\n                    ptr := sub(ptr, 1)\r\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\r\n                    ptr := selfptr\r\n                    jump(exit)\r\n                    ret:\r\n                    ptr := add(ptr, needlelen)\r\n                    exit:\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := sha3(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := sha3(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice self, slice needle) internal returns (slice) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice self, slice needle) internal returns (slice) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice self, slice needle, slice token) internal returns (slice) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice self, slice needle) internal returns (slice token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice self, slice needle, slice token) internal returns (slice) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice self, slice needle) internal returns (slice token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice self, slice needle) internal returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice self, slice needle) internal returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice self, slice other) internal returns (string) {\r\n        var ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice self, slice[] parts) internal returns (string) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for (uint i = 0; i < parts.length; i++) {\r\n            length += parts[i]._len;\r\n        }\r\n\r\n        var ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n *      See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n    * @dev give an address access to this role\r\n    */\r\n    function add(Role storage role, address addr) internal {\r\n        role.bearer[addr] = true;\r\n    }\r\n\r\n    /**\r\n    * @dev remove an address' access to this role\r\n    */\r\n    function remove(Role storage role, address addr) internal {\r\n        role.bearer[addr] = false;\r\n    }\r\n\r\n    /**\r\n    * @dev check if an address has this role\r\n    * // reverts\r\n    */\r\n    function check(Role storage role, address addr) view internal {\r\n        require(has(role, addr));\r\n    }\r\n\r\n    /**\r\n    * @dev check if an address has this role\r\n    * @return bool\r\n    */\r\n    function has(Role storage role, address addr) view internal returns (bool) {\r\n        return role.bearer[addr];\r\n    }\r\n}\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n *      Supports unlimited numbers of roles and addresses.\r\n *      See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n *  for you to write your own implementation of this interface using Enums or similar.\r\n * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\r\n *  to avoid typos.\r\n */\r\ncontract RBAC is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    mapping (string => Roles.Role) private roles;\r\n\r\n    event RoleAdded(address addr, string roleName);\r\n    event RoleRemoved(address addr, string roleName);\r\n\r\n    /**\r\n    * @dev constructor. Sets msg.sender as admin by default\r\n    */\r\n    function RBAC() public {\r\n    }\r\n\r\n    /**\r\n    * @dev reverts if addr does not have role\r\n    * @param addr address\r\n    * @param roleName the name of the role\r\n    * // reverts\r\n    */\r\n    function checkRole(address addr, string roleName) view public {\r\n        roles[roleName].check(addr);\r\n    }\r\n\r\n    /**\r\n    * @dev determine if addr has role\r\n    * @param addr address\r\n    * @param roleName the name of the role\r\n    * @return bool\r\n    */\r\n    function hasRole(address addr, string roleName) view public returns (bool) {\r\n        return roles[roleName].has(addr);\r\n    }\r\n\r\n    /**\r\n    * @dev add a role to an address\r\n    * @param addr address\r\n    * @param roleName the name of the role\r\n    */\r\n    function adminAddRole(address addr, string roleName) onlyOwner public {\r\n        roles[roleName].add(addr);\r\n        RoleAdded(addr, roleName);\r\n    }\r\n\r\n    /**\r\n    * @dev remove a role from an address\r\n    * @param addr address\r\n    * @param roleName the name of the role\r\n    */\r\n    function adminRemoveRole(address addr, string roleName) onlyOwner public {\r\n        roles[roleName].remove(addr);\r\n        RoleRemoved(addr, roleName);\r\n    }\r\n\r\n    /**\r\n    * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n    * @param roleName the name of the role\r\n    * // reverts\r\n    */\r\n    modifier onlyRole(string roleName) {\r\n        checkRole(msg.sender, roleName);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOr(string roleName) {\r\n        require(msg.sender == owner || roles[roleName].has(msg.sender));\r\n        _;\r\n    }    \r\n}\r\n\r\n/**\r\n * @title Heritable\r\n * @dev The Heritable contract provides ownership transfer capabilities, in the\r\n * case that the current owner stops \"heartbeating\". Only the heir can pronounce the\r\n * owner's death.\r\n */\r\ncontract Heritable is RBAC {\r\n  address private heir_;\r\n\r\n  // Time window the owner has to notify they are alive.\r\n  uint256 private heartbeatTimeout_;\r\n\r\n  // Timestamp of the owner's death, as pronounced by the heir.\r\n  uint256 private timeOfDeath_;\r\n\r\n  event HeirChanged(address indexed owner, address indexed newHeir);\r\n  event OwnerHeartbeated(address indexed owner);\r\n  event OwnerProclaimedDead(address indexed owner, address indexed heir, uint256 timeOfDeath);\r\n  event HeirOwnershipClaimed(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev Throw an exception if called by any account other than the heir's.\r\n   */\r\n  modifier onlyHeir() {\r\n    require(msg.sender == heir_);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Create a new Heritable Contract with heir address 0x0.\r\n   * @param _heartbeatTimeout time available for the owner to notify they are alive,\r\n   * before the heir can take ownership.\r\n   */\r\n  function Heritable(uint256 _heartbeatTimeout) public {\r\n    setHeartbeatTimeout(_heartbeatTimeout);\r\n  }\r\n\r\n  function setHeir(address newHeir) public onlyOwner {\r\n    require(newHeir != owner);\r\n    heartbeat();\r\n    HeirChanged(owner, newHeir);\r\n    heir_ = newHeir;\r\n  }\r\n\r\n  /**\r\n   * @dev Use these getter functions to access the internal variables in\r\n   * an inherited contract.\r\n   */\r\n  function heir() public view returns(address) {\r\n    return heir_;\r\n  }\r\n\r\n  function heartbeatTimeout() public view returns(uint256) {\r\n    return heartbeatTimeout_;\r\n  }\r\n  \r\n  function timeOfDeath() public view returns(uint256) {\r\n    return timeOfDeath_;\r\n  }\r\n\r\n  /**\r\n   * @dev set heir = 0x0\r\n   */\r\n  function removeHeir() public onlyOwner {\r\n    heartbeat();\r\n    heir_ = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Heir can pronounce the owners death. To claim the ownership, they will\r\n   * have to wait for `heartbeatTimeout` seconds.\r\n   */\r\n  function proclaimDeath() public onlyHeir {\r\n    require(ownerLives());\r\n    OwnerProclaimedDead(owner, heir_, timeOfDeath_);\r\n    timeOfDeath_ = block.timestamp;\r\n  }\r\n\r\n  /**\r\n   * @dev Owner can send a heartbeat if they were mistakenly pronounced dead.\r\n   */\r\n  function heartbeat() public onlyOwner {\r\n    OwnerHeartbeated(owner);\r\n    timeOfDeath_ = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows heir to transfer ownership only if heartbeat has timed out.\r\n   */\r\n  function claimHeirOwnership() public onlyHeir {\r\n    require(!ownerLives());\r\n    require(block.timestamp >= timeOfDeath_ + heartbeatTimeout_);\r\n    OwnershipTransferred(owner, heir_);\r\n    HeirOwnershipClaimed(owner, heir_);\r\n    owner = heir_;\r\n    timeOfDeath_ = 0;\r\n  }\r\n\r\n  function setHeartbeatTimeout(uint256 newHeartbeatTimeout) internal onlyOwner {\r\n    require(ownerLives());\r\n    heartbeatTimeout_ = newHeartbeatTimeout;\r\n  }\r\n\r\n  function ownerLives() internal view returns (bool) {\r\n    return timeOfDeath_ == 0;\r\n  }\r\n}\r\n\r\ncontract BettingBase {\r\n    enum BetStatus {\r\n        None,\r\n        Won\r\n    }\r\n\r\n    enum LineStages {\r\n        OpenedUntilStart,\r\n        ResultSubmitted,\r\n        Cancelled,\r\n        Refunded,\r\n        Paid\r\n    }    \r\n\r\n    enum LineType {\r\n        ThreeWay,\r\n        TwoWay,\r\n        DoubleChance,\r\n        SomeOfMany\r\n    }\r\n\r\n    enum TwoWayLineType {\r\n        Standart,\r\n        YesNo,\r\n        OverUnder,\r\n        AsianHandicap,\r\n        HeadToHead\r\n    }\r\n\r\n    enum PaymentType {\r\n        No,\r\n        Gain, \r\n        Refund\r\n    }\r\n}\r\n\r\ncontract AbstractBetStorage is BettingBase {\r\n    function addBet(uint lineId, uint betId, address player, uint amount) external;\r\n    function addLine(uint lineId, LineType lineType, uint start, uint resultCount) external;\r\n    function cancelLine(uint lineId) external;\r\n    function getBetPool(uint lineId, uint betId) external view returns (BetStatus status, uint sum);\r\n    function getLineData(uint lineId) external view returns (uint startTime, uint resultCount, LineType lineType, LineStages stage);\r\n    function getLineData2(uint lineId) external view returns (uint resultCount, LineStages stage);\r\n    function getLineSum(uint lineId) external view returns (uint sum);\r\n    function getPlayerBet(uint lineId, uint betId, address player) external view returns (uint result);\r\n    function getSumOfPlayerBetsById(uint lineId, uint playerId, PaymentType paymentType) external view returns (address player, uint amount);\r\n    function isBetStorage() external pure returns (bool);\r\n    function setLineStartTime(uint lineId, uint time) external;    \r\n    function startPayments(uint lineId, uint chunkSize) external returns (PaymentType paymentType, uint startId, uint endId, uint luckyPool, uint unluckyPool);\r\n    function submitResult(uint lineId, uint[] results) external;\r\n    function transferOwnership(address newOwner) public;\r\n    function tryCloseLine(uint lineId, uint lastPlayerId, PaymentType paymentType) external returns (bool lineClosed);\r\n}\r\n\r\ncontract BettingCore is BettingBase, Heritable {\r\n    using SafeMath for uint;\r\n    using strings for *;\r\n\r\n    enum ActivityType{\r\n        Soccer,\r\n        IceHockey,\r\n        Basketball,\r\n        Tennis,\r\n        BoxingAndMMA, \r\n        Formula1,               \r\n        Volleyball,\r\n        Chess,\r\n        Athletics,\r\n        Biathlon,\r\n        Baseball,\r\n        Rugby,\r\n        AmericanFootball,\r\n        Cycling,\r\n        AutoMotorSports,        \r\n        Other\r\n    }    \r\n    \r\n    struct Activity {\r\n        string title;\r\n        ActivityType activityType;\r\n    }\r\n\r\n    struct Event {\r\n        uint activityId;\r\n        string title;\r\n    }    \r\n\r\n    struct Line {\r\n        uint eventId;\r\n        string title;\r\n        string outcomes;\r\n    }\r\n\r\n    struct FeeDiscount {\r\n        uint64 till;\r\n        uint8 discount;\r\n    }    \r\n\r\n    // it's not possible to take off players bets\r\n    bool public payoutToOwnerIsLimited;\r\n    // total sum of bets\r\n    uint public blockedSum; \r\n    uint public fee;\r\n    uint public minBetAmount;\r\n    string public contractMessage;\r\n   \r\n    Activity[] public activities;\r\n    Event[] public events;\r\n    Line[] private lines;\r\n\r\n    mapping(address => FeeDiscount) private discounts;\r\n\r\n    event NewActivity(uint indexed activityId, ActivityType activityType, string title);\r\n    event NewEvent(uint indexed activityId, uint indexed eventId, string title);\r\n    event NewLine(uint indexed eventId, uint indexed lineId, string title, LineType lineType, uint start, string outcomes);     \r\n    event BetMade(uint indexed lineId, uint betId, address indexed player, uint amount);\r\n    event PlayerPaid(uint indexed lineId, address indexed player, uint amount);\r\n    event ResultSubmitted(uint indexed lineId, uint[] results);\r\n    event LineCanceled(uint indexed lineId, string comment);\r\n    event LineClosed(uint indexed lineId, PaymentType paymentType, uint totalPool);\r\n    event LineStartTimeChanged(uint indexed lineId, uint newTime);\r\n\r\n    AbstractBetStorage private betStorage;\r\n\r\n    function BettingCore() Heritable(2592000) public {\r\n        minBetAmount = 5 finney; // 0.005 ETH\r\n        fee = 200; // 2 %\r\n        payoutToOwnerIsLimited = true;\r\n        blockedSum = 1 wei;\r\n        contractMessage = \"betdapp.co\";\r\n    }\r\n\r\n    function() external onlyOwner payable {\r\n    }\r\n\r\n    function addActivity(ActivityType activityType, string title) external onlyOwnerOr(\"Edit\") returns (uint activityId) {\r\n        Activity memory _activity = Activity({\r\n            title: title, \r\n            activityType: activityType\r\n        });\r\n\r\n        activityId = activities.push(_activity) - 1;\r\n        NewActivity(activityId, activityType, title);\r\n    }\r\n\r\n    function addDoubleChanceLine(uint eventId, string title, uint start) external onlyOwnerOr(\"Edit\") {\r\n        addLine(eventId, title, LineType.DoubleChance, start, \"1X_12_X2\");\r\n    }\r\n\r\n    function addEvent(uint activityId, string title) external onlyOwnerOr(\"Edit\") returns (uint eventId) {\r\n        Event memory _event = Event({\r\n            activityId: activityId, \r\n            title: title\r\n        });\r\n\r\n        eventId = events.push(_event) - 1;\r\n        NewEvent(activityId, eventId, title);      \r\n    }\r\n\r\n    function addThreeWayLine(uint eventId, string title, uint start) external onlyOwnerOr(\"Edit\") {\r\n        addLine(eventId, title, LineType.ThreeWay, start,  \"1_X_2\");\r\n    }\r\n\r\n    function addSomeOfManyLine(uint eventId, string title, uint start, string outcomes) external onlyOwnerOr(\"Edit\") {\r\n        addLine(eventId, title, LineType.SomeOfMany, start, outcomes);\r\n    }\r\n\r\n    function addTwoWayLine(uint eventId, string title, uint start, TwoWayLineType customType) external onlyOwnerOr(\"Edit\") {\r\n        string memory outcomes;\r\n\r\n        if (customType == TwoWayLineType.YesNo) {\r\n            outcomes = \"Yes_No\";\r\n        } else if (customType == TwoWayLineType.OverUnder) {\r\n            outcomes = \"Over_Under\";\r\n        } else {\r\n            outcomes = \"1_2\";\r\n        }\r\n        \r\n        addLine(eventId, title, LineType.TwoWay, start, outcomes);\r\n    }\r\n\r\n    function bet(uint lineId, uint betId) external payable {\r\n        uint amount = msg.value;\r\n        require(amount >= minBetAmount);\r\n        address player = msg.sender;\r\n        betStorage.addBet(lineId, betId, player, amount);\r\n        blockedSum = blockedSum.add(amount);\r\n        BetMade(lineId, betId, player, amount);\r\n    }\r\n\r\n    function cancelLine(uint lineId, string comment) external onlyOwnerOr(\"Submit\") {\r\n        betStorage.cancelLine(lineId);\r\n        LineCanceled(lineId, comment);\r\n    }   \r\n\r\n    function getMyBets(uint lineId) external view returns (uint[] result) {\r\n        return getPlayerBets(lineId, msg.sender);\r\n    }\r\n\r\n    function getMyDiscount() external view returns (uint discount, uint till) {\r\n        (discount, till) = getPlayerDiscount(msg.sender);\r\n    }\r\n\r\n    function getLineData(uint lineId) external view returns (uint eventId, string title, string outcomes, uint startTime, uint resultCount, LineType lineType, LineStages stage, BetStatus[] status, uint[] pool) {\r\n        (startTime, resultCount, lineType, stage) = betStorage.getLineData(lineId);\r\n\r\n        Line storage line = lines[lineId];\r\n        eventId = line.eventId;\r\n        title = line.title;\r\n        outcomes = line.outcomes;\r\n        status = new BetStatus[](resultCount);\r\n        pool = new uint[](resultCount);\r\n\r\n        for (uint i = 0; i < resultCount; i++) {\r\n            (status[i], pool[i]) = betStorage.getBetPool(lineId, i);\r\n        }\r\n    }\r\n\r\n    function getLineStat(uint lineId) external view returns (LineStages stage, BetStatus[] status, uint[] pool) {       \r\n        uint resultCount;\r\n        (resultCount, stage) = betStorage.getLineData2(lineId);\r\n        status = new BetStatus[](resultCount);\r\n        pool = new uint[](resultCount);\r\n\r\n        for (uint i = 0; i < resultCount; i++) {\r\n            (status[i], pool[i]) = betStorage.getBetPool(lineId, i);\r\n        }\r\n    }\r\n\r\n    // emergency\r\n    function kill() external onlyOwner {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    function payout(uint sum) external onlyOwner {\r\n        require(sum > 0);\r\n        require(!payoutToOwnerIsLimited || (this.balance - blockedSum) >= sum);\r\n        msg.sender.transfer(sum);\r\n    }    \r\n\r\n    function payPlayers(uint lineId, uint chunkSize) external onlyOwnerOr(\"Pay\") {\r\n        uint startId;\r\n        uint endId;\r\n        PaymentType paymentType;\r\n        uint luckyPool;\r\n        uint unluckyPool;\r\n\r\n        (paymentType, startId, endId, luckyPool, unluckyPool) = betStorage.startPayments(lineId, chunkSize);\r\n\r\n        for (uint i = startId; i < endId; i++) {\r\n            address player;\r\n            uint amount; \r\n            (player, amount) = betStorage.getSumOfPlayerBetsById(lineId, i, paymentType);\r\n\r\n            if (amount == 0) {\r\n                continue;\r\n            }\r\n\r\n            uint payment;            \r\n            \r\n            if (paymentType == PaymentType.Gain) {\r\n                payment = amount.add(amount.mul(unluckyPool).div(luckyPool)).div(10000).mul(10000 - getFee(player));\r\n\r\n                if (payment < amount) {\r\n                    payment = amount;\r\n                }\r\n            } else {\r\n                payment = amount;               \r\n            }\r\n\r\n            if (payment > 0) {\r\n                player.transfer(payment);\r\n                PlayerPaid(lineId, player, payment);\r\n            }\r\n        }\r\n\r\n        if (betStorage.tryCloseLine(lineId, endId, paymentType)) {\r\n            uint totalPool = betStorage.getLineSum(lineId);\r\n            blockedSum = blockedSum.sub(totalPool);\r\n            LineClosed(lineId, paymentType, totalPool);\r\n        }\r\n    }\r\n    \r\n    function setContractMessage(string value) external onlyOwner {\r\n        contractMessage = value;\r\n    }    \r\n\r\n    function setDiscountForPlayer(address player, uint discount, uint till) external onlyOwner {\r\n        require(till > now && discount > 0 && discount <= 100);\r\n        discounts[player].till = uint64(till);\r\n        discounts[player].discount = uint8(discount);\r\n    }\r\n\r\n    function setFee(uint value) external onlyOwner {\r\n        // 100 = 1% fee;\r\n        require(value >= 0 && value <= 500);\r\n        fee = value;\r\n    }\r\n\r\n    function setLineStartTime(uint lineId, uint time) external onlyOwnerOr(\"Edit\") {\r\n        betStorage.setLineStartTime(lineId, time);\r\n        LineStartTimeChanged(lineId, time);\r\n    }    \r\n\r\n    function setMinBetAmount(uint value) external onlyOwner {\r\n        require(value > 0);\r\n        minBetAmount = value;\r\n    }\r\n\r\n    // if something goes wrong with contract, we can turn on this function\r\n    // and then withdraw balance and pay players by hand without need to kill contract\r\n    function setPayoutLimit(bool value) external onlyOwner {\r\n        payoutToOwnerIsLimited = value;\r\n    }\r\n\r\n    function setStorage(address contractAddress) external onlyOwner {        \r\n        AbstractBetStorage candidateContract = AbstractBetStorage(contractAddress);\r\n        require(candidateContract.isBetStorage());\r\n        betStorage = candidateContract;\r\n        // betStorage.transferOwnership(address(this));\r\n    }\r\n\r\n    function setStorageOwner(address newOwner) external onlyOwner {\r\n        betStorage.transferOwnership(newOwner);\r\n    }    \r\n\r\n    function submitResult(uint lineId, uint[] results) external onlyOwnerOr(\"Submit\") {\r\n        betStorage.submitResult(lineId, results);\r\n        ResultSubmitted(lineId, results);\r\n    }    \r\n\r\n    function addLine(uint eventId, string title, LineType lineType, uint start, string outcomes) private {\r\n        require(start > now);\r\n\r\n        Line memory line = Line({\r\n            eventId: eventId, \r\n            title: title, \r\n            outcomes: outcomes\r\n        });\r\n\r\n        uint lineId = lines.push(line) - 1;\r\n        uint resultCount;\r\n\r\n        if (lineType == LineType.ThreeWay || lineType == LineType.DoubleChance) {\r\n            resultCount = 3;           \r\n        } else if (lineType == LineType.TwoWay) {\r\n            resultCount = 2; \r\n        } else {\r\n            resultCount = getSplitCount(outcomes);\r\n        }       \r\n\r\n        betStorage.addLine(lineId, lineType, start, resultCount);\r\n        NewLine(eventId, lineId, title, lineType, start, outcomes);\r\n    }\r\n\r\n    function getFee(address player) private view returns (uint newFee) {\r\n        var data = discounts[player];\r\n\r\n        if (data.till > now) {\r\n            return fee * (100 - data.discount) / 100;\r\n        }\r\n\r\n        return fee;\r\n    }    \r\n\r\n    function getPlayerBets(uint lineId, address player) private view returns (uint[] result) {\r\n        Line storage line = lines[lineId];\r\n        uint count = getSplitCount(line.outcomes);\r\n        result = new uint[](count);\r\n\r\n        for (uint i = 0; i < count; i++) {\r\n            result[i] = betStorage.getPlayerBet(lineId, i, player);\r\n        }\r\n    }\r\n\r\n    function getPlayerDiscount(address player) private view returns (uint discount, uint till) {\r\n        FeeDiscount storage discountFee = discounts[player];\r\n        discount = discountFee.discount;\r\n        till = discountFee.till;\r\n    }    \r\n\r\n    function getSplitCount(string input) private returns (uint) { \r\n        var s = input.toSlice();\r\n        var delim = \"_\".toSlice();\r\n        var parts = new string[](s.count(delim) + 1);\r\n\r\n        for (uint i = 0; i < parts.length; i++) {\r\n            parts[i] = s.split(delim).toString();\r\n        }\r\n\r\n        return parts.length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"events\",\"outputs\":[{\"name\":\"activityId\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setContractMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activities\",\"outputs\":[{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"activityType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"outcomes\",\"type\":\"string\"}],\"name\":\"addSomeOfManyLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lineId\",\"type\":\"uint256\"},{\"name\":\"chunkSize\",\"type\":\"uint256\"}],\"name\":\"payPlayers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimHeirOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setStorageOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHeir\",\"type\":\"address\"}],\"name\":\"setHeir\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"proclaimDeath\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"addDoubleChanceLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setPayoutLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"heartbeat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lineId\",\"type\":\"uint256\"}],\"name\":\"getLineData\",\"outputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"outcomes\",\"type\":\"string\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"resultCount\",\"type\":\"uint256\"},{\"name\":\"lineType\",\"type\":\"uint8\"},{\"name\":\"stage\",\"type\":\"uint8\"},{\"name\":\"status\",\"type\":\"uint8[]\"},{\"name\":\"pool\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractMessage\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinBetAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lineId\",\"type\":\"uint256\"},{\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lineId\",\"type\":\"uint256\"}],\"name\":\"getMyBets\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lineId\",\"type\":\"uint256\"}],\"name\":\"getLineStat\",\"outputs\":[{\"name\":\"stage\",\"type\":\"uint8\"},{\"name\":\"status\",\"type\":\"uint8[]\"},{\"name\":\"pool\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heartbeatTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lineId\",\"type\":\"uint256\"},{\"name\":\"comment\",\"type\":\"string\"}],\"name\":\"cancelLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"discount\",\"type\":\"uint256\"},{\"name\":\"till\",\"type\":\"uint256\"}],\"name\":\"setDiscountForPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutToOwnerIsLimited\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminRemoveRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heir\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"addThreeWayLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"activityType\",\"type\":\"uint8\"},{\"name\":\"title\",\"type\":\"string\"}],\"name\":\"addActivity\",\"outputs\":[{\"name\":\"activityId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lineId\",\"type\":\"uint256\"},{\"name\":\"results\",\"type\":\"uint256[]\"}],\"name\":\"submitResult\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"adminAddRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeOfDeath\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockedSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"lineId\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setLineStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sum\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyDiscount\",\"outputs\":[{\"name\":\"discount\",\"type\":\"uint256\"},{\"name\":\"till\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"customType\",\"type\":\"uint8\"}],\"name\":\"addTwoWayLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeHeir\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBetAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"activityId\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"}],\"name\":\"addEvent\",\"outputs\":[{\"name\":\"eventId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"activityId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"activityType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"title\",\"type\":\"string\"}],\"name\":\"NewActivity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"activityId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"title\",\"type\":\"string\"}],\"name\":\"NewEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"eventId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"lineId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"title\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"lineType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"outcomes\",\"type\":\"string\"}],\"name\":\"NewLine\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lineId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BetMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lineId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlayerPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lineId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"results\",\"type\":\"uint256[]\"}],\"name\":\"ResultSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lineId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"comment\",\"type\":\"string\"}],\"name\":\"LineCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lineId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"totalPool\",\"type\":\"uint256\"}],\"name\":\"LineClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lineId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"LineStartTimeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newHeir\",\"type\":\"address\"}],\"name\":\"HeirChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerHeartbeated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"heir\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeOfDeath\",\"type\":\"uint256\"}],\"name\":\"OwnerProclaimedDead\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"HeirOwnershipClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BettingCore","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a20365ebebe84e9c79b5605c4c6693a6a607bc7f4293f6081e59ccc74b0b6897"}]}