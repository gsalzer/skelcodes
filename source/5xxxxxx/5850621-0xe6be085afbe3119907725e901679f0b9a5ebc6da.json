{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface token {\r\n    function mint(address _to, uint256 _amount) public returns (bool);     \r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n    function transferOwnership(address newOwner) public;\r\n    \r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n */\r\ncontract Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    // The token being sold\r\n    token public tokenReward;\r\n\r\n    // start and end timestamps where investments are allowed (both inclusive)\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    // address where funds are collected\r\n    address public wallet;\r\n\r\n    // how many token units a buyer gets per wei\r\n    uint256 public rate;\r\n\r\n    // amount of raised money in wei\r\n    uint256 public weiRaised;\r\n\r\n    /**\r\n    * event for token purchase logging\r\n    * @param purchaser who paid for the tokens\r\n    * @param beneficiary who got the tokens\r\n    * @param value weis paid for purchase\r\n    * @param amount amount of tokens purchased\r\n    */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\r\n    function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, address _token) public {\r\n        //require(_startTime >= now);\r\n        require(_endTime >= _startTime);\r\n        require(_rate > 0);\r\n        require(_wallet != address(0));\r\n\r\n        // token = createTokenContract();\r\n        tokenReward = token(_token);\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        rate = _rate;\r\n        wallet = _wallet;\r\n    }\r\n\r\n    // creates the token to be sold.\r\n    // override this method to have crowdsale of a specific mintable token.\r\n    // function createTokenContract() internal returns (MintableToken) {\r\n    //     return new MintableToken();\r\n    // }\r\n\r\n    // send ether to the fund collection wallet\r\n    // override to create custom fund forwarding mechanisms\r\n    function forwardFunds() internal {\r\n        wallet.transfer(msg.value);\r\n    }\r\n\r\n    // @return true if the transaction can buy tokens\r\n    function validPurchase() internal view returns (bool) {\r\n        bool withinPeriod = now >= startTime && now <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        return withinPeriod && nonZeroPurchase;\r\n    }\r\n\r\n    // @return true if crowdsale event has ended\r\n    function hasEnded() public view returns (bool) {\r\n        return now > endTime;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title RefundVault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\n * and forwarding it if crowdsale is successful.\r\n */\r\ncontract RefundVault is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    enum State { Active, Refunding, Closed }\r\n\r\n    mapping (address => uint256) public deposited;\r\n    address public wallet;\r\n    State public state;\r\n\r\n    event Closed();\r\n    event RefundsEnabled();\r\n    event Refunded(address indexed beneficiary, uint256 weiAmount);\r\n\r\n    function RefundVault(address _wallet) public {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;\r\n        state = State.Active;\r\n    }\r\n\r\n    function deposit(address investor) onlyOwner public payable {\r\n        require(state == State.Active);\r\n        deposited[investor] = deposited[investor].add(msg.value);\r\n    }\r\n\r\n    function close() onlyOwner public {\r\n        require(state == State.Active);\r\n        state = State.Closed;\r\n        emit Closed();\r\n        wallet.transfer(this.balance);\r\n    }\r\n\r\n    function enableRefunds() onlyOwner public {\r\n        require(state == State.Active);\r\n        state = State.Refunding;\r\n        emit RefundsEnabled();\r\n    }\r\n\r\n    function refund(address investor) public {\r\n        require(state == State.Refunding);\r\n        uint256 depositedValue = deposited[investor];\r\n        deposited[investor] = 0;\r\n        investor.transfer(depositedValue);\r\n        emit Refunded(investor, depositedValue);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of Crowdsale where an owner can do extra work\r\n * after finishing.\r\n */\r\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    bool public isFinalized = false;\r\n\r\n    event Finalized();\r\n\r\n    /**\r\n    * @dev Must be called after crowdsale ends, to do some extra finalization\r\n    * work. Calls the contract's finalization function.\r\n    */\r\n    function finalize() onlyOwner public {\r\n        require(!isFinalized);\r\n        require(hasEnded());\r\n\r\n        finalization();\r\n        emit Finalized();\r\n\r\n        isFinalized = true;\r\n    }\r\n\r\n  /**\r\n   * @dev Can be overridden to add finalization logic. The overriding function\r\n   * should call super.finalization() to ensure the chain of finalization is\r\n   * executed entirely.\r\n   */\r\n    function finalization() internal {\r\n    }\r\n}\r\n/**\r\n * @title RefundableCrowdsale\r\n * @dev Extension of Crowdsale contract that adds a funding goal, and\r\n * the possibility of users getting a refund if goal is not met.\r\n * Uses a RefundVault as the crowdsale's vault.\r\n */\r\ncontract RefundableCrowdsale is FinalizableCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    // minimum amount of funds to be raised in weis\r\n    uint256 public goal;\r\n\r\n    // refund vault used to hold funds while crowdsale is running\r\n    RefundVault public vault;\r\n\r\n    function RefundableCrowdsale(uint256 _goal) public {\r\n        require(_goal > 0);\r\n        vault = new RefundVault(wallet);\r\n        goal = _goal;\r\n    }\r\n\r\n    // We're overriding the fund forwarding from Crowdsale.\r\n    // In addition to sending the funds, we want to call\r\n    // the RefundVault deposit function\r\n    function forwardFunds() internal {\r\n        vault.deposit.value(msg.value)(msg.sender);\r\n    }\r\n\r\n    // if crowdsale is unsuccessful, investors can claim refunds here\r\n    function claimRefund() public {\r\n        require(isFinalized);\r\n        require(!goalReached());\r\n\r\n        vault.refund(msg.sender);\r\n    }\r\n\r\n    // vault finalization task, called when owner calls finalize()\r\n    function finalization() internal {\r\n        if (!goalReached()) {\r\n            vault.enableRefunds(); \r\n        } \r\n\r\n        super.finalization();\r\n    }\r\n\r\n    function goalReached() public view returns (bool) {\r\n        return weiRaised >= goal;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title CappedCrowdsale\r\n * @dev Extension of Crowdsale with a max amount of funds raised\r\n */\r\ncontract CappedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public cap;\r\n\r\n    function CappedCrowdsale(uint256 _cap) public {\r\n        require(_cap > 0);\r\n        cap = _cap;\r\n    }\r\n\r\n\r\n    // overriding Crowdsale#hasEnded to add cap logic\r\n    // @return true if crowdsale event has ended\r\n    function hasEnded() public view returns (bool) {\r\n        bool capReached = weiRaised >= cap;\r\n        return super.hasEnded() || capReached;\r\n    }\r\n\r\n}\r\n\r\ncontract ControlledAccess is Ownable {\r\n    address public signer;\r\n    event SignerTransferred(address indexed previousSigner, address indexed newSigner);\r\n\r\n     /**\r\n    * @dev Throws if called by any account other than the signer.\r\n    */\r\n    modifier onlySigner() {\r\n        require(msg.sender == signer);\r\n        _;\r\n    }\r\n    /**\r\n    * @dev Allows the current owner to transfer the signer of the contract to a newSigner.\r\n    * @param newSigner The address to transfer signership to.\r\n    */\r\n\r\n    function transferSigner(address newSigner) public onlyOwner {\r\n        require(newSigner != address(0));\r\n        emit SignerTransferred(signer, newSigner);\r\n        signer = newSigner;\r\n    }\r\n    \r\n   /* \r\n    * @dev Requires msg.sender to have valid access message.\r\n    * @param _v ECDSA signature parameter v.\r\n    * @param _r ECDSA signature parameters r.\r\n    * @param _s ECDSA signature parameters s.\r\n    */\r\n    modifier onlyValidAccess(uint8 _v, bytes32 _r, bytes32 _s) \r\n    {\r\n        require(isValidAccessMessage(msg.sender,_v,_r,_s) );\r\n        _;\r\n    }\r\n \r\n    /* \r\n    * @dev Verifies if message was signed by owner to give access to _add for this contract.\r\n    *      Assumes Geth signature prefix.\r\n    * @param _add Address of agent with access\r\n    * @param _v ECDSA signature parameter v.\r\n    * @param _r ECDSA signature parameters r.\r\n    * @param _s ECDSA signature parameters s.\r\n    * @return Validity of access message for a given address.\r\n    */\r\n    function isValidAccessMessage(\r\n        address _add,\r\n        uint8 _v, \r\n        bytes32 _r, \r\n        bytes32 _s) \r\n        view public returns (bool)\r\n    {\r\n        bytes32 hash = keccak256(this, _add);\r\n        return signer == ecrecover(\r\n            keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n    }\r\n}\r\n\r\ncontract ElepigCrowdsale is CappedCrowdsale, RefundableCrowdsale, ControlledAccess {\r\n    using SafeMath for uint256;\r\n    \r\n    // ICO Stage  \r\n    // ============\r\n    enum CrowdsaleStage { PreICO, ICO1, ICO2, ICO3, ICO4 } //Sale has pre-ico and 4 bonus rounds\r\n    CrowdsaleStage public stage = CrowdsaleStage.PreICO; // By default stage is Pre ICO\r\n    // =============\r\n\r\n    address public community;    \r\n\r\n  // Token Distribution\r\n    // =============================\r\n    // 150MM of Elepig are already minted. \r\n    uint256 public totalTokensForSale = 150000000000000000000000000;  // 150 EPGs will be sold in Crowdsale (50% of total tokens for community) \r\n    uint256 public totalTokensForSaleDuringPreICO = 30000000000000000000000000; // 30MM out of 150MM EPGs will be sold during Pre ICO\r\n    uint256 public totalTokensForSaleDuringICO1 = 37500000000000000000000000;   // 37.5MM out of 150MM EPGs will be sold during Bonus Round 1\r\n    uint256 public totalTokensForSaleDuringICO2 = 37500000000000000000000000;   // 37.5MM out of 150MM EPGs will be sold during Bonus Round 2\r\n    uint256 public totalTokensForSaleDuringICO3 = 30000000000000000000000000;   // 30MM out of 150MM EPGs will be sold during Bonus Round 3\r\n    uint256 public totalTokensForSaleDuringICO4 = 15000000000000000000000000;   // 15MM out of 150MM EPGs will be sold during Bonus Round 4\r\n  // ==============================\r\n\r\n    // Amount raised\r\n    // ==================\r\n    \r\n    // store amount sold at each stage of sale\r\n    uint256 public totalWeiRaisedDuringPreICO;\r\n    uint256 public totalWeiRaisedDuringICO1;\r\n    uint256 public totalWeiRaisedDuringICO2;\r\n    uint256 public totalWeiRaisedDuringICO3;\r\n    uint256 public totalWeiRaisedDuringICO4;\r\n    uint256 public totalWeiRaised;\r\n\r\n\r\n    // store amount sold at each stage of sale\r\n    uint256 public totalTokensPreICO;\r\n    uint256 public totalTokensICO1;\r\n    uint256 public totalTokensICO2;\r\n    uint256 public totalTokensICO3;\r\n    uint256 public totalTokensICO4;\r\n    uint256 public tokensMinted;\r\n    \r\n\r\n    uint256 public airDropsClaimed = 0;\r\n    // ===================\r\n\r\n    mapping (address => bool) public airdrops;\r\n    mapping (address => bool) public blacklist;\r\n    \r\n    \r\n    // Events\r\n    event EthTransferred(string text);\r\n    event EthRefunded(string text);\r\n   \r\n\r\n\r\n    // Constructor\r\n    // ============\r\n    function ElepigCrowdsale(\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        uint256 _rate,\r\n        address _wallet,\r\n        uint256 _goal,\r\n        uint256 _cap,\r\n        address _communityAddress,\r\n        address _token,\r\n        address _signer\r\n    ) \r\n    CappedCrowdsale(_cap) FinalizableCrowdsale() RefundableCrowdsale(_goal) Crowdsale( _startTime, _endTime,  _rate, _wallet, _token) public {\r\n        require(_goal <= _cap);   // goal is softcap\r\n        require(_signer != address(0));\r\n        require(_communityAddress != address(0));\r\n        require(_token != address(0));\r\n\r\n\r\n        community = _communityAddress; // sets address of community wallet - address where tokens not sold will be minted\r\n        signer = _signer; // sets original address of signer\r\n\r\n        \r\n    }\r\n    \r\n\r\n  // =========================================================\r\n  // Crowdsale Stage Management\r\n  // =========================================================\r\n\r\n  // Change Crowdsale Stage. Available Options: PreICO, ICO1, ICO2, ICO3, ICO4\r\n    function setCrowdsaleStage(uint value) public onlyOwner {\r\n        require(value <= 4);\r\n        if (uint(CrowdsaleStage.PreICO) == value) {\r\n            rate = 2380; // 1 EPG = 0.00042 ETH\r\n            stage = CrowdsaleStage.PreICO;\r\n        } else if (uint(CrowdsaleStage.ICO1) == value) {\r\n            rate = 2040; // 1 EPG = 0.00049 ETH\r\n            stage = CrowdsaleStage.ICO1;\r\n        }\r\n        else if (uint(CrowdsaleStage.ICO2) == value) {\r\n            rate = 1785; // 1 EPG = 0.00056 ETH\r\n            stage = CrowdsaleStage.ICO2;\r\n        }\r\n        else if (uint(CrowdsaleStage.ICO3) == value) {\r\n            rate = 1587; // 1 EPG = 0.00063 ETH\r\n            stage = CrowdsaleStage.ICO3;\r\n        }\r\n        else if (uint(CrowdsaleStage.ICO4) == value) {\r\n            rate = 1503; // 1 EPG = 0.000665 ETH\r\n            stage = CrowdsaleStage.ICO4;\r\n        }\r\n    }\r\n\r\n\r\n    // Change the current rate\r\n    function setCurrentRate(uint256 _rate) private {\r\n        rate = _rate;\r\n    }    \r\n    // ================ Stage Management Over =====================\r\n\r\n    // ============================================================\r\n    //                     Address Management \r\n    // ============================================================\r\n\r\n\r\n    // adding an address to the blacklist, addresses on this list cannot send ETH to the contract     \r\n    function addBlacklistAddress (address _address) public onlyOwner {\r\n        blacklist[_address] = true;\r\n    }\r\n    \r\n    // removing an address from the blacklist    \r\n    function removeBlacklistAddress (address _address) public onlyOwner {\r\n        blacklist[_address] = false;\r\n    } \r\n\r\n    // ================= Address Management Over ==================\r\n\r\n\r\n    // Token Purchase, function will be called when 'data' is sent in \r\n    // FOR KYC\r\n    function donate(uint8 _v, bytes32 _r, bytes32 _s) \r\n    onlyValidAccess(_v,_r,_s) public payable{\r\n        require(msg.value >= 150000000000000000); // minimum limit - no max\r\n        require(blacklist[msg.sender] == false); // require that the sender is not in the blacklist      \r\n        \r\n        require(validPurchase()); // after ico start date and not value of 0  \r\n        \r\n        uint256 tokensThatWillBeMintedAfterPurchase = msg.value.mul(rate);\r\n\r\n        // if Pre-ICO sale limit is reached, refund sender\r\n        if ((stage == CrowdsaleStage.PreICO) && (totalTokensPreICO + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringPreICO)) {\r\n            msg.sender.transfer(msg.value); // Refund them\r\n            emit EthRefunded(\"PreICO Limit Hit\");\r\n            return;\r\n        } \r\n        if ((stage == CrowdsaleStage.ICO1) && (totalTokensICO1 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO1)) {\r\n            msg.sender.transfer(msg.value); // Refund them\r\n            emit EthRefunded(\"ICO1 Limit Hit\");\r\n            return;\r\n\r\n        }         \r\n        if ((stage == CrowdsaleStage.ICO2) && (totalTokensICO2 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO2)) {\r\n            msg.sender.transfer(msg.value); // Refund them\r\n            emit EthRefunded(\"ICO2 Limit Hit\");\r\n            return;\r\n\r\n        }  \r\n        if ((stage == CrowdsaleStage.ICO3) && (totalTokensICO3 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO3)) {\r\n            msg.sender.transfer(msg.value); // Refund them\r\n            emit EthRefunded(\"ICO3 Limit Hit\");\r\n            return;        \r\n        } \r\n\r\n        if ((stage == CrowdsaleStage.ICO4) && (totalTokensICO4 + tokensThatWillBeMintedAfterPurchase > totalTokensForSaleDuringICO4)) {\r\n            msg.sender.transfer(msg.value); // Refund them\r\n            emit EthRefunded(\"ICO4 Limit Hit\");\r\n            return;\r\n        } else {                \r\n            // calculate token amount to be created\r\n            uint256 tokens = msg.value.mul(rate);\r\n            weiRaised = weiRaised.add(msg.value);          \r\n\r\n            // mint token\r\n            tokenReward.mint(msg.sender, tokens);\r\n            emit TokenPurchase(msg.sender, msg.sender, msg.value, tokens);\r\n            forwardFunds();            \r\n            // end of buy tokens\r\n\r\n            if (stage == CrowdsaleStage.PreICO) {\r\n                totalWeiRaisedDuringPreICO = totalWeiRaisedDuringPreICO.add(msg.value);\r\n                totalTokensPreICO = totalTokensPreICO.add(tokensThatWillBeMintedAfterPurchase);    \r\n            } else if (stage == CrowdsaleStage.ICO1) {\r\n                totalWeiRaisedDuringICO1 = totalWeiRaisedDuringICO1.add(msg.value);\r\n                totalTokensICO1 = totalTokensICO1.add(tokensThatWillBeMintedAfterPurchase);\r\n            } else if (stage == CrowdsaleStage.ICO2) {\r\n                totalWeiRaisedDuringICO2 = totalWeiRaisedDuringICO2.add(msg.value);\r\n                totalTokensICO2 = totalTokensICO2.add(tokensThatWillBeMintedAfterPurchase);\r\n            } else if (stage == CrowdsaleStage.ICO3) {\r\n                totalWeiRaisedDuringICO3 = totalWeiRaisedDuringICO3.add(msg.value);\r\n                totalTokensICO3 = totalTokensICO3.add(tokensThatWillBeMintedAfterPurchase);\r\n            } else if (stage == CrowdsaleStage.ICO4) {\r\n                totalWeiRaisedDuringICO4 = totalWeiRaisedDuringICO4.add(msg.value);\r\n                totalTokensICO4 = totalTokensICO4.add(tokensThatWillBeMintedAfterPurchase);\r\n            }\r\n\r\n        }\r\n        // update state\r\n        tokensMinted = tokensMinted.add(tokensThatWillBeMintedAfterPurchase);      \r\n        \r\n    }\r\n\r\n    // =========================\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    function forwardFunds() internal {\r\n        // if Wei raised greater than softcap, send to wallet else put in refund vault\r\n        if (goalReached()) {\r\n            wallet.transfer(msg.value);\r\n            emit EthTransferred(\"forwarding funds to wallet\");\r\n        } else  {\r\n            emit EthTransferred(\"forwarding funds to refundable vault\");\r\n            super.forwardFunds();\r\n        }\r\n    }\r\n  \r\n     /**\r\n    * @dev perform a transfer of allocations (recommend doing in batches of 80 due to gas block limit)\r\n    * @param _from is the address the tokens will come from\r\n    * @param _recipient is a list of recipients\r\n    * @param _premium is a bool of if the list of addresses are premium or not\r\n    */\r\n    function airdropTokens(address _from, address[] _recipient, bool _premium) public onlyOwner {\r\n        uint airdropped;\r\n        uint tokens;\r\n\r\n        if(_premium == true) {\r\n            tokens = 500000000000000000000;\r\n        } else {\r\n            tokens = 50000000000000000000;\r\n        }\r\n\r\n        for(uint256 i = 0; i < _recipient.length; i++)\r\n        {\r\n            if (!airdrops[_recipient[i]]) {\r\n                airdrops[_recipient[i]] = true;\r\n                require(tokenReward.transferFrom(_from, _recipient[i], tokens));\r\n                airdropped = airdropped.add(tokens);\r\n            }\r\n        }\r\n        \r\n        airDropsClaimed = airDropsClaimed.add(airdropped);\r\n    }\r\n\r\n  // Finish: Mint Extra Tokens as needed before finalizing the Crowdsale.\r\n  // ====================================================================\r\n\r\n    function finish() public onlyOwner {\r\n\r\n        require(!isFinalized);\r\n        \r\n        if(tokensMinted < totalTokensForSale) {\r\n\r\n            uint256 unsoldTokens = totalTokensForSale - tokensMinted;            \r\n            tokenReward.mint(community, unsoldTokens);\r\n            \r\n        }\r\n             \r\n        finalize();\r\n    } \r\n\r\n    // if goal reached, manually close the vault\r\n    function releaseVault() public onlyOwner {\r\n        require(goalReached());\r\n        vault.close();\r\n    }\r\n\r\n    // transfers ownership of contract back to wallet\r\n    function transferTokenOwnership(address _newOwner) public onlyOwner {\r\n        tokenReward.transferOwnership(_newOwner);\r\n    }\r\n  // ===============================\r\n\r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaisedDuringICO2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensForSaleDuringICO4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeBlacklistAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"isValidAccessMessage\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"transferSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensICO2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensForSaleDuringICO3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaisedDuringICO1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensICO3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"airdrops\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addBlacklistAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropsClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setCrowdsaleStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaisedDuringPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensForSaleDuringPreICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaisedDuringICO4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensForSaleDuringICO2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensICO1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensForSaleDuringICO1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address[]\"},{\"name\":\"_premium\",\"type\":\"bool\"}],\"name\":\"airdropTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"community\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"donate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensICO4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaisedDuringICO3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_goal\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_communityAddress\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_signer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"EthTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"text\",\"type\":\"string\"}],\"name\":\"EthRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousSigner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"SignerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"ElepigCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005b30af10000000000000000000000000000000000000000000000000000000005bb1637f000000000000000000000000000000000000000000000000000000000000094c00000000000000000000000041d8925843121549724e232f1fca41811e6647f10000000000000000000000000000000000000000000000233c8fe42703e8000000000000000000000000000000000000000000000000111ee324ee575c08000000000000000000000000000089d2f089ae080f3740cc93d8ab363bdcfe657cfb000000000000000000000000afbe321aa28ab653dd6d507acc38e71ee7b0c7c0000000000000000000000000066f71beba634ffcae0580b059480c173e506d71","Library":"","SwarmSource":"bzzr://2bd067c2bb466d21f5f87ddd242c95710415af93b5d90f677b4f2934a3f496aa"}]}