{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract IMigrationContract {\r\n    function migrate(address _addr, uint256 _tokens, uint256 _totaltokens) public returns (bool success);\r\n}\r\n\r\n/* taking ideas from FirstBlood token */\r\ncontract SafeMath {\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z/x == y));\r\n        return z;\r\n    }\r\n    \r\n    function safeDiv(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        uint256 z = x / y;\r\n        return z;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public ethFundDeposit;\r\n\r\n    event OwnershipTransferred(address indexed ethFundDeposit, address indexed _newFundDeposit);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        ethFundDeposit = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == ethFundDeposit);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a _newFundDeposit.\r\n     * @param _newFundDeposit The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newFundDeposit) public onlyOwner {\r\n        require(_newFundDeposit != address(0));\r\n        emit OwnershipTransferred(ethFundDeposit, _newFundDeposit);\r\n        ethFundDeposit = _newFundDeposit;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS paused\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS NOT paused\r\n     */\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Controllable\r\n * @dev Base contract which allows children to control the address\r\n */\r\ncontract controllable is Ownable {\r\n\r\n    event AddToBlacklist(address _addr);\r\n    event DeleteFromBlacklist(address _addr);\r\n\r\n    // controllable variable\r\n    mapping (address => bool) internal blacklist; // black list\r\n\r\n    /**\r\n     * @dev called by the owner to AddToBlacklist\r\n     */\r\n    function addtoblacklist(address _addr) public onlyOwner {\r\n        blacklist[_addr] = true;\r\n        emit AddToBlacklist(_addr);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpDeleteFromBlacklistause\r\n     */\r\n    function deletefromblacklist(address _addr) public onlyOwner {\r\n        blacklist[_addr] = false;\r\n        emit DeleteFromBlacklist(_addr);\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to check the blacklist address\r\n     */\r\n    function isBlacklist(address _addr) public view returns(bool) {\r\n        return blacklist[_addr];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Lockable\r\n * @dev Base contract which allows children to control the token release mechanism\r\n */\r\ncontract Lockable is Ownable, SafeMath {\r\n\r\n    // parameters\r\n    mapping (address => uint256) balances;\r\n    mapping (address => uint256) totalbalances;\r\n    uint256 public totalreleaseblances;\r\n\r\n    mapping (address => mapping (uint256 => uint256)) userbalances; // address ， order ，balances amount\r\n    mapping (address => mapping (uint256 => uint256)) userRelease; // address ， order ，release amount\r\n    mapping (address => mapping (uint256 => uint256)) isRelease; // already release period\r\n    mapping (address => mapping (uint256 => uint256)) userChargeTime; // address ， order ，charge time\r\n    mapping (address => uint256) userChargeCount; // user total charge times\r\n    mapping (address => mapping (uint256 => uint256)) lastCliff; // address ， order ，last cliff time\r\n\r\n    // userbalances each time segmentation\r\n    mapping (address => mapping (uint256 => mapping (uint256 => uint256))) userbalancesSegmentation; // address ， order ，balances amount\r\n\r\n    uint256 internal duration = 30*15 days;\r\n    uint256 internal cliff = 90 days;\r\n\r\n    // event\r\n    event userlockmechanism(address _addr,uint256 _amount,uint256 _timestamp);\r\n    event userrelease(address _addr, uint256 _times, uint256 _amount);\r\n\r\n    modifier onlySelfOrOwner(address _addr) {\r\n        require(msg.sender == _addr || msg.sender == ethFundDeposit);\r\n        _;\r\n    }\r\n\r\n    function LockMechanism (\r\n        address _addr,\r\n        uint256 _value\r\n    )\r\n        internal\r\n    {\r\n        require(_addr != address(0));\r\n        require(_value != 0);\r\n        // count\r\n        userChargeCount[_addr] = safeAdd(userChargeCount[_addr],1);\r\n        uint256 _times = userChargeCount[_addr];\r\n        // time\r\n        userChargeTime[_addr][_times] = ShowTime();\r\n        // balances\r\n        userbalances[_addr][_times] = _value;\r\n        initsegmentation(_addr,userChargeCount[_addr],_value);\r\n        totalbalances[_addr] = safeAdd(totalbalances[_addr],_value);\r\n        isRelease[_addr][_times] = 0;\r\n        emit userlockmechanism(_addr,_value,ShowTime());\r\n    }\r\n\r\n// init segmentation\r\n    function initsegmentation(address _addr,uint256 _times,uint256 _value) internal {\r\n        for (uint8 i = 1 ; i <= 5 ; i++ ) {\r\n            userbalancesSegmentation[_addr][_times][i] = safeDiv(_value,5);\r\n        }\r\n    }\r\n\r\n// calculate period\r\n    function CalcPeriod(address _addr, uint256 _times) public view returns (uint256) {\r\n        uint256 userstart = userChargeTime[_addr][_times];\r\n        if (ShowTime() >= safeAdd(userstart,duration)) {\r\n            return 5;\r\n        }\r\n        uint256 timedifference = safeSubtract(ShowTime(),userstart);\r\n        uint256 period = 0;\r\n        for (uint8 i = 1 ; i <= 5 ; i++ ) {\r\n            if (timedifference >= cliff) {\r\n                timedifference = safeSubtract(timedifference,cliff);\r\n                period += 1;\r\n            }\r\n        }\r\n        return period;\r\n    }\r\n\r\n// ReleasableAmount() looking for the current releasable amount\r\n    function ReleasableAmount(address _addr, uint256 _times) public view returns (uint256) {\r\n        require(_addr != address(0));\r\n        uint256 period = CalcPeriod(_addr,_times);\r\n        if (safeSubtract(period,isRelease[_addr][_times]) > 0){\r\n            uint256 amount = 0;\r\n            for (uint256 i = safeAdd(isRelease[_addr][_times],1) ; i <= period ; i++ ) {\r\n                amount = safeAdd(amount,userbalancesSegmentation[_addr][_times][i]);\r\n            }\r\n            return amount;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n// release() release the current releasable amount\r\n    function release(address _addr, uint256 _times) external onlySelfOrOwner(_addr) {\r\n        uint256 amount = ReleasableAmount(_addr,_times);\r\n        require(amount > 0);\r\n        userRelease[_addr][_times] = safeAdd(userRelease[_addr][_times],amount);\r\n        balances[_addr] = safeAdd(balances[_addr],amount);\r\n        lastCliff[_addr][_times] = ShowTime();\r\n        isRelease[_addr][_times] = CalcPeriod(_addr,_times);\r\n        totalreleaseblances = safeAdd(totalreleaseblances,amount);\r\n        emit userrelease(_addr, _times, amount);\r\n    }\r\n\r\n// ShowTime\r\n    function ShowTime() internal view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n// totalBalance()\r\n    function totalBalanceOf(address _addr) public view returns (uint256) {\r\n        return totalbalances[_addr];\r\n    }\r\n// ShowRelease() looking for the already release amount of the address at some time\r\n    function ShowRelease(address _addr, uint256 _times) public view returns (uint256) {\r\n        return userRelease[_addr][_times];\r\n    }\r\n// ShowUnrelease() looking for the not yet release amount of the address at some time\r\n    function ShowUnrelease(address _addr, uint256 _times) public view returns (uint256) {\r\n        return safeSubtract(userbalances[_addr][_times],ShowRelease(_addr,_times));\r\n    }\r\n// ShowChargeTime() looking for the charge time\r\n    function ShowChargeTime(address _addr, uint256 _times) public view returns (uint256) {\r\n        return userChargeTime[_addr][_times];\r\n    }\r\n// ShowChargeCount() looking for the user total charge times\r\n    function ShowChargeCount(address _addr) public view returns (uint256) {\r\n        return userChargeCount[_addr];\r\n    }\r\n// ShowNextCliff() looking for the nex cliff time\r\n    function ShowNextCliff(address _addr, uint256 _times) public view returns (uint256) {\r\n        return safeAdd(lastCliff[_addr][_times],cliff);\r\n    }\r\n// ShowSegmentation() looking for the user balances Segmentation\r\n    function ShowSegmentation(address _addr, uint256 _times,uint256 _period) public view returns (uint256) {\r\n        return userbalancesSegmentation[_addr][_times][_period];\r\n    }\r\n\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining); \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is controllable, Pausable, Token, Lockable {\r\n\r\n    function transfer(address _to, uint256 _value) public whenNotPaused() returns (bool success) {\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to] && !isBlacklist(msg.sender)) {\r\n            // sender\r\n            balances[msg.sender] = safeSubtract(balances[msg.sender],_value);\r\n            totalbalances[msg.sender] = safeSubtract(totalbalances[msg.sender],_value);\r\n            // _to\r\n            balances[_to] = safeAdd(balances[_to],_value);\r\n            totalbalances[_to] = safeAdd(totalbalances[_to],_value);\r\n\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused() returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to] && !isBlacklist(msg.sender)) {\r\n            // _to\r\n            balances[_to] = safeAdd(balances[_to],_value);\r\n            totalbalances[_to] = safeAdd(totalbalances[_to],_value);\r\n            // _from\r\n            balances[_from] = safeSubtract(balances[_from],_value);\r\n            totalbalances[_from] = safeSubtract(totalbalances[_from],_value);\r\n            // allowed\r\n            allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender],_value);\r\n\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) { \r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract BugXToken is StandardToken {\r\n\r\n    /**\r\n    *  base parameters\r\n    */\r\n\r\n    // metadata\r\n    string  public constant name = \"BUGX Token\";\r\n    string  public constant symbol = \"BUX\";\r\n    uint256 public constant decimals = 18;\r\n    string  public version = \"1.0\";\r\n\r\n    // contracts\r\n    address public newContractAddr;         // the new contract for BUGX token updates;\r\n\r\n    // crowdsale parameters\r\n    bool    public isFunding;                // switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingStopBlock;\r\n\r\n    uint256 public currentSupply;           // current supply tokens for sell\r\n    uint256 public tokenRaised = 0;           // the number of total sold token\r\n    uint256 public tokenIssued = 0;         // the number of total issued token\r\n    uint256 public tokenMigrated = 0;     // the number of total Migrated token\r\n    uint256 internal tokenExchangeRate = 9000;             // 9000 BUGX tokens per 1 ETH\r\n    uint256 internal tokenExchangeRateTwo = 9900;             // 9000 * 1.1 BUGX tokens per 1 ETH\r\n    uint256 internal tokenExchangeRateThree = 11250;             // 9000 * 1.25 BUGX tokens per 1 ETH\r\n\r\n    // events\r\n    event AllocateToken(address indexed _to, uint256 _value);   // issue token to buyer;\r\n    event TakebackToken(address indexed _from, uint256 _value);   //  record token take back info;\r\n    event RaiseToken(address indexed _to, uint256 _value);      // record token raise info;\r\n    event IssueToken(address indexed _to, uint256 _value);\r\n    event IncreaseSupply(uint256 _value);\r\n    event DecreaseSupply(uint256 _value);\r\n    event Migrate(address indexed _addr, uint256 _tokens, uint256 _totaltokens);\r\n\r\n    // format decimals.\r\n    function formatDecimals(uint256 _value) internal pure returns (uint256 ) {\r\n        return _value * 10 ** decimals;\r\n    }\r\n\r\n    /**\r\n    *  constructor function\r\n    */\r\n\r\n    // constructor\r\n    constructor(\r\n        address _ethFundDeposit,\r\n        uint256 _currentSupply\r\n        ) \r\n        public\r\n    {\r\n        require(_ethFundDeposit != address(0x0));\r\n        ethFundDeposit = _ethFundDeposit;\r\n\r\n        isFunding = false;                           //controls pre through crowdsale state\r\n        fundingStartBlock = 0;\r\n        fundingStopBlock = 0;\r\n\r\n        currentSupply = formatDecimals(_currentSupply);\r\n        totalSupply = formatDecimals(1500000000);    //1,500,000,000 total supply\r\n        require(currentSupply <= totalSupply);\r\n        balances[ethFundDeposit] = currentSupply;\r\n        totalbalances[ethFundDeposit] = currentSupply;\r\n    }\r\n\r\n    /**\r\n    *  Modify currentSupply functions\r\n    */\r\n\r\n    /// @dev increase the token's supply\r\n    function increaseSupply (uint256 _tokens) onlyOwner external {\r\n        uint256 _value = formatDecimals(_tokens);\r\n        require (_value + currentSupply <= totalSupply);\r\n        currentSupply = safeAdd(currentSupply, _value);\r\n        tokenadd(ethFundDeposit,_value);\r\n        emit IncreaseSupply(_value);\r\n    }\r\n\r\n    /// @dev decrease the token's supply\r\n    function decreaseSupply (uint256 _tokens) onlyOwner external {\r\n        uint256 _value = formatDecimals(_tokens);\r\n        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\r\n        require (safeAdd(_value,tokenCirculation) <= currentSupply);\r\n        currentSupply = safeSubtract(currentSupply, _value);\r\n        tokensub(ethFundDeposit,_value);\r\n        emit DecreaseSupply(_value);\r\n    }\r\n\r\n    /**\r\n    *  Funding functions\r\n    */\r\n\r\n    modifier whenFunding() {\r\n        require (isFunding);\r\n        require (block.number >= fundingStartBlock);\r\n        require (block.number <= fundingStopBlock);\r\n        _;\r\n    }\r\n\r\n    /// @dev turn on the funding state\r\n    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) onlyOwner external {\r\n        require (!isFunding);\r\n        require (_fundingStartBlock < _fundingStopBlock);\r\n        require (block.number < _fundingStartBlock);\r\n\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingStopBlock = _fundingStopBlock;\r\n        isFunding = true;\r\n    }\r\n\r\n    /// @dev turn off the funding state\r\n    function stopFunding() onlyOwner external {\r\n        require (isFunding);\r\n        isFunding = false;\r\n    }\r\n\r\n\r\n    /**\r\n    *  migrate functions\r\n    */\r\n\r\n    /// @dev set a new contract for recieve the tokens (for update contract)\r\n    function setMigrateContract(address _newContractAddr) onlyOwner external {\r\n        require (_newContractAddr != newContractAddr);\r\n        newContractAddr = _newContractAddr;\r\n    }\r\n\r\n    /// sends the tokens to new contract by owner\r\n    function migrate(address _addr) onlySelfOrOwner(_addr) external {\r\n        require(!isFunding);\r\n        require(newContractAddr != address(0x0));\r\n\r\n        uint256 tokens_value = balances[_addr];\r\n        uint256 totaltokens_value = totalbalances[_addr];\r\n        require (tokens_value != 0 || totaltokens_value != 0);\r\n\r\n        balances[_addr] = 0;\r\n        totalbalances[_addr] = 0;\r\n\r\n        IMigrationContract newContract = IMigrationContract(newContractAddr);\r\n        require (newContract.migrate(_addr, tokens_value, totaltokens_value));\r\n\r\n        tokenMigrated = safeAdd(tokenMigrated, totaltokens_value);\r\n        emit Migrate(_addr, tokens_value, totaltokens_value);\r\n    }\r\n\r\n    /**\r\n    *  tokenRaised and tokenIssued control functions\r\n    *  base functions\r\n    */\r\n\r\n    /// token raised\r\n    function tokenRaise (address _addr,uint256 _value) internal {\r\n        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\r\n        require (safeAdd(_value,tokenCirculation) <= currentSupply);\r\n        tokenRaised = safeAdd(tokenRaised, _value);\r\n        emit RaiseToken(_addr, _value);\r\n    }\r\n\r\n    /// issue token 1 : token issued\r\n    function tokenIssue (address _addr,uint256 _value) internal {\r\n        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\r\n        require (safeAdd(_value,tokenCirculation) <= currentSupply);\r\n        tokenIssued = safeAdd(tokenIssued, _value);\r\n        emit IssueToken(_addr, _value);\r\n    }\r\n\r\n    /// issue token 2 : issue token take back\r\n    function tokenTakeback (address _addr,uint256 _value) internal {\r\n        require (tokenIssued >= _value);\r\n        tokenIssued = safeSubtract(tokenIssued, _value);\r\n        emit TakebackToken(_addr, _value);\r\n    }\r\n\r\n    /// issue token take from ethFundDeposit to user\r\n    function tokenadd (address _addr,uint256 _value) internal {\r\n        require(_value != 0);\r\n        require (_addr != address(0x0));\r\n        balances[_addr] = safeAdd(balances[_addr], _value);\r\n        totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);\r\n    }\r\n\r\n    /// issue token take from user to ethFundDeposit\r\n    function tokensub (address _addr,uint256 _value) internal {\r\n        require(_value != 0);\r\n        require (_addr != address(0x0));\r\n        balances[_addr] = safeSubtract(balances[_addr], _value);\r\n        totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);\r\n    }\r\n\r\n    /**\r\n    *  tokenRaised and tokenIssued control functions\r\n    *  main functions\r\n    */\r\n\r\n    /// Issues tokens to buyers.\r\n    function allocateToken(address _addr, uint256 _tokens) onlyOwner external {\r\n        uint256 _value = formatDecimals(_tokens);\r\n        tokenadd(_addr,_value);\r\n        tokensub(ethFundDeposit,_value);\r\n        tokenIssue(_addr,_value);\r\n        emit Transfer(ethFundDeposit, _addr, _value);\r\n    }\r\n\r\n    /// Issues tokens deduction.\r\n    function deductionToken (address _addr, uint256 _tokens) onlyOwner external {\r\n        uint256 _value = formatDecimals(_tokens);\r\n        tokensub(_addr,_value);\r\n        tokenadd(ethFundDeposit,_value);\r\n        tokenTakeback(_addr,_value);\r\n        emit Transfer(_addr, ethFundDeposit, _value);\r\n    }\r\n\r\n    /// add the segmentation\r\n    function addSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {\r\n        uint256 amount = userbalancesSegmentation[_addr][_times][_period];\r\n        if (amount != 0 && _tokens != 0){\r\n            uint256 _value = formatDecimals(_tokens);\r\n            userbalancesSegmentation[_addr][_times][_period] = safeAdd(amount,_value);\r\n            userbalances[_addr][_times] = safeAdd(userbalances[_addr][_times], _value);\r\n            totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);\r\n            tokensub(ethFundDeposit,_value);\r\n            tokenIssue(_addr,_value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// sub the segmentation\r\n    function subSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {\r\n        uint256 amount = userbalancesSegmentation[_addr][_times][_period];\r\n        if (amount != 0 && _tokens != 0){\r\n            uint256 _value = formatDecimals(_tokens);\r\n            userbalancesSegmentation[_addr][_times][_period] = safeSubtract(amount,_value);\r\n            userbalances[_addr][_times] = safeSubtract(userbalances[_addr][_times], _value);\r\n            totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);\r\n            tokenadd(ethFundDeposit,_value);\r\n            tokenTakeback(_addr,_value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  tokenExchangeRate functions\r\n    */\r\n\r\n    /// @dev set the token's tokenExchangeRate,\r\n    function setTokenExchangeRate(uint256 _RateOne,uint256 _RateTwo,uint256 _RateThree) onlyOwner external {\r\n        require (_RateOne != 0 && _RateTwo != 0 && _RateThree != 0);\r\n        require (_RateOne != tokenExchangeRate && _RateTwo != tokenExchangeRateTwo && _RateThree != tokenExchangeRateThree);\r\n\r\n        tokenExchangeRate = _RateOne;\r\n        tokenExchangeRateTwo = _RateTwo;\r\n        tokenExchangeRateThree = _RateThree;\r\n    }\r\n\r\n    /// calculate the tokenExchangeRate\r\n    function computeTokenAmount(uint256 _eth) internal view returns (uint256 tokens) {\r\n        if(_eth > 0 && _eth < 100 ether){\r\n            tokens = safeMult(_eth, tokenExchangeRate);\r\n        }\r\n        \r\n        if (_eth >= 100 ether && _eth < 500 ether){\r\n            tokens = safeMult(_eth, tokenExchangeRateTwo);\r\n        }\r\n\r\n        if (_eth >= 500 ether ){\r\n            tokens = safeMult(_eth, tokenExchangeRateThree);\r\n        }\r\n    }\r\n\r\n    /**\r\n    *  Append : the LockMechanism functions by owner\r\n    */\r\n\r\n    function LockMechanismByOwner (\r\n        address _addr,\r\n        uint256 _tokens\r\n    )\r\n        external onlyOwner whenFunding\r\n    {\r\n        require (_tokens != 0);\r\n        uint256 _value = formatDecimals(_tokens);\r\n        tokenRaise(_addr,_value);\r\n        tokensub(ethFundDeposit,_value);\r\n        LockMechanism(_addr,_value);\r\n        emit Transfer(ethFundDeposit,_addr,_value);\r\n    }\r\n\r\n    /**\r\n    *  ETH control functions\r\n    */\r\n\r\n    /// @dev sends ETH to BUGX team\r\n    function transferETH() onlyOwner external {\r\n        require (address(this).balance != 0);\r\n        ethFundDeposit.transfer(address(this).balance);\r\n    }\r\n\r\n    function () public payable whenFunding { // fallback function\r\n        require (msg.value != 0);\r\n        uint256 _value = computeTokenAmount(msg.value);\r\n        tokenRaise(msg.sender,_value);\r\n        tokensub(ethFundDeposit,_value);\r\n        LockMechanism(msg.sender,_value);\r\n        emit Transfer(ethFundDeposit,msg.sender,_value);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"allocateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addtoblacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"}],\"name\":\"CalcPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"},{\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"ShowSegmentation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"}],\"name\":\"ReleasableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isBlacklist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"ShowChargeCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContractAddr\",\"type\":\"address\"}],\"name\":\"setMigrateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"totalBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalreleaseblances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"},{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"subSegmentation\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fundingStartBlock\",\"type\":\"uint256\"},{\"name\":\"_fundingStopBlock\",\"type\":\"uint256\"}],\"name\":\"startFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"}],\"name\":\"ShowChargeTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"deductionToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"}],\"name\":\"ShowNextCliff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_RateOne\",\"type\":\"uint256\"},{\"name\":\"_RateTwo\",\"type\":\"uint256\"},{\"name\":\"_RateThree\",\"type\":\"uint256\"}],\"name\":\"setTokenExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"}],\"name\":\"ShowUnrelease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"decreaseSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"deletefromblacklist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethFundDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"LockMechanismByOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"}],\"name\":\"ShowRelease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"increaseSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_times\",\"type\":\"uint256\"},{\"name\":\"_period\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"addSegmentation\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFundDeposit\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingStopBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ethFundDeposit\",\"type\":\"address\"},{\"name\":\"_currentSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"AllocateToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TakebackToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"RaiseToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"IssueToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"IncreaseSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"DecreaseSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totaltokens\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"userlockmechanism\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_times\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"userrelease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"AddToBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"DeleteFromBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ethFundDeposit\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newFundDeposit\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BugXToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000a053f95863f6d35f7daaafaac4b8e7011539f0b000000000000000000000000000000000000000000000000000000001ad27480","Library":"","SwarmSource":"bzzr://7e596a90d8aaca758bf21749dafb64c35e522ce41a77ed11e7dcaa12e9412f60"}]}