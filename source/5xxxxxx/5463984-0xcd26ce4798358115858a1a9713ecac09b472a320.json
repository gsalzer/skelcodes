{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\ncontract ERC20 {\r\n  // We want to be able to recover & donate any tokens sent to the contract.\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n}\r\n\r\n\r\ncontract theCyberInterface {\r\n  // The utility contract can call the following methods of theCyber.\r\n  function newMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public;\r\n  function proclaimInactive(uint8 _memberId) public;\r\n  function heartbeat() public;\r\n  function revokeMembership(uint8 _memberId) public;\r\n  function getMembershipStatus(address _memberAddress) public view returns (bool member, uint8 memberId);\r\n  function getMemberInformation(uint8 _memberId) public view returns (bytes32 memberName, string memberKey, uint64 memberSince, uint64 inactiveSince, address memberAddress);\r\n  function maxMembers() public pure returns(uint16);\r\n  function inactivityTimeout() public pure returns(uint64);\r\n  function donationAddress() public pure returns(address);\r\n}\r\n\r\n\r\ncontract theCyberMemberUtilities {\r\n  // This contract provides a set of helper functions that members of theCyber\r\n  // may call in order to perform more advanced operations. In order to interact\r\n  // with theCyber, the contract must first be assigned as a member.\r\n\r\n  event MembershipStatusSet(bool isMember, uint8 memberId);\r\n  event FundsDonated(uint256 value);\r\n  event TokensDonated(address tokenContractAddress, uint256 value);\r\n\r\n  // Set the address and interface of theCyber.\r\n  address private constant THECYBERADDRESS_ = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;\r\n  theCyberInterface theCyber = theCyberInterface(THECYBERADDRESS_);\r\n\r\n  // Set up variables for checking the contract's membership status.\r\n  bool private isMember_;\r\n  uint8 private memberId_;\r\n\r\n  // The max members, inactivity timeout, and the donation address are pulled\r\n  // from theCyber inside the constructor function.\r\n  uint16 private maxMembers_;\r\n  uint64 private inactivityTimeout_;\r\n  address private donationAddress_;\r\n\r\n  // Batch operations on all members utilize incrementing member ids.\r\n  uint8 private nextInactiveMemberIndex_;\r\n  uint8 private nextRevokedMemberIndex_;\r\n\r\n  // Methods of the utility contract can only be called by a valid member.\r\n  modifier membersOnly() {\r\n    // Only allow transactions originating from a valid member address.\r\n    bool member;\r\n    (member,) = theCyber.getMembershipStatus(msg.sender);\r\n    require(member);\r\n    _;\r\n  }\r\n\r\n  // In the constructor function, set up the max members, the inactivity\r\n  // timeout, and the donation address.\r\n  function theCyberMemberUtilities() public {\r\n    // Set the maximum number of members.\r\n    maxMembers_ = theCyber.maxMembers();\r\n\r\n    // Set the inactivity timeout.\r\n    inactivityTimeout_ = theCyber.inactivityTimeout();\r\n\r\n    // Set the donation address.\r\n    donationAddress_ = theCyber.donationAddress();\r\n\r\n    // Set the initial membership status to false.\r\n    isMember_ = false;\r\n\r\n    // Start the inactive member index at 0.\r\n    nextInactiveMemberIndex_ = 0;\r\n\r\n    // Start the revoked member index at 0.\r\n    nextRevokedMemberIndex_ = 0;\r\n  }\r\n\r\n  // Set the member id of the utility contract prior to calling batch methods.\r\n  function setMembershipStatus() public membersOnly {\r\n    // Set the membership status and member id of the utility contract.\r\n    (isMember_,memberId_) = theCyber.getMembershipStatus(this);\r\n\r\n    // Log the membership status of the utility contract.\r\n    MembershipStatusSet(isMember_, memberId_);\r\n  }\r\n\r\n  // The utility contract must be able to heartbeat if it is marked as inactive.\r\n  function heartbeat() public membersOnly {\r\n    // Heartbeat the utility contract.\r\n    theCyber.heartbeat();\r\n  }\r\n\r\n  // Revoke a membership and immediately assign the membership to a new member.\r\n  function revokeAndSetNewMember(uint8 _memberId, bytes32 _memberName, address _memberAddress) public membersOnly {\r\n    // Revoke the membership (provided it has been inactive for long enough).\r\n    theCyber.revokeMembership(_memberId);\r\n\r\n    // Assign a new member to the membership (provided the new member is valid).\r\n    theCyber.newMember(_memberId, _memberName, _memberAddress);\r\n  }\r\n\r\n  // Mark all members (except this contract & msg.sender) as inactive.\r\n  function proclaimAllInactive() public membersOnly returns (bool complete) {\r\n    // The utility contract must be a member (and therefore have a member id).\r\n    require(isMember_);\r\n\r\n    // Get the memberId of the calling member.\r\n    uint8 callingMemberId;\r\n    (,callingMemberId) = theCyber.getMembershipStatus(msg.sender);\r\n\r\n    // Initialize variables for checking the status of each membership.\r\n    uint64 inactiveSince;\r\n    address memberAddress;\r\n    \r\n    // Pick up where the function last left off in assigning new members.\r\n    uint8 i = nextInactiveMemberIndex_;\r\n\r\n    // make sure that the loop triggers at least once.\r\n    require(msg.gas > 175000);\r\n\r\n    // Loop through members as long as sufficient gas remains.\r\n    while (msg.gas > 170000) {\r\n      // Make sure that the target membership is owned and active.\r\n      (,,,inactiveSince,memberAddress) = theCyber.getMemberInformation(i);\r\n      if ((i != memberId_) && (i != callingMemberId) && (memberAddress != address(0)) && (inactiveSince == 0)) {\r\n        // Mark the member as inactive.\r\n        theCyber.proclaimInactive(i);\r\n      }\r\n      // Increment the index to point to the next member id.\r\n      i++;\r\n\r\n      // exit once the index overflows.\r\n      if (i == 0) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Set the index where the function left off.\r\n    nextInactiveMemberIndex_ = i;\r\n    return (i == 0);\r\n  }\r\n\r\n  // Allow members to circumvent the safety measure against self-inactivation.\r\n  function inactivateSelf() public membersOnly {\r\n    // Get the memberId of the calling member.\r\n    uint8 memberId;\r\n    (,memberId) = theCyber.getMembershipStatus(msg.sender);\r\n\r\n    // Inactivate the membership (provided it is not already marked inactive).\r\n    theCyber.proclaimInactive(memberId);\r\n  }\r\n\r\n  // Revoke all memberships (except those of the utility contract & msg.sender)\r\n  // that have been inactive for longer than the inactivity timeout.\r\n  function revokeAllVulnerable() public membersOnly returns (bool complete) {\r\n    // The utility contract must be a member (and therefore have a member id).\r\n    require(isMember_);\r\n\r\n    // Get the memberId of the calling member.\r\n    uint8 callingMemberId;\r\n    (,callingMemberId) = theCyber.getMembershipStatus(msg.sender);\r\n\r\n    // Initialize variables for checking the status of each membership.\r\n    uint64 inactiveSince;\r\n    address memberAddress;\r\n    \r\n    // Pick up where the function last left off in assigning new members.\r\n    uint8 i = nextRevokedMemberIndex_;\r\n\r\n    // make sure that the loop triggers at least once.\r\n    require(msg.gas > 175000);\r\n\r\n    // Loop through members as long as sufficient gas remains.\r\n    while (msg.gas > 175000) {\r\n      // Make sure that the target membership is owned and inactive long enough.\r\n      (,,,inactiveSince,memberAddress) = theCyber.getMemberInformation(i);\r\n      if ((i != memberId_) && (i != callingMemberId) && (memberAddress != address(0)) && (inactiveSince != 0) && (now >= inactiveSince + inactivityTimeout_)) {\r\n        // Revoke the member.\r\n        theCyber.revokeMembership(i);\r\n      }\r\n      // Increment the index to point to the next member id.\r\n      i++;\r\n\r\n      // exit once the index overflows.\r\n      if (i == 0) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Set the index where the function left off.\r\n    nextRevokedMemberIndex_ = i;\r\n    return (i == 0);\r\n  }\r\n\r\n  // Allow members to circumvent the safety measure against self-revokation.\r\n  function revokeSelf() public membersOnly {\r\n    // Get the memberId of the calling member.\r\n    uint8 memberId;\r\n    (,memberId) = theCyber.getMembershipStatus(msg.sender);\r\n\r\n    // Revoke the membership (provided it has been inactive for long enough).\r\n    theCyber.revokeMembership(memberId);\r\n  }\r\n\r\n  // The contract is not payable by design, but could end up with a balance as\r\n  // a recipient of a selfdestruct / coinbase of a mined block.\r\n  function donateFunds() public membersOnly {\r\n    // Log the donation of any funds that have made their way into the contract.\r\n    FundsDonated(this.balance);\r\n\r\n    // Send all available funds to the donation address.\r\n    donationAddress_.transfer(this.balance);\r\n  }\r\n\r\n  // We also want to be able to access any tokens that are sent to the contract.\r\n  function donateTokens(address _tokenContractAddress) public membersOnly {\r\n    // Make sure that we didn't pass in the current contract address by mistake.\r\n    require(_tokenContractAddress != address(this));\r\n\r\n    // Log the donation of any tokens that have been sent into the contract.\r\n    TokensDonated(_tokenContractAddress, ERC20(_tokenContractAddress).balanceOf(this));\r\n\r\n    // Send all available tokens at the given contract to the donation address.\r\n    ERC20(_tokenContractAddress).transfer(donationAddress_, ERC20(_tokenContractAddress).balanceOf(this));\r\n  }\r\n\r\n  // The donation address for lost ether / ERC20 tokens should match theCyber's.\r\n  function donationAddress() public view returns(address) {\r\n    return donationAddress_;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"donateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"revokeSelf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"heartbeat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"inactivateSelf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"revokeAllVulnerable\",\"outputs\":[{\"name\":\"complete\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_memberId\",\"type\":\"uint8\"},{\"name\":\"_memberName\",\"type\":\"bytes32\"},{\"name\":\"_memberAddress\",\"type\":\"address\"}],\"name\":\"revokeAndSetNewMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setMembershipStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"proclaimAllInactive\",\"outputs\":[{\"name\":\"complete\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"donationAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"isMember\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"memberId\",\"type\":\"uint8\"}],\"name\":\"MembershipStatusSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FundsDonated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokensDonated\",\"type\":\"event\"}]","ContractName":"theCyberMemberUtilities","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9bfbe8fe2531f1ee1e1b5aaf132af08b103ffe455f6a3524ecde24439697718b"}]}