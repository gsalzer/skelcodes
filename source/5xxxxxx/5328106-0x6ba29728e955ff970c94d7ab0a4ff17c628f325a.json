{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * The edgeless casino contract v2 holds the players's funds and provides state channel functionality.\r\n * The casino has at no time control over the players's funds.\r\n * State channels can be updated and closed from both parties: the player and the casino.\r\n * author: Julia Altenried\r\n **/\r\n\r\npragma solidity ^0.4.19;\r\n\r\ncontract SafeMath {\r\n\r\n\tfunction safeSub(uint a, uint b) pure internal returns(uint) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\t\r\n\tfunction safeSub(int a, int b) pure internal returns(int) {\r\n\t\tif(b < 0) assert(a - b > a);\r\n\t\telse assert(a - b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction safeAdd(uint a, uint b) pure internal returns(uint) {\r\n\t\tuint c = a + b;\r\n\t\tassert(c >= a && c >= b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction safeMul(uint a, uint b) pure internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n\tfunction transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\r\n\r\n\tfunction transfer(address receiver, uint amount) public returns(bool success) {}\r\n\r\n\tfunction balanceOf(address holder) public constant returns(uint) {}\r\n}\r\n\r\ncontract owned {\r\n  address public owner;\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function owned() public{\r\n    owner = msg.sender;\r\n  }\r\n\r\n}\r\n\r\n/** owner should be able to close the contract is nobody has been using it for at least 30 days */\r\ncontract mortal is owned {\r\n\t/** contract can be closed by the owner anytime after this timestamp if non-zero */\r\n\tuint public closeAt;\r\n\t/** the edgeless token contract */\r\n\tToken edg;\r\n\t\r\n\tfunction mortal(address tokenContract) internal{\r\n\t\tedg = Token(tokenContract);\r\n\t}\r\n\t/**\r\n\t* lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days\r\n\t*/\r\n  function closeContract(uint playerBalance) internal{\r\n\t\tif(closeAt == 0) closeAt = now + 30 days;\r\n\t\tif(closeAt < now || playerBalance == 0){\r\n\t\t\tedg.transfer(owner, edg.balanceOf(address(this)));\r\n\t\t\tselfdestruct(owner);\r\n\t\t} \r\n  }\r\n\r\n\t/**\r\n\t* in case close has been called accidentally.\r\n\t**/\r\n\tfunction open() onlyOwner public{\r\n\t\tcloseAt = 0;\r\n\t}\r\n\r\n\t/**\r\n\t* make sure the contract is not in process of being closed.\r\n\t**/\r\n\tmodifier isAlive {\r\n\t\trequire(closeAt == 0);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* delays the time of closing.\r\n\t**/\r\n\tmodifier keepAlive {\r\n\t\tif(closeAt > 0) closeAt = now + 30 days;\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n\r\ncontract requiringAuthorization is mortal {\r\n\t/** indicates if an address is authorized to act in the casino's name  */\r\n\tmapping(address => bool) public authorized;\r\n\t/** tells if an address is allowed to receive funds from the bankroll **/\r\n\tmapping(address => bool) public allowedReceiver;\r\n\r\n\tmodifier onlyAuthorized {\r\n\t\trequire(authorized[msg.sender]);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * Constructor. Authorize the owner.\r\n\t * */\r\n\tfunction requiringAuthorization() internal {\r\n\t\tauthorized[msg.sender] = true;\r\n\t\tallowedReceiver[msg.sender] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * authorize a address to call game functions and set configs.\r\n\t * @param addr the address to be authorized\r\n\t **/\r\n\tfunction authorize(address addr) public onlyOwner {\r\n\t\tauthorized[addr] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * deauthorize a address to call game functions and set configs.\r\n\t * @param addr the address to be deauthorized\r\n\t **/\r\n\tfunction deauthorize(address addr) public onlyOwner {\r\n\t\tauthorized[addr] = false;\r\n\t}\r\n\r\n\t/**\r\n\t * allow authorized wallets to withdraw funds from the bonkroll to this address\r\n\t * @param receiver the receiver's address\r\n\t * */\r\n\tfunction allowReceiver(address receiver) public onlyOwner {\r\n\t\tallowedReceiver[receiver] = true;\r\n\t}\r\n\r\n\t/**\r\n\t * disallow authorized wallets to withdraw funds from the bonkroll to this address\r\n\t * @param receiver the receiver's address\r\n\t * */\r\n\tfunction disallowReceiver(address receiver) public onlyOwner {\r\n\t\tallowedReceiver[receiver] = false;\r\n\t}\r\n\r\n\t/**\r\n\t * changes the owner of the contract. revokes authorization of the old owner and authorizes the new one.\r\n\t * @param newOwner the address of the new owner\r\n\t * */\r\n\tfunction changeOwner(address newOwner) public onlyOwner {\r\n\t\tdeauthorize(owner);\r\n\t\tauthorize(newOwner);\r\n\t\tdisallowReceiver(owner);\r\n\t\tallowReceiver(newOwner);\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\n\r\ncontract chargingGas is requiringAuthorization, SafeMath {\r\n\t/** 1 EDG has 5 decimals **/\r\n\tuint public constant oneEDG = 100000;\r\n\t/** the price per kgas and GWei in tokens (with decimals) */\r\n\tuint public gasPrice;\r\n\t/** the amount of gas used per transaction in kGas */\r\n\tmapping(bytes4 => uint) public gasPerTx;\r\n\t/** the number of tokens (5 decimals) payed by the users to cover the gas cost */\r\n\tuint public gasPayback;\r\n\t\r\n\tfunction chargingGas(uint kGasPrice) internal{\r\n\t\t//deposit, withdrawFor, updateChannel, updateBatch, transferToNewContract\r\n\t    bytes4[5] memory signatures = [bytes4(0x3edd1128),0x9607610a, 0xde48ff52, 0xc97b6d1f, 0x6bf06fde];\r\n\t    //amount of gas consumed by the above methods in GWei\r\n\t    uint[5] memory gasUsage = [uint(146), 100, 65, 50, 85];\r\n\t    setGasUsage(signatures, gasUsage);\r\n\t    setGasPrice(kGasPrice);\r\n\t}\r\n\t/**\r\n\t * sets the amount of gas consumed by methods with the given sigantures.\r\n\t * only called from the edgeless casino constructor.\r\n\t * @param signatures an array of method-signatures\r\n\t *        gasNeeded  the amount of gas consumed by these methods\r\n\t * */\r\n\tfunction setGasUsage(bytes4[5] signatures, uint[5] gasNeeded) public onlyOwner {\r\n\t\trequire(signatures.length == gasNeeded.length);\r\n\t\tfor (uint8 i = 0; i < signatures.length; i++)\r\n\t\t\tgasPerTx[signatures[i]] = gasNeeded[i];\r\n\t}\r\n\r\n\t/**\r\n\t * updates the price per 1000 gas in EDG.\r\n\t * @param price the new gas price (with decimals, max 0.1 EDG)\r\n\t **/\r\n\tfunction setGasPrice(uint price) public onlyAuthorized {\r\n\t\trequire(price < oneEDG/10);\r\n\t\tgasPrice = price;\r\n\t}\r\n\r\n\t/**\r\n\t * returns the gas cost of the called function.\r\n\t * */\r\n\tfunction getGasCost() internal view returns(uint) {\r\n\t\treturn safeMul(safeMul(gasPerTx[msg.sig], gasPrice), tx.gasprice) / 1000000000;\r\n\t}\r\n\r\n}\r\n\r\n\r\ncontract CasinoBank is chargingGas {\r\n\t/** the total balance of all players with virtual decimals **/\r\n\tuint public playerBalance;\r\n\t/** the balance per player in edgeless tokens with virtual decimals */\r\n\tmapping(address => uint) public balanceOf;\r\n\t/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */\r\n\tmapping(address => uint) public withdrawAfter;\r\n\t/** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */\r\n\tmapping(address => uint) public withdrawCount;\r\n\t/** the maximum amount of tokens the user is allowed to deposit (with decimals) */\r\n\tuint public maxDeposit;\r\n\t/** the maximum withdrawal of tokens the user is allowed to withdraw on one day (only enforced when the tx is not sent from an authorized wallet) **/\r\n\tuint public maxWithdrawal;\r\n\t/** waiting time for withdrawal if not requested via the server **/\r\n\tuint public waitingTime;\r\n\t/** the address of the predecessor **/\r\n\taddress public predecessor;\r\n\r\n\t/** informs listeners how many tokens were deposited for a player */\r\n\tevent Deposit(address _player, uint _numTokens, uint _gasCost);\r\n\t/** informs listeners how many tokens were withdrawn from the player to the receiver address */\r\n\tevent Withdrawal(address _player, address _receiver, uint _numTokens, uint _gasCost);\r\n\t\r\n\t\r\n\t/**\r\n\t * Constructor.\r\n\t * @param depositLimit    the maximum deposit allowed\r\n\t *\t\t  predecessorAddr the address of the predecessing contract\r\n\t * */\r\n\tfunction CasinoBank(uint depositLimit, address predecessorAddr) internal {\r\n\t\tmaxDeposit = depositLimit * oneEDG;\r\n\t\tmaxWithdrawal = maxDeposit;\r\n\t\twaitingTime = 24 hours;\r\n\t\tpredecessor = predecessorAddr;\r\n\t}\r\n\r\n\t/**\r\n\t * accepts deposits for an arbitrary address.\r\n\t * retrieves tokens from the message sender and adds them to the balance of the specified address.\r\n\t * edgeless tokens do not have any decimals, but are represented on this contract with decimals.\r\n\t * @param receiver  address of the receiver\r\n\t *        numTokens number of tokens to deposit (0 decimals)\r\n\t *\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user's edgeless token balance\r\n\t **/\r\n\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive {\r\n\t\trequire(numTokens > 0);\r\n\t\tuint value = safeMul(numTokens, oneEDG);\r\n\t\tuint gasCost;\r\n\t\tif (chargeGas) {\r\n\t\t\tgasCost = getGasCost();\r\n\t\t\tvalue = safeSub(value, gasCost);\r\n\t\t\tgasPayback = safeAdd(gasPayback, gasCost);\r\n\t\t}\r\n\t\tuint newBalance = safeAdd(balanceOf[receiver], value);\r\n\t\trequire(newBalance <= maxDeposit);\r\n\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\r\n\t\tbalanceOf[receiver] = newBalance;\r\n\t\tplayerBalance = safeAdd(playerBalance, value);\r\n\t\tDeposit(receiver, numTokens, gasCost);\r\n\t}\r\n\r\n\t/**\r\n\t * If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first.\r\n\t * This method sets the earliest possible withdrawal date to 'waitingTime from now (default 90m, but up to 24h).\r\n\t * Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined.\r\n\t **/\r\n\tfunction requestWithdrawal() public {\r\n\t\twithdrawAfter[msg.sender] = now + waitingTime;\r\n\t}\r\n\r\n\t/**\r\n\t * In case the user requested a withdrawal and changes his mind.\r\n\t * Necessary to be able to continue playing.\r\n\t **/\r\n\tfunction cancelWithdrawalRequest() public {\r\n\t\twithdrawAfter[msg.sender] = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * withdraws an amount from the user balance if the waiting time passed since the request.\r\n\t * @param amount the amount of tokens to withdraw\r\n\t **/\r\n\tfunction withdraw(uint amount) public keepAlive {\r\n\t\trequire(amount <= maxWithdrawal);\r\n\t\trequire(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]);\r\n\t\twithdrawAfter[msg.sender] = 0;\r\n\t\tuint value = safeMul(amount, oneEDG);\r\n\t\tbalanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);\r\n\t\tplayerBalance = safeSub(playerBalance, value);\r\n\t\tassert(edg.transfer(msg.sender, amount));\r\n\t\tWithdrawal(msg.sender, msg.sender, amount, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * lets the owner withdraw from the bankroll\r\n\t * @param receiver the receiver's address\r\n\t *\t\t\t\tnumTokens the number of tokens to withdraw (0 decimals)\r\n\t **/\r\n\tfunction withdrawBankroll(address receiver, uint numTokens) public onlyAuthorized {\r\n\t\trequire(numTokens <= bankroll());\r\n\t\trequire(allowedReceiver[receiver]);\r\n\t\tassert(edg.transfer(receiver, numTokens));\r\n\t}\r\n\r\n\t/**\r\n\t * withdraw the gas payback to the owner\r\n\t **/\r\n\tfunction withdrawGasPayback() public onlyAuthorized {\r\n\t\tuint payback = gasPayback / oneEDG;\r\n\t\tassert(payback > 0);\r\n\t\tgasPayback = safeSub(gasPayback, payback * oneEDG);\r\n\t\tassert(edg.transfer(owner, payback));\r\n\t}\r\n\r\n\t/**\r\n\t * returns the current bankroll in tokens with 0 decimals\r\n\t **/\r\n\tfunction bankroll() constant public returns(uint) {\r\n\t\treturn safeSub(edg.balanceOf(address(this)), safeAdd(playerBalance, gasPayback) / oneEDG);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * updates the maximum deposit.\r\n\t * @param newMax the new maximum deposit (0 decimals)\r\n\t **/\r\n\tfunction setMaxDeposit(uint newMax) public onlyAuthorized {\r\n\t\tmaxDeposit = newMax * oneEDG;\r\n\t}\r\n\t\r\n\t/**\r\n\t * updates the maximum withdrawal.\r\n\t * @param newMax the new maximum withdrawal (0 decimals)\r\n\t **/\r\n\tfunction setMaxWithdrawal(uint newMax) public onlyAuthorized {\r\n\t\tmaxWithdrawal = newMax * oneEDG;\r\n\t}\r\n\r\n\t/**\r\n\t * sets the time the player has to wait for his funds to be unlocked before withdrawal (if not withdrawing with help of the casino server).\r\n\t * the time may not be longer than 24 hours.\r\n\t * @param newWaitingTime the new waiting time in seconds\r\n\t * */\r\n\tfunction setWaitingTime(uint newWaitingTime) public onlyAuthorized  {\r\n\t\trequire(newWaitingTime <= 24 hours);\r\n\t\twaitingTime = newWaitingTime;\r\n\t}\r\n\r\n\t/**\r\n\t * transfers an amount from the contract balance to the owner's wallet.\r\n\t * @param receiver the receiver address\r\n\t *\t\t\t\t amount   the amount of tokens to withdraw (0 decimals)\r\n\t *\t\t\t\t v,r,s \t\tthe signature of the player\r\n\t **/\r\n\tfunction withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive {\r\n\t\taddress player = ecrecover(keccak256(receiver, amount, withdrawCount[receiver]), v, r, s);\r\n\t\twithdrawCount[receiver]++;\r\n\t\tuint gasCost = getGasCost();\r\n\t\tuint value = safeAdd(safeMul(amount, oneEDG), gasCost);\r\n\t\tgasPayback = safeAdd(gasPayback, gasCost);\r\n\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\r\n\t\tplayerBalance = safeSub(playerBalance, value);\r\n\t\tassert(edg.transfer(receiver, amount));\r\n\t\tWithdrawal(player, receiver, amount, gasCost);\r\n\t}\r\n\t\r\n\t/**\r\n\t * transfers the player's tokens directly to the new casino contract after an update.\r\n\t * @param newCasino the address of the new casino contract\r\n\t *\t\t  v, r, s   the signature of the player\r\n\t *\t\t  chargeGas indicates if the gas cost is payed by the player.\r\n\t * */\r\n\tfunction transferToNewContract(address newCasino, uint8 v, bytes32 r, bytes32 s, bool chargeGas) public onlyAuthorized keepAlive {\r\n\t\taddress player = ecrecover(keccak256(address(this), newCasino), v, r, s);\r\n\t\tuint gasCost = 0;\r\n\t\tif(chargeGas) gasCost = getGasCost();\r\n\t\tuint value = safeSub(balanceOf[player], gasCost);\r\n\t\trequire(value > oneEDG);\r\n\t\t//fractions of one EDG cannot be withdrawn \r\n\t\tvalue /= oneEDG;\r\n\t\tplayerBalance = safeSub(playerBalance, balanceOf[player]);\r\n\t\tbalanceOf[player] = 0;\r\n\t\tassert(edg.transfer(newCasino, value));\r\n\t\tWithdrawal(player, newCasino, value, gasCost);\r\n\t\tCasinoBank cb = CasinoBank(newCasino);\r\n\t\tassert(cb.credit(player, value));\r\n\t}\r\n\t\r\n\t/**\r\n\t * receive a player balance from the predecessor contract.\r\n\t * @param player the address of the player to credit the value for\r\n\t *\t\t\t\tvalue  the number of tokens to credit (0 decimals)\r\n\t * */\r\n\tfunction credit(address player, uint value) public returns(bool) {\r\n\t\trequire(msg.sender == predecessor);\r\n\t\tuint valueWithDecimals = safeMul(value, oneEDG);\r\n\t\tbalanceOf[player] = safeAdd(balanceOf[player], valueWithDecimals);\r\n\t\tplayerBalance = safeAdd(playerBalance, valueWithDecimals);\r\n\t\tDeposit(player, value, 0);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days\r\n\t * */\r\n\tfunction close() public onlyOwner {\r\n\t\tcloseContract(playerBalance);\r\n\t}\r\n}\r\n\r\n\r\ncontract EdgelessCasino is CasinoBank{\r\n\t/** the most recent known state of a state channel */\r\n\tmapping(address => State) public lastState;\r\n\t/** fired when the state is updated */\r\n\tevent StateUpdate(address player, uint128 count, int128 winBalance, int difference, uint gasCost);\r\n  /** fired if one of the parties chooses to log the seeds and results */\r\n  event GameData(address player, bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint gasCost);\r\n  \r\n\tstruct State{\r\n\t\tuint128 count;\r\n\t\tint128 winBalance;\r\n\t}\r\n\r\n\r\n  /**\r\n  * creates a new edgeless casino contract.\r\n  * @param predecessorAddress the address of the predecessing contract\r\n\t*\t\t\t\t tokenContract      the address of the Edgeless token contract\r\n\t* \t\t\t depositLimit       the maximum deposit allowed\r\n\t* \t\t\t kGasPrice\t\t\t\t  the price per kGas in WEI\r\n  **/\r\n  function EdgelessCasino(address predecessorAddress, address tokenContract, uint depositLimit, uint kGasPrice) CasinoBank(depositLimit, predecessorAddress) mortal(tokenContract) chargingGas(kGasPrice) public{\r\n\r\n  }\r\n  \r\n  /**\r\n   * updates several state channels at once. can be called by authorized wallets only.\r\n   * 1. determines the player address from the signature.\r\n   * 2. verifies if the signed game-count is higher than the last known game-count of this channel.\r\n   * 3. updates the balances accordingly. This means: It checks the already performed updates for this channel and computes\r\n   *    the new balance difference to add or subtract from the player‘s balance.\r\n   * @param winBalances array of the current wins or losses\r\n   *\t\t\t\tgameCounts  array of the numbers of signed game moves\r\n   *\t\t\t\tv,r,s       array of the players's signatures\r\n   *        chargeGas   indicates if the gas costs should be subtracted from the players's balances\r\n   * */\r\n  function updateBatch(int128[] winBalances,  uint128[] gameCounts, uint8[] v, bytes32[] r, bytes32[] s, bool chargeGas) public onlyAuthorized{\r\n    require(winBalances.length == gameCounts.length);\r\n    require(winBalances.length == v.length);\r\n    require(winBalances.length == r.length);\r\n    require(winBalances.length == s.length);\r\n    require(winBalances.length <= 50);\r\n    address player;\r\n    uint gasCost = 0;\r\n    if(chargeGas) \r\n      gasCost = getGasCost();\r\n    gasPayback = safeAdd(gasPayback, safeMul(gasCost, winBalances.length));\r\n    for(uint8 i = 0; i < winBalances.length; i++){\r\n      player = ecrecover(keccak256(winBalances[i], gameCounts[i]), v[i], r[i], s[i]);\r\n      _updateState(player, winBalances[i], gameCounts[i], gasCost);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * updates a state channel. can be called by both parties.\r\n   * 1. verifies the signature.\r\n   * 2. verifies if the signed game-count is higher than the last known game-count of this channel.\r\n   * 3. updates the balances accordingly. This means: It checks the already performed updates for this channel and computes\r\n   *    the new balance difference to add or subtract from the player‘s balance.\r\n   * @param winBalance the current win or loss\r\n   *\t\t\t\tgameCount  the number of signed game moves\r\n   *\t\t\t\tv,r,s      the signature of either the casino or the player\r\n   *        chargeGas  indicates if the gas costs should be subtracted from the player's balance\r\n   * */\r\n  function updateState(int128 winBalance,  uint128 gameCount, uint8 v, bytes32 r, bytes32 s, bool chargeGas) public{\r\n  \taddress player = determinePlayer(winBalance, gameCount, v, r, s);\r\n  \tuint gasCost = 0;\r\n  \tif(player == msg.sender)//if the player closes the state channel himself, make sure the signer is a casino wallet\r\n  \t\trequire(authorized[ecrecover(keccak256(player, winBalance, gameCount), v, r, s)]);\r\n  \telse if (chargeGas){//subtract the gas costs from the player balance only if the casino wallet is the sender\r\n  \t\tgasCost = getGasCost();\r\n  \t\tgasPayback = safeAdd(gasPayback, gasCost);\r\n  \t}\r\n  \t_updateState(player, winBalance, gameCount, gasCost);\r\n  }\r\n  \r\n  /**\r\n   * internal method to perform the actual state update.\r\n   * @param player the player address\r\n   *        winBalance the player's win balance\r\n   *        gameCount  the player's game count\r\n   * */\r\n  function _updateState(address player, int128 winBalance,  uint128 gameCount, uint gasCost) internal {\r\n    State storage last = lastState[player];\r\n  \trequire(gameCount > last.count);\r\n  \tint difference = updatePlayerBalance(player, winBalance, last.winBalance, gasCost);\r\n  \tlastState[player] = State(gameCount, winBalance);\r\n  \tStateUpdate(player, gameCount, winBalance, difference, gasCost);\r\n  }\r\n\r\n  /**\r\n   * determines if the msg.sender or the signer of the passed signature is the player. returns the player's address\r\n   * @param winBalance the current winBalance, used to calculate the msg hash\r\n   *\t\t\t\tgameCount  the current gameCount, used to calculate the msg.hash\r\n   *\t\t\t\tv, r, s    the signature of the non-sending party\r\n   * */\r\n  function determinePlayer(int128 winBalance, uint128 gameCount, uint8 v, bytes32 r, bytes32 s) constant internal returns(address){\r\n  \tif (authorized[msg.sender])//casino is the sender -> player is the signer\r\n  \t\treturn ecrecover(keccak256(winBalance, gameCount), v, r, s);\r\n  \telse\r\n  \t\treturn msg.sender;\r\n  }\r\n\r\n\t/**\r\n\t * computes the difference of the win balance relative to the last known state and adds it to the player's balance.\r\n\t * in case the casino is the sender, the gas cost in EDG gets subtracted from the player's balance.\r\n\t * @param player the address of the player\r\n\t *\t\t\t\twinBalance the current win-balance\r\n\t *\t\t\t\tlastWinBalance the win-balance of the last known state\r\n\t *\t\t\t\tgasCost the gas cost of the tx\r\n\t * */\r\n  function updatePlayerBalance(address player, int128 winBalance, int128 lastWinBalance, uint gasCost) internal returns(int difference){\r\n  \tdifference = safeSub(winBalance, lastWinBalance);\r\n  \tint outstanding = safeSub(difference, int(gasCost));\r\n  \tuint outs;\r\n  \tif(outstanding < 0){\r\n  \t\touts = uint256(outstanding * (-1));\r\n  \t\tplayerBalance = safeSub(playerBalance, outs);\r\n  \t\tbalanceOf[player] = safeSub(balanceOf[player], outs);\r\n  \t}\r\n  \telse{\r\n  \t\touts = uint256(outstanding);\r\n  \t\tassert(bankroll() * oneEDG > outs);\r\n  \t  playerBalance = safeAdd(playerBalance, outs);\r\n  \t  balanceOf[player] = safeAdd(balanceOf[player], outs);\r\n  \t}\r\n  }\r\n  \r\n  /**\r\n   * logs some seeds and game results for players wishing to have their game history logged by the contract\r\n   * @param serverSeeds array containing the server seeds\r\n   *        clientSeeds array containing the client seeds\r\n   *        results     array containing the results\r\n   *        v, r, s     the signature of the non-sending party (to make sure the correct results are logged)\r\n   * */\r\n  function logGameData(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) public{\r\n    address player = determinePlayer(serverSeeds, clientSeeds, results, v, r, s);\r\n    uint gasCost;\r\n    //charge gas in case the server is logging the results for the player\r\n    if(player != msg.sender){\r\n      gasCost = (57 + 768 * serverSeeds.length / 1000)*gasPrice;\r\n      balanceOf[player] = safeSub(balanceOf[player], gasCost);\r\n      playerBalance = safeSub(playerBalance, gasCost);\r\n      gasPayback = safeAdd(gasPayback, gasCost);\r\n    }\r\n    GameData(player, serverSeeds, clientSeeds, results, gasCost);\r\n  }\r\n  \r\n  /**\r\n   * determines if the msg.sender or the signer of the passed signature is the player. returns the player's address\r\n   * @param serverSeeds array containing the server seeds\r\n   *        clientSeeds array containing the client seeds\r\n   *        results     array containing the results\r\n   *\t\t\t\tv, r, s    the signature of the non-sending party\r\n   * */\r\n  function determinePlayer(bytes32[] serverSeeds, bytes32[] clientSeeds, int[] results, uint8 v, bytes32 r, bytes32 s) constant internal returns(address){\r\n  \taddress signer = ecrecover(keccak256(serverSeeds, clientSeeds, results), v, r, s);\r\n  \tif (authorized[msg.sender])//casino is the sender -> player is the signer\r\n  \t\treturn signer;\r\n  \telse if (authorized[signer])\r\n  \t\treturn msg.sender;\r\n  \telse \r\n  \t  revert();\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"serverSeeds\",\"type\":\"bytes32[]\"},{\"name\":\"clientSeeds\",\"type\":\"bytes32[]\"},{\"name\":\"results\",\"type\":\"int256[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"logGameData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankroll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"disallowReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signatures\",\"type\":\"bytes4[5]\"},{\"name\":\"gasNeeded\",\"type\":\"uint256[5]\"}],\"name\":\"setGasUsage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastState\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint128\"},{\"name\":\"winBalance\",\"type\":\"int128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaxWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"numTokens\",\"type\":\"uint256\"},{\"name\":\"chargeGas\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawAfter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCasino\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"chargeGas\",\"type\":\"bool\"}],\"name\":\"transferToNewContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oneEDG\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closeAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"gasPerTx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"predecessor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMax\",\"type\":\"uint256\"}],\"name\":\"setMaxDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"allowReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winBalances\",\"type\":\"int128[]\"},{\"name\":\"gameCounts\",\"type\":\"uint128[]\"},{\"name\":\"v\",\"type\":\"uint8[]\"},{\"name\":\"r\",\"type\":\"bytes32[]\"},{\"name\":\"s\",\"type\":\"bytes32[]\"},{\"name\":\"chargeGas\",\"type\":\"bool\"}],\"name\":\"updateBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"requestWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"winBalance\",\"type\":\"int128\"},{\"name\":\"gameCount\",\"type\":\"uint128\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"chargeGas\",\"type\":\"bool\"}],\"name\":\"updateState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPayback\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelWithdrawalRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWaitingTime\",\"type\":\"uint256\"}],\"name\":\"setWaitingTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"credit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawGasPayback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"predecessorAddress\",\"type\":\"address\"},{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"depositLimit\",\"type\":\"uint256\"},{\"name\":\"kGasPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"winBalance\",\"type\":\"int128\"},{\"indexed\":false,\"name\":\"difference\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"StateUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"serverSeeds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"clientSeeds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"results\",\"type\":\"int256[]\"},{\"indexed\":false,\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"GameData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gasCost\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gasCost\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"}]","ContractName":"EdgelessCasino","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000015f08079310e2c9dacaa73c0e450368185724aea00000000000000000000000008711d3b02c8758f2fb3ab4e80228418a7f8e39c00000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000032","Library":"","SwarmSource":"bzzr://8a99b2b81985b9f4333dd5a0b09e78f48d645921a186452e5beb2356d91d4d84"}]}