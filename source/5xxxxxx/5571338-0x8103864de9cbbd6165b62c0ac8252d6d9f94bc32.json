{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract GoCryptobotAccessControl {\r\n    address public owner;\r\n    address public operator;\r\n\r\n    bool public paused;\r\n\r\n    modifier onlyOwner() {require(msg.sender == owner); _;}\r\n    modifier onlyOperator() {require(msg.sender == operator); _;}\r\n    modifier onlyOwnerOrOperator() {require(msg.sender == owner || msg.sender == operator); _;}\r\n\r\n    modifier whenPaused() {require(paused); _;}\r\n    modifier whenNotPaused() {require(!paused); _;}\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n    function transferOperator(address newOperator) public onlyOwner {\r\n        require(newOperator != address(0));\r\n        operator = newOperator;\r\n    }\r\n\r\n    function pause() public onlyOwnerOrOperator whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract GoCryptobotRandom is GoCryptobotAccessControl {\r\n    uint commitmentNumber;\r\n    bytes32 randomBytes;\r\n\r\n    function commitment() public onlyOperator {\r\n        commitmentNumber = block.number;\r\n    }\r\n\r\n    function _initRandom() internal {\r\n        require(commitmentNumber < block.number);\r\n\r\n        if (commitmentNumber < block.number - 255) {\r\n            randomBytes = block.blockhash(block.number - 1);\r\n        } else {\r\n            randomBytes = block.blockhash(commitmentNumber);\r\n        }\r\n    }\r\n\r\n    function _shuffle(uint8[] deck) internal {\r\n        require(deck.length < 256);\r\n\r\n        uint8 deckLength = uint8(deck.length);\r\n        uint8 random;\r\n        for (uint8 i = 0; i < deckLength; i++) {\r\n            if (i % 32 == 0) {\r\n                randomBytes = keccak256(randomBytes);\r\n            }\r\n            random = uint8(randomBytes[i % 32]) % (deckLength - i);\r\n\r\n            if (random != deckLength - 1 - i) {\r\n                deck[random] ^= deck[deckLength - 1 - i];\r\n                deck[deckLength - 1 - i] ^= deck[random];\r\n                deck[random] ^= deck[deckLength - 1 - i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function _random256() internal returns(uint256) {\r\n        randomBytes = keccak256(randomBytes);\r\n        return uint256(randomBytes);\r\n    }\r\n}\r\n\r\ncontract GoCryptobotScore is GoCryptobotRandom {\r\n    // A part's skill consists of color and level. (Total 2 bytes)\r\n    //   1   2\r\n    // Skill\r\n    // +---+---+\r\n    // | C | L +\r\n    // +---+---+\r\n    //\r\n    // C = Color, 0 ~ 4.\r\n    // L = Level, 0 ~ 8.\r\n    //\r\n    uint256 constant PART_SKILL_SIZE = 2;\r\n\r\n    // A part consists of level and 3 skills. (Total 7 bytes)\r\n    //   1   2   3   4   5   6   7\r\n    // Part\r\n    // +---+---+---+---+---+---+---+\r\n    // | L | Skill | Skill | Skill |\r\n    // +---+---+---+---+---+---+---+\r\n    //\r\n    // L = Level, 1 ~ 50.\r\n    //\r\n    // A part doesn't contains color because individual color doesn't affect to\r\n    // the score, but it is used to calculate player's theme color.\r\n    //\r\n    uint256 constant PART_BASE_SIZE = 1;\r\n    uint256 constant PART_SIZE = PART_BASE_SIZE + 3 * PART_SKILL_SIZE;\r\n\r\n    // A player consists of theme effect and 4 parts. (Total 29 bytes)\r\n    //   1   2   3   4   5   6   7\r\n    // Player\r\n    // +---+\r\n    // | C |\r\n    // +---+---+---+---+---+---+---+\r\n    // |         HEAD PART         |\r\n    // +---+---+---+---+---+---+---+\r\n    // |         BODY PART         |\r\n    // +---+---+---+---+---+---+---+\r\n    // |         LEGS PART         |\r\n    // +---+---+---+---+---+---+---+\r\n    // |         BOOSTER PART      |\r\n    // +---+---+---+---+---+---+---+\r\n    //\r\n    // C = Whether player's theme effect is enabled or not, 1 or 0.\r\n    //\r\n    // The theme effect is set to 1 iff the theme of each part are identical.\r\n    //\r\n    uint256 constant PLAYER_BASE_SIZE = 1;\r\n    uint256 constant PLAYER_SIZE = PLAYER_BASE_SIZE + PART_SIZE * 4;\r\n\r\n    enum PartType {HEAD, BODY, LEGS, BOOSTER}\r\n    enum EventType {BOWLING, HANGING, SPRINT, HIGH_JUMP}\r\n    enum EventColor {NONE, YELLOW, BLUE, GREEN, RED}\r\n\r\n    function _getPartLevel(bytes data, uint partOffset) internal pure returns(uint8) {\r\n        return uint8(data[partOffset + 0]);\r\n    }\r\n    // NOTE: _getPartSkillColor is called up to 128 * 4 * 3 times. Explicit\r\n    // conversion to EventColor could be costful.\r\n    function _getPartSkillColor(bytes data, uint partOffset, uint skillIndex) internal pure returns(byte) {\r\n        return data[partOffset + PART_BASE_SIZE + (skillIndex * PART_SKILL_SIZE) + 0];\r\n    }\r\n    function _getPartSkillLevel(bytes data, uint partOffset, uint skillIndex) internal pure returns(uint8) {\r\n        return uint8(data[partOffset + PART_BASE_SIZE + (skillIndex * PART_SKILL_SIZE) + 1]);\r\n    }\r\n\r\n    function _getPlayerThemeEffect(bytes data, uint playerOffset) internal pure returns(byte) {\r\n        return data[playerOffset + 0];\r\n    }\r\n\r\n    function _getPlayerEventScore(bytes data, uint playerIndex, EventType eventType, EventColor _eventMajorColor, EventColor _eventMinorColor) internal pure returns(uint) {\r\n        uint partOffset = (PLAYER_SIZE * playerIndex) + PLAYER_BASE_SIZE + (uint256(eventType) * PART_SIZE);\r\n        uint level = _getPartLevel(data, partOffset);\r\n        uint majorSkillSum = 0;\r\n        uint minorSkillSum = 0;\r\n\r\n        byte eventMajorColor = byte(uint8(_eventMajorColor));\r\n        byte eventMinorColor = byte(uint8(_eventMinorColor));\r\n        for (uint i = 0; i < 3; i++) {\r\n            byte skillColor = _getPartSkillColor(data, partOffset, i);\r\n            if (skillColor == eventMajorColor) {\r\n                majorSkillSum += _getPartSkillLevel(data, partOffset, i);\r\n            } else if (skillColor == eventMinorColor) {\r\n                minorSkillSum += _getPartSkillLevel(data, partOffset, i);\r\n            }\r\n        }\r\n        byte playerThemeEffect = _getPlayerThemeEffect(data, PLAYER_SIZE * playerIndex);\r\n        if (playerThemeEffect != 0) {\r\n            return level + (majorSkillSum * 4) + (minorSkillSum * 2);\r\n        } else {\r\n            return level + (majorSkillSum * 3) + (minorSkillSum * 1);\r\n        }\r\n    }\r\n}\r\n\r\ncontract GoCryptobotRounds is GoCryptobotScore {\r\n    event RoundFinished(EventType eventType, EventColor eventMajorColor, EventColor eventMinorColor, uint scoreA, uint scoreB, uint scoreC, uint scoreD);\r\n    event AllFinished(uint scoreA, uint scoreB, uint scoreC, uint scoreD);\r\n    event WinnerTeam(uint8[4] candidates, uint8 winner);\r\n\r\n    function run(bytes playerData, uint8[4] eventTypes, uint8[2][4] eventColors) public onlyOperator {\r\n        require(playerData.length == 128 * PLAYER_SIZE);\r\n\r\n        _initRandom();\r\n\r\n        uint8[] memory colorSelection = new uint8[](8);\r\n        colorSelection[0] = 0;\r\n        colorSelection[1] = 1;\r\n        colorSelection[2] = 0;\r\n        colorSelection[3] = 1;\r\n        colorSelection[4] = 0;\r\n        colorSelection[5] = 1;\r\n        colorSelection[6] = 0;\r\n        colorSelection[7] = 1;\r\n\r\n        _shuffle(colorSelection);\r\n\r\n        uint[4] memory totalScores;\r\n        for (uint8 i = 0; i < 4; i++) {\r\n            uint8 majorColor = eventColors[i][colorSelection[i]];\r\n            uint8 minorColor = eventColors[i][colorSelection[i]^1];\r\n            uint[4] memory roundScores = _round(playerData, EventType(eventTypes[i]), EventColor(majorColor), EventColor(minorColor));\r\n            totalScores[0] += roundScores[0];\r\n            totalScores[1] += roundScores[1];\r\n            totalScores[2] += roundScores[2];\r\n            totalScores[3] += roundScores[3];\r\n        }\r\n        AllFinished(totalScores[0], totalScores[1], totalScores[2], totalScores[3]);\r\n\r\n        uint maxScore;\r\n        uint maxCount;\r\n        uint8[4] memory candidates;\r\n        for (i = 0; i < 4; i++) {\r\n            if (maxScore < totalScores[i]) {\r\n                maxScore = totalScores[i];\r\n                maxCount = 0;\r\n                candidates[maxCount++] = i + 1;\r\n            } else if (maxScore == totalScores[i]) {\r\n                candidates[maxCount++] = i + 1;\r\n            }\r\n        }\r\n        assert(maxCount > 0);\r\n        if (maxCount == 1) {\r\n            WinnerTeam(candidates, candidates[0]);\r\n        } else {\r\n            WinnerTeam(candidates, candidates[_random256() % maxCount]);\r\n        }\r\n    }\r\n\r\n    function _round(bytes memory playerData, EventType eventType, EventColor eventMajorColor, EventColor eventMinorColor) internal returns(uint[4]) {\r\n        uint numOfPlayers = playerData.length / PLAYER_SIZE;\r\n        uint[4] memory scores;\r\n        for (uint i = 0; i < numOfPlayers; i++) {\r\n            scores[i / (numOfPlayers / 4)] += _getPlayerEventScore(playerData, i, eventType, eventMajorColor, eventMinorColor);\r\n        }\r\n        RoundFinished(eventType, eventMajorColor, eventMinorColor, scores[0], scores[1], scores[2], scores[3]);\r\n        return scores;\r\n    }\r\n}\r\n\r\ncontract GoCryptobotCore is GoCryptobotRounds {\r\n    function GoCryptobotCore() public {\r\n        paused = false;\r\n\r\n        owner = msg.sender;\r\n        operator = msg.sender;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"commitment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"playerData\",\"type\":\"bytes\"},{\"name\":\"eventTypes\",\"type\":\"uint8[4]\"},{\"name\":\"eventColors\",\"type\":\"uint8[2][4]\"}],\"name\":\"run\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"eventType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"eventMajorColor\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"eventMinorColor\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"scoreA\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"scoreB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"scoreC\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"scoreD\",\"type\":\"uint256\"}],\"name\":\"RoundFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"scoreA\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"scoreB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"scoreC\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"scoreD\",\"type\":\"uint256\"}],\"name\":\"AllFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"candidates\",\"type\":\"uint8[4]\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"uint8\"}],\"name\":\"WinnerTeam\",\"type\":\"event\"}]","ContractName":"GoCryptobotCore","CompilerVersion":"v0.4.22+commit.4cb486ee","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8e57320567b1b012a1608aa1c8b3334a48c4165257f6ed2952f639b5ea104e84"}]}