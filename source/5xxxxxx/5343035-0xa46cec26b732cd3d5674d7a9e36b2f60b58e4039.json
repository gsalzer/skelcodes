{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public constant returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amout of tokens to be transfered\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        var _allowance = allowed[_from][msg.sender];\r\n\r\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n        // require (_value <= _allowance);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = _allowance.sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifing the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnerLog(address a);\r\n\r\n}\r\n\r\ncontract Configurable is Ownable {\r\n\r\n    address public configurer;\r\n\r\n    function Configurable() public {\r\n        configurer = msg.sender;\r\n    }\r\n\r\n    modifier onlyConfigurerOrOwner() {\r\n        require(msg.sender == configurer || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyConfigurer() {\r\n        require(msg.sender == configurer);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DLCToken is StandardToken, Configurable {\r\n\r\n    string public constant name = \"DoubleLand Coin\";\r\n    string public constant symbol = \"DLC\";\r\n    uint32 public constant decimals = 18;\r\n\r\n    uint256 public priceOfToken;\r\n\r\n    bool tokenBeenInit = false;\r\n\r\n    uint public constant percentRate = 100;\r\n    uint public investorsTokensPercent;\r\n    uint public foundersTokensPercent;\r\n    uint public bountyTokensPercent;\r\n    uint public developmentAuditPromotionTokensPercent;\r\n\r\n    address public toSaleWallet;\r\n    address public bountyWallet;\r\n    address public foundersWallet;\r\n    address public developmentAuditPromotionWallet;\r\n\r\n    address public saleAgent;\r\n\r\n\r\n    function DLCToken() public {\r\n    }\r\n\r\n    modifier notInit() {\r\n        require(!tokenBeenInit);\r\n        _;\r\n    }\r\n\r\n    function setSaleAgent(address newSaleAgent) public onlyConfigurerOrOwner{\r\n        saleAgent = newSaleAgent;\r\n    }\r\n\r\n    function setPriceOfToken(uint256 newPriceOfToken) public onlyConfigurerOrOwner{\r\n        priceOfToken = newPriceOfToken;\r\n    }\r\n\r\n    function setTotalSupply(uint256 _totalSupply) public notInit onlyConfigurer{\r\n        totalSupply = _totalSupply;\r\n    }\r\n\r\n    function setFoundersTokensPercent(uint _foundersTokensPercent) public notInit onlyConfigurer{\r\n        foundersTokensPercent = _foundersTokensPercent;\r\n    }\r\n\r\n    function setBountyTokensPercent(uint _bountyTokensPercent) public notInit onlyConfigurer{\r\n        bountyTokensPercent = _bountyTokensPercent;\r\n    }\r\n\r\n    function setDevelopmentAuditPromotionTokensPercent(uint _developmentAuditPromotionTokensPercent) public notInit onlyConfigurer{\r\n        developmentAuditPromotionTokensPercent = _developmentAuditPromotionTokensPercent;\r\n    }\r\n\r\n    function setBountyWallet(address _bountyWallet) public notInit onlyConfigurer{\r\n        bountyWallet = _bountyWallet;\r\n    }\r\n\r\n    function setToSaleWallet(address _toSaleWallet) public notInit onlyConfigurer{\r\n        toSaleWallet = _toSaleWallet;\r\n    }\r\n\r\n    function setFoundersWallet(address _foundersWallet) public notInit onlyConfigurer{\r\n        foundersWallet = _foundersWallet;\r\n    }\r\n\r\n    function setDevelopmentAuditPromotionWallet(address _developmentAuditPromotionWallet) public notInit onlyConfigurer {\r\n        developmentAuditPromotionWallet = _developmentAuditPromotionWallet;\r\n    }\r\n\r\n    function init() public notInit onlyConfigurer{\r\n        require(totalSupply > 0);\r\n        require(foundersTokensPercent > 0);\r\n        require(bountyTokensPercent > 0);\r\n        require(developmentAuditPromotionTokensPercent > 0);\r\n        require(foundersWallet != address(0));\r\n        require(bountyWallet != address(0));\r\n        require(developmentAuditPromotionWallet != address(0));\r\n        tokenBeenInit = true;\r\n\r\n        investorsTokensPercent = percentRate - (foundersTokensPercent + bountyTokensPercent + developmentAuditPromotionTokensPercent);\r\n\r\n        balances[toSaleWallet] = totalSupply.mul(investorsTokensPercent).div(percentRate);\r\n        balances[foundersWallet] = totalSupply.mul(foundersTokensPercent).div(percentRate);\r\n        balances[bountyWallet] = totalSupply.mul(bountyTokensPercent).div(percentRate);\r\n        balances[developmentAuditPromotionWallet] = totalSupply.mul(developmentAuditPromotionTokensPercent).div(percentRate);\r\n    }\r\n\r\n    function getRestTokenBalance() public constant returns (uint256) {\r\n        return balances[toSaleWallet];\r\n    }\r\n\r\n    function purchase(address beneficiary, uint256 qty) public {\r\n        require(msg.sender == saleAgent || msg.sender == owner);\r\n        require(beneficiary != address(0));\r\n        require(qty > 0);\r\n        require((getRestTokenBalance().sub(qty)) > 0);\r\n\r\n        balances[beneficiary] = balances[beneficiary].add(qty);\r\n        balances[toSaleWallet] = balances[toSaleWallet].sub(qty);\r\n\r\n        Transfer(toSaleWallet, beneficiary, qty);\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}\r\n\r\ncontract Bonuses {\r\n    using SafeMath for uint256;\r\n\r\n    DLCToken public token;\r\n\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    mapping(uint => uint256) public bonusOfDay;\r\n\r\n    bool public bonusInited = false;\r\n\r\n    function initBonuses (string _preset) public {\r\n        require(!bonusInited);\r\n        bonusInited = true;\r\n        bytes32 preset = keccak256(_preset);\r\n\r\n        if(preset == keccak256('privatesale')){\r\n            bonusOfDay[0] = 313;\r\n        } else\r\n        if(preset == keccak256('presale')){\r\n            bonusOfDay[0] = 210;\r\n        } else\r\n        if(preset == keccak256('generalsale')){\r\n            bonusOfDay[0] = 60;\r\n            bonusOfDay[7] = 38;\r\n            bonusOfDay[14] = 10;\r\n        }\r\n    }\r\n\r\n    function calculateTokensQtyByEther(uint256 amount) public constant returns(uint256) {\r\n        int dayOfStart = int(now.sub(startTime).div(86400).add(1));\r\n        uint currentBonus = 0;\r\n        int i;\r\n\r\n        for (i = dayOfStart; i >= 0; i--) {\r\n            if (bonusOfDay[uint(i)] > 0) {\r\n                currentBonus = bonusOfDay[uint(i)];\r\n                break;\r\n            }\r\n        }\r\n\r\n        return amount.div(token.priceOfToken()).mul(currentBonus + 100).div(100).mul(1 ether);\r\n    }\r\n}\r\n\r\ncontract Sale is Configurable, Bonuses{\r\n    using SafeMath for uint256;\r\n\r\n    address public multisigWallet;\r\n    uint256 public tokensLimit;\r\n    uint256 public minimalPrice;\r\n    uint256 public tokensTransferred = 0;\r\n\r\n    string public bonusPreset;\r\n\r\n    uint256 public collected = 0;\r\n\r\n    bool public activated = false;\r\n    bool public closed = false;\r\n    bool public saleInited = false;\r\n\r\n\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n    function init(\r\n        string _bonusPreset,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        uint256 _tokensLimit,\r\n        uint256 _minimalPrice,\r\n        DLCToken _token,\r\n        address _multisigWallet\r\n    ) public onlyConfigurer {\r\n        require(!saleInited);\r\n        require(_startTime >= now);\r\n        require(_endTime >= _startTime);\r\n        require(_tokensLimit > 0);\r\n        require(_multisigWallet != address(0));\r\n\r\n        saleInited = true;\r\n\r\n        token = _token;\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        tokensLimit = _tokensLimit;\r\n        multisigWallet = _multisigWallet;\r\n        minimalPrice = _minimalPrice;\r\n        bonusPreset = _bonusPreset;\r\n\r\n        initBonuses(bonusPreset);\r\n    }\r\n\r\n    function activate() public onlyConfigurerOrOwner {\r\n        require(!activated);\r\n        require(!closed);\r\n        activated = true;\r\n    }\r\n\r\n    function close() public onlyConfigurerOrOwner {\r\n        activated = true;\r\n        closed = true;\r\n    }\r\n\r\n    function setMultisigWallet(address _multisigWallet) public onlyConfigurerOrOwner {\r\n        multisigWallet = _multisigWallet;\r\n    }\r\n\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function buyTokens(address beneficiary) public payable {\r\n        require(beneficiary != address(0));\r\n        require(validPurchase());\r\n\r\n        uint256 amount = msg.value;\r\n        uint256 tokens = calculateTokensQtyByEther({\r\n                amount: amount\r\n            });\r\n\r\n        require(tokensTransferred.add(tokens) < tokensLimit);\r\n\r\n        tokensTransferred = tokensTransferred.add(tokens);\r\n        collected = collected.add(amount);\r\n\r\n        token.purchase(beneficiary, tokens);\r\n        TokenPurchase(msg.sender, beneficiary, amount, tokens);\r\n\r\n        forwardFunds();\r\n    }\r\n\r\n    function forwardFunds() internal {\r\n        multisigWallet.transfer(msg.value);\r\n    }\r\n\r\n    function validPurchase() internal constant returns (bool) {\r\n        bool withinPeriod = now >= startTime && now <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        bool minimalPriceChecked = msg.value >= minimalPrice;\r\n        return withinPeriod && nonZeroPurchase && minimalPriceChecked && activated && !closed;\r\n    }\r\n\r\n    function isEnded() public constant returns (bool) {\r\n        return now > endTime;\r\n    }\r\n}\r\n\r\n\r\ncontract DoubleLandICO_TEST is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    DLCToken public token;\r\n\r\n    Sale[] public sales;\r\n\r\n    uint256 public softCap;\r\n    uint256 public hardCap;\r\n\r\n    uint public activatedSalesTotalCount = 0;\r\n    uint public maxActivatedSalesTotalCount;\r\n\r\n    address public multisigWallet;\r\n\r\n    bool public isDeployed = false;\r\n\r\n    function createSale(string _bonusPreset, uint256 _startTime, uint256 _endTime,  uint256 _tokensLimit, uint256 _minimalPrice) public onlyOwner{\r\n        require(activatedSalesTotalCount < maxActivatedSalesTotalCount);\r\n        require(getTotalCollected() < hardCap );\r\n        require(token.getRestTokenBalance() >= _tokensLimit);\r\n        require(sales.length == 0 || sales[sales.length - 1].activated());\r\n        Sale newSale = new Sale();\r\n\r\n        newSale.init({\r\n            _bonusPreset: _bonusPreset,\r\n            _startTime: _startTime,\r\n            _endTime: _endTime,\r\n            _tokensLimit: _tokensLimit,\r\n            _minimalPrice: _minimalPrice,\r\n            _token: token,\r\n            _multisigWallet: multisigWallet\r\n            });\r\n        newSale.transferOwnership(owner);\r\n\r\n        sales.push(newSale);\r\n    }\r\n\r\n    function activateLastSale() public onlyOwner {\r\n        require(activatedSalesTotalCount < maxActivatedSalesTotalCount);\r\n        require(!sales[sales.length - 1].activated());\r\n        activatedSalesTotalCount ++;\r\n        sales[sales.length - 1].activate();\r\n        token.setSaleAgent(sales[sales.length - 1]);\r\n    }\r\n\r\n    function removeLastSaleOnlyNotActivated() public onlyOwner {\r\n        require(!sales[sales.length - 1].activated());\r\n        delete sales[sales.length - 1];\r\n    }\r\n\r\n    function closeAllSales() public onlyOwner {\r\n        for (uint i = 0; i < sales.length; i++) {\r\n            sales[i].close();\r\n        }\r\n    }\r\n\r\n    function setGlobalMultisigWallet(address _multisigWallet) public onlyOwner {\r\n        multisigWallet = _multisigWallet;\r\n        for (uint i = 0; i < sales.length; i++) {\r\n            if (!sales[i].closed()) {\r\n                sales[i].setMultisigWallet(multisigWallet);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTotalCollected() public constant returns(uint256) {\r\n        uint256 _totalCollected = 0;\r\n        for (uint i = 0; i < sales.length; i++) {\r\n            _totalCollected = _totalCollected + sales[i].collected();\r\n        }\r\n        return _totalCollected;\r\n    }\r\n\r\n    function getCurrentSale() public constant returns(address) {\r\n        return token.saleAgent();\r\n    }\r\n\r\n    function deploy() public onlyOwner {\r\n        require(!isDeployed);\r\n        isDeployed = true;\r\n\r\n        softCap = 6000 ether;\r\n        hardCap = 25000 ether;\r\n        maxActivatedSalesTotalCount = 5;\r\n\r\n        setGlobalMultisigWallet(0xcC6E23E740FBc50e242B6B90f0BcaF64b83BF813);\r\n\r\n        token = new DLCToken();\r\n        token.setTotalSupply(1000000000 * 1 ether);\r\n        token.setFoundersTokensPercent(15);\r\n        token.setBountyTokensPercent(1);\r\n        token.setDevelopmentAuditPromotionTokensPercent(10);\r\n        token.setPriceOfToken(0.00013749 * 1 ether);\r\n        token.setToSaleWallet(0xf9D1398a6e2c856fab73B5baaD13D125EDe30006);\r\n        token.setBountyWallet(0xFc6248b06e65686C9aDC5f4F758bBd716BaE80e1);\r\n        token.setFoundersWallet(0xf54315F87480f87Bfa2fCe97aCA036fd90223516);\r\n        token.setDevelopmentAuditPromotionWallet(0x34EEA5f12DeF816Bd86F682eDc6010500dd51976);\r\n        token.transferOwnership(owner);\r\n        token.init();\r\n\r\n        createSale({\r\n            _bonusPreset: 'privatesale',\r\n            _startTime: 1522342800, // 29.03.2018\r\n           // _startTime: 1523318400, // 2018-04-10\r\n            _endTime:   1524614400, // 2018-04-25\r\n            _tokensLimit: 80000000 * 1 ether,\r\n            _minimalPrice: 1 ether\r\n            });\r\n        activateLastSale();\r\n\r\n        createSale({\r\n            _bonusPreset: 'presale',\r\n            _startTime: 1525910400, // 2018-05-10\r\n            _endTime:   1527206400, // 2018-05-25\r\n            _tokensLimit: 75000000 * 1 ether,\r\n            _minimalPrice: 0.03 ether\r\n            });\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"activatedSalesTotalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentSale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxActivatedSalesTotalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeAllSales\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_multisigWallet\",\"type\":\"address\"}],\"name\":\"setGlobalMultisigWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sales\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDeployed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateLastSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonusPreset\",\"type\":\"string\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_tokensLimit\",\"type\":\"uint256\"},{\"name\":\"_minimalPrice\",\"type\":\"uint256\"}],\"name\":\"createSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeLastSaleOnlyNotActivated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"a\",\"type\":\"address\"}],\"name\":\"OwnerLog\",\"type\":\"event\"}]","ContractName":"DoubleLandICO_TEST","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bbc5312fd4f619ec5187a19a82c4996b2f3e9fd0c13c0d6c156b3918757f960c"}]}