{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary NumericSequence\r\n{\r\n    function sumOfN(uint basePrice, uint pricePerLevel, uint owned, uint count) internal pure returns (uint price)\r\n    {\r\n        require(count > 0);\r\n        \r\n        price = 0;\r\n        price += (basePrice + pricePerLevel * owned) * count;\r\n        price += pricePerLevel * ((count-1) * count) / 2;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n//-----------------------------------------------------------------------\r\ncontract RigIdle is ERC20  {\r\n    using NumericSequence for uint;\r\n\r\n    struct MinerData \r\n    {\r\n        uint[9]   rigs; // rig types and their upgrades\r\n        uint8[3]  hasUpgrade;\r\n        uint      money;\r\n        uint      lastUpdateTime;\r\n        uint      premamentMineBonusPct;\r\n        uint      unclaimedPot;\r\n        uint      lastPotShare;\r\n    }\r\n    \r\n    struct RigData\r\n    {\r\n        uint basePrice;\r\n        uint baseOutput;\r\n        uint pricePerLevel;\r\n        uint priceInETH;\r\n        uint limit;\r\n    }\r\n    \r\n    struct BoostData\r\n    {\r\n        uint percentBonus;\r\n        uint priceInWEI;\r\n    }\r\n    \r\n    struct PVPData\r\n    {\r\n        uint[6] troops;\r\n        uint immunityTime;\r\n        uint exhaustTime;\r\n    }\r\n    \r\n    struct TroopData\r\n    {\r\n        uint attackPower;\r\n        uint defensePower;\r\n        uint priceGold;\r\n        uint priceETH;\r\n    }\r\n    \r\n    uint8 private constant NUMBER_OF_RIG_TYPES = 9;\r\n    RigData[9]  private rigData;\r\n    \r\n    uint8 private constant NUMBER_OF_UPGRADES = 3;\r\n    BoostData[3] private boostData;\r\n    \r\n    uint8 private constant NUMBER_OF_TROOPS = 6;\r\n    uint8 private constant ATTACKER_START_IDX = 0;\r\n    uint8 private constant ATTACKER_END_IDX = 3;\r\n    uint8 private constant DEFENDER_START_IDX = 3;\r\n    uint8 private constant DEFENDER_END_IDX = 6;\r\n    TroopData[6] private troopData;\r\n\r\n    // honey pot variables\r\n    uint private honeyPotAmount;\r\n    uint private honeyPotSharePct;\r\n    uint private jackPot;\r\n    uint private devFund;\r\n    uint private nextPotDistributionTime;\r\n    \r\n    //booster info\r\n    uint public constant NUMBER_OF_BOOSTERS = 5;\r\n    uint       boosterIndex;\r\n    uint       nextBoosterPrice;\r\n    address[5] boosterHolders;\r\n    \r\n    mapping(address => MinerData) private miners;\r\n    mapping(address => PVPData)   private pvpMap;\r\n    mapping(uint => address)  private indexes;\r\n    uint private topindex;\r\n    \r\n    address public owner;\r\n    \r\n    // ERC20 functionality\r\n    mapping(address => mapping(address => uint256)) private allowed;\r\n    string public constant name  = \"RigWarsIdle\";\r\n    string public constant symbol = \"RIG\";\r\n    uint8 public constant decimals = 8;\r\n    uint256 private estimatedSupply;\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function RigIdle() public {\r\n        owner = msg.sender;\r\n        \r\n        //                   price,           prod.     upgrade,        priceETH, limit\r\n        rigData[0] = RigData(128,             1,        64,              0,          64);\r\n        rigData[1] = RigData(1024,            64,       512,             0,          64);\r\n        rigData[2] = RigData(204800,          1024,     102400,          0,          128);\r\n        rigData[3] = RigData(25600000,        8192,     12800000,        0,          128);\r\n        rigData[4] = RigData(30000000000,     65536,    30000000000,     0.01 ether, 256);\r\n        rigData[5] = RigData(30000000000,     100000,   10000000000,     0,          256);\r\n        rigData[6] = RigData(300000000000,    500000,   100000000000,    0,          256);\r\n        rigData[7] = RigData(50000000000000,  3000000,  12500000000000,  0.1 ether,  256);\r\n        rigData[8] = RigData(100000000000000, 30000000, 50000000000000,  0,          256);\r\n        \r\n        boostData[0] = BoostData(30,  0.01 ether);\r\n        boostData[1] = BoostData(50,  0.1 ether);\r\n        boostData[2] = BoostData(100, 1 ether);\r\n        \r\n        topindex = 0;\r\n        honeyPotAmount = 0;\r\n        devFund = 0;\r\n        jackPot = 0;\r\n        nextPotDistributionTime = block.timestamp;\r\n        // default 90% honeypot, 8% for DevFund + transaction fees, 2% safe deposit\r\n        honeyPotSharePct = 90;\r\n        \r\n        // has to be set to a value\r\n        boosterHolders[0] = owner;\r\n        boosterHolders[1] = owner;\r\n        boosterHolders[2] = owner;\r\n        boosterHolders[3] = owner;\r\n        boosterHolders[4] = owner;\r\n        \r\n        boosterIndex = 0;\r\n        nextBoosterPrice = 0.1 ether;\r\n        \r\n        //pvp\r\n        troopData[0] = TroopData(10,     0,      100000,   0);\r\n        troopData[1] = TroopData(1000,   0,      80000000, 0);\r\n        troopData[2] = TroopData(100000, 0,      0,        0.01 ether);\r\n        troopData[3] = TroopData(0,      15,     100000,   0);\r\n        troopData[4] = TroopData(0,      1500,   80000000, 0);\r\n        troopData[5] = TroopData(0,      150000, 0,        0.01 ether);\r\n        \r\n        estimatedSupply = 80000000;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // Data access functions\r\n    //--------------------------------------------------------------------------\r\n    function GetNumberOfRigs() public pure returns (uint8 rigNum)\r\n    {\r\n        rigNum = NUMBER_OF_RIG_TYPES;\r\n    }\r\n    \r\n    function GetRigData(uint8 rigIdx) public constant returns (uint price, uint production, uint upgrade, uint limit, uint priceETH)\r\n    {\r\n        require(rigIdx < NUMBER_OF_RIG_TYPES);\r\n        price =      rigData[rigIdx].basePrice;\r\n        production = rigData[rigIdx].baseOutput;\r\n        upgrade =    rigData[rigIdx].pricePerLevel;\r\n        limit =      rigData[rigIdx].limit;\r\n        priceETH =   rigData[rigIdx].priceInETH;\r\n    }\r\n    \r\n    function GetMinerData(address minerAddr) public constant returns \r\n        (uint money, uint lastupdate, uint prodPerSec, \r\n         uint[9] rigs, uint[3] upgrades, uint unclaimedPot, uint lastPot, bool hasBooster, uint unconfirmedMoney)\r\n    {\r\n        uint8 i = 0;\r\n        \r\n        money = miners[minerAddr].money;\r\n        lastupdate = miners[minerAddr].lastUpdateTime;\r\n        prodPerSec = GetProductionPerSecond(minerAddr);\r\n        \r\n        for(i = 0; i < NUMBER_OF_RIG_TYPES; ++i)\r\n        {\r\n            rigs[i] = miners[minerAddr].rigs[i];\r\n        }\r\n        \r\n        for(i = 0; i < NUMBER_OF_UPGRADES; ++i)\r\n        {\r\n            upgrades[i] = miners[minerAddr].hasUpgrade[i];\r\n        }\r\n        \r\n        unclaimedPot = miners[minerAddr].unclaimedPot;\r\n        lastPot = miners[minerAddr].lastPotShare;\r\n        hasBooster = HasBooster(minerAddr);\r\n        \r\n        unconfirmedMoney = money + (prodPerSec * (now - lastupdate));\r\n    }\r\n    \r\n    function GetTotalMinerCount() public constant returns (uint count)\r\n    {\r\n        count = topindex;\r\n    }\r\n    \r\n    function GetMinerAt(uint idx) public constant returns (address minerAddr)\r\n    {\r\n        require(idx < topindex);\r\n        minerAddr = indexes[idx];\r\n    }\r\n    \r\n    function GetPriceOfRigs(uint rigIdx, uint count, uint owned) public constant returns (uint price)\r\n    {\r\n        require(rigIdx < NUMBER_OF_RIG_TYPES);\r\n        require(count > 0);\r\n        price = NumericSequence.sumOfN(rigData[rigIdx].basePrice, rigData[rigIdx].pricePerLevel, owned, count); \r\n    }\r\n    \r\n    function GetPotInfo() public constant returns (uint _honeyPotAmount, uint _devFunds, uint _jackPot, uint _nextDistributionTime)\r\n    {\r\n        _honeyPotAmount = honeyPotAmount;\r\n        _devFunds = devFund;\r\n        _jackPot = jackPot;\r\n        _nextDistributionTime = nextPotDistributionTime;\r\n    }\r\n    \r\n    function GetProductionPerSecond(address minerAddr) public constant returns (uint personalProduction)\r\n    {\r\n        MinerData storage m = miners[minerAddr];\r\n        \r\n        personalProduction = 0;\r\n        uint productionSpeed = 100 + m.premamentMineBonusPct;\r\n        \r\n        if(HasBooster(minerAddr)) // 500% bonus\r\n            productionSpeed += 500;\r\n        \r\n        for(uint8 j = 0; j < NUMBER_OF_RIG_TYPES; ++j)\r\n        {\r\n            personalProduction += m.rigs[j] * rigData[j].baseOutput;\r\n        }\r\n        \r\n        personalProduction = personalProduction * productionSpeed / 100;\r\n    }\r\n    \r\n    function GetGlobalProduction() public constant returns (uint globalMoney, uint globalHashRate)\r\n    {\r\n        globalMoney = 0;\r\n        globalHashRate = 0;\r\n        uint i = 0;\r\n        for(i = 0; i < topindex; ++i)\r\n        {\r\n            MinerData storage m = miners[indexes[i]];\r\n            globalMoney += m.money;\r\n            globalHashRate += GetProductionPerSecond(indexes[i]);\r\n        }\r\n    }\r\n    \r\n    function GetBoosterData() public constant returns (address[5] _boosterHolders, uint currentPrice, uint currentIndex)\r\n    {\r\n        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\r\n        {\r\n            _boosterHolders[i] = boosterHolders[i];\r\n        }\r\n        currentPrice = nextBoosterPrice;\r\n        currentIndex = boosterIndex;\r\n    }\r\n    \r\n    function HasBooster(address addr) public constant returns (bool hasBoost)\r\n    { \r\n        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\r\n        {\r\n           if(boosterHolders[i] == addr)\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function GetPVPData(address addr) public constant returns (uint attackpower, uint defensepower, uint immunityTime, uint exhaustTime,\r\n    uint[6] troops)\r\n    {\r\n        PVPData storage a = pvpMap[addr];\r\n            \r\n        immunityTime = a.immunityTime;\r\n        exhaustTime = a.exhaustTime;\r\n        \r\n        attackpower = 0;\r\n        defensepower = 0;\r\n        for(uint i = 0; i < NUMBER_OF_TROOPS; ++i)\r\n        {\r\n            attackpower  += a.troops[i] * troopData[i].attackPower;\r\n            defensepower += a.troops[i] * troopData[i].defensePower;\r\n            \r\n            troops[i] = a.troops[i];\r\n        }\r\n    }\r\n    \r\n    function GetPriceOfTroops(uint idx, uint count, uint owned) public constant returns (uint price, uint priceETH)\r\n    {\r\n        require(idx < NUMBER_OF_TROOPS);\r\n        require(count > 0);\r\n        price = NumericSequence.sumOfN(troopData[idx].priceGold, troopData[idx].priceGold, owned, count);\r\n        priceETH = troopData[idx].priceETH * count;\r\n    }\r\n    \r\n    // -------------------------------------------------------------------------\r\n    // RigWars game handler functions\r\n    // -------------------------------------------------------------------------\r\n    function StartNewMiner() public\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime == 0);\r\n        \r\n        miners[msg.sender].lastUpdateTime = block.timestamp;\r\n        miners[msg.sender].money = 0;\r\n        miners[msg.sender].rigs[0] = 1;\r\n        miners[msg.sender].unclaimedPot = 0;\r\n        miners[msg.sender].lastPotShare = 0;\r\n        \r\n        pvpMap[msg.sender].troops[0] = 0;\r\n        pvpMap[msg.sender].troops[1] = 0;\r\n        pvpMap[msg.sender].troops[2] = 0;\r\n        pvpMap[msg.sender].troops[3] = 0;\r\n        pvpMap[msg.sender].troops[4] = 0;\r\n        pvpMap[msg.sender].troops[5] = 0;\r\n        pvpMap[msg.sender].immunityTime = block.timestamp + 28800;\r\n        pvpMap[msg.sender].exhaustTime  = block.timestamp;\r\n        \r\n        indexes[topindex] = msg.sender;\r\n        ++topindex;\r\n    }\r\n    \r\n    function UpgradeRig(uint8 rigIdx, uint count) public\r\n    {\r\n        require(rigIdx < NUMBER_OF_RIG_TYPES);\r\n        require(count > 0);\r\n        \r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        require(rigData[rigIdx].limit >= (m.rigs[rigIdx] + count));\r\n        \r\n        UpdateMoney();\r\n     \r\n        // the base of geometrical sequence\r\n        uint price = NumericSequence.sumOfN(rigData[rigIdx].basePrice, rigData[rigIdx].pricePerLevel, m.rigs[rigIdx], count); \r\n       \r\n        require(m.money >= price);\r\n        \r\n        m.rigs[rigIdx] = m.rigs[rigIdx] + count;\r\n        m.money -= price;\r\n    }\r\n    \r\n    function UpgradeRigETH(uint8 rigIdx, uint count) public payable\r\n    {\r\n        require(rigIdx < NUMBER_OF_RIG_TYPES);\r\n        require(count > 0);\r\n        require(rigData[rigIdx].priceInETH > 0);\r\n        \r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        require(rigData[rigIdx].limit >= (m.rigs[rigIdx] + count));\r\n      \r\n        uint price = rigData[rigIdx].priceInETH * count; \r\n       \r\n        require(msg.value >= price);\r\n        \r\n        BuyHandler(msg.value);\r\n        \r\n        UpdateMoney();\r\n        \r\n        m.rigs[rigIdx] = m.rigs[rigIdx] + count;\r\n    }\r\n    \r\n    function UpdateMoney() public\r\n    {\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        \r\n        MinerData storage m = miners[msg.sender];\r\n        uint diff = block.timestamp - m.lastUpdateTime;\r\n        uint revenue = GetProductionPerSecond(msg.sender);\r\n   \r\n        m.lastUpdateTime = block.timestamp;\r\n        if(revenue > 0)\r\n        {\r\n            revenue *= diff;\r\n            \r\n            m.money += revenue;\r\n        }\r\n    }\r\n    \r\n    function UpdateMoneyAt(address addr) internal\r\n    {\r\n        require(miners[addr].lastUpdateTime != 0);\r\n        \r\n        MinerData storage m = miners[addr];\r\n        uint diff = block.timestamp - m.lastUpdateTime;\r\n        uint revenue = GetProductionPerSecond(addr);\r\n   \r\n        m.lastUpdateTime = block.timestamp;\r\n        if(revenue > 0)\r\n        {\r\n            revenue *= diff;\r\n            \r\n            m.money += revenue;\r\n        }\r\n    }\r\n    \r\n    function BuyUpgrade(uint idx) public payable\r\n    {\r\n        require(idx < NUMBER_OF_UPGRADES);\r\n        require(msg.value >= boostData[idx].priceInWEI);\r\n        require(miners[msg.sender].hasUpgrade[idx] == 0);\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        \r\n        BuyHandler(msg.value);\r\n        \r\n        UpdateMoney();\r\n        \r\n        miners[msg.sender].hasUpgrade[idx] = 1;\r\n        miners[msg.sender].premamentMineBonusPct +=  boostData[idx].percentBonus;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // BOOSTER handlers\r\n    //--------------------------------------------------------------------------\r\n    function BuyBooster() public payable \r\n    {\r\n        require(msg.value >= nextBoosterPrice);\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        \r\n        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\r\n            if(boosterHolders[i] == msg.sender)\r\n                revert();\r\n                \r\n        address beneficiary = boosterHolders[boosterIndex];\r\n        \r\n        MinerData storage m = miners[beneficiary];\r\n        \r\n        // 95% goes to the owner (21% interest after 5 buys)\r\n        m.unclaimedPot += nextBoosterPrice * 95 / 100;\r\n        \r\n        // 5% to the pot\r\n        BuyHandler((nextBoosterPrice / 20));\r\n        \r\n        // increase price by 5%\r\n        nextBoosterPrice += nextBoosterPrice / 20;\r\n        \r\n        UpdateMoney();\r\n        UpdateMoneyAt(beneficiary);\r\n        \r\n        // transfer ownership    \r\n        boosterHolders[boosterIndex] = msg.sender;\r\n        \r\n        // increase booster index\r\n        boosterIndex += 1;\r\n        if(boosterIndex >= 5)\r\n            boosterIndex = 0;\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // PVP handler\r\n    //--------------------------------------------------------------------------\r\n    // 0 for attacker 1 for defender\r\n    function BuyTroop(uint idx, uint count) public payable\r\n    {\r\n        require(idx < NUMBER_OF_TROOPS);\r\n        require(count > 0);\r\n        require(count <= 1000);\r\n        \r\n        PVPData storage pvp = pvpMap[msg.sender];\r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        uint owned = pvp.troops[idx];\r\n        \r\n        uint priceGold = NumericSequence.sumOfN(troopData[idx].priceGold, troopData[idx].priceGold, owned, count); \r\n        uint priceETH = troopData[idx].priceETH * count;\r\n        \r\n        UpdateMoney();\r\n        \r\n        require(m.money >= priceGold);\r\n        require(msg.value >= priceETH);\r\n        \r\n        if(priceGold > 0)\r\n            m.money -= priceGold;\r\n         \r\n        if(msg.value > 0)\r\n            BuyHandler(msg.value);\r\n        \r\n        pvp.troops[idx] += count;\r\n    }\r\n    \r\n    function Attack(address defenderAddr) public\r\n    {\r\n        require(msg.sender != defenderAddr);\r\n        require(miners[msg.sender].lastUpdateTime != 0);\r\n        require(miners[defenderAddr].lastUpdateTime != 0);\r\n        \r\n        PVPData storage attacker = pvpMap[msg.sender];\r\n        PVPData storage defender = pvpMap[defenderAddr];\r\n        uint i = 0;\r\n        uint count = 0;\r\n        \r\n        require(block.timestamp > attacker.exhaustTime);\r\n        require(block.timestamp > defender.immunityTime);\r\n        \r\n        // the aggressor loses immunity\r\n        if(attacker.immunityTime > block.timestamp)\r\n            attacker.immunityTime = block.timestamp - 1;\r\n            \r\n        attacker.exhaustTime = block.timestamp + 7200;\r\n        \r\n        uint attackpower = 0;\r\n        uint defensepower = 0;\r\n        for(i = 0; i < NUMBER_OF_TROOPS; ++i)\r\n        {\r\n            attackpower  += attacker.troops[i] * troopData[i].attackPower;\r\n            defensepower += defender.troops[i] * troopData[i].defensePower;\r\n        }\r\n        \r\n        if(attackpower > defensepower)\r\n        {\r\n            if(defender.immunityTime < block.timestamp + 14400)\r\n                defender.immunityTime = block.timestamp + 14400;\r\n            \r\n            UpdateMoneyAt(defenderAddr);\r\n            \r\n            MinerData storage m = miners[defenderAddr];\r\n            MinerData storage m2 = miners[msg.sender];\r\n            uint moneyStolen = m.money / 2;\r\n         \r\n            for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)\r\n            {\r\n                defender.troops[i] = 0;\r\n            }\r\n            \r\n            for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)\r\n            {\r\n                if(troopData[i].attackPower > 0)\r\n                {\r\n                    count = attacker.troops[i];\r\n                    \r\n                    // if the troops overpower the total defense power only a fraction is lost\r\n                    if((count * troopData[i].attackPower) > defensepower)\r\n                        count = defensepower / troopData[i].attackPower;\r\n                        \r\n                    attacker.troops[i] -= count;\r\n                    defensepower -= count * troopData[i].attackPower;\r\n                }\r\n            }\r\n            \r\n            m.money -= moneyStolen;\r\n            m2.money += moneyStolen;\r\n        } else\r\n        {\r\n            for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)\r\n            {\r\n                attacker.troops[i] = 0;\r\n            }\r\n            \r\n            for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)\r\n            {\r\n                if(troopData[i].defensePower > 0)\r\n                {\r\n                    count = defender.troops[i];\r\n                    \r\n                    // if the troops overpower the total defense power only a fraction is lost\r\n                    if((count * troopData[i].defensePower) > attackpower)\r\n                        count = attackpower / troopData[i].defensePower;\r\n                        \r\n                    defender.troops[i] -= count;\r\n                    attackpower -= count * troopData[i].defensePower;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // ETH handler functions\r\n    //--------------------------------------------------------------------------\r\n    function BuyHandler(uint amount) public payable\r\n    {\r\n        // add 2% to jakcpot\r\n        // add 90% (default) to honeyPot\r\n        honeyPotAmount += (amount * honeyPotSharePct) / 100;\r\n        jackPot += amount / 50;\r\n        // default 100 - (90+2) = 8%\r\n        devFund += (amount * (100-(honeyPotSharePct+2))) / 100;\r\n    }\r\n    \r\n    function WithdrawPotShare() public\r\n    {\r\n        MinerData storage m = miners[msg.sender];\r\n        \r\n        require(m.unclaimedPot > 0);\r\n        \r\n        uint amntToSend = m.unclaimedPot;\r\n        m.unclaimedPot = 0;\r\n        \r\n        if(msg.sender.send(amntToSend))\r\n        {\r\n            m.unclaimedPot = 0;\r\n        }\r\n    }\r\n    \r\n    function WithdrawDevFunds(uint amount) public\r\n    {\r\n        require(msg.sender == owner);\r\n        \r\n        if(amount == 0)\r\n        {\r\n            if(owner.send(devFund))\r\n            {\r\n                devFund = 0;\r\n            }\r\n        } else\r\n        {\r\n            // should never be used! this is only in case of emergency\r\n            // if some error happens with distribution someone has to access\r\n            // and distribute the funds manually\r\n            owner.transfer(amount);\r\n        }\r\n    }\r\n    \r\n    function SnapshotAndDistributePot() public\r\n    {\r\n        require(honeyPotAmount > 0);\r\n        require(gasleft() >= 1000000);\r\n        require(nextPotDistributionTime <= block.timestamp);\r\n        \r\n        uint globalMoney = 1;\r\n        uint i = 0;\r\n        for(i = 0; i < topindex; ++i)\r\n        {\r\n            globalMoney += miners[indexes[i]].money;\r\n        }\r\n        \r\n        estimatedSupply = globalMoney;\r\n        \r\n        uint remainingPot = honeyPotAmount;\r\n        \r\n        // 20% of the total pot\r\n        uint potFraction = honeyPotAmount / 5;\r\n                \r\n        honeyPotAmount -= potFraction;\r\n        \r\n        potFraction /= 10000;\r\n        \r\n        for(i = 0; i < topindex; ++i)\r\n        {\r\n            // lowest limit of pot share is 0.01%\r\n            MinerData storage m = miners[indexes[i]];\r\n            uint share = (m.money * 10000) / globalMoney;\r\n            if(share > 0)\r\n            {\r\n                uint newPot = potFraction * share;\r\n                \r\n                if(newPot <= remainingPot)\r\n                {\r\n                    m.unclaimedPot += newPot;\r\n                    m.lastPotShare = newPot;\r\n                    remainingPot   -= newPot;\r\n                }\r\n            }\r\n        }\r\n        \r\n        nextPotDistributionTime = block.timestamp + 86400;\r\n        \r\n        MinerData storage jakpotWinner = miners[msg.sender];\r\n        jakpotWinner.unclaimedPot += jackPot;\r\n        jackPot = 0;\r\n    }\r\n    \r\n    // fallback payment to pot\r\n    function() public payable {\r\n    }\r\n    \r\n    //--------------------------------------------------------------------------\r\n    // ERC20 support\r\n    //--------------------------------------------------------------------------\r\n    function totalSupply() public constant returns(uint256) {\r\n        return estimatedSupply;\r\n    }\r\n    \r\n    function balanceOf(address miner) public constant returns(uint256) {\r\n        return miners[miner].money;\r\n    }\r\n    \r\n     function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        require(amount <= miners[msg.sender].money);\r\n        require(miners[recipient].lastUpdateTime != 0);\r\n        \r\n        miners[msg.sender].money -= amount * (10**uint(decimals));\r\n        miners[recipient].money += amount * (10**uint(decimals));\r\n        \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address miner, address recipient, uint256 amount) public returns (bool) {\r\n        require(amount <= allowed[miner][msg.sender] && amount <= balanceOf(miner));\r\n        require(miners[recipient].lastUpdateTime != 0);\r\n        \r\n        miners[miner].money -= amount * (10**uint(decimals));\r\n        miners[recipient].money += amount * (10**uint(decimals));\r\n        allowed[miner][msg.sender] -= amount * (10**uint(decimals));\r\n        \r\n        emit Transfer(miner, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address approvee, uint256 amount) public returns (bool){\r\n        allowed[msg.sender][approvee] = amount * (10**uint(decimals));\r\n        emit Approval(msg.sender, approvee, amount);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address miner, address approvee) public constant returns(uint256){\r\n        return allowed[miner][approvee];\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"BuyUpgrade\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"name\":\"GetProductionPerSecond\",\"outputs\":[{\"name\":\"personalProduction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvee\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rigIdx\",\"type\":\"uint8\"}],\"name\":\"GetRigData\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"production\",\"type\":\"uint256\"},{\"name\":\"upgrade\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"},{\"name\":\"priceETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"UpdateMoney\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawPotShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rigIdx\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"owned\",\"type\":\"uint256\"}],\"name\":\"GetPriceOfRigs\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetGlobalProduction\",\"outputs\":[{\"name\":\"globalMoney\",\"type\":\"uint256\"},{\"name\":\"globalHashRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"GetPVPData\",\"outputs\":[{\"name\":\"attackpower\",\"type\":\"uint256\"},{\"name\":\"defensepower\",\"type\":\"uint256\"},{\"name\":\"immunityTime\",\"type\":\"uint256\"},{\"name\":\"exhaustTime\",\"type\":\"uint256\"},{\"name\":\"troops\",\"type\":\"uint256[6]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetPotInfo\",\"outputs\":[{\"name\":\"_honeyPotAmount\",\"type\":\"uint256\"},{\"name\":\"_devFunds\",\"type\":\"uint256\"},{\"name\":\"_jackPot\",\"type\":\"uint256\"},{\"name\":\"_nextDistributionTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rigIdx\",\"type\":\"uint8\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"UpgradeRig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"SnapshotAndDistributePot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"owned\",\"type\":\"uint256\"}],\"name\":\"GetPriceOfTroops\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"priceETH\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetTotalMinerCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyHandler\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"HasBooster\",\"outputs\":[{\"name\":\"hasBoost\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetNumberOfRigs\",\"outputs\":[{\"name\":\"rigNum\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawDevFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"BuyTroop\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rigIdx\",\"type\":\"uint8\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"UpgradeRigETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"defenderAddr\",\"type\":\"address\"}],\"name\":\"Attack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetBoosterData\",\"outputs\":[{\"name\":\"_boosterHolders\",\"type\":\"address[5]\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"currentIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"name\":\"GetMinerData\",\"outputs\":[{\"name\":\"money\",\"type\":\"uint256\"},{\"name\":\"lastupdate\",\"type\":\"uint256\"},{\"name\":\"prodPerSec\",\"type\":\"uint256\"},{\"name\":\"rigs\",\"type\":\"uint256[9]\"},{\"name\":\"upgrades\",\"type\":\"uint256[3]\"},{\"name\":\"unclaimedPot\",\"type\":\"uint256\"},{\"name\":\"lastPot\",\"type\":\"uint256\"},{\"name\":\"hasBooster\",\"type\":\"bool\"},{\"name\":\"unconfirmedMoney\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"GetMinerAt\",\"outputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"miner\",\"type\":\"address\"},{\"name\":\"approvee\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NUMBER_OF_BOOSTERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"StartNewMiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"BuyBooster\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RigIdle","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a8b82728c7eb6159a835444f77839d32451a92df624c644f1b1dc1e99bf6b870"}]}